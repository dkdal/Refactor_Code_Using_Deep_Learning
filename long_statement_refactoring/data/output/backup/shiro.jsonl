{"Refactored Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.shiro.cdi;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport javax.ejb.Stateless;\nimport javax.enterprise.context.SessionScoped;\nimport javax.enterprise.inject.spi.AnnotatedType;\n\nimport org.apache.shiro.authz.annotation.RequiresAuthentication;\nimport org.apache.shiro.authz.annotation.RequiresGuest;\nimport org.apache.shiro.authz.annotation.RequiresPermissions;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.Mock;\n\nimport static org.mockito.Mockito.when;\n\nimport org.mockito.junit.jupiter.MockitoExtension;\n\n/**\n * Annotated Type Wrapper tests\n */\n@ExtendWith(MockitoExtension.class)\nclass AnnotatedTypeWrapperTest {\n    @Mock\n    private AnnotatedType<Void> annotatedType;\n\n    @RequiresAuthentication\n    @RequiresGuest\n    @RequiresPermissions(\"hello\")\n    private final class Annotated {\n    }\n\n    @ShiroSecureAnnotation\n    private final class ShiroSecureAnnotated {\n    }\n\n    @Stateless\n    private final class StatelessAnnotated {\n    }\n\n    @SessionScoped\n    @SuppressWarnings(\"serial\")\n    private static final class SessionScopedAnnotated implements Serializable {\n    }\n\n    @Test\n    void noAnnotations() {\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType);\n        assertEquals(0, wrapper.getAnnotations().size());\n    }\n\n    @Test\n    void noAdditionalAnnotations() {\n        initializeStubs();\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType);\n        assertEquals(3, wrapper.getAnnotations().size());\n    }\n\n    @Test\n    @SuppressWarnings(\"MagicNumber\")\n    void twoAdditionalAnnotations() {\n        initializeStubs();\n        Annotation shiroSecureAnnotation = getAnnotation(ShiroSecureAnnotated.class, ShiroSecureAnnotation.class);\n        Annotation statelessAnnotation = getAnnotation(StatelessAnnotated.class, Stateless.class);\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType, shiroSecureAnnotation, statelessAnnotation);\n        assertEquals(5, wrapper.getAnnotations().size());\n        assertTrue(wrapper.isAnnotationPresent(ShiroSecureAnnotation.class));\n        assertTrue(wrapper.isAnnotationPresent(Stateless.class));\n        assertTrue(wrapper.isAnnotationPresent(RequiresAuthentication.class));\n        assertTrue(wrapper.isAnnotationPresent(RequiresGuest.class));\n        assertTrue(wrapper.isAnnotationPresent(RequiresPermissions.class));\n    }\n\n    @Test\n    void removeAnnotations() {\n        initializeStubs();\n        Set<Annotation> sessionScopeAnnoationsSet = Set.of(getAnnotation(SessionScopedAnnotated.class, SessionScoped.class));\n        Set<Annotation> requiresGuestAnnoationsSet = Set.of(getAnnotation(Annotated.class, RequiresGuest.class));\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType, true, sessionScopeAnnoationsSet, requiresGuestAnnoationsSet);\n        assertEquals(3, wrapper.getAnnotations().size());\n        assertFalse(wrapper.isAnnotationPresent(RequiresGuest.class));\n        assertTrue(wrapper.isAnnotationPresent(SessionScoped.class));\n    }\n\n    @Test\n    void badLambdaArgument() {\n        assertThrows(IllegalArgumentException.class,\n                () -> new AnnotatedTypeWrapper<>(annotatedType, true,\n                        Set.of(() -> SessionScoped.class),\n                        Set.of(() -> RequiresGuest.class)));\n        assertThrows(IllegalArgumentException.class,\n                () -> new AnnotatedTypeWrapper<>(annotatedType, true,\n                        Set.of(() -> RequiresGuest.class),\n                        Set.of()));\n        assertThrows(IllegalArgumentException.class,\n                () -> new AnnotatedTypeWrapper<>(annotatedType, true,\n                        Set.of(),\n                        Set.of(() -> RequiresGuest.class)));\n    }\n\n    @Test\n    void overriddenAnnotation() {\n        initializeStubs();\n        when(annotatedType.getJavaClass()).thenReturn(Void.class);\n        assertEquals(3, annotatedType.getAnnotations().size());\n        Annotation shiroSecureAnnoations = getAnnotation(ShiroSecureAnnotated.class, ShiroSecureAnnotation.class);\n        Annotation statelessAnnoations = getAnnotation(StatelessAnnotated.class, Stateless.class);\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType, false,\n                Set.of(shiroSecureAnnoations, statelessAnnoations),\n                Set.of());\n        assertEquals(2, wrapper.getAnnotations().size());\n        assertTrue(wrapper.isAnnotationPresent(ShiroSecureAnnotation.class));\n        assertTrue(wrapper.isAnnotationPresent(Stateless.class));\n        assertEquals(Void.class, wrapper.getJavaClass());\n    }\n\n    @Test\n    void decreaseAnnotationsToZero() {\n        initializeStubs();\n        assertEquals(3, annotatedType.getAnnotations().size());\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType, false, Set.of(), Set.of());\n        assertEquals(0, wrapper.getAnnotations().size());\n    }\n\n    private void initializeStubs() {\n        when(annotatedType.getAnnotations()).thenReturn(Stream.of(Annotated.class.getDeclaredAnnotations())\n                .collect(Collectors.toSet()));\n    }\n\n    private Annotation getAnnotation(Class<?> annotatedClass, Class<?> annotation) {\n        return Arrays.stream(annotatedClass.getDeclaredAnnotations())\n                .filter(a -> a.annotationType().equals(annotation))\n                .findFirst()\n                .orElse(null);\n    }\n}\n","Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.shiro.cdi;\n\nimport java.io.Serializable;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport javax.ejb.Stateless;\nimport javax.enterprise.context.SessionScoped;\nimport javax.enterprise.inject.spi.AnnotatedType;\n\nimport org.apache.shiro.authz.annotation.RequiresAuthentication;\nimport org.apache.shiro.authz.annotation.RequiresGuest;\nimport org.apache.shiro.authz.annotation.RequiresPermissions;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.Mock;\n\nimport static org.mockito.Mockito.when;\n\nimport org.mockito.junit.jupiter.MockitoExtension;\n\n/**\n * Annotated Type Wrapper tests\n */\n@ExtendWith(MockitoExtension.class)\nclass AnnotatedTypeWrapperTest {\n    @Mock\n    private AnnotatedType<Void> annotatedType;\n\n    @RequiresAuthentication\n    @RequiresGuest\n    @RequiresPermissions(\"hello\")\n    private final class Annotated {\n    }\n\n    @ShiroSecureAnnotation\n    private final class ShiroSecureAnnotated {\n    }\n\n    @Stateless\n    private final class StatelessAnnotated {\n    }\n\n    @SessionScoped\n    @SuppressWarnings(\"serial\")\n    private static final class SessionScopedAnnotated implements Serializable {\n    }\n\n    @Test\n    void noAnnotations() {\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType);\n        assertEquals(0, wrapper.getAnnotations().size());\n    }\n\n    @Test\n    void noAdditionalAnnotations() {\n        initializeStubs();\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType);\n        assertEquals(3, wrapper.getAnnotations().size());\n    }\n\n    @Test\n    @SuppressWarnings(\"MagicNumber\")\n    void twoAdditionalAnnotations() {\n        initializeStubs();\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType,\n                ShiroSecureAnnotated.class.getDeclaredAnnotations()[0],\n                StatelessAnnotated.class.getDeclaredAnnotations()[0]);\n        assertEquals(5, wrapper.getAnnotations().size());\n        assertTrue(wrapper.isAnnotationPresent(ShiroSecureAnnotated.class\n                .getDeclaredAnnotations()[0].annotationType()));\n        assertTrue(wrapper.isAnnotationPresent(StatelessAnnotated.class\n                .getDeclaredAnnotations()[0].annotationType()));\n        assertTrue(wrapper.isAnnotationPresent(Annotated.class\n                .getDeclaredAnnotations()[0].annotationType()));\n        assertTrue(wrapper.isAnnotationPresent(Annotated.class\n                .getDeclaredAnnotations()[1].annotationType()));\n        assertTrue(wrapper.isAnnotationPresent(Annotated.class\n                .getDeclaredAnnotations()[2].annotationType()));\n    }\n\n    @Test\n    void removeAnnotations() {\n        initializeStubs();\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType, true,\n                Set.of(SessionScopedAnnotated.class.getDeclaredAnnotations()[0]),\n                Set.of(Annotated.class.getDeclaredAnnotations()[1]));\n        assertEquals(3, wrapper.getAnnotations().size());\n        assertFalse(wrapper.isAnnotationPresent(RequiresGuest.class));\n        assertTrue(wrapper.isAnnotationPresent(SessionScoped.class));\n    }\n\n    @Test\n    void badLambdaArgument() {\n        assertThrows(IllegalArgumentException.class,\n                () -> new AnnotatedTypeWrapper<>(annotatedType, true,\n                        Set.of(() -> SessionScoped.class),\n                        Set.of(() -> RequiresGuest.class)));\n        assertThrows(IllegalArgumentException.class,\n                () -> new AnnotatedTypeWrapper<>(annotatedType, true,\n                        Set.of(() -> RequiresGuest.class),\n                        Set.of()));\n        assertThrows(IllegalArgumentException.class,\n                () -> new AnnotatedTypeWrapper<>(annotatedType, true,\n                        Set.of(),\n                        Set.of(() -> RequiresGuest.class)));\n    }\n\n    @Test\n    void overriddenAnnotation() {\n        initializeStubs();\n        when(annotatedType.getJavaClass()).thenReturn(Void.class);\n        assertEquals(3, annotatedType.getAnnotations().size());\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType, false,\n                Set.of(ShiroSecureAnnotated.class.getDeclaredAnnotations()[0],\n                        StatelessAnnotated.class.getDeclaredAnnotations()[0]),\n                Set.of());\n        assertEquals(2, wrapper.getAnnotations().size());\n        assertTrue(wrapper.isAnnotationPresent(ShiroSecureAnnotated.class\n                .getDeclaredAnnotations()[0].annotationType()));\n        assertTrue(wrapper.isAnnotationPresent(StatelessAnnotated.class\n                .getDeclaredAnnotations()[0].annotationType()));\n        assertEquals(Void.class, wrapper.getJavaClass());\n    }\n\n    @Test\n    void decreaseAnnotationsToZero() {\n        initializeStubs();\n        assertEquals(3, annotatedType.getAnnotations().size());\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType, false, Set.of(), Set.of());\n        assertEquals(0, wrapper.getAnnotations().size());\n    }\n\n    private void initializeStubs() {\n        when(annotatedType.getAnnotations()).thenReturn(Stream.of(Annotated.class.getDeclaredAnnotations())\n                .collect(Collectors.toSet()));\n    }\n}\n","lineNo":100}
{"Refactored Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.shiro.cdi;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport javax.ejb.Stateless;\nimport javax.enterprise.context.SessionScoped;\nimport javax.enterprise.inject.spi.AnnotatedType;\n\nimport org.apache.shiro.authz.annotation.RequiresAuthentication;\nimport org.apache.shiro.authz.annotation.RequiresGuest;\nimport org.apache.shiro.authz.annotation.RequiresPermissions;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.Mock;\n\nimport static org.mockito.Mockito.when;\n\nimport org.mockito.junit.jupiter.MockitoExtension;\n\n/**\n * Annotated Type Wrapper tests\n */\n@ExtendWith(MockitoExtension.class)\nclass AnnotatedTypeWrapperTest {\n    @Mock\n    private AnnotatedType<Void> annotatedType;\n\n    @RequiresAuthentication\n    @RequiresGuest\n    @RequiresPermissions(\"hello\")\n    private final class Annotated {\n    }\n\n    @ShiroSecureAnnotation\n    private final class ShiroSecureAnnotated {\n    }\n\n    @Stateless\n    private final class StatelessAnnotated {\n    }\n\n    @SessionScoped\n    @SuppressWarnings(\"serial\")\n    private static final class SessionScopedAnnotated implements Serializable {\n    }\n\n    @Test\n    void noAnnotations() {\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType);\n        assertEquals(0, wrapper.getAnnotations().size());\n    }\n\n    @Test\n    void noAdditionalAnnotations() {\n        initializeStubs();\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType);\n        assertEquals(3, wrapper.getAnnotations().size());\n    }\n\n    @Test\n    @SuppressWarnings(\"MagicNumber\")\n    void twoAdditionalAnnotations() {\n        initializeStubs();\n        Annotation shiroSecureAnnotation = getAnnotation(ShiroSecureAnnotated.class, ShiroSecureAnnotation.class);\n        Annotation statelessAnnotation = getAnnotation(StatelessAnnotated.class, Stateless.class);\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType, shiroSecureAnnotation, statelessAnnotation);\n        assertEquals(5, wrapper.getAnnotations().size());\n        assertTrue(wrapper.isAnnotationPresent(ShiroSecureAnnotation.class));\n        assertTrue(wrapper.isAnnotationPresent(Stateless.class));\n        assertTrue(wrapper.isAnnotationPresent(RequiresAuthentication.class));\n        assertTrue(wrapper.isAnnotationPresent(RequiresGuest.class));\n        assertTrue(wrapper.isAnnotationPresent(RequiresPermissions.class));\n    }\n\n    @Test\n    void removeAnnotations() {\n        initializeStubs();\n        Set<Annotation> sessionScopeAnnoationsSet = Set.of(getAnnotation(SessionScopedAnnotated.class, SessionScoped.class));\n        Set<Annotation> requiresGuestAnnoationsSet = Set.of(getAnnotation(Annotated.class, RequiresGuest.class));\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType, true, sessionScopeAnnoationsSet, requiresGuestAnnoationsSet);\n        assertEquals(3, wrapper.getAnnotations().size());\n        assertFalse(wrapper.isAnnotationPresent(RequiresGuest.class));\n        assertTrue(wrapper.isAnnotationPresent(SessionScoped.class));\n    }\n\n    @Test\n    void badLambdaArgument() {\n        assertThrows(IllegalArgumentException.class,\n                () -> new AnnotatedTypeWrapper<>(annotatedType, true,\n                        Set.of(() -> SessionScoped.class),\n                        Set.of(() -> RequiresGuest.class)));\n        assertThrows(IllegalArgumentException.class,\n                () -> new AnnotatedTypeWrapper<>(annotatedType, true,\n                        Set.of(() -> RequiresGuest.class),\n                        Set.of()));\n        assertThrows(IllegalArgumentException.class,\n                () -> new AnnotatedTypeWrapper<>(annotatedType, true,\n                        Set.of(),\n                        Set.of(() -> RequiresGuest.class)));\n    }\n\n    @Test\n    void overriddenAnnotation() {\n        initializeStubs();\n        when(annotatedType.getJavaClass()).thenReturn(Void.class);\n        assertEquals(3, annotatedType.getAnnotations().size());\n        Annotation shiroSecureAnnoations = getAnnotation(ShiroSecureAnnotated.class, ShiroSecureAnnotation.class);\n        Annotation statelessAnnoations = getAnnotation(StatelessAnnotated.class, Stateless.class);\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType, false,\n                Set.of(shiroSecureAnnoations, statelessAnnoations),\n                Set.of());\n        assertEquals(2, wrapper.getAnnotations().size());\n        assertTrue(wrapper.isAnnotationPresent(ShiroSecureAnnotation.class));\n        assertTrue(wrapper.isAnnotationPresent(Stateless.class));\n        assertEquals(Void.class, wrapper.getJavaClass());\n    }\n\n    @Test\n    void decreaseAnnotationsToZero() {\n        initializeStubs();\n        assertEquals(3, annotatedType.getAnnotations().size());\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType, false, Set.of(), Set.of());\n        assertEquals(0, wrapper.getAnnotations().size());\n    }\n\n    private void initializeStubs() {\n        when(annotatedType.getAnnotations()).thenReturn(Stream.of(Annotated.class.getDeclaredAnnotations())\n                .collect(Collectors.toSet()));\n    }\n\n    private Annotation getAnnotation(Class<?> annotatedClass, Class<?> annotation) {\n        return Arrays.stream(annotatedClass.getDeclaredAnnotations())\n                .filter(a -> a.annotationType().equals(annotation))\n                .findFirst()\n                .orElse(null);\n    }\n}\n","Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.shiro.cdi;\n\nimport java.io.Serializable;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport javax.ejb.Stateless;\nimport javax.enterprise.context.SessionScoped;\nimport javax.enterprise.inject.spi.AnnotatedType;\n\nimport org.apache.shiro.authz.annotation.RequiresAuthentication;\nimport org.apache.shiro.authz.annotation.RequiresGuest;\nimport org.apache.shiro.authz.annotation.RequiresPermissions;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.Mock;\n\nimport static org.mockito.Mockito.when;\n\nimport org.mockito.junit.jupiter.MockitoExtension;\n\n/**\n * Annotated Type Wrapper tests\n */\n@ExtendWith(MockitoExtension.class)\nclass AnnotatedTypeWrapperTest {\n    @Mock\n    private AnnotatedType<Void> annotatedType;\n\n    @RequiresAuthentication\n    @RequiresGuest\n    @RequiresPermissions(\"hello\")\n    private final class Annotated {\n    }\n\n    @ShiroSecureAnnotation\n    private final class ShiroSecureAnnotated {\n    }\n\n    @Stateless\n    private final class StatelessAnnotated {\n    }\n\n    @SessionScoped\n    @SuppressWarnings(\"serial\")\n    private static final class SessionScopedAnnotated implements Serializable {\n    }\n\n    @Test\n    void noAnnotations() {\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType);\n        assertEquals(0, wrapper.getAnnotations().size());\n    }\n\n    @Test\n    void noAdditionalAnnotations() {\n        initializeStubs();\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType);\n        assertEquals(3, wrapper.getAnnotations().size());\n    }\n\n    @Test\n    @SuppressWarnings(\"MagicNumber\")\n    void twoAdditionalAnnotations() {\n        initializeStubs();\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType,\n                ShiroSecureAnnotated.class.getDeclaredAnnotations()[0],\n                StatelessAnnotated.class.getDeclaredAnnotations()[0]);\n        assertEquals(5, wrapper.getAnnotations().size());\n        assertTrue(wrapper.isAnnotationPresent(ShiroSecureAnnotated.class\n                .getDeclaredAnnotations()[0].annotationType()));\n        assertTrue(wrapper.isAnnotationPresent(StatelessAnnotated.class\n                .getDeclaredAnnotations()[0].annotationType()));\n        assertTrue(wrapper.isAnnotationPresent(Annotated.class\n                .getDeclaredAnnotations()[0].annotationType()));\n        assertTrue(wrapper.isAnnotationPresent(Annotated.class\n                .getDeclaredAnnotations()[1].annotationType()));\n        assertTrue(wrapper.isAnnotationPresent(Annotated.class\n                .getDeclaredAnnotations()[2].annotationType()));\n    }\n\n    @Test\n    void removeAnnotations() {\n        initializeStubs();\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType, true,\n                Set.of(SessionScopedAnnotated.class.getDeclaredAnnotations()[0]),\n                Set.of(Annotated.class.getDeclaredAnnotations()[1]));\n        assertEquals(3, wrapper.getAnnotations().size());\n        assertFalse(wrapper.isAnnotationPresent(RequiresGuest.class));\n        assertTrue(wrapper.isAnnotationPresent(SessionScoped.class));\n    }\n\n    @Test\n    void badLambdaArgument() {\n        assertThrows(IllegalArgumentException.class,\n                () -> new AnnotatedTypeWrapper<>(annotatedType, true,\n                        Set.of(() -> SessionScoped.class),\n                        Set.of(() -> RequiresGuest.class)));\n        assertThrows(IllegalArgumentException.class,\n                () -> new AnnotatedTypeWrapper<>(annotatedType, true,\n                        Set.of(() -> RequiresGuest.class),\n                        Set.of()));\n        assertThrows(IllegalArgumentException.class,\n                () -> new AnnotatedTypeWrapper<>(annotatedType, true,\n                        Set.of(),\n                        Set.of(() -> RequiresGuest.class)));\n    }\n\n    @Test\n    void overriddenAnnotation() {\n        initializeStubs();\n        when(annotatedType.getJavaClass()).thenReturn(Void.class);\n        assertEquals(3, annotatedType.getAnnotations().size());\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType, false,\n                Set.of(ShiroSecureAnnotated.class.getDeclaredAnnotations()[0],\n                        StatelessAnnotated.class.getDeclaredAnnotations()[0]),\n                Set.of());\n        assertEquals(2, wrapper.getAnnotations().size());\n        assertTrue(wrapper.isAnnotationPresent(ShiroSecureAnnotated.class\n                .getDeclaredAnnotations()[0].annotationType()));\n        assertTrue(wrapper.isAnnotationPresent(StatelessAnnotated.class\n                .getDeclaredAnnotations()[0].annotationType()));\n        assertEquals(Void.class, wrapper.getJavaClass());\n    }\n\n    @Test\n    void decreaseAnnotationsToZero() {\n        initializeStubs();\n        assertEquals(3, annotatedType.getAnnotations().size());\n        var wrapper = new AnnotatedTypeWrapper<>(annotatedType, false, Set.of(), Set.of());\n        assertEquals(0, wrapper.getAnnotations().size());\n    }\n\n    private void initializeStubs() {\n        when(annotatedType.getAnnotations()).thenReturn(Stream.of(Annotated.class.getDeclaredAnnotations())\n                .collect(Collectors.toSet()));\n    }\n}\n","lineNo":101}
{"Refactored Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.shiro.ee.filters;\n\nimport static org.apache.shiro.ee.filters.FormAuthenticationFilter.LOGIN_URL_ATTR_NAME;\nimport static org.apache.shiro.ee.filters.FormResubmitSupport.HttpHeaderContstants.CONTENT_TYPE;\nimport static org.apache.shiro.ee.filters.FormResubmitSupport.HttpHeaderContstants.COOKIE;\nimport static org.apache.shiro.ee.filters.FormResubmitSupport.HttpHeaderContstants.LOCATION;\nimport static org.apache.shiro.ee.filters.FormResubmitSupport.HttpHeaderContstants.SET_COOKIE;\nimport static org.apache.shiro.ee.filters.FormResubmitSupport.HttpResponseCodes.AUTHFAIL;\nimport static org.apache.shiro.ee.filters.FormResubmitSupport.HttpResponseCodes.FOUND;\nimport static org.apache.shiro.ee.filters.FormResubmitSupport.HttpResponseCodes.OK;\nimport static org.apache.shiro.ee.filters.FormResubmitSupport.MediaType.APPLICATION_FORM_URLENCODED;\nimport static org.apache.shiro.ee.filters.FormResubmitSupport.MediaType.TEXT_XML;\nimport static org.apache.shiro.ee.filters.FormResubmitSupportCookies.DONT_ADD_ANY_MORE_COOKIES;\nimport static org.apache.shiro.ee.filters.FormResubmitSupportCookies.addCookie;\nimport static org.apache.shiro.ee.filters.FormResubmitSupportCookies.cookieStreamFromHeader;\nimport static org.apache.shiro.ee.filters.FormResubmitSupportCookies.deleteCookie;\nimport static org.apache.shiro.ee.filters.FormResubmitSupportCookies.getCookieAge;\nimport static org.apache.shiro.ee.filters.FormResubmitSupportCookies.getSessionCookieName;\nimport java.util.Collections;\nimport org.apache.shiro.ee.filters.Forms.FallbackPredicate;\nimport org.apache.shiro.ee.filters.ShiroFilter.WrappedSecurityManager;\nimport static org.apache.shiro.ee.filters.FormResubmitSupportCookies.transformCookieHeader;\nimport static org.apache.shiro.ee.listeners.EnvironmentLoaderListener.isFormResumbitDisabled;\nimport java.io.IOException;\nimport java.net.CookieManager;\nimport java.net.HttpCookie;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URLDecoder;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpHeaders;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Optional;\nimport java.util.UUID;\nimport static java.util.function.Predicate.not;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport static javax.faces.application.StateManager.STATE_SAVING_METHOD_CLIENT;\nimport static javax.faces.application.StateManager.STATE_SAVING_METHOD_PARAM_NAME;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport lombok.AccessLevel;\nimport lombok.EqualsAndHashCode;\nimport lombok.NoArgsConstructor;\nimport lombok.NonNull;\nimport lombok.RequiredArgsConstructor;\nimport lombok.SneakyThrows;\nimport lombok.ToString;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.shiro.SecurityUtils;\nimport static org.apache.shiro.ee.util.JakartaTransformer.jakartify;\nimport org.apache.shiro.mgt.AbstractRememberMeManager;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.mgt.SessionsSecurityManager;\nimport org.apache.shiro.web.session.mgt.DefaultWebSessionManager;\nimport org.apache.shiro.web.util.WebUtils;\nimport org.jsoup.Jsoup;\nimport org.jsoup.select.Elements;\nimport org.omnifaces.util.Faces;\nimport org.omnifaces.util.Servlets;\n\n/**\n * supporting methods for {@link Forms}\n */\n@Slf4j\n@NoArgsConstructor(access = AccessLevel.PRIVATE)\n@SuppressWarnings(\"HideUtilityClassConstructor\")\npublic class FormResubmitSupport {\n    static final String SHIRO_FORM_DATA_KEY = \"org.apache.shiro.form-data-key\";\n    static final String SESSION_EXPIRED_PARAMETER = \"org.apache.shiro.sessionExpired\";\n    static final String FORM_IS_RESUBMITTED = \"org.apache.shiro.form-is-resubmitted\";\n    // encoded view state\n    private static final String FACES_VIEW_STATE = jakartify(\"javax.faces.ViewState\");\n    private static final String FACES_VIEW_STATE_EQUALS = FACES_VIEW_STATE + \"=\";\n    private static final Pattern VIEW_STATE_PATTERN\n            = Pattern.compile(String.format(\"(.*)(%s[-]?[\\\\d]+:[-]?[\\\\d]+)(.*)\", FACES_VIEW_STATE_EQUALS));\n    private static final String PARTIAL_VIEW = jakartify(\"javax.faces.partial\");\n    private static final Pattern PARTIAL_REQUEST_PATTERN\n            = Pattern.compile(String.format(\"[\\\\&]?%s.\\\\w+=[\\\\w\\\\s:%%\\\\d]*\", PARTIAL_VIEW));\n    private static final Pattern INITIAL_AMPERSAND = Pattern.compile(\"^\\\\&\");\n    private static final String FORM_DATA_CACHE = \"org.apache.shiro.form-data-cache\";\n\n    static class HttpMethod {\n        static final String GET = \"GET\";\n        static final String POST = \"POST\";\n    }\n\n    static class HttpHeaderContstants {\n        static final String CONTENT_TYPE = \"Content-Type\";\n        static final String LOCATION = \"Location\";\n        static final String COOKIE = \"Cookie\";\n        static final String SET_COOKIE = \"Set-Cookie\";\n    }\n\n    static class MediaType {\n        static final String APPLICATION_FORM_URLENCODED = \"application/x-www-form-urlencoded\";\n        static final String TEXT_XML = \"text/xml\";\n    }\n\n    static class HttpResponseCodes {\n        static final int OK = 200;\n        static final int FOUND = 302;\n        static final int AUTHFAIL = 401;\n    }\n\n    @RequiredArgsConstructor\n    @EqualsAndHashCode @ToString\n    @SuppressWarnings(\"VisibilityModifier\")\n    static class PartialAjaxResult {\n        public final String result;\n        public final boolean isPartialAjaxRequest;\n        public final boolean isStatelessRequest;\n    }\n\n    static void savePostDataForResubmit(HttpServletRequest request, HttpServletResponse response, @NonNull String loginUrl) {\n        if (isPostRequest(request) && unwrapSecurityManager(SecurityUtils.getSecurityManager())\n                instanceof DefaultSecurityManager) {\n            String postData = getPostData(request);\n            var cacheKey = UUID.randomUUID();\n            var dsm = (DefaultSecurityManager) unwrapSecurityManager(SecurityUtils.getSecurityManager());\n            if (dsm.getCacheManager() != null) {\n                var cache = dsm.getCacheManager().getCache(FORM_DATA_CACHE);\n                var rememberMeManager = (AbstractRememberMeManager) dsm.getRememberMeManager();\n                if (rememberMeManager != null && rememberMeManager.getCipherService() != null) {\n                    cache.put(cacheKey, rememberMeManager.getCipherService()\n                            .encrypt(postData.getBytes(StandardCharsets.UTF_8),\n                                    rememberMeManager.getEncryptionCipherKey()).getBytes());\n                } else {\n                    log.warn(\"Post-data was saved in plain text due to rememberMeManager not being available\");\n                    cache.put(cacheKey, postData);\n                }\n                addCookie(response, request.getServletContext(), SHIRO_FORM_DATA_KEY,\n                        cacheKey.toString(), getCookieAge(request, dsm));\n            } else {\n                log.warn(\"Shiro Cache manager is not configured, cannot store form data\");\n            }\n        }\n        boolean isFacesGetRequest = HttpMethod.GET.equalsIgnoreCase(request.getMethod());\n        doFacesRedirect(request, response, request.getContextPath() + loginUrl\n                + (isFacesGetRequest ? \"\" : \"?%s=true\"), SESSION_EXPIRED_PARAMETER);\n    }\n\n    static boolean isPostRequest(ServletRequest request) {\n        if (request instanceof HttpServletRequest) {\n            return HttpMethod.POST.equalsIgnoreCase(WebUtils.toHttp(request).getMethod());\n        } else {\n            return false;\n        }\n    }\n\n    @SneakyThrows(IOException.class)\n    static String getPostData(ServletRequest request) {\n        return request.getReader().lines().collect(Collectors.joining());\n    }\n\n    static String getSavedFormDataFromKey(@NonNull String savedFormDataKey) {\n        String savedFormData = null;\n        if (unwrapSecurityManager(SecurityUtils.getSecurityManager()) instanceof DefaultSecurityManager) {\n            var dsm = (DefaultSecurityManager) unwrapSecurityManager(SecurityUtils.getSecurityManager());\n            if (dsm.getCacheManager() != null) {\n                var cache = dsm.getCacheManager().getCache(FORM_DATA_CACHE);\n                var cacheKey = UUID.fromString(savedFormDataKey);\n                var rememberMeManager = (AbstractRememberMeManager) dsm.getRememberMeManager();\n                if (rememberMeManager != null && rememberMeManager.getCipherService() != null) {\n                    var cachedData = Optional.ofNullable((byte[]) cache.get(cacheKey));\n                    savedFormData = cachedData.map(encryptedData ->\n                            decrypt(encryptedData, rememberMeManager)).orElse(savedFormData);\n                } else {\n                    savedFormData = (String) cache.get(cacheKey);\n                }\n                cache.remove(cacheKey);\n            }\n        }\n        return savedFormData;\n    }\n\n    static String decrypt(byte[] encrypted, AbstractRememberMeManager rememberMeManager) {\n        return new String(rememberMeManager.getCipherService()\n                .decrypt(encrypted, rememberMeManager.getDecryptionCipherKey()).getClonedBytes(),\n                StandardCharsets.UTF_8);\n    }\n\n    static void saveRequest(HttpServletRequest request, HttpServletResponse response, boolean useReferer) {\n        String path = useReferer ? getReferer(request)\n                : Servlets.getRequestURLWithQueryString(request);\n        if (path != null) {\n            Servlets.addResponseCookie(request, response, WebUtils.SAVED_REQUEST_KEY,\n                    path, null, request.getContextPath(),\n                    // cookie age = session timeout\n                    getCookieAge(request, SecurityUtils.getSecurityManager()));\n        }\n    }\n\n    static void saveRequestReferer(boolean rv, HttpServletRequest request, HttpServletResponse response) {\n        if (rv && HttpMethod.GET.equalsIgnoreCase(request.getMethod())) {\n            if (Servlets.getRequestCookie(request, WebUtils.SAVED_REQUEST_KEY) == null) {\n                // only save refer when there is no saved request cookie already,\n                // and only as a last resort\n                saveRequest(request, response, true);\n            }\n        }\n    }\n\n    static String getReferer(HttpServletRequest request) {\n        String referer = request.getHeader(\"referer\");\n        if (referer != null) {\n            // do not switch to https if custom port is specified\n            if (!referer.matches(\"^http:\\\\/\\\\/[A-z|.|[0-9]]+:[0-9]+(\\\\/.*|$)\")) {\n                referer = referer.replaceFirst(\"^http:\", \"https:\");\n            }\n        }\n        return referer;\n    }\n\n    /**\n     * Redirects the user to saved request after login, if available\n     * Resumbits the form that caused the logout upon successfull login.Form resumnission supports JSF and Ajax forms\n     * @param request\n     * @param response\n     * @param useFallbackPath predicate whether to use fall back path\n     * @param fallbackPath\n     * @param resubmit if true, attempt to resubmit the form that was unsubmitted prior to logout\n     */\n    @SneakyThrows({IOException.class, URISyntaxException.class, InterruptedException.class})\n    static void redirectToSaved(HttpServletRequest request, HttpServletResponse response,\n            FallbackPredicate useFallbackPath, String fallbackPath, boolean resubmit) {\n        String savedRequest = Servlets.getRequestCookie(request, WebUtils.SAVED_REQUEST_KEY);\n        if (savedRequest != null) {\n            doRedirectToSaved(request, response, savedRequest, resubmit);\n        } else {\n            redirectToView(request, response, useFallbackPath, fallbackPath);\n        }\n    }\n\n    /**\n     * redirect to saved request, possibly resubmitting an existing form\n     * the saved request is via a cookie\n     *\n     * @param request\n     * @param response\n     * @param useFallbackPath\n     * @param fallbackPath\n     */\n    static void redirectToSaved(HttpServletRequest request, HttpServletResponse response,\n            FallbackPredicate useFallbackPath, String fallbackPath) {\n        redirectToSaved(request, response, useFallbackPath, fallbackPath,\n                !isFormResumbitDisabled(request.getServletContext()));\n    }\n\n\n    private static void doRedirectToSaved(HttpServletRequest request, HttpServletResponse response,\n            @NonNull String savedRequest, boolean resubmit) throws IOException, URISyntaxException, InterruptedException {\n        deleteCookie(response, request.getServletContext(), WebUtils.SAVED_REQUEST_KEY);\n        String savedFormDataKey = Servlets.getRequestCookie(request, SHIRO_FORM_DATA_KEY);\n        boolean doRedirectAtEnd = true;\n        if (savedFormDataKey != null && resubmit) {\n            String formData = getSavedFormDataFromKey(savedFormDataKey);\n            if (formData != null) {\n                Optional.ofNullable(resubmitSavedForm(formData, savedRequest,\n                        request, response, request.getServletContext(), false))\n                        .ifPresent(path -> doFacesRedirect(request, response, path));\n                doRedirectAtEnd = false;\n            } else {\n                deleteCookie(response, request.getServletContext(), SHIRO_FORM_DATA_KEY);\n            }\n        }\n        if (doRedirectAtEnd) {\n            doFacesRedirect(request, response, savedRequest);\n        }\n    }\n\n    /**\n     * @param request\n     * @param response\n     */\n    static void redirectToView(HttpServletRequest request, HttpServletResponse response) {\n        redirectToView(request, response, (path, req) -> false, null);\n    }\n\n    /**\n     * redirects to current view after a form submit,\n     * or the fallback path if predicate succeeds\n     *\n     * @param request\n     * @param response\n     * @param useFallbackPath\n     * @param fallbackPath\n     */\n    @SneakyThrows\n    static void redirectToView(HttpServletRequest request, HttpServletResponse response,\n            FallbackPredicate useFallbackPath, String fallbackPath) {\n        boolean useFallback = useFallbackPath.useFallback(request.getRequestURI(), request);\n        String referer = getReferer(request);\n        String redirectPath = Servlets.getRequestURLWithQueryString(request);\n        if (useFallback && referer != null && !isLoginUrl(request)) {\n            // the following is used in the logout flow only,\n            // because login flow saves the request automatically, without\n            // needing a referrer\n            useFallback = useFallbackPath.useFallback(referer, request);\n            redirectPath = referer;\n        }\n        if (useFallback) {\n            doFacesRedirect(request, response, request.getContextPath() + fallbackPath);\n        } else {\n            doFacesRedirect(request, response, redirectPath);\n        }\n    }\n\n    /**\n     * flash cookie is preserved here\n     *\n     * @param request\n     * @param response\n     * @param path\n     * @param paramValues\n     */\n    private static void doFacesRedirect(HttpServletRequest request, HttpServletResponse response,\n            String path, Object... paramValues) {\n        if (hasFacesContext()) {\n            Faces.redirect(path, paramValues);\n        } else {\n            Servlets.facesRedirect(request, response, path, paramValues);\n        }\n    }\n\n    static boolean hasFacesContext() {\n        try {\n            return Faces.hasContext();\n        } catch (Throwable e) {\n            return false;\n        }\n    }\n\n    static boolean isLoginUrl(HttpServletRequest request) {\n        String loginUrl = (String) request.getAttribute(LOGIN_URL_ATTR_NAME);\n        return loginUrl != null && request.getRequestURI().equals(request.getContextPath() + loginUrl);\n    }\n\n    static String resubmitSavedForm(@NonNull String savedFormData, @NonNull String savedRequest,\n            HttpServletRequest originalRequest, HttpServletResponse originalResponse,\n            ServletContext servletContext, boolean rememberedAjaxResubmit)\n            throws InterruptedException, URISyntaxException, IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"saved form data: {}\", savedFormData);\n            log.debug(\"Set Cookie Headers: {}\", originalResponse.getHeaders(SET_COOKIE));\n            log.debug(\"Original Request Headers: {}\", Collections.list(originalRequest.getHeaderNames()));\n            log.debug(\"Original Request Cookie Header: {}\", Collections.list(originalRequest.getHeaders(COOKIE)));\n        }\n        if (Boolean.TRUE.toString().equals(originalRequest.getHeader(FORM_IS_RESUBMITTED))) {\n            log.debug(\"Form resubmit: internal auth failure\");\n            originalResponse.setStatus(AUTHFAIL);\n            return resubmitResponseCleanup(originalRequest);\n        }\n        var savedRequestURI = URI.create(savedRequest);\n        HttpClient client = buildHttpClient(savedRequestURI, servletContext, originalRequest);\n        PartialAjaxResult decodedFormData = parseFormData(savedFormData, savedRequestURI, client, servletContext);\n        HttpRequest postRequest = constructPostRequest(savedRequestURI, decodedFormData.result);\n        HttpResponse<String> response = sendResubmitRequest(client, postRequest);\n        if (rememberedAjaxResubmit && !decodedFormData.isStatelessRequest) {\n            HttpRequest redirectRequest = constructPostRequest(savedRequestURI, savedFormData);\n            var redirectResponse = client.send(redirectRequest, HttpResponse.BodyHandlers.ofString());\n            log.debug(\"Redirect request: {}, response: {}\", redirectRequest, redirectResponse);\n            return processResubmitResponse(redirectResponse, originalRequest, originalResponse,\n                    response.headers(), savedRequest, servletContext, true, rememberedAjaxResubmit);\n        } else {\n            deleteCookie(originalResponse, servletContext, SHIRO_FORM_DATA_KEY);\n            return processResubmitResponse(response, originalRequest, originalResponse,\n                    response.headers(), savedRequest, servletContext,\n                    (rememberedAjaxResubmit && decodedFormData.isStatelessRequest) ? false\n                            : decodedFormData.isPartialAjaxRequest, rememberedAjaxResubmit);\n        }\n    }\n\n    private static HttpRequest constructPostRequest(URI request, String body) {\n        return HttpRequest.newBuilder().uri(request)\n                .POST(HttpRequest.BodyPublishers.ofString(body))\n                .headers(CONTENT_TYPE, APPLICATION_FORM_URLENCODED,\n                        FORM_IS_RESUBMITTED, Boolean.TRUE.toString())\n                .build();\n    }\n\n    private static HttpResponse<String>\n    sendResubmitRequest(HttpClient client, HttpRequest request) throws IOException, InterruptedException {\n        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n        if (log.isDebugEnabled()) {\n            log.debug(\"Resubmit request: {}, response: {}\", request, response);\n            log.debug(\"Response Headers: {}\", response.headers().map());\n        }\n        if (response.statusCode() == AUTHFAIL) {\n            log.debug(\"processing authfail\");\n            var cookieManager = (CookieManager) client.cookieHandler().get();\n            cookieStreamFromHeader(response.headers().allValues(SET_COOKIE))\n                    .forEach(cookie -> cookieManager.getCookieStore().add(request.uri(), cookie));\n            response = client.send(request, HttpResponse.BodyHandlers.ofString());\n            if (log.isDebugEnabled()) {\n                log.debug(\"Resubmit request(authfail): {}, response: {}\", request, response);\n                log.debug(\"Response Headers(authfail): {}\", response.headers().map());\n            }\n        }\n        return response;\n    }\n\n    private static PartialAjaxResult parseFormData(String savedFormData, URI savedRequest,\n            HttpClient client, ServletContext servletContext) throws IOException, InterruptedException {\n        boolean isStateless = true;\n        if (!isJSFClientStateSavingMethod(servletContext)) {\n            String decodedFormData = URLDecoder.decode(savedFormData, StandardCharsets.UTF_8);\n            if (isJSFStatefulForm(decodedFormData)) {\n                isStateless = false;\n                savedFormData = getJSFNewViewState(savedRequest, client, decodedFormData);\n            }\n        }\n        return noJSFAjaxRequests(savedFormData, isStateless);\n    }\n\n    @SuppressWarnings(\"fallthrough\")\n    private static String processResubmitResponse(HttpResponse<String> response,\n            HttpServletRequest originalRequest, HttpServletResponse originalResponse,\n            HttpHeaders headers, String savedRequest, ServletContext servletContext,\n            boolean isPartialAjaxRequest, boolean rememberedAjaxResubmit) throws IOException {\n        switch (response.statusCode()) {\n            case FOUND:\n                if (rememberedAjaxResubmit) {\n                    originalResponse.setStatus(OK);\n                } else {\n                    // can't use Faces.redirect() here\n                    originalResponse.setStatus(response.statusCode());\n                    originalResponse.setHeader(LOCATION, response.headers().firstValue(LOCATION).orElseThrow());\n                }\n            case OK:\n                // do not duplicate the session cookie(s)\n                transformCookieHeader(headers.allValues(SET_COOKIE))\n                        .entrySet().stream().filter(not(entry -> entry.getKey()\n                                .startsWith(getSessionCookieName(servletContext, SecurityUtils.getSecurityManager()))))\n                        .forEach(entry -> addCookie(originalResponse, servletContext,\n                                entry.getKey(), entry.getValue(), -1));\n                if (isPartialAjaxRequest) {\n                    originalResponse.setHeader(CONTENT_TYPE, TEXT_XML);\n                    originalResponse.setCharacterEncoding(StandardCharsets.UTF_8.name());\n                    originalResponse.getWriter().append(String.format(\n                            \"<partial-response><redirect url=\\\"%s\\\"><\/redirect><\/partial-response>\",\n                            savedRequest));\n                } else {\n                    originalResponse.getWriter().append(response.body());\n                }\n                return resubmitResponseCleanup(originalRequest);\n            default:\n                return savedRequest;\n        }\n    }\n\n    private static String resubmitResponseCleanup(HttpServletRequest originalRequest) {\n        originalRequest.setAttribute(DONT_ADD_ANY_MORE_COOKIES, Boolean.TRUE);\n        if (hasFacesContext()) {\n            Faces.responseComplete();\n        }\n        return null;\n    }\n\n    private static HttpClient buildHttpClient(URI savedRequest, ServletContext servletContext,\n            HttpServletRequest originalRequest) throws URISyntaxException {\n        CookieManager cookieManager = new CookieManager();\n        var session = SecurityUtils.getSubject().getSession();\n        var sessionCookieName = getSessionCookieName(servletContext, SecurityUtils.getSecurityManager());\n        var sessionCookie = new HttpCookie(sessionCookieName, session.getId().toString());\n        sessionCookie.setPath(servletContext.getContextPath());\n        sessionCookie.setVersion(0);\n        cookieManager.getCookieStore().add(savedRequest, sessionCookie);\n        log.debug(\"Setting Cookie {}\", sessionCookieName);\n        for (Cookie origCookie : originalRequest.getCookies()) {\n            if (!origCookie.getName().equals(sessionCookieName)) {\n                try {\n                    log.debug(\"Setting Cookie {}\", origCookie.getName());\n                    HttpCookie cookie = new HttpCookie(origCookie.getName(), origCookie.getValue());\n                    cookie.setPath(servletContext.getContextPath());\n                    cookie.setVersion(0);\n                    cookieManager.getCookieStore().add(savedRequest, cookie);\n                } catch (IllegalArgumentException e) {\n                    log.warn(\"Form Resubmit: Ignoring invalid cookie [{} - {}]\",\n                            origCookie.getName(), origCookie.getValue(), e);\n                }\n            }\n        }\n        return HttpClient.newBuilder().cookieHandler(cookieManager).build();\n    }\n\n    public static DefaultWebSessionManager getNativeSessionManager(SecurityManager securityManager) {\n        DefaultWebSessionManager rv = null;\n        SecurityManager unwrapped = unwrapSecurityManager(securityManager);\n        if (unwrapped instanceof SessionsSecurityManager) {\n            var ssm = (SessionsSecurityManager) unwrapped;\n            var sm = ssm.getSessionManager();\n            if (sm instanceof DefaultWebSessionManager) {\n                rv = (DefaultWebSessionManager) sm;\n            }\n        }\n        return rv;\n    }\n\n    private static org.apache.shiro.mgt.SecurityManager unwrapSecurityManager(SecurityManager securityManager) {\n        if (securityManager instanceof WrappedSecurityManager) {\n            WrappedSecurityManager wsm = (WrappedSecurityManager) securityManager;\n            return wsm.wrapped;\n        } else {\n            return securityManager;\n        }\n    }\n\n    private static String getJSFNewViewState(URI savedRequest, HttpClient client, String savedFormData)\n            throws IOException, InterruptedException {\n        var getRequest = HttpRequest.newBuilder().uri(savedRequest).GET().build();\n        HttpResponse<String> htmlResponse = sendResubmitRequest(client, getRequest);\n        if (htmlResponse.statusCode() == OK) {\n            savedFormData = extractJSFNewViewState(htmlResponse.body(), savedFormData);\n        }\n        return savedFormData;\n    }\n\n    static String extractJSFNewViewState(@NonNull String responseBody, @NonNull String savedFormData) {\n        Elements elts = Jsoup.parse(responseBody).select(String.format(\"input[name=%s]\", FACES_VIEW_STATE));\n        if (!elts.isEmpty()) {\n            String viewState = elts.first().attr(\"value\");\n\n            var matcher = VIEW_STATE_PATTERN.matcher(savedFormData);\n            if (matcher.matches()) {\n                savedFormData = matcher.replaceFirst(String.format(\"$1%s%s$3\",\n                        FACES_VIEW_STATE_EQUALS, viewState));\n                log.debug(\"Encoded w/Replaced ViewState: {}\", savedFormData);\n            }\n        }\n        return savedFormData;\n    }\n\n    static PartialAjaxResult noJSFAjaxRequests(String savedFormData, boolean isStateless) {\n        var partialMatcher = PARTIAL_REQUEST_PATTERN.matcher(savedFormData);\n        boolean hasPartialAjax = partialMatcher.find();\n        return new PartialAjaxResult(isStateless ? savedFormData : INITIAL_AMPERSAND.matcher(partialMatcher\n                .replaceAll(\"\")).replaceFirst(\"\"), hasPartialAjax, isStateless);\n    }\n\n    static boolean isJSFStatefulForm(@NonNull String savedFormData) {\n        var matcher = VIEW_STATE_PATTERN.matcher(savedFormData);\n        return matcher.find() && matcher.groupCount() >= 2\n                && !matcher.group(2).equalsIgnoreCase(\"stateless\");\n    }\n\n    static boolean isJSFClientStateSavingMethod(ServletContext servletContext) {\n        return STATE_SAVING_METHOD_CLIENT.equals(\n                servletContext.getInitParameter(STATE_SAVING_METHOD_PARAM_NAME));\n    }\n}\n","Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.shiro.ee.filters;\n\nimport static org.apache.shiro.ee.filters.FormAuthenticationFilter.LOGIN_URL_ATTR_NAME;\nimport static org.apache.shiro.ee.filters.FormResubmitSupport.HttpHeaderContstants.CONTENT_TYPE;\nimport static org.apache.shiro.ee.filters.FormResubmitSupport.HttpHeaderContstants.LOCATION;\nimport static org.apache.shiro.ee.filters.FormResubmitSupport.HttpHeaderContstants.SET_COOKIE;\nimport static org.apache.shiro.ee.filters.FormResubmitSupport.HttpResponseCodes.FOUND;\nimport static org.apache.shiro.ee.filters.FormResubmitSupport.HttpResponseCodes.OK;\nimport static org.apache.shiro.ee.filters.FormResubmitSupport.MediaType.APPLICATION_FORM_URLENCODED;\nimport static org.apache.shiro.ee.filters.FormResubmitSupport.MediaType.TEXT_XML;\nimport static org.apache.shiro.ee.filters.FormResubmitSupportCookies.DONT_ADD_ANY_MORE_COOKIES;\nimport static org.apache.shiro.ee.filters.FormResubmitSupportCookies.addCookie;\nimport static org.apache.shiro.ee.filters.FormResubmitSupportCookies.deleteCookie;\nimport static org.apache.shiro.ee.filters.FormResubmitSupportCookies.getCookieAge;\nimport static org.apache.shiro.ee.filters.FormResubmitSupportCookies.getSessionCookieName;\nimport static org.apache.shiro.ee.filters.FormResubmitSupportCookies.transformCookieHeader;\nimport org.apache.shiro.ee.filters.Forms.FallbackPredicate;\nimport org.apache.shiro.ee.filters.ShiroFilter.WrappedSecurityManager;\nimport static org.apache.shiro.ee.listeners.EnvironmentLoaderListener.isFormResumbitDisabled;\nimport java.io.IOException;\nimport java.net.CookieManager;\nimport java.net.HttpCookie;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URLDecoder;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpHeaders;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Optional;\nimport java.util.UUID;\nimport static java.util.function.Predicate.not;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport static javax.faces.application.StateManager.STATE_SAVING_METHOD_CLIENT;\nimport static javax.faces.application.StateManager.STATE_SAVING_METHOD_PARAM_NAME;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport lombok.AccessLevel;\nimport lombok.EqualsAndHashCode;\nimport lombok.NoArgsConstructor;\nimport lombok.NonNull;\nimport lombok.RequiredArgsConstructor;\nimport lombok.SneakyThrows;\nimport lombok.ToString;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.shiro.SecurityUtils;\nimport static org.apache.shiro.ee.util.JakartaTransformer.jakartify;\nimport org.apache.shiro.mgt.AbstractRememberMeManager;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.mgt.SessionsSecurityManager;\nimport org.apache.shiro.web.session.mgt.DefaultWebSessionManager;\nimport org.apache.shiro.web.util.WebUtils;\nimport org.jsoup.Jsoup;\nimport org.jsoup.select.Elements;\nimport org.omnifaces.util.Faces;\nimport org.omnifaces.util.Servlets;\n\n/**\n * supporting methods for {@link Forms}\n */\n@Slf4j\n@NoArgsConstructor(access = AccessLevel.PRIVATE)\n@SuppressWarnings(\"HideUtilityClassConstructor\")\npublic class FormResubmitSupport {\n    static final String SHIRO_FORM_DATA_KEY = \"org.apache.shiro.form-data-key\";\n    static final String SESSION_EXPIRED_PARAMETER = \"org.apache.shiro.sessionExpired\";\n    static final String FORM_IS_RESUBMITTED = \"org.apache.shiro.form-is-resubmitted\";\n    // encoded view state\n    private static final String FACES_VIEW_STATE = jakartify(\"javax.faces.ViewState\");\n    private static final String FACES_VIEW_STATE_EQUALS = FACES_VIEW_STATE + \"=\";\n    private static final Pattern VIEW_STATE_PATTERN\n            = Pattern.compile(String.format(\"(.*)(%s[-]?[\\\\d]+:[-]?[\\\\d]+)(.*)\", FACES_VIEW_STATE_EQUALS));\n    private static final String PARTIAL_VIEW = jakartify(\"javax.faces.partial\");\n    private static final Pattern PARTIAL_REQUEST_PATTERN\n            = Pattern.compile(String.format(\"[\\\\&]?%s.\\\\w+=[\\\\w\\\\s:%%\\\\d]*\", PARTIAL_VIEW));\n    private static final Pattern INITIAL_AMPERSAND = Pattern.compile(\"^\\\\&\");\n    private static final String FORM_DATA_CACHE = \"org.apache.shiro.form-data-cache\";\n\n    static class HttpMethod {\n        static final String GET = \"GET\";\n        static final String POST = \"POST\";\n    }\n\n    static class HttpHeaderContstants {\n        static final String CONTENT_TYPE = \"Content-Type\";\n        static final String LOCATION = \"Location\";\n        static final String SET_COOKIE = \"Set-Cookie\";\n    }\n\n    static class MediaType {\n        static final String APPLICATION_FORM_URLENCODED = \"application/x-www-form-urlencoded\";\n        static final String TEXT_XML = \"text/xml\";\n    }\n\n    static class HttpResponseCodes {\n        static final int OK = 200;\n        static final int FOUND = 302;\n    }\n\n    @RequiredArgsConstructor\n    @EqualsAndHashCode @ToString\n    @SuppressWarnings(\"VisibilityModifier\")\n    static class PartialAjaxResult {\n        public final String result;\n        public final boolean isPartialAjaxRequest;\n        public final boolean isStatelessRequest;\n    }\n\n    static void savePostDataForResubmit(HttpServletRequest request, HttpServletResponse response, @NonNull String loginUrl) {\n        if (isPostRequest(request) && unwrapSecurityManager(SecurityUtils.getSecurityManager())\n                instanceof DefaultSecurityManager) {\n            String postData = getPostData(request);\n            var cacheKey = UUID.randomUUID();\n            var dsm = (DefaultSecurityManager) unwrapSecurityManager(SecurityUtils.getSecurityManager());\n            if (dsm.getCacheManager() != null) {\n                var cache = dsm.getCacheManager().getCache(FORM_DATA_CACHE);\n                var rememberMeManager = (AbstractRememberMeManager) dsm.getRememberMeManager();\n                if (rememberMeManager != null && rememberMeManager.getCipherService() != null) {\n                    cache.put(cacheKey, rememberMeManager.getCipherService()\n                            .encrypt(postData.getBytes(StandardCharsets.UTF_8),\n                                    rememberMeManager.getEncryptionCipherKey()).getBytes());\n                } else {\n                    log.warn(\"Post-data was saved in plain text due to rememberMeManager not being available\");\n                    cache.put(cacheKey, postData);\n                }\n                addCookie(response, request.getServletContext(), SHIRO_FORM_DATA_KEY,\n                        cacheKey.toString(), getCookieAge(request, dsm));\n            } else {\n                log.warn(\"Shiro Cache manager is not configured, cannot store form data\");\n            }\n        }\n        boolean isFacesGetRequest = HttpMethod.GET.equalsIgnoreCase(request.getMethod());\n        doFacesRedirect(request, response, request.getContextPath() + loginUrl\n                + (isFacesGetRequest ? \"\" : \"?%s=true\"), SESSION_EXPIRED_PARAMETER);\n    }\n\n    static boolean isPostRequest(ServletRequest request) {\n        if (request instanceof HttpServletRequest) {\n            return HttpMethod.POST.equalsIgnoreCase(WebUtils.toHttp(request).getMethod());\n        } else {\n            return false;\n        }\n    }\n\n    @SneakyThrows(IOException.class)\n    static String getPostData(ServletRequest request) {\n        return request.getReader().lines().collect(Collectors.joining());\n    }\n\n    static String getSavedFormDataFromKey(@NonNull String savedFormDataKey) {\n        String savedFormData = null;\n        if (unwrapSecurityManager(SecurityUtils.getSecurityManager()) instanceof DefaultSecurityManager) {\n            var dsm = (DefaultSecurityManager) unwrapSecurityManager(SecurityUtils.getSecurityManager());\n            if (dsm.getCacheManager() != null) {\n                var cache = dsm.getCacheManager().getCache(FORM_DATA_CACHE);\n                var cacheKey = UUID.fromString(savedFormDataKey);\n                var rememberMeManager = (AbstractRememberMeManager) dsm.getRememberMeManager();\n                if (rememberMeManager != null && rememberMeManager.getCipherService() != null) {\n                    var cachedData = Optional.ofNullable((byte[]) cache.get(cacheKey));\n                    savedFormData = cachedData.map(encryptedData ->\n                            decrypt(encryptedData, rememberMeManager)).orElse(savedFormData);\n                } else {\n                    savedFormData = (String) cache.get(cacheKey);\n                }\n                cache.remove(cacheKey);\n            }\n        }\n        return savedFormData;\n    }\n\n    static String decrypt(byte[] encrypted, AbstractRememberMeManager rememberMeManager) {\n        return new String(rememberMeManager.getCipherService()\n                .decrypt(encrypted, rememberMeManager.getDecryptionCipherKey()).getClonedBytes(),\n                StandardCharsets.UTF_8);\n    }\n\n    static void saveRequest(HttpServletRequest request, HttpServletResponse response, boolean useReferer) {\n        String path = useReferer ? getReferer(request)\n                : Servlets.getRequestURLWithQueryString(request);\n        if (path != null) {\n            Servlets.addResponseCookie(request, response, WebUtils.SAVED_REQUEST_KEY,\n                    path, null, request.getContextPath(),\n                    // cookie age = session timeout\n                    getCookieAge(request, SecurityUtils.getSecurityManager()));\n        }\n    }\n\n    static void saveRequestReferer(boolean rv, HttpServletRequest request, HttpServletResponse response) {\n        if (rv && HttpMethod.GET.equalsIgnoreCase(request.getMethod())) {\n            if (Servlets.getRequestCookie(request, WebUtils.SAVED_REQUEST_KEY) == null) {\n                // only save refer when there is no saved request cookie already,\n                // and only as a last resort\n                saveRequest(request, response, true);\n            }\n        }\n    }\n\n    static String getReferer(HttpServletRequest request) {\n        String referer = request.getHeader(\"referer\");\n        if (referer != null) {\n            // do not switch to https if custom port is specified\n            if (!referer.matches(\"^http:\\\\/\\\\/[A-z|.|[0-9]]+:[0-9]+(\\\\/.*|$)\")) {\n                referer = referer.replaceFirst(\"^http:\", \"https:\");\n            }\n        }\n        return referer;\n    }\n\n    /**\n     * Redirects the user to saved request after login, if available\n     * Resumbits the form that caused the logout upon successfull login.Form resumnission supports JSF and Ajax forms\n     * @param request\n     * @param response\n     * @param useFallbackPath predicate whether to use fall back path\n     * @param fallbackPath\n     * @param resubmit if true, attempt to resubmit the form that was unsubmitted prior to logout\n     */\n    @SneakyThrows({IOException.class, URISyntaxException.class, InterruptedException.class})\n    static void redirectToSaved(HttpServletRequest request, HttpServletResponse response,\n            FallbackPredicate useFallbackPath, String fallbackPath, boolean resubmit) {\n        String savedRequest = Servlets.getRequestCookie(request, WebUtils.SAVED_REQUEST_KEY);\n        if (savedRequest != null) {\n            doRedirectToSaved(request, response, savedRequest, resubmit);\n        } else {\n            redirectToView(request, response, useFallbackPath, fallbackPath);\n        }\n    }\n\n    /**\n     * redirect to saved request, possibly resubmitting an existing form\n     * the saved request is via a cookie\n     *\n     * @param request\n     * @param response\n     * @param useFallbackPath\n     * @param fallbackPath\n     */\n    static void redirectToSaved(HttpServletRequest request, HttpServletResponse response,\n            FallbackPredicate useFallbackPath, String fallbackPath) {\n        redirectToSaved(request, response, useFallbackPath, fallbackPath,\n                !isFormResumbitDisabled(request.getServletContext()));\n    }\n\n\n    private static void doRedirectToSaved(HttpServletRequest request, HttpServletResponse response,\n            @NonNull String savedRequest, boolean resubmit) throws IOException, URISyntaxException, InterruptedException {\n        deleteCookie(response, request.getServletContext(), WebUtils.SAVED_REQUEST_KEY);\n        String savedFormDataKey = Servlets.getRequestCookie(request, SHIRO_FORM_DATA_KEY);\n        boolean doRedirectAtEnd = true;\n        if (savedFormDataKey != null && resubmit) {\n            String formData = getSavedFormDataFromKey(savedFormDataKey);\n            if (formData != null) {\n                Optional.ofNullable(resubmitSavedForm(formData, savedRequest,\n                        request, response, request.getServletContext(), false))\n                        .ifPresent(path -> doFacesRedirect(request, response, path));\n                doRedirectAtEnd = false;\n            } else {\n                deleteCookie(response, request.getServletContext(), SHIRO_FORM_DATA_KEY);\n            }\n        }\n        if (doRedirectAtEnd) {\n            doFacesRedirect(request, response, savedRequest);\n        }\n    }\n\n    /**\n     * @param request\n     * @param response\n     */\n    static void redirectToView(HttpServletRequest request, HttpServletResponse response) {\n        redirectToView(request, response, (path, req) -> false, null);\n    }\n\n    /**\n     * redirects to current view after a form submit,\n     * or the fallback path if predicate succeeds\n     *\n     * @param request\n     * @param response\n     * @param useFallbackPath\n     * @param fallbackPath\n     */\n    @SneakyThrows\n    static void redirectToView(HttpServletRequest request, HttpServletResponse response,\n            FallbackPredicate useFallbackPath, String fallbackPath) {\n        boolean useFallback = useFallbackPath.useFallback(request.getRequestURI(), request);\n        String referer = getReferer(request);\n        String redirectPath = Servlets.getRequestURLWithQueryString(request);\n        if (useFallback && referer != null && !isLoginUrl(request)) {\n            // the following is used in the logout flow only,\n            // because login flow saves the request automatically, without\n            // needing a referrer\n            useFallback = useFallbackPath.useFallback(referer, request);\n            redirectPath = referer;\n        }\n        if (useFallback) {\n            doFacesRedirect(request, response, request.getContextPath() + fallbackPath);\n        } else {\n            doFacesRedirect(request, response, redirectPath);\n        }\n    }\n\n    /**\n     * flash cookie is preserved here\n     *\n     * @param request\n     * @param response\n     * @param path\n     * @param paramValues\n     */\n    private static void doFacesRedirect(HttpServletRequest request, HttpServletResponse response,\n            String path, Object... paramValues) {\n        if (hasFacesContext()) {\n            Faces.redirect(path, paramValues);\n        } else {\n            Servlets.facesRedirect(request, response, path, paramValues);\n        }\n    }\n\n    static boolean hasFacesContext() {\n        try {\n            return Faces.hasContext();\n        } catch (Throwable e) {\n            return false;\n        }\n    }\n\n    static boolean isLoginUrl(HttpServletRequest request) {\n        String loginUrl = (String) request.getAttribute(LOGIN_URL_ATTR_NAME);\n        return loginUrl != null && request.getRequestURI().equals(request.getContextPath() + loginUrl);\n    }\n\n    static String resubmitSavedForm(@NonNull String savedFormData, @NonNull String savedRequest,\n            HttpServletRequest originalRequest, HttpServletResponse originalResponse,\n            ServletContext servletContext, boolean rememberedAjaxResubmit)\n            throws InterruptedException, URISyntaxException, IOException {\n        log.debug(\"saved form data: {}\", savedFormData);\n        HttpClient client = buildHttpClient(savedRequest, servletContext, originalRequest);\n        PartialAjaxResult decodedFormData = parseFormData(savedFormData, savedRequest, client, servletContext);\n        HttpRequest postRequest = HttpRequest.newBuilder().uri(URI.create(savedRequest))\n                .POST(HttpRequest.BodyPublishers.ofString(decodedFormData.result))\n                .headers(CONTENT_TYPE, APPLICATION_FORM_URLENCODED,\n                        FORM_IS_RESUBMITTED, Boolean.TRUE.toString())\n                .build();\n        HttpResponse<String> response = client.send(postRequest, HttpResponse.BodyHandlers.ofString());\n        log.debug(\"Resubmit request: {}, response: {}\", postRequest, response);\n        if (rememberedAjaxResubmit && !decodedFormData.isStatelessRequest) {\n            HttpRequest redirectRequest = HttpRequest.newBuilder().uri(URI.create(savedRequest))\n                    .POST(HttpRequest.BodyPublishers.ofString(savedFormData))\n                    .headers(CONTENT_TYPE, APPLICATION_FORM_URLENCODED)\n                    .build();\n            var redirectResponse = client.send(redirectRequest, HttpResponse.BodyHandlers.ofString());\n            log.debug(\"Redirect request: {}, response: {}\", redirectRequest, redirectResponse);\n            return processResubmitResponse(redirectResponse, originalRequest, originalResponse,\n                    response.headers(), savedRequest, servletContext, true, rememberedAjaxResubmit);\n        } else {\n            deleteCookie(originalResponse, servletContext, SHIRO_FORM_DATA_KEY);\n            return processResubmitResponse(response, originalRequest, originalResponse,\n                    response.headers(), savedRequest, servletContext,\n                    (rememberedAjaxResubmit && decodedFormData.isStatelessRequest) ? false\n                            : decodedFormData.isPartialAjaxRequest, rememberedAjaxResubmit);\n        }\n    }\n\n    private static PartialAjaxResult parseFormData(String savedFormData, String savedRequest,\n            HttpClient client, ServletContext servletContext) throws IOException, InterruptedException {\n        boolean isStateless = true;\n        if (!isJSFClientStateSavingMethod(servletContext)) {\n            String decodedFormData = URLDecoder.decode(savedFormData, StandardCharsets.UTF_8);\n            if (isJSFStatefulForm(decodedFormData)) {\n                isStateless = false;\n                savedFormData = getJSFNewViewState(savedRequest, client, decodedFormData);\n            }\n        }\n        return noJSFAjaxRequests(savedFormData, isStateless);\n    }\n\n    @SuppressWarnings(\"fallthrough\")\n    private static String processResubmitResponse(HttpResponse<String> response,\n            HttpServletRequest originalRequest, HttpServletResponse originalResponse,\n            HttpHeaders headers, String savedRequest, ServletContext servletContext,\n            boolean isPartialAjaxRequest, boolean rememberedAjaxResubmit) throws IOException {\n        switch (response.statusCode()) {\n            case FOUND:\n                if (rememberedAjaxResubmit) {\n                    originalResponse.setStatus(OK);\n                } else {\n                    // can't use Faces.redirect() here\n                    originalResponse.setStatus(response.statusCode());\n                    originalResponse.setHeader(LOCATION, response.headers().firstValue(LOCATION).orElseThrow());\n                }\n            case OK:\n                // do not duplicate the session cookie(s)\n                transformCookieHeader(headers.allValues(SET_COOKIE))\n                        .entrySet().stream().filter(not(entry -> entry.getKey()\n                        .startsWith(getSessionCookieName(servletContext, SecurityUtils.getSecurityManager()))))\n                        .forEach(entry -> addCookie(originalResponse, servletContext,\n                                entry.getKey(), entry.getValue(), -1));\n                if (isPartialAjaxRequest) {\n                    originalResponse.setHeader(CONTENT_TYPE, TEXT_XML);\n                    originalResponse.setCharacterEncoding(StandardCharsets.UTF_8.name());\n                    originalResponse.getWriter().append(String.format(\n                            \"<partial-response><redirect url=\\\"%s\\\"><\/redirect><\/partial-response>\",\n                            savedRequest));\n                } else {\n                    originalResponse.getWriter().append(response.body());\n                }\n                originalRequest.setAttribute(DONT_ADD_ANY_MORE_COOKIES, Boolean.TRUE);\n                if (hasFacesContext()) {\n                    Faces.responseComplete();\n                }\n                return null;\n            default:\n                return savedRequest;\n        }\n    }\n\n    private static HttpClient buildHttpClient(String savedRequest, ServletContext servletContext,\n            HttpServletRequest originalRequest) throws URISyntaxException {\n        CookieManager cookieManager = new CookieManager();\n        var session = SecurityUtils.getSubject().getSession();\n        var sessionCookieName = getSessionCookieName(servletContext, SecurityUtils.getSecurityManager());\n        var sessionCookie = new HttpCookie(sessionCookieName, session.getId().toString());\n        sessionCookie.setPath(servletContext.getContextPath());\n        cookieManager.getCookieStore().add(new URI(savedRequest), sessionCookie);\n        for (Cookie origCookie : originalRequest.getCookies()) {\n            if (!origCookie.getName().equals(sessionCookieName)) {\n                try {\n                    HttpCookie cookie = new HttpCookie(origCookie.getName(), origCookie.getValue());\n                    cookie.setPath(servletContext.getContextPath());\n                    cookieManager.getCookieStore().add(new URI(savedRequest), cookie);\n                } catch (IllegalArgumentException e) {\n                    log.warn(\"Form Resubmit: Ignoring invalid cookie [{} - {}]\",\n                            origCookie.getName(), origCookie.getValue(), e);\n                }\n            }\n        }\n        return HttpClient.newBuilder().cookieHandler(cookieManager).build();\n    }\n\n    public static DefaultWebSessionManager getNativeSessionManager(SecurityManager securityManager) {\n        DefaultWebSessionManager rv = null;\n        SecurityManager unwrapped = unwrapSecurityManager(securityManager);\n        if (unwrapped instanceof SessionsSecurityManager) {\n            var ssm = (SessionsSecurityManager) unwrapped;\n            var sm = ssm.getSessionManager();\n            if (sm instanceof DefaultWebSessionManager) {\n                rv = (DefaultWebSessionManager) sm;\n            }\n        }\n        return rv;\n    }\n\n    private static org.apache.shiro.mgt.SecurityManager unwrapSecurityManager(SecurityManager securityManager) {\n        if (securityManager instanceof WrappedSecurityManager) {\n            WrappedSecurityManager wsm = (WrappedSecurityManager) securityManager;\n            return wsm.wrapped;\n        } else {\n            return securityManager;\n        }\n    }\n\n    private static String getJSFNewViewState(String savedRequest, HttpClient client, String savedFormData)\n            throws IOException, InterruptedException {\n        var getRequest = HttpRequest.newBuilder().uri(URI.create(savedRequest)).GET().build();\n        HttpResponse<String> htmlResponse = client.send(getRequest, HttpResponse.BodyHandlers.ofString());\n        if (htmlResponse.statusCode() == OK) {\n            savedFormData = extractJSFNewViewState(htmlResponse.body(), savedFormData);\n        }\n        return savedFormData;\n    }\n\n    static String extractJSFNewViewState(@NonNull String responseBody, @NonNull String savedFormData) {\n        Elements elts = Jsoup.parse(responseBody).select(String.format(\"input[name=%s]\", FACES_VIEW_STATE));\n        if (!elts.isEmpty()) {\n            String viewState = elts.first().attr(\"value\");\n\n            var matcher = VIEW_STATE_PATTERN.matcher(savedFormData);\n            if (matcher.matches()) {\n                savedFormData = matcher.replaceFirst(String.format(\"$1%s%s$3\",\n                        FACES_VIEW_STATE_EQUALS, viewState));\n                log.debug(\"Encoded w/Replaced ViewState: {}\", savedFormData);\n            }\n        }\n        return savedFormData;\n    }\n\n    static PartialAjaxResult noJSFAjaxRequests(String savedFormData, boolean isStateless) {\n        var partialMatcher = PARTIAL_REQUEST_PATTERN.matcher(savedFormData);\n        boolean hasPartialAjax = partialMatcher.find();\n        return new PartialAjaxResult(isStateless ? savedFormData : INITIAL_AMPERSAND.matcher(partialMatcher\n                .replaceAll(\"\")).replaceFirst(\"\"), hasPartialAjax, isStateless);\n    }\n\n    static boolean isJSFStatefulForm(@NonNull String savedFormData) {\n        var matcher = VIEW_STATE_PATTERN.matcher(savedFormData);\n        return matcher.find() && matcher.groupCount() >= 2\n                && !matcher.group(2).equalsIgnoreCase(\"stateless\");\n    }\n\n    static boolean isJSFClientStateSavingMethod(ServletContext servletContext) {\n        return STATE_SAVING_METHOD_CLIENT.equals(\n                servletContext.getInitParameter(STATE_SAVING_METHOD_PARAM_NAME));\n    }\n}\n","lineNo":373}
{"Refactored Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.shiro.cdi;\n\nimport java.io.Serializable;\nimport java.lang.reflect.ParameterizedType;\nimport java.util.Optional;\nimport java.util.function.Supplier;\nimport javax.enterprise.context.Dependent;\nimport javax.enterprise.context.RequestScoped;\nimport javax.enterprise.inject.Produces;\nimport javax.enterprise.inject.spi.InjectionPoint;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.cdi.annotations.NoSessionCreation;\nimport org.apache.shiro.cdi.annotations.Principal;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.session.InvalidSessionException;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.subject.Subject;\n\n/**\n * Exposes Shiro's SecurityManager, Session and Subject via CDI @Inject\n */\n@SuppressWarnings(\"HideUtilityClassConstructor\")\n@Dependent\n@Slf4j\npublic class ShiroComponentProducer {\n    interface SerializableSupplier<T> extends Supplier<T>, Serializable { }\n\n    @Produces\n    public static SecurityManager getSecurityManager() {\n        return SecurityUtils.getSecurityManager();\n    }\n\n    @Produces\n    @RequestScoped\n    public static Subject getSubject() {\n        return SecurityUtils.getSubject();\n    }\n\n    @Produces\n    @RequestScoped\n    public static Session getSession() {\n        return SecurityUtils.getSubject().getSession();\n    }\n\n    @Produces\n    @NoSessionCreation\n    @RequestScoped\n    public static Session getSessionNoCreation() {\n        return Optional.ofNullable(SecurityUtils.getSubject().getSession(false))\n                .orElseThrow(InvalidSessionException::new);\n    }\n\n    @Produces\n    @Principal\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Supplier<T> getPrincipal(InjectionPoint injectionPoint) {\n        var parameterizedType = (ParameterizedType) injectionPoint.getType();\n        var principalType = (Class<T>) parameterizedType.getActualTypeArguments()[0];\n        SerializableSupplier<T> supplier = () -> SecurityUtils.getSubject().getPrincipals().oneByType(principalType);\n        return supplier;\n    }\n}\n","Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.shiro.cdi;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.util.Optional;\nimport javax.enterprise.context.Dependent;\nimport javax.enterprise.context.RequestScoped;\nimport javax.enterprise.inject.Produces;\nimport javax.enterprise.inject.spi.InjectionPoint;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.cdi.annotations.NoSessionCreation;\nimport org.apache.shiro.cdi.annotations.Principal;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.session.InvalidSessionException;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.subject.Subject;\n\n/**\n * Exposes Shiro's SecurityManager, Session and Subject via CDI @Inject\n */\n@SuppressWarnings(\"HideUtilityClassConstructor\")\n@Dependent\n@Slf4j\npublic class ShiroComponentProducer {\n    @Produces\n    public static SecurityManager getSecurityManager() {\n        return SecurityUtils.getSecurityManager();\n    }\n\n    @Produces\n    @RequestScoped\n    public static Subject getSubject() {\n        return SecurityUtils.getSubject();\n    }\n\n    @Produces\n    @RequestScoped\n    public static Session getSession() {\n        return SecurityUtils.getSubject().getSession();\n    }\n\n    @Produces\n    @NoSessionCreation\n    @RequestScoped\n    public static Session getSessionNoCreation() {\n        return Optional.ofNullable(SecurityUtils.getSubject().getSession(false))\n                .orElseThrow(InvalidSessionException::new);\n    }\n\n    @Produces\n    @Principal\n    @SuppressWarnings(\"unchecked\")\n    public static <T> ShiroPrincipal<T> getPrincipal(InjectionPoint injectionPoint) {\n        var parameterizedType = (ParameterizedType) injectionPoint.getType();\n        return new ShiroPrincipal<>((Class<T>) parameterizedType.getActualTypeArguments()[0]);\n    }\n}\n","lineNo":72}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.jaxrs;\n\n\nimport org.apache.shiro.authz.annotation.RequiresAuthentication;\nimport org.apache.shiro.authz.annotation.RequiresGuest;\nimport org.apache.shiro.authz.annotation.RequiresPermissions;\nimport org.apache.shiro.authz.annotation.RequiresRoles;\nimport org.apache.shiro.authz.annotation.RequiresUser;\nimport org.apache.shiro.web.filter.authz.AuthorizationFilter;\n\nimport javax.ws.rs.Priorities;\nimport javax.ws.rs.container.DynamicFeature;\nimport javax.ws.rs.container.ResourceInfo;\nimport javax.ws.rs.core.FeatureContext;\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport javax.annotation.security.DenyAll;\nimport javax.annotation.security.PermitAll;\nimport javax.annotation.security.RolesAllowed;\nimport static org.apache.shiro.web.jaxrs.SubjectPrincipalRequestFilter.SHIRO_WEB_JAXRS_DISABLE_PRINCIPAL_PARAM;\n\n/**\n * Wraps {@link AuthorizationFilter filters} around JAX-RS resources that are annotated with Shiro annotations.\n * @since 1.4\n */\npublic class ShiroAnnotationFilterFeature implements DynamicFeature {\n    private static final List<Class<? extends Annotation>> shiroAnnotations = List.of(\n            RequiresPermissions.class,\n            RequiresRoles.class,\n            RequiresAuthentication.class,\n            RequiresUser.class,\n            RequiresGuest.class);\n    private static final List<Class<? extends Annotation>> jsr250Annotations = List.of(\n            RolesAllowed.class, PermitAll.class, DenyAll.class);\n\n    @Override\n    public void configure(ResourceInfo resourceInfo, FeatureContext context) {\n        List<Annotation> authzSpecs = new ArrayList<>();\n        var annotations = shiroAnnotations;\n        if (Boolean.TRUE.equals(context.getConfiguration().getProperty(SHIRO_WEB_JAXRS_DISABLE_PRINCIPAL_PARAM))) {\n            annotations = Stream.concat(shiroAnnotations.stream(), jsr250Annotations.stream())\n                    .collect(Collectors.toList());\n        }\n\n        for (Class<? extends Annotation> annotationClass : annotations) {\n            // XXX What is the performance of getAnnotation vs getAnnotations?\n            Annotation classAuthzSpec = resourceInfo.getResourceClass().getAnnotation(annotationClass);\n            Annotation methodAuthzSpec = resourceInfo.getResourceMethod().getAnnotation(annotationClass);\n\n            if (classAuthzSpec != null) authzSpecs.add(classAuthzSpec);\n            if (methodAuthzSpec != null) authzSpecs.add(methodAuthzSpec);\n        }\n\n        if (!authzSpecs.isEmpty()) {\n            context.register(new AnnotationAuthorizationFilter(authzSpecs), Priorities.AUTHORIZATION);\n        }\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.jaxrs;\n\n\nimport org.apache.shiro.authz.annotation.RequiresAuthentication;\nimport org.apache.shiro.authz.annotation.RequiresGuest;\nimport org.apache.shiro.authz.annotation.RequiresPermissions;\nimport org.apache.shiro.authz.annotation.RequiresRoles;\nimport org.apache.shiro.authz.annotation.RequiresUser;\nimport org.apache.shiro.web.filter.authz.AuthorizationFilter;\n\nimport javax.ws.rs.Priorities;\nimport javax.ws.rs.container.DynamicFeature;\nimport javax.ws.rs.container.ResourceInfo;\nimport javax.ws.rs.core.FeatureContext;\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Wraps {@link AuthorizationFilter filters} around JAX-RS resources that are annotated with Shiro annotations.\n * @since 1.4\n */\npublic class ShiroAnnotationFilterFeature implements DynamicFeature {\n\n    private static List<Class<? extends Annotation>> shiroAnnotations = Collections.unmodifiableList(Arrays.asList(\n            RequiresPermissions.class,\n            RequiresRoles.class,\n            RequiresAuthentication.class,\n            RequiresUser.class,\n            RequiresGuest.class));\n\n    @Override\n    public void configure(ResourceInfo resourceInfo, FeatureContext context) {\n\n        List<Annotation> authzSpecs = new ArrayList<Annotation>();\n\n        for (Class<? extends Annotation> annotationClass : shiroAnnotations) {\n            // XXX What is the performance of getAnnotation vs getAnnotations?\n            Annotation classAuthzSpec = resourceInfo.getResourceClass().getAnnotation(annotationClass);\n            Annotation methodAuthzSpec = resourceInfo.getResourceMethod().getAnnotation(annotationClass);\n\n            if (classAuthzSpec != null) authzSpecs.add(classAuthzSpec);\n            if (methodAuthzSpec != null) authzSpecs.add(methodAuthzSpec);\n        }\n\n        if (!authzSpecs.isEmpty()) {\n            context.register(new AnnotationAuthorizationFilter(authzSpecs), Priorities.AUTHORIZATION);\n        }\n    }\n\n}\n","lineNo":60}
{"Refactored Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.shiro.ee.listeners;\n\nimport org.apache.shiro.ee.filters.FormAuthenticationFilter;\nimport org.apache.shiro.ee.filters.LogoutFilter;\nimport org.apache.shiro.ee.filters.SslFilter;\nimport java.util.Map;\nimport javax.servlet.Filter;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.shiro.config.Ini;\nimport org.apache.shiro.web.config.WebIniSecurityManagerFactory;\nimport org.apache.shiro.web.env.IniWebEnvironment;\nimport org.apache.shiro.web.filter.mgt.DefaultFilter;\nimport org.omnifaces.util.Beans;\n\n/**\n * Ability to merge two configuration files, exactly two\n */\n@Slf4j\npublic class IniEnvironment extends IniWebEnvironment {\n    private String otherConfigLocation;\n\n    @SuppressWarnings(\"deprecation\")\n    private static class SecurityManagerFactory extends WebIniSecurityManagerFactory {\n        @Override\n        protected Map<String, ?> createDefaults(Ini ini, Ini.Section mainSection) {\n            @SuppressWarnings(\"unchecked\")\n            Map<String, Filter> defaults = (Map<String, Filter>) super.createDefaults(ini, mainSection);\n            try {\n                // SSL filter must be first because it will trigger an exception if OmniFaces is not available\n                var sslFilter = new SslFilter();\n                defaults.replace(DefaultFilter.authc.name(), new FormAuthenticationFilter());\n                defaults.replace(DefaultFilter.ssl.name(), sslFilter);\n                defaults.replace(DefaultFilter.logout.name(), new LogoutFilter());\n            } catch (Throwable e) {\n                log.warn(\"unable to initialize filters\", e);\n            }\n            return defaults;\n        }\n    }\n\n    public IniEnvironment() {\n        var securityManagerFactory = new SecurityManagerFactory();\n        securityManagerFactory.getReflectionBuilder().setAlternateObjectSupplier(Beans::getInstance);\n        setSecurityManagerFactory(securityManagerFactory);\n    }\n\n    @Override\n    public void setConfigLocations(String[] configLocations) {\n        if (configLocations.length == 2) {\n            otherConfigLocation = configLocations[1];\n            super.setConfigLocations(configLocations[0]);\n        } else {\n            super.setConfigLocations(configLocations);\n        }\n    }\n\n    @Override\n    protected Ini getFrameworkIni() {\n        if (otherConfigLocation != null) {\n            return createIni(otherConfigLocation, true);\n        } else {\n            return super.getFrameworkIni();\n        }\n    }\n}\n","Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.shiro.ee.listeners;\n\nimport org.apache.shiro.ee.filters.FormAuthenticationFilter;\nimport org.apache.shiro.ee.filters.LogoutFilter;\nimport org.apache.shiro.ee.filters.SslFilter;\nimport java.util.Map;\nimport javax.servlet.Filter;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.shiro.config.Ini;\nimport org.apache.shiro.web.config.WebIniSecurityManagerFactory;\nimport org.apache.shiro.web.env.IniWebEnvironment;\nimport org.apache.shiro.web.filter.mgt.DefaultFilter;\n\n/**\n * Ability to merge two configuration files, exactly two\n */\n@Slf4j\npublic class IniEnvironment extends IniWebEnvironment {\n    private String otherConfigLocation;\n\n    @SuppressWarnings(\"deprecation\")\n    private static class SecurityManagerFactory extends WebIniSecurityManagerFactory {\n        @Override\n        protected Map<String, ?> createDefaults(Ini ini, Ini.Section mainSection) {\n            @SuppressWarnings(\"unchecked\")\n            Map<String, Filter> defaults = (Map<String, Filter>) super.createDefaults(ini, mainSection);\n            try {\n                // SSL filter must be first because it will trigger an exception if OmniFaces is not available\n                var sslFilter = new SslFilter();\n                defaults.replace(DefaultFilter.authc.name(), new FormAuthenticationFilter());\n                defaults.replace(DefaultFilter.ssl.name(), sslFilter);\n                defaults.replace(DefaultFilter.logout.name(), new LogoutFilter());\n            } catch (Throwable e) {\n                log.warn(\"unable to initialize filters\", e);\n            }\n            return defaults;\n        }\n    }\n\n    public IniEnvironment() {\n        setSecurityManagerFactory(new SecurityManagerFactory());\n    }\n\n    @Override\n    public void setConfigLocations(String[] configLocations) {\n        if (configLocations.length == 2) {\n            otherConfigLocation = configLocations[1];\n            super.setConfigLocations(configLocations[0]);\n        } else {\n            super.setConfigLocations(configLocations);\n        }\n    }\n\n    @Override\n    protected Ini getFrameworkIni() {\n        if (otherConfigLocation != null) {\n            return createIni(otherConfigLocation, true);\n        } else {\n            return super.getFrameworkIni();\n        }\n    }\n}\n","lineNo":55}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.guice.web;\n\nimport java.util.*;\n\nimport javax.servlet.Filter;\nimport javax.servlet.ServletContext;\n\nimport org.apache.shiro.config.ConfigurationException;\nimport org.apache.shiro.env.Environment;\nimport org.apache.shiro.guice.ShiroModule;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.session.mgt.SessionManager;\nimport org.apache.shiro.lang.util.StringUtils;\nimport org.apache.shiro.web.env.WebEnvironment;\nimport org.apache.shiro.web.filter.InvalidRequestFilter;\nimport org.apache.shiro.web.filter.PathMatchingFilter;\nimport org.apache.shiro.web.filter.authc.AnonymousFilter;\nimport org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter;\nimport org.apache.shiro.web.filter.authc.BearerHttpAuthenticationFilter;\nimport org.apache.shiro.web.filter.authc.FormAuthenticationFilter;\nimport org.apache.shiro.web.filter.authc.LogoutFilter;\nimport org.apache.shiro.web.filter.authc.UserFilter;\nimport org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter;\nimport org.apache.shiro.web.filter.authz.IpFilter;\nimport org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter;\nimport org.apache.shiro.web.filter.authz.PortFilter;\nimport org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;\nimport org.apache.shiro.web.filter.authz.SslFilter;\nimport org.apache.shiro.web.filter.mgt.FilterChainResolver;\nimport org.apache.shiro.web.filter.session.NoSessionCreationFilter;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.apache.shiro.web.mgt.WebSecurityManager;\nimport org.apache.shiro.web.session.mgt.ServletContainerSessionManager;\n\nimport com.google.inject.Binder;\nimport com.google.inject.Key;\nimport com.google.inject.TypeLiteral;\nimport com.google.inject.binder.AnnotatedBindingBuilder;\nimport com.google.inject.name.Names;\nimport com.google.inject.servlet.ServletModule;\n\n/**\n * Sets up Shiro lifecycles within Guice, enables the injecting of Shiro objects, and binds a default\n * {@link org.apache.shiro.web.mgt.WebSecurityManager}, {@link org.apache.shiro.mgt.SecurityManager} and {@link org.apache.shiro.session.mgt.SessionManager}.  At least one realm must be added by\n * using {@link #bindRealm() bindRealm}.\n * <p/>\n * Also provides for the configuring of filter chains and binds a {@link org.apache.shiro.web.filter.mgt.FilterChainResolver} with that information.\n */\npublic abstract class ShiroWebModule extends ShiroModule {\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<AnonymousFilter> ANON = Key.get(AnonymousFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<FormAuthenticationFilter> AUTHC = Key.get(FormAuthenticationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<BasicHttpAuthenticationFilter> AUTHC_BASIC = Key.get(BasicHttpAuthenticationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<BearerHttpAuthenticationFilter> AUTHC_BEARER = Key.get(BearerHttpAuthenticationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<NoSessionCreationFilter> NO_SESSION_CREATION = Key.get(NoSessionCreationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<LogoutFilter> LOGOUT = Key.get(LogoutFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<PermissionsAuthorizationFilter> PERMS = Key.get(PermissionsAuthorizationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<PortFilter> PORT = Key.get(PortFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<HttpMethodPermissionFilter> REST = Key.get(HttpMethodPermissionFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<RolesAuthorizationFilter> ROLES = Key.get(RolesAuthorizationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<SslFilter> SSL = Key.get(SslFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<IpFilter> IP = Key.get(IpFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<UserFilter> USER = Key.get(UserFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<InvalidRequestFilter> INVALID_REQUEST = Key.get(InvalidRequestFilter.class);\n\n    static final String NAME = \"SHIRO\";\n\n    /**\n     * We use a LinkedHashMap here to ensure that iterator order is the same as add order.  This is important, as the\n     * FilterChainResolver uses iterator order when searching for a matching chain.\n     */\n    private final Map<String, FilterConfig<? extends Filter>[]> filterChains = new LinkedHashMap<String, FilterConfig<? extends Filter>[]>();\n    private final ServletContext servletContext;\n\n    public ShiroWebModule(ServletContext servletContext) {\n        this.servletContext = servletContext;\n    }\n\n    public static void bindGuiceFilter(Binder binder) {\n        binder.install(guiceFilterModule());\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static void bindGuiceFilter(final String pattern, Binder binder) {\n        binder.install(guiceFilterModule(pattern));\n    }\n\n    public static ServletModule guiceFilterModule() {\n        return guiceFilterModule(\"/*\");\n    }\n\n    public static ServletModule guiceFilterModule(final String pattern) {\n        return new ServletModule() {\n            @Override\n            protected void configureServlets() {\n                filter(pattern).through(GuiceShiroFilter.class);\n            }\n        };\n    }\n\n    public List<FilterConfig<? extends Filter>> globalFilters() {\n        return Collections.singletonList(filterConfig(INVALID_REQUEST));\n    }\n\n    @Override\n    protected final void configureShiro() {\n        bindBeanType(TypeLiteral.get(ServletContext.class), Key.get(ServletContext.class, Names.named(NAME)));\n        bind(Key.get(ServletContext.class, Names.named(NAME))).toInstance(this.servletContext);\n        bindWebSecurityManager(bind(WebSecurityManager.class));\n        bindWebEnvironment(bind(WebEnvironment.class));\n        bind(GuiceShiroFilter.class).asEagerSingleton();\n        expose(GuiceShiroFilter.class);\n\n        this.configureShiroWeb();\n\n        // add default matching route if not already set\n        if (!filterChains.containsKey(\"/**\")) {\n            // no config, this will add only the global filters\n            this.addFilterChain(\"/**\", new FilterConfig[0]);\n        }\n\n        bind(FilterChainResolver.class).toProvider(new FilterChainResolverProvider(setupFilterChainConfigs()));\n    }\n\n    private Map<String, Key<? extends Filter>[]> setupFilterChainConfigs() {\n\n        // loop through and build a map of Filter Key -> Map<Path, Config>\n        Map<Key<? extends Filter>, Map<String, String>> filterToPathToConfig = new HashMap<Key<? extends Filter>, Map<String, String>>();\n\n        // At the same time build a map to return with Path -> Key[]\n        Map<String, Key<? extends Filter>[]> resultConfigMap = new LinkedHashMap<String, Key<? extends Filter>[]>();\n\n        for (Map.Entry<String, FilterConfig<? extends Filter>[]> filterChain : filterChains.entrySet()) {\n\n            String path = filterChain.getKey();\n\n            // collect the keys used for this path\n            List<Key<? extends Filter>> keysForPath = new ArrayList<Key<? extends Filter>>();\n\n            List<FilterConfig<? extends Filter>> globalFilters = this.globalFilters();\n            FilterConfig<? extends Filter>[] pathFilters = filterChain.getValue();\n\n            // merge the global filters and the path specific filters\n            List<FilterConfig<? extends Filter>> filterConfigs = new ArrayList<>(globalFilters.size() + pathFilters.length);\n            filterConfigs.addAll(globalFilters);\n            filterConfigs.addAll(Arrays.asList(pathFilters));\n\n            for (FilterConfig<? extends Filter> filterConfig : filterConfigs) {\n\n                Key<? extends Filter> key = filterConfig.getKey();\n                String config = filterConfig.getConfigValue();\n\n                // initialize key in filterToPathToConfig, if it doesn't exist\n                if (filterToPathToConfig.get(key) == null) {\n                \t// Fix for SHIRO-621: REST filter bypassing matched path\n                    filterToPathToConfig.put((key), new LinkedHashMap<String, String>());\n                }\n                // now set the value\n                filterToPathToConfig.get(key).put(path, config);\n\n                // Config error if someone configured a non PathMatchingFilter with a config value\n                if (StringUtils.hasText(config) && !PathMatchingFilter.class.isAssignableFrom(key.getTypeLiteral().getRawType())) {\n                    throw new ConfigurationException(\"Config information requires a PathMatchingFilter - can't apply to \" + key.getTypeLiteral().getRawType());\n                }\n\n                // store the key in keysForPath\n                keysForPath.add(key);\n            }\n\n            // map the current path to all of its Keys\n            resultConfigMap.put(path, keysForPath.toArray(new Key[keysForPath.size()]));\n        }\n\n        // now we find only the PathMatchingFilter and configure bindings\n        // non PathMatchingFilter, can be loaded with the default provider via the class name\n        for (Key<? extends Filter> key : filterToPathToConfig.keySet()) {\n            if (PathMatchingFilter.class.isAssignableFrom(key.getTypeLiteral().getRawType())) {\n                bindPathMatchingFilter(castToPathMatching(key), filterToPathToConfig.get(key));\n            }\n            else {\n                bind(key);\n            }\n        }\n\n        return resultConfigMap;\n    }\n\n\n    private <T extends PathMatchingFilter> void bindPathMatchingFilter(Key<T> filterKey, Map<String, String> configs) {\n        bind(filterKey).toProvider(new PathMatchingFilterProvider<T>(filterKey, configs)).asEagerSingleton();\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private Key<? extends PathMatchingFilter> castToPathMatching(Key<? extends Filter> key) {\n        return (Key<? extends PathMatchingFilter>) key;\n    }\n\n    protected abstract void configureShiroWeb();\n\n    @SuppressWarnings({\"unchecked\"})\n    @Override\n    protected final void bindSecurityManager(AnnotatedBindingBuilder<? super SecurityManager> bind) {\n        bind.to(WebSecurityManager.class); // SHIRO-435\n    }\n\n    /**\n     * Binds the security manager.  Override this method in order to provide your own security manager binding.\n     * <p/>\n     * By default, a {@link org.apache.shiro.web.mgt.DefaultWebSecurityManager} is bound as an eager singleton.\n     *\n     * @param bind\n     */\n    protected void bindWebSecurityManager(AnnotatedBindingBuilder<? super WebSecurityManager> bind) {\n        try {\n            bind.toConstructor(DefaultWebSecurityManager.class.getConstructor(Collection.class)).asEagerSingleton();\n        } catch (NoSuchMethodException e) {\n            throw new ConfigurationException(\"This really shouldn't happen.  Either something has changed in Shiro, or there's a bug in ShiroModule.\", e);\n        }\n    }\n\n    /**\n     * Binds the session manager.  Override this method in order to provide your own session manager binding.\n     * <p/>\n     * By default, a {@link org.apache.shiro.web.session.mgt.DefaultWebSessionManager} is bound as an eager singleton.\n     *\n     * @param bind\n     */\n    @Override\n    protected void bindSessionManager(AnnotatedBindingBuilder<SessionManager> bind) {\n        bind.to(ServletContainerSessionManager.class).asEagerSingleton();\n    }\n\n    @Override\n    protected final void bindEnvironment(AnnotatedBindingBuilder<Environment> bind) {\n        bind.to(WebEnvironment.class); // SHIRO-435\n    }\n\n    protected void bindWebEnvironment(AnnotatedBindingBuilder<? super WebEnvironment> bind) {\n        bind.to(WebGuiceEnvironment.class).asEagerSingleton();\n    }\n\n    protected final void addFilterChain(String pattern, Key<? extends Filter> key) {\n        // check for legacy API\n        if (key instanceof FilterConfigKey) {\n            addLegacyFilterChain(pattern, (FilterConfigKey) key);\n        }\n        else {\n            addFilterChain(pattern, new FilterConfig<Filter>((Key<Filter>) key, \"\"));\n        }\n    }\n\n    /**\n     * Maps 'n' number of <code>filterConfig<\/code>s to a specific path pattern.<BR/>\n     * For example, a path of '/my_private_resource/**' to 'filterConfig(AUTHC)' would require\n     * any resource under the path '/my_private_resource' would be processed through the {@link FormAuthenticationFilter}.\n     *\n     * @param pattern URL patter to be mapped to a FilterConfig, e.g. '/my_private-path/**'\n     * @param filterConfigs FilterConfiguration representing the Filter and config to be used when processing resources on <code>pattern<\/code>.\n     * @since 1.4\n     */\n    protected final void addFilterChain(String pattern, FilterConfig<? extends Filter>... filterConfigs) {\n        filterChains.put(pattern, filterConfigs);\n    }\n\n    /**\n     * Builds a FilterConfig from a Filer and configuration String\n     * @param baseKey The Key of the Filter class to be used.\n     * @param <T> A Servlet Filter class.\n     * @return A FilterConfig used to map a String path to this configuration.\n     * @since 1.4\n     */\n    protected static <T extends Filter> FilterConfig<T> filterConfig(Key<T> baseKey, String configValue) {\n        return new FilterConfig<T>(baseKey, configValue);\n    }\n\n    /**\n     * Builds a FilterConfig from a Filer and configuration String\n     * @param baseKey The Key of the Filter class to be used.\n     * @param <T> A Servlet Filter class.\n     * @return A FilterConfig used to map a String path to this configuration.\n     * @since 1.4\n     */\n    protected static <T extends Filter> FilterConfig<T> filterConfig(Key<T> baseKey) {\n        return filterConfig(baseKey, \"\");\n    }\n\n    /**\n     * Builds a FilterConfig from a Filer and configuration String\n     * @param typeLiteral The TyleLiteral of the filter key to be used.\n     * @param configValue the configuration used.\n     * @param <T> A Servlet Filter class.\n     * @return A FilterConfig used to map a String path to this configuration.\n     * @since 1.4\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected static <T extends Filter> FilterConfig<T> filterConfig(TypeLiteral<T> typeLiteral, String configValue) {\n        return filterConfig(Key.get(typeLiteral), configValue);\n    }\n\n    /**\n     * Builds a FilterConfig from a Filer and configuration String\n     * @param type The filter to be used.\n     * @param configValue the configuration used.\n     * @param <T> A Servlet Filter class.\n     * @return A FilterConfig used to map a String path to this configuration.\n     * @since 1.4\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected static <T extends Filter> FilterConfig<T> filterConfig(Class<T> type, String configValue) {\n        return filterConfig(Key.get(type), configValue);\n    }\n\n\n    /**\n     * Filter configuration which pairs a Filter class with its configuration used on a path.\n     * @param <T> The Servlet Filter class.\n     * @since 1.4\n     */\n    public static class FilterConfig<T extends Filter> {\n        private Key<T> key;\n        private String configValue;\n\n        private FilterConfig(Key<T> key, String configValue) {\n            super();\n            this.key = key;\n            this.configValue = configValue;\n        }\n\n        public Key<T> getKey() {\n            return key;\n        }\n\n        public String getConfigValue() {\n            return configValue;\n        }\n    }\n\n\n\n\n\n\n\n    // legacy methods\n\n\n    static boolean isGuiceVersion3() {\n        try {\n            Class.forName(\"com.google.inject.multibindings.MapKey\");\n            return false;\n        } catch (ClassNotFoundException e) {\n            return true;\n        }\n    }\n\n    private void addLegacyFilterChain(String pattern, FilterConfigKey filterConfigKey) {\n\n        FilterConfig<Filter> filterConfig = new FilterConfig<Filter>(filterConfigKey.getKey(), filterConfigKey.getConfigValue());\n        addFilterChain(pattern, filterConfig);\n    }\n\n    /**\n     * Adds a filter chain to the shiro configuration.\n     * <p/>\n     * NOTE: If the provided key is for a subclass of {@link org.apache.shiro.web.filter.PathMatchingFilter}, it will be registered with a proper\n     * provider.\n     *\n     * @param pattern\n     * @param keys\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    @Deprecated\n    protected final void addFilterChain(String pattern, Key<? extends Filter>... keys) {\n\n        // We need to extract the keys and FilterConfigKey and convert to the new format.\n\n        FilterConfig[] filterConfigs = new FilterConfig[keys.length];\n        for (int ii = 0; ii < keys.length; ii++) {\n            Key<? extends Filter> key = keys[ii];\n            // If this is a path matching filter, we need to remember the config\n            if (key instanceof FilterConfigKey) {\n                // legacy config\n                FilterConfigKey legacyKey = (FilterConfigKey) key;\n                filterConfigs[ii] = new FilterConfig(legacyKey.getKey(), legacyKey.getConfigValue());\n            }\n            else {\n                // Some other type of Filter key, no config\n                filterConfigs[ii] = new FilterConfig(key, \"\");\n            }\n        }\n\n        filterChains.put(pattern, filterConfigs);\n    }\n\n    @Deprecated\n    protected static <T extends PathMatchingFilter> Key<T> config(Key<T> baseKey, String configValue) {\n\n        if( !isGuiceVersion3()) {\n            throw new ConfigurationException(\"Method ShiroWebModule.config(Key<? extends PathMatchingFilter>, String configValue), is not supported when using Guice 4+\");\n        }\n\n        return new FilterConfigKey<T>(baseKey, configValue);\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    @Deprecated\n    protected static <T extends PathMatchingFilter> Key<T> config(TypeLiteral<T> typeLiteral, String configValue) {\n        return config(Key.get(typeLiteral), configValue);\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    @Deprecated\n    protected static <T extends PathMatchingFilter> Key<T> config(Class<T> type, String configValue) {\n        return config(Key.get(type), configValue);\n    }\n\n    @Deprecated\n    private static class FilterConfigKey<T extends PathMatchingFilter> extends Key<T> {\n        private Key<T> key;\n        private String configValue;\n\n        private FilterConfigKey(Key<T> key, String configValue) {\n            super();\n            this.key = key;\n            this.configValue = configValue;\n        }\n\n        public Key<T> getKey() {\n            return key;\n        }\n\n        public String getConfigValue() {\n            return configValue;\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.guice.web;\n\nimport java.util.*;\n\nimport javax.servlet.Filter;\nimport javax.servlet.ServletContext;\n\nimport org.apache.shiro.config.ConfigurationException;\nimport org.apache.shiro.env.Environment;\nimport org.apache.shiro.guice.ShiroModule;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.session.mgt.SessionManager;\nimport org.apache.shiro.lang.util.StringUtils;\nimport org.apache.shiro.web.env.WebEnvironment;\nimport org.apache.shiro.web.filter.PathMatchingFilter;\nimport org.apache.shiro.web.filter.authc.AnonymousFilter;\nimport org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter;\nimport org.apache.shiro.web.filter.authc.BearerHttpAuthenticationFilter;\nimport org.apache.shiro.web.filter.authc.FormAuthenticationFilter;\nimport org.apache.shiro.web.filter.authc.LogoutFilter;\nimport org.apache.shiro.web.filter.authc.UserFilter;\nimport org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter;\nimport org.apache.shiro.web.filter.authz.IpFilter;\nimport org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter;\nimport org.apache.shiro.web.filter.authz.PortFilter;\nimport org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;\nimport org.apache.shiro.web.filter.authz.SslFilter;\nimport org.apache.shiro.web.filter.mgt.FilterChainResolver;\nimport org.apache.shiro.web.filter.session.NoSessionCreationFilter;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.apache.shiro.web.mgt.WebSecurityManager;\nimport org.apache.shiro.web.session.mgt.ServletContainerSessionManager;\n\nimport com.google.inject.Binder;\nimport com.google.inject.Key;\nimport com.google.inject.TypeLiteral;\nimport com.google.inject.binder.AnnotatedBindingBuilder;\nimport com.google.inject.name.Names;\nimport com.google.inject.servlet.ServletModule;\n\n/**\n * Sets up Shiro lifecycles within Guice, enables the injecting of Shiro objects, and binds a default\n * {@link org.apache.shiro.web.mgt.WebSecurityManager}, {@link org.apache.shiro.mgt.SecurityManager} and {@link org.apache.shiro.session.mgt.SessionManager}.  At least one realm must be added by\n * using {@link #bindRealm() bindRealm}.\n * <p/>\n * Also provides for the configuring of filter chains and binds a {@link org.apache.shiro.web.filter.mgt.FilterChainResolver} with that information.\n */\npublic abstract class ShiroWebModule extends ShiroModule {\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<AnonymousFilter> ANON = Key.get(AnonymousFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<FormAuthenticationFilter> AUTHC = Key.get(FormAuthenticationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<BasicHttpAuthenticationFilter> AUTHC_BASIC = Key.get(BasicHttpAuthenticationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<BearerHttpAuthenticationFilter> AUTHC_BEARER = Key.get(BearerHttpAuthenticationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<NoSessionCreationFilter> NO_SESSION_CREATION = Key.get(NoSessionCreationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<LogoutFilter> LOGOUT = Key.get(LogoutFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<PermissionsAuthorizationFilter> PERMS = Key.get(PermissionsAuthorizationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<PortFilter> PORT = Key.get(PortFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<HttpMethodPermissionFilter> REST = Key.get(HttpMethodPermissionFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<RolesAuthorizationFilter> ROLES = Key.get(RolesAuthorizationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<SslFilter> SSL = Key.get(SslFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<IpFilter> IP = Key.get(IpFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<UserFilter> USER = Key.get(UserFilter.class);\n\n\n    static final String NAME = \"SHIRO\";\n\n    /**\n     * We use a LinkedHashMap here to ensure that iterator order is the same as add order.  This is important, as the\n     * FilterChainResolver uses iterator order when searching for a matching chain.\n     */\n    private final Map<String, FilterConfig<? extends Filter>[]> filterChains = new LinkedHashMap<String, FilterConfig<? extends Filter>[]>();\n    private final ServletContext servletContext;\n\n    public ShiroWebModule(ServletContext servletContext) {\n        this.servletContext = servletContext;\n    }\n\n    public static void bindGuiceFilter(Binder binder) {\n        binder.install(guiceFilterModule());\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static void bindGuiceFilter(final String pattern, Binder binder) {\n        binder.install(guiceFilterModule(pattern));\n    }\n\n    public static ServletModule guiceFilterModule() {\n        return guiceFilterModule(\"/*\");\n    }\n\n    public static ServletModule guiceFilterModule(final String pattern) {\n        return new ServletModule() {\n            @Override\n            protected void configureServlets() {\n                filter(pattern).through(GuiceShiroFilter.class);\n            }\n        };\n    }\n\n    @Override\n    protected final void configureShiro() {\n        bindBeanType(TypeLiteral.get(ServletContext.class), Key.get(ServletContext.class, Names.named(NAME)));\n        bind(Key.get(ServletContext.class, Names.named(NAME))).toInstance(this.servletContext);\n        bindWebSecurityManager(bind(WebSecurityManager.class));\n        bindWebEnvironment(bind(WebEnvironment.class));\n        bind(GuiceShiroFilter.class).asEagerSingleton();\n        expose(GuiceShiroFilter.class);\n\n        this.configureShiroWeb();\n\n        bind(FilterChainResolver.class).toProvider(new FilterChainResolverProvider(setupFilterChainConfigs()));\n    }\n\n    private Map<String, Key<? extends Filter>[]> setupFilterChainConfigs() {\n\n        // loop through and build a map of Filter Key -> Map<Path, Config>\n        Map<Key<? extends Filter>, Map<String, String>> filterToPathToConfig = new HashMap<Key<? extends Filter>, Map<String, String>>();\n\n        // At the same time build a map to return with Path -> Key[]\n        Map<String, Key<? extends Filter>[]> resultConfigMap = new LinkedHashMap<String, Key<? extends Filter>[]>();\n\n        for (Map.Entry<String, FilterConfig<? extends Filter>[]> filterChain : filterChains.entrySet()) {\n\n            String path = filterChain.getKey();\n\n            // collect the keys used for this path\n            List<Key<? extends Filter>> keysForPath = new ArrayList<Key<? extends Filter>>();\n\n            for (int i = 0; i < filterChain.getValue().length; i++) {\n                FilterConfig<? extends Filter> filterConfig = filterChain.getValue()[i];\n\n                Key<? extends Filter> key = filterConfig.getKey();\n                String config = filterConfig.getConfigValue();\n\n                // initialize key in filterToPathToConfig, if it doesn't exist\n                if (filterToPathToConfig.get(key) == null) {\n                \t// Fix for SHIRO-621: REST filter bypassing matched path\n                    filterToPathToConfig.put((key), new LinkedHashMap<String, String>());\n                }\n                // now set the value\n                filterToPathToConfig.get(key).put(path, config);\n\n                // Config error if someone configured a non PathMatchingFilter with a config value\n                if (StringUtils.hasText(config) && !PathMatchingFilter.class.isAssignableFrom(key.getTypeLiteral().getRawType())) {\n                    throw new ConfigurationException(\"Config information requires a PathMatchingFilter - can't apply to \" + key.getTypeLiteral().getRawType());\n                }\n\n                // store the key in keysForPath\n                keysForPath.add(key);\n            }\n\n            // map the current path to all of its Keys\n            resultConfigMap.put(path, keysForPath.toArray(new Key[keysForPath.size()]));\n        }\n\n        // now we find only the PathMatchingFilter and configure bindings\n        // non PathMatchingFilter, can be loaded with the default provider via the class name\n        for (Key<? extends Filter> key : filterToPathToConfig.keySet()) {\n            if (PathMatchingFilter.class.isAssignableFrom(key.getTypeLiteral().getRawType())) {\n                bindPathMatchingFilter(castToPathMatching(key), filterToPathToConfig.get(key));\n            }\n            else {\n                bind(key);\n            }\n        }\n\n        return resultConfigMap;\n    }\n\n\n    private <T extends PathMatchingFilter> void bindPathMatchingFilter(Key<T> filterKey, Map<String, String> configs) {\n        bind(filterKey).toProvider(new PathMatchingFilterProvider<T>(filterKey, configs)).asEagerSingleton();\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private Key<? extends PathMatchingFilter> castToPathMatching(Key<? extends Filter> key) {\n        return (Key<? extends PathMatchingFilter>) key;\n    }\n\n    protected abstract void configureShiroWeb();\n\n    @SuppressWarnings({\"unchecked\"})\n    @Override\n    protected final void bindSecurityManager(AnnotatedBindingBuilder<? super SecurityManager> bind) {\n        bind.to(WebSecurityManager.class); // SHIRO-435\n    }\n\n    /**\n     * Binds the security manager.  Override this method in order to provide your own security manager binding.\n     * <p/>\n     * By default, a {@link org.apache.shiro.web.mgt.DefaultWebSecurityManager} is bound as an eager singleton.\n     *\n     * @param bind\n     */\n    protected void bindWebSecurityManager(AnnotatedBindingBuilder<? super WebSecurityManager> bind) {\n        try {\n            bind.toConstructor(DefaultWebSecurityManager.class.getConstructor(Collection.class)).asEagerSingleton();\n        } catch (NoSuchMethodException e) {\n            throw new ConfigurationException(\"This really shouldn't happen.  Either something has changed in Shiro, or there's a bug in ShiroModule.\", e);\n        }\n    }\n\n    /**\n     * Binds the session manager.  Override this method in order to provide your own session manager binding.\n     * <p/>\n     * By default, a {@link org.apache.shiro.web.session.mgt.DefaultWebSessionManager} is bound as an eager singleton.\n     *\n     * @param bind\n     */\n    @Override\n    protected void bindSessionManager(AnnotatedBindingBuilder<SessionManager> bind) {\n        bind.to(ServletContainerSessionManager.class).asEagerSingleton();\n    }\n\n    @Override\n    protected final void bindEnvironment(AnnotatedBindingBuilder<Environment> bind) {\n        bind.to(WebEnvironment.class); // SHIRO-435\n    }\n\n    protected void bindWebEnvironment(AnnotatedBindingBuilder<? super WebEnvironment> bind) {\n        bind.to(WebGuiceEnvironment.class).asEagerSingleton();\n    }\n\n    protected final void addFilterChain(String pattern, Key<? extends Filter> key) {\n        // check for legacy API\n        if (key instanceof FilterConfigKey) {\n            addLegacyFilterChain(pattern, (FilterConfigKey) key);\n        }\n        else {\n            addFilterChain(pattern, new FilterConfig<Filter>((Key<Filter>) key, \"\"));\n        }\n    }\n\n    /**\n     * Maps 'n' number of <code>filterConfig<\/code>s to a specific path pattern.<BR/>\n     * For example, a path of '/my_private_resource/**' to 'filterConfig(AUTHC)' would require\n     * any resource under the path '/my_private_resource' would be processed through the {@link FormAuthenticationFilter}.\n     *\n     * @param pattern URL patter to be mapped to a FilterConfig, e.g. '/my_private-path/**'\n     * @param filterConfigs FilterConfiguration representing the Filter and config to be used when processing resources on <code>pattern<\/code>.\n     * @since 1.4\n     */\n    protected final void addFilterChain(String pattern, FilterConfig<? extends Filter>... filterConfigs) {\n        filterChains.put(pattern, filterConfigs);\n    }\n\n    /**\n     * Builds a FilterConfig from a Filer and configuration String\n     * @param baseKey The Key of the Filter class to be used.\n     * @param <T> A Servlet Filter class.\n     * @return A FilterConfig used to map a String path to this configuration.\n     * @since 1.4\n     */\n    protected static <T extends Filter> FilterConfig<T> filterConfig(Key<T> baseKey, String configValue) {\n        return new FilterConfig<T>(baseKey, configValue);\n    }\n\n    /**\n     * Builds a FilterConfig from a Filer and configuration String\n     * @param baseKey The Key of the Filter class to be used.\n     * @param <T> A Servlet Filter class.\n     * @return A FilterConfig used to map a String path to this configuration.\n     * @since 1.4\n     */\n    protected static <T extends Filter> FilterConfig<T> filterConfig(Key<T> baseKey) {\n        return filterConfig(baseKey, \"\");\n    }\n\n    /**\n     * Builds a FilterConfig from a Filer and configuration String\n     * @param typeLiteral The TyleLiteral of the filter key to be used.\n     * @param configValue the configuration used.\n     * @param <T> A Servlet Filter class.\n     * @return A FilterConfig used to map a String path to this configuration.\n     * @since 1.4\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected static <T extends Filter> FilterConfig<T> filterConfig(TypeLiteral<T> typeLiteral, String configValue) {\n        return filterConfig(Key.get(typeLiteral), configValue);\n    }\n\n    /**\n     * Builds a FilterConfig from a Filer and configuration String\n     * @param type The filter to be used.\n     * @param configValue the configuration used.\n     * @param <T> A Servlet Filter class.\n     * @return A FilterConfig used to map a String path to this configuration.\n     * @since 1.4\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected static <T extends Filter> FilterConfig<T> filterConfig(Class<T> type, String configValue) {\n        return filterConfig(Key.get(type), configValue);\n    }\n\n\n    /**\n     * Filter configuration which pairs a Filter class with its configuration used on a path.\n     * @param <T> The Servlet Filter class.\n     * @since 1.4\n     */\n    public static class FilterConfig<T extends Filter> {\n        private Key<T> key;\n        private String configValue;\n\n        private FilterConfig(Key<T> key, String configValue) {\n            super();\n            this.key = key;\n            this.configValue = configValue;\n        }\n\n        public Key<T> getKey() {\n            return key;\n        }\n\n        public String getConfigValue() {\n            return configValue;\n        }\n    }\n\n\n\n\n\n\n\n    // legacy methods\n\n\n    static boolean isGuiceVersion3() {\n        try {\n            Class.forName(\"com.google.inject.multibindings.MapKey\");\n            return false;\n        } catch (ClassNotFoundException e) {\n            return true;\n        }\n    }\n\n    private void addLegacyFilterChain(String pattern, FilterConfigKey filterConfigKey) {\n\n        FilterConfig<Filter> filterConfig = new FilterConfig<Filter>(filterConfigKey.getKey(), filterConfigKey.getConfigValue());\n        addFilterChain(pattern, filterConfig);\n    }\n\n    /**\n     * Adds a filter chain to the shiro configuration.\n     * <p/>\n     * NOTE: If the provided key is for a subclass of {@link org.apache.shiro.web.filter.PathMatchingFilter}, it will be registered with a proper\n     * provider.\n     *\n     * @param pattern\n     * @param keys\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    @Deprecated\n    protected final void addFilterChain(String pattern, Key<? extends Filter>... keys) {\n\n        // We need to extract the keys and FilterConfigKey and convert to the new format.\n\n        FilterConfig[] filterConfigs = new FilterConfig[keys.length];\n        for (int ii = 0; ii < keys.length; ii++) {\n            Key<? extends Filter> key = keys[ii];\n            // If this is a path matching filter, we need to remember the config\n            if (key instanceof FilterConfigKey) {\n                // legacy config\n                FilterConfigKey legacyKey = (FilterConfigKey) key;\n                filterConfigs[ii] = new FilterConfig(legacyKey.getKey(), legacyKey.getConfigValue());\n            }\n            else {\n                // Some other type of Filter key, no config\n                filterConfigs[ii] = new FilterConfig(key, \"\");\n            }\n        }\n\n        filterChains.put(pattern, filterConfigs);\n    }\n\n    @Deprecated\n    protected static <T extends PathMatchingFilter> Key<T> config(Key<T> baseKey, String configValue) {\n\n        if( !isGuiceVersion3()) {\n            throw new ConfigurationException(\"Method ShiroWebModule.config(Key<? extends PathMatchingFilter>, String configValue), is not supported when using Guice 4+\");\n        }\n\n        return new FilterConfigKey<T>(baseKey, configValue);\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    @Deprecated\n    protected static <T extends PathMatchingFilter> Key<T> config(TypeLiteral<T> typeLiteral, String configValue) {\n        return config(Key.get(typeLiteral), configValue);\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    @Deprecated\n    protected static <T extends PathMatchingFilter> Key<T> config(Class<T> type, String configValue) {\n        return config(Key.get(type), configValue);\n    }\n\n    @Deprecated\n    private static class FilterConfigKey<T extends PathMatchingFilter> extends Key<T> {\n        private Key<T> key;\n        private String configValue;\n\n        private FilterConfigKey(Key<T> key, String configValue) {\n            super();\n            this.key = key;\n            this.configValue = configValue;\n        }\n\n        public Key<T> getKey() {\n            return key;\n        }\n\n        public String getConfigValue() {\n            return configValue;\n        }\n    }\n\n}\n","lineNo":172}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.util;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.util.Map;\n\n/**\n * View that redirects to an absolute, context relative, or current request\n * relative URL, exposing all model attributes as HTTP query parameters.\n * <p/>\n * A URL for this view is supposed to be a HTTP redirect URL, i.e.\n * suitable for HttpServletResponse's <code>sendRedirect<\/code> method, which\n * is what actually does the redirect if the HTTP 1.0 flag is on, or via sending\n * back an HTTP 303 code - if the HTTP 1.0 compatibility flag is off.\n * <p/>\n * Note that while the default value for the \"contextRelative\" flag is off,\n * you will probably want to almost always set it to true. With the flag off,\n * URLs starting with \"/\" are considered relative to the web server root, while\n * with the flag on, they are considered relative to the web application root.\n * Since most web apps will never know or care what their context path actually\n * is, they are much better off setting this flag to true, and submitting paths\n * which are to be considered relative to the web application root.\n * <p/>\n * Note that in a Servlet 2.2 environment, i.e. a servlet container which\n * is only compliant to the limits of this spec, this class will probably fail\n * when feeding in URLs which are not fully absolute, or relative to the current\n * request (no leading \"/\"), as these are the only two types of URL that\n * <code>sendRedirect<\/code> supports in a Servlet 2.2 environment.\n * <p/>\n * <em>This class was borrowed from a nearly identical version found in\n * the <a href=\"http://www.springframework.org/\">Spring Framework<\/a>, with minor modifications to\n * avoid a dependency on Spring itself for a very small amount of code - we couldn't have done it better, and\n * don't want to repeat all of their great effort ;).\n * The original author names and copyright (Apache 2.0) has been left in place.  A special\n * thanks to Rod Johnson, Juergen Hoeller, and Colin Sampaleanu for making this available.<\/em>\n *\n * @see #setContextRelative\n * @see #setHttp10Compatible\n * @see javax.servlet.http.HttpServletResponse#sendRedirect\n * @since 0.2\n */\npublic class RedirectView {\n\n    //TODO - complete JavaDoc\n\n    /**\n     * The default encoding scheme: UTF-8\n     */\n    public static final String DEFAULT_ENCODING_SCHEME = \"UTF-8\";\n\n    private String url;\n\n    private boolean contextRelative = false;\n\n    private boolean http10Compatible = true;\n\n    private String encodingScheme = DEFAULT_ENCODING_SCHEME;\n\n    /**\n     * Constructor for use as a bean.\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public RedirectView() {\n    }\n\n    /**\n     * Create a new RedirectView with the given URL.\n     * <p>The given URL will be considered as relative to the web server,\n     * not as relative to the current ServletContext.\n     *\n     * @param url the URL to redirect to\n     * @see #RedirectView(String, boolean)\n     */\n    public RedirectView(String url) {\n        setUrl(url);\n    }\n\n    /**\n     * Create a new RedirectView with the given URL.\n     *\n     * @param url             the URL to redirect to\n     * @param contextRelative whether to interpret the given URL as\n     *                        relative to the current ServletContext\n     */\n    public RedirectView(String url, boolean contextRelative) {\n        this(url);\n        this.contextRelative = contextRelative;\n    }\n\n    /**\n     * Create a new RedirectView with the given URL.\n     *\n     * @param url              the URL to redirect to\n     * @param contextRelative  whether to interpret the given URL as\n     *                         relative to the current ServletContext\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients\n     */\n    public RedirectView(String url, boolean contextRelative, boolean http10Compatible) {\n        this(url);\n        this.contextRelative = contextRelative;\n        this.http10Compatible = http10Compatible;\n    }\n\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    /**\n     * Set whether to interpret a given URL that starts with a slash (\"/\")\n     * as relative to the current ServletContext, i.e. as relative to the\n     * web application root.\n     * <p/>\n     * Default is \"false\": A URL that starts with a slash will be interpreted\n     * as absolute, i.e. taken as-is. If true, the context path will be\n     * prepended to the URL in such a case.\n     *\n     * @param contextRelative whether to interpret a given URL that starts with a slash (\"/\")\n     *                        as relative to the current ServletContext, i.e. as relative to the\n     *                        web application root.\n     * @see javax.servlet.http.HttpServletRequest#getContextPath\n     */\n    public void setContextRelative(boolean contextRelative) {\n        this.contextRelative = contextRelative;\n    }\n\n    /**\n     * Set whether to stay compatible with HTTP 1.0 clients.\n     * <p>In the default implementation, this will enforce HTTP status code 302\n     * in any case, i.e. delegate to <code>HttpServletResponse.sendRedirect<\/code>.\n     * Turning this off will send HTTP status code 303, which is the correct\n     * code for HTTP 1.1 clients, but not understood by HTTP 1.0 clients.\n     * <p>Many HTTP 1.1 clients treat 302 just like 303, not making any\n     * difference. However, some clients depend on 303 when redirecting\n     * after a POST request; turn this flag off in such a scenario.\n     *\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @see javax.servlet.http.HttpServletResponse#sendRedirect\n     */\n    public void setHttp10Compatible(boolean http10Compatible) {\n        this.http10Compatible = http10Compatible;\n    }\n\n    /**\n     * Set the encoding scheme for this view. Default is UTF-8.\n     *\n     * @param encodingScheme the encoding scheme for this view. Default is UTF-8.\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public void setEncodingScheme(String encodingScheme) {\n        this.encodingScheme = encodingScheme;\n    }\n\n\n    /**\n     * Convert model to request parameters and redirect to the given URL.\n     *\n     * @param model    the model to convert\n     * @param request  the incoming HttpServletRequest\n     * @param response the outgoing HttpServletResponse\n     * @throws java.io.IOException if there is a problem issuing the redirect\n     * @see #appendQueryProperties\n     * @see #sendRedirect\n     */\n    public final void renderMergedOutputModel(\n            Map model, HttpServletRequest request, HttpServletResponse response) throws IOException {\n\n        // Prepare name URL.\n        StringBuilder targetUrl = new StringBuilder();\n        if (this.contextRelative && getUrl().startsWith(\"/\")) {\n            // Do not apply context path to relative URLs.\n            targetUrl.append(request.getContextPath());\n        }\n        targetUrl.append(getUrl());\n        //change the following method to accept a StringBuilder instead of a StringBuilder for Shiro 2.x:\n        appendQueryProperties(targetUrl, model, this.encodingScheme);\n\n        sendRedirect(request, response, targetUrl.toString(), this.http10Compatible);\n    }\n\n    /**\n     * Append query properties to the redirect URL.\n     * Stringifies, URL-encodes and formats model attributes as query properties.\n     *\n     * @param targetUrl      the StringBuffer to append the properties to\n     * @param model          Map that contains model attributes\n     * @param encodingScheme the encoding scheme to use\n     * @throws java.io.UnsupportedEncodingException if string encoding failed\n     * @see #urlEncode\n     * @see #queryProperties\n     * @see #urlEncode(String, String)\n     */\n    protected void appendQueryProperties(StringBuilder targetUrl, Map model, String encodingScheme)\n            throws UnsupportedEncodingException {\n\n        // Extract anchor fragment, if any.\n        // The following code does not use JDK 1.4's StringBuffer.indexOf(String)\n        // method to retain JDK 1.3 compatibility.\n        String fragment = null;\n        int anchorIndex = targetUrl.toString().indexOf('#');\n        if (anchorIndex > -1) {\n            fragment = targetUrl.substring(anchorIndex);\n            targetUrl.delete(anchorIndex, targetUrl.length());\n        }\n\n        // If there aren't already some parameters, we need a \"?\".\n        boolean first = (getUrl().indexOf('?') < 0);\n        Map queryProps = queryProperties(model);\n\n        if (queryProps != null) {\n            for (Object o : queryProps.entrySet()) {\n                if (first) {\n                    targetUrl.append('?');\n                    first = false;\n                } else {\n                    targetUrl.append('&');\n                }\n                Map.Entry entry = (Map.Entry) o;\n                String encodedKey = urlEncode(entry.getKey().toString(), encodingScheme);\n                String encodedValue =\n                        (entry.getValue() != null ? urlEncode(entry.getValue().toString(), encodingScheme) : \"\");\n                targetUrl.append(encodedKey).append('=').append(encodedValue);\n            }\n        }\n\n        // Append anchor fragment, if any, to end of URL.\n        if (fragment != null) {\n            targetUrl.append(fragment);\n        }\n    }\n\n    /**\n     * URL-encode the given input String with the given encoding scheme, using\n     * {@link URLEncoder#encode(String, String) URLEncoder.encode(input, enc)}.\n     *\n     * @param input          the unencoded input String\n     * @param encodingScheme the encoding scheme\n     * @return the encoded output String\n     * @throws UnsupportedEncodingException if thrown by the JDK URLEncoder\n     * @see java.net.URLEncoder#encode(String, String)\n     * @see java.net.URLEncoder#encode(String)\n     */\n    protected String urlEncode(String input, String encodingScheme) throws UnsupportedEncodingException {\n        return URLEncoder.encode(input, encodingScheme);\n    }\n\n    /**\n     * Determine name-value pairs for query strings, which will be stringified,\n     * URL-encoded and formatted by appendQueryProperties.\n     * <p/>\n     * This implementation returns all model elements as-is.\n     *\n     * @param model the model elements for which to determine name-value pairs.\n     * @return the name-value pairs for query strings.\n     * @see #appendQueryProperties\n     */\n    protected Map queryProperties(Map model) {\n        return model;\n    }\n\n    /**\n     * Send a redirect back to the HTTP client\n     *\n     * @param request          current HTTP request (allows for reacting to request method)\n     * @param response         current HTTP response (for sending response headers)\n     * @param targetUrl        the name URL to redirect to\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients\n     * @throws IOException if thrown by response methods\n     */\n    protected void sendRedirect(HttpServletRequest request, HttpServletResponse response,\n                                String targetUrl, boolean http10Compatible) throws IOException {\n        String encodedRedirectURL = response.encodeRedirectURL(targetUrl);\n        if (http10Compatible) {\n            // Always send status code 302.\n            response.sendRedirect(encodedRedirectURL);\n        } else {\n            // Correct HTTP status code is 303, in particular for POST requests.\n            response.setStatus(303);\n            response.setHeader(\"Location\", encodedRedirectURL);\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.util;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.util.Map;\n\n/**\n * View that redirects to an absolute, context relative, or current request\n * relative URL, exposing all model attributes as HTTP query parameters.\n * <p/>\n * A URL for this view is supposed to be a HTTP redirect URL, i.e.\n * suitable for HttpServletResponse's <code>sendRedirect<\/code> method, which\n * is what actually does the redirect if the HTTP 1.0 flag is on, or via sending\n * back an HTTP 303 code - if the HTTP 1.0 compatibility flag is off.\n * <p/>\n * Note that while the default value for the \"contextRelative\" flag is off,\n * you will probably want to almost always set it to true. With the flag off,\n * URLs starting with \"/\" are considered relative to the web server root, while\n * with the flag on, they are considered relative to the web application root.\n * Since most web apps will never know or care what their context path actually\n * is, they are much better off setting this flag to true, and submitting paths\n * which are to be considered relative to the web application root.\n * <p/>\n * Note that in a Servlet 2.2 environment, i.e. a servlet container which\n * is only compliant to the limits of this spec, this class will probably fail\n * when feeding in URLs which are not fully absolute, or relative to the current\n * request (no leading \"/\"), as these are the only two types of URL that\n * <code>sendRedirect<\/code> supports in a Servlet 2.2 environment.\n * <p/>\n * <em>This class was borrowed from a nearly identical version found in\n * the <a href=\"http://www.springframework.org/\">Spring Framework<\/a>, with minor modifications to\n * avoid a dependency on Spring itself for a very small amount of code - we couldn't have done it better, and\n * don't want to repeat all of their great effort ;).\n * The original author names and copyright (Apache 2.0) has been left in place.  A special\n * thanks to Rod Johnson, Juergen Hoeller, and Colin Sampaleanu for making this available.<\/em>\n *\n * @see #setContextRelative\n * @see #setHttp10Compatible\n * @see javax.servlet.http.HttpServletResponse#sendRedirect\n * @since 0.2\n */\npublic class RedirectView {\n\n    //TODO - complete JavaDoc\n\n    /**\n     * The default encoding scheme: UTF-8\n     */\n    public static final String DEFAULT_ENCODING_SCHEME = \"UTF-8\";\n\n    private String url;\n\n    private boolean contextRelative = false;\n\n    private boolean http10Compatible = true;\n\n    private String encodingScheme = DEFAULT_ENCODING_SCHEME;\n\n    /**\n     * Constructor for use as a bean.\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public RedirectView() {\n    }\n\n    /**\n     * Create a new RedirectView with the given URL.\n     * <p>The given URL will be considered as relative to the web server,\n     * not as relative to the current ServletContext.\n     *\n     * @param url the URL to redirect to\n     * @see #RedirectView(String, boolean)\n     */\n    public RedirectView(String url) {\n        setUrl(url);\n    }\n\n    /**\n     * Create a new RedirectView with the given URL.\n     *\n     * @param url             the URL to redirect to\n     * @param contextRelative whether to interpret the given URL as\n     *                        relative to the current ServletContext\n     */\n    public RedirectView(String url, boolean contextRelative) {\n        this(url);\n        this.contextRelative = contextRelative;\n    }\n\n    /**\n     * Create a new RedirectView with the given URL.\n     *\n     * @param url              the URL to redirect to\n     * @param contextRelative  whether to interpret the given URL as\n     *                         relative to the current ServletContext\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients\n     */\n    public RedirectView(String url, boolean contextRelative, boolean http10Compatible) {\n        this(url);\n        this.contextRelative = contextRelative;\n        this.http10Compatible = http10Compatible;\n    }\n\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    /**\n     * Set whether to interpret a given URL that starts with a slash (\"/\")\n     * as relative to the current ServletContext, i.e. as relative to the\n     * web application root.\n     * <p/>\n     * Default is \"false\": A URL that starts with a slash will be interpreted\n     * as absolute, i.e. taken as-is. If true, the context path will be\n     * prepended to the URL in such a case.\n     *\n     * @param contextRelative whether to interpret a given URL that starts with a slash (\"/\")\n     *                        as relative to the current ServletContext, i.e. as relative to the\n     *                        web application root.\n     * @see javax.servlet.http.HttpServletRequest#getContextPath\n     */\n    public void setContextRelative(boolean contextRelative) {\n        this.contextRelative = contextRelative;\n    }\n\n    /**\n     * Set whether to stay compatible with HTTP 1.0 clients.\n     * <p>In the default implementation, this will enforce HTTP status code 302\n     * in any case, i.e. delegate to <code>HttpServletResponse.sendRedirect<\/code>.\n     * Turning this off will send HTTP status code 303, which is the correct\n     * code for HTTP 1.1 clients, but not understood by HTTP 1.0 clients.\n     * <p>Many HTTP 1.1 clients treat 302 just like 303, not making any\n     * difference. However, some clients depend on 303 when redirecting\n     * after a POST request; turn this flag off in such a scenario.\n     *\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @see javax.servlet.http.HttpServletResponse#sendRedirect\n     */\n    public void setHttp10Compatible(boolean http10Compatible) {\n        this.http10Compatible = http10Compatible;\n    }\n\n    /**\n     * Set the encoding scheme for this view. Default is UTF-8.\n     *\n     * @param encodingScheme the encoding scheme for this view. Default is UTF-8.\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public void setEncodingScheme(String encodingScheme) {\n        this.encodingScheme = encodingScheme;\n    }\n\n\n    /**\n     * Convert model to request parameters and redirect to the given URL.\n     *\n     * @param model    the model to convert\n     * @param request  the incoming HttpServletRequest\n     * @param response the outgoing HttpServletResponse\n     * @throws java.io.IOException if there is a problem issuing the redirect\n     * @see #appendQueryProperties\n     * @see #sendRedirect\n     */\n    public final void renderMergedOutputModel(\n            Map model, HttpServletRequest request, HttpServletResponse response) throws IOException {\n\n        // Prepare name URL.\n        StringBuilder targetUrl = new StringBuilder();\n        if (this.contextRelative && getUrl().startsWith(\"/\")) {\n            // Do not apply context path to relative URLs.\n            targetUrl.append(request.getContextPath());\n        }\n        targetUrl.append(getUrl());\n        //change the following method to accept a StringBuilder instead of a StringBuilder for Shiro 2.x:\n        appendQueryProperties(targetUrl, model, this.encodingScheme);\n\n        sendRedirect(request, response, targetUrl.toString(), this.http10Compatible);\n    }\n\n    /**\n     * Append query properties to the redirect URL.\n     * Stringifies, URL-encodes and formats model attributes as query properties.\n     *\n     * @param targetUrl      the StringBuffer to append the properties to\n     * @param model          Map that contains model attributes\n     * @param encodingScheme the encoding scheme to use\n     * @throws java.io.UnsupportedEncodingException if string encoding failed\n     * @see #urlEncode\n     * @see #queryProperties\n     * @see #urlEncode(String, String)\n     */\n    protected void appendQueryProperties(StringBuilder targetUrl, Map model, String encodingScheme)\n            throws UnsupportedEncodingException {\n\n        // Extract anchor fragment, if any.\n        // The following code does not use JDK 1.4's StringBuffer.indexOf(String)\n        // method to retain JDK 1.3 compatibility.\n        String fragment = null;\n        int anchorIndex = targetUrl.toString().indexOf('#');\n        if (anchorIndex > -1) {\n            fragment = targetUrl.substring(anchorIndex);\n            targetUrl.delete(anchorIndex, targetUrl.length());\n        }\n\n        // If there aren't already some parameters, we need a \"?\".\n        boolean first = (getUrl().indexOf('?') < 0);\n        Map queryProps = queryProperties(model);\n\n        if (queryProps != null) {\n            for (Object o : queryProps.entrySet()) {\n                if (first) {\n                    targetUrl.append('?');\n                    first = false;\n                } else {\n                    targetUrl.append('&');\n                }\n                Map.Entry entry = (Map.Entry) o;\n                String encodedKey = urlEncode(entry.getKey().toString(), encodingScheme);\n                String encodedValue =\n                        (entry.getValue() != null ? urlEncode(entry.getValue().toString(), encodingScheme) : \"\");\n                targetUrl.append(encodedKey).append('=').append(encodedValue);\n            }\n        }\n\n        // Append anchor fragment, if any, to end of URL.\n        if (fragment != null) {\n            targetUrl.append(fragment);\n        }\n    }\n\n    /**\n     * URL-encode the given input String with the given encoding scheme, using\n     * {@link URLEncoder#encode(String, String) URLEncoder.encode(input, enc)}.\n     *\n     * @param input          the unencoded input String\n     * @param encodingScheme the encoding scheme\n     * @return the encoded output String\n     * @throws UnsupportedEncodingException if thrown by the JDK URLEncoder\n     * @see java.net.URLEncoder#encode(String, String)\n     * @see java.net.URLEncoder#encode(String)\n     */\n    protected String urlEncode(String input, String encodingScheme) throws UnsupportedEncodingException {\n        return URLEncoder.encode(input, encodingScheme);\n    }\n\n    /**\n     * Determine name-value pairs for query strings, which will be stringified,\n     * URL-encoded and formatted by appendQueryProperties.\n     * <p/>\n     * This implementation returns all model elements as-is.\n     *\n     * @param model the model elements for which to determine name-value pairs.\n     * @return the name-value pairs for query strings.\n     * @see #appendQueryProperties\n     */\n    protected Map queryProperties(Map model) {\n        return model;\n    }\n\n    /**\n     * Send a redirect back to the HTTP client\n     *\n     * @param request          current HTTP request (allows for reacting to request method)\n     * @param response         current HTTP response (for sending response headers)\n     * @param targetUrl        the name URL to redirect to\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients\n     * @throws IOException if thrown by response methods\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected void sendRedirect(HttpServletRequest request, HttpServletResponse response,\n                                String targetUrl, boolean http10Compatible) throws IOException {\n        if (http10Compatible) {\n            // Always send status code 302.\n            response.sendRedirect(response.encodeRedirectURL(targetUrl));\n        } else {\n            // Correct HTTP status code is 303, in particular for POST requests.\n            response.setStatus(303);\n            response.setHeader(\"Location\", response.encodeRedirectURL(targetUrl));\n        }\n    }\n\n}\n","lineNo":297}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.realm.jdbc;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.IncorrectCredentialsException;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.codec.Base64;\nimport org.apache.shiro.codec.CodecSupport;\nimport org.apache.shiro.config.Ini;\nimport org.apache.shiro.config.IniSecurityManagerFactory;\nimport org.apache.shiro.crypto.hash.Sha256Hash;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.util.JdbcUtils;\nimport org.apache.shiro.util.ThreadContext;\nimport org.hsqldb.jdbc.JDBCDataSource;\nimport org.junit.*;\nimport org.junit.rules.TestName;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.HashMap;\n\n\n/**\n * Test case for JDBCRealm.\n */\npublic class JDBCRealmTest {\n\n    protected DefaultSecurityManager securityManager = null;\n    protected AuthorizingRealm realm;\n    protected final String username = \"testUser\";\n    protected final String plainTextPassword = \"testPassword\";\n    protected final String salt = username;  //Default impl of getSaltForUser returns username\n    protected final String testRole = \"testRole\";\n    protected final String testPermissionString = \"testDomain:testTarget:testAction\";\n    \n    // Maps keyed on test method name so setup/teardown can manage per test resources\n    protected HashMap<String, JdbcRealm> realmMap = new HashMap<String, JdbcRealm>();\n    protected HashMap<String, DataSource> dsMap = new HashMap<String, DataSource>();\n\n    @Rule \n    public TestName name = new TestName();\n\n    @Before\n    public void setup() {\n        ThreadContext.remove();\n        Ini config = new Ini();\n        config.setSectionProperty(\"main\", \"myRealm\", \"org.apache.shiro.realm.jdbc.JdbcRealm\");\n        config.setSectionProperty(\"main\", \"myRealmCredentialsMatcher\", \"org.apache.shiro.authc.credential.Sha256CredentialsMatcher\");\n        config.setSectionProperty(\"main\", \"myRealm.credentialsMatcher\", \"$myRealmCredentialsMatcher\");\n        config.setSectionProperty(\"main\", \"securityManager.sessionManager.sessionValidationSchedulerEnabled\", \"false\");\n        \n        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(config);\n        securityManager = (DefaultSecurityManager) factory.createInstance();\n        SecurityUtils.setSecurityManager(securityManager);\n        \n        // Create a database and realm for the test\n        createRealm(name.getMethodName()); \n    }\n\n    @After\n    public void tearDown() {\n        final String testName = name.getMethodName();\n        shutDown(testName);\n        SecurityUtils.setSecurityManager(null);\n        securityManager.destroy();\n        ThreadContext.remove();\n    }\n    \n    @Test\n    public void testUnSaltedSuccess() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createDefaultSchema(testMethodName, false);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);\n        currentUser.login(token);\n        currentUser.logout();\n    }\n    \n    @Test\n    public void testUnSaltedWrongPassword() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createDefaultSchema(testMethodName, false);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, \"passwrd\");\n        try {\n            currentUser.login(token);\n        } catch (IncorrectCredentialsException ex) {\n            // Expected\n        }\n    }\n    \n    @Test\n    public void testUnSaltedMultipleRows() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createDefaultSchema(testMethodName, false);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);\n        Connection conn = dsMap.get(testMethodName).getConnection();\n        Statement sql = conn.createStatement();\n        sql.executeUpdate(\"insert into users values ('\" + username + \"', 'dupe')\");\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, \"passwrd\");\n        try {\n            currentUser.login(token);\n        } catch (AuthenticationException ex) {\n            // Expected\n        }\n    }\n    \n    @Test\n    public void testSaltColumnSuccess() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createSaltColumnSchema(testMethodName, false);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.COLUMN);\n        realm.setSaltIsBase64Encoded(false);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);\n        currentUser.login(token);\n        currentUser.logout();\n    }\n    \n    @Test\n    public void testBase64EncodedSaltColumnSuccess() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createSaltColumnSchema(testMethodName, true);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.COLUMN);\n\n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);\n        currentUser.login(token);\n        currentUser.logout();\n    }\n\n    @Test\n    public void testSaltColumnWrongPassword() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createSaltColumnSchema(testMethodName, false);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.COLUMN);\n        realm.setSaltIsBase64Encoded(false);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, \"passwrd\");\n        try {\n            currentUser.login(token);\n        } catch (IncorrectCredentialsException ex) {\n            // Expected\n        }\n    }\n\n    @Test\n    public void testBase64SaltColumnWrongPassword() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createSaltColumnSchema(testMethodName, true);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.COLUMN);\n        realm.setSaltIsBase64Encoded(false);\n\n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, \"passwrd\");\n        try {\n            currentUser.login(token);\n        } catch (IncorrectCredentialsException ex) {\n            // Expected\n        }\n    }\n    \n    @Test\n    public void testExternalSuccess() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createDefaultSchema(testMethodName, true);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.EXTERNAL);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);\n        currentUser.login(token);\n        currentUser.logout();\n    }\n    \n    @Test\n    public void testExternalWrongPassword() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createDefaultSchema(testMethodName, true);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.EXTERNAL);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, \"passwrd\");\n        try {\n            currentUser.login(token);\n        } catch (IncorrectCredentialsException ex) {\n            // Expected\n        }\n    }\n    \n    @Test\n    public void testRolePresent() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createDefaultSchema(testMethodName, false);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);\n        currentUser.login(token);\n        Assert.assertTrue(currentUser.hasRole(testRole));\n    }\n    \n    @Test\n    public void testRoleNotPresent() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createDefaultSchema(testMethodName, false);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);\n        currentUser.login(token);\n        Assert.assertFalse(currentUser.hasRole(\"Game Overall Director\"));\n    }\n    \n    @Test\n    public void testPermissionPresent() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createDefaultSchema(testMethodName, false);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);\n        realm.setPermissionsLookupEnabled(true);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);\n        currentUser.login(token);\n        Assert.assertTrue(currentUser.isPermitted(testPermissionString));\n    }\n    \n    @Test\n    public void testPermissionNotPresent() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createDefaultSchema(testMethodName, false);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);\n        realm.setPermissionsLookupEnabled(true);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);\n        currentUser.login(token);\n        Assert.assertFalse(currentUser.isPermitted(\"testDomain:testTarget:specialAction\"));\n    }\n    \n    /**\n     * Creates a realm for a test method and puts it in the realMap.\n     */\n    protected void createRealm(String testMethodName) {\n        JdbcRealm realm = (JdbcRealm) securityManager.getRealms().iterator().next();\n        realmMap.put(testMethodName, realm);\n    }\n    \n    /**\n     * Shuts down the database and removes the realm from the realm map.\n     */\n    protected void shutDown(String testName) {\n        Connection conn = null;\n        Statement sql = null;\n        DataSource ds = dsMap.get(testName);\n        try {\n            Connection c = ds.getConnection();\n            Statement s = c.createStatement();\n            s.executeUpdate(\"SHUTDOWN\");\n        } catch (SQLException ex) {\n            // ignore\n        } finally {\n            JdbcUtils.closeStatement(sql);\n            JdbcUtils.closeConnection(conn);\n            dsMap.remove(testName);\n            realmMap.remove(testName);\n        }\n    }\n    \n    /**\n     * Creates a test database with the default (no separate salt column) schema, salting with\n     * username if salted is true. Sets the DataSource of the realm associated with the test\n     * to a DataSource connected to the database.  (To prevent concurrency problems when tests\n     * are executed in multithreaded mode, each test method gets its own database.)\n     */\n    protected void createDefaultSchema(String testName, boolean salted) {\n        JDBCDataSource ds = new JDBCDataSource();\n        ds.setDatabase(\"jdbc:hsqldb:mem:\" + name);\n        ds.setUser(\"SA\");\n        ds.setPassword(\"\");\n        Connection conn = null;\n        Statement sql = null;\n        try {\n            conn = ds.getConnection();\n            sql = conn.createStatement();\n            sql.executeUpdate(\"create table users (username varchar(20), password varchar(100))\");\n            Sha256Hash sha256Hash = salted ? new Sha256Hash(plainTextPassword, salt) :\n                new Sha256Hash(plainTextPassword);\n            String password = sha256Hash.toHex();\n            sql.executeUpdate(\"insert into users values ('\" + username + \"', '\" + password + \"')\");\n        } catch (SQLException ex) {\n            Assert.fail(\"Exception creating test database\");\n        } finally {\n            JdbcUtils.closeStatement(sql);\n            JdbcUtils.closeConnection(conn);\n        }\n        createRolesAndPermissions(ds);\n        realmMap.get(testName).setDataSource(ds);\n        dsMap.put(testName, ds);\n    }\n    \n    /**\n     * Creates a test database with a separate salt column in the users table. Sets the\n     * DataSource of the realm associated with the test to a DataSource connected to the database.\n     * @param The name of the test which is used as the key when saving the created realm in the realmMap\n     * @param base64EncodeSalt if true, the salt will be base64 encoded before it's stored in the database\n     */\n    protected void createSaltColumnSchema(String testName, boolean base64EncodeSalt) {\n        JDBCDataSource ds = new JDBCDataSource();\n        ds.setDatabase(\"jdbc:hsqldb:mem:\" + name);\n        ds.setUser(\"SA\");\n        ds.setPassword(\"\");\n        Connection conn = null;\n        Statement sql = null;\n        try {\n            conn = ds.getConnection();\n            sql = conn.createStatement();\n            sql.executeUpdate(\n                    \"create table users (username varchar(20), password varchar(100), password_salt varchar(20))\");\n            Sha256Hash sha256Hash = new Sha256Hash(plainTextPassword, salt);\n            String password = sha256Hash.toHex();\n            String maybeBase64EncodedSalt = base64EncodeSalt ? Base64.encodeToString(CodecSupport.toBytes(salt)) : salt;\n            sql.executeUpdate(\"insert into users values ('\" + username + \"', '\" + password + \"', '\" + maybeBase64EncodedSalt + \"')\");\n        } catch (SQLException ex) {\n            Assert.fail(\"Exception creating test database\");\n        } finally {\n            JdbcUtils.closeStatement(sql);\n            JdbcUtils.closeConnection(conn);\n        }\n        createRolesAndPermissions(ds);\n        realmMap.get(testName).setDataSource(ds);\n        dsMap.put(testName, ds);\n    }\n    \n    /**\n     * Creates and adds test data to user_role and roles_permissions tables.\n     */\n    protected void createRolesAndPermissions(DataSource ds) {\n        Connection conn = null;;\n        Statement sql = null;\n        try {\n            conn = ds.getConnection();\n            sql = conn.createStatement();\n            sql.executeUpdate(\"create table user_roles (username varchar(20), role_name varchar(20))\");\n            sql.executeUpdate(\"insert into user_roles values ('\" + username + \"', '\" + testRole + \"')\");\n            sql.executeUpdate(\"create table roles_permissions (role_name varchar(20), permission varchar(40))\");\n            sql.executeUpdate(\n                    \"insert into roles_permissions values ('\" + testRole + \"', '\" + testPermissionString + \"')\");\n        } catch (SQLException ex) {\n            Assert.fail(\"Exception adding test role and permission\");\n        } finally {\n            JdbcUtils.closeStatement(sql);\n            JdbcUtils.closeConnection(conn);\n        }\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.realm.jdbc;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.IncorrectCredentialsException;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.config.Ini;\nimport org.apache.shiro.config.IniSecurityManagerFactory;\nimport org.apache.shiro.crypto.hash.Sha256Hash;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.util.JdbcUtils;\nimport org.apache.shiro.util.ThreadContext;\nimport org.hsqldb.jdbc.JDBCDataSource;\nimport org.junit.*;\nimport org.junit.rules.TestName;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.HashMap;\n\n\n/**\n * Test case for JDBCRealm.\n */\npublic class JDBCRealmTest {\n\n    protected DefaultSecurityManager securityManager = null;\n    protected AuthorizingRealm realm;\n    protected final String username = \"testUser\";\n    protected final String plainTextPassword = \"testPassword\";\n    protected final String salt = username;  //Default impl of getSaltForUser returns username\n    protected final String testRole = \"testRole\";\n    protected final String testPermissionString = \"testDomain:testTarget:testAction\";\n    \n    // Maps keyed on test method name so setup/teardown can manage per test resources\n    protected HashMap<String, JdbcRealm> realmMap = new HashMap<String, JdbcRealm>();\n    protected HashMap<String, DataSource> dsMap = new HashMap<String, DataSource>();\n\n    @Rule \n    public TestName name = new TestName();\n\n    @Before\n    public void setup() {\n        ThreadContext.remove();\n        Ini config = new Ini();\n        config.setSectionProperty(\"main\", \"myRealm\", \"org.apache.shiro.realm.jdbc.JdbcRealm\");\n        config.setSectionProperty(\"main\", \"myRealmCredentialsMatcher\", \"org.apache.shiro.authc.credential.Sha256CredentialsMatcher\");\n        config.setSectionProperty(\"main\", \"myRealm.credentialsMatcher\", \"$myRealmCredentialsMatcher\");\n        config.setSectionProperty(\"main\", \"securityManager.sessionManager.sessionValidationSchedulerEnabled\", \"false\");\n        \n        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(config);\n        securityManager = (DefaultSecurityManager) factory.createInstance();\n        SecurityUtils.setSecurityManager(securityManager);\n        \n        // Create a database and realm for the test\n        createRealm(name.getMethodName()); \n    }\n\n    @After\n    public void tearDown() {\n        final String testName = name.getMethodName();\n        shutDown(testName);\n        SecurityUtils.setSecurityManager(null);\n        securityManager.destroy();\n        ThreadContext.remove();\n    }\n    \n    @Test\n    public void testUnSaltedSuccess() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createDefaultSchema(testMethodName, false);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);\n        currentUser.login(token);\n        currentUser.logout();\n    }\n    \n    @Test\n    public void testUnSaltedWrongPassword() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createDefaultSchema(testMethodName, false);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, \"passwrd\");\n        try {\n            currentUser.login(token);\n        } catch (IncorrectCredentialsException ex) {\n            // Expected\n        }\n    }\n    \n    @Test\n    public void testUnSaltedMultipleRows() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createDefaultSchema(testMethodName, false);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);\n        Connection conn = dsMap.get(testMethodName).getConnection();\n        Statement sql = conn.createStatement();\n        sql.executeUpdate(\"insert into users values ('\" + username + \"', 'dupe')\");\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, \"passwrd\");\n        try {\n            currentUser.login(token);\n        } catch (AuthenticationException ex) {\n            // Expected\n        }\n    }\n    \n    @Test\n    public void testSaltColumnSuccess() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createSaltColumnSchema(testMethodName);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.COLUMN);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);\n        currentUser.login(token);\n        currentUser.logout();\n    }\n    \n    @Test\n    public void testSaltColumnWrongPassword() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createSaltColumnSchema(testMethodName);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.COLUMN);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, \"passwrd\");\n        try {\n            currentUser.login(token);\n        } catch (IncorrectCredentialsException ex) {\n            // Expected\n        }\n    }\n    \n    @Test\n    public void testExternalSuccess() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createDefaultSchema(testMethodName, true);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.EXTERNAL);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);\n        currentUser.login(token);\n        currentUser.logout();\n    }\n    \n    @Test\n    public void testExternalWrongPassword() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createDefaultSchema(testMethodName, true);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.EXTERNAL);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, \"passwrd\");\n        try {\n            currentUser.login(token);\n        } catch (IncorrectCredentialsException ex) {\n            // Expected\n        }\n    }\n    \n    @Test\n    public void testRolePresent() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createDefaultSchema(testMethodName, false);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);\n        currentUser.login(token);\n        Assert.assertTrue(currentUser.hasRole(testRole));\n    }\n    \n    @Test\n    public void testRoleNotPresent() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createDefaultSchema(testMethodName, false);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);\n        currentUser.login(token);\n        Assert.assertFalse(currentUser.hasRole(\"Game Overall Director\"));\n    }\n    \n    @Test\n    public void testPermissionPresent() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createDefaultSchema(testMethodName, false);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);\n        realm.setPermissionsLookupEnabled(true);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);\n        currentUser.login(token);\n        Assert.assertTrue(currentUser.isPermitted(testPermissionString));\n    }\n    \n    @Test\n    public void testPermissionNotPresent() throws Exception {\n        String testMethodName = name.getMethodName();\n        JdbcRealm realm = realmMap.get(testMethodName);\n        createDefaultSchema(testMethodName, false);\n        realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);\n        realm.setPermissionsLookupEnabled(true);\n        \n        Subject.Builder builder = new Subject.Builder(securityManager);\n        Subject currentUser = builder.buildSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);\n        currentUser.login(token);\n        Assert.assertFalse(currentUser.isPermitted(\"testDomain:testTarget:specialAction\"));\n    }\n    \n    /**\n     * Creates a realm for a test method and puts it in the realMap.\n     */\n    protected void createRealm(String testMethodName) {\n        JdbcRealm realm = (JdbcRealm) securityManager.getRealms().iterator().next();\n        realmMap.put(testMethodName, realm);\n    }\n    \n    /**\n     * Shuts down the database and removes the realm from the realm map.\n     */\n    protected void shutDown(String testName) {\n        Connection conn = null;\n        Statement sql = null;\n        DataSource ds = dsMap.get(testName);\n        try {\n            Connection c = ds.getConnection();\n            Statement s = c.createStatement();\n            s.executeUpdate(\"SHUTDOWN\");\n        } catch (SQLException ex) {\n            // ignore\n        } finally {\n            JdbcUtils.closeStatement(sql);\n            JdbcUtils.closeConnection(conn);\n            dsMap.remove(testName);\n            realmMap.remove(testName);\n        }\n    }\n    \n    /**\n     * Creates a test database with the default (no separate salt column) schema, salting with\n     * username if salted is true. Sets the DataSource of the realm associated with the test\n     * to a DataSource connected to the database.  (To prevent concurrency problems when tests\n     * are executed in multithreaded mode, each test method gets its own database.)\n     */\n    protected void createDefaultSchema(String testName, boolean salted) {\n        JDBCDataSource ds = new JDBCDataSource();\n        ds.setDatabase(\"jdbc:hsqldb:mem:\" + name);\n        ds.setUser(\"SA\");\n        ds.setPassword(\"\");\n        Connection conn = null;\n        Statement sql = null;\n        try {\n            conn = ds.getConnection();\n            sql = conn.createStatement();\n            sql.executeUpdate(\"create table users (username varchar(20), password varchar(100))\");\n            Sha256Hash sha256Hash = salted ? new Sha256Hash(plainTextPassword, salt) :\n                new Sha256Hash(plainTextPassword);\n            String password = sha256Hash.toHex();\n            sql.executeUpdate(\"insert into users values ('\" + username + \"', '\" + password + \"')\");\n        } catch (SQLException ex) {\n            Assert.fail(\"Exception creating test database\");\n        } finally {\n            JdbcUtils.closeStatement(sql);\n            JdbcUtils.closeConnection(conn);\n        }\n        createRolesAndPermissions(ds);\n        realmMap.get(testName).setDataSource(ds);\n        dsMap.put(testName, ds);\n    }\n    \n    /**\n     * Creates a test database with a separate salt column in the users table. Sets the\n     * DataSource of the realm associated with the test to a DataSource connected to the database.\n     */\n    protected void createSaltColumnSchema(String testName) {\n        JDBCDataSource ds = new JDBCDataSource();\n        ds.setDatabase(\"jdbc:hsqldb:mem:\" + name);\n        ds.setUser(\"SA\");\n        ds.setPassword(\"\");\n        Connection conn = null;\n        Statement sql = null;\n        try {\n            conn = ds.getConnection();\n            sql = conn.createStatement();\n            sql.executeUpdate(\n                    \"create table users (username varchar(20), password varchar(100), password_salt varchar(20))\");\n            Sha256Hash sha256Hash = new Sha256Hash(plainTextPassword, salt);\n            String password = sha256Hash.toHex();\n            sql.executeUpdate(\"insert into users values ('\" + username + \"', '\" + password + \"', '\" + salt + \"')\");\n        } catch (SQLException ex) {\n            Assert.fail(\"Exception creating test database\");\n        } finally {\n            JdbcUtils.closeStatement(sql);\n            JdbcUtils.closeConnection(conn);\n        }\n        createRolesAndPermissions(ds);\n        realmMap.get(testName).setDataSource(ds);\n        dsMap.put(testName, ds);\n    }\n    \n    /**\n     * Creates and adds test data to user_role and roles_permissions tables.\n     */\n    protected void createRolesAndPermissions(DataSource ds) {\n        Connection conn = null;;\n        Statement sql = null;\n        try {\n            conn = ds.getConnection();\n            sql = conn.createStatement();\n            sql.executeUpdate(\"create table user_roles (username varchar(20), role_name varchar(20))\");\n            sql.executeUpdate(\"insert into user_roles values ('\" + username + \"', '\" + testRole + \"')\");\n            sql.executeUpdate(\"create table roles_permissions (role_name varchar(20), permission varchar(40))\");\n            sql.executeUpdate(\n                    \"insert into roles_permissions values ('\" + testRole + \"', '\" + testPermissionString + \"')\");\n        } catch (SQLException ex) {\n            Assert.fail(\"Exception adding test role and permission\");\n        } finally {\n            JdbcUtils.closeStatement(sql);\n            JdbcUtils.closeConnection(conn);\n        }\n    }\n}\n","lineNo":378}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.mgt;\n\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.mgt.DefaultSubjectDAO;\nimport org.apache.shiro.mgt.SessionStorageEvaluator;\nimport org.apache.shiro.mgt.SubjectDAO;\nimport org.apache.shiro.realm.Realm;\nimport org.apache.shiro.session.mgt.SessionContext;\nimport org.apache.shiro.session.mgt.SessionKey;\nimport org.apache.shiro.session.mgt.SessionManager;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.subject.SubjectContext;\nimport org.apache.shiro.util.LifecycleUtils;\nimport org.apache.shiro.web.servlet.ShiroHttpServletRequest;\nimport org.apache.shiro.web.session.mgt.*;\nimport org.apache.shiro.web.subject.WebSubject;\nimport org.apache.shiro.web.subject.WebSubjectContext;\nimport org.apache.shiro.web.subject.support.DefaultWebSubjectContext;\nimport org.apache.shiro.web.util.WebUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\nimport java.util.Collection;\n\n\n/**\n * Default {@link WebSecurityManager WebSecurityManager} implementation used in web-based applications or any\n * application that requires HTTP connectivity (SOAP, http remoting, etc).\n *\n * @since 0.2\n */\npublic class DefaultWebSecurityManager extends DefaultSecurityManager implements WebSecurityManager {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(DefaultWebSecurityManager.class);\n\n    @Deprecated\n    public static final String HTTP_SESSION_MODE = \"http\";\n    @Deprecated\n    public static final String NATIVE_SESSION_MODE = \"native\";\n\n    /**\n     * @deprecated as of 1.2.  This should NOT be used for anything other than determining if the sessionMode has changed.\n     */\n    @Deprecated\n    private String sessionMode;\n\n    public DefaultWebSecurityManager() {\n        super();\n        DefaultWebSessionStorageEvaluator webEvalutator = new DefaultWebSessionStorageEvaluator();  \n        ((DefaultSubjectDAO) this.subjectDAO).setSessionStorageEvaluator(webEvalutator);\n        this.sessionMode = HTTP_SESSION_MODE;\n        setSubjectFactory(new DefaultWebSubjectFactory());\n        setRememberMeManager(new CookieRememberMeManager());\n        setSessionManager(new ServletContainerSessionManager());\n        webEvalutator.setSessionManager(getSessionManager());\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public DefaultWebSecurityManager(Realm singleRealm) {\n        this();\n        setRealm(singleRealm);\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public DefaultWebSecurityManager(Collection<Realm> realms) {\n        this();\n        setRealms(realms);\n    }\n\n    @Override\n    protected SubjectContext createSubjectContext() {\n        return new DefaultWebSubjectContext();\n    }\n\n    @Override\n    //since 1.2.1 for fixing SHIRO-350\n    public void setSubjectDAO(SubjectDAO subjectDAO) {\n        super.setSubjectDAO(subjectDAO);\n        applySessionManagerToSessionStorageEvaluatorIfPossible();\n    }\n\n    //since 1.2.1 for fixing SHIRO-350\n    @Override\n    protected void afterSessionManagerSet() {\n        super.afterSessionManagerSet();\n        applySessionManagerToSessionStorageEvaluatorIfPossible();\n    }\n\n    //since 1.2.1 for fixing SHIRO-350:\n    private void applySessionManagerToSessionStorageEvaluatorIfPossible() {\n        SubjectDAO subjectDAO = getSubjectDAO();\n        if (subjectDAO instanceof DefaultSubjectDAO) {\n            SessionStorageEvaluator evaluator = ((DefaultSubjectDAO)subjectDAO).getSessionStorageEvaluator();\n            if (evaluator instanceof DefaultWebSessionStorageEvaluator) {\n                ((DefaultWebSessionStorageEvaluator)evaluator).setSessionManager(getSessionManager());\n            }\n        }\n    }\n\n    @Override\n    protected SubjectContext copy(SubjectContext subjectContext) {\n        if (subjectContext instanceof WebSubjectContext) {\n            return new DefaultWebSubjectContext((WebSubjectContext) subjectContext);\n        }\n        return super.copy(subjectContext);\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    @Deprecated\n    public String getSessionMode() {\n        return sessionMode;\n    }\n\n    /**\n     * @param sessionMode\n     * @deprecated since 1.2\n     */\n    @Deprecated\n    public void setSessionMode(String sessionMode) {\n        log.warn(\"The 'sessionMode' property has been deprecated.  Please configure an appropriate WebSessionManager \" +\n                \"instance instead of using this property.  This property/method will be removed in a later version.\");\n        String mode = sessionMode;\n        if (mode == null) {\n            throw new IllegalArgumentException(\"sessionMode argument cannot be null.\");\n        }\n        mode = sessionMode.toLowerCase();\n        if (!HTTP_SESSION_MODE.equals(mode) && !NATIVE_SESSION_MODE.equals(mode)) {\n            String msg = \"Invalid sessionMode [\" + sessionMode + \"].  Allowed values are \" +\n                    \"public static final String constants in the \" + getClass().getName() + \" class: '\"\n                    + HTTP_SESSION_MODE + \"' or '\" + NATIVE_SESSION_MODE + \"', with '\" +\n                    HTTP_SESSION_MODE + \"' being the default.\";\n            throw new IllegalArgumentException(msg);\n        }\n        boolean recreate = this.sessionMode == null || !this.sessionMode.equals(mode);\n        this.sessionMode = mode;\n        if (recreate) {\n            LifecycleUtils.destroy(getSessionManager());\n            SessionManager sessionManager = createSessionManager(mode);\n            this.setInternalSessionManager(sessionManager);\n        }\n    }\n\n    @Override\n    public void setSessionManager(SessionManager sessionManager) {\n        this.sessionMode = null;\n        if (sessionManager != null && !(sessionManager instanceof WebSessionManager)) {\n            if (log.isWarnEnabled()) {\n                String msg = \"The \" + getClass().getName() + \" implementation expects SessionManager instances \" +\n                        \"that implement the \" + WebSessionManager.class.getName() + \" interface.  The \" +\n                        \"configured instance is of type [\" + sessionManager.getClass().getName() + \"] which does not \" +\n                        \"implement this interface..  This may cause unexpected behavior.\";\n                log.warn(msg);\n            }\n        }\n        setInternalSessionManager(sessionManager);\n    }\n\n    /**\n     * @param sessionManager\n     * @since 1.2\n     */\n    private void setInternalSessionManager(SessionManager sessionManager) {\n        super.setSessionManager(sessionManager);\n    }\n\n    /**\n     * @since 1.0\n     */\n    public boolean isHttpSessionMode() {\n        SessionManager sessionManager = getSessionManager();\n        return sessionManager instanceof WebSessionManager && ((WebSessionManager)sessionManager).isServletContainerSessions();\n    }\n\n    protected SessionManager createSessionManager(String sessionMode) {\n        if (sessionMode == null || !sessionMode.equalsIgnoreCase(NATIVE_SESSION_MODE)) {\n            log.info(\"{} mode - enabling ServletContainerSessionManager (HTTP-only Sessions)\", HTTP_SESSION_MODE);\n            return new ServletContainerSessionManager();\n        } else {\n            log.info(\"{} mode - enabling DefaultWebSessionManager (non-HTTP and HTTP Sessions)\", NATIVE_SESSION_MODE);\n            return new DefaultWebSessionManager();\n        }\n    }\n\n    @Override\n    protected SessionContext createSessionContext(SubjectContext subjectContext) {\n        SessionContext sessionContext = super.createSessionContext(subjectContext);\n        if (subjectContext instanceof WebSubjectContext) {\n            WebSubjectContext wsc = (WebSubjectContext) subjectContext;\n            ServletRequest request = wsc.resolveServletRequest();\n            ServletResponse response = wsc.resolveServletResponse();\n            DefaultWebSessionContext webSessionContext = new DefaultWebSessionContext(sessionContext);\n            if (request != null) {\n                webSessionContext.setServletRequest(request);\n            }\n            if (response != null) {\n                webSessionContext.setServletResponse(response);\n            }\n\n            sessionContext = webSessionContext;\n        }\n        return sessionContext;\n    }\n\n    @Override\n    protected SessionKey getSessionKey(SubjectContext context) {\n        if (WebUtils.isWeb(context)) {\n            Serializable sessionId = context.getSessionId();\n            ServletRequest request = WebUtils.getRequest(context);\n            ServletResponse response = WebUtils.getResponse(context);\n            return new WebSessionKey(sessionId, request, response);\n        } else {\n            return super.getSessionKey(context);\n\n        }\n    }\n\n    @Override\n    protected void beforeLogout(Subject subject) {\n        super.beforeLogout(subject);\n        removeRequestIdentity(subject);\n    }\n\n    protected void removeRequestIdentity(Subject subject) {\n        if (subject instanceof WebSubject) {\n            WebSubject webSubject = (WebSubject) subject;\n            ServletRequest request = webSubject.getServletRequest();\n            if (request != null) {\n                request.setAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY, Boolean.TRUE);\n            }\n        }\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.mgt;\n\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.mgt.DefaultSubjectDAO;\nimport org.apache.shiro.mgt.SessionStorageEvaluator;\nimport org.apache.shiro.mgt.SubjectDAO;\nimport org.apache.shiro.realm.Realm;\nimport org.apache.shiro.session.mgt.SessionContext;\nimport org.apache.shiro.session.mgt.SessionKey;\nimport org.apache.shiro.session.mgt.SessionManager;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.subject.SubjectContext;\nimport org.apache.shiro.util.LifecycleUtils;\nimport org.apache.shiro.web.servlet.ShiroHttpServletRequest;\nimport org.apache.shiro.web.session.mgt.*;\nimport org.apache.shiro.web.subject.WebSubject;\nimport org.apache.shiro.web.subject.WebSubjectContext;\nimport org.apache.shiro.web.subject.support.DefaultWebSubjectContext;\nimport org.apache.shiro.web.util.WebUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\nimport java.util.Collection;\n\n\n/**\n * Default {@link WebSecurityManager WebSecurityManager} implementation used in web-based applications or any\n * application that requires HTTP connectivity (SOAP, http remoting, etc).\n *\n * @since 0.2\n */\npublic class DefaultWebSecurityManager extends DefaultSecurityManager implements WebSecurityManager {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(DefaultWebSecurityManager.class);\n\n    @Deprecated\n    public static final String HTTP_SESSION_MODE = \"http\";\n    @Deprecated\n    public static final String NATIVE_SESSION_MODE = \"native\";\n\n    /**\n     * @deprecated as of 1.2.  This should NOT be used for anything other than determining if the sessionMode has changed.\n     */\n    @Deprecated\n    private String sessionMode;\n\n    public DefaultWebSecurityManager() {\n        super();\n        ((DefaultSubjectDAO) this.subjectDAO).setSessionStorageEvaluator(new DefaultWebSessionStorageEvaluator());\n        this.sessionMode = HTTP_SESSION_MODE;\n        setSubjectFactory(new DefaultWebSubjectFactory());\n        setRememberMeManager(new CookieRememberMeManager());\n        setSessionManager(new ServletContainerSessionManager());\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public DefaultWebSecurityManager(Realm singleRealm) {\n        this();\n        setRealm(singleRealm);\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public DefaultWebSecurityManager(Collection<Realm> realms) {\n        this();\n        setRealms(realms);\n    }\n\n    @Override\n    protected SubjectContext createSubjectContext() {\n        return new DefaultWebSubjectContext();\n    }\n\n    @Override\n    //since 1.2.1 for fixing SHIRO-350\n    public void setSubjectDAO(SubjectDAO subjectDAO) {\n        super.setSubjectDAO(subjectDAO);\n        applySessionManagerToSessionStorageEvaluatorIfPossible();\n    }\n\n    //since 1.2.1 for fixing SHIRO-350\n    @Override\n    protected void afterSessionManagerSet() {\n        super.afterSessionManagerSet();\n        applySessionManagerToSessionStorageEvaluatorIfPossible();\n    }\n\n    //since 1.2.1 for fixing SHIRO-350:\n    private void applySessionManagerToSessionStorageEvaluatorIfPossible() {\n        SubjectDAO subjectDAO = getSubjectDAO();\n        if (subjectDAO instanceof DefaultSubjectDAO) {\n            SessionStorageEvaluator evaluator = ((DefaultSubjectDAO)subjectDAO).getSessionStorageEvaluator();\n            if (evaluator instanceof DefaultWebSessionStorageEvaluator) {\n                ((DefaultWebSessionStorageEvaluator)evaluator).setSessionManager(getSessionManager());\n            }\n        }\n    }\n\n    @Override\n    protected SubjectContext copy(SubjectContext subjectContext) {\n        if (subjectContext instanceof WebSubjectContext) {\n            return new DefaultWebSubjectContext((WebSubjectContext) subjectContext);\n        }\n        return super.copy(subjectContext);\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    @Deprecated\n    public String getSessionMode() {\n        return sessionMode;\n    }\n\n    /**\n     * @param sessionMode\n     * @deprecated since 1.2\n     */\n    @Deprecated\n    public void setSessionMode(String sessionMode) {\n        log.warn(\"The 'sessionMode' property has been deprecated.  Please configure an appropriate WebSessionManager \" +\n                \"instance instead of using this property.  This property/method will be removed in a later version.\");\n        String mode = sessionMode;\n        if (mode == null) {\n            throw new IllegalArgumentException(\"sessionMode argument cannot be null.\");\n        }\n        mode = sessionMode.toLowerCase();\n        if (!HTTP_SESSION_MODE.equals(mode) && !NATIVE_SESSION_MODE.equals(mode)) {\n            String msg = \"Invalid sessionMode [\" + sessionMode + \"].  Allowed values are \" +\n                    \"public static final String constants in the \" + getClass().getName() + \" class: '\"\n                    + HTTP_SESSION_MODE + \"' or '\" + NATIVE_SESSION_MODE + \"', with '\" +\n                    HTTP_SESSION_MODE + \"' being the default.\";\n            throw new IllegalArgumentException(msg);\n        }\n        boolean recreate = this.sessionMode == null || !this.sessionMode.equals(mode);\n        this.sessionMode = mode;\n        if (recreate) {\n            LifecycleUtils.destroy(getSessionManager());\n            SessionManager sessionManager = createSessionManager(mode);\n            this.setInternalSessionManager(sessionManager);\n        }\n    }\n\n    @Override\n    public void setSessionManager(SessionManager sessionManager) {\n        this.sessionMode = null;\n        if (sessionManager != null && !(sessionManager instanceof WebSessionManager)) {\n            if (log.isWarnEnabled()) {\n                String msg = \"The \" + getClass().getName() + \" implementation expects SessionManager instances \" +\n                        \"that implement the \" + WebSessionManager.class.getName() + \" interface.  The \" +\n                        \"configured instance is of type [\" + sessionManager.getClass().getName() + \"] which does not \" +\n                        \"implement this interface..  This may cause unexpected behavior.\";\n                log.warn(msg);\n            }\n        }\n        setInternalSessionManager(sessionManager);\n    }\n\n    /**\n     * @param sessionManager\n     * @since 1.2\n     */\n    private void setInternalSessionManager(SessionManager sessionManager) {\n        super.setSessionManager(sessionManager);\n    }\n\n    /**\n     * @since 1.0\n     */\n    public boolean isHttpSessionMode() {\n        SessionManager sessionManager = getSessionManager();\n        return sessionManager instanceof WebSessionManager && ((WebSessionManager)sessionManager).isServletContainerSessions();\n    }\n\n    protected SessionManager createSessionManager(String sessionMode) {\n        if (sessionMode == null || !sessionMode.equalsIgnoreCase(NATIVE_SESSION_MODE)) {\n            log.info(\"{} mode - enabling ServletContainerSessionManager (HTTP-only Sessions)\", HTTP_SESSION_MODE);\n            return new ServletContainerSessionManager();\n        } else {\n            log.info(\"{} mode - enabling DefaultWebSessionManager (non-HTTP and HTTP Sessions)\", NATIVE_SESSION_MODE);\n            return new DefaultWebSessionManager();\n        }\n    }\n\n    @Override\n    protected SessionContext createSessionContext(SubjectContext subjectContext) {\n        SessionContext sessionContext = super.createSessionContext(subjectContext);\n        if (subjectContext instanceof WebSubjectContext) {\n            WebSubjectContext wsc = (WebSubjectContext) subjectContext;\n            ServletRequest request = wsc.resolveServletRequest();\n            ServletResponse response = wsc.resolveServletResponse();\n            DefaultWebSessionContext webSessionContext = new DefaultWebSessionContext(sessionContext);\n            if (request != null) {\n                webSessionContext.setServletRequest(request);\n            }\n            if (response != null) {\n                webSessionContext.setServletResponse(response);\n            }\n\n            sessionContext = webSessionContext;\n        }\n        return sessionContext;\n    }\n\n    @Override\n    protected SessionKey getSessionKey(SubjectContext context) {\n        if (WebUtils.isWeb(context)) {\n            Serializable sessionId = context.getSessionId();\n            ServletRequest request = WebUtils.getRequest(context);\n            ServletResponse response = WebUtils.getResponse(context);\n            return new WebSessionKey(sessionId, request, response);\n        } else {\n            return super.getSessionKey(context);\n\n        }\n    }\n\n    @Override\n    protected void beforeLogout(Subject subject) {\n        super.beforeLogout(subject);\n        removeRequestIdentity(subject);\n    }\n\n    protected void removeRequestIdentity(Subject subject) {\n        if (subject instanceof WebSubject) {\n            WebSubject webSubject = (WebSubject) subject;\n            ServletRequest request = webSubject.getServletRequest();\n            if (request != null) {\n                request.setAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY, Boolean.TRUE);\n            }\n        }\n    }\n}\n","lineNo":72}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.guice.web;\n\nimport java.util.*;\n\nimport javax.servlet.Filter;\nimport javax.servlet.ServletContext;\n\nimport org.apache.shiro.config.ConfigurationException;\nimport org.apache.shiro.env.Environment;\nimport org.apache.shiro.guice.ShiroModule;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.session.mgt.SessionManager;\nimport org.apache.shiro.util.StringUtils;\nimport org.apache.shiro.web.env.WebEnvironment;\nimport org.apache.shiro.web.filter.PathMatchingFilter;\nimport org.apache.shiro.web.filter.authc.AnonymousFilter;\nimport org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter;\nimport org.apache.shiro.web.filter.authc.FormAuthenticationFilter;\nimport org.apache.shiro.web.filter.authc.LogoutFilter;\nimport org.apache.shiro.web.filter.authc.UserFilter;\nimport org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter;\nimport org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter;\nimport org.apache.shiro.web.filter.authz.PortFilter;\nimport org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;\nimport org.apache.shiro.web.filter.authz.SslFilter;\nimport org.apache.shiro.web.filter.mgt.FilterChainResolver;\nimport org.apache.shiro.web.filter.session.NoSessionCreationFilter;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.apache.shiro.web.mgt.WebSecurityManager;\nimport org.apache.shiro.web.session.mgt.ServletContainerSessionManager;\n\nimport com.google.inject.Binder;\nimport com.google.inject.Key;\nimport com.google.inject.TypeLiteral;\nimport com.google.inject.binder.AnnotatedBindingBuilder;\nimport com.google.inject.name.Names;\nimport com.google.inject.servlet.ServletModule;\n\n/**\n * Sets up Shiro lifecycles within Guice, enables the injecting of Shiro objects, and binds a default\n * {@link org.apache.shiro.web.mgt.WebSecurityManager}, {@link org.apache.shiro.mgt.SecurityManager} and {@link org.apache.shiro.session.mgt.SessionManager}.  At least one realm must be added by\n * using {@link #bindRealm() bindRealm}.\n * <p/>\n * Also provides for the configuring of filter chains and binds a {@link org.apache.shiro.web.filter.mgt.FilterChainResolver} with that information.\n */\npublic abstract class ShiroWebModule extends ShiroModule {\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<AnonymousFilter> ANON = Key.get(AnonymousFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<FormAuthenticationFilter> AUTHC = Key.get(FormAuthenticationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<BasicHttpAuthenticationFilter> AUTHC_BASIC = Key.get(BasicHttpAuthenticationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<NoSessionCreationFilter> NO_SESSION_CREATION = Key.get(NoSessionCreationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<LogoutFilter> LOGOUT = Key.get(LogoutFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<PermissionsAuthorizationFilter> PERMS = Key.get(PermissionsAuthorizationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<PortFilter> PORT = Key.get(PortFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<HttpMethodPermissionFilter> REST = Key.get(HttpMethodPermissionFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<RolesAuthorizationFilter> ROLES = Key.get(RolesAuthorizationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<SslFilter> SSL = Key.get(SslFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<UserFilter> USER = Key.get(UserFilter.class);\n\n\n    static final String NAME = \"SHIRO\";\n\n    /**\n     * We use a LinkedHashMap here to ensure that iterator order is the same as add order.  This is important, as the\n     * FilterChainResolver uses iterator order when searching for a matching chain.\n     */\n    private final Map<String, FilterConfig<? extends Filter>[]> filterChains = new LinkedHashMap<String, FilterConfig<? extends Filter>[]>();\n    private final ServletContext servletContext;\n\n    public ShiroWebModule(ServletContext servletContext) {\n        this.servletContext = servletContext;\n    }\n\n    public static void bindGuiceFilter(Binder binder) {\n        binder.install(guiceFilterModule());\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static void bindGuiceFilter(final String pattern, Binder binder) {\n        binder.install(guiceFilterModule(pattern));\n    }\n\n    public static ServletModule guiceFilterModule() {\n        return guiceFilterModule(\"/*\");\n    }\n\n    public static ServletModule guiceFilterModule(final String pattern) {\n        return new ServletModule() {\n            @Override\n            protected void configureServlets() {\n                filter(pattern).through(GuiceShiroFilter.class);\n            }\n        };\n    }\n\n    @Override\n    protected final void configureShiro() {\n        bindBeanType(TypeLiteral.get(ServletContext.class), Key.get(ServletContext.class, Names.named(NAME)));\n        bind(Key.get(ServletContext.class, Names.named(NAME))).toInstance(this.servletContext);\n        bindWebSecurityManager(bind(WebSecurityManager.class));\n        bindWebEnvironment(bind(WebEnvironment.class));\n        bind(GuiceShiroFilter.class).asEagerSingleton();\n        expose(GuiceShiroFilter.class);\n\n        this.configureShiroWeb();\n\n        bind(FilterChainResolver.class).toProvider(new FilterChainResolverProvider(setupFilterChainConfigs()));\n    }\n\n    private Map<String, Key<? extends Filter>[]> setupFilterChainConfigs() {\n\n        // loop through and build a map of Filter Key -> Map<Path, Config>\n        Map<Key<? extends Filter>, Map<String, String>> filterToPathToConfig = new HashMap<Key<? extends Filter>, Map<String, String>>();\n\n        // At the same time build a map to return with Path -> Key[]\n        Map<String, Key<? extends Filter>[]> resultConfigMap = new HashMap<String, Key<? extends Filter>[]>();\n\n        for (Map.Entry<String, FilterConfig<? extends Filter>[]> filterChain : filterChains.entrySet()) {\n\n            String path = filterChain.getKey();\n\n            // collect the keys used for this path\n            List<Key<? extends Filter>> keysForPath = new ArrayList<Key<? extends Filter>>();\n\n            for (int i = 0; i < filterChain.getValue().length; i++) {\n                FilterConfig<? extends Filter> filterConfig = filterChain.getValue()[i];\n\n                Key<? extends Filter> key = filterConfig.getKey();\n                String config = filterConfig.getConfigValue();\n\n                // initialize key in filterToPathToConfig, if it doesn't exist\n                if (filterToPathToConfig.get(key) == null) {\n                    filterToPathToConfig.put((key), new HashMap<String, String>());\n                }\n                // now set the value\n                filterToPathToConfig.get(key).put(path, config);\n\n                // Config error if someone configured a non PathMatchingFilter with a config value\n                if (StringUtils.hasText(config) && !PathMatchingFilter.class.isAssignableFrom(key.getTypeLiteral().getRawType())) {\n                    throw new ConfigurationException(\"Config information requires a PathMatchingFilter - can't apply to \" + key.getTypeLiteral().getRawType());\n                }\n\n                // store the key in keysForPath\n                keysForPath.add(key);\n            }\n\n            // map the current path to all of its Keys\n            resultConfigMap.put(path, keysForPath.toArray(new Key[keysForPath.size()]));\n        }\n\n        // now we find only the PathMatchingFilter and configure bindings\n        // non PathMatchingFilter, can be loaded with the default provider via the class name\n        for (Key<? extends Filter> key : filterToPathToConfig.keySet()) {\n            if (PathMatchingFilter.class.isAssignableFrom(key.getTypeLiteral().getRawType())) {\n                bindPathMatchingFilter(castToPathMatching(key), filterToPathToConfig.get(key));\n            }\n            else {\n                bind(key);\n            }\n        }\n\n        return resultConfigMap;\n    }\n\n\n    private <T extends PathMatchingFilter> void bindPathMatchingFilter(Key<T> filterKey, Map<String, String> configs) {\n        bind(filterKey).toProvider(new PathMatchingFilterProvider<T>(filterKey, configs)).asEagerSingleton();\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private Key<? extends PathMatchingFilter> castToPathMatching(Key<? extends Filter> key) {\n        return (Key<? extends PathMatchingFilter>) key;\n    }\n\n    protected abstract void configureShiroWeb();\n\n    @SuppressWarnings({\"unchecked\"})\n    @Override\n    protected final void bindSecurityManager(AnnotatedBindingBuilder<? super SecurityManager> bind) {\n        bind.to(WebSecurityManager.class); // SHIRO-435\n    }\n\n    /**\n     * Binds the security manager.  Override this method in order to provide your own security manager binding.\n     * <p/>\n     * By default, a {@link org.apache.shiro.web.mgt.DefaultWebSecurityManager} is bound as an eager singleton.\n     *\n     * @param bind\n     */\n    protected void bindWebSecurityManager(AnnotatedBindingBuilder<? super WebSecurityManager> bind) {\n        try {\n            bind.toConstructor(DefaultWebSecurityManager.class.getConstructor(Collection.class)).asEagerSingleton();\n        } catch (NoSuchMethodException e) {\n            throw new ConfigurationException(\"This really shouldn't happen.  Either something has changed in Shiro, or there's a bug in ShiroModule.\", e);\n        }\n    }\n\n    /**\n     * Binds the session manager.  Override this method in order to provide your own session manager binding.\n     * <p/>\n     * By default, a {@link org.apache.shiro.web.session.mgt.DefaultWebSessionManager} is bound as an eager singleton.\n     *\n     * @param bind\n     */\n    @Override\n    protected void bindSessionManager(AnnotatedBindingBuilder<SessionManager> bind) {\n        bind.to(ServletContainerSessionManager.class).asEagerSingleton();\n    }\n\n    @Override\n    protected final void bindEnvironment(AnnotatedBindingBuilder<Environment> bind) {\n        bind.to(WebEnvironment.class); // SHIRO-435\n    }\n\n    protected void bindWebEnvironment(AnnotatedBindingBuilder<? super WebEnvironment> bind) {\n        bind.to(WebGuiceEnvironment.class).asEagerSingleton();\n    }\n\n    protected final void addFilterChain(String pattern, Key<? extends Filter> key) {\n        // check for legacy API\n        if (key instanceof FilterConfigKey) {\n            addLegacyFilterChain(pattern, (FilterConfigKey) key);\n        }\n        else {\n            addFilterChain(pattern, new FilterConfig<Filter>((Key<Filter>) key, \"\"));\n        }\n    }\n\n    /**\n     * Maps 'n' number of <code>filterConfig<\/code>s to a specific path pattern.<BR/>\n     * For example, a path of '/my_private_resource/**' to 'filterConfig(AUTHC)' would require\n     * any resource under the path '/my_private_resource' would be processed through the {@link FormAuthenticationFilter}.\n     *\n     * @param pattern URL patter to be mapped to a FilterConfig, e.g. '/my_private-path/**'\n     * @param filterConfigs FilterConfiguration representing the Filter and config to be used when processing resources on <code>pattern<\/code>.\n     * @since 1.4\n     */\n    protected final void addFilterChain(String pattern, FilterConfig<? extends Filter>... filterConfigs) {\n        filterChains.put(pattern, filterConfigs);\n    }\n\n    /**\n     * Builds a FilterConfig from a Filer and configuration String\n     * @param baseKey The Key of the Filter class to be used.\n     * @param <T> A Servlet Filter class.\n     * @return A FilterConfig used to map a String path to this configuration.\n     * @since 1.4\n     */\n    protected static <T extends Filter> FilterConfig<T> filterConfig(Key<T> baseKey, String configValue) {\n        return new FilterConfig<T>(baseKey, configValue);\n    }\n\n    /**\n     * Builds a FilterConfig from a Filer and configuration String\n     * @param baseKey The Key of the Filter class to be used.\n     * @param <T> A Servlet Filter class.\n     * @return A FilterConfig used to map a String path to this configuration.\n     * @since 1.4\n     */\n    protected static <T extends Filter> FilterConfig<T> filterConfig(Key<T> baseKey) {\n        return filterConfig(baseKey, \"\");\n    }\n\n    /**\n     * Builds a FilterConfig from a Filer and configuration String\n     * @param typeLiteral The TyleLiteral of the filter key to be used.\n     * @param configValue the configuration used.\n     * @param <T> A Servlet Filter class.\n     * @return A FilterConfig used to map a String path to this configuration.\n     * @since 1.4\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected static <T extends Filter> FilterConfig<T> filterConfig(TypeLiteral<T> typeLiteral, String configValue) {\n        return filterConfig(Key.get(typeLiteral), configValue);\n    }\n\n    /**\n     * Builds a FilterConfig from a Filer and configuration String\n     * @param type The filter to be used.\n     * @param configValue the configuration used.\n     * @param <T> A Servlet Filter class.\n     * @return A FilterConfig used to map a String path to this configuration.\n     * @since 1.4\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected static <T extends Filter> FilterConfig<T> filterConfig(Class<T> type, String configValue) {\n        return filterConfig(Key.get(type), configValue);\n    }\n\n\n    /**\n     * Filter configuration which pairs a Filter class with its configuration used on a path.\n     * @param <T> The Servlet Filter class.\n     * @since 1.4\n     */\n    public static class FilterConfig<T extends Filter> {\n        private Key<T> key;\n        private String configValue;\n\n        private FilterConfig(Key<T> key, String configValue) {\n            super();\n            this.key = key;\n            this.configValue = configValue;\n        }\n\n        public Key<T> getKey() {\n            return key;\n        }\n\n        public String getConfigValue() {\n            return configValue;\n        }\n    }\n\n\n\n\n\n\n\n    // legacy methods\n\n\n    static boolean isGuiceVersion3() {\n        try {\n            Class.forName(\"com.google.inject.multibindings.MapKey\");\n            return false;\n        } catch (ClassNotFoundException e) {\n            return true;\n        }\n    }\n\n    private void addLegacyFilterChain(String pattern, FilterConfigKey filterConfigKey) {\n\n        FilterConfig<Filter> filterConfig = new FilterConfig<Filter>(filterConfigKey.getKey(), filterConfigKey.getConfigValue());\n        addFilterChain(pattern, filterConfig);\n    }\n\n    /**\n     * Adds a filter chain to the shiro configuration.\n     * <p/>\n     * NOTE: If the provided key is for a subclass of {@link org.apache.shiro.web.filter.PathMatchingFilter}, it will be registered with a proper\n     * provider.\n     *\n     * @param pattern\n     * @param keys\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    @Deprecated\n    protected final void addFilterChain(String pattern, Key<? extends Filter>... keys) {\n\n        // We need to extract the keys and FilterConfigKey and convert to the new format.\n\n        FilterConfig[] filterConfigs = new FilterConfig[keys.length];\n        for (int ii = 0; ii < keys.length; ii++) {\n            Key<? extends Filter> key = keys[ii];\n            // If this is a path matching filter, we need to remember the config\n            if (key instanceof FilterConfigKey) {\n                // legacy config\n                FilterConfigKey legacyKey = (FilterConfigKey) key;\n                filterConfigs[ii] = new FilterConfig(legacyKey.getKey(), legacyKey.getConfigValue());\n            }\n            else {\n                // Some other type of Filter key, no config\n                filterConfigs[ii] = new FilterConfig(key, \"\");\n            }\n        }\n\n        filterChains.put(pattern, filterConfigs);\n    }\n\n    @Deprecated\n    protected static <T extends PathMatchingFilter> Key<T> config(Key<T> baseKey, String configValue) {\n\n        if( !isGuiceVersion3()) {\n            throw new ConfigurationException(\"Method ShiroWebModule.config(Key<? extends PathMatchingFilter>, String configValue), is not supported when using Guice 4+\");\n        }\n\n        return new FilterConfigKey<T>(baseKey, configValue);\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    @Deprecated\n    protected static <T extends PathMatchingFilter> Key<T> config(TypeLiteral<T> typeLiteral, String configValue) {\n        return config(Key.get(typeLiteral), configValue);\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    @Deprecated\n    protected static <T extends PathMatchingFilter> Key<T> config(Class<T> type, String configValue) {\n        return config(Key.get(type), configValue);\n    }\n\n    @Deprecated\n    private static class FilterConfigKey<T extends PathMatchingFilter> extends Key<T> {\n        private Key<T> key;\n        private String configValue;\n\n        private FilterConfigKey(Key<T> key, String configValue) {\n            super();\n            this.key = key;\n            this.configValue = configValue;\n        }\n\n        public Key<T> getKey() {\n            return key;\n        }\n\n        public String getConfigValue() {\n            return configValue;\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.guice.web;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\nimport javax.servlet.Filter;\nimport javax.servlet.ServletContext;\n\nimport org.apache.shiro.config.ConfigurationException;\nimport org.apache.shiro.env.Environment;\nimport org.apache.shiro.guice.ShiroModule;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.session.mgt.SessionManager;\nimport org.apache.shiro.web.env.WebEnvironment;\nimport org.apache.shiro.web.filter.PathMatchingFilter;\nimport org.apache.shiro.web.filter.authc.AnonymousFilter;\nimport org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter;\nimport org.apache.shiro.web.filter.authc.FormAuthenticationFilter;\nimport org.apache.shiro.web.filter.authc.LogoutFilter;\nimport org.apache.shiro.web.filter.authc.UserFilter;\nimport org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter;\nimport org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter;\nimport org.apache.shiro.web.filter.authz.PortFilter;\nimport org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;\nimport org.apache.shiro.web.filter.authz.SslFilter;\nimport org.apache.shiro.web.filter.mgt.FilterChainResolver;\nimport org.apache.shiro.web.filter.session.NoSessionCreationFilter;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.apache.shiro.web.mgt.WebSecurityManager;\nimport org.apache.shiro.web.session.mgt.ServletContainerSessionManager;\n\nimport com.google.inject.Binder;\nimport com.google.inject.Key;\nimport com.google.inject.TypeLiteral;\nimport com.google.inject.binder.AnnotatedBindingBuilder;\nimport com.google.inject.name.Names;\nimport com.google.inject.servlet.ServletModule;\n\n/**\n * Sets up Shiro lifecycles within Guice, enables the injecting of Shiro objects, and binds a default\n * {@link org.apache.shiro.web.mgt.WebSecurityManager}, {@link org.apache.shiro.mgt.SecurityManager} and {@link org.apache.shiro.session.mgt.SessionManager}.  At least one realm must be added by\n * using {@link #bindRealm() bindRealm}.\n * <p/>\n * Also provides for the configuring of filter chains and binds a {@link org.apache.shiro.web.filter.mgt.FilterChainResolver} with that information.\n */\npublic abstract class ShiroWebModule extends ShiroModule {\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<AnonymousFilter> ANON = Key.get(AnonymousFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<FormAuthenticationFilter> AUTHC = Key.get(FormAuthenticationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<BasicHttpAuthenticationFilter> AUTHC_BASIC = Key.get(BasicHttpAuthenticationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<NoSessionCreationFilter> NO_SESSION_CREATION = Key.get(NoSessionCreationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<LogoutFilter> LOGOUT = Key.get(LogoutFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<PermissionsAuthorizationFilter> PERMS = Key.get(PermissionsAuthorizationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<PortFilter> PORT = Key.get(PortFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<HttpMethodPermissionFilter> REST = Key.get(HttpMethodPermissionFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<RolesAuthorizationFilter> ROLES = Key.get(RolesAuthorizationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<SslFilter> SSL = Key.get(SslFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<UserFilter> USER = Key.get(UserFilter.class);\n\n\n    static final String NAME = \"SHIRO\";\n\n    /**\n     * We use a LinkedHashMap here to ensure that iterator order is the same as add order.  This is important, as the\n     * FilterChainResolver uses iterator order when searching for a matching chain.\n     */\n    private final Map<String, Key<? extends Filter>[]> filterChains = new LinkedHashMap<String, Key<? extends Filter>[]>();\n    private final ServletContext servletContext;\n\n    public ShiroWebModule(ServletContext servletContext) {\n        this.servletContext = servletContext;\n    }\n\n    public static void bindGuiceFilter(Binder binder) {\n        binder.install(guiceFilterModule());\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static void bindGuiceFilter(final String pattern, Binder binder) {\n        binder.install(guiceFilterModule(pattern));\n    }\n\n    public static ServletModule guiceFilterModule() {\n        return guiceFilterModule(\"/*\");\n    }\n\n    public static ServletModule guiceFilterModule(final String pattern) {\n        return new ServletModule() {\n            @Override\n            protected void configureServlets() {\n                filter(pattern).through(GuiceShiroFilter.class);\n            }\n        };\n    }\n\n    @Override\n    protected final void configureShiro() {\n        bindBeanType(TypeLiteral.get(ServletContext.class), Key.get(ServletContext.class, Names.named(NAME)));\n        bind(Key.get(ServletContext.class, Names.named(NAME))).toInstance(this.servletContext);\n        bindWebSecurityManager(bind(WebSecurityManager.class));\n        bindWebEnvironment(bind(WebEnvironment.class));\n        bind(GuiceShiroFilter.class).asEagerSingleton();\n        expose(GuiceShiroFilter.class);\n\n        this.configureShiroWeb();\n\n        setupFilterChainConfigs();\n\n        bind(FilterChainResolver.class).toProvider(new FilterChainResolverProvider(filterChains));\n    }\n\n    private void setupFilterChainConfigs() {\n        Map<Key<? extends PathMatchingFilter>, Map<String, String>> configs = new HashMap<Key<? extends PathMatchingFilter>, Map<String, String>>();\n\n        for (Map.Entry<String, Key<? extends Filter>[]> filterChain : filterChains.entrySet()) {\n            for (int i = 0; i < filterChain.getValue().length; i++) {\n                Key<? extends Filter> key = filterChain.getValue()[i];\n                if (key instanceof FilterConfigKey) {\n                    FilterConfigKey<? extends PathMatchingFilter> configKey = (FilterConfigKey<? extends PathMatchingFilter>) key;\n                    key = configKey.getKey();\n                    filterChain.getValue()[i] = key;\n                    if (!PathMatchingFilter.class.isAssignableFrom(key.getTypeLiteral().getRawType())) {\n                        throw new ConfigurationException(\"Config information requires a PathMatchingFilter - can't apply to \" + key.getTypeLiteral().getRawType());\n                    }\n                    if (configs.get(castToPathMatching(key)) == null) configs.put(castToPathMatching(key), new HashMap<String, String>());\n                    configs.get(castToPathMatching(key)).put(filterChain.getKey(), configKey.getConfigValue());\n                } else if (PathMatchingFilter.class.isAssignableFrom(key.getTypeLiteral().getRawType())) {\n\t                  if (configs.get(castToPathMatching(key)) == null) configs.put(castToPathMatching(key), new HashMap<String, String>());\n                    configs.get(castToPathMatching(key)).put(filterChain.getKey(), \"\");\n                }\n            }\n        }\n        for (Key<? extends PathMatchingFilter> filterKey : configs.keySet()) {\n            bindPathMatchingFilter(filterKey, configs.get(filterKey));\n        }\n    }\n\n    private <T extends PathMatchingFilter> void bindPathMatchingFilter(Key<T> filterKey, Map<String, String> configs) {\n        bind(filterKey).toProvider(new PathMatchingFilterProvider<T>(filterKey, configs)).asEagerSingleton();\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private Key<? extends PathMatchingFilter> castToPathMatching(Key<? extends Filter> key) {\n        return (Key<? extends PathMatchingFilter>) key;\n    }\n\n    protected abstract void configureShiroWeb();\n\n    @SuppressWarnings({\"unchecked\"})\n    @Override\n    protected final void bindSecurityManager(AnnotatedBindingBuilder<? super SecurityManager> bind) {\n        bind.to(WebSecurityManager.class); // SHIRO-435\n    }\n\n    /**\n     * Binds the security manager.  Override this method in order to provide your own security manager binding.\n     * <p/>\n     * By default, a {@link org.apache.shiro.web.mgt.DefaultWebSecurityManager} is bound as an eager singleton.\n     *\n     * @param bind\n     */\n    protected void bindWebSecurityManager(AnnotatedBindingBuilder<? super WebSecurityManager> bind) {\n        try {\n            bind.toConstructor(DefaultWebSecurityManager.class.getConstructor(Collection.class)).asEagerSingleton();\n        } catch (NoSuchMethodException e) {\n            throw new ConfigurationException(\"This really shouldn't happen.  Either something has changed in Shiro, or there's a bug in ShiroModule.\", e);\n        }\n    }\n\n    /**\n     * Binds the session manager.  Override this method in order to provide your own session manager binding.\n     * <p/>\n     * By default, a {@link org.apache.shiro.web.session.mgt.DefaultWebSessionManager} is bound as an eager singleton.\n     *\n     * @param bind\n     */\n    @Override\n    protected void bindSessionManager(AnnotatedBindingBuilder<SessionManager> bind) {\n        bind.to(ServletContainerSessionManager.class).asEagerSingleton();\n    }\n\n    @Override\n    protected final void bindEnvironment(AnnotatedBindingBuilder<Environment> bind) {\n        bind.to(WebEnvironment.class); // SHIRO-435\n    }\n\n    protected void bindWebEnvironment(AnnotatedBindingBuilder<? super WebEnvironment> bind) {\n        bind.to(WebGuiceEnvironment.class).asEagerSingleton();\n    }\n\n    /**\n     * Adds a filter chain to the shiro configuration.\n     * <p/>\n     * NOTE: If the provided key is for a subclass of {@link org.apache.shiro.web.filter.PathMatchingFilter}, it will be registered with a proper\n     * provider.\n     *\n     * @param pattern\n     * @param keys\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected final void addFilterChain(String pattern, Key<? extends Filter>... keys) {\n        filterChains.put(pattern, keys);\n    }\n\n    protected static <T extends PathMatchingFilter> Key<T> config(Key<T> baseKey, String configValue) {\n        return new FilterConfigKey<T>(baseKey, configValue);\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected static <T extends PathMatchingFilter> Key<T> config(TypeLiteral<T> typeLiteral, String configValue) {\n        return config(Key.get(typeLiteral), configValue);\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected static <T extends PathMatchingFilter> Key<T> config(Class<T> type, String configValue) {\n        return config(Key.get(type), configValue);\n    }\n\n    private static class FilterConfigKey<T extends PathMatchingFilter> extends Key<T> {\n        private Key<T> key;\n        private String configValue;\n\n        private FilterConfigKey(Key<T> key, String configValue) {\n            super();\n            this.key = key;\n            this.configValue = configValue;\n        }\n\n        public Key<T> getKey() {\n            return key;\n        }\n\n        public String getConfigValue() {\n            return configValue;\n        }\n    }\n}\n","lineNo":148}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.guice.web;\n\nimport java.util.*;\n\nimport javax.servlet.Filter;\nimport javax.servlet.ServletContext;\n\nimport org.apache.shiro.config.ConfigurationException;\nimport org.apache.shiro.env.Environment;\nimport org.apache.shiro.guice.ShiroModule;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.session.mgt.SessionManager;\nimport org.apache.shiro.util.StringUtils;\nimport org.apache.shiro.web.env.WebEnvironment;\nimport org.apache.shiro.web.filter.PathMatchingFilter;\nimport org.apache.shiro.web.filter.authc.AnonymousFilter;\nimport org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter;\nimport org.apache.shiro.web.filter.authc.FormAuthenticationFilter;\nimport org.apache.shiro.web.filter.authc.LogoutFilter;\nimport org.apache.shiro.web.filter.authc.UserFilter;\nimport org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter;\nimport org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter;\nimport org.apache.shiro.web.filter.authz.PortFilter;\nimport org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;\nimport org.apache.shiro.web.filter.authz.SslFilter;\nimport org.apache.shiro.web.filter.mgt.FilterChainResolver;\nimport org.apache.shiro.web.filter.session.NoSessionCreationFilter;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.apache.shiro.web.mgt.WebSecurityManager;\nimport org.apache.shiro.web.session.mgt.ServletContainerSessionManager;\n\nimport com.google.inject.Binder;\nimport com.google.inject.Key;\nimport com.google.inject.TypeLiteral;\nimport com.google.inject.binder.AnnotatedBindingBuilder;\nimport com.google.inject.name.Names;\nimport com.google.inject.servlet.ServletModule;\n\n/**\n * Sets up Shiro lifecycles within Guice, enables the injecting of Shiro objects, and binds a default\n * {@link org.apache.shiro.web.mgt.WebSecurityManager}, {@link org.apache.shiro.mgt.SecurityManager} and {@link org.apache.shiro.session.mgt.SessionManager}.  At least one realm must be added by\n * using {@link #bindRealm() bindRealm}.\n * <p/>\n * Also provides for the configuring of filter chains and binds a {@link org.apache.shiro.web.filter.mgt.FilterChainResolver} with that information.\n */\npublic abstract class ShiroWebModule extends ShiroModule {\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<AnonymousFilter> ANON = Key.get(AnonymousFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<FormAuthenticationFilter> AUTHC = Key.get(FormAuthenticationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<BasicHttpAuthenticationFilter> AUTHC_BASIC = Key.get(BasicHttpAuthenticationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<NoSessionCreationFilter> NO_SESSION_CREATION = Key.get(NoSessionCreationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<LogoutFilter> LOGOUT = Key.get(LogoutFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<PermissionsAuthorizationFilter> PERMS = Key.get(PermissionsAuthorizationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<PortFilter> PORT = Key.get(PortFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<HttpMethodPermissionFilter> REST = Key.get(HttpMethodPermissionFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<RolesAuthorizationFilter> ROLES = Key.get(RolesAuthorizationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<SslFilter> SSL = Key.get(SslFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<UserFilter> USER = Key.get(UserFilter.class);\n\n\n    static final String NAME = \"SHIRO\";\n\n    /**\n     * We use a LinkedHashMap here to ensure that iterator order is the same as add order.  This is important, as the\n     * FilterChainResolver uses iterator order when searching for a matching chain.\n     */\n    private final Map<String, FilterConfig<? extends Filter>[]> filterChains = new LinkedHashMap<String, FilterConfig<? extends Filter>[]>();\n    private final ServletContext servletContext;\n\n    public ShiroWebModule(ServletContext servletContext) {\n        this.servletContext = servletContext;\n    }\n\n    public static void bindGuiceFilter(Binder binder) {\n        binder.install(guiceFilterModule());\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static void bindGuiceFilter(final String pattern, Binder binder) {\n        binder.install(guiceFilterModule(pattern));\n    }\n\n    public static ServletModule guiceFilterModule() {\n        return guiceFilterModule(\"/*\");\n    }\n\n    public static ServletModule guiceFilterModule(final String pattern) {\n        return new ServletModule() {\n            @Override\n            protected void configureServlets() {\n                filter(pattern).through(GuiceShiroFilter.class);\n            }\n        };\n    }\n\n    @Override\n    protected final void configureShiro() {\n        bindBeanType(TypeLiteral.get(ServletContext.class), Key.get(ServletContext.class, Names.named(NAME)));\n        bind(Key.get(ServletContext.class, Names.named(NAME))).toInstance(this.servletContext);\n        bindWebSecurityManager(bind(WebSecurityManager.class));\n        bindWebEnvironment(bind(WebEnvironment.class));\n        bind(GuiceShiroFilter.class).asEagerSingleton();\n        expose(GuiceShiroFilter.class);\n\n        this.configureShiroWeb();\n\n        bind(FilterChainResolver.class).toProvider(new FilterChainResolverProvider(setupFilterChainConfigs()));\n    }\n\n    private Map<String, Key<? extends Filter>[]> setupFilterChainConfigs() {\n\n        // loop through and build a map of Filter Key -> Map<Path, Config>\n        Map<Key<? extends Filter>, Map<String, String>> filterToPathToConfig = new HashMap<Key<? extends Filter>, Map<String, String>>();\n\n        // At the same time build a map to return with Path -> Key[]\n        Map<String, Key<? extends Filter>[]> resultConfigMap = new HashMap<String, Key<? extends Filter>[]>();\n\n        for (Map.Entry<String, FilterConfig<? extends Filter>[]> filterChain : filterChains.entrySet()) {\n\n            String path = filterChain.getKey();\n\n            // collect the keys used for this path\n            List<Key<? extends Filter>> keysForPath = new ArrayList<Key<? extends Filter>>();\n\n            for (int i = 0; i < filterChain.getValue().length; i++) {\n                FilterConfig<? extends Filter> filterConfig = filterChain.getValue()[i];\n\n                Key<? extends Filter> key = filterConfig.getKey();\n                String config = filterConfig.getConfigValue();\n\n                // initialize key in filterToPathToConfig, if it doesn't exist\n                if (filterToPathToConfig.get(key) == null) {\n                    filterToPathToConfig.put((key), new HashMap<String, String>());\n                }\n                // now set the value\n                filterToPathToConfig.get(key).put(path, config);\n\n                // Config error if someone configured a non PathMatchingFilter with a config value\n                if (StringUtils.hasText(config) && !PathMatchingFilter.class.isAssignableFrom(key.getTypeLiteral().getRawType())) {\n                    throw new ConfigurationException(\"Config information requires a PathMatchingFilter - can't apply to \" + key.getTypeLiteral().getRawType());\n                }\n\n                // store the key in keysForPath\n                keysForPath.add(key);\n            }\n\n            // map the current path to all of its Keys\n            resultConfigMap.put(path, keysForPath.toArray(new Key[keysForPath.size()]));\n        }\n\n        // now we find only the PathMatchingFilter and configure bindings\n        // non PathMatchingFilter, can be loaded with the default provider via the class name\n        for (Key<? extends Filter> key : filterToPathToConfig.keySet()) {\n            if (PathMatchingFilter.class.isAssignableFrom(key.getTypeLiteral().getRawType())) {\n                bindPathMatchingFilter(castToPathMatching(key), filterToPathToConfig.get(key));\n            }\n            else {\n                bind(key);\n            }\n        }\n\n        return resultConfigMap;\n    }\n\n\n    private <T extends PathMatchingFilter> void bindPathMatchingFilter(Key<T> filterKey, Map<String, String> configs) {\n        bind(filterKey).toProvider(new PathMatchingFilterProvider<T>(filterKey, configs)).asEagerSingleton();\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private Key<? extends PathMatchingFilter> castToPathMatching(Key<? extends Filter> key) {\n        return (Key<? extends PathMatchingFilter>) key;\n    }\n\n    protected abstract void configureShiroWeb();\n\n    @SuppressWarnings({\"unchecked\"})\n    @Override\n    protected final void bindSecurityManager(AnnotatedBindingBuilder<? super SecurityManager> bind) {\n        bind.to(WebSecurityManager.class); // SHIRO-435\n    }\n\n    /**\n     * Binds the security manager.  Override this method in order to provide your own security manager binding.\n     * <p/>\n     * By default, a {@link org.apache.shiro.web.mgt.DefaultWebSecurityManager} is bound as an eager singleton.\n     *\n     * @param bind\n     */\n    protected void bindWebSecurityManager(AnnotatedBindingBuilder<? super WebSecurityManager> bind) {\n        try {\n            bind.toConstructor(DefaultWebSecurityManager.class.getConstructor(Collection.class)).asEagerSingleton();\n        } catch (NoSuchMethodException e) {\n            throw new ConfigurationException(\"This really shouldn't happen.  Either something has changed in Shiro, or there's a bug in ShiroModule.\", e);\n        }\n    }\n\n    /**\n     * Binds the session manager.  Override this method in order to provide your own session manager binding.\n     * <p/>\n     * By default, a {@link org.apache.shiro.web.session.mgt.DefaultWebSessionManager} is bound as an eager singleton.\n     *\n     * @param bind\n     */\n    @Override\n    protected void bindSessionManager(AnnotatedBindingBuilder<SessionManager> bind) {\n        bind.to(ServletContainerSessionManager.class).asEagerSingleton();\n    }\n\n    @Override\n    protected final void bindEnvironment(AnnotatedBindingBuilder<Environment> bind) {\n        bind.to(WebEnvironment.class); // SHIRO-435\n    }\n\n    protected void bindWebEnvironment(AnnotatedBindingBuilder<? super WebEnvironment> bind) {\n        bind.to(WebGuiceEnvironment.class).asEagerSingleton();\n    }\n\n    protected final void addFilterChain(String pattern, Key<? extends Filter> key) {\n        // check for legacy API\n        if (key instanceof FilterConfigKey) {\n            addLegacyFilterChain(pattern, (FilterConfigKey) key);\n        }\n        else {\n            addFilterChain(pattern, new FilterConfig<Filter>((Key<Filter>) key, \"\"));\n        }\n    }\n\n    /**\n     * Maps 'n' number of <code>filterConfig<\/code>s to a specific path pattern.<BR/>\n     * For example, a path of '/my_private_resource/**' to 'filterConfig(AUTHC)' would require\n     * any resource under the path '/my_private_resource' would be processed through the {@link FormAuthenticationFilter}.\n     *\n     * @param pattern URL patter to be mapped to a FilterConfig, e.g. '/my_private-path/**'\n     * @param filterConfigs FilterConfiguration representing the Filter and config to be used when processing resources on <code>pattern<\/code>.\n     * @since 1.4\n     */\n    protected final void addFilterChain(String pattern, FilterConfig<? extends Filter>... filterConfigs) {\n        filterChains.put(pattern, filterConfigs);\n    }\n\n    /**\n     * Builds a FilterConfig from a Filer and configuration String\n     * @param baseKey The Key of the Filter class to be used.\n     * @param <T> A Servlet Filter class.\n     * @return A FilterConfig used to map a String path to this configuration.\n     * @since 1.4\n     */\n    protected static <T extends Filter> FilterConfig<T> filterConfig(Key<T> baseKey, String configValue) {\n        return new FilterConfig<T>(baseKey, configValue);\n    }\n\n    /**\n     * Builds a FilterConfig from a Filer and configuration String\n     * @param baseKey The Key of the Filter class to be used.\n     * @param <T> A Servlet Filter class.\n     * @return A FilterConfig used to map a String path to this configuration.\n     * @since 1.4\n     */\n    protected static <T extends Filter> FilterConfig<T> filterConfig(Key<T> baseKey) {\n        return filterConfig(baseKey, \"\");\n    }\n\n    /**\n     * Builds a FilterConfig from a Filer and configuration String\n     * @param typeLiteral The TyleLiteral of the filter key to be used.\n     * @param configValue the configuration used.\n     * @param <T> A Servlet Filter class.\n     * @return A FilterConfig used to map a String path to this configuration.\n     * @since 1.4\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected static <T extends Filter> FilterConfig<T> filterConfig(TypeLiteral<T> typeLiteral, String configValue) {\n        return filterConfig(Key.get(typeLiteral), configValue);\n    }\n\n    /**\n     * Builds a FilterConfig from a Filer and configuration String\n     * @param type The filter to be used.\n     * @param configValue the configuration used.\n     * @param <T> A Servlet Filter class.\n     * @return A FilterConfig used to map a String path to this configuration.\n     * @since 1.4\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected static <T extends Filter> FilterConfig<T> filterConfig(Class<T> type, String configValue) {\n        return filterConfig(Key.get(type), configValue);\n    }\n\n\n    /**\n     * Filter configuration which pairs a Filter class with its configuration used on a path.\n     * @param <T> The Servlet Filter class.\n     * @since 1.4\n     */\n    public static class FilterConfig<T extends Filter> {\n        private Key<T> key;\n        private String configValue;\n\n        private FilterConfig(Key<T> key, String configValue) {\n            super();\n            this.key = key;\n            this.configValue = configValue;\n        }\n\n        public Key<T> getKey() {\n            return key;\n        }\n\n        public String getConfigValue() {\n            return configValue;\n        }\n    }\n\n\n\n\n\n\n\n    // legacy methods\n\n\n    static boolean isGuiceVersion3() {\n        try {\n            Class.forName(\"com.google.inject.multibindings.MapKey\");\n            return false;\n        } catch (ClassNotFoundException e) {\n            return true;\n        }\n    }\n\n    private void addLegacyFilterChain(String pattern, FilterConfigKey filterConfigKey) {\n\n        FilterConfig<Filter> filterConfig = new FilterConfig<Filter>(filterConfigKey.getKey(), filterConfigKey.getConfigValue());\n        addFilterChain(pattern, filterConfig);\n    }\n\n    /**\n     * Adds a filter chain to the shiro configuration.\n     * <p/>\n     * NOTE: If the provided key is for a subclass of {@link org.apache.shiro.web.filter.PathMatchingFilter}, it will be registered with a proper\n     * provider.\n     *\n     * @param pattern\n     * @param keys\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    @Deprecated\n    protected final void addFilterChain(String pattern, Key<? extends Filter>... keys) {\n\n        // We need to extract the keys and FilterConfigKey and convert to the new format.\n\n        FilterConfig[] filterConfigs = new FilterConfig[keys.length];\n        for (int ii = 0; ii < keys.length; ii++) {\n            Key<? extends Filter> key = keys[ii];\n            // If this is a path matching filter, we need to remember the config\n            if (key instanceof FilterConfigKey) {\n                // legacy config\n                FilterConfigKey legacyKey = (FilterConfigKey) key;\n                filterConfigs[ii] = new FilterConfig(legacyKey.getKey(), legacyKey.getConfigValue());\n            }\n            else {\n                // Some other type of Filter key, no config\n                filterConfigs[ii] = new FilterConfig(key, \"\");\n            }\n        }\n\n        filterChains.put(pattern, filterConfigs);\n    }\n\n    @Deprecated\n    protected static <T extends PathMatchingFilter> Key<T> config(Key<T> baseKey, String configValue) {\n\n        if( !isGuiceVersion3()) {\n            throw new ConfigurationException(\"Method ShiroWebModule.config(Key<? extends PathMatchingFilter>, String configValue), is not supported when using Guice 4+\");\n        }\n\n        return new FilterConfigKey<T>(baseKey, configValue);\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    @Deprecated\n    protected static <T extends PathMatchingFilter> Key<T> config(TypeLiteral<T> typeLiteral, String configValue) {\n        return config(Key.get(typeLiteral), configValue);\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    @Deprecated\n    protected static <T extends PathMatchingFilter> Key<T> config(Class<T> type, String configValue) {\n        return config(Key.get(type), configValue);\n    }\n\n    @Deprecated\n    private static class FilterConfigKey<T extends PathMatchingFilter> extends Key<T> {\n        private Key<T> key;\n        private String configValue;\n\n        private FilterConfigKey(Key<T> key, String configValue) {\n            super();\n            this.key = key;\n            this.configValue = configValue;\n        }\n\n        public Key<T> getKey() {\n            return key;\n        }\n\n        public String getConfigValue() {\n            return configValue;\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.guice.web;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\nimport javax.servlet.Filter;\nimport javax.servlet.ServletContext;\n\nimport org.apache.shiro.config.ConfigurationException;\nimport org.apache.shiro.env.Environment;\nimport org.apache.shiro.guice.ShiroModule;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.session.mgt.SessionManager;\nimport org.apache.shiro.web.env.WebEnvironment;\nimport org.apache.shiro.web.filter.PathMatchingFilter;\nimport org.apache.shiro.web.filter.authc.AnonymousFilter;\nimport org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter;\nimport org.apache.shiro.web.filter.authc.FormAuthenticationFilter;\nimport org.apache.shiro.web.filter.authc.LogoutFilter;\nimport org.apache.shiro.web.filter.authc.UserFilter;\nimport org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter;\nimport org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter;\nimport org.apache.shiro.web.filter.authz.PortFilter;\nimport org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;\nimport org.apache.shiro.web.filter.authz.SslFilter;\nimport org.apache.shiro.web.filter.mgt.FilterChainResolver;\nimport org.apache.shiro.web.filter.session.NoSessionCreationFilter;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.apache.shiro.web.mgt.WebSecurityManager;\nimport org.apache.shiro.web.session.mgt.ServletContainerSessionManager;\n\nimport com.google.inject.Binder;\nimport com.google.inject.Key;\nimport com.google.inject.TypeLiteral;\nimport com.google.inject.binder.AnnotatedBindingBuilder;\nimport com.google.inject.name.Names;\nimport com.google.inject.servlet.ServletModule;\n\n/**\n * Sets up Shiro lifecycles within Guice, enables the injecting of Shiro objects, and binds a default\n * {@link org.apache.shiro.web.mgt.WebSecurityManager}, {@link org.apache.shiro.mgt.SecurityManager} and {@link org.apache.shiro.session.mgt.SessionManager}.  At least one realm must be added by\n * using {@link #bindRealm() bindRealm}.\n * <p/>\n * Also provides for the configuring of filter chains and binds a {@link org.apache.shiro.web.filter.mgt.FilterChainResolver} with that information.\n */\npublic abstract class ShiroWebModule extends ShiroModule {\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<AnonymousFilter> ANON = Key.get(AnonymousFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<FormAuthenticationFilter> AUTHC = Key.get(FormAuthenticationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<BasicHttpAuthenticationFilter> AUTHC_BASIC = Key.get(BasicHttpAuthenticationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<NoSessionCreationFilter> NO_SESSION_CREATION = Key.get(NoSessionCreationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<LogoutFilter> LOGOUT = Key.get(LogoutFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<PermissionsAuthorizationFilter> PERMS = Key.get(PermissionsAuthorizationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<PortFilter> PORT = Key.get(PortFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<HttpMethodPermissionFilter> REST = Key.get(HttpMethodPermissionFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<RolesAuthorizationFilter> ROLES = Key.get(RolesAuthorizationFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<SslFilter> SSL = Key.get(SslFilter.class);\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static final Key<UserFilter> USER = Key.get(UserFilter.class);\n\n\n    static final String NAME = \"SHIRO\";\n\n    /**\n     * We use a LinkedHashMap here to ensure that iterator order is the same as add order.  This is important, as the\n     * FilterChainResolver uses iterator order when searching for a matching chain.\n     */\n    private final Map<String, Key<? extends Filter>[]> filterChains = new LinkedHashMap<String, Key<? extends Filter>[]>();\n    private final ServletContext servletContext;\n\n    public ShiroWebModule(ServletContext servletContext) {\n        this.servletContext = servletContext;\n    }\n\n    public static void bindGuiceFilter(Binder binder) {\n        binder.install(guiceFilterModule());\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public static void bindGuiceFilter(final String pattern, Binder binder) {\n        binder.install(guiceFilterModule(pattern));\n    }\n\n    public static ServletModule guiceFilterModule() {\n        return guiceFilterModule(\"/*\");\n    }\n\n    public static ServletModule guiceFilterModule(final String pattern) {\n        return new ServletModule() {\n            @Override\n            protected void configureServlets() {\n                filter(pattern).through(GuiceShiroFilter.class);\n            }\n        };\n    }\n\n    @Override\n    protected final void configureShiro() {\n        bindBeanType(TypeLiteral.get(ServletContext.class), Key.get(ServletContext.class, Names.named(NAME)));\n        bind(Key.get(ServletContext.class, Names.named(NAME))).toInstance(this.servletContext);\n        bindWebSecurityManager(bind(WebSecurityManager.class));\n        bindWebEnvironment(bind(WebEnvironment.class));\n        bind(GuiceShiroFilter.class).asEagerSingleton();\n        expose(GuiceShiroFilter.class);\n\n        this.configureShiroWeb();\n\n        setupFilterChainConfigs();\n\n        bind(FilterChainResolver.class).toProvider(new FilterChainResolverProvider(filterChains));\n    }\n\n    private void setupFilterChainConfigs() {\n        Map<Key<? extends PathMatchingFilter>, Map<String, String>> configs = new HashMap<Key<? extends PathMatchingFilter>, Map<String, String>>();\n\n        for (Map.Entry<String, Key<? extends Filter>[]> filterChain : filterChains.entrySet()) {\n            for (int i = 0; i < filterChain.getValue().length; i++) {\n                Key<? extends Filter> key = filterChain.getValue()[i];\n                if (key instanceof FilterConfigKey) {\n                    FilterConfigKey<? extends PathMatchingFilter> configKey = (FilterConfigKey<? extends PathMatchingFilter>) key;\n                    key = configKey.getKey();\n                    filterChain.getValue()[i] = key;\n                    if (!PathMatchingFilter.class.isAssignableFrom(key.getTypeLiteral().getRawType())) {\n                        throw new ConfigurationException(\"Config information requires a PathMatchingFilter - can't apply to \" + key.getTypeLiteral().getRawType());\n                    }\n                    if (configs.get(castToPathMatching(key)) == null) configs.put(castToPathMatching(key), new HashMap<String, String>());\n                    configs.get(castToPathMatching(key)).put(filterChain.getKey(), configKey.getConfigValue());\n                } else if (PathMatchingFilter.class.isAssignableFrom(key.getTypeLiteral().getRawType())) {\n\t                  if (configs.get(castToPathMatching(key)) == null) configs.put(castToPathMatching(key), new HashMap<String, String>());\n                    configs.get(castToPathMatching(key)).put(filterChain.getKey(), \"\");\n                }\n            }\n        }\n        for (Key<? extends PathMatchingFilter> filterKey : configs.keySet()) {\n            bindPathMatchingFilter(filterKey, configs.get(filterKey));\n        }\n    }\n\n    private <T extends PathMatchingFilter> void bindPathMatchingFilter(Key<T> filterKey, Map<String, String> configs) {\n        bind(filterKey).toProvider(new PathMatchingFilterProvider<T>(filterKey, configs)).asEagerSingleton();\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private Key<? extends PathMatchingFilter> castToPathMatching(Key<? extends Filter> key) {\n        return (Key<? extends PathMatchingFilter>) key;\n    }\n\n    protected abstract void configureShiroWeb();\n\n    @SuppressWarnings({\"unchecked\"})\n    @Override\n    protected final void bindSecurityManager(AnnotatedBindingBuilder<? super SecurityManager> bind) {\n        bind.to(WebSecurityManager.class); // SHIRO-435\n    }\n\n    /**\n     * Binds the security manager.  Override this method in order to provide your own security manager binding.\n     * <p/>\n     * By default, a {@link org.apache.shiro.web.mgt.DefaultWebSecurityManager} is bound as an eager singleton.\n     *\n     * @param bind\n     */\n    protected void bindWebSecurityManager(AnnotatedBindingBuilder<? super WebSecurityManager> bind) {\n        try {\n            bind.toConstructor(DefaultWebSecurityManager.class.getConstructor(Collection.class)).asEagerSingleton();\n        } catch (NoSuchMethodException e) {\n            throw new ConfigurationException(\"This really shouldn't happen.  Either something has changed in Shiro, or there's a bug in ShiroModule.\", e);\n        }\n    }\n\n    /**\n     * Binds the session manager.  Override this method in order to provide your own session manager binding.\n     * <p/>\n     * By default, a {@link org.apache.shiro.web.session.mgt.DefaultWebSessionManager} is bound as an eager singleton.\n     *\n     * @param bind\n     */\n    @Override\n    protected void bindSessionManager(AnnotatedBindingBuilder<SessionManager> bind) {\n        bind.to(ServletContainerSessionManager.class).asEagerSingleton();\n    }\n\n    @Override\n    protected final void bindEnvironment(AnnotatedBindingBuilder<Environment> bind) {\n        bind.to(WebEnvironment.class); // SHIRO-435\n    }\n\n    protected void bindWebEnvironment(AnnotatedBindingBuilder<? super WebEnvironment> bind) {\n        bind.to(WebGuiceEnvironment.class).asEagerSingleton();\n    }\n\n    /**\n     * Adds a filter chain to the shiro configuration.\n     * <p/>\n     * NOTE: If the provided key is for a subclass of {@link org.apache.shiro.web.filter.PathMatchingFilter}, it will be registered with a proper\n     * provider.\n     *\n     * @param pattern\n     * @param keys\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected final void addFilterChain(String pattern, Key<? extends Filter>... keys) {\n        filterChains.put(pattern, keys);\n    }\n\n    protected static <T extends PathMatchingFilter> Key<T> config(Key<T> baseKey, String configValue) {\n        return new FilterConfigKey<T>(baseKey, configValue);\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected static <T extends PathMatchingFilter> Key<T> config(TypeLiteral<T> typeLiteral, String configValue) {\n        return config(Key.get(typeLiteral), configValue);\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected static <T extends PathMatchingFilter> Key<T> config(Class<T> type, String configValue) {\n        return config(Key.get(type), configValue);\n    }\n\n    private static class FilterConfigKey<T extends PathMatchingFilter> extends Key<T> {\n        private Key<T> key;\n        private String configValue;\n\n        private FilterConfigKey(Key<T> key, String configValue) {\n            super();\n            this.key = key;\n            this.configValue = configValue;\n        }\n\n        public Key<T> getKey() {\n            return key;\n        }\n\n        public String getConfigValue() {\n            return configValue;\n        }\n    }\n}\n","lineNo":157}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.util;\n\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.subject.Subject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.MDC;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n\n/**\n * A ThreadContext provides a means of binding and unbinding objects to the\n * current thread based on key/value pairs.\n * <p/>\n * <p>An internal {@link java.util.HashMap} is used to maintain the key/value pairs\n * for each thread.<\/p>\n * <p/>\n * <p>If the desired behavior is to ensure that bound data is not shared across\n * threads in a pooled or reusable threaded environment, the application (or more likely a framework) must\n * bind and remove any necessary values at the beginning and end of stack\n * execution, respectively (i.e. individually explicitly or all via the <tt>clear<\/tt> method).<\/p>\n *\n * @see #remove()\n * @since 0.1\n */\npublic abstract class ThreadContext {\n\n    /**\n     * Private internal log instance.\n     */\n    private static final Logger log = LoggerFactory.getLogger(ThreadContext.class);\n\n    public static final String SECURITY_MANAGER_KEY = ThreadContext.class.getName() + \"_SECURITY_MANAGER_KEY\";\n    public static final String SUBJECT_KEY = ThreadContext.class.getName() + \"_SUBJECT_KEY\";\n\n\t/**\n     * The key of the subject in SLF4Js Mapped Diagnostic Context ({@link MDC}). This can be used to\n     * show the subject in the logs. The subject is displayed in the logs using the pattern <pre>%X{shiroSubject}<\/pre>.\n     */\n    private static final String SUBJECT_KEY_MDC = \"shiroSubject\";\n\n    private static final ThreadLocal<Map<Object, Object>> resources = new InheritableThreadLocalMap<Map<Object, Object>>();\n\n    /**\n     * Default no-argument constructor.\n     */\n    protected ThreadContext() {\n    }\n\n    /**\n     * Returns the ThreadLocal Map. This Map is used internally to bind objects\n     * to the current thread by storing each object under a unique key.\n     *\n     * @return the map of bound resources\n     */\n    public static Map<Object, Object> getResources() {\n        if (resources.get() == null){\n            return Collections.emptyMap();\n        } else {\n            return new HashMap<Object, Object>(resources.get());\n        }\n    }\n\n    /**\n     * Allows a caller to explicitly set the entire resource map.  This operation overwrites everything that existed\n     * previously in the ThreadContext - if you need to retain what was on the thread prior to calling this method,\n     * call the {@link #getResources()} method, which will give you the existing state.\n     *\n     * @param newResources the resources to replace the existing {@link #getResources() resources}.\n     * @since 1.0\n     */\n    public static void setResources(Map<Object, Object> newResources) {\n        if (CollectionUtils.isEmpty(newResources)) {\n            return;\n        }\n        ensureResourcesInitialized();\n        resources.get().clear();\n        resources.get().putAll(newResources);\n    }\n\n    /**\n     * Returns the value bound in the {@code ThreadContext} under the specified {@code key}, or {@code null} if there\n     * is no value for that {@code key}.\n     *\n     * @param key the map key to use to lookup the value\n     * @return the value bound in the {@code ThreadContext} under the specified {@code key}, or {@code null} if there\n     *         is no value for that {@code key}.\n     * @since 1.0\n     */\n    private static Object getValue(Object key) {\n        Map<Object, Object> perThreadResources = resources.get();\n        return perThreadResources != null ? perThreadResources.get(key) : null;\n    }\n\n    private static void ensureResourcesInitialized(){\n        if (resources.get() == null){\n           resources.set(new HashMap<Object, Object>());\n        }\n    }\n\n    /**\n     * Returns the object for the specified <code>key<\/code> that is bound to\n     * the current thread.\n     *\n     * @param key the key that identifies the value to return\n     * @return the object keyed by <code>key<\/code> or <code>null<\/code> if\n     *         no value exists for the specified <code>key<\/code>\n     */\n    public static Object get(Object key) {\n        if (log.isTraceEnabled()) {\n            String msg = \"get() - in thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n\n        Object value = getValue(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Retrieved value of type [\" + value.getClass().getName() + \"] for key [\" +\n                    key + \"] \" + \"bound to thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Binds <tt>value<\/tt> for the given <code>key<\/code> to the current thread.\n     * <p/>\n     * <p>A <tt>null<\/tt> <tt>value<\/tt> has the same effect as if <tt>remove<\/tt> was called for the given\n     * <tt>key<\/tt>, i.e.:\n     * <p/>\n     * <pre>\n     * if ( value == null ) {\n     *     remove( key );\n     * }<\/pre>\n     *\n     * @param key   The key with which to identify the <code>value<\/code>.\n     * @param value The value to bind to the thread.\n     * @throws IllegalArgumentException if the <code>key<\/code> argument is <tt>null<\/tt>.\n     */\n    public static void put(Object key, Object value) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n\n        if (value == null) {\n            remove(key);\n            return;\n        }\n\n        ensureResourcesInitialized();\n        resources.get().put(key, value);\n\n        if (log.isTraceEnabled()) {\n            String msg = \"Bound value of type [\" + value.getClass().getName() + \"] for key [\" +\n                    key + \"] to thread \" + \"[\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n    }\n\n    /**\n     * Unbinds the value for the given <code>key<\/code> from the current\n     * thread.\n     *\n     * @param key The key identifying the value bound to the current thread.\n     * @return the object unbound or <tt>null<\/tt> if there was nothing bound\n     *         under the specified <tt>key<\/tt> name.\n     */\n    public static Object remove(Object key) {\n        Map<Object, Object> perThreadResources = resources.get();\n        Object value = perThreadResources != null ? perThreadResources.remove(key) : null;\n\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Removed value of type [\" + value.getClass().getName() + \"] for key [\" +\n                    key + \"]\" + \"from thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n\n        return value;\n    }\n\n    /**\n     * {@link ThreadLocal#remove Remove}s the underlying {@link ThreadLocal ThreadLocal} from the thread.\n     * <p/>\n     * This method is meant to be the final 'clean up' operation that is called at the end of thread execution to\n     * prevent thread corruption in pooled thread environments.\n     *\n     * @since 1.0\n     */\n    public static void remove() {\n        resources.remove();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of the application's SecurityManager instance from the current\n     * thread. If there is no SecurityManager bound to the thread (probably because framework code did not bind it\n     * to the thread), this method returns <tt>null<\/tt>.\n     * <p/>\n     * It is merely a convenient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)get( SECURITY_MANAGER_KEY );<\/code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSecurityManager() unbindSecurityManager()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null<\/tt> if there isn't one bound.\n     * @since 0.9\n     */\n    public static SecurityManager getSecurityManager() {\n        return (SecurityManager) get(SECURITY_MANAGER_KEY);\n    }\n\n\n    /**\n     * Convenience method that simplifies binding the application's SecurityManager instance to the ThreadContext.\n     * <p/>\n     * <p>The method's existence is to help reduce casting in code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the SecurityManager is not <tt>null<\/tt>,\n     * it binds it to the thread, i.e.:\n     * <p/>\n     * <pre>\n     * if (securityManager != null) {\n     *     put( SECURITY_MANAGER_KEY, securityManager);\n     * }<\/pre>\n     *\n     * @param securityManager the application's SecurityManager instance to bind to the thread.  If the argument is\n     *                        null, nothing will be done.\n     * @since 0.9\n     */\n    public static void bind(SecurityManager securityManager) {\n        if (securityManager != null) {\n            put(SECURITY_MANAGER_KEY, securityManager);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of the application's SecurityManager instance from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)remove( SECURITY_MANAGER_KEY );<\/code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later\n     * during thread execution), use the {@link #getSecurityManager() getSecurityManager()} method instead.\n     *\n     * @return the application's SecurityManager instance previously bound to the thread, or <tt>null<\/tt> if there\n     *         was none bound.\n     * @since 0.9\n     */\n    public static SecurityManager unbindSecurityManager() {\n        return (SecurityManager) remove(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound Subject.  If there is no\n     * Subject bound to the thread, this method returns <tt>null<\/tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (Subject)get( SUBJECT_KEY );<\/code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSubject() unbindSubject()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null<\/tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static Subject getSubject() {\n        return (Subject) get(SUBJECT_KEY);\n    }\n\n\n    /**\n     * Convenience method that simplifies binding a Subject to the ThreadContext.\n     * <p/>\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the Subject is not <tt>null<\/tt>,\n     * it binds it to the thread, i.e.:\n     * <p/>\n     * <pre>\n     * if (subject != null) {\n     *     put( SUBJECT_KEY, subject );\n     * }<\/pre>\n     *\n     * @param subject the Subject object to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(Subject subject) {\n        if (subject != null) {\n            put(SUBJECT_KEY, subject);\n            MDC.put(SUBJECT_KEY_MDC, String.valueOf(subject.getPrincipal()));\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local Subject from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (Subject)remove( SUBJECT_KEY );<\/code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getSubject() getSubject()} method for that purpose.\n     *\n     * @return the Subject object previously bound to the thread, or <tt>null<\/tt> if there was none bound.\n     * @since 0.2\n     */\n    public static Subject unbindSubject() {\n        MDC.remove(SUBJECT_KEY_MDC);\n        return (Subject) remove(SUBJECT_KEY);\n    }\n    \n    private static final class InheritableThreadLocalMap<T extends Map<Object, Object>> extends InheritableThreadLocal<Map<Object, Object>> {\n\n        /**\n         * This implementation was added to address a\n         * <a href=\"http://jsecurity.markmail.org/search/?q=#query:+page:1+mid:xqi2yxurwmrpqrvj+state:results\">\n         * user-reported issue<\/a>.\n         * @param parentValue the parent value, a HashMap as defined in the {@link #initialValue()} method.\n         * @return the HashMap to be used by any parent-spawned child threads (a clone of the parent HashMap).\n         */\n        @SuppressWarnings({\"unchecked\"})\n        protected Map<Object, Object> childValue(Map<Object, Object> parentValue) {\n            if (parentValue != null) {\n                return (Map<Object, Object>) ((HashMap<Object, Object>) parentValue).clone();\n            } else {\n                return null;\n            }\n        }\n    }\n}\n\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.util;\n\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.subject.Subject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.MDC;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n\n/**\n * A ThreadContext provides a means of binding and unbinding objects to the\n * current thread based on key/value pairs.\n * <p/>\n * <p>An internal {@link java.util.HashMap} is used to maintain the key/value pairs\n * for each thread.<\/p>\n * <p/>\n * <p>If the desired behavior is to ensure that bound data is not shared across\n * threads in a pooled or reusable threaded environment, the application (or more likely a framework) must\n * bind and remove any necessary values at the beginning and end of stack\n * execution, respectively (i.e. individually explicitly or all via the <tt>clear<\/tt> method).<\/p>\n *\n * @see #remove()\n * @since 0.1\n */\npublic abstract class ThreadContext {\n\n    /**\n     * Private internal log instance.\n     */\n    private static final Logger log = LoggerFactory.getLogger(ThreadContext.class);\n\n    public static final String SECURITY_MANAGER_KEY = ThreadContext.class.getName() + \"_SECURITY_MANAGER_KEY\";\n    public static final String SUBJECT_KEY = ThreadContext.class.getName() + \"_SUBJECT_KEY\";\n\n\t/**\n     * The key of the subject in SLF4Js Mapped Diagnostic Context ({@link MDC}). This can be used to\n     * show the subject in the logs. The subject is displayed in the logs using the pattern <pre>%X{shiroSubject}<\/pre>.\n     */\n    private static final String SUBJECT_KEY_MDC = \"shiroSubject\";\n\n    private static final ThreadLocal<Map<Object, Object>> resources = new InheritableThreadLocalMap<Map<Object, Object>>();\n\n    /**\n     * Default no-argument constructor.\n     */\n    protected ThreadContext() {\n    }\n\n    /**\n     * Returns the ThreadLocal Map. This Map is used internally to bind objects\n     * to the current thread by storing each object under a unique key.\n     *\n     * @return the map of bound resources\n     */\n    public static Map<Object, Object> getResources() {\n        return resources != null ? new HashMap<Object, Object>(resources.get()) : null;\n    }\n\n    /**\n     * Allows a caller to explicitly set the entire resource map.  This operation overwrites everything that existed\n     * previously in the ThreadContext - if you need to retain what was on the thread prior to calling this method,\n     * call the {@link #getResources()} method, which will give you the existing state.\n     *\n     * @param newResources the resources to replace the existing {@link #getResources() resources}.\n     * @since 1.0\n     */\n    public static void setResources(Map<Object, Object> newResources) {\n        if (CollectionUtils.isEmpty(newResources)) {\n            return;\n        }\n        resources.get().clear();\n        resources.get().putAll(newResources);\n    }\n\n    /**\n     * Returns the value bound in the {@code ThreadContext} under the specified {@code key}, or {@code null} if there\n     * is no value for that {@code key}.\n     *\n     * @param key the map key to use to lookup the value\n     * @return the value bound in the {@code ThreadContext} under the specified {@code key}, or {@code null} if there\n     *         is no value for that {@code key}.\n     * @since 1.0\n     */\n    private static Object getValue(Object key) {\n        return resources.get().get(key);\n    }\n\n    /**\n     * Returns the object for the specified <code>key<\/code> that is bound to\n     * the current thread.\n     *\n     * @param key the key that identifies the value to return\n     * @return the object keyed by <code>key<\/code> or <code>null<\/code> if\n     *         no value exists for the specified <code>key<\/code>\n     */\n    public static Object get(Object key) {\n        if (log.isTraceEnabled()) {\n            String msg = \"get() - in thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n\n        Object value = getValue(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Retrieved value of type [\" + value.getClass().getName() + \"] for key [\" +\n                    key + \"] \" + \"bound to thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Binds <tt>value<\/tt> for the given <code>key<\/code> to the current thread.\n     * <p/>\n     * <p>A <tt>null<\/tt> <tt>value<\/tt> has the same effect as if <tt>remove<\/tt> was called for the given\n     * <tt>key<\/tt>, i.e.:\n     * <p/>\n     * <pre>\n     * if ( value == null ) {\n     *     remove( key );\n     * }<\/pre>\n     *\n     * @param key   The key with which to identify the <code>value<\/code>.\n     * @param value The value to bind to the thread.\n     * @throws IllegalArgumentException if the <code>key<\/code> argument is <tt>null<\/tt>.\n     */\n    public static void put(Object key, Object value) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n\n        if (value == null) {\n            remove(key);\n            return;\n        }\n\n        resources.get().put(key, value);\n\n        if (log.isTraceEnabled()) {\n            String msg = \"Bound value of type [\" + value.getClass().getName() + \"] for key [\" +\n                    key + \"] to thread \" + \"[\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n    }\n\n    /**\n     * Unbinds the value for the given <code>key<\/code> from the current\n     * thread.\n     *\n     * @param key The key identifying the value bound to the current thread.\n     * @return the object unbound or <tt>null<\/tt> if there was nothing bound\n     *         under the specified <tt>key<\/tt> name.\n     */\n    public static Object remove(Object key) {\n        Object value = resources.get().remove(key);\n\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Removed value of type [\" + value.getClass().getName() + \"] for key [\" +\n                    key + \"]\" + \"from thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n\n        return value;\n    }\n\n    /**\n     * {@link ThreadLocal#remove Remove}s the underlying {@link ThreadLocal ThreadLocal} from the thread.\n     * <p/>\n     * This method is meant to be the final 'clean up' operation that is called at the end of thread execution to\n     * prevent thread corruption in pooled thread environments.\n     *\n     * @since 1.0\n     */\n    public static void remove() {\n        resources.remove();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of the application's SecurityManager instance from the current\n     * thread. If there is no SecurityManager bound to the thread (probably because framework code did not bind it\n     * to the thread), this method returns <tt>null<\/tt>.\n     * <p/>\n     * It is merely a convenient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)get( SECURITY_MANAGER_KEY );<\/code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSecurityManager() unbindSecurityManager()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null<\/tt> if there isn't one bound.\n     * @since 0.9\n     */\n    public static SecurityManager getSecurityManager() {\n        return (SecurityManager) get(SECURITY_MANAGER_KEY);\n    }\n\n\n    /**\n     * Convenience method that simplifies binding the application's SecurityManager instance to the ThreadContext.\n     * <p/>\n     * <p>The method's existence is to help reduce casting in code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the SecurityManager is not <tt>null<\/tt>,\n     * it binds it to the thread, i.e.:\n     * <p/>\n     * <pre>\n     * if (securityManager != null) {\n     *     put( SECURITY_MANAGER_KEY, securityManager);\n     * }<\/pre>\n     *\n     * @param securityManager the application's SecurityManager instance to bind to the thread.  If the argument is\n     *                        null, nothing will be done.\n     * @since 0.9\n     */\n    public static void bind(SecurityManager securityManager) {\n        if (securityManager != null) {\n            put(SECURITY_MANAGER_KEY, securityManager);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of the application's SecurityManager instance from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)remove( SECURITY_MANAGER_KEY );<\/code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later\n     * during thread execution), use the {@link #getSecurityManager() getSecurityManager()} method instead.\n     *\n     * @return the application's SecurityManager instance previously bound to the thread, or <tt>null<\/tt> if there\n     *         was none bound.\n     * @since 0.9\n     */\n    public static SecurityManager unbindSecurityManager() {\n        return (SecurityManager) remove(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound Subject.  If there is no\n     * Subject bound to the thread, this method returns <tt>null<\/tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (Subject)get( SUBJECT_KEY );<\/code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSubject() unbindSubject()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null<\/tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static Subject getSubject() {\n        return (Subject) get(SUBJECT_KEY);\n    }\n\n\n    /**\n     * Convenience method that simplifies binding a Subject to the ThreadContext.\n     * <p/>\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the Subject is not <tt>null<\/tt>,\n     * it binds it to the thread, i.e.:\n     * <p/>\n     * <pre>\n     * if (subject != null) {\n     *     put( SUBJECT_KEY, subject );\n     * }<\/pre>\n     *\n     * @param subject the Subject object to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(Subject subject) {\n        if (subject != null) {\n            put(SUBJECT_KEY, subject);\n            MDC.put(SUBJECT_KEY_MDC, String.valueOf(subject.getPrincipal()));\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local Subject from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (Subject)remove( SUBJECT_KEY );<\/code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getSubject() getSubject()} method for that purpose.\n     *\n     * @return the Subject object previously bound to the thread, or <tt>null<\/tt> if there was none bound.\n     * @since 0.2\n     */\n    public static Subject unbindSubject() {\n        MDC.remove(SUBJECT_KEY_MDC);\n        return (Subject) remove(SUBJECT_KEY);\n    }\n    \n    private static final class InheritableThreadLocalMap<T extends Map<Object, Object>> extends InheritableThreadLocal<Map<Object, Object>> {\n        protected Map<Object, Object> initialValue() {\n            return new HashMap<Object, Object>();\n        }\n\n        /**\n         * This implementation was added to address a\n         * <a href=\"http://jsecurity.markmail.org/search/?q=#query:+page:1+mid:xqi2yxurwmrpqrvj+state:results\">\n         * user-reported issue<\/a>.\n         * @param parentValue the parent value, a HashMap as defined in the {@link #initialValue()} method.\n         * @return the HashMap to be used by any parent-spawned child threads (a clone of the parent HashMap).\n         */\n        @SuppressWarnings({\"unchecked\"})\n        protected Map<Object, Object> childValue(Map<Object, Object> parentValue) {\n            if (parentValue != null) {\n                return (Map<Object, Object>) ((HashMap<Object, Object>) parentValue).clone();\n            } else {\n                return null;\n            }\n        }\n    }\n}\n\n","lineNo":112}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.filter.mgt;\n\nimport org.apache.shiro.config.ConfigurationException;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.util.Nameable;\nimport org.apache.shiro.util.StringUtils;\nimport org.apache.shiro.web.filter.PathConfigProcessor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Default {@link FilterChainManager} implementation maintaining a map of {@link Filter Filter} instances\n * (key: filter name, value: Filter) as well as a map of {@link NamedFilterList NamedFilterList}s created from these\n * {@code Filter}s (key: filter chain name, value: NamedFilterList).  The {@code NamedFilterList} is essentially a\n * {@link FilterChain} that also has a name property by which it can be looked up.\n *\n * @see NamedFilterList\n * @since 1.0\n */\npublic class DefaultFilterChainManager implements FilterChainManager {\n\n    private static transient final Logger log = LoggerFactory.getLogger(DefaultFilterChainManager.class);\n\n    private FilterConfig filterConfig;\n\n    private Map<String, Filter> filters; //pool of filters available for creating chains\n\n    private Map<String, NamedFilterList> filterChains; //key: chain name, value: chain\n\n    public DefaultFilterChainManager() {\n        this.filters = new LinkedHashMap<String, Filter>();\n        this.filterChains = new LinkedHashMap<String, NamedFilterList>();\n        addDefaultFilters(false);\n    }\n\n    public DefaultFilterChainManager(FilterConfig filterConfig) {\n        this.filters = new LinkedHashMap<String, Filter>();\n        this.filterChains = new LinkedHashMap<String, NamedFilterList>();\n        setFilterConfig(filterConfig);\n        addDefaultFilters(true);\n    }\n\n    /**\n     * Returns the {@code FilterConfig} provided by the Servlet container at webapp startup.\n     *\n     * @return the {@code FilterConfig} provided by the Servlet container at webapp startup.\n     */\n    public FilterConfig getFilterConfig() {\n        return filterConfig;\n    }\n\n    /**\n     * Sets the {@code FilterConfig} provided by the Servlet container at webapp startup.\n     *\n     * @param filterConfig the {@code FilterConfig} provided by the Servlet container at webapp startup.\n     */\n    public void setFilterConfig(FilterConfig filterConfig) {\n        this.filterConfig = filterConfig;\n    }\n\n    public Map<String, Filter> getFilters() {\n        return filters;\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public void setFilters(Map<String, Filter> filters) {\n        this.filters = filters;\n    }\n\n    public Map<String, NamedFilterList> getFilterChains() {\n        return filterChains;\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public void setFilterChains(Map<String, NamedFilterList> filterChains) {\n        this.filterChains = filterChains;\n    }\n\n    public Filter getFilter(String name) {\n        return this.filters.get(name);\n    }\n\n    public void addFilter(String name, Filter filter) {\n        addFilter(name, filter, false);\n    }\n\n    public void addFilter(String name, Filter filter, boolean init) {\n        addFilter(name, filter, init, true);\n    }\n\n    public void createChain(String chainName, String chainDefinition) {\n        if (!StringUtils.hasText(chainName)) {\n            throw new NullPointerException(\"chainName cannot be null or empty.\");\n        }\n        if (!StringUtils.hasText(chainDefinition)) {\n            throw new NullPointerException(\"chainDefinition cannot be null or empty.\");\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Creating chain [\" + chainName + \"] from String definition [\" + chainDefinition + \"]\");\n        }\n\n        //parse the value by tokenizing it to get the resulting filter-specific config entries\n        //\n        //e.g. for a value of\n        //\n        //     \"authc, roles[admin,user], perms[file:edit]\"\n        //\n        // the resulting token array would equal\n        //\n        //     { \"authc\", \"roles[admin,user]\", \"perms[file:edit]\" }\n        //\n        String[] filterTokens = splitChainDefinition(chainDefinition);\n\n        //each token is specific to each filter.\n        //strip the name and extract any filter-specific config between brackets [ ]\n        for (String token : filterTokens) {\n            String[] nameConfigPair = toNameConfigPair(token);\n\n            //now we have the filter name, path and (possibly null) path-specific config.  Let's apply them:\n            addToChain(chainName, nameConfigPair[0], nameConfigPair[1]);\n        }\n    }\n\n    /**\n     * Splits the comma-delimited filter chain definition line into individual filter definition tokens.\n     * <p/>\n     * Example Input:\n     * <pre>\n     *     foo, bar[baz], blah[x, y]\n     * <\/pre>\n     * Resulting Output:\n     * <pre>\n     *     output[0] == foo\n     *     output[1] == bar[baz]\n     *     output[2] == blah[x, y]\n     * <\/pre>\n     * @param chainDefinition the comma-delimited filter chain definition.\n     * @return an array of filter definition tokens\n     * @since 1.2\n     * @see <a href=\"https://issues.apache.org/jira/browse/SHIRO-205\">SHIRO-205<\/a>\n     */\n    protected String[] splitChainDefinition(String chainDefinition) {\n        return StringUtils.split(chainDefinition, StringUtils.DEFAULT_DELIMITER_CHAR, '[', ']', true, true);\n    }\n\n    /**\n     * Based on the given filter chain definition token (e.g. 'foo' or 'foo[bar, baz]'), this will return the token\n     * as a name/value pair, removing any brackets as necessary.  Examples:\n     * <table>\n     *     <tr>\n     *         <th>Input<\/th>\n     *         <th>Result<\/th>\n     *     <\/tr>\n     *     <tr>\n     *         <td>{@code foo}<\/td>\n     *         <td>returned[0] == {@code foo}<br/>returned[1] == {@code null}<\/td>\n     *     <\/tr>\n     *     <tr>\n     *         <td>{@code foo[bar, baz]}<\/td>\n     *         <td>returned[0] == {@code foo}<br/>returned[1] == {@code bar, baz}<\/td>\n     *     <\/tr>\n     * <\/table>\n     * @param token the filter chain definition token\n     * @return A name/value pair representing the filter name and a (possibly null) config value.\n     * @throws ConfigurationException if the token cannot be parsed\n     * @since 1.2\n     * @see <a href=\"https://issues.apache.org/jira/browse/SHIRO-205\">SHIRO-205<\/a>\n     */\n    protected String[] toNameConfigPair(String token) throws ConfigurationException {\n\n        try {\n            String[] pair = token.split(\"\\\\[\", 2);\n            String name = StringUtils.clean(pair[0]);\n\n            if (name == null) {\n                throw new IllegalArgumentException(\"Filter name not found for filter chain definition token: \" + token);\n            }\n            String config = null;\n\n            if (pair.length == 2) {\n                config = StringUtils.clean(pair[1]);\n                //if there was an open bracket, it assumed there is a closing bracket, so strip it too:\n                config = config.substring(0, config.length() - 1);\n                config = StringUtils.clean(config);\n\n                //backwards compatibility prior to implementing SHIRO-205:\n                //prior to SHIRO-205 being implemented, it was common for end-users to quote the config inside brackets\n                //if that config required commas.  We need to strip those quotes to get to the interior quoted definition\n                //to ensure any existing quoted definitions still function for end users:\n                if (config != null && config.startsWith(\"\\\"\") && config.endsWith(\"\\\"\")) {\n                    String stripped = config.substring(1, config.length() - 1);\n                    stripped = StringUtils.clean(stripped);\n\n                    //if the stripped value does not have any internal quotes, we can assume that the entire config was\n                    //quoted and we can use the stripped value.\n                    if (stripped != null && stripped.indexOf('\"') == -1) {\n                        config = stripped;\n                    }\n                    //else:\n                    //the remaining config does have internal quotes, so we need to assume that each comma delimited\n                    //pair might be quoted, in which case we need the leading and trailing quotes that we stripped\n                    //So we ignore the stripped value.\n                }\n            }\n            \n            return new String[]{name, config};\n\n        } catch (Exception e) {\n            String msg = \"Unable to parse filter chain definition token: \" + token;\n            throw new ConfigurationException(msg, e);\n        }\n    }\n\n    protected void addFilter(String name, Filter filter, boolean init, boolean overwrite) {\n        Filter existing = getFilter(name);\n        if (existing == null || overwrite) {\n            if (filter instanceof Nameable) {\n                ((Nameable) filter).setName(name);\n            }\n            if (init) {\n                initFilter(filter);\n            }\n            this.filters.put(name, filter);\n        }\n    }\n\n    public void addToChain(String chainName, String filterName) {\n        addToChain(chainName, filterName, null);\n    }\n\n    public void addToChain(String chainName, String filterName, String chainSpecificFilterConfig) {\n        if (!StringUtils.hasText(chainName)) {\n            throw new IllegalArgumentException(\"chainName cannot be null or empty.\");\n        }\n        Filter filter = getFilter(filterName);\n        if (filter == null) {\n            throw new IllegalArgumentException(\"There is no filter with name '\" + filterName +\n                    \"' to apply to chain [\" + chainName + \"] in the pool of available Filters.  Ensure a \" +\n                    \"filter with that name/path has first been registered with the addFilter method(s).\");\n        }\n\n        applyChainConfig(chainName, filter, chainSpecificFilterConfig);\n\n        NamedFilterList chain = ensureChain(chainName);\n        chain.add(filter);\n    }\n\n    protected void applyChainConfig(String chainName, Filter filter, String chainSpecificFilterConfig) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Attempting to apply path [\" + chainName + \"] to filter [\" + filter + \"] \" +\n                    \"with config [\" + chainSpecificFilterConfig + \"]\");\n        }\n        if (filter instanceof PathConfigProcessor) {\n            ((PathConfigProcessor) filter).processPathConfig(chainName, chainSpecificFilterConfig);\n        } else {\n            if (StringUtils.hasText(chainSpecificFilterConfig)) {\n                //they specified a filter configuration, but the Filter doesn't implement PathConfigProcessor\n                //this is an erroneous config:\n                String msg = \"chainSpecificFilterConfig was specified, but the underlying \" +\n                        \"Filter instance is not an 'instanceof' \" +\n                        PathConfigProcessor.class.getName() + \".  This is required if the filter is to accept \" +\n                        \"chain-specific configuration.\";\n                throw new ConfigurationException(msg);\n            }\n        }\n    }\n\n    protected NamedFilterList ensureChain(String chainName) {\n        NamedFilterList chain = getChain(chainName);\n        if (chain == null) {\n            chain = new SimpleNamedFilterList(chainName);\n            this.filterChains.put(chainName, chain);\n        }\n        return chain;\n    }\n\n    public NamedFilterList getChain(String chainName) {\n        return this.filterChains.get(chainName);\n    }\n\n    public boolean hasChains() {\n        return !CollectionUtils.isEmpty(this.filterChains);\n    }\n\n    public Set<String> getChainNames() {\n        //noinspection unchecked\n        return this.filterChains != null ? this.filterChains.keySet() : Collections.EMPTY_SET;\n    }\n\n    public FilterChain proxy(FilterChain original, String chainName) {\n        NamedFilterList configured = getChain(chainName);\n        if (configured == null) {\n            String msg = \"There is no configured chain under the name/key [\" + chainName + \"].\";\n            throw new IllegalArgumentException(msg);\n        }\n        return configured.proxy(original);\n    }\n\n    /**\n     * Initializes the filter by calling <code>filter.init( {@link #getFilterConfig() getFilterConfig()} );<\/code>.\n     *\n     * @param filter the filter to initialize with the {@code FilterConfig}.\n     */\n    protected void initFilter(Filter filter) {\n        FilterConfig filterConfig = getFilterConfig();\n        if (filterConfig == null) {\n            throw new IllegalStateException(\"FilterConfig attribute has not been set.  This must occur before filter \" +\n                    \"initialization can occur.\");\n        }\n        try {\n            filter.init(filterConfig);\n        } catch (ServletException e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    protected void addDefaultFilters(boolean init) {\n        for (DefaultFilter defaultFilter : DefaultFilter.values()) {\n            addFilter(defaultFilter.name(), defaultFilter.newInstance(), init, false);\n        }\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.filter.mgt;\n\nimport org.apache.shiro.config.ConfigurationException;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.util.Nameable;\nimport org.apache.shiro.util.StringUtils;\nimport org.apache.shiro.web.filter.PathConfigProcessor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Default {@link FilterChainManager} implementation maintaining a map of {@link Filter Filter} instances\n * (key: filter name, value: Filter) as well as a map of {@link NamedFilterList NamedFilterList}s created from these\n * {@code Filter}s (key: filter chain name, value: NamedFilterList).  The {@code NamedFilterList} is essentially a\n * {@link FilterChain} that also has a name property by which it can be looked up.\n *\n * @see NamedFilterList\n * @since 1.0\n */\npublic class DefaultFilterChainManager implements FilterChainManager {\n\n    private static transient final Logger log = LoggerFactory.getLogger(DefaultFilterChainManager.class);\n\n    private FilterConfig filterConfig;\n\n    private Map<String, Filter> filters; //pool of filters available for creating chains\n\n    private Map<String, NamedFilterList> filterChains; //key: chain name, value: chain\n\n    public DefaultFilterChainManager() {\n        this.filters = new LinkedHashMap<String, Filter>();\n        this.filterChains = new LinkedHashMap<String, NamedFilterList>();\n        addDefaultFilters(false);\n    }\n\n    public DefaultFilterChainManager(FilterConfig filterConfig) {\n        this.filters = new LinkedHashMap<String, Filter>();\n        this.filterChains = new LinkedHashMap<String, NamedFilterList>();\n        setFilterConfig(filterConfig);\n        addDefaultFilters(true);\n    }\n\n    /**\n     * Returns the {@code FilterConfig} provided by the Servlet container at webapp startup.\n     *\n     * @return the {@code FilterConfig} provided by the Servlet container at webapp startup.\n     */\n    public FilterConfig getFilterConfig() {\n        return filterConfig;\n    }\n\n    /**\n     * Sets the {@code FilterConfig} provided by the Servlet container at webapp startup.\n     *\n     * @param filterConfig the {@code FilterConfig} provided by the Servlet container at webapp startup.\n     */\n    public void setFilterConfig(FilterConfig filterConfig) {\n        this.filterConfig = filterConfig;\n    }\n\n    public Map<String, Filter> getFilters() {\n        return filters;\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public void setFilters(Map<String, Filter> filters) {\n        this.filters = filters;\n    }\n\n    public Map<String, NamedFilterList> getFilterChains() {\n        return filterChains;\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public void setFilterChains(Map<String, NamedFilterList> filterChains) {\n        this.filterChains = filterChains;\n    }\n\n    public Filter getFilter(String name) {\n        return this.filters.get(name);\n    }\n\n    public void addFilter(String name, Filter filter) {\n        addFilter(name, filter, false);\n    }\n\n    public void addFilter(String name, Filter filter, boolean init) {\n        addFilter(name, filter, init, true);\n    }\n\n    public void createChain(String chainName, String chainDefinition) {\n        if (!StringUtils.hasText(chainName)) {\n            throw new NullPointerException(\"chainName cannot be null or empty.\");\n        }\n        if (!StringUtils.hasText(chainDefinition)) {\n            throw new NullPointerException(\"chainDefinition cannot be null or empty.\");\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Creating chain [\" + chainName + \"] from String definition [\" + chainDefinition + \"]\");\n        }\n\n        //parse the value by tokenizing it to get the resulting filter-specific config entries\n        //\n        //e.g. for a value of\n        //\n        //     \"authc, roles[admin,user], perms[file:edit]\"\n        //\n        // the resulting token array would equal\n        //\n        //     { \"authc\", \"roles[admin,user]\", \"perms[file:edit]\" }\n        //\n        String[] filterTokens = splitChainDefinition(chainDefinition);\n\n        //each token is specific to each filter.\n        //strip the name and extract any filter-specific config between brackets [ ]\n        for (String token : filterTokens) {\n            String[] nameConfigPair = toNameConfigPair(token);\n\n            //now we have the filter name, path and (possibly null) path-specific config.  Let's apply them:\n            addToChain(chainName, nameConfigPair[0], nameConfigPair[1]);\n        }\n    }\n\n    /**\n     * Splits the comma-delimited filter chain definition line into individual filter definition tokens.\n     * <p/>\n     * Example Input:\n     * <pre>\n     *     foo, bar[baz], blah[x, y]\n     * <\/pre>\n     * Resulting Output:\n     * <pre>\n     *     output[0] == foo\n     *     output[1] == bar[baz]\n     *     output[2] == blah[x, y]\n     * <\/pre>\n     * @param chainDefinition the comma-delimited filter chain definition.\n     * @return an array of filter definition tokens\n     * @since 1.2\n     * @see <a href=\"https://issues.apache.org/jira/browse/SHIRO-205\">SHIRO-205<\/a>\n     */\n    protected String[] splitChainDefinition(String chainDefinition) {\n        return StringUtils.split(chainDefinition, StringUtils.DEFAULT_DELIMITER_CHAR, '[', ']', true, true);\n    }\n\n    /**\n     * Based on the given filter chain definition token (e.g. 'foo' or 'foo[bar, baz]'), this will return the token\n     * as a name/value pair, removing any brackets as necessary.  Examples:\n     * <table>\n     *     <tr>\n     *         <th>Input<\/th>\n     *         <th>Result<\/th>\n     *     <\/tr>\n     *     <tr>\n     *         <td>{@code foo}<\/td>\n     *         <td>returned[0] == {@code foo}<br/>returned[1] == {@code null}<\/td>\n     *     <\/tr>\n     *     <tr>\n     *         <td>{@code foo[bar, baz]}<\/td>\n     *         <td>returned[0] == {@code foo}<br/>returned[1] == {@code bar, baz}<\/td>\n     *     <\/tr>\n     * <\/table>\n     * @param token the filter chain definition token\n     * @return A name/value pair representing the filter name and a (possibly null) config value.\n     * @throws ConfigurationException if the token cannot be parsed\n     * @since 1.2\n     * @see <a href=\"https://issues.apache.org/jira/browse/SHIRO-205\">SHIRO-205<\/a>\n     */\n    protected String[] toNameConfigPair(String token) throws ConfigurationException {\n\n        try {\n            String[] pair = token.split(\"\\\\[\", 2);\n            String name = StringUtils.clean(pair[0]);\n\n            if (name == null) {\n                throw new IllegalArgumentException(\"Filter name not found for filter chain definition token: \" + token);\n            }\n            String config = null;\n\n            if (pair.length == 2) {\n                config = StringUtils.clean(pair[1]);\n                //if there was an open bracket, it assumed there is a closing bracket, so strip it too:\n                config = config.substring(0, config.length() - 1);\n\n                //backwards compatibility prior to implmenting SHIRO-205:\n                //prior to SHIRO-205 being implemented, it was common for end-users to quote the config inside brackets\n                //if that config required commas.  We need to strip those quotes to get to the interior quoted definition\n                //to ensure any existing quoted definitions still function for end users:\n                if (config.startsWith(\"\\\"\") && config.endsWith(\"\\\"\")) {\n                    config = config.substring(1, config.length() - 1);\n                }\n                \n                config = StringUtils.clean(config);\n            }\n            \n            return new String[]{name, config};\n\n        } catch (Exception e) {\n            String msg = \"Unable to parse filter chain definition token: \" + token;\n            throw new ConfigurationException(msg, e);\n        }\n    }\n\n    protected void addFilter(String name, Filter filter, boolean init, boolean overwrite) {\n        Filter existing = getFilter(name);\n        if (existing == null || overwrite) {\n            if (filter instanceof Nameable) {\n                ((Nameable) filter).setName(name);\n            }\n            if (init) {\n                initFilter(filter);\n            }\n            this.filters.put(name, filter);\n        }\n    }\n\n    public void addToChain(String chainName, String filterName) {\n        addToChain(chainName, filterName, null);\n    }\n\n    public void addToChain(String chainName, String filterName, String chainSpecificFilterConfig) {\n        if (!StringUtils.hasText(chainName)) {\n            throw new IllegalArgumentException(\"chainName cannot be null or empty.\");\n        }\n        Filter filter = getFilter(filterName);\n        if (filter == null) {\n            throw new IllegalArgumentException(\"There is no filter with name '\" + filterName +\n                    \"' to apply to chain [\" + chainName + \"] in the pool of available Filters.  Ensure a \" +\n                    \"filter with that name/path has first been registered with the addFilter method(s).\");\n        }\n\n        applyChainConfig(chainName, filter, chainSpecificFilterConfig);\n\n        NamedFilterList chain = ensureChain(chainName);\n        chain.add(filter);\n    }\n\n    protected void applyChainConfig(String chainName, Filter filter, String chainSpecificFilterConfig) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Attempting to apply path [\" + chainName + \"] to filter [\" + filter + \"] \" +\n                    \"with config [\" + chainSpecificFilterConfig + \"]\");\n        }\n        if (filter instanceof PathConfigProcessor) {\n            ((PathConfigProcessor) filter).processPathConfig(chainName, chainSpecificFilterConfig);\n        } else {\n            if (StringUtils.hasText(chainSpecificFilterConfig)) {\n                //they specified a filter configuration, but the Filter doesn't implement PathConfigProcessor\n                //this is an erroneous config:\n                String msg = \"chainSpecificFilterConfig was specified, but the underlying \" +\n                        \"Filter instance is not an 'instanceof' \" +\n                        PathConfigProcessor.class.getName() + \".  This is required if the filter is to accept \" +\n                        \"chain-specific configuration.\";\n                throw new ConfigurationException(msg);\n            }\n        }\n    }\n\n    protected NamedFilterList ensureChain(String chainName) {\n        NamedFilterList chain = getChain(chainName);\n        if (chain == null) {\n            chain = new SimpleNamedFilterList(chainName);\n            this.filterChains.put(chainName, chain);\n        }\n        return chain;\n    }\n\n    public NamedFilterList getChain(String chainName) {\n        return this.filterChains.get(chainName);\n    }\n\n    public boolean hasChains() {\n        return !CollectionUtils.isEmpty(this.filterChains);\n    }\n\n    public Set<String> getChainNames() {\n        //noinspection unchecked\n        return this.filterChains != null ? this.filterChains.keySet() : Collections.EMPTY_SET;\n    }\n\n    public FilterChain proxy(FilterChain original, String chainName) {\n        NamedFilterList configured = getChain(chainName);\n        if (configured == null) {\n            String msg = \"There is no configured chain under the name/key [\" + chainName + \"].\";\n            throw new IllegalArgumentException(msg);\n        }\n        return configured.proxy(original);\n    }\n\n    /**\n     * Initializes the filter by calling <code>filter.init( {@link #getFilterConfig() getFilterConfig()} );<\/code>.\n     *\n     * @param filter the filter to initialize with the {@code FilterConfig}.\n     */\n    protected void initFilter(Filter filter) {\n        FilterConfig filterConfig = getFilterConfig();\n        if (filterConfig == null) {\n            throw new IllegalStateException(\"FilterConfig attribute has not been set.  This must occur before filter \" +\n                    \"initialization can occur.\");\n        }\n        try {\n            filter.init(filterConfig);\n        } catch (ServletException e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    protected void addDefaultFilters(boolean init) {\n        for (DefaultFilter defaultFilter : DefaultFilter.values()) {\n            addFilter(defaultFilter.name(), defaultFilter.newInstance(), init, false);\n        }\n    }\n}\n","lineNo":219}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.realm.text;\n\nimport org.apache.shiro.ShiroException;\nimport org.apache.shiro.io.ResourceUtils;\nimport org.apache.shiro.util.Destroyable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Enumeration;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * A {@link TextConfigurationRealm} that defers all logic to the parent class, but just enables\n * {@link java.util.Properties Properties} based configuration in addition to the parent class's String configuration.\n * <p/>\n * This class allows processing of a single .properties file for user, role, and\n * permission configuration.\n * <p/>\n * The {@link #setResourcePath resourcePath} <em>MUST<\/em> be set before this realm can be initialized.  You\n * can specify any resource path supported by\n * {@link ResourceUtils#getInputStreamForPath(String) ResourceUtils.getInputStreamForPath} method.\n * <p/>\n * The Properties format understood by this implementation must be written as follows:\n * <p/>\n * Each line's key/value pair represents either a user-to-role(s) mapping <em>or<\/em> a role-to-permission(s)\n * mapping.\n * <p/>\n * The user-to-role(s) lines have this format:<\/p>\n * <p/>\n * <code><b>user.<\/b><em>username<\/em> = <em>password<\/em>,role1,role2,...<\/code><\/p>\n * <p/>\n * Note that each key is prefixed with the token <b>{@code user.}<\/b>  Each value must adhere to the\n * the {@link #setUserDefinitions(String) setUserDefinitions(String)} JavaDoc.\n * <p/>\n * The role-to-permission(s) lines have this format:<\/p>\n * <p/>\n * <code><b>role.<\/b><em>rolename<\/em> = <em>permissionDefinition1<\/em>, <em>permissionDefinition2<\/em>, ...<\/code>\n * <p/>\n * where each key is prefixed with the token <b>{@code role.}<\/b> and the value adheres to the format specified in\n * the {@link #setRoleDefinitions(String) setRoleDefinitions(String)} JavaDoc.\n * <p/>\n * Here is an example of a very simple properties definition that conforms to the above format rules and corresponding\n * method JavaDocs:\n * <p/>\n * <code>user.root = <em>rootPassword<\/em>,administrator<br/>\n * user.jsmith = <em>jsmithPassword<\/em>,manager,engineer,employee<br/>\n * user.abrown = <em>abrownPassword<\/em>,qa,employee<br/>\n * user.djones = <em>djonesPassword<\/em>,qa,contractor<br/>\n * <br/>\n * role.administrator = *<br/>\n * role.manager = &quot;user:read,write&quot;, file:execute:/usr/local/emailManagers.sh<br/>\n * role.engineer = &quot;file:read,execute:/usr/local/tomcat/bin/startup.sh&quot;<br/>\n * role.employee = application:use:wiki<br/>\n * role.qa = &quot;server:view,start,shutdown,restart:someQaServer&quot;, server:view:someProductionServer<br/>\n * role.contractor = application:use:timesheet<\/code>\n *\n * @since 0.2\n */\npublic class PropertiesRealm extends TextConfigurationRealm implements Destroyable, Runnable {\n\n    //TODO - complete JavaDoc\n\n    /*-------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    private static final int DEFAULT_RELOAD_INTERVAL_SECONDS = 10;\n    private static final String USERNAME_PREFIX = \"user.\";\n    private static final String ROLENAME_PREFIX = \"role.\";\n    private static final String DEFAULT_RESOURCE_PATH = \"classpath:shiro-users.properties\";\n\n    /*-------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    private static final Logger log = LoggerFactory.getLogger(PropertiesRealm.class);\n\n    protected ExecutorService scheduler = null;\n    protected boolean useXmlFormat = false;\n    protected String resourcePath = DEFAULT_RESOURCE_PATH;\n    protected long fileLastModified;\n    protected int reloadIntervalSeconds = DEFAULT_RELOAD_INTERVAL_SECONDS;\n\n    public PropertiesRealm() {\n        super();\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    /**\n     * Determines whether or not the properties XML format should be used.  For more information, see\n     * {@link Properties#loadFromXML(java.io.InputStream)}\n     *\n     * @param useXmlFormat true to use XML or false to use the normal format.  Defaults to false.\n     */\n    public void setUseXmlFormat(boolean useXmlFormat) {\n        this.useXmlFormat = useXmlFormat;\n    }\n\n    /**\n     * Sets the path of the properties file to load user, role, and permission information from.  The properties\n     * file will be loaded using {@link ResourceUtils#getInputStreamForPath(String)} so any convention recongized\n     * by that method is accepted here.  For example, to load a file from the classpath use\n     * {@code classpath:myfile.properties}; to load a file from disk simply specify the full path; to load\n     * a file from a URL use {@code url:www.mysite.com/myfile.properties}.\n     *\n     * @param resourcePath the path to load the properties file from.  This is a required property.\n     */\n    public void setResourcePath(String resourcePath) {\n        this.resourcePath = resourcePath;\n    }\n\n    /**\n     * Sets the interval in seconds at which the property file will be checked for changes and reloaded.  If this is\n     * set to zero or less, property file reloading will be disabled.  If it is set to 1 or greater, then a\n     * separate thread will be created to monitor the propery file for changes and reload the file if it is updated.\n     *\n     * @param reloadIntervalSeconds the interval in seconds at which the property file should be examined for changes.\n     *                              If set to zero or less, reloading is disabled.\n     */\n    public void setReloadIntervalSeconds(int reloadIntervalSeconds) {\n        this.reloadIntervalSeconds = reloadIntervalSeconds;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    @Override\n    public void onInit() {\n        super.onInit();\n        //TODO - cleanup - this method shouldn't be necessary\n        afterRoleCacheSet();\n    }\n\n    protected void afterRoleCacheSet() {\n        loadProperties();\n        //we can only determine if files have been modified at runtime (not classpath entries or urls), so only\n        //start the thread in this case:\n        if (this.resourcePath.startsWith(ResourceUtils.FILE_PREFIX) && scheduler == null) {\n            startReloadThread();\n        }\n    }\n\n    /**\n     * Destroy reload scheduler if one exists.\n     */\n    public void destroy() {\n        try {\n            if (scheduler != null) {\n                scheduler.shutdown();\n            }\n        } catch (Exception e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to cleanly shutdown Scheduler.  Ignoring (shutting down)...\", e);\n            }\n        } finally {\n            scheduler = null;\n        }\n    }\n\n    protected void startReloadThread() {\n        if (this.reloadIntervalSeconds > 0) {\n            this.scheduler = Executors.newSingleThreadScheduledExecutor();\n            ((ScheduledExecutorService) this.scheduler).scheduleAtFixedRate(this, reloadIntervalSeconds, reloadIntervalSeconds, TimeUnit.SECONDS);\n        }\n    }\n\n    public void run() {\n        try {\n            reloadPropertiesIfNecessary();\n        } catch (Exception e) {\n            if (log.isErrorEnabled()) {\n                log.error(\"Error while reloading property files for realm.\", e);\n            }\n        }\n    }\n\n    private void loadProperties() {\n        if (resourcePath == null || resourcePath.length() == 0) {\n            throw new IllegalStateException(\"The resourcePath property is not set.  \" +\n                    \"It must be set prior to this realm being initialized.\");\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Loading user security information from file [\" + resourcePath + \"]...\");\n        }\n\n        Properties properties = loadProperties(resourcePath);\n        createRealmEntitiesFromProperties(properties);\n    }\n\n    private Properties loadProperties(String resourcePath) {\n        Properties props = new Properties();\n\n        InputStream is = null;\n        try {\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Opening input stream for path [\" + resourcePath + \"]...\");\n            }\n\n            is = ResourceUtils.getInputStreamForPath(resourcePath);\n            if (useXmlFormat) {\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Loading properties from path [\" + resourcePath + \"] in XML format...\");\n                }\n\n                props.loadFromXML(is);\n            } else {\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Loading properties from path [\" + resourcePath + \"]...\");\n                }\n\n                props.load(is);\n            }\n\n        } catch (IOException e) {\n            throw new ShiroException(\"Error reading properties path [\" + resourcePath + \"].  \" +\n                    \"Initializing of the realm from this file failed.\", e);\n        } finally {\n            ResourceUtils.close(is);\n        }\n\n        return props;\n    }\n\n\n    private void reloadPropertiesIfNecessary() {\n        if (isSourceModified()) {\n            restart();\n        }\n    }\n\n    private boolean isSourceModified() {\n        //we can only check last modified times on files - classpath and URL entries can't tell us modification times\n        return this.resourcePath.startsWith(ResourceUtils.FILE_PREFIX) && isFileModified();\n    }\n\n    private boolean isFileModified() {\n        //SHIRO-394: strip file prefix before constructing the File instance:\n        String fileNameWithoutPrefix = this.resourcePath.substring(this.resourcePath.indexOf(\":\") + 1);\n        File propertyFile = new File(fileNameWithoutPrefix);\n        long currentLastModified = propertyFile.lastModified();\n        if (currentLastModified > this.fileLastModified) {\n            this.fileLastModified = currentLastModified;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void restart() {\n        if (resourcePath == null || resourcePath.length() == 0) {\n            throw new IllegalStateException(\"The resourcePath property is not set.  \" +\n                    \"It must be set prior to this realm being initialized.\");\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Loading user security information from file [\" + resourcePath + \"]...\");\n        }\n\n        try {\n            destroy();\n        } catch (Exception e) {\n            //ignored\n        }\n        init();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void createRealmEntitiesFromProperties(Properties properties) {\n\n        StringBuilder userDefs = new StringBuilder();\n        StringBuilder roleDefs = new StringBuilder();\n\n        Enumeration<String> propNames = (Enumeration<String>) properties.propertyNames();\n\n        while (propNames.hasMoreElements()) {\n\n            String key = propNames.nextElement().trim();\n            String value = properties.getProperty(key).trim();\n            if (log.isTraceEnabled()) {\n                log.trace(\"Processing properties line - key: [\" + key + \"], value: [\" + value + \"].\");\n            }\n\n            if (isUsername(key)) {\n                String username = getUsername(key);\n                userDefs.append(username).append(\" = \").append(value).append(\"\\n\");\n            } else if (isRolename(key)) {\n                String rolename = getRolename(key);\n                roleDefs.append(rolename).append(\" = \").append(value).append(\"\\n\");\n            } else {\n                String msg = \"Encountered unexpected key/value pair.  All keys must be prefixed with either '\" +\n                        USERNAME_PREFIX + \"' or '\" + ROLENAME_PREFIX + \"'.\";\n                throw new IllegalStateException(msg);\n            }\n        }\n\n        setUserDefinitions(userDefs.toString());\n        setRoleDefinitions(roleDefs.toString());\n        processDefinitions();\n    }\n\n    protected String getName(String key, String prefix) {\n        return key.substring(prefix.length(), key.length());\n    }\n\n    protected boolean isUsername(String key) {\n        return key != null && key.startsWith(USERNAME_PREFIX);\n    }\n\n    protected boolean isRolename(String key) {\n        return key != null && key.startsWith(ROLENAME_PREFIX);\n    }\n\n    protected String getUsername(String key) {\n        return getName(key, USERNAME_PREFIX);\n    }\n\n    protected String getRolename(String key) {\n        return getName(key, ROLENAME_PREFIX);\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.realm.text;\n\nimport org.apache.shiro.ShiroException;\nimport org.apache.shiro.io.ResourceUtils;\nimport org.apache.shiro.util.Destroyable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Enumeration;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * A {@link TextConfigurationRealm} that defers all logic to the parent class, but just enables\n * {@link java.util.Properties Properties} based configuration in addition to the parent class's String configuration.\n * <p/>\n * This class allows processing of a single .properties file for user, role, and\n * permission configuration.\n * <p/>\n * The {@link #setResourcePath resourcePath} <em>MUST<\/em> be set before this realm can be initialized.  You\n * can specify any resource path supported by\n * {@link ResourceUtils#getInputStreamForPath(String) ResourceUtils.getInputStreamForPath} method.\n * <p/>\n * The Properties format understood by this implementation must be written as follows:\n * <p/>\n * Each line's key/value pair represents either a user-to-role(s) mapping <em>or<\/em> a role-to-permission(s)\n * mapping.\n * <p/>\n * The user-to-role(s) lines have this format:<\/p>\n * <p/>\n * <code><b>user.<\/b><em>username<\/em> = <em>password<\/em>,role1,role2,...<\/code><\/p>\n * <p/>\n * Note that each key is prefixed with the token <b>{@code user.}<\/b>  Each value must adhere to the\n * the {@link #setUserDefinitions(String) setUserDefinitions(String)} JavaDoc.\n * <p/>\n * The role-to-permission(s) lines have this format:<\/p>\n * <p/>\n * <code><b>role.<\/b><em>rolename<\/em> = <em>permissionDefinition1<\/em>, <em>permissionDefinition2<\/em>, ...<\/code>\n * <p/>\n * where each key is prefixed with the token <b>{@code role.}<\/b> and the value adheres to the format specified in\n * the {@link #setRoleDefinitions(String) setRoleDefinitions(String)} JavaDoc.\n * <p/>\n * Here is an example of a very simple properties definition that conforms to the above format rules and corresponding\n * method JavaDocs:\n * <p/>\n * <code>user.root = <em>rootPassword<\/em>,administrator<br/>\n * user.jsmith = <em>jsmithPassword<\/em>,manager,engineer,employee<br/>\n * user.abrown = <em>abrownPassword<\/em>,qa,employee<br/>\n * user.djones = <em>djonesPassword<\/em>,qa,contractor<br/>\n * <br/>\n * role.administrator = *<br/>\n * role.manager = &quot;user:read,write&quot;, file:execute:/usr/local/emailManagers.sh<br/>\n * role.engineer = &quot;file:read,execute:/usr/local/tomcat/bin/startup.sh&quot;<br/>\n * role.employee = application:use:wiki<br/>\n * role.qa = &quot;server:view,start,shutdown,restart:someQaServer&quot;, server:view:someProductionServer<br/>\n * role.contractor = application:use:timesheet<\/code>\n *\n * @since 0.2\n */\npublic class PropertiesRealm extends TextConfigurationRealm implements Destroyable, Runnable {\n\n    //TODO - complete JavaDoc\n\n    /*-------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    private static final int DEFAULT_RELOAD_INTERVAL_SECONDS = 10;\n    private static final String USERNAME_PREFIX = \"user.\";\n    private static final String ROLENAME_PREFIX = \"role.\";\n    private static final String DEFAULT_RESOURCE_PATH = \"classpath:shiro-users.properties\";\n\n    /*-------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    private static final Logger log = LoggerFactory.getLogger(PropertiesRealm.class);\n\n    protected ExecutorService scheduler = null;\n    protected boolean useXmlFormat = false;\n    protected String resourcePath = DEFAULT_RESOURCE_PATH;\n    protected long fileLastModified;\n    protected int reloadIntervalSeconds = DEFAULT_RELOAD_INTERVAL_SECONDS;\n\n    public PropertiesRealm() {\n        super();\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    /**\n     * Determines whether or not the properties XML format should be used.  For more information, see\n     * {@link Properties#loadFromXML(java.io.InputStream)}\n     *\n     * @param useXmlFormat true to use XML or false to use the normal format.  Defaults to false.\n     */\n    public void setUseXmlFormat(boolean useXmlFormat) {\n        this.useXmlFormat = useXmlFormat;\n    }\n\n    /**\n     * Sets the path of the properties file to load user, role, and permission information from.  The properties\n     * file will be loaded using {@link ResourceUtils#getInputStreamForPath(String)} so any convention recongized\n     * by that method is accepted here.  For example, to load a file from the classpath use\n     * {@code classpath:myfile.properties}; to load a file from disk simply specify the full path; to load\n     * a file from a URL use {@code url:www.mysite.com/myfile.properties}.\n     *\n     * @param resourcePath the path to load the properties file from.  This is a required property.\n     */\n    public void setResourcePath(String resourcePath) {\n        this.resourcePath = resourcePath;\n    }\n\n    /**\n     * Sets the interval in seconds at which the property file will be checked for changes and reloaded.  If this is\n     * set to zero or less, property file reloading will be disabled.  If it is set to 1 or greater, then a\n     * separate thread will be created to monitor the propery file for changes and reload the file if it is updated.\n     *\n     * @param reloadIntervalSeconds the interval in seconds at which the property file should be examined for changes.\n     *                              If set to zero or less, reloading is disabled.\n     */\n    public void setReloadIntervalSeconds(int reloadIntervalSeconds) {\n        this.reloadIntervalSeconds = reloadIntervalSeconds;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    @Override\n    public void onInit() {\n        super.onInit();\n        //TODO - cleanup - this method shouldn't be necessary\n        afterRoleCacheSet();\n    }\n\n    protected void afterRoleCacheSet() {\n        loadProperties();\n        //we can only determine if files have been modified at runtime (not classpath entries or urls), so only\n        //start the thread in this case:\n        if (this.resourcePath.startsWith(ResourceUtils.FILE_PREFIX) && scheduler == null) {\n            startReloadThread();\n        }\n    }\n\n    /**\n     * Destroy reload scheduler if one exists.\n     */\n    public void destroy() {\n        try {\n            if (scheduler != null) {\n                scheduler.shutdown();\n            }\n        } catch (Exception e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to cleanly shutdown Scheduler.  Ignoring (shutting down)...\", e);\n            }\n        } finally {\n            scheduler = null;\n        }\n    }\n\n    protected void startReloadThread() {\n        if (this.reloadIntervalSeconds > 0) {\n            this.scheduler = Executors.newSingleThreadScheduledExecutor();\n            ((ScheduledExecutorService) this.scheduler).scheduleAtFixedRate(this, reloadIntervalSeconds, reloadIntervalSeconds, TimeUnit.SECONDS);\n        }\n    }\n\n    public void run() {\n        try {\n            reloadPropertiesIfNecessary();\n        } catch (Exception e) {\n            if (log.isErrorEnabled()) {\n                log.error(\"Error while reloading property files for realm.\", e);\n            }\n        }\n    }\n\n    private void loadProperties() {\n        if (resourcePath == null || resourcePath.length() == 0) {\n            throw new IllegalStateException(\"The resourcePath property is not set.  \" +\n                    \"It must be set prior to this realm being initialized.\");\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Loading user security information from file [\" + resourcePath + \"]...\");\n        }\n\n        Properties properties = loadProperties(resourcePath);\n        createRealmEntitiesFromProperties(properties);\n    }\n\n    private Properties loadProperties(String resourcePath) {\n        Properties props = new Properties();\n\n        InputStream is = null;\n        try {\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Opening input stream for path [\" + resourcePath + \"]...\");\n            }\n\n            is = ResourceUtils.getInputStreamForPath(resourcePath);\n            if (useXmlFormat) {\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Loading properties from path [\" + resourcePath + \"] in XML format...\");\n                }\n\n                props.loadFromXML(is);\n            } else {\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Loading properties from path [\" + resourcePath + \"]...\");\n                }\n\n                props.load(is);\n            }\n\n        } catch (IOException e) {\n            throw new ShiroException(\"Error reading properties path [\" + resourcePath + \"].  \" +\n                    \"Initializing of the realm from this file failed.\", e);\n        } finally {\n            ResourceUtils.close(is);\n        }\n\n        return props;\n    }\n\n\n    private void reloadPropertiesIfNecessary() {\n        if (isSourceModified()) {\n            restart();\n        }\n    }\n\n    private boolean isSourceModified() {\n        //we can only check last modified times on files - classpath and URL entries can't tell us modification times\n        return this.resourcePath.startsWith(ResourceUtils.FILE_PREFIX) && isFileModified();\n    }\n\n    private boolean isFileModified() {\n        File propertyFile = new File(this.resourcePath);\n        long currentLastModified = propertyFile.lastModified();\n        if (currentLastModified > this.fileLastModified) {\n            this.fileLastModified = currentLastModified;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void restart() {\n        if (resourcePath == null || resourcePath.length() == 0) {\n            throw new IllegalStateException(\"The resourcePath property is not set.  \" +\n                    \"It must be set prior to this realm being initialized.\");\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Loading user security information from file [\" + resourcePath + \"]...\");\n        }\n\n        try {\n            destroy();\n        } catch (Exception e) {\n            //ignored\n        }\n        init();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void createRealmEntitiesFromProperties(Properties properties) {\n\n        StringBuilder userDefs = new StringBuilder();\n        StringBuilder roleDefs = new StringBuilder();\n\n        Enumeration<String> propNames = (Enumeration<String>) properties.propertyNames();\n\n        while (propNames.hasMoreElements()) {\n\n            String key = propNames.nextElement().trim();\n            String value = properties.getProperty(key).trim();\n            if (log.isTraceEnabled()) {\n                log.trace(\"Processing properties line - key: [\" + key + \"], value: [\" + value + \"].\");\n            }\n\n            if (isUsername(key)) {\n                String username = getUsername(key);\n                userDefs.append(username).append(\" = \").append(value).append(\"\\n\");\n            } else if (isRolename(key)) {\n                String rolename = getRolename(key);\n                roleDefs.append(rolename).append(\" = \").append(value).append(\"\\n\");\n            } else {\n                String msg = \"Encountered unexpected key/value pair.  All keys must be prefixed with either '\" +\n                        USERNAME_PREFIX + \"' or '\" + ROLENAME_PREFIX + \"'.\";\n                throw new IllegalStateException(msg);\n            }\n        }\n\n        setUserDefinitions(userDefs.toString());\n        setRoleDefinitions(roleDefs.toString());\n        processDefinitions();\n    }\n\n    protected String getName(String key, String prefix) {\n        return key.substring(prefix.length(), key.length());\n    }\n\n    protected boolean isUsername(String key) {\n        return key != null && key.startsWith(USERNAME_PREFIX);\n    }\n\n    protected boolean isRolename(String key) {\n        return key != null && key.startsWith(ROLENAME_PREFIX);\n    }\n\n    protected String getUsername(String key) {\n        return getName(key, USERNAME_PREFIX);\n    }\n\n    protected String getRolename(String key) {\n        return getName(key, ROLENAME_PREFIX);\n    }\n}\n","lineNo":269}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.realm;\n\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.ExpiredCredentialsException;\nimport org.apache.shiro.authc.LockedAccountException;\nimport org.apache.shiro.authc.SimpleAccount;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleRole;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.util.CollectionUtils;\n\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * A simple implementation of the {@link Realm Realm} interface that\n * uses a set of configured user accounts and roles to support authentication and authorization.  Each account entry\n * specifies the username, password, and roles for a user.  Roles can also be mapped\n * to permissions and associated with users.\n * <p/>\n * User accounts and roles are stored in two {@code Map}s in memory, so it is expected that the total number of either\n * is not sufficiently large.\n *\n * @since 0.1\n */\npublic class SimpleAccountRealm extends AuthorizingRealm {\n\n    //TODO - complete JavaDoc\n    protected final Map<String, SimpleAccount> users; //username-to-SimpleAccount\n    protected final Map<String, SimpleRole> roles; //roleName-to-SimpleRole\n    protected final ReadWriteLock USERS_LOCK;\n    protected final ReadWriteLock ROLES_LOCK;\n\n    public SimpleAccountRealm() {\n        this.users = new LinkedHashMap<String, SimpleAccount>();\n        this.roles = new LinkedHashMap<String, SimpleRole>();\n        USERS_LOCK = new ReentrantReadWriteLock();\n        ROLES_LOCK = new ReentrantReadWriteLock();\n        //SimpleAccountRealms are memory-only realms - no need for an additional cache mechanism since we're\n        //already as memory-efficient as we can be:\n        setCachingEnabled(false);\n    }\n\n    public SimpleAccountRealm(String name) {\n        this();\n        setName(name);\n    }\n\n    protected SimpleAccount getUser(String username) {\n        USERS_LOCK.readLock().lock();\n        try {\n            return this.users.get(username);\n        } finally {\n            USERS_LOCK.readLock().unlock();\n        }\n    }\n\n    public boolean accountExists(String username) {\n        return getUser(username) != null;\n    }\n\n    public void addAccount(String username, String password) {\n        addAccount(username, password, (String[]) null);\n    }\n\n    public void addAccount(String username, String password, String... roles) {\n        Set<String> roleNames = CollectionUtils.asSet(roles);\n        SimpleAccount account = new SimpleAccount(username, password, getName(), roleNames, null);\n        add(account);\n    }\n\n    protected String getUsername(SimpleAccount account) {\n        return getUsername(account.getPrincipals());\n    }\n\n    protected String getUsername(PrincipalCollection principals) {\n        return getAvailablePrincipal(principals).toString();\n    }\n\n    protected void add(SimpleAccount account) {\n        String username = getUsername(account);\n        USERS_LOCK.writeLock().lock();\n        try {\n            this.users.put(username, account);\n        } finally {\n            USERS_LOCK.writeLock().unlock();\n        }\n    }\n\n    protected SimpleRole getRole(String rolename) {\n        ROLES_LOCK.readLock().lock();\n        try {\n            return roles.get(rolename);\n        } finally {\n            ROLES_LOCK.readLock().unlock();\n        }\n    }\n\n    public boolean roleExists(String name) {\n        return getRole(name) != null;\n    }\n\n    public void addRole(String name) {\n        add(new SimpleRole(name));\n    }\n\n    protected void add(SimpleRole role) {\n        ROLES_LOCK.writeLock().lock();\n        try {\n            roles.put(role.getName(), role);\n        } finally {\n            ROLES_LOCK.writeLock().unlock();\n        }\n    }\n\n    protected static Set<String> toSet(String delimited, String delimiter) {\n        if (delimited == null || delimited.trim().equals(\"\")) {\n            return null;\n        }\n\n        Set<String> values = new HashSet<String>();\n        String[] rolenamesArray = delimited.split(delimiter);\n        for (String s : rolenamesArray) {\n            String trimmed = s.trim();\n            if (trimmed.length() > 0) {\n                values.add(trimmed);\n            }\n        }\n\n        return values;\n    }\n\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n        SimpleAccount account = getUser(upToken.getUsername());\n\n        if (account != null) {\n\n            if (account.isLocked()) {\n                throw new LockedAccountException(\"Account [\" + account + \"] is locked.\");\n            }\n            if (account.isCredentialsExpired()) {\n                String msg = \"The credentials for account [\" + account + \"] are expired\";\n                throw new ExpiredCredentialsException(msg);\n            }\n\n        }\n\n        return account;\n    }\n\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        String username = getUsername(principals);\n        USERS_LOCK.readLock().lock();\n        try {\n            return this.users.get(username);\n        } finally {\n            USERS_LOCK.readLock().unlock();\n        }\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.realm;\n\nimport org.apache.shiro.authc.*;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleRole;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.util.CollectionUtils;\n\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * A simple implementation of the {@link Realm Realm} interface that\n * uses a set of configured user accounts and roles to support authentication and authorization.  Each account entry\n * specifies the username, password, and roles for a user.  Roles can also be mapped\n * to permissions and associated with users.\n * <p/>\n * User accounts and roles are stored in two {@code Map}s in memory, so it is expected that the total number of either\n * is not sufficiently large.\n *\n * @since 0.1\n */\npublic class SimpleAccountRealm extends AuthorizingRealm {\n\n    //TODO - complete JavaDoc\n\n    protected final Map<String, SimpleAccount> users; //username-to-SimpleAccount\n    protected final Map<String, SimpleRole> roles; //roleName-to-SimpleRole\n\n    public SimpleAccountRealm() {\n        this.users = new LinkedHashMap<String, SimpleAccount>();\n        this.roles = new LinkedHashMap<String, SimpleRole>();\n        //SimpleAccountRealms are memory-only realms - no need for an additional cache mechanism since we're\n        //already as memory-efficient as we can be:\n        setCachingEnabled(false);\n    }\n\n    public SimpleAccountRealm(String name) {\n        this();\n        setName(name);\n    }\n\n    protected SimpleAccount getUser(String username) {\n        return this.users.get(username);\n    }\n\n    public boolean accountExists(String username) {\n        return getUser(username) != null;\n    }\n\n    public void addAccount(String username, String password) {\n        addAccount(username, password, (String[]) null);\n    }\n\n    public void addAccount(String username, String password, String... roles) {\n        Set<String> roleNames = CollectionUtils.asSet(roles);\n        SimpleAccount account = new SimpleAccount(username, password, getName(), roleNames, null);\n        add(account);\n    }\n\n    protected String getUsername(SimpleAccount account) {\n        return getUsername(account.getPrincipals());\n    }\n\n    protected String getUsername(PrincipalCollection principals) {\n        return getAvailablePrincipal(principals).toString();\n    }\n\n    protected void add(SimpleAccount account) {\n        String username = getUsername(account);\n        this.users.put(username, account);\n    }\n\n    protected SimpleRole getRole(String rolename) {\n        return roles.get(rolename);\n    }\n\n    public boolean roleExists(String name) {\n        return getRole(name) != null;\n    }\n\n    public void addRole(String name) {\n        add(new SimpleRole(name));\n    }\n\n    protected void add(SimpleRole role) {\n        roles.put(role.getName(), role);\n    }\n\n    protected static Set<String> toSet(String delimited, String delimiter) {\n        if (delimited == null || delimited.trim().equals(\"\")) {\n            return null;\n        }\n\n        Set<String> values = new HashSet<String>();\n        String[] rolenamesArray = delimited.split(delimiter);\n        for (String s : rolenamesArray) {\n            String trimmed = s.trim();\n            if (trimmed.length() > 0) {\n                values.add(trimmed);\n            }\n        }\n\n        return values;\n    }\n\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n        SimpleAccount account = getUser(upToken.getUsername());\n\n        if (account != null) {\n\n            if (account.isLocked()) {\n                throw new LockedAccountException(\"Account [\" + account + \"] is locked.\");\n            }\n            if (account.isCredentialsExpired()) {\n                String msg = \"The credentials for account [\" + account + \"] are expired\";\n                throw new ExpiredCredentialsException(msg);\n            }\n\n        }\n\n        return account;\n    }\n\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        return this.users.get(getUsername(principals));\n    }\n}\n","lineNo":178}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.config;\n\nimport org.apache.commons.beanutils.BeanUtils;\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.shiro.codec.Base64;\nimport org.apache.shiro.codec.Hex;\nimport org.apache.shiro.config.event.BeanEvent;\nimport org.apache.shiro.config.event.ConfiguredBeanEvent;\nimport org.apache.shiro.config.event.DestroyedBeanEvent;\nimport org.apache.shiro.config.event.InitializedBeanEvent;\nimport org.apache.shiro.config.event.InstantiatedBeanEvent;\nimport org.apache.shiro.event.EventBus;\nimport org.apache.shiro.event.EventBusAware;\nimport org.apache.shiro.event.Subscribe;\nimport org.apache.shiro.event.support.DefaultEventBus;\nimport org.apache.shiro.util.Assert;\nimport org.apache.shiro.util.ByteSource;\nimport org.apache.shiro.util.ClassUtils;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.util.Factory;\nimport org.apache.shiro.util.LifecycleUtils;\nimport org.apache.shiro.util.Nameable;\nimport org.apache.shiro.util.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.beans.PropertyDescriptor;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n\n/**\n * Object builder that uses reflection and Apache Commons BeanUtils to build objects given a\n * map of \"property values\".  Typically these come from the Shiro INI configuration and are used\n * to construct or modify the SecurityManager, its dependencies, and web-based security filters.\n * <p/>\n * Recognizes {@link Factory} implementations and will call\n * {@link org.apache.shiro.util.Factory#getInstance() getInstance} to satisfy any reference to this bean.\n *\n * @since 0.9\n */\npublic class ReflectionBuilder {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(ReflectionBuilder.class);\n\n    private static final String OBJECT_REFERENCE_BEGIN_TOKEN = \"$\";\n    private static final String ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN = \"\\\\$\";\n    private static final String GLOBAL_PROPERTY_PREFIX = \"shiro\";\n    private static final char MAP_KEY_VALUE_DELIMITER = ':';\n    private static final String HEX_BEGIN_TOKEN = \"0x\";\n    private static final String NULL_VALUE_TOKEN = \"null\";\n    private static final String EMPTY_STRING_VALUE_TOKEN = \"\\\"\\\"\";\n    private static final char STRING_VALUE_DELIMETER = '\"';\n    private static final char MAP_PROPERTY_BEGIN_TOKEN = '[';\n    private static final char MAP_PROPERTY_END_TOKEN = ']';\n\n    private static final String EVENT_BUS_NAME = \"eventBus\";\n\n    private final Map<String, Object> objects;\n    /**\n     * @since 1.3\n     */\n    private EventBus eventBus;\n    /**\n     * Keeps track of event subscribers that were automatically registered by this ReflectionBuilder during\n     * object construction.  This is used in case a new EventBus is discovered during object graph\n     * construction:  upon discovery of the new EventBus, the existing subscribers will be unregistered from the\n     * old EventBus and then re-registered with the new EventBus.\n     *\n     * @since 1.3\n     */\n    private final Map<String,Object> registeredEventSubscribers;\n\n    //@since 1.3\n    private Map<String,Object> createDefaultObjectMap() {\n        Map<String,Object> map = new LinkedHashMap<String, Object>();\n        map.put(EVENT_BUS_NAME, new DefaultEventBus());\n        return map;\n    }\n\n    public ReflectionBuilder() {\n        this(null);\n    }\n\n    public ReflectionBuilder(Map<String, ?> defaults) {\n        this.objects = createDefaultObjectMap();\n        this.registeredEventSubscribers = new LinkedHashMap<String,Object>();\n        apply(defaults);\n    }\n\n    private void apply(Map<String, ?> objects) {\n        if(!CollectionUtils.isEmpty(objects)) {\n            this.objects.putAll(objects);\n        }\n        EventBus found = findEventBus(this.objects);\n        Assert.notNull(found, \"An \" + EventBus.class.getName() + \" instance must be present in the object defaults\");\n        enableEvents(found);\n    }\n\n    public Map<String, ?> getObjects() {\n        return objects;\n    }\n\n    /**\n     * @param objects\n     */\n    public void setObjects(Map<String, ?> objects) {\n        this.objects.clear();\n        this.objects.putAll(createDefaultObjectMap());\n        apply(objects);\n    }\n\n    //@since 1.3\n    private void enableEvents(EventBus eventBus) {\n        Assert.notNull(eventBus, \"EventBus argument cannot be null.\");\n        //clean up old auto-registered subscribers:\n        for (Object subscriber : this.registeredEventSubscribers.values()) {\n            this.eventBus.unregister(subscriber);\n        }\n        this.registeredEventSubscribers.clear();\n\n        this.eventBus = eventBus;\n\n        for(Map.Entry<String,Object> entry : this.objects.entrySet()) {\n            enableEventsIfNecessary(entry.getValue(), entry.getKey());\n        }\n    }\n\n    //@since 1.3\n    private void enableEventsIfNecessary(Object bean, String name) {\n        boolean applied = applyEventBusIfNecessary(bean);\n        if (!applied) {\n            //if the event bus is applied, and the bean wishes to be a subscriber as well (not just a publisher),\n            // we assume that the implementation registers itself with the event bus, i.e. eventBus.register(this);\n\n            //if the event bus isn't applied, only then do we need to check to see if the bean is an event subscriber,\n            // and if so, register it on the event bus automatically since it has no ability to do so itself:\n            if (isEventSubscriber(bean, name)) {\n                //found an event subscriber, so register them with the EventBus:\n                this.eventBus.register(bean);\n                this.registeredEventSubscribers.put(name, bean);\n            }\n        }\n    }\n\n    //@since 1.3\n    private boolean isEventSubscriber(Object bean, String name) {\n        List annotatedMethods = ClassUtils.getAnnotatedMethods(bean.getClass(), Subscribe.class);\n        return !CollectionUtils.isEmpty(annotatedMethods);\n    }\n\n    //@since 1.3\n    protected EventBus findEventBus(Map<String,?> objects) {\n\n        if (CollectionUtils.isEmpty(objects)) {\n            return null;\n        }\n\n        //prefer a named object first:\n        Object value = objects.get(EVENT_BUS_NAME);\n        if (value != null && value instanceof EventBus) {\n            return (EventBus)value;\n        }\n\n        //couldn't find a named 'eventBus' EventBus object.  Try to find the first typed value we can:\n        for( Object v : objects.values()) {\n            if (v instanceof EventBus) {\n                return (EventBus)v;\n            }\n        }\n\n        return null;\n    }\n\n    private boolean applyEventBusIfNecessary(Object value) {\n        if (value instanceof EventBusAware) {\n            ((EventBusAware)value).setEventBus(this.eventBus);\n            return true;\n        }\n        return false;\n    }\n\n    public Object getBean(String id) {\n        return objects.get(id);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public <T> T getBean(String id, Class<T> requiredType) {\n        if (requiredType == null) {\n            throw new NullPointerException(\"requiredType argument cannot be null.\");\n        }\n        Object bean = getBean(id);\n        if (bean == null) {\n            return null;\n        }\n        Assert.state(requiredType.isAssignableFrom(bean.getClass()),\n                \"Bean with id [\" + id + \"] is not of the required type [\" + requiredType.getName() + \"].\");\n        return (T) bean;\n    }\n\n    private String parseBeanId(String lhs) {\n        Assert.notNull(lhs);\n        if (lhs.indexOf('.') < 0) {\n            return lhs;\n        }\n        String classSuffix = \".class\";\n        int index = lhs.indexOf(classSuffix);\n        if (index >= 0) {\n            return lhs.substring(0, index);\n        }\n        return null;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Map<String, ?> buildObjects(Map<String, String> kvPairs) {\n\n        if (kvPairs != null && !kvPairs.isEmpty()) {\n\n            BeanConfigurationProcessor processor = new BeanConfigurationProcessor();\n\n            for (Map.Entry<String, String> entry : kvPairs.entrySet()) {\n                String lhs = entry.getKey();\n                String rhs = entry.getValue();\n\n                String beanId = parseBeanId(lhs);\n                if (beanId != null) { //a beanId could be parsed, so the line is a bean instance definition\n                    processor.add(new InstantiationStatement(beanId, rhs));\n                } else { //the line must be a property configuration\n                    processor.add(new AssignmentStatement(lhs, rhs));\n                }\n            }\n\n            processor.execute();\n        }\n\n        return objects;\n    }\n\n    public void destroy() {\n        final Map<String, Object> immutableObjects = Collections.unmodifiableMap(objects);\n\n        //destroy objects in the opposite order they were initialized:\n        List<Map.Entry<String,?>> entries = new ArrayList<Map.Entry<String,?>>(objects.entrySet());\n        Collections.reverse(entries);\n\n        for(Map.Entry<String, ?> entry: entries) {\n            String id = entry.getKey();\n            Object bean = entry.getValue();\n\n            //don't destroy the eventbus until the end - we need it to still be 'alive' while publishing destroy events:\n            if (bean != this.eventBus) { //memory equality check (not .equals) on purpose\n                LifecycleUtils.destroy(bean);\n                BeanEvent event = new DestroyedBeanEvent(id, bean, immutableObjects);\n                eventBus.publish(event);\n                this.eventBus.unregister(bean); //bean is now destroyed - it should not receive any other events\n            }\n        }\n        //only now destroy the event bus:\n        LifecycleUtils.destroy(this.eventBus);\n    }\n\n    protected void createNewInstance(Map<String, Object> objects, String name, String value) {\n\n        Object currentInstance = objects.get(name);\n        if (currentInstance != null) {\n            log.info(\"An instance with name '{}' already exists.  \" +\n                    \"Redefining this object as a new instance of type {}\", name, value);\n        }\n\n        Object instance;//name with no property, assume right hand side of equals sign is the class name:\n        try {\n            instance = ClassUtils.newInstance(value);\n            if (instance instanceof Nameable) {\n                ((Nameable) instance).setName(name);\n            }\n        } catch (Exception e) {\n            String msg = \"Unable to instantiate class [\" + value + \"] for object named '\" + name + \"'.  \" +\n                    \"Please ensure you've specified the fully qualified class name correctly.\";\n            throw new ConfigurationException(msg, e);\n        }\n        objects.put(name, instance);\n    }\n\n    protected void applyProperty(String key, String value, Map objects) {\n\n        int index = key.indexOf('.');\n\n        if (index >= 0) {\n            String name = key.substring(0, index);\n            String property = key.substring(index + 1, key.length());\n\n            if (GLOBAL_PROPERTY_PREFIX.equalsIgnoreCase(name)) {\n                applyGlobalProperty(objects, property, value);\n            } else {\n                applySingleProperty(objects, name, property, value);\n            }\n\n        } else {\n            throw new IllegalArgumentException(\"All property keys must contain a '.' character. \" +\n                    \"(e.g. myBean.property = value)  These should already be separated out by buildObjects().\");\n        }\n    }\n\n    protected void applyGlobalProperty(Map objects, String property, String value) {\n        for (Object instance : objects.values()) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(instance, property);\n                if (pd != null) {\n                    applyProperty(instance, property, value);\n                }\n            } catch (Exception e) {\n                String msg = \"Error retrieving property descriptor for instance \" +\n                        \"of type [\" + instance.getClass().getName() + \"] \" +\n                        \"while setting property [\" + property + \"]\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected void applySingleProperty(Map objects, String name, String property, String value) {\n        Object instance = objects.get(name);\n        if (property.equals(\"class\")) {\n            throw new IllegalArgumentException(\"Property keys should not contain 'class' properties since these \" +\n                    \"should already be separated out by buildObjects().\");\n\n        } else if (instance == null) {\n            String msg = \"Configuration error.  Specified object [\" + name + \"] with property [\" +\n                    property + \"] without first defining that object's class.  Please first \" +\n                    \"specify the class property first, e.g. myObject = fully_qualified_class_name \" +\n                    \"and then define additional properties.\";\n            throw new IllegalArgumentException(msg);\n\n        } else {\n            applyProperty(instance, property, value);\n        }\n    }\n\n    protected boolean isReference(String value) {\n        return value != null && value.startsWith(OBJECT_REFERENCE_BEGIN_TOKEN);\n    }\n\n    protected String getId(String referenceToken) {\n        return referenceToken.substring(OBJECT_REFERENCE_BEGIN_TOKEN.length());\n    }\n\n    protected Object getReferencedObject(String id) {\n        Object o = objects != null && !objects.isEmpty() ? objects.get(id) : null;\n        if (o == null) {\n            String msg = \"The object with id [\" + id + \"] has not yet been defined and therefore cannot be \" +\n                    \"referenced.  Please ensure objects are defined in the order in which they should be \" +\n                    \"created and made available for future reference.\";\n            throw new UnresolveableReferenceException(msg);\n        }\n        return o;\n    }\n\n    protected String unescapeIfNecessary(String value) {\n        if (value != null && value.startsWith(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN)) {\n            return value.substring(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN.length() - 1);\n        }\n        return value;\n    }\n\n    protected Object resolveReference(String reference) {\n        String id = getId(reference);\n        log.debug(\"Encountered object reference '{}'.  Looking up object with id '{}'\", reference, id);\n        final Object referencedObject = getReferencedObject(id);\n        if (referencedObject instanceof Factory) {\n            return ((Factory) referencedObject).getInstance();\n        }\n        return referencedObject;\n    }\n\n    protected boolean isTypedProperty(Object object, String propertyName, Class clazz) {\n        if (clazz == null) {\n            throw new NullPointerException(\"type (class) argument cannot be null.\");\n        }\n        try {\n            PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(object, propertyName);\n            if (descriptor == null) {\n                String msg = \"Property '\" + propertyName + \"' does not exist for object of \" +\n                        \"type \" + object.getClass().getName() + \".\";\n                throw new ConfigurationException(msg);\n            }\n            Class propertyClazz = descriptor.getPropertyType();\n            return clazz.isAssignableFrom(propertyClazz);\n        } catch (ConfigurationException ce) {\n            //let it propagate:\n            throw ce;\n        } catch (Exception e) {\n            String msg = \"Unable to determine if property [\" + propertyName + \"] represents a \" + clazz.getName();\n            throw new ConfigurationException(msg, e);\n        }\n    }\n\n    protected Set<?> toSet(String sValue) {\n        String[] tokens = StringUtils.split(sValue);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n        Set<String> setTokens = new LinkedHashSet<String>(Arrays.asList(tokens));\n\n        //now convert into correct values and/or references:\n        Set<Object> values = new LinkedHashSet<Object>(setTokens.size());\n        for (String token : setTokens) {\n            Object value = resolveValue(token);\n            values.add(value);\n        }\n        return values;\n    }\n\n    protected Map<?, ?> toMap(String sValue) {\n        String[] tokens = StringUtils.split(sValue, StringUtils.DEFAULT_DELIMITER_CHAR,\n                StringUtils.DEFAULT_QUOTE_CHAR, StringUtils.DEFAULT_QUOTE_CHAR, true, true);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n\n        Map<String, String> mapTokens = new LinkedHashMap<String, String>(tokens.length);\n        for (String token : tokens) {\n            String[] kvPair = StringUtils.split(token, MAP_KEY_VALUE_DELIMITER);\n            if (kvPair == null || kvPair.length != 2) {\n                String msg = \"Map property value [\" + sValue + \"] contained key-value pair token [\" +\n                        token + \"] that does not properly split to a single key and pair.  This must be the \" +\n                        \"case for all map entries.\";\n                throw new ConfigurationException(msg);\n            }\n            mapTokens.put(kvPair[0], kvPair[1]);\n        }\n\n        //now convert into correct values and/or references:\n        Map<Object, Object> map = new LinkedHashMap<Object, Object>(mapTokens.size());\n        for (Map.Entry<String, String> entry : mapTokens.entrySet()) {\n            Object key = resolveValue(entry.getKey());\n            Object value = resolveValue(entry.getValue());\n            map.put(key, value);\n        }\n        return map;\n    }\n\n\n    protected List<?> toList(String sValue) {\n        String[] tokens = StringUtils.split(sValue);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n\n        //now convert into correct values and/or references:\n        List<Object> values = new ArrayList<Object>(tokens.length);\n        for (String token : tokens) {\n            Object value = resolveValue(token);\n            values.add(value);\n        }\n        return values;\n    }\n\n    protected byte[] toBytes(String sValue) {\n        if (sValue == null) {\n            return null;\n        }\n        byte[] bytes;\n        if (sValue.startsWith(HEX_BEGIN_TOKEN)) {\n            String hex = sValue.substring(HEX_BEGIN_TOKEN.length());\n            bytes = Hex.decode(hex);\n        } else {\n            //assume base64 encoded:\n            bytes = Base64.decode(sValue);\n        }\n        return bytes;\n    }\n\n    protected Object resolveValue(String stringValue) {\n        Object value;\n        if (isReference(stringValue)) {\n            value = resolveReference(stringValue);\n        } else {\n            value = unescapeIfNecessary(stringValue);\n        }\n        return value;\n    }\n\n    protected String checkForNullOrEmptyLiteral(String stringValue) {\n        if (stringValue == null) {\n            return null;\n        }\n        //check if the value is the actual literal string 'null' (expected to be wrapped in quotes):\n        if (stringValue.equals(\"\\\"null\\\"\")) {\n            return NULL_VALUE_TOKEN;\n        }\n        //or the actual literal string of two quotes '\"\"' (expected to be wrapped in quotes):\n        else if (stringValue.equals(\"\\\"\\\"\\\"\\\"\")) {\n            return EMPTY_STRING_VALUE_TOKEN;\n        } else {\n            return stringValue;\n        }\n    }\n    \n    protected void applyProperty(Object object, String propertyPath, Object value) {\n\n        int mapBegin = propertyPath.indexOf(MAP_PROPERTY_BEGIN_TOKEN);\n        int mapEnd = -1;\n        String mapPropertyPath = null;\n        String keyString = null;\n\n        String remaining = null;\n        \n        if (mapBegin >= 0) {\n            //a map is being referenced in the overall property path.  Find just the map's path:\n            mapPropertyPath = propertyPath.substring(0, mapBegin);\n            //find the end of the map reference:\n            mapEnd = propertyPath.indexOf(MAP_PROPERTY_END_TOKEN, mapBegin);\n            //find the token in between the [ and the ] (the map/array key or index):\n            keyString = propertyPath.substring(mapBegin+1, mapEnd);\n\n            //find out if there is more path reference to follow.  If not, we're at a terminal of the OGNL expression\n            if (propertyPath.length() > (mapEnd+1)) {\n                remaining = propertyPath.substring(mapEnd+1);\n                if (remaining.startsWith(\".\")) {\n                    remaining = StringUtils.clean(remaining.substring(1));\n                }\n            }\n        }\n        \n        if (remaining == null) {\n            //we've terminated the OGNL expression.  Check to see if we're assigning a property or a map entry:\n            if (keyString == null) {\n                //not a map or array value assignment - assign the property directly:\n                setProperty(object, propertyPath, value);\n            } else {\n                //we're assigning a map or array entry.  Check to see which we should call:\n                if (isTypedProperty(object, mapPropertyPath, Map.class)) {\n                    Map map = (Map)getProperty(object, mapPropertyPath);\n                    Object mapKey = resolveValue(keyString);\n                    //noinspection unchecked\n                    map.put(mapKey, value);\n                } else {\n                    //must be an array property.  Convert the key string to an index:\n                    int index = Integer.valueOf(keyString);\n                    setIndexedProperty(object, mapPropertyPath, index, value);\n                }\n            }\n        } else {\n            //property is being referenced as part of a nested path.  Find the referenced map/array entry and\n            //recursively call this method with the remaining property path\n            Object referencedValue = null;\n            if (isTypedProperty(object, mapPropertyPath, Map.class)) {\n                Map map = (Map)getProperty(object, mapPropertyPath);\n                Object mapKey = resolveValue(keyString);\n                referencedValue = map.get(mapKey);\n            } else {\n                //must be an array property:\n                int index = Integer.valueOf(keyString);\n                referencedValue = getIndexedProperty(object, mapPropertyPath, index);\n            }\n\n            if (referencedValue == null) {\n                throw new ConfigurationException(\"Referenced map/array value '\" + mapPropertyPath + \"[\" +\n                keyString + \"]' does not exist.\");\n            }\n\n            applyProperty(referencedValue, remaining, value);\n        }\n    }\n    \n    private void setProperty(Object object, String propertyPath, Object value) {\n        try {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Applying property [{}] value [{}] on object of type [{}]\",\n                        new Object[]{propertyPath, value, object.getClass().getName()});\n            }\n            BeanUtils.setProperty(object, propertyPath, value);\n        } catch (Exception e) {\n            String msg = \"Unable to set property '\" + propertyPath + \"' with value [\" + value + \"] on object \" +\n                    \"of type \" + (object != null ? object.getClass().getName() : null) + \".  If \" +\n                    \"'\" + value + \"' is a reference to another (previously defined) object, prefix it with \" +\n                    \"'\" + OBJECT_REFERENCE_BEGIN_TOKEN + \"' to indicate that the referenced \" +\n                    \"object should be used as the actual value.  \" +\n                    \"For example, \" + OBJECT_REFERENCE_BEGIN_TOKEN + value;\n            throw new ConfigurationException(msg, e);\n        }\n    }\n    \n    private Object getProperty(Object object, String propertyPath) {\n        try {\n            return PropertyUtils.getProperty(object, propertyPath);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Unable to access property '\" + propertyPath + \"'\", e);\n        }\n    }\n    \n    private void setIndexedProperty(Object object, String propertyPath, int index, Object value) {\n        try {\n            PropertyUtils.setIndexedProperty(object, propertyPath, index, value);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Unable to set array property '\" + propertyPath + \"'\", e);\n        }\n    }\n    \n    private Object getIndexedProperty(Object object, String propertyPath, int index) {\n        try {\n            return PropertyUtils.getIndexedProperty(object, propertyPath, index);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Unable to acquire array property '\" + propertyPath + \"'\", e);\n        }\n    }\n    \n    protected boolean isIndexedPropertyAssignment(String propertyPath) {\n        return propertyPath.endsWith(\"\" + MAP_PROPERTY_END_TOKEN);\n    }\n\n    protected void applyProperty(Object object, String propertyName, String stringValue) {\n\n        Object value;\n\n        if (NULL_VALUE_TOKEN.equals(stringValue)) {\n            value = null;\n        } else if (EMPTY_STRING_VALUE_TOKEN.equals(stringValue)) {\n            value = StringUtils.EMPTY_STRING;\n        } else if (isIndexedPropertyAssignment(propertyName)) {\n            String checked = checkForNullOrEmptyLiteral(stringValue);\n            value = resolveValue(checked);\n        } else if (isTypedProperty(object, propertyName, Set.class)) {\n            value = toSet(stringValue);\n        } else if (isTypedProperty(object, propertyName, Map.class)) {\n            value = toMap(stringValue);\n        } else if (isTypedProperty(object, propertyName, List.class) ||\n                isTypedProperty(object, propertyName, Collection.class)) {\n            value = toList(stringValue);\n        } else if (isTypedProperty(object, propertyName, byte[].class)) {\n            value = toBytes(stringValue);\n        } else if (isTypedProperty(object, propertyName, ByteSource.class)) {\n            byte[] bytes = toBytes(stringValue);\n            value = ByteSource.Util.bytes(bytes);\n        } else {\n            String checked = checkForNullOrEmptyLiteral(stringValue);\n            value = resolveValue(checked);\n        }\n\n        applyProperty(object, propertyName, value);\n    }\n\n    private class BeanConfigurationProcessor {\n\n        private final List<Statement> statements = new ArrayList<Statement>();\n        private final List<BeanConfiguration> beanConfigurations = new ArrayList<BeanConfiguration>();\n\n        public void add(Statement statement) {\n\n            statements.add(statement); //we execute bean configuration statements in the order they are declared.\n\n            if (statement instanceof InstantiationStatement) {\n                InstantiationStatement is = (InstantiationStatement)statement;\n                beanConfigurations.add(new BeanConfiguration(is));\n            } else {\n                AssignmentStatement as = (AssignmentStatement)statement;\n                //statements always apply to the most recently defined bean configuration with the same name, so we\n                //have to traverse the configuration list starting at the end (most recent elements are appended):\n                boolean addedToConfig = false;\n                String beanName = as.getRootBeanName();\n                for( int i = beanConfigurations.size()-1; i >= 0; i--) {\n                    BeanConfiguration mostRecent = beanConfigurations.get(i);\n                    String mostRecentBeanName = mostRecent.getBeanName();\n                    if (beanName.equals(mostRecentBeanName)) {\n                        mostRecent.add(as);\n                        addedToConfig = true;\n                        break;\n                    }\n                }\n\n                if (!addedToConfig) {\n                    // the AssignmentStatement must be for an existing bean that does not yet have a corresponding\n                    // configuration object (this would happen if the bean is in the default objects map). Because\n                    // BeanConfiguration instances don't exist for default (already instantiated) beans,\n                    // we simulate a creation of one to satisfy this processors implementation:\n                    beanConfigurations.add(new BeanConfiguration(as));\n                }\n            }\n        }\n\n        public void execute() {\n\n            for( Statement statement : statements) {\n\n                statement.execute();\n\n                BeanConfiguration bd = statement.getBeanConfiguration();\n\n                if (bd.isExecuted()) { //bean is fully configured, no more statements to execute for it:\n\n                    //bean configured overrides the 'eventBus' bean - replace the existing eventBus with the one configured:\n                    if (bd.getBeanName().equals(EVENT_BUS_NAME)) {\n                        EventBus eventBus = (EventBus)bd.getBean();\n                        enableEvents(eventBus);\n                    }\n\n                    //ignore global 'shiro.' shortcut mechanism:\n                    if (!bd.isGlobalConfig()) {\n                        BeanEvent event = new ConfiguredBeanEvent(bd.getBeanName(), bd.getBean(),\n                                Collections.unmodifiableMap(objects));\n                        eventBus.publish(event);\n                    }\n\n                    //initialize the bean if necessary:\n                    LifecycleUtils.init(bd.getBean());\n\n                    //ignore global 'shiro.' shortcut mechanism:\n                    if (!bd.isGlobalConfig()) {\n                        BeanEvent event = new InitializedBeanEvent(bd.getBeanName(), bd.getBean(),\n                                Collections.unmodifiableMap(objects));\n                        eventBus.publish(event);\n                    }\n                }\n            }\n        }\n    }\n\n    private class BeanConfiguration {\n\n        private final InstantiationStatement instantiationStatement;\n        private final List<AssignmentStatement> assignments = new ArrayList<AssignmentStatement>();\n        private final String beanName;\n        private Object bean;\n\n        private BeanConfiguration(InstantiationStatement statement) {\n            statement.setBeanConfiguration(this);\n            this.instantiationStatement = statement;\n            this.beanName = statement.lhs;\n        }\n\n        private BeanConfiguration(AssignmentStatement as) {\n            this.instantiationStatement = null;\n            this.beanName = as.getRootBeanName();\n            add(as);\n        }\n\n        public String getBeanName() {\n            return this.beanName;\n        }\n\n        public boolean isGlobalConfig() { //BeanConfiguration instance representing the global 'shiro.' properties\n            // (we should remove this concept).\n            return GLOBAL_PROPERTY_PREFIX.equals(getBeanName());\n        }\n\n        public void add(AssignmentStatement as) {\n            as.setBeanConfiguration(this);\n            assignments.add(as);\n        }\n\n        /**\n         * When this configuration is parsed sufficiently to create (or find) an actual bean instance, that instance\n         * will be associated with its configuration by setting it via this method.\n         *\n         * @param bean the bean instantiated (or found) that corresponds to this BeanConfiguration instance.\n         */\n        public void setBean(Object bean) {\n            this.bean = bean;\n        }\n\n        public Object getBean() {\n            return this.bean;\n        }\n\n        /**\n         * Returns true if all configuration statements have been executed.\n         * @return true if all configuration statements have been executed.\n         */\n        public boolean isExecuted() {\n            if (instantiationStatement != null && !instantiationStatement.isExecuted()) {\n                return false;\n            }\n            for (AssignmentStatement as : assignments) {\n                if (!as.isExecuted()) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    private abstract class Statement {\n\n        protected final String lhs;\n        protected final String rhs;\n        protected Object bean;\n        private Object result;\n        private boolean executed;\n        private BeanConfiguration beanConfiguration;\n\n        private Statement(String lhs, String rhs) {\n            this.lhs = lhs;\n            this.rhs = rhs;\n            this.executed = false;\n        }\n\n        public void setBeanConfiguration(BeanConfiguration bd) {\n            this.beanConfiguration = bd;\n        }\n\n        public BeanConfiguration getBeanConfiguration() {\n            return this.beanConfiguration;\n        }\n\n        public Object execute() {\n            if (!isExecuted()) {\n                this.result = doExecute();\n                this.executed = true;\n            }\n            if (!getBeanConfiguration().isGlobalConfig()) {\n                Assert.notNull(this.bean, \"Implementation must set the root bean for which it executed.\");\n            }\n            return this.result;\n        }\n\n        public Object getBean() {\n            return this.bean;\n        }\n\n        protected void setBean(Object bean) {\n            this.bean = bean;\n            if (this.beanConfiguration.getBean() == null) {\n                this.beanConfiguration.setBean(bean);\n            }\n        }\n\n        public Object getResult() {\n            return result;\n        }\n\n        protected abstract Object doExecute();\n\n        public boolean isExecuted() {\n            return executed;\n        }\n    }\n\n    private class InstantiationStatement extends Statement {\n\n        private InstantiationStatement(String lhs, String rhs) {\n            super(lhs, rhs);\n        }\n\n        @Override\n        protected Object doExecute() {\n            String beanName = this.lhs;\n            createNewInstance(objects, beanName, this.rhs);\n            Object instantiated = objects.get(beanName);\n            setBean(instantiated);\n\n            //also ensure the instantiated bean has access to the event bus or is subscribed to events if necessary:\n            //Note: because events are being enabled on this bean here (before the instantiated event below is\n            //triggered), beans can react to their own instantiation events.\n            enableEventsIfNecessary(instantiated, beanName);\n\n            BeanEvent event = new InstantiatedBeanEvent(beanName, instantiated, Collections.unmodifiableMap(objects));\n            eventBus.publish(event);\n\n            return instantiated;\n        }\n    }\n\n    private class AssignmentStatement extends Statement {\n\n        private final String rootBeanName;\n\n        private AssignmentStatement(String lhs, String rhs) {\n            super(lhs, rhs);\n            int index = lhs.indexOf('.');\n            this.rootBeanName = lhs.substring(0, index);\n        }\n\n        @Override\n        protected Object doExecute() {\n            applyProperty(lhs, rhs, objects);\n            Object bean = objects.get(this.rootBeanName);\n            setBean(bean);\n            return null;\n        }\n\n        public String getRootBeanName() {\n            return this.rootBeanName;\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.config;\n\nimport org.apache.commons.beanutils.BeanUtils;\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.shiro.codec.Base64;\nimport org.apache.shiro.codec.Hex;\nimport org.apache.shiro.config.event.BeanEvent;\nimport org.apache.shiro.config.event.ConfiguredBeanEvent;\nimport org.apache.shiro.config.event.DestroyedBeanEvent;\nimport org.apache.shiro.config.event.InstantiatedBeanEvent;\nimport org.apache.shiro.event.EventBus;\nimport org.apache.shiro.event.EventBusAware;\nimport org.apache.shiro.event.Subscribe;\nimport org.apache.shiro.event.support.DefaultEventBus;\nimport org.apache.shiro.util.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.beans.PropertyDescriptor;\nimport java.util.*;\n\n\n/**\n * Object builder that uses reflection and Apache Commons BeanUtils to build objects given a\n * map of \"property values\".  Typically these come from the Shiro INI configuration and are used\n * to construct or modify the SecurityManager, its dependencies, and web-based security filters.\n * <p/>\n * Recognizes {@link Factory} implementations and will call\n * {@link org.apache.shiro.util.Factory#getInstance() getInstance} to satisfy any reference to this bean.\n *\n * @since 0.9\n */\npublic class ReflectionBuilder {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(ReflectionBuilder.class);\n\n    private static final String OBJECT_REFERENCE_BEGIN_TOKEN = \"$\";\n    private static final String ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN = \"\\\\$\";\n    private static final String GLOBAL_PROPERTY_PREFIX = \"shiro\";\n    private static final char MAP_KEY_VALUE_DELIMITER = ':';\n    private static final String HEX_BEGIN_TOKEN = \"0x\";\n    private static final String NULL_VALUE_TOKEN = \"null\";\n    private static final String EMPTY_STRING_VALUE_TOKEN = \"\\\"\\\"\";\n    private static final char STRING_VALUE_DELIMETER = '\"';\n    private static final char MAP_PROPERTY_BEGIN_TOKEN = '[';\n    private static final char MAP_PROPERTY_END_TOKEN = ']';\n\n    private static final String EVENT_BUS_NAME = \"eventBus\";\n\n    private final Map<String, Object> objects;\n    /**\n     * @since 1.3\n     */\n    private EventBus eventBus;\n    /**\n     * Keeps track of event subscribers that were automatically registered by this ReflectionBuilder during\n     * object construction.  This is used in case a new EventBus is discovered during object graph\n     * construction:  upon discovery of the new EventBus, the existing subscribers will be unregistered from the\n     * old EventBus and then re-registered with the new EventBus.\n     *\n     * @since 1.3\n     */\n    private final Map<String,Object> registeredEventSubscribers;\n\n    //@since 1.3\n    private static Map<String,Object> createDefaultObjectMap() {\n        Map<String,Object> map = new LinkedHashMap<String, Object>();\n        map.put(EVENT_BUS_NAME, new DefaultEventBus());\n        return map;\n    }\n\n    public ReflectionBuilder() {\n        this(null);\n    }\n\n    public ReflectionBuilder(Map<String, ?> defaults) {\n        this.objects = createDefaultObjectMap();\n        this.registeredEventSubscribers = new LinkedHashMap<String,Object>();\n        apply(defaults);\n    }\n\n    private void apply(Map<String, ?> objects) {\n        if(!CollectionUtils.isEmpty(objects)) {\n            this.objects.putAll(objects);\n        }\n        EventBus found = findEventBus(this.objects);\n        Assert.notNull(found, \"An \" + EventBus.class.getName() + \" instance must be present in the object defaults\");\n        enableEvents(found);\n    }\n\n    public Map<String, ?> getObjects() {\n        return objects;\n    }\n\n    /**\n     * @param objects\n     */\n    public void setObjects(Map<String, ?> objects) {\n        this.objects.clear();\n        this.objects.putAll(createDefaultObjectMap());\n        apply(objects);\n    }\n\n    //@since 1.3\n    private void enableEvents(EventBus eventBus) {\n        Assert.notNull(eventBus, \"EventBus argument cannot be null.\");\n        //clean up old auto-registered subscribers:\n        for (Object subscriber : this.registeredEventSubscribers.values()) {\n            this.eventBus.unregister(subscriber);\n        }\n        this.registeredEventSubscribers.clear();\n\n        this.eventBus = eventBus;\n\n        for(Map.Entry<String,Object> entry : this.objects.entrySet()) {\n            enableEventsIfNecessary(entry.getValue(), entry.getKey());\n        }\n    }\n\n    //@since 1.3\n    private void enableEventsIfNecessary(Object bean, String name) {\n        boolean applied = applyEventBusIfNecessary(bean);\n        if (!applied) {\n            //if the event bus is applied, and the bean wishes to be a subscriber as well (not just a publisher),\n            // we assume that the implementation registers itself with the event bus, i.e. eventBus.register(this);\n\n            //if the event bus isn't applied, only then do we need to check to see if the bean is an event subscriber,\n            // and if so, register it on the event bus automatically since it has no ability to do so itself:\n            if (isEventSubscriber(bean, name)) {\n                //found an event subscriber, so register them with the EventBus:\n                this.eventBus.register(bean);\n                this.registeredEventSubscribers.put(name, bean);\n            }\n        }\n    }\n\n    //@since 1.3\n    private boolean isEventSubscriber(Object bean, String name) {\n        List annotatedMethods = ClassUtils.getAnnotatedMethods(bean.getClass(), Subscribe.class);\n        return !CollectionUtils.isEmpty(annotatedMethods);\n    }\n\n    //@since 1.3\n    protected EventBus findEventBus(Map<String,?> objects) {\n\n        if (CollectionUtils.isEmpty(objects)) {\n            return null;\n        }\n\n        //prefer a named object first:\n        Object value = objects.get(EVENT_BUS_NAME);\n        if (value != null && value instanceof EventBus) {\n            return (EventBus)value;\n        }\n\n        //couldn't find a named 'eventBus' EventBus object.  Try to find the first typed value we can:\n        for( Object v : objects.values()) {\n            if (v instanceof EventBus) {\n                return (EventBus)v;\n            }\n        }\n\n        return null;\n    }\n\n    private boolean applyEventBusIfNecessary(Object value) {\n        if (value instanceof EventBusAware) {\n            ((EventBusAware)value).setEventBus(this.eventBus);\n            return true;\n        }\n        return false;\n    }\n\n    public Object getBean(String id) {\n        return objects.get(id);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public <T> T getBean(String id, Class<T> requiredType) {\n        if (requiredType == null) {\n            throw new NullPointerException(\"requiredType argument cannot be null.\");\n        }\n        Object bean = getBean(id);\n        if (bean == null) {\n            return null;\n        }\n        Assert.state(requiredType.isAssignableFrom(bean.getClass()),\n                \"Bean with id [\" + id + \"] is not of the required type [\" + requiredType.getName() + \"].\");\n        return (T) bean;\n    }\n\n    private String parseBeanId(String lhs) {\n        Assert.notNull(lhs);\n        if (lhs.indexOf('.') < 0) {\n            return lhs;\n        }\n        String classSuffix = \".class\";\n        int index = lhs.indexOf(classSuffix);\n        if (index >= 0) {\n            return lhs.substring(0, index);\n        }\n        return null;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Map<String, ?> buildObjects(Map<String, String> kvPairs) {\n\n        if (kvPairs != null && !kvPairs.isEmpty()) {\n\n            BeanConfigurationProcessor processor = new BeanConfigurationProcessor();\n\n            for (Map.Entry<String, String> entry : kvPairs.entrySet()) {\n                String lhs = entry.getKey();\n                String rhs = entry.getValue();\n\n                String beanId = parseBeanId(lhs);\n                if (beanId != null) { //a beanId could be parsed, so the line is a bean instance definition\n                    processor.add(new InstantiationStatement(beanId, rhs));\n                } else { //the line must be a property configuration\n                    processor.add(new AssignmentStatement(lhs, rhs));\n                }\n            }\n\n            processor.execute();\n        }\n\n        return objects;\n    }\n\n    public void destroy() {\n        final Map<String, Object> immutableObjects = Collections.unmodifiableMap(objects);\n        for(Map.Entry<String, ?> entry: objects.entrySet()) {\n            String id = entry.getKey();\n            Object bean = entry.getValue();\n            BeanEvent event = new DestroyedBeanEvent(id, bean, immutableObjects);\n            eventBus.publish(event);\n            LifecycleUtils.destroy(bean);\n        }\n    }\n\n    protected void createNewInstance(Map<String, Object> objects, String name, String value) {\n\n        Object currentInstance = objects.get(name);\n        if (currentInstance != null) {\n            log.info(\"An instance with name '{}' already exists.  \" +\n                    \"Redefining this object as a new instance of type {}\", name, value);\n        }\n\n        Object instance;//name with no property, assume right hand side of equals sign is the class name:\n        try {\n            instance = ClassUtils.newInstance(value);\n            if (instance instanceof Nameable) {\n                ((Nameable) instance).setName(name);\n            }\n        } catch (Exception e) {\n            String msg = \"Unable to instantiate class [\" + value + \"] for object named '\" + name + \"'.  \" +\n                    \"Please ensure you've specified the fully qualified class name correctly.\";\n            throw new ConfigurationException(msg, e);\n        }\n        objects.put(name, instance);\n    }\n\n    protected void applyProperty(String key, String value, Map objects) {\n\n        int index = key.indexOf('.');\n\n        if (index >= 0) {\n            String name = key.substring(0, index);\n            String property = key.substring(index + 1, key.length());\n\n            if (GLOBAL_PROPERTY_PREFIX.equalsIgnoreCase(name)) {\n                applyGlobalProperty(objects, property, value);\n            } else {\n                applySingleProperty(objects, name, property, value);\n            }\n\n        } else {\n            throw new IllegalArgumentException(\"All property keys must contain a '.' character. \" +\n                    \"(e.g. myBean.property = value)  These should already be separated out by buildObjects().\");\n        }\n    }\n\n    protected void applyGlobalProperty(Map objects, String property, String value) {\n        for (Object instance : objects.values()) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(instance, property);\n                if (pd != null) {\n                    applyProperty(instance, property, value);\n                }\n            } catch (Exception e) {\n                String msg = \"Error retrieving property descriptor for instance \" +\n                        \"of type [\" + instance.getClass().getName() + \"] \" +\n                        \"while setting property [\" + property + \"]\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected void applySingleProperty(Map objects, String name, String property, String value) {\n        Object instance = objects.get(name);\n        if (property.equals(\"class\")) {\n            throw new IllegalArgumentException(\"Property keys should not contain 'class' properties since these \" +\n                    \"should already be separated out by buildObjects().\");\n\n        } else if (instance == null) {\n            String msg = \"Configuration error.  Specified object [\" + name + \"] with property [\" +\n                    property + \"] without first defining that object's class.  Please first \" +\n                    \"specify the class property first, e.g. myObject = fully_qualified_class_name \" +\n                    \"and then define additional properties.\";\n            throw new IllegalArgumentException(msg);\n\n        } else {\n            applyProperty(instance, property, value);\n        }\n    }\n\n    protected boolean isReference(String value) {\n        return value != null && value.startsWith(OBJECT_REFERENCE_BEGIN_TOKEN);\n    }\n\n    protected String getId(String referenceToken) {\n        return referenceToken.substring(OBJECT_REFERENCE_BEGIN_TOKEN.length());\n    }\n\n    protected Object getReferencedObject(String id) {\n        Object o = objects != null && !objects.isEmpty() ? objects.get(id) : null;\n        if (o == null) {\n            String msg = \"The object with id [\" + id + \"] has not yet been defined and therefore cannot be \" +\n                    \"referenced.  Please ensure objects are defined in the order in which they should be \" +\n                    \"created and made available for future reference.\";\n            throw new UnresolveableReferenceException(msg);\n        }\n        return o;\n    }\n\n    protected String unescapeIfNecessary(String value) {\n        if (value != null && value.startsWith(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN)) {\n            return value.substring(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN.length() - 1);\n        }\n        return value;\n    }\n\n    protected Object resolveReference(String reference) {\n        String id = getId(reference);\n        log.debug(\"Encountered object reference '{}'.  Looking up object with id '{}'\", reference, id);\n        final Object referencedObject = getReferencedObject(id);\n        if (referencedObject instanceof Factory) {\n            return ((Factory) referencedObject).getInstance();\n        }\n        return referencedObject;\n    }\n\n    protected boolean isTypedProperty(Object object, String propertyName, Class clazz) {\n        if (clazz == null) {\n            throw new NullPointerException(\"type (class) argument cannot be null.\");\n        }\n        try {\n            PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(object, propertyName);\n            if (descriptor == null) {\n                String msg = \"Property '\" + propertyName + \"' does not exist for object of \" +\n                        \"type \" + object.getClass().getName() + \".\";\n                throw new ConfigurationException(msg);\n            }\n            Class propertyClazz = descriptor.getPropertyType();\n            return clazz.isAssignableFrom(propertyClazz);\n        } catch (ConfigurationException ce) {\n            //let it propagate:\n            throw ce;\n        } catch (Exception e) {\n            String msg = \"Unable to determine if property [\" + propertyName + \"] represents a \" + clazz.getName();\n            throw new ConfigurationException(msg, e);\n        }\n    }\n\n    protected Set<?> toSet(String sValue) {\n        String[] tokens = StringUtils.split(sValue);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n        Set<String> setTokens = new LinkedHashSet<String>(Arrays.asList(tokens));\n\n        //now convert into correct values and/or references:\n        Set<Object> values = new LinkedHashSet<Object>(setTokens.size());\n        for (String token : setTokens) {\n            Object value = resolveValue(token);\n            values.add(value);\n        }\n        return values;\n    }\n\n    protected Map<?, ?> toMap(String sValue) {\n        String[] tokens = StringUtils.split(sValue, StringUtils.DEFAULT_DELIMITER_CHAR,\n                StringUtils.DEFAULT_QUOTE_CHAR, StringUtils.DEFAULT_QUOTE_CHAR, true, true);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n\n        Map<String, String> mapTokens = new LinkedHashMap<String, String>(tokens.length);\n        for (String token : tokens) {\n            String[] kvPair = StringUtils.split(token, MAP_KEY_VALUE_DELIMITER);\n            if (kvPair == null || kvPair.length != 2) {\n                String msg = \"Map property value [\" + sValue + \"] contained key-value pair token [\" +\n                        token + \"] that does not properly split to a single key and pair.  This must be the \" +\n                        \"case for all map entries.\";\n                throw new ConfigurationException(msg);\n            }\n            mapTokens.put(kvPair[0], kvPair[1]);\n        }\n\n        //now convert into correct values and/or references:\n        Map<Object, Object> map = new LinkedHashMap<Object, Object>(mapTokens.size());\n        for (Map.Entry<String, String> entry : mapTokens.entrySet()) {\n            Object key = resolveValue(entry.getKey());\n            Object value = resolveValue(entry.getValue());\n            map.put(key, value);\n        }\n        return map;\n    }\n\n\n    protected List<?> toList(String sValue) {\n        String[] tokens = StringUtils.split(sValue);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n\n        //now convert into correct values and/or references:\n        List<Object> values = new ArrayList<Object>(tokens.length);\n        for (String token : tokens) {\n            Object value = resolveValue(token);\n            values.add(value);\n        }\n        return values;\n    }\n\n    protected byte[] toBytes(String sValue) {\n        if (sValue == null) {\n            return null;\n        }\n        byte[] bytes;\n        if (sValue.startsWith(HEX_BEGIN_TOKEN)) {\n            String hex = sValue.substring(HEX_BEGIN_TOKEN.length());\n            bytes = Hex.decode(hex);\n        } else {\n            //assume base64 encoded:\n            bytes = Base64.decode(sValue);\n        }\n        return bytes;\n    }\n\n    protected Object resolveValue(String stringValue) {\n        Object value;\n        if (isReference(stringValue)) {\n            value = resolveReference(stringValue);\n        } else {\n            value = unescapeIfNecessary(stringValue);\n        }\n        return value;\n    }\n\n    protected String checkForNullOrEmptyLiteral(String stringValue) {\n        if (stringValue == null) {\n            return null;\n        }\n        //check if the value is the actual literal string 'null' (expected to be wrapped in quotes):\n        if (stringValue.equals(\"\\\"null\\\"\")) {\n            return NULL_VALUE_TOKEN;\n        }\n        //or the actual literal string of two quotes '\"\"' (expected to be wrapped in quotes):\n        else if (stringValue.equals(\"\\\"\\\"\\\"\\\"\")) {\n            return EMPTY_STRING_VALUE_TOKEN;\n        } else {\n            return stringValue;\n        }\n    }\n    \n    protected void applyProperty(Object object, String propertyPath, Object value) {\n\n        int mapBegin = propertyPath.indexOf(MAP_PROPERTY_BEGIN_TOKEN);\n        int mapEnd = -1;\n        String mapPropertyPath = null;\n        String keyString = null;\n\n        String remaining = null;\n        \n        if (mapBegin >= 0) {\n            //a map is being referenced in the overall property path.  Find just the map's path:\n            mapPropertyPath = propertyPath.substring(0, mapBegin);\n            //find the end of the map reference:\n            mapEnd = propertyPath.indexOf(MAP_PROPERTY_END_TOKEN, mapBegin);\n            //find the token in between the [ and the ] (the map/array key or index):\n            keyString = propertyPath.substring(mapBegin+1, mapEnd);\n\n            //find out if there is more path reference to follow.  If not, we're at a terminal of the OGNL expression\n            if (propertyPath.length() > (mapEnd+1)) {\n                remaining = propertyPath.substring(mapEnd+1);\n                if (remaining.startsWith(\".\")) {\n                    remaining = StringUtils.clean(remaining.substring(1));\n                }\n            }\n        }\n        \n        if (remaining == null) {\n            //we've terminated the OGNL expression.  Check to see if we're assigning a property or a map entry:\n            if (keyString == null) {\n                //not a map or array value assignment - assign the property directly:\n                setProperty(object, propertyPath, value);\n            } else {\n                //we're assigning a map or array entry.  Check to see which we should call:\n                if (isTypedProperty(object, mapPropertyPath, Map.class)) {\n                    Map map = (Map)getProperty(object, mapPropertyPath);\n                    Object mapKey = resolveValue(keyString);\n                    //noinspection unchecked\n                    map.put(mapKey, value);\n                } else {\n                    //must be an array property.  Convert the key string to an index:\n                    int index = Integer.valueOf(keyString);\n                    setIndexedProperty(object, mapPropertyPath, index, value);\n                }\n            }\n        } else {\n            //property is being referenced as part of a nested path.  Find the referenced map/array entry and\n            //recursively call this method with the remaining property path\n            Object referencedValue = null;\n            if (isTypedProperty(object, mapPropertyPath, Map.class)) {\n                Map map = (Map)getProperty(object, mapPropertyPath);\n                Object mapKey = resolveValue(keyString);\n                referencedValue = map.get(mapKey);\n            } else {\n                //must be an array property:\n                int index = Integer.valueOf(keyString);\n                referencedValue = getIndexedProperty(object, mapPropertyPath, index);\n            }\n\n            if (referencedValue == null) {\n                throw new ConfigurationException(\"Referenced map/array value '\" + mapPropertyPath + \"[\" +\n                keyString + \"]' does not exist.\");\n            }\n\n            applyProperty(referencedValue, remaining, value);\n        }\n    }\n    \n    private void setProperty(Object object, String propertyPath, Object value) {\n        try {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Applying property [{}] value [{}] on object of type [{}]\",\n                        new Object[]{propertyPath, value, object.getClass().getName()});\n            }\n            BeanUtils.setProperty(object, propertyPath, value);\n        } catch (Exception e) {\n            String msg = \"Unable to set property '\" + propertyPath + \"' with value [\" + value + \"] on object \" +\n                    \"of type \" + (object != null ? object.getClass().getName() : null) + \".  If \" +\n                    \"'\" + value + \"' is a reference to another (previously defined) object, prefix it with \" +\n                    \"'\" + OBJECT_REFERENCE_BEGIN_TOKEN + \"' to indicate that the referenced \" +\n                    \"object should be used as the actual value.  \" +\n                    \"For example, \" + OBJECT_REFERENCE_BEGIN_TOKEN + value;\n            throw new ConfigurationException(msg, e);\n        }\n    }\n    \n    private Object getProperty(Object object, String propertyPath) {\n        try {\n            return PropertyUtils.getProperty(object, propertyPath);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Unable to access property '\" + propertyPath + \"'\", e);\n        }\n    }\n    \n    private void setIndexedProperty(Object object, String propertyPath, int index, Object value) {\n        try {\n            PropertyUtils.setIndexedProperty(object, propertyPath, index, value);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Unable to set array property '\" + propertyPath + \"'\", e);\n        }\n    }\n    \n    private Object getIndexedProperty(Object object, String propertyPath, int index) {\n        try {\n            return PropertyUtils.getIndexedProperty(object, propertyPath, index);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Unable to acquire array property '\" + propertyPath + \"'\", e);\n        }\n    }\n    \n    protected boolean isIndexedPropertyAssignment(String propertyPath) {\n        return propertyPath.endsWith(\"\" + MAP_PROPERTY_END_TOKEN);\n    }\n\n    protected void applyProperty(Object object, String propertyName, String stringValue) {\n\n        Object value;\n\n        if (NULL_VALUE_TOKEN.equals(stringValue)) {\n            value = null;\n        } else if (EMPTY_STRING_VALUE_TOKEN.equals(stringValue)) {\n            value = StringUtils.EMPTY_STRING;\n        } else if (isIndexedPropertyAssignment(propertyName)) {\n            String checked = checkForNullOrEmptyLiteral(stringValue);\n            value = resolveValue(checked);\n        } else if (isTypedProperty(object, propertyName, Set.class)) {\n            value = toSet(stringValue);\n        } else if (isTypedProperty(object, propertyName, Map.class)) {\n            value = toMap(stringValue);\n        } else if (isTypedProperty(object, propertyName, List.class) ||\n                isTypedProperty(object, propertyName, Collection.class)) {\n            value = toList(stringValue);\n        } else if (isTypedProperty(object, propertyName, byte[].class)) {\n            value = toBytes(stringValue);\n        } else if (isTypedProperty(object, propertyName, ByteSource.class)) {\n            byte[] bytes = toBytes(stringValue);\n            value = ByteSource.Util.bytes(bytes);\n        } else {\n            String checked = checkForNullOrEmptyLiteral(stringValue);\n            value = resolveValue(checked);\n        }\n\n        applyProperty(object, propertyName, value);\n    }\n\n    private class BeanConfigurationProcessor {\n\n        private final List<Statement> statements = new ArrayList<Statement>();\n        private final List<BeanConfiguration> beanConfigurations = new ArrayList<BeanConfiguration>();\n\n        public void add(Statement statement) {\n\n            statements.add(statement); //we execute bean configuration statements in the order they are declared.\n\n            if (statement instanceof InstantiationStatement) {\n                InstantiationStatement is = (InstantiationStatement)statement;\n                beanConfigurations.add(new BeanConfiguration(is));\n            } else {\n                AssignmentStatement as = (AssignmentStatement)statement;\n                //statements always apply to the most recently defined bean configuration with the same name, so we\n                //have to traverse the configuration list starting at the end (most recent elements are appended):\n                boolean addedToConfig = false;\n                String beanName = as.getRootBeanName();\n                for( int i = beanConfigurations.size()-1; i >= 0; i--) {\n                    BeanConfiguration mostRecent = beanConfigurations.get(i);\n                    String mostRecentBeanName = mostRecent.getBeanName();\n                    if (beanName.equals(mostRecentBeanName)) {\n                        mostRecent.add(as);\n                        addedToConfig = true;\n                        break;\n                    }\n                }\n\n                if (!addedToConfig) {\n                    // the AssignmentStatement must be for an existing bean that does not yet have a corresponding\n                    // configuration object (this would happen if the bean is in the default objects map). Because\n                    // BeanConfiguration instances don't exist for default (already instantiated) beans,\n                    // we simulate a creation of one to satisfy this processors implementation:\n                    beanConfigurations.add(new BeanConfiguration(as));\n                }\n            }\n        }\n\n        public void execute() {\n\n            for( Statement statement : statements) {\n\n                statement.execute();\n\n                BeanConfiguration bd = statement.getBeanConfiguration();\n\n                if (bd.isExecuted()) { //bean is fully configured, no more statements to execute for it:\n\n                    if (bd.getBeanName().equals(EVENT_BUS_NAME)) {\n                        EventBus eventBus = (EventBus)bd.getBean();\n                        enableEvents(eventBus);\n                    }\n\n                    //ignore global 'shiro.' shortcut mechanism:\n                    if (!bd.isGlobalConfig()) {\n                        BeanEvent event = new ConfiguredBeanEvent(bd.getBeanName(), bd.getBean(),\n                                Collections.unmodifiableMap(objects));\n                        eventBus.publish(event);\n                    }\n                }\n            }\n        }\n    }\n\n    private class BeanConfiguration {\n\n        private final InstantiationStatement instantiationStatement;\n        private final List<AssignmentStatement> assignments = new ArrayList<AssignmentStatement>();\n        private final String beanName;\n        private Object bean;\n\n        private BeanConfiguration(InstantiationStatement statement) {\n            statement.setBeanConfiguration(this);\n            this.instantiationStatement = statement;\n            this.beanName = statement.lhs;\n        }\n\n        private BeanConfiguration(AssignmentStatement as) {\n            this.instantiationStatement = null;\n            this.beanName = as.getRootBeanName();\n            add(as);\n        }\n\n        public String getBeanName() {\n            return this.beanName;\n        }\n\n        public boolean isGlobalConfig() { //BeanConfiguration instance representing the global 'shiro.' properties\n            // (we should remove this concept).\n            return GLOBAL_PROPERTY_PREFIX.equals(getBeanName());\n        }\n\n        public void add(AssignmentStatement as) {\n            as.setBeanConfiguration(this);\n            assignments.add(as);\n        }\n\n        /**\n         * When this configuration is parsed sufficiently to create (or find) an actual bean instance, that instance\n         * will be associated with its configuration by setting it via this method.\n         *\n         * @param bean the bean instantiated (or found) that corresponds to this BeanConfiguration instance.\n         */\n        public void setBean(Object bean) {\n            this.bean = bean;\n        }\n\n        public Object getBean() {\n            return this.bean;\n        }\n\n        /**\n         * Returns true if all configuration statements have been executed.\n         * @return true if all configuration statements have been executed.\n         */\n        public boolean isExecuted() {\n            if (instantiationStatement != null && !instantiationStatement.isExecuted()) {\n                return false;\n            }\n            for (AssignmentStatement as : assignments) {\n                if (!as.isExecuted()) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    private abstract class Statement {\n\n        protected final String lhs;\n        protected final String rhs;\n        protected Object bean;\n        private Object result;\n        private boolean executed;\n        private BeanConfiguration beanConfiguration;\n\n        private Statement(String lhs, String rhs) {\n            this.lhs = lhs;\n            this.rhs = rhs;\n            this.executed = false;\n        }\n\n        public void setBeanConfiguration(BeanConfiguration bd) {\n            this.beanConfiguration = bd;\n        }\n\n        public BeanConfiguration getBeanConfiguration() {\n            return this.beanConfiguration;\n        }\n\n        public Object execute() {\n            if (!isExecuted()) {\n                this.result = doExecute();\n                this.executed = true;\n            }\n            if (!getBeanConfiguration().isGlobalConfig()) {\n                Assert.notNull(this.bean, \"Implementation must set the root bean for which it executed.\");\n            }\n            return this.result;\n        }\n\n        public Object getBean() {\n            return this.bean;\n        }\n\n        protected void setBean(Object bean) {\n            this.bean = bean;\n            if (this.beanConfiguration.getBean() == null) {\n                this.beanConfiguration.setBean(bean);\n            }\n        }\n\n        public Object getResult() {\n            return result;\n        }\n\n        protected abstract Object doExecute();\n\n        public boolean isExecuted() {\n            return executed;\n        }\n    }\n\n    private class InstantiationStatement extends Statement {\n\n        private InstantiationStatement(String lhs, String rhs) {\n            super(lhs, rhs);\n        }\n\n        @Override\n        protected Object doExecute() {\n            createNewInstance(objects, this.lhs, this.rhs);\n            Object instantiated = objects.get(this.lhs);\n            setBean(instantiated);\n\n            BeanEvent event = new InstantiatedBeanEvent(this.lhs, instantiated, Collections.unmodifiableMap(objects));\n            eventBus.publish(event);\n\n            return instantiated;\n        }\n    }\n\n    private class AssignmentStatement extends Statement {\n\n        private final String rootBeanName;\n\n        private AssignmentStatement(String lhs, String rhs) {\n            super(lhs, rhs);\n            int index = lhs.indexOf('.');\n            this.rootBeanName = lhs.substring(0, index);\n        }\n\n        @Override\n        protected Object doExecute() {\n            applyProperty(lhs, rhs, objects);\n            Object bean = objects.get(this.rootBeanName);\n            setBean(bean);\n            return null;\n        }\n\n        public String getRootBeanName() {\n            return this.rootBeanName;\n        }\n    }\n\n}\n","lineNo":872}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.config;\n\nimport org.apache.commons.beanutils.BeanUtils;\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.shiro.codec.Base64;\nimport org.apache.shiro.codec.Hex;\nimport org.apache.shiro.config.event.BeanEvent;\nimport org.apache.shiro.config.event.ConfiguredBeanEvent;\nimport org.apache.shiro.config.event.DestroyedBeanEvent;\nimport org.apache.shiro.config.event.InitializedBeanEvent;\nimport org.apache.shiro.config.event.InstantiatedBeanEvent;\nimport org.apache.shiro.event.EventBus;\nimport org.apache.shiro.event.EventBusAware;\nimport org.apache.shiro.event.Subscribe;\nimport org.apache.shiro.event.support.DefaultEventBus;\nimport org.apache.shiro.util.Assert;\nimport org.apache.shiro.util.ByteSource;\nimport org.apache.shiro.util.ClassUtils;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.util.Factory;\nimport org.apache.shiro.util.LifecycleUtils;\nimport org.apache.shiro.util.Nameable;\nimport org.apache.shiro.util.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.beans.PropertyDescriptor;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n\n/**\n * Object builder that uses reflection and Apache Commons BeanUtils to build objects given a\n * map of \"property values\".  Typically these come from the Shiro INI configuration and are used\n * to construct or modify the SecurityManager, its dependencies, and web-based security filters.\n * <p/>\n * Recognizes {@link Factory} implementations and will call\n * {@link org.apache.shiro.util.Factory#getInstance() getInstance} to satisfy any reference to this bean.\n *\n * @since 0.9\n */\npublic class ReflectionBuilder {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(ReflectionBuilder.class);\n\n    private static final String OBJECT_REFERENCE_BEGIN_TOKEN = \"$\";\n    private static final String ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN = \"\\\\$\";\n    private static final String GLOBAL_PROPERTY_PREFIX = \"shiro\";\n    private static final char MAP_KEY_VALUE_DELIMITER = ':';\n    private static final String HEX_BEGIN_TOKEN = \"0x\";\n    private static final String NULL_VALUE_TOKEN = \"null\";\n    private static final String EMPTY_STRING_VALUE_TOKEN = \"\\\"\\\"\";\n    private static final char STRING_VALUE_DELIMETER = '\"';\n    private static final char MAP_PROPERTY_BEGIN_TOKEN = '[';\n    private static final char MAP_PROPERTY_END_TOKEN = ']';\n\n    private static final String EVENT_BUS_NAME = \"eventBus\";\n\n    private final Map<String, Object> objects;\n    /**\n     * @since 1.3\n     */\n    private EventBus eventBus;\n    /**\n     * Keeps track of event subscribers that were automatically registered by this ReflectionBuilder during\n     * object construction.  This is used in case a new EventBus is discovered during object graph\n     * construction:  upon discovery of the new EventBus, the existing subscribers will be unregistered from the\n     * old EventBus and then re-registered with the new EventBus.\n     *\n     * @since 1.3\n     */\n    private final Map<String,Object> registeredEventSubscribers;\n\n    //@since 1.3\n    private Map<String,Object> createDefaultObjectMap() {\n        Map<String,Object> map = new LinkedHashMap<String, Object>();\n        map.put(EVENT_BUS_NAME, new DefaultEventBus());\n        return map;\n    }\n\n    public ReflectionBuilder() {\n        this(null);\n    }\n\n    public ReflectionBuilder(Map<String, ?> defaults) {\n        this.objects = createDefaultObjectMap();\n        this.registeredEventSubscribers = new LinkedHashMap<String,Object>();\n        apply(defaults);\n    }\n\n    private void apply(Map<String, ?> objects) {\n        if(!CollectionUtils.isEmpty(objects)) {\n            this.objects.putAll(objects);\n        }\n        EventBus found = findEventBus(this.objects);\n        Assert.notNull(found, \"An \" + EventBus.class.getName() + \" instance must be present in the object defaults\");\n        enableEvents(found);\n    }\n\n    public Map<String, ?> getObjects() {\n        return objects;\n    }\n\n    /**\n     * @param objects\n     */\n    public void setObjects(Map<String, ?> objects) {\n        this.objects.clear();\n        this.objects.putAll(createDefaultObjectMap());\n        apply(objects);\n    }\n\n    //@since 1.3\n    private void enableEvents(EventBus eventBus) {\n        Assert.notNull(eventBus, \"EventBus argument cannot be null.\");\n        //clean up old auto-registered subscribers:\n        for (Object subscriber : this.registeredEventSubscribers.values()) {\n            this.eventBus.unregister(subscriber);\n        }\n        this.registeredEventSubscribers.clear();\n\n        this.eventBus = eventBus;\n\n        for(Map.Entry<String,Object> entry : this.objects.entrySet()) {\n            enableEventsIfNecessary(entry.getValue(), entry.getKey());\n        }\n    }\n\n    //@since 1.3\n    private void enableEventsIfNecessary(Object bean, String name) {\n        boolean applied = applyEventBusIfNecessary(bean);\n        if (!applied) {\n            //if the event bus is applied, and the bean wishes to be a subscriber as well (not just a publisher),\n            // we assume that the implementation registers itself with the event bus, i.e. eventBus.register(this);\n\n            //if the event bus isn't applied, only then do we need to check to see if the bean is an event subscriber,\n            // and if so, register it on the event bus automatically since it has no ability to do so itself:\n            if (isEventSubscriber(bean, name)) {\n                //found an event subscriber, so register them with the EventBus:\n                this.eventBus.register(bean);\n                this.registeredEventSubscribers.put(name, bean);\n            }\n        }\n    }\n\n    //@since 1.3\n    private boolean isEventSubscriber(Object bean, String name) {\n        List annotatedMethods = ClassUtils.getAnnotatedMethods(bean.getClass(), Subscribe.class);\n        return !CollectionUtils.isEmpty(annotatedMethods);\n    }\n\n    //@since 1.3\n    protected EventBus findEventBus(Map<String,?> objects) {\n\n        if (CollectionUtils.isEmpty(objects)) {\n            return null;\n        }\n\n        //prefer a named object first:\n        Object value = objects.get(EVENT_BUS_NAME);\n        if (value != null && value instanceof EventBus) {\n            return (EventBus)value;\n        }\n\n        //couldn't find a named 'eventBus' EventBus object.  Try to find the first typed value we can:\n        for( Object v : objects.values()) {\n            if (v instanceof EventBus) {\n                return (EventBus)v;\n            }\n        }\n\n        return null;\n    }\n\n    private boolean applyEventBusIfNecessary(Object value) {\n        if (value instanceof EventBusAware) {\n            ((EventBusAware)value).setEventBus(this.eventBus);\n            return true;\n        }\n        return false;\n    }\n\n    public Object getBean(String id) {\n        return objects.get(id);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public <T> T getBean(String id, Class<T> requiredType) {\n        if (requiredType == null) {\n            throw new NullPointerException(\"requiredType argument cannot be null.\");\n        }\n        Object bean = getBean(id);\n        if (bean == null) {\n            return null;\n        }\n        Assert.state(requiredType.isAssignableFrom(bean.getClass()),\n                \"Bean with id [\" + id + \"] is not of the required type [\" + requiredType.getName() + \"].\");\n        return (T) bean;\n    }\n\n    private String parseBeanId(String lhs) {\n        Assert.notNull(lhs);\n        if (lhs.indexOf('.') < 0) {\n            return lhs;\n        }\n        String classSuffix = \".class\";\n        int index = lhs.indexOf(classSuffix);\n        if (index >= 0) {\n            return lhs.substring(0, index);\n        }\n        return null;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Map<String, ?> buildObjects(Map<String, String> kvPairs) {\n\n        if (kvPairs != null && !kvPairs.isEmpty()) {\n\n            BeanConfigurationProcessor processor = new BeanConfigurationProcessor();\n\n            for (Map.Entry<String, String> entry : kvPairs.entrySet()) {\n                String lhs = entry.getKey();\n                String rhs = entry.getValue();\n\n                String beanId = parseBeanId(lhs);\n                if (beanId != null) { //a beanId could be parsed, so the line is a bean instance definition\n                    processor.add(new InstantiationStatement(beanId, rhs));\n                } else { //the line must be a property configuration\n                    processor.add(new AssignmentStatement(lhs, rhs));\n                }\n            }\n\n            processor.execute();\n        }\n\n        return objects;\n    }\n\n    public void destroy() {\n        final Map<String, Object> immutableObjects = Collections.unmodifiableMap(objects);\n\n        //destroy objects in the opposite order they were initialized:\n        List<Map.Entry<String,?>> entries = new ArrayList<Map.Entry<String,?>>(objects.entrySet());\n        Collections.reverse(entries);\n\n        for(Map.Entry<String, ?> entry: entries) {\n            String id = entry.getKey();\n            Object bean = entry.getValue();\n\n            //don't destroy the eventbus until the end - we need it to still be 'alive' while publishing destroy events:\n            if (bean != this.eventBus) { //memory equality check (not .equals) on purpose\n                LifecycleUtils.destroy(bean);\n                BeanEvent event = new DestroyedBeanEvent(id, bean, immutableObjects);\n                eventBus.publish(event);\n                this.eventBus.unregister(bean); //bean is now destroyed - it should not receive any other events\n            }\n        }\n        //only now destroy the event bus:\n        LifecycleUtils.destroy(this.eventBus);\n    }\n\n    protected void createNewInstance(Map<String, Object> objects, String name, String value) {\n\n        Object currentInstance = objects.get(name);\n        if (currentInstance != null) {\n            log.info(\"An instance with name '{}' already exists.  \" +\n                    \"Redefining this object as a new instance of type {}\", name, value);\n        }\n\n        Object instance;//name with no property, assume right hand side of equals sign is the class name:\n        try {\n            instance = ClassUtils.newInstance(value);\n            if (instance instanceof Nameable) {\n                ((Nameable) instance).setName(name);\n            }\n        } catch (Exception e) {\n            String msg = \"Unable to instantiate class [\" + value + \"] for object named '\" + name + \"'.  \" +\n                    \"Please ensure you've specified the fully qualified class name correctly.\";\n            throw new ConfigurationException(msg, e);\n        }\n        objects.put(name, instance);\n    }\n\n    protected void applyProperty(String key, String value, Map objects) {\n\n        int index = key.indexOf('.');\n\n        if (index >= 0) {\n            String name = key.substring(0, index);\n            String property = key.substring(index + 1, key.length());\n\n            if (GLOBAL_PROPERTY_PREFIX.equalsIgnoreCase(name)) {\n                applyGlobalProperty(objects, property, value);\n            } else {\n                applySingleProperty(objects, name, property, value);\n            }\n\n        } else {\n            throw new IllegalArgumentException(\"All property keys must contain a '.' character. \" +\n                    \"(e.g. myBean.property = value)  These should already be separated out by buildObjects().\");\n        }\n    }\n\n    protected void applyGlobalProperty(Map objects, String property, String value) {\n        for (Object instance : objects.values()) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(instance, property);\n                if (pd != null) {\n                    applyProperty(instance, property, value);\n                }\n            } catch (Exception e) {\n                String msg = \"Error retrieving property descriptor for instance \" +\n                        \"of type [\" + instance.getClass().getName() + \"] \" +\n                        \"while setting property [\" + property + \"]\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected void applySingleProperty(Map objects, String name, String property, String value) {\n        Object instance = objects.get(name);\n        if (property.equals(\"class\")) {\n            throw new IllegalArgumentException(\"Property keys should not contain 'class' properties since these \" +\n                    \"should already be separated out by buildObjects().\");\n\n        } else if (instance == null) {\n            String msg = \"Configuration error.  Specified object [\" + name + \"] with property [\" +\n                    property + \"] without first defining that object's class.  Please first \" +\n                    \"specify the class property first, e.g. myObject = fully_qualified_class_name \" +\n                    \"and then define additional properties.\";\n            throw new IllegalArgumentException(msg);\n\n        } else {\n            applyProperty(instance, property, value);\n        }\n    }\n\n    protected boolean isReference(String value) {\n        return value != null && value.startsWith(OBJECT_REFERENCE_BEGIN_TOKEN);\n    }\n\n    protected String getId(String referenceToken) {\n        return referenceToken.substring(OBJECT_REFERENCE_BEGIN_TOKEN.length());\n    }\n\n    protected Object getReferencedObject(String id) {\n        Object o = objects != null && !objects.isEmpty() ? objects.get(id) : null;\n        if (o == null) {\n            String msg = \"The object with id [\" + id + \"] has not yet been defined and therefore cannot be \" +\n                    \"referenced.  Please ensure objects are defined in the order in which they should be \" +\n                    \"created and made available for future reference.\";\n            throw new UnresolveableReferenceException(msg);\n        }\n        return o;\n    }\n\n    protected String unescapeIfNecessary(String value) {\n        if (value != null && value.startsWith(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN)) {\n            return value.substring(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN.length() - 1);\n        }\n        return value;\n    }\n\n    protected Object resolveReference(String reference) {\n        String id = getId(reference);\n        log.debug(\"Encountered object reference '{}'.  Looking up object with id '{}'\", reference, id);\n        final Object referencedObject = getReferencedObject(id);\n        if (referencedObject instanceof Factory) {\n            return ((Factory) referencedObject).getInstance();\n        }\n        return referencedObject;\n    }\n\n    protected boolean isTypedProperty(Object object, String propertyName, Class clazz) {\n        if (clazz == null) {\n            throw new NullPointerException(\"type (class) argument cannot be null.\");\n        }\n        try {\n            PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(object, propertyName);\n            if (descriptor == null) {\n                String msg = \"Property '\" + propertyName + \"' does not exist for object of \" +\n                        \"type \" + object.getClass().getName() + \".\";\n                throw new ConfigurationException(msg);\n            }\n            Class propertyClazz = descriptor.getPropertyType();\n            return clazz.isAssignableFrom(propertyClazz);\n        } catch (ConfigurationException ce) {\n            //let it propagate:\n            throw ce;\n        } catch (Exception e) {\n            String msg = \"Unable to determine if property [\" + propertyName + \"] represents a \" + clazz.getName();\n            throw new ConfigurationException(msg, e);\n        }\n    }\n\n    protected Set<?> toSet(String sValue) {\n        String[] tokens = StringUtils.split(sValue);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n        Set<String> setTokens = new LinkedHashSet<String>(Arrays.asList(tokens));\n\n        //now convert into correct values and/or references:\n        Set<Object> values = new LinkedHashSet<Object>(setTokens.size());\n        for (String token : setTokens) {\n            Object value = resolveValue(token);\n            values.add(value);\n        }\n        return values;\n    }\n\n    protected Map<?, ?> toMap(String sValue) {\n        String[] tokens = StringUtils.split(sValue, StringUtils.DEFAULT_DELIMITER_CHAR,\n                StringUtils.DEFAULT_QUOTE_CHAR, StringUtils.DEFAULT_QUOTE_CHAR, true, true);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n\n        Map<String, String> mapTokens = new LinkedHashMap<String, String>(tokens.length);\n        for (String token : tokens) {\n            String[] kvPair = StringUtils.split(token, MAP_KEY_VALUE_DELIMITER);\n            if (kvPair == null || kvPair.length != 2) {\n                String msg = \"Map property value [\" + sValue + \"] contained key-value pair token [\" +\n                        token + \"] that does not properly split to a single key and pair.  This must be the \" +\n                        \"case for all map entries.\";\n                throw new ConfigurationException(msg);\n            }\n            mapTokens.put(kvPair[0], kvPair[1]);\n        }\n\n        //now convert into correct values and/or references:\n        Map<Object, Object> map = new LinkedHashMap<Object, Object>(mapTokens.size());\n        for (Map.Entry<String, String> entry : mapTokens.entrySet()) {\n            Object key = resolveValue(entry.getKey());\n            Object value = resolveValue(entry.getValue());\n            map.put(key, value);\n        }\n        return map;\n    }\n\n\n    protected List<?> toList(String sValue) {\n        String[] tokens = StringUtils.split(sValue);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n\n        //now convert into correct values and/or references:\n        List<Object> values = new ArrayList<Object>(tokens.length);\n        for (String token : tokens) {\n            Object value = resolveValue(token);\n            values.add(value);\n        }\n        return values;\n    }\n\n    protected byte[] toBytes(String sValue) {\n        if (sValue == null) {\n            return null;\n        }\n        byte[] bytes;\n        if (sValue.startsWith(HEX_BEGIN_TOKEN)) {\n            String hex = sValue.substring(HEX_BEGIN_TOKEN.length());\n            bytes = Hex.decode(hex);\n        } else {\n            //assume base64 encoded:\n            bytes = Base64.decode(sValue);\n        }\n        return bytes;\n    }\n\n    protected Object resolveValue(String stringValue) {\n        Object value;\n        if (isReference(stringValue)) {\n            value = resolveReference(stringValue);\n        } else {\n            value = unescapeIfNecessary(stringValue);\n        }\n        return value;\n    }\n\n    protected String checkForNullOrEmptyLiteral(String stringValue) {\n        if (stringValue == null) {\n            return null;\n        }\n        //check if the value is the actual literal string 'null' (expected to be wrapped in quotes):\n        if (stringValue.equals(\"\\\"null\\\"\")) {\n            return NULL_VALUE_TOKEN;\n        }\n        //or the actual literal string of two quotes '\"\"' (expected to be wrapped in quotes):\n        else if (stringValue.equals(\"\\\"\\\"\\\"\\\"\")) {\n            return EMPTY_STRING_VALUE_TOKEN;\n        } else {\n            return stringValue;\n        }\n    }\n    \n    protected void applyProperty(Object object, String propertyPath, Object value) {\n\n        int mapBegin = propertyPath.indexOf(MAP_PROPERTY_BEGIN_TOKEN);\n        int mapEnd = -1;\n        String mapPropertyPath = null;\n        String keyString = null;\n\n        String remaining = null;\n        \n        if (mapBegin >= 0) {\n            //a map is being referenced in the overall property path.  Find just the map's path:\n            mapPropertyPath = propertyPath.substring(0, mapBegin);\n            //find the end of the map reference:\n            mapEnd = propertyPath.indexOf(MAP_PROPERTY_END_TOKEN, mapBegin);\n            //find the token in between the [ and the ] (the map/array key or index):\n            keyString = propertyPath.substring(mapBegin+1, mapEnd);\n\n            //find out if there is more path reference to follow.  If not, we're at a terminal of the OGNL expression\n            if (propertyPath.length() > (mapEnd+1)) {\n                remaining = propertyPath.substring(mapEnd+1);\n                if (remaining.startsWith(\".\")) {\n                    remaining = StringUtils.clean(remaining.substring(1));\n                }\n            }\n        }\n        \n        if (remaining == null) {\n            //we've terminated the OGNL expression.  Check to see if we're assigning a property or a map entry:\n            if (keyString == null) {\n                //not a map or array value assignment - assign the property directly:\n                setProperty(object, propertyPath, value);\n            } else {\n                //we're assigning a map or array entry.  Check to see which we should call:\n                if (isTypedProperty(object, mapPropertyPath, Map.class)) {\n                    Map map = (Map)getProperty(object, mapPropertyPath);\n                    Object mapKey = resolveValue(keyString);\n                    //noinspection unchecked\n                    map.put(mapKey, value);\n                } else {\n                    //must be an array property.  Convert the key string to an index:\n                    int index = Integer.valueOf(keyString);\n                    setIndexedProperty(object, mapPropertyPath, index, value);\n                }\n            }\n        } else {\n            //property is being referenced as part of a nested path.  Find the referenced map/array entry and\n            //recursively call this method with the remaining property path\n            Object referencedValue = null;\n            if (isTypedProperty(object, mapPropertyPath, Map.class)) {\n                Map map = (Map)getProperty(object, mapPropertyPath);\n                Object mapKey = resolveValue(keyString);\n                referencedValue = map.get(mapKey);\n            } else {\n                //must be an array property:\n                int index = Integer.valueOf(keyString);\n                referencedValue = getIndexedProperty(object, mapPropertyPath, index);\n            }\n\n            if (referencedValue == null) {\n                throw new ConfigurationException(\"Referenced map/array value '\" + mapPropertyPath + \"[\" +\n                keyString + \"]' does not exist.\");\n            }\n\n            applyProperty(referencedValue, remaining, value);\n        }\n    }\n    \n    private void setProperty(Object object, String propertyPath, Object value) {\n        try {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Applying property [{}] value [{}] on object of type [{}]\",\n                        new Object[]{propertyPath, value, object.getClass().getName()});\n            }\n            BeanUtils.setProperty(object, propertyPath, value);\n        } catch (Exception e) {\n            String msg = \"Unable to set property '\" + propertyPath + \"' with value [\" + value + \"] on object \" +\n                    \"of type \" + (object != null ? object.getClass().getName() : null) + \".  If \" +\n                    \"'\" + value + \"' is a reference to another (previously defined) object, prefix it with \" +\n                    \"'\" + OBJECT_REFERENCE_BEGIN_TOKEN + \"' to indicate that the referenced \" +\n                    \"object should be used as the actual value.  \" +\n                    \"For example, \" + OBJECT_REFERENCE_BEGIN_TOKEN + value;\n            throw new ConfigurationException(msg, e);\n        }\n    }\n    \n    private Object getProperty(Object object, String propertyPath) {\n        try {\n            return PropertyUtils.getProperty(object, propertyPath);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Unable to access property '\" + propertyPath + \"'\", e);\n        }\n    }\n    \n    private void setIndexedProperty(Object object, String propertyPath, int index, Object value) {\n        try {\n            PropertyUtils.setIndexedProperty(object, propertyPath, index, value);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Unable to set array property '\" + propertyPath + \"'\", e);\n        }\n    }\n    \n    private Object getIndexedProperty(Object object, String propertyPath, int index) {\n        try {\n            return PropertyUtils.getIndexedProperty(object, propertyPath, index);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Unable to acquire array property '\" + propertyPath + \"'\", e);\n        }\n    }\n    \n    protected boolean isIndexedPropertyAssignment(String propertyPath) {\n        return propertyPath.endsWith(\"\" + MAP_PROPERTY_END_TOKEN);\n    }\n\n    protected void applyProperty(Object object, String propertyName, String stringValue) {\n\n        Object value;\n\n        if (NULL_VALUE_TOKEN.equals(stringValue)) {\n            value = null;\n        } else if (EMPTY_STRING_VALUE_TOKEN.equals(stringValue)) {\n            value = StringUtils.EMPTY_STRING;\n        } else if (isIndexedPropertyAssignment(propertyName)) {\n            String checked = checkForNullOrEmptyLiteral(stringValue);\n            value = resolveValue(checked);\n        } else if (isTypedProperty(object, propertyName, Set.class)) {\n            value = toSet(stringValue);\n        } else if (isTypedProperty(object, propertyName, Map.class)) {\n            value = toMap(stringValue);\n        } else if (isTypedProperty(object, propertyName, List.class) ||\n                isTypedProperty(object, propertyName, Collection.class)) {\n            value = toList(stringValue);\n        } else if (isTypedProperty(object, propertyName, byte[].class)) {\n            value = toBytes(stringValue);\n        } else if (isTypedProperty(object, propertyName, ByteSource.class)) {\n            byte[] bytes = toBytes(stringValue);\n            value = ByteSource.Util.bytes(bytes);\n        } else {\n            String checked = checkForNullOrEmptyLiteral(stringValue);\n            value = resolveValue(checked);\n        }\n\n        applyProperty(object, propertyName, value);\n    }\n\n    private class BeanConfigurationProcessor {\n\n        private final List<Statement> statements = new ArrayList<Statement>();\n        private final List<BeanConfiguration> beanConfigurations = new ArrayList<BeanConfiguration>();\n\n        public void add(Statement statement) {\n\n            statements.add(statement); //we execute bean configuration statements in the order they are declared.\n\n            if (statement instanceof InstantiationStatement) {\n                InstantiationStatement is = (InstantiationStatement)statement;\n                beanConfigurations.add(new BeanConfiguration(is));\n            } else {\n                AssignmentStatement as = (AssignmentStatement)statement;\n                //statements always apply to the most recently defined bean configuration with the same name, so we\n                //have to traverse the configuration list starting at the end (most recent elements are appended):\n                boolean addedToConfig = false;\n                String beanName = as.getRootBeanName();\n                for( int i = beanConfigurations.size()-1; i >= 0; i--) {\n                    BeanConfiguration mostRecent = beanConfigurations.get(i);\n                    String mostRecentBeanName = mostRecent.getBeanName();\n                    if (beanName.equals(mostRecentBeanName)) {\n                        mostRecent.add(as);\n                        addedToConfig = true;\n                        break;\n                    }\n                }\n\n                if (!addedToConfig) {\n                    // the AssignmentStatement must be for an existing bean that does not yet have a corresponding\n                    // configuration object (this would happen if the bean is in the default objects map). Because\n                    // BeanConfiguration instances don't exist for default (already instantiated) beans,\n                    // we simulate a creation of one to satisfy this processors implementation:\n                    beanConfigurations.add(new BeanConfiguration(as));\n                }\n            }\n        }\n\n        public void execute() {\n\n            for( Statement statement : statements) {\n\n                statement.execute();\n\n                BeanConfiguration bd = statement.getBeanConfiguration();\n\n                if (bd.isExecuted()) { //bean is fully configured, no more statements to execute for it:\n\n                    //bean configured overrides the 'eventBus' bean - replace the existing eventBus with the one configured:\n                    if (bd.getBeanName().equals(EVENT_BUS_NAME)) {\n                        EventBus eventBus = (EventBus)bd.getBean();\n                        enableEvents(eventBus);\n                    }\n\n                    //ignore global 'shiro.' shortcut mechanism:\n                    if (!bd.isGlobalConfig()) {\n                        BeanEvent event = new ConfiguredBeanEvent(bd.getBeanName(), bd.getBean(),\n                                Collections.unmodifiableMap(objects));\n                        eventBus.publish(event);\n                    }\n\n                    //initialize the bean if necessary:\n                    LifecycleUtils.init(bd.getBean());\n\n                    //ignore global 'shiro.' shortcut mechanism:\n                    if (!bd.isGlobalConfig()) {\n                        BeanEvent event = new InitializedBeanEvent(bd.getBeanName(), bd.getBean(),\n                                Collections.unmodifiableMap(objects));\n                        eventBus.publish(event);\n                    }\n                }\n            }\n        }\n    }\n\n    private class BeanConfiguration {\n\n        private final InstantiationStatement instantiationStatement;\n        private final List<AssignmentStatement> assignments = new ArrayList<AssignmentStatement>();\n        private final String beanName;\n        private Object bean;\n\n        private BeanConfiguration(InstantiationStatement statement) {\n            statement.setBeanConfiguration(this);\n            this.instantiationStatement = statement;\n            this.beanName = statement.lhs;\n        }\n\n        private BeanConfiguration(AssignmentStatement as) {\n            this.instantiationStatement = null;\n            this.beanName = as.getRootBeanName();\n            add(as);\n        }\n\n        public String getBeanName() {\n            return this.beanName;\n        }\n\n        public boolean isGlobalConfig() { //BeanConfiguration instance representing the global 'shiro.' properties\n            // (we should remove this concept).\n            return GLOBAL_PROPERTY_PREFIX.equals(getBeanName());\n        }\n\n        public void add(AssignmentStatement as) {\n            as.setBeanConfiguration(this);\n            assignments.add(as);\n        }\n\n        /**\n         * When this configuration is parsed sufficiently to create (or find) an actual bean instance, that instance\n         * will be associated with its configuration by setting it via this method.\n         *\n         * @param bean the bean instantiated (or found) that corresponds to this BeanConfiguration instance.\n         */\n        public void setBean(Object bean) {\n            this.bean = bean;\n        }\n\n        public Object getBean() {\n            return this.bean;\n        }\n\n        /**\n         * Returns true if all configuration statements have been executed.\n         * @return true if all configuration statements have been executed.\n         */\n        public boolean isExecuted() {\n            if (instantiationStatement != null && !instantiationStatement.isExecuted()) {\n                return false;\n            }\n            for (AssignmentStatement as : assignments) {\n                if (!as.isExecuted()) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    private abstract class Statement {\n\n        protected final String lhs;\n        protected final String rhs;\n        protected Object bean;\n        private Object result;\n        private boolean executed;\n        private BeanConfiguration beanConfiguration;\n\n        private Statement(String lhs, String rhs) {\n            this.lhs = lhs;\n            this.rhs = rhs;\n            this.executed = false;\n        }\n\n        public void setBeanConfiguration(BeanConfiguration bd) {\n            this.beanConfiguration = bd;\n        }\n\n        public BeanConfiguration getBeanConfiguration() {\n            return this.beanConfiguration;\n        }\n\n        public Object execute() {\n            if (!isExecuted()) {\n                this.result = doExecute();\n                this.executed = true;\n            }\n            if (!getBeanConfiguration().isGlobalConfig()) {\n                Assert.notNull(this.bean, \"Implementation must set the root bean for which it executed.\");\n            }\n            return this.result;\n        }\n\n        public Object getBean() {\n            return this.bean;\n        }\n\n        protected void setBean(Object bean) {\n            this.bean = bean;\n            if (this.beanConfiguration.getBean() == null) {\n                this.beanConfiguration.setBean(bean);\n            }\n        }\n\n        public Object getResult() {\n            return result;\n        }\n\n        protected abstract Object doExecute();\n\n        public boolean isExecuted() {\n            return executed;\n        }\n    }\n\n    private class InstantiationStatement extends Statement {\n\n        private InstantiationStatement(String lhs, String rhs) {\n            super(lhs, rhs);\n        }\n\n        @Override\n        protected Object doExecute() {\n            String beanName = this.lhs;\n            createNewInstance(objects, beanName, this.rhs);\n            Object instantiated = objects.get(beanName);\n            setBean(instantiated);\n\n            //also ensure the instantiated bean has access to the event bus or is subscribed to events if necessary:\n            //Note: because events are being enabled on this bean here (before the instantiated event below is\n            //triggered), beans can react to their own instantiation events.\n            enableEventsIfNecessary(instantiated, beanName);\n\n            BeanEvent event = new InstantiatedBeanEvent(beanName, instantiated, Collections.unmodifiableMap(objects));\n            eventBus.publish(event);\n\n            return instantiated;\n        }\n    }\n\n    private class AssignmentStatement extends Statement {\n\n        private final String rootBeanName;\n\n        private AssignmentStatement(String lhs, String rhs) {\n            super(lhs, rhs);\n            int index = lhs.indexOf('.');\n            this.rootBeanName = lhs.substring(0, index);\n        }\n\n        @Override\n        protected Object doExecute() {\n            applyProperty(lhs, rhs, objects);\n            Object bean = objects.get(this.rootBeanName);\n            setBean(bean);\n            return null;\n        }\n\n        public String getRootBeanName() {\n            return this.rootBeanName;\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.config;\n\nimport org.apache.commons.beanutils.BeanUtils;\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.shiro.codec.Base64;\nimport org.apache.shiro.codec.Hex;\nimport org.apache.shiro.config.event.BeanEvent;\nimport org.apache.shiro.config.event.ConfiguredBeanEvent;\nimport org.apache.shiro.config.event.DestroyedBeanEvent;\nimport org.apache.shiro.config.event.InstantiatedBeanEvent;\nimport org.apache.shiro.event.EventBus;\nimport org.apache.shiro.event.EventBusAware;\nimport org.apache.shiro.event.Subscribe;\nimport org.apache.shiro.event.support.DefaultEventBus;\nimport org.apache.shiro.util.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.beans.PropertyDescriptor;\nimport java.util.*;\n\n\n/**\n * Object builder that uses reflection and Apache Commons BeanUtils to build objects given a\n * map of \"property values\".  Typically these come from the Shiro INI configuration and are used\n * to construct or modify the SecurityManager, its dependencies, and web-based security filters.\n * <p/>\n * Recognizes {@link Factory} implementations and will call\n * {@link org.apache.shiro.util.Factory#getInstance() getInstance} to satisfy any reference to this bean.\n *\n * @since 0.9\n */\npublic class ReflectionBuilder {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(ReflectionBuilder.class);\n\n    private static final String OBJECT_REFERENCE_BEGIN_TOKEN = \"$\";\n    private static final String ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN = \"\\\\$\";\n    private static final String GLOBAL_PROPERTY_PREFIX = \"shiro\";\n    private static final char MAP_KEY_VALUE_DELIMITER = ':';\n    private static final String HEX_BEGIN_TOKEN = \"0x\";\n    private static final String NULL_VALUE_TOKEN = \"null\";\n    private static final String EMPTY_STRING_VALUE_TOKEN = \"\\\"\\\"\";\n    private static final char STRING_VALUE_DELIMETER = '\"';\n    private static final char MAP_PROPERTY_BEGIN_TOKEN = '[';\n    private static final char MAP_PROPERTY_END_TOKEN = ']';\n\n    private static final String EVENT_BUS_NAME = \"eventBus\";\n\n    private final Map<String, Object> objects;\n    /**\n     * @since 1.3\n     */\n    private EventBus eventBus;\n    /**\n     * Keeps track of event subscribers that were automatically registered by this ReflectionBuilder during\n     * object construction.  This is used in case a new EventBus is discovered during object graph\n     * construction:  upon discovery of the new EventBus, the existing subscribers will be unregistered from the\n     * old EventBus and then re-registered with the new EventBus.\n     *\n     * @since 1.3\n     */\n    private final Map<String,Object> registeredEventSubscribers;\n\n    //@since 1.3\n    private static Map<String,Object> createDefaultObjectMap() {\n        Map<String,Object> map = new LinkedHashMap<String, Object>();\n        map.put(EVENT_BUS_NAME, new DefaultEventBus());\n        return map;\n    }\n\n    public ReflectionBuilder() {\n        this(null);\n    }\n\n    public ReflectionBuilder(Map<String, ?> defaults) {\n        this.objects = createDefaultObjectMap();\n        this.registeredEventSubscribers = new LinkedHashMap<String,Object>();\n        apply(defaults);\n    }\n\n    private void apply(Map<String, ?> objects) {\n        if(!CollectionUtils.isEmpty(objects)) {\n            this.objects.putAll(objects);\n        }\n        EventBus found = findEventBus(this.objects);\n        Assert.notNull(found, \"An \" + EventBus.class.getName() + \" instance must be present in the object defaults\");\n        enableEvents(found);\n    }\n\n    public Map<String, ?> getObjects() {\n        return objects;\n    }\n\n    /**\n     * @param objects\n     */\n    public void setObjects(Map<String, ?> objects) {\n        this.objects.clear();\n        this.objects.putAll(createDefaultObjectMap());\n        apply(objects);\n    }\n\n    //@since 1.3\n    private void enableEvents(EventBus eventBus) {\n        Assert.notNull(eventBus, \"EventBus argument cannot be null.\");\n        //clean up old auto-registered subscribers:\n        for (Object subscriber : this.registeredEventSubscribers.values()) {\n            this.eventBus.unregister(subscriber);\n        }\n        this.registeredEventSubscribers.clear();\n\n        this.eventBus = eventBus;\n\n        for(Map.Entry<String,Object> entry : this.objects.entrySet()) {\n            enableEventsIfNecessary(entry.getValue(), entry.getKey());\n        }\n    }\n\n    //@since 1.3\n    private void enableEventsIfNecessary(Object bean, String name) {\n        boolean applied = applyEventBusIfNecessary(bean);\n        if (!applied) {\n            //if the event bus is applied, and the bean wishes to be a subscriber as well (not just a publisher),\n            // we assume that the implementation registers itself with the event bus, i.e. eventBus.register(this);\n\n            //if the event bus isn't applied, only then do we need to check to see if the bean is an event subscriber,\n            // and if so, register it on the event bus automatically since it has no ability to do so itself:\n            if (isEventSubscriber(bean, name)) {\n                //found an event subscriber, so register them with the EventBus:\n                this.eventBus.register(bean);\n                this.registeredEventSubscribers.put(name, bean);\n            }\n        }\n    }\n\n    //@since 1.3\n    private boolean isEventSubscriber(Object bean, String name) {\n        List annotatedMethods = ClassUtils.getAnnotatedMethods(bean.getClass(), Subscribe.class);\n        return !CollectionUtils.isEmpty(annotatedMethods);\n    }\n\n    //@since 1.3\n    protected EventBus findEventBus(Map<String,?> objects) {\n\n        if (CollectionUtils.isEmpty(objects)) {\n            return null;\n        }\n\n        //prefer a named object first:\n        Object value = objects.get(EVENT_BUS_NAME);\n        if (value != null && value instanceof EventBus) {\n            return (EventBus)value;\n        }\n\n        //couldn't find a named 'eventBus' EventBus object.  Try to find the first typed value we can:\n        for( Object v : objects.values()) {\n            if (v instanceof EventBus) {\n                return (EventBus)v;\n            }\n        }\n\n        return null;\n    }\n\n    private boolean applyEventBusIfNecessary(Object value) {\n        if (value instanceof EventBusAware) {\n            ((EventBusAware)value).setEventBus(this.eventBus);\n            return true;\n        }\n        return false;\n    }\n\n    public Object getBean(String id) {\n        return objects.get(id);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public <T> T getBean(String id, Class<T> requiredType) {\n        if (requiredType == null) {\n            throw new NullPointerException(\"requiredType argument cannot be null.\");\n        }\n        Object bean = getBean(id);\n        if (bean == null) {\n            return null;\n        }\n        Assert.state(requiredType.isAssignableFrom(bean.getClass()),\n                \"Bean with id [\" + id + \"] is not of the required type [\" + requiredType.getName() + \"].\");\n        return (T) bean;\n    }\n\n    private String parseBeanId(String lhs) {\n        Assert.notNull(lhs);\n        if (lhs.indexOf('.') < 0) {\n            return lhs;\n        }\n        String classSuffix = \".class\";\n        int index = lhs.indexOf(classSuffix);\n        if (index >= 0) {\n            return lhs.substring(0, index);\n        }\n        return null;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Map<String, ?> buildObjects(Map<String, String> kvPairs) {\n\n        if (kvPairs != null && !kvPairs.isEmpty()) {\n\n            BeanConfigurationProcessor processor = new BeanConfigurationProcessor();\n\n            for (Map.Entry<String, String> entry : kvPairs.entrySet()) {\n                String lhs = entry.getKey();\n                String rhs = entry.getValue();\n\n                String beanId = parseBeanId(lhs);\n                if (beanId != null) { //a beanId could be parsed, so the line is a bean instance definition\n                    processor.add(new InstantiationStatement(beanId, rhs));\n                } else { //the line must be a property configuration\n                    processor.add(new AssignmentStatement(lhs, rhs));\n                }\n            }\n\n            processor.execute();\n        }\n\n        return objects;\n    }\n\n    public void destroy() {\n        final Map<String, Object> immutableObjects = Collections.unmodifiableMap(objects);\n        for(Map.Entry<String, ?> entry: objects.entrySet()) {\n            String id = entry.getKey();\n            Object bean = entry.getValue();\n            BeanEvent event = new DestroyedBeanEvent(id, bean, immutableObjects);\n            eventBus.publish(event);\n            LifecycleUtils.destroy(bean);\n        }\n    }\n\n    protected void createNewInstance(Map<String, Object> objects, String name, String value) {\n\n        Object currentInstance = objects.get(name);\n        if (currentInstance != null) {\n            log.info(\"An instance with name '{}' already exists.  \" +\n                    \"Redefining this object as a new instance of type {}\", name, value);\n        }\n\n        Object instance;//name with no property, assume right hand side of equals sign is the class name:\n        try {\n            instance = ClassUtils.newInstance(value);\n            if (instance instanceof Nameable) {\n                ((Nameable) instance).setName(name);\n            }\n        } catch (Exception e) {\n            String msg = \"Unable to instantiate class [\" + value + \"] for object named '\" + name + \"'.  \" +\n                    \"Please ensure you've specified the fully qualified class name correctly.\";\n            throw new ConfigurationException(msg, e);\n        }\n        objects.put(name, instance);\n    }\n\n    protected void applyProperty(String key, String value, Map objects) {\n\n        int index = key.indexOf('.');\n\n        if (index >= 0) {\n            String name = key.substring(0, index);\n            String property = key.substring(index + 1, key.length());\n\n            if (GLOBAL_PROPERTY_PREFIX.equalsIgnoreCase(name)) {\n                applyGlobalProperty(objects, property, value);\n            } else {\n                applySingleProperty(objects, name, property, value);\n            }\n\n        } else {\n            throw new IllegalArgumentException(\"All property keys must contain a '.' character. \" +\n                    \"(e.g. myBean.property = value)  These should already be separated out by buildObjects().\");\n        }\n    }\n\n    protected void applyGlobalProperty(Map objects, String property, String value) {\n        for (Object instance : objects.values()) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(instance, property);\n                if (pd != null) {\n                    applyProperty(instance, property, value);\n                }\n            } catch (Exception e) {\n                String msg = \"Error retrieving property descriptor for instance \" +\n                        \"of type [\" + instance.getClass().getName() + \"] \" +\n                        \"while setting property [\" + property + \"]\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected void applySingleProperty(Map objects, String name, String property, String value) {\n        Object instance = objects.get(name);\n        if (property.equals(\"class\")) {\n            throw new IllegalArgumentException(\"Property keys should not contain 'class' properties since these \" +\n                    \"should already be separated out by buildObjects().\");\n\n        } else if (instance == null) {\n            String msg = \"Configuration error.  Specified object [\" + name + \"] with property [\" +\n                    property + \"] without first defining that object's class.  Please first \" +\n                    \"specify the class property first, e.g. myObject = fully_qualified_class_name \" +\n                    \"and then define additional properties.\";\n            throw new IllegalArgumentException(msg);\n\n        } else {\n            applyProperty(instance, property, value);\n        }\n    }\n\n    protected boolean isReference(String value) {\n        return value != null && value.startsWith(OBJECT_REFERENCE_BEGIN_TOKEN);\n    }\n\n    protected String getId(String referenceToken) {\n        return referenceToken.substring(OBJECT_REFERENCE_BEGIN_TOKEN.length());\n    }\n\n    protected Object getReferencedObject(String id) {\n        Object o = objects != null && !objects.isEmpty() ? objects.get(id) : null;\n        if (o == null) {\n            String msg = \"The object with id [\" + id + \"] has not yet been defined and therefore cannot be \" +\n                    \"referenced.  Please ensure objects are defined in the order in which they should be \" +\n                    \"created and made available for future reference.\";\n            throw new UnresolveableReferenceException(msg);\n        }\n        return o;\n    }\n\n    protected String unescapeIfNecessary(String value) {\n        if (value != null && value.startsWith(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN)) {\n            return value.substring(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN.length() - 1);\n        }\n        return value;\n    }\n\n    protected Object resolveReference(String reference) {\n        String id = getId(reference);\n        log.debug(\"Encountered object reference '{}'.  Looking up object with id '{}'\", reference, id);\n        final Object referencedObject = getReferencedObject(id);\n        if (referencedObject instanceof Factory) {\n            return ((Factory) referencedObject).getInstance();\n        }\n        return referencedObject;\n    }\n\n    protected boolean isTypedProperty(Object object, String propertyName, Class clazz) {\n        if (clazz == null) {\n            throw new NullPointerException(\"type (class) argument cannot be null.\");\n        }\n        try {\n            PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(object, propertyName);\n            if (descriptor == null) {\n                String msg = \"Property '\" + propertyName + \"' does not exist for object of \" +\n                        \"type \" + object.getClass().getName() + \".\";\n                throw new ConfigurationException(msg);\n            }\n            Class propertyClazz = descriptor.getPropertyType();\n            return clazz.isAssignableFrom(propertyClazz);\n        } catch (ConfigurationException ce) {\n            //let it propagate:\n            throw ce;\n        } catch (Exception e) {\n            String msg = \"Unable to determine if property [\" + propertyName + \"] represents a \" + clazz.getName();\n            throw new ConfigurationException(msg, e);\n        }\n    }\n\n    protected Set<?> toSet(String sValue) {\n        String[] tokens = StringUtils.split(sValue);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n        Set<String> setTokens = new LinkedHashSet<String>(Arrays.asList(tokens));\n\n        //now convert into correct values and/or references:\n        Set<Object> values = new LinkedHashSet<Object>(setTokens.size());\n        for (String token : setTokens) {\n            Object value = resolveValue(token);\n            values.add(value);\n        }\n        return values;\n    }\n\n    protected Map<?, ?> toMap(String sValue) {\n        String[] tokens = StringUtils.split(sValue, StringUtils.DEFAULT_DELIMITER_CHAR,\n                StringUtils.DEFAULT_QUOTE_CHAR, StringUtils.DEFAULT_QUOTE_CHAR, true, true);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n\n        Map<String, String> mapTokens = new LinkedHashMap<String, String>(tokens.length);\n        for (String token : tokens) {\n            String[] kvPair = StringUtils.split(token, MAP_KEY_VALUE_DELIMITER);\n            if (kvPair == null || kvPair.length != 2) {\n                String msg = \"Map property value [\" + sValue + \"] contained key-value pair token [\" +\n                        token + \"] that does not properly split to a single key and pair.  This must be the \" +\n                        \"case for all map entries.\";\n                throw new ConfigurationException(msg);\n            }\n            mapTokens.put(kvPair[0], kvPair[1]);\n        }\n\n        //now convert into correct values and/or references:\n        Map<Object, Object> map = new LinkedHashMap<Object, Object>(mapTokens.size());\n        for (Map.Entry<String, String> entry : mapTokens.entrySet()) {\n            Object key = resolveValue(entry.getKey());\n            Object value = resolveValue(entry.getValue());\n            map.put(key, value);\n        }\n        return map;\n    }\n\n\n    protected List<?> toList(String sValue) {\n        String[] tokens = StringUtils.split(sValue);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n\n        //now convert into correct values and/or references:\n        List<Object> values = new ArrayList<Object>(tokens.length);\n        for (String token : tokens) {\n            Object value = resolveValue(token);\n            values.add(value);\n        }\n        return values;\n    }\n\n    protected byte[] toBytes(String sValue) {\n        if (sValue == null) {\n            return null;\n        }\n        byte[] bytes;\n        if (sValue.startsWith(HEX_BEGIN_TOKEN)) {\n            String hex = sValue.substring(HEX_BEGIN_TOKEN.length());\n            bytes = Hex.decode(hex);\n        } else {\n            //assume base64 encoded:\n            bytes = Base64.decode(sValue);\n        }\n        return bytes;\n    }\n\n    protected Object resolveValue(String stringValue) {\n        Object value;\n        if (isReference(stringValue)) {\n            value = resolveReference(stringValue);\n        } else {\n            value = unescapeIfNecessary(stringValue);\n        }\n        return value;\n    }\n\n    protected String checkForNullOrEmptyLiteral(String stringValue) {\n        if (stringValue == null) {\n            return null;\n        }\n        //check if the value is the actual literal string 'null' (expected to be wrapped in quotes):\n        if (stringValue.equals(\"\\\"null\\\"\")) {\n            return NULL_VALUE_TOKEN;\n        }\n        //or the actual literal string of two quotes '\"\"' (expected to be wrapped in quotes):\n        else if (stringValue.equals(\"\\\"\\\"\\\"\\\"\")) {\n            return EMPTY_STRING_VALUE_TOKEN;\n        } else {\n            return stringValue;\n        }\n    }\n    \n    protected void applyProperty(Object object, String propertyPath, Object value) {\n\n        int mapBegin = propertyPath.indexOf(MAP_PROPERTY_BEGIN_TOKEN);\n        int mapEnd = -1;\n        String mapPropertyPath = null;\n        String keyString = null;\n\n        String remaining = null;\n        \n        if (mapBegin >= 0) {\n            //a map is being referenced in the overall property path.  Find just the map's path:\n            mapPropertyPath = propertyPath.substring(0, mapBegin);\n            //find the end of the map reference:\n            mapEnd = propertyPath.indexOf(MAP_PROPERTY_END_TOKEN, mapBegin);\n            //find the token in between the [ and the ] (the map/array key or index):\n            keyString = propertyPath.substring(mapBegin+1, mapEnd);\n\n            //find out if there is more path reference to follow.  If not, we're at a terminal of the OGNL expression\n            if (propertyPath.length() > (mapEnd+1)) {\n                remaining = propertyPath.substring(mapEnd+1);\n                if (remaining.startsWith(\".\")) {\n                    remaining = StringUtils.clean(remaining.substring(1));\n                }\n            }\n        }\n        \n        if (remaining == null) {\n            //we've terminated the OGNL expression.  Check to see if we're assigning a property or a map entry:\n            if (keyString == null) {\n                //not a map or array value assignment - assign the property directly:\n                setProperty(object, propertyPath, value);\n            } else {\n                //we're assigning a map or array entry.  Check to see which we should call:\n                if (isTypedProperty(object, mapPropertyPath, Map.class)) {\n                    Map map = (Map)getProperty(object, mapPropertyPath);\n                    Object mapKey = resolveValue(keyString);\n                    //noinspection unchecked\n                    map.put(mapKey, value);\n                } else {\n                    //must be an array property.  Convert the key string to an index:\n                    int index = Integer.valueOf(keyString);\n                    setIndexedProperty(object, mapPropertyPath, index, value);\n                }\n            }\n        } else {\n            //property is being referenced as part of a nested path.  Find the referenced map/array entry and\n            //recursively call this method with the remaining property path\n            Object referencedValue = null;\n            if (isTypedProperty(object, mapPropertyPath, Map.class)) {\n                Map map = (Map)getProperty(object, mapPropertyPath);\n                Object mapKey = resolveValue(keyString);\n                referencedValue = map.get(mapKey);\n            } else {\n                //must be an array property:\n                int index = Integer.valueOf(keyString);\n                referencedValue = getIndexedProperty(object, mapPropertyPath, index);\n            }\n\n            if (referencedValue == null) {\n                throw new ConfigurationException(\"Referenced map/array value '\" + mapPropertyPath + \"[\" +\n                keyString + \"]' does not exist.\");\n            }\n\n            applyProperty(referencedValue, remaining, value);\n        }\n    }\n    \n    private void setProperty(Object object, String propertyPath, Object value) {\n        try {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Applying property [{}] value [{}] on object of type [{}]\",\n                        new Object[]{propertyPath, value, object.getClass().getName()});\n            }\n            BeanUtils.setProperty(object, propertyPath, value);\n        } catch (Exception e) {\n            String msg = \"Unable to set property '\" + propertyPath + \"' with value [\" + value + \"] on object \" +\n                    \"of type \" + (object != null ? object.getClass().getName() : null) + \".  If \" +\n                    \"'\" + value + \"' is a reference to another (previously defined) object, prefix it with \" +\n                    \"'\" + OBJECT_REFERENCE_BEGIN_TOKEN + \"' to indicate that the referenced \" +\n                    \"object should be used as the actual value.  \" +\n                    \"For example, \" + OBJECT_REFERENCE_BEGIN_TOKEN + value;\n            throw new ConfigurationException(msg, e);\n        }\n    }\n    \n    private Object getProperty(Object object, String propertyPath) {\n        try {\n            return PropertyUtils.getProperty(object, propertyPath);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Unable to access property '\" + propertyPath + \"'\", e);\n        }\n    }\n    \n    private void setIndexedProperty(Object object, String propertyPath, int index, Object value) {\n        try {\n            PropertyUtils.setIndexedProperty(object, propertyPath, index, value);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Unable to set array property '\" + propertyPath + \"'\", e);\n        }\n    }\n    \n    private Object getIndexedProperty(Object object, String propertyPath, int index) {\n        try {\n            return PropertyUtils.getIndexedProperty(object, propertyPath, index);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Unable to acquire array property '\" + propertyPath + \"'\", e);\n        }\n    }\n    \n    protected boolean isIndexedPropertyAssignment(String propertyPath) {\n        return propertyPath.endsWith(\"\" + MAP_PROPERTY_END_TOKEN);\n    }\n\n    protected void applyProperty(Object object, String propertyName, String stringValue) {\n\n        Object value;\n\n        if (NULL_VALUE_TOKEN.equals(stringValue)) {\n            value = null;\n        } else if (EMPTY_STRING_VALUE_TOKEN.equals(stringValue)) {\n            value = StringUtils.EMPTY_STRING;\n        } else if (isIndexedPropertyAssignment(propertyName)) {\n            String checked = checkForNullOrEmptyLiteral(stringValue);\n            value = resolveValue(checked);\n        } else if (isTypedProperty(object, propertyName, Set.class)) {\n            value = toSet(stringValue);\n        } else if (isTypedProperty(object, propertyName, Map.class)) {\n            value = toMap(stringValue);\n        } else if (isTypedProperty(object, propertyName, List.class) ||\n                isTypedProperty(object, propertyName, Collection.class)) {\n            value = toList(stringValue);\n        } else if (isTypedProperty(object, propertyName, byte[].class)) {\n            value = toBytes(stringValue);\n        } else if (isTypedProperty(object, propertyName, ByteSource.class)) {\n            byte[] bytes = toBytes(stringValue);\n            value = ByteSource.Util.bytes(bytes);\n        } else {\n            String checked = checkForNullOrEmptyLiteral(stringValue);\n            value = resolveValue(checked);\n        }\n\n        applyProperty(object, propertyName, value);\n    }\n\n    private class BeanConfigurationProcessor {\n\n        private final List<Statement> statements = new ArrayList<Statement>();\n        private final List<BeanConfiguration> beanConfigurations = new ArrayList<BeanConfiguration>();\n\n        public void add(Statement statement) {\n\n            statements.add(statement); //we execute bean configuration statements in the order they are declared.\n\n            if (statement instanceof InstantiationStatement) {\n                InstantiationStatement is = (InstantiationStatement)statement;\n                beanConfigurations.add(new BeanConfiguration(is));\n            } else {\n                AssignmentStatement as = (AssignmentStatement)statement;\n                //statements always apply to the most recently defined bean configuration with the same name, so we\n                //have to traverse the configuration list starting at the end (most recent elements are appended):\n                boolean addedToConfig = false;\n                String beanName = as.getRootBeanName();\n                for( int i = beanConfigurations.size()-1; i >= 0; i--) {\n                    BeanConfiguration mostRecent = beanConfigurations.get(i);\n                    String mostRecentBeanName = mostRecent.getBeanName();\n                    if (beanName.equals(mostRecentBeanName)) {\n                        mostRecent.add(as);\n                        addedToConfig = true;\n                        break;\n                    }\n                }\n\n                if (!addedToConfig) {\n                    // the AssignmentStatement must be for an existing bean that does not yet have a corresponding\n                    // configuration object (this would happen if the bean is in the default objects map). Because\n                    // BeanConfiguration instances don't exist for default (already instantiated) beans,\n                    // we simulate a creation of one to satisfy this processors implementation:\n                    beanConfigurations.add(new BeanConfiguration(as));\n                }\n            }\n        }\n\n        public void execute() {\n\n            for( Statement statement : statements) {\n\n                statement.execute();\n\n                BeanConfiguration bd = statement.getBeanConfiguration();\n\n                if (bd.isExecuted()) { //bean is fully configured, no more statements to execute for it:\n\n                    if (bd.getBeanName().equals(EVENT_BUS_NAME)) {\n                        EventBus eventBus = (EventBus)bd.getBean();\n                        enableEvents(eventBus);\n                    }\n\n                    //ignore global 'shiro.' shortcut mechanism:\n                    if (!bd.isGlobalConfig()) {\n                        BeanEvent event = new ConfiguredBeanEvent(bd.getBeanName(), bd.getBean(),\n                                Collections.unmodifiableMap(objects));\n                        eventBus.publish(event);\n                    }\n                }\n            }\n        }\n    }\n\n    private class BeanConfiguration {\n\n        private final InstantiationStatement instantiationStatement;\n        private final List<AssignmentStatement> assignments = new ArrayList<AssignmentStatement>();\n        private final String beanName;\n        private Object bean;\n\n        private BeanConfiguration(InstantiationStatement statement) {\n            statement.setBeanConfiguration(this);\n            this.instantiationStatement = statement;\n            this.beanName = statement.lhs;\n        }\n\n        private BeanConfiguration(AssignmentStatement as) {\n            this.instantiationStatement = null;\n            this.beanName = as.getRootBeanName();\n            add(as);\n        }\n\n        public String getBeanName() {\n            return this.beanName;\n        }\n\n        public boolean isGlobalConfig() { //BeanConfiguration instance representing the global 'shiro.' properties\n            // (we should remove this concept).\n            return GLOBAL_PROPERTY_PREFIX.equals(getBeanName());\n        }\n\n        public void add(AssignmentStatement as) {\n            as.setBeanConfiguration(this);\n            assignments.add(as);\n        }\n\n        /**\n         * When this configuration is parsed sufficiently to create (or find) an actual bean instance, that instance\n         * will be associated with its configuration by setting it via this method.\n         *\n         * @param bean the bean instantiated (or found) that corresponds to this BeanConfiguration instance.\n         */\n        public void setBean(Object bean) {\n            this.bean = bean;\n        }\n\n        public Object getBean() {\n            return this.bean;\n        }\n\n        /**\n         * Returns true if all configuration statements have been executed.\n         * @return true if all configuration statements have been executed.\n         */\n        public boolean isExecuted() {\n            if (instantiationStatement != null && !instantiationStatement.isExecuted()) {\n                return false;\n            }\n            for (AssignmentStatement as : assignments) {\n                if (!as.isExecuted()) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    private abstract class Statement {\n\n        protected final String lhs;\n        protected final String rhs;\n        protected Object bean;\n        private Object result;\n        private boolean executed;\n        private BeanConfiguration beanConfiguration;\n\n        private Statement(String lhs, String rhs) {\n            this.lhs = lhs;\n            this.rhs = rhs;\n            this.executed = false;\n        }\n\n        public void setBeanConfiguration(BeanConfiguration bd) {\n            this.beanConfiguration = bd;\n        }\n\n        public BeanConfiguration getBeanConfiguration() {\n            return this.beanConfiguration;\n        }\n\n        public Object execute() {\n            if (!isExecuted()) {\n                this.result = doExecute();\n                this.executed = true;\n            }\n            if (!getBeanConfiguration().isGlobalConfig()) {\n                Assert.notNull(this.bean, \"Implementation must set the root bean for which it executed.\");\n            }\n            return this.result;\n        }\n\n        public Object getBean() {\n            return this.bean;\n        }\n\n        protected void setBean(Object bean) {\n            this.bean = bean;\n            if (this.beanConfiguration.getBean() == null) {\n                this.beanConfiguration.setBean(bean);\n            }\n        }\n\n        public Object getResult() {\n            return result;\n        }\n\n        protected abstract Object doExecute();\n\n        public boolean isExecuted() {\n            return executed;\n        }\n    }\n\n    private class InstantiationStatement extends Statement {\n\n        private InstantiationStatement(String lhs, String rhs) {\n            super(lhs, rhs);\n        }\n\n        @Override\n        protected Object doExecute() {\n            createNewInstance(objects, this.lhs, this.rhs);\n            Object instantiated = objects.get(this.lhs);\n            setBean(instantiated);\n\n            BeanEvent event = new InstantiatedBeanEvent(this.lhs, instantiated, Collections.unmodifiableMap(objects));\n            eventBus.publish(event);\n\n            return instantiated;\n        }\n    }\n\n    private class AssignmentStatement extends Statement {\n\n        private final String rootBeanName;\n\n        private AssignmentStatement(String lhs, String rhs) {\n            super(lhs, rhs);\n            int index = lhs.indexOf('.');\n            this.rootBeanName = lhs.substring(0, index);\n        }\n\n        @Override\n        protected Object doExecute() {\n            applyProperty(lhs, rhs, objects);\n            Object bean = objects.get(this.rootBeanName);\n            setBean(bean);\n            return null;\n        }\n\n        public String getRootBeanName() {\n            return this.rootBeanName;\n        }\n    }\n\n}\n","lineNo":270}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.config;\n\nimport org.apache.commons.beanutils.BeanUtils;\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.shiro.codec.Base64;\nimport org.apache.shiro.codec.Hex;\nimport org.apache.shiro.config.event.BeanEvent;\nimport org.apache.shiro.config.event.ConfiguredBeanEvent;\nimport org.apache.shiro.config.event.DestroyedBeanEvent;\nimport org.apache.shiro.config.event.InstantiatedBeanEvent;\nimport org.apache.shiro.event.EventBus;\nimport org.apache.shiro.event.EventBusAware;\nimport org.apache.shiro.event.Subscribe;\nimport org.apache.shiro.event.support.DefaultEventBus;\nimport org.apache.shiro.util.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.beans.PropertyDescriptor;\nimport java.util.*;\n\n\n/**\n * Object builder that uses reflection and Apache Commons BeanUtils to build objects given a\n * map of \"property values\".  Typically these come from the Shiro INI configuration and are used\n * to construct or modify the SecurityManager, its dependencies, and web-based security filters.\n * <p/>\n * Recognizes {@link Factory} implementations and will call\n * {@link org.apache.shiro.util.Factory#getInstance() getInstance} to satisfy any reference to this bean.\n *\n * @since 0.9\n */\npublic class ReflectionBuilder {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(ReflectionBuilder.class);\n\n    private static final String OBJECT_REFERENCE_BEGIN_TOKEN = \"$\";\n    private static final String ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN = \"\\\\$\";\n    private static final String GLOBAL_PROPERTY_PREFIX = \"shiro\";\n    private static final char MAP_KEY_VALUE_DELIMITER = ':';\n    private static final String HEX_BEGIN_TOKEN = \"0x\";\n    private static final String NULL_VALUE_TOKEN = \"null\";\n    private static final String EMPTY_STRING_VALUE_TOKEN = \"\\\"\\\"\";\n    private static final char STRING_VALUE_DELIMETER = '\"';\n    private static final char MAP_PROPERTY_BEGIN_TOKEN = '[';\n    private static final char MAP_PROPERTY_END_TOKEN = ']';\n\n    private static final String EVENT_BUS_NAME = \"eventBus\";\n\n    private final Map<String, Object> objects;\n    /**\n     * @since 1.3\n     */\n    private EventBus eventBus;\n    /**\n     * Keeps track of event subscribers that were automatically registered by this ReflectionBuilder during\n     * object construction.  This is used in case a new EventBus is discovered during object graph\n     * construction:  upon discovery of the new EventBus, the existing subscribers will be unregistered from the\n     * old EventBus and then re-registered with the new EventBus.\n     *\n     * @since 1.3\n     */\n    private final Map<String,Object> registeredEventSubscribers;\n\n    //@since 1.3\n    private static Map<String,Object> createDefaultObjectMap() {\n        Map<String,Object> map = new LinkedHashMap<String, Object>();\n        map.put(EVENT_BUS_NAME, new DefaultEventBus());\n        return map;\n    }\n\n    public ReflectionBuilder() {\n        this(null);\n    }\n\n    public ReflectionBuilder(Map<String, ?> defaults) {\n        this.objects = createDefaultObjectMap();\n        this.registeredEventSubscribers = new LinkedHashMap<String,Object>();\n        apply(defaults);\n    }\n\n    private void apply(Map<String, ?> objects) {\n        if(!CollectionUtils.isEmpty(objects)) {\n            this.objects.putAll(objects);\n        }\n        EventBus found = findEventBus(this.objects);\n        Assert.notNull(found, \"An \" + EventBus.class.getName() + \" instance must be present in the object defaults\");\n        enableEvents(found);\n    }\n\n    public Map<String, ?> getObjects() {\n        return objects;\n    }\n\n    /**\n     * @param objects\n     */\n    public void setObjects(Map<String, ?> objects) {\n        this.objects.clear();\n        this.objects.putAll(createDefaultObjectMap());\n        apply(objects);\n    }\n\n    //@since 1.3\n    private void enableEvents(EventBus eventBus) {\n        Assert.notNull(eventBus, \"EventBus argument cannot be null.\");\n        //clean up old auto-registered subscribers:\n        for (Object subscriber : this.registeredEventSubscribers.values()) {\n            this.eventBus.unregister(subscriber);\n        }\n        this.registeredEventSubscribers.clear();\n\n        this.eventBus = eventBus;\n\n        for(Map.Entry<String,Object> entry : this.objects.entrySet()) {\n            enableEventsIfNecessary(entry.getValue(), entry.getKey());\n        }\n    }\n\n    //@since 1.3\n    private void enableEventsIfNecessary(Object bean, String name) {\n        boolean applied = applyEventBusIfNecessary(bean);\n        if (!applied) {\n            //if the event bus is applied, and the bean wishes to be a subscriber as well (not just a publisher),\n            // we assume that the implementation registers itself with the event bus, i.e. eventBus.register(this);\n\n            //if the event bus isn't applied, only then do we need to check to see if the bean is an event subscriber,\n            // and if so, register it on the event bus automatically since it has no ability to do so itself:\n            if (isEventSubscriber(bean, name)) {\n                //found an event subscriber, so register them with the EventBus:\n                this.eventBus.register(bean);\n                this.registeredEventSubscribers.put(name, bean);\n            }\n        }\n    }\n\n    //@since 1.3\n    private boolean isEventSubscriber(Object bean, String name) {\n        List annotatedMethods = ClassUtils.getAnnotatedMethods(bean.getClass(), Subscribe.class);\n        return !CollectionUtils.isEmpty(annotatedMethods);\n    }\n\n    //@since 1.3\n    protected EventBus findEventBus(Map<String,?> objects) {\n\n        if (CollectionUtils.isEmpty(objects)) {\n            return null;\n        }\n\n        //prefer a named object first:\n        Object value = objects.get(EVENT_BUS_NAME);\n        if (value != null && value instanceof EventBus) {\n            return (EventBus)value;\n        }\n\n        //couldn't find a named 'eventBus' EventBus object.  Try to find the first typed value we can:\n        for( Object v : objects.values()) {\n            if (v instanceof EventBus) {\n                return (EventBus)v;\n            }\n        }\n\n        return null;\n    }\n\n    private boolean applyEventBusIfNecessary(Object value) {\n        if (value instanceof EventBusAware) {\n            ((EventBusAware)value).setEventBus(this.eventBus);\n            return true;\n        }\n        return false;\n    }\n\n    public Object getBean(String id) {\n        return objects.get(id);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public <T> T getBean(String id, Class<T> requiredType) {\n        if (requiredType == null) {\n            throw new NullPointerException(\"requiredType argument cannot be null.\");\n        }\n        Object bean = getBean(id);\n        if (bean == null) {\n            return null;\n        }\n        Assert.state(requiredType.isAssignableFrom(bean.getClass()),\n                \"Bean with id [\" + id + \"] is not of the required type [\" + requiredType.getName() + \"].\");\n        return (T) bean;\n    }\n\n    private String parseBeanId(String lhs) {\n        Assert.notNull(lhs);\n        if (lhs.indexOf('.') < 0) {\n            return lhs;\n        }\n        String classSuffix = \".class\";\n        int index = lhs.indexOf(classSuffix);\n        if (index >= 0) {\n            return lhs.substring(0, index);\n        }\n        return null;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Map<String, ?> buildObjects(Map<String, String> kvPairs) {\n\n        if (kvPairs != null && !kvPairs.isEmpty()) {\n\n            BeanConfigurationProcessor processor = new BeanConfigurationProcessor();\n\n            for (Map.Entry<String, String> entry : kvPairs.entrySet()) {\n                String lhs = entry.getKey();\n                String rhs = entry.getValue();\n\n                String beanId = parseBeanId(lhs);\n                if (beanId != null) { //a beanId could be parsed, so the line is a bean instance definition\n                    processor.add(new InstantiationStatement(beanId, rhs));\n                } else { //the line must be a property configuration\n                    processor.add(new AssignmentStatement(lhs, rhs));\n                }\n            }\n\n            processor.execute();\n        }\n\n        return objects;\n    }\n\n    public void destroy() {\n        final Map<String, Object> immutableObjects = Collections.unmodifiableMap(objects);\n        for(Map.Entry<String, ?> entry: objects.entrySet()) {\n            String id = entry.getKey();\n            Object bean = entry.getValue();\n            BeanEvent event = new DestroyedBeanEvent(id, bean, immutableObjects);\n            eventBus.publish(event);\n            LifecycleUtils.destroy(bean);\n        }\n    }\n\n    protected void createNewInstance(Map<String, Object> objects, String name, String value) {\n\n        Object currentInstance = objects.get(name);\n        if (currentInstance != null) {\n            log.info(\"An instance with name '{}' already exists.  \" +\n                    \"Redefining this object as a new instance of type {}\", name, value);\n        }\n\n        Object instance;//name with no property, assume right hand side of equals sign is the class name:\n        try {\n            instance = ClassUtils.newInstance(value);\n            if (instance instanceof Nameable) {\n                ((Nameable) instance).setName(name);\n            }\n        } catch (Exception e) {\n            String msg = \"Unable to instantiate class [\" + value + \"] for object named '\" + name + \"'.  \" +\n                    \"Please ensure you've specified the fully qualified class name correctly.\";\n            throw new ConfigurationException(msg, e);\n        }\n        objects.put(name, instance);\n    }\n\n    protected void applyProperty(String key, String value, Map objects) {\n\n        int index = key.indexOf('.');\n\n        if (index >= 0) {\n            String name = key.substring(0, index);\n            String property = key.substring(index + 1, key.length());\n\n            if (GLOBAL_PROPERTY_PREFIX.equalsIgnoreCase(name)) {\n                applyGlobalProperty(objects, property, value);\n            } else {\n                applySingleProperty(objects, name, property, value);\n            }\n\n        } else {\n            throw new IllegalArgumentException(\"All property keys must contain a '.' character. \" +\n                    \"(e.g. myBean.property = value)  These should already be separated out by buildObjects().\");\n        }\n    }\n\n    protected void applyGlobalProperty(Map objects, String property, String value) {\n        for (Object instance : objects.values()) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(instance, property);\n                if (pd != null) {\n                    applyProperty(instance, property, value);\n                }\n            } catch (Exception e) {\n                String msg = \"Error retrieving property descriptor for instance \" +\n                        \"of type [\" + instance.getClass().getName() + \"] \" +\n                        \"while setting property [\" + property + \"]\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected void applySingleProperty(Map objects, String name, String property, String value) {\n        Object instance = objects.get(name);\n        if (property.equals(\"class\")) {\n            throw new IllegalArgumentException(\"Property keys should not contain 'class' properties since these \" +\n                    \"should already be separated out by buildObjects().\");\n\n        } else if (instance == null) {\n            String msg = \"Configuration error.  Specified object [\" + name + \"] with property [\" +\n                    property + \"] without first defining that object's class.  Please first \" +\n                    \"specify the class property first, e.g. myObject = fully_qualified_class_name \" +\n                    \"and then define additional properties.\";\n            throw new IllegalArgumentException(msg);\n\n        } else {\n            applyProperty(instance, property, value);\n        }\n    }\n\n    protected boolean isReference(String value) {\n        return value != null && value.startsWith(OBJECT_REFERENCE_BEGIN_TOKEN);\n    }\n\n    protected String getId(String referenceToken) {\n        return referenceToken.substring(OBJECT_REFERENCE_BEGIN_TOKEN.length());\n    }\n\n    protected Object getReferencedObject(String id) {\n        Object o = objects != null && !objects.isEmpty() ? objects.get(id) : null;\n        if (o == null) {\n            String msg = \"The object with id [\" + id + \"] has not yet been defined and therefore cannot be \" +\n                    \"referenced.  Please ensure objects are defined in the order in which they should be \" +\n                    \"created and made available for future reference.\";\n            throw new UnresolveableReferenceException(msg);\n        }\n        return o;\n    }\n\n    protected String unescapeIfNecessary(String value) {\n        if (value != null && value.startsWith(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN)) {\n            return value.substring(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN.length() - 1);\n        }\n        return value;\n    }\n\n    protected Object resolveReference(String reference) {\n        String id = getId(reference);\n        log.debug(\"Encountered object reference '{}'.  Looking up object with id '{}'\", reference, id);\n        final Object referencedObject = getReferencedObject(id);\n        if (referencedObject instanceof Factory) {\n            return ((Factory) referencedObject).getInstance();\n        }\n        return referencedObject;\n    }\n\n    protected boolean isTypedProperty(Object object, String propertyName, Class clazz) {\n        if (clazz == null) {\n            throw new NullPointerException(\"type (class) argument cannot be null.\");\n        }\n        try {\n            PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(object, propertyName);\n            if (descriptor == null) {\n                String msg = \"Property '\" + propertyName + \"' does not exist for object of \" +\n                        \"type \" + object.getClass().getName() + \".\";\n                throw new ConfigurationException(msg);\n            }\n            Class propertyClazz = descriptor.getPropertyType();\n            return clazz.isAssignableFrom(propertyClazz);\n        } catch (ConfigurationException ce) {\n            //let it propagate:\n            throw ce;\n        } catch (Exception e) {\n            String msg = \"Unable to determine if property [\" + propertyName + \"] represents a \" + clazz.getName();\n            throw new ConfigurationException(msg, e);\n        }\n    }\n\n    protected Set<?> toSet(String sValue) {\n        String[] tokens = StringUtils.split(sValue);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n        Set<String> setTokens = new LinkedHashSet<String>(Arrays.asList(tokens));\n\n        //now convert into correct values and/or references:\n        Set<Object> values = new LinkedHashSet<Object>(setTokens.size());\n        for (String token : setTokens) {\n            Object value = resolveValue(token);\n            values.add(value);\n        }\n        return values;\n    }\n\n    protected Map<?, ?> toMap(String sValue) {\n        String[] tokens = StringUtils.split(sValue, StringUtils.DEFAULT_DELIMITER_CHAR,\n                StringUtils.DEFAULT_QUOTE_CHAR, StringUtils.DEFAULT_QUOTE_CHAR, true, true);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n\n        Map<String, String> mapTokens = new LinkedHashMap<String, String>(tokens.length);\n        for (String token : tokens) {\n            String[] kvPair = StringUtils.split(token, MAP_KEY_VALUE_DELIMITER);\n            if (kvPair == null || kvPair.length != 2) {\n                String msg = \"Map property value [\" + sValue + \"] contained key-value pair token [\" +\n                        token + \"] that does not properly split to a single key and pair.  This must be the \" +\n                        \"case for all map entries.\";\n                throw new ConfigurationException(msg);\n            }\n            mapTokens.put(kvPair[0], kvPair[1]);\n        }\n\n        //now convert into correct values and/or references:\n        Map<Object, Object> map = new LinkedHashMap<Object, Object>(mapTokens.size());\n        for (Map.Entry<String, String> entry : mapTokens.entrySet()) {\n            Object key = resolveValue(entry.getKey());\n            Object value = resolveValue(entry.getValue());\n            map.put(key, value);\n        }\n        return map;\n    }\n\n\n    protected List<?> toList(String sValue) {\n        String[] tokens = StringUtils.split(sValue);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n\n        //now convert into correct values and/or references:\n        List<Object> values = new ArrayList<Object>(tokens.length);\n        for (String token : tokens) {\n            Object value = resolveValue(token);\n            values.add(value);\n        }\n        return values;\n    }\n\n    protected byte[] toBytes(String sValue) {\n        if (sValue == null) {\n            return null;\n        }\n        byte[] bytes;\n        if (sValue.startsWith(HEX_BEGIN_TOKEN)) {\n            String hex = sValue.substring(HEX_BEGIN_TOKEN.length());\n            bytes = Hex.decode(hex);\n        } else {\n            //assume base64 encoded:\n            bytes = Base64.decode(sValue);\n        }\n        return bytes;\n    }\n\n    protected Object resolveValue(String stringValue) {\n        Object value;\n        if (isReference(stringValue)) {\n            value = resolveReference(stringValue);\n        } else {\n            value = unescapeIfNecessary(stringValue);\n        }\n        return value;\n    }\n\n    protected String checkForNullOrEmptyLiteral(String stringValue) {\n        if (stringValue == null) {\n            return null;\n        }\n        //check if the value is the actual literal string 'null' (expected to be wrapped in quotes):\n        if (stringValue.equals(\"\\\"null\\\"\")) {\n            return NULL_VALUE_TOKEN;\n        }\n        //or the actual literal string of two quotes '\"\"' (expected to be wrapped in quotes):\n        else if (stringValue.equals(\"\\\"\\\"\\\"\\\"\")) {\n            return EMPTY_STRING_VALUE_TOKEN;\n        } else {\n            return stringValue;\n        }\n    }\n    \n    protected void applyProperty(Object object, String propertyPath, Object value) {\n\n        int mapBegin = propertyPath.indexOf(MAP_PROPERTY_BEGIN_TOKEN);\n        int mapEnd = -1;\n        String mapPropertyPath = null;\n        String keyString = null;\n\n        String remaining = null;\n        \n        if (mapBegin >= 0) {\n            //a map is being referenced in the overall property path.  Find just the map's path:\n            mapPropertyPath = propertyPath.substring(0, mapBegin);\n            //find the end of the map reference:\n            mapEnd = propertyPath.indexOf(MAP_PROPERTY_END_TOKEN, mapBegin);\n            //find the token in between the [ and the ] (the map/array key or index):\n            keyString = propertyPath.substring(mapBegin+1, mapEnd);\n\n            //find out if there is more path reference to follow.  If not, we're at a terminal of the OGNL expression\n            if (propertyPath.length() > (mapEnd+1)) {\n                remaining = propertyPath.substring(mapEnd+1);\n                if (remaining.startsWith(\".\")) {\n                    remaining = StringUtils.clean(remaining.substring(1));\n                }\n            }\n        }\n        \n        if (remaining == null) {\n            //we've terminated the OGNL expression.  Check to see if we're assigning a property or a map entry:\n            if (keyString == null) {\n                //not a map or array value assignment - assign the property directly:\n                setProperty(object, propertyPath, value);\n            } else {\n                //we're assigning a map or array entry.  Check to see which we should call:\n                if (isTypedProperty(object, mapPropertyPath, Map.class)) {\n                    Map map = (Map)getProperty(object, mapPropertyPath);\n                    Object mapKey = resolveValue(keyString);\n                    //noinspection unchecked\n                    map.put(mapKey, value);\n                } else {\n                    //must be an array property.  Convert the key string to an index:\n                    int index = Integer.valueOf(keyString);\n                    setIndexedProperty(object, mapPropertyPath, index, value);\n                }\n            }\n        } else {\n            //property is being referenced as part of a nested path.  Find the referenced map/array entry and\n            //recursively call this method with the remaining property path\n            Object referencedValue = null;\n            if (isTypedProperty(object, mapPropertyPath, Map.class)) {\n                Map map = (Map)getProperty(object, mapPropertyPath);\n                Object mapKey = resolveValue(keyString);\n                referencedValue = map.get(mapKey);\n            } else {\n                //must be an array property:\n                int index = Integer.valueOf(keyString);\n                referencedValue = getIndexedProperty(object, mapPropertyPath, index);\n            }\n\n            if (referencedValue == null) {\n                throw new ConfigurationException(\"Referenced map/array value '\" + mapPropertyPath + \"[\" +\n                keyString + \"]' does not exist.\");\n            }\n\n            applyProperty(referencedValue, remaining, value);\n        }\n    }\n    \n    private void setProperty(Object object, String propertyPath, Object value) {\n        try {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Applying property [{}] value [{}] on object of type [{}]\",\n                        new Object[]{propertyPath, value, object.getClass().getName()});\n            }\n            BeanUtils.setProperty(object, propertyPath, value);\n        } catch (Exception e) {\n            String msg = \"Unable to set property '\" + propertyPath + \"' with value [\" + value + \"] on object \" +\n                    \"of type \" + (object != null ? object.getClass().getName() : null) + \".  If \" +\n                    \"'\" + value + \"' is a reference to another (previously defined) object, prefix it with \" +\n                    \"'\" + OBJECT_REFERENCE_BEGIN_TOKEN + \"' to indicate that the referenced \" +\n                    \"object should be used as the actual value.  \" +\n                    \"For example, \" + OBJECT_REFERENCE_BEGIN_TOKEN + value;\n            throw new ConfigurationException(msg, e);\n        }\n    }\n    \n    private Object getProperty(Object object, String propertyPath) {\n        try {\n            return PropertyUtils.getProperty(object, propertyPath);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Unable to access property '\" + propertyPath + \"'\", e);\n        }\n    }\n    \n    private void setIndexedProperty(Object object, String propertyPath, int index, Object value) {\n        try {\n            PropertyUtils.setIndexedProperty(object, propertyPath, index, value);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Unable to set array property '\" + propertyPath + \"'\", e);\n        }\n    }\n    \n    private Object getIndexedProperty(Object object, String propertyPath, int index) {\n        try {\n            return PropertyUtils.getIndexedProperty(object, propertyPath, index);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Unable to acquire array property '\" + propertyPath + \"'\", e);\n        }\n    }\n    \n    protected boolean isIndexedPropertyAssignment(String propertyPath) {\n        return propertyPath.endsWith(\"\" + MAP_PROPERTY_END_TOKEN);\n    }\n\n    protected void applyProperty(Object object, String propertyName, String stringValue) {\n\n        Object value;\n\n        if (NULL_VALUE_TOKEN.equals(stringValue)) {\n            value = null;\n        } else if (EMPTY_STRING_VALUE_TOKEN.equals(stringValue)) {\n            value = StringUtils.EMPTY_STRING;\n        } else if (isIndexedPropertyAssignment(propertyName)) {\n            String checked = checkForNullOrEmptyLiteral(stringValue);\n            value = resolveValue(checked);\n        } else if (isTypedProperty(object, propertyName, Set.class)) {\n            value = toSet(stringValue);\n        } else if (isTypedProperty(object, propertyName, Map.class)) {\n            value = toMap(stringValue);\n        } else if (isTypedProperty(object, propertyName, List.class) ||\n                isTypedProperty(object, propertyName, Collection.class)) {\n            value = toList(stringValue);\n        } else if (isTypedProperty(object, propertyName, byte[].class)) {\n            value = toBytes(stringValue);\n        } else if (isTypedProperty(object, propertyName, ByteSource.class)) {\n            byte[] bytes = toBytes(stringValue);\n            value = ByteSource.Util.bytes(bytes);\n        } else {\n            String checked = checkForNullOrEmptyLiteral(stringValue);\n            value = resolveValue(checked);\n        }\n\n        applyProperty(object, propertyName, value);\n    }\n\n    private class BeanConfigurationProcessor {\n\n        private final List<Statement> statements = new ArrayList<Statement>();\n        private final List<BeanConfiguration> beanConfigurations = new ArrayList<BeanConfiguration>();\n\n        public void add(Statement statement) {\n\n            statements.add(statement); //we execute bean configuration statements in the order they are declared.\n\n            if (statement instanceof InstantiationStatement) {\n                InstantiationStatement is = (InstantiationStatement)statement;\n                beanConfigurations.add(new BeanConfiguration(is));\n            } else {\n                AssignmentStatement as = (AssignmentStatement)statement;\n                //statements always apply to the most recently defined bean configuration with the same name, so we\n                //have to traverse the configuration list starting at the end (most recent elements are appended):\n                boolean addedToConfig = false;\n                String beanName = as.getRootBeanName();\n                for( int i = beanConfigurations.size()-1; i >= 0; i--) {\n                    BeanConfiguration mostRecent = beanConfigurations.get(i);\n                    String mostRecentBeanName = mostRecent.getBeanName();\n                    if (beanName.equals(mostRecentBeanName)) {\n                        mostRecent.add(as);\n                        addedToConfig = true;\n                        break;\n                    }\n                }\n\n                if (!addedToConfig) {\n                    // the AssignmentStatement must be for an existing bean that does not yet have a corresponding\n                    // configuration object (this would happen if the bean is in the default objects map). Because\n                    // BeanConfiguration instances don't exist for default (already instantiated) beans,\n                    // we simulate a creation of one to satisfy this processors implementation:\n                    beanConfigurations.add(new BeanConfiguration(as));\n                }\n            }\n        }\n\n        public void execute() {\n\n            for( Statement statement : statements) {\n\n                statement.execute();\n\n                BeanConfiguration bd = statement.getBeanConfiguration();\n\n                if (bd.isExecuted()) { //bean is fully configured, no more statements to execute for it:\n\n                    if (bd.getBeanName().equals(EVENT_BUS_NAME)) {\n                        EventBus eventBus = (EventBus)bd.getBean();\n                        enableEvents(eventBus);\n                    }\n\n                    //ignore global 'shiro.' shortcut mechanism:\n                    if (!bd.isGlobalConfig()) {\n                        BeanEvent event = new ConfiguredBeanEvent(bd.getBeanName(), bd.getBean(),\n                                Collections.unmodifiableMap(objects));\n                        eventBus.publish(event);\n                    }\n                }\n            }\n        }\n    }\n\n    private class BeanConfiguration {\n\n        private final InstantiationStatement instantiationStatement;\n        private final List<AssignmentStatement> assignments = new ArrayList<AssignmentStatement>();\n        private final String beanName;\n        private Object bean;\n\n        private BeanConfiguration(InstantiationStatement statement) {\n            statement.setBeanConfiguration(this);\n            this.instantiationStatement = statement;\n            this.beanName = statement.lhs;\n        }\n\n        private BeanConfiguration(AssignmentStatement as) {\n            this.instantiationStatement = null;\n            this.beanName = as.getRootBeanName();\n            add(as);\n        }\n\n        public String getBeanName() {\n            return this.beanName;\n        }\n\n        public boolean isGlobalConfig() { //BeanConfiguration instance representing the global 'shiro.' properties\n            // (we should remove this concept).\n            return GLOBAL_PROPERTY_PREFIX.equals(getBeanName());\n        }\n\n        public void add(AssignmentStatement as) {\n            as.setBeanConfiguration(this);\n            assignments.add(as);\n        }\n\n        /**\n         * When this configuration is parsed sufficiently to create (or find) an actual bean instance, that instance\n         * will be associated with its configuration by setting it via this method.\n         *\n         * @param bean the bean instantiated (or found) that corresponds to this BeanConfiguration instance.\n         */\n        public void setBean(Object bean) {\n            this.bean = bean;\n        }\n\n        public Object getBean() {\n            return this.bean;\n        }\n\n        /**\n         * Returns true if all configuration statements have been executed.\n         * @return true if all configuration statements have been executed.\n         */\n        public boolean isExecuted() {\n            if (instantiationStatement != null && !instantiationStatement.isExecuted()) {\n                return false;\n            }\n            for (AssignmentStatement as : assignments) {\n                if (!as.isExecuted()) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    private abstract class Statement {\n\n        protected final String lhs;\n        protected final String rhs;\n        protected Object bean;\n        private Object result;\n        private boolean executed;\n        private BeanConfiguration beanConfiguration;\n\n        private Statement(String lhs, String rhs) {\n            this.lhs = lhs;\n            this.rhs = rhs;\n            this.executed = false;\n        }\n\n        public void setBeanConfiguration(BeanConfiguration bd) {\n            this.beanConfiguration = bd;\n        }\n\n        public BeanConfiguration getBeanConfiguration() {\n            return this.beanConfiguration;\n        }\n\n        public Object execute() {\n            if (!isExecuted()) {\n                this.result = doExecute();\n                this.executed = true;\n            }\n            if (!getBeanConfiguration().isGlobalConfig()) {\n                Assert.notNull(this.bean, \"Implementation must set the root bean for which it executed.\");\n            }\n            return this.result;\n        }\n\n        public Object getBean() {\n            return this.bean;\n        }\n\n        protected void setBean(Object bean) {\n            this.bean = bean;\n            if (this.beanConfiguration.getBean() == null) {\n                this.beanConfiguration.setBean(bean);\n            }\n        }\n\n        public Object getResult() {\n            return result;\n        }\n\n        protected abstract Object doExecute();\n\n        public boolean isExecuted() {\n            return executed;\n        }\n    }\n\n    private class InstantiationStatement extends Statement {\n\n        private InstantiationStatement(String lhs, String rhs) {\n            super(lhs, rhs);\n        }\n\n        @Override\n        protected Object doExecute() {\n            createNewInstance(objects, this.lhs, this.rhs);\n            Object instantiated = objects.get(this.lhs);\n            setBean(instantiated);\n\n            BeanEvent event = new InstantiatedBeanEvent(this.lhs, instantiated, Collections.unmodifiableMap(objects));\n            eventBus.publish(event);\n\n            return instantiated;\n        }\n    }\n\n    private class AssignmentStatement extends Statement {\n\n        private final String rootBeanName;\n\n        private AssignmentStatement(String lhs, String rhs) {\n            super(lhs, rhs);\n            int index = lhs.indexOf('.');\n            this.rootBeanName = lhs.substring(0, index);\n        }\n\n        @Override\n        protected Object doExecute() {\n            applyProperty(lhs, rhs, objects);\n            Object bean = objects.get(this.rootBeanName);\n            setBean(bean);\n            return null;\n        }\n\n        public String getRootBeanName() {\n            return this.rootBeanName;\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.config;\n\nimport org.apache.commons.beanutils.BeanUtils;\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.shiro.codec.Base64;\nimport org.apache.shiro.codec.Hex;\nimport org.apache.shiro.config.event.*;\nimport org.apache.shiro.util.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.beans.PropertyDescriptor;\nimport java.util.*;\n\n\n/**\n * Object builder that uses reflection and Apache Commons BeanUtils to build objects given a\n * map of \"property values\".  Typically these come from the Shiro INI configuration and are used\n * to construct or modify the SecurityManager, its dependencies, and web-based security filters.\n * <p/>\n * Recognizes {@link Factory} implementations and will call\n * {@link org.apache.shiro.util.Factory#getInstance() getInstance} to satisfy any reference to this bean.\n *\n * @since 0.9\n */\npublic class ReflectionBuilder {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(ReflectionBuilder.class);\n\n    private static final String OBJECT_REFERENCE_BEGIN_TOKEN = \"$\";\n    private static final String ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN = \"\\\\$\";\n    private static final String GLOBAL_PROPERTY_PREFIX = \"shiro\";\n    private static final char MAP_KEY_VALUE_DELIMITER = ':';\n    private static final String HEX_BEGIN_TOKEN = \"0x\";\n    private static final String NULL_VALUE_TOKEN = \"null\";\n    private static final String EMPTY_STRING_VALUE_TOKEN = \"\\\"\\\"\";\n    private static final char STRING_VALUE_DELIMETER = '\"';\n    private static final char MAP_PROPERTY_BEGIN_TOKEN = '[';\n    private static final char MAP_PROPERTY_END_TOKEN = ']';\n\n    private final Map<String, Object> objects;\n    private final List<BeanListener> listeners = new ArrayList<BeanListener>();\n    private final BeanListener compositeListener = new BeanListener() {\n        public void onBeanEvent(BeanEvent beanEvent) {\n            for(BeanListener listener: listeners) {\n                listener.onBeanEvent(beanEvent);\n            }\n        }\n    };\n\n    public ReflectionBuilder() {\n        this.objects = new LinkedHashMap<String, Object>();\n    }\n\n    public ReflectionBuilder(Map<String, ?> defaults) {\n        this.objects = new LinkedHashMap<String, Object>();\n        if(!CollectionUtils.isEmpty(defaults)) {\n            this.objects.putAll(defaults);\n        }\n    }\n\n    public Map<String, ?> getObjects() {\n        return objects;\n    }\n\n    /**\n     * @deprecated Use of this method will break the event contract.  We recommend not using it.\n     * @param objects\n     */\n    @Deprecated\n    public void setObjects(Map<String, ?> objects) {\n        this.objects.clear();\n        if(!CollectionUtils.isEmpty(objects)) {\n            this.objects.putAll(objects);\n        }\n    }\n\n    public Object getBean(String id) {\n        return objects.get(id);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public <T> T getBean(String id, Class<T> requiredType) {\n        if (requiredType == null) {\n            throw new NullPointerException(\"requiredType argument cannot be null.\");\n        }\n        Object bean = getBean(id);\n        if (bean == null) {\n            return null;\n        }\n        if (!requiredType.isAssignableFrom(bean.getClass())) {\n            throw new IllegalStateException(\"Bean with id [\" + id + \"] is not of the required type [\" +\n                    requiredType.getName() + \"].\");\n        }\n        return (T) bean;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Map<String, ?> buildObjects(Map<String, String> kvPairs) {\n        if (kvPairs != null && !kvPairs.isEmpty()) {\n\n            // Separate key value pairs into object declarations and property assignment\n            // so that all objects can be created up front\n\n            //https://issues.apache.org/jira/browse/SHIRO-85 - need to use LinkedHashMaps here:\n            Map<String, String> instanceMap = new LinkedHashMap<String, String>();\n            Map<String, String> propertyMap = new LinkedHashMap<String, String>();\n\n            for (Map.Entry<String, String> entry : kvPairs.entrySet()) {\n                if (entry.getKey().indexOf('.') < 0 || entry.getKey().endsWith(\".class\")) {\n                    instanceMap.put(entry.getKey(), entry.getValue());\n                } else {\n                    propertyMap.put(entry.getKey(), entry.getValue());\n                }\n            }\n\n            // Create all instances\n            for (Map.Entry<String, String> entry : instanceMap.entrySet()) {\n                createNewInstance((Map<String, Object>) objects, entry.getKey(), entry.getValue());\n            }\n\n            // Set properties on listeners\n            Iterator<Map.Entry<String, String>> entryIterator = propertyMap.entrySet().iterator();\n            while(entryIterator.hasNext()) {\n                Map.Entry<String, String> entry = entryIterator.next();\n                if(isListenerProperty(entry.getKey())) {\n                    applyProperty(entry.getKey(), entry.getValue(), objects);\n                    entryIterator.remove();\n                }\n            }\n\n            Map<String, Object> immutableObjects = Collections.unmodifiableMap(objects);\n\n            // Add listeners to listener set, notifying events on them as we go - order is important here\n            for(Map.Entry<String, ?> entry: objects.entrySet()) {\n                if(entry.getValue() instanceof BeanListener) {\n                    compositeListener.onBeanEvent(new ConfiguredBeanEvent(entry.getKey(), entry.getValue(), immutableObjects));\n                    listeners.add((BeanListener) entry.getValue());\n                }\n            }\n\n            // notify instantiated event on non-listeners\n            for(Map.Entry<String, ?> entry: objects.entrySet()) {\n                if(!(entry.getValue() instanceof BeanListener)) {\n                    compositeListener.onBeanEvent(new InstantiatedBeanEvent(entry.getKey(), entry.getValue(), immutableObjects));\n                }\n            }\n\n            // Set all properties\n            for (Map.Entry<String, String> entry : propertyMap.entrySet()) {\n                applyProperty(entry.getKey(), entry.getValue(), objects);\n            }\n\n            for(Map.Entry<String, ?> entry: objects.entrySet()) {\n                if(!(entry.getValue() instanceof BeanListener)) {\n                    compositeListener.onBeanEvent(new ConfiguredBeanEvent(entry.getKey(), entry.getValue(), immutableObjects));\n                }\n            }\n        }\n\n        return objects;\n    }\n\n    public void destroy() {\n        final Map<String, Object> immutableObjects = Collections.unmodifiableMap(objects);\n        for(Map.Entry<String, ?> entry: objects.entrySet()) {\n            compositeListener.onBeanEvent(new DestroyedBeanEvent(entry.getKey(), entry.getValue(), immutableObjects));\n        }\n    }\n\n    private boolean isListenerProperty(String key) {\n        int index = key.indexOf('.');\n\n        if (index >= 0) {\n            String name = key.substring(0, index);\n\n            return objects.containsKey(name) && objects.get(name) instanceof BeanListener;\n        } else {\n            throw new IllegalArgumentException(\"All property keys must contain a '.' character. \" +\n                    \"(e.g. myBean.property = value)  These should already be separated out by buildObjects().\");\n        }\n    }\n\n    protected void createNewInstance(Map<String, Object> objects, String name, String value) {\n\n        Object currentInstance = objects.get(name);\n        if (currentInstance != null) {\n            log.info(\"An instance with name '{}' already exists.  \" +\n                    \"Redefining this object as a new instance of type {}\", name, value);\n        }\n\n        Object instance;//name with no property, assume right hand side of equals sign is the class name:\n        try {\n            instance = ClassUtils.newInstance(value);\n            if (instance instanceof Nameable) {\n                ((Nameable) instance).setName(name);\n            }\n        } catch (Exception e) {\n            String msg = \"Unable to instantiate class [\" + value + \"] for object named '\" + name + \"'.  \" +\n                    \"Please ensure you've specified the fully qualified class name correctly.\";\n            throw new ConfigurationException(msg, e);\n        }\n        objects.put(name, instance);\n    }\n\n    protected void applyProperty(String key, String value, Map objects) {\n\n        int index = key.indexOf('.');\n\n        if (index >= 0) {\n            String name = key.substring(0, index);\n            String property = key.substring(index + 1, key.length());\n\n            if (GLOBAL_PROPERTY_PREFIX.equalsIgnoreCase(name)) {\n                applyGlobalProperty(objects, property, value);\n            } else {\n                applySingleProperty(objects, name, property, value);\n            }\n\n        } else {\n            throw new IllegalArgumentException(\"All property keys must contain a '.' character. \" +\n                    \"(e.g. myBean.property = value)  These should already be separated out by buildObjects().\");\n        }\n    }\n\n    protected void applyGlobalProperty(Map objects, String property, String value) {\n        for (Object instance : objects.values()) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(instance, property);\n                if (pd != null) {\n                    applyProperty(instance, property, value);\n                }\n            } catch (Exception e) {\n                String msg = \"Error retrieving property descriptor for instance \" +\n                        \"of type [\" + instance.getClass().getName() + \"] \" +\n                        \"while setting property [\" + property + \"]\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected void applySingleProperty(Map objects, String name, String property, String value) {\n        Object instance = objects.get(name);\n        if (property.equals(\"class\")) {\n            throw new IllegalArgumentException(\"Property keys should not contain 'class' properties since these \" +\n                    \"should already be separated out by buildObjects().\");\n\n        } else if (instance == null) {\n            String msg = \"Configuration error.  Specified object [\" + name + \"] with property [\" +\n                    property + \"] without first defining that object's class.  Please first \" +\n                    \"specify the class property first, e.g. myObject = fully_qualified_class_name \" +\n                    \"and then define additional properties.\";\n            throw new IllegalArgumentException(msg);\n\n        } else {\n            applyProperty(instance, property, value);\n        }\n    }\n\n    protected boolean isReference(String value) {\n        return value != null && value.startsWith(OBJECT_REFERENCE_BEGIN_TOKEN);\n    }\n\n    protected String getId(String referenceToken) {\n        return referenceToken.substring(OBJECT_REFERENCE_BEGIN_TOKEN.length());\n    }\n\n    protected Object getReferencedObject(String id) {\n        Object o = objects != null && !objects.isEmpty() ? objects.get(id) : null;\n        if (o == null) {\n            String msg = \"The object with id [\" + id + \"] has not yet been defined and therefore cannot be \" +\n                    \"referenced.  Please ensure objects are defined in the order in which they should be \" +\n                    \"created and made available for future reference.\";\n            throw new UnresolveableReferenceException(msg);\n        }\n        return o;\n    }\n\n    protected String unescapeIfNecessary(String value) {\n        if (value != null && value.startsWith(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN)) {\n            return value.substring(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN.length() - 1);\n        }\n        return value;\n    }\n\n    protected Object resolveReference(String reference) {\n        String id = getId(reference);\n        log.debug(\"Encountered object reference '{}'.  Looking up object with id '{}'\", reference, id);\n        final Object referencedObject = getReferencedObject(id);\n        if (referencedObject instanceof Factory) {\n            return ((Factory) referencedObject).getInstance();\n        }\n        return referencedObject;\n    }\n\n    protected boolean isTypedProperty(Object object, String propertyName, Class clazz) {\n        if (clazz == null) {\n            throw new NullPointerException(\"type (class) argument cannot be null.\");\n        }\n        try {\n            PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(object, propertyName);\n            if (descriptor == null) {\n                String msg = \"Property '\" + propertyName + \"' does not exist for object of \" +\n                        \"type \" + object.getClass().getName() + \".\";\n                throw new ConfigurationException(msg);\n            }\n            Class propertyClazz = descriptor.getPropertyType();\n            return clazz.isAssignableFrom(propertyClazz);\n        } catch (ConfigurationException ce) {\n            //let it propagate:\n            throw ce;\n        } catch (Exception e) {\n            String msg = \"Unable to determine if property [\" + propertyName + \"] represents a \" + clazz.getName();\n            throw new ConfigurationException(msg, e);\n        }\n    }\n\n    protected Set<?> toSet(String sValue) {\n        String[] tokens = StringUtils.split(sValue);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n        Set<String> setTokens = new LinkedHashSet<String>(Arrays.asList(tokens));\n\n        //now convert into correct values and/or references:\n        Set<Object> values = new LinkedHashSet<Object>(setTokens.size());\n        for (String token : setTokens) {\n            Object value = resolveValue(token);\n            values.add(value);\n        }\n        return values;\n    }\n\n    protected Map<?, ?> toMap(String sValue) {\n        String[] tokens = StringUtils.split(sValue, StringUtils.DEFAULT_DELIMITER_CHAR,\n                StringUtils.DEFAULT_QUOTE_CHAR, StringUtils.DEFAULT_QUOTE_CHAR, true, true);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n\n        Map<String, String> mapTokens = new LinkedHashMap<String, String>(tokens.length);\n        for (String token : tokens) {\n            String[] kvPair = StringUtils.split(token, MAP_KEY_VALUE_DELIMITER);\n            if (kvPair == null || kvPair.length != 2) {\n                String msg = \"Map property value [\" + sValue + \"] contained key-value pair token [\" +\n                        token + \"] that does not properly split to a single key and pair.  This must be the \" +\n                        \"case for all map entries.\";\n                throw new ConfigurationException(msg);\n            }\n            mapTokens.put(kvPair[0], kvPair[1]);\n        }\n\n        //now convert into correct values and/or references:\n        Map<Object, Object> map = new LinkedHashMap<Object, Object>(mapTokens.size());\n        for (Map.Entry<String, String> entry : mapTokens.entrySet()) {\n            Object key = resolveValue(entry.getKey());\n            Object value = resolveValue(entry.getValue());\n            map.put(key, value);\n        }\n        return map;\n    }\n\n\n    protected List<?> toList(String sValue) {\n        String[] tokens = StringUtils.split(sValue);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n\n        //now convert into correct values and/or references:\n        List<Object> values = new ArrayList<Object>(tokens.length);\n        for (String token : tokens) {\n            Object value = resolveValue(token);\n            values.add(value);\n        }\n        return values;\n    }\n\n    protected byte[] toBytes(String sValue) {\n        if (sValue == null) {\n            return null;\n        }\n        byte[] bytes;\n        if (sValue.startsWith(HEX_BEGIN_TOKEN)) {\n            String hex = sValue.substring(HEX_BEGIN_TOKEN.length());\n            bytes = Hex.decode(hex);\n        } else {\n            //assume base64 encoded:\n            bytes = Base64.decode(sValue);\n        }\n        return bytes;\n    }\n\n    protected Object resolveValue(String stringValue) {\n        Object value;\n        if (isReference(stringValue)) {\n            value = resolveReference(stringValue);\n        } else {\n            value = unescapeIfNecessary(stringValue);\n        }\n        return value;\n    }\n\n    protected String checkForNullOrEmptyLiteral(String stringValue) {\n        if (stringValue == null) {\n            return null;\n        }\n        //check if the value is the actual literal string 'null' (expected to be wrapped in quotes):\n        if (stringValue.equals(\"\\\"null\\\"\")) {\n            return NULL_VALUE_TOKEN;\n        }\n        //or the actual literal string of two quotes '\"\"' (expected to be wrapped in quotes):\n        else if (stringValue.equals(\"\\\"\\\"\\\"\\\"\")) {\n            return EMPTY_STRING_VALUE_TOKEN;\n        } else {\n            return stringValue;\n        }\n    }\n    \n    protected void applyProperty(Object object, String propertyPath, Object value) {\n\n        int mapBegin = propertyPath.indexOf(MAP_PROPERTY_BEGIN_TOKEN);\n        int mapEnd = -1;\n        String mapPropertyPath = null;\n        String keyString = null;\n\n        String remaining = null;\n        \n        if (mapBegin >= 0) {\n            //a map is being referenced in the overall property path.  Find just the map's path:\n            mapPropertyPath = propertyPath.substring(0, mapBegin);\n            //find the end of the map reference:\n            mapEnd = propertyPath.indexOf(MAP_PROPERTY_END_TOKEN, mapBegin);\n            //find the token in between the [ and the ] (the map/array key or index):\n            keyString = propertyPath.substring(mapBegin+1, mapEnd);\n\n            //find out if there is more path reference to follow.  If not, we're at a terminal of the OGNL expression\n            if (propertyPath.length() > (mapEnd+1)) {\n                remaining = propertyPath.substring(mapEnd+1);\n                if (remaining.startsWith(\".\")) {\n                    remaining = StringUtils.clean(remaining.substring(1));\n                }\n            }\n        }\n        \n        if (remaining == null) {\n            //we've terminated the OGNL expression.  Check to see if we're assigning a property or a map entry:\n            if (keyString == null) {\n                //not a map or array value assignment - assign the property directly:\n                setProperty(object, propertyPath, value);\n            } else {\n                //we're assigning a map or array entry.  Check to see which we should call:\n                if (isTypedProperty(object, mapPropertyPath, Map.class)) {\n                    Map map = (Map)getProperty(object, mapPropertyPath);\n                    Object mapKey = resolveValue(keyString);\n                    //noinspection unchecked\n                    map.put(mapKey, value);\n                } else {\n                    //must be an array property.  Convert the key string to an index:\n                    int index = Integer.valueOf(keyString);\n                    setIndexedProperty(object, mapPropertyPath, index, value);\n                }\n            }\n        } else {\n            //property is being referenced as part of a nested path.  Find the referenced map/array entry and\n            //recursively call this method with the remaining property path\n            Object referencedValue = null;\n            if (isTypedProperty(object, mapPropertyPath, Map.class)) {\n                Map map = (Map)getProperty(object, mapPropertyPath);\n                Object mapKey = resolveValue(keyString);\n                referencedValue = map.get(mapKey);\n            } else {\n                //must be an array property:\n                int index = Integer.valueOf(keyString);\n                referencedValue = getIndexedProperty(object, mapPropertyPath, index);\n            }\n\n            if (referencedValue == null) {\n                throw new ConfigurationException(\"Referenced map/array value '\" + mapPropertyPath + \"[\" +\n                keyString + \"]' does not exist.\");\n            }\n\n            applyProperty(referencedValue, remaining, value);\n        }\n    }\n    \n    private void setProperty(Object object, String propertyPath, Object value) {\n        try {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Applying property [{}] value [{}] on object of type [{}]\",\n                        new Object[]{propertyPath, value, object.getClass().getName()});\n            }\n            BeanUtils.setProperty(object, propertyPath, value);\n        } catch (Exception e) {\n            String msg = \"Unable to set property '\" + propertyPath + \"' with value [\" + value + \"] on object \" +\n                    \"of type \" + (object != null ? object.getClass().getName() : null) + \".  If \" +\n                    \"'\" + value + \"' is a reference to another (previously defined) object, prefix it with \" +\n                    \"'\" + OBJECT_REFERENCE_BEGIN_TOKEN + \"' to indicate that the referenced \" +\n                    \"object should be used as the actual value.  \" +\n                    \"For example, \" + OBJECT_REFERENCE_BEGIN_TOKEN + value;\n            throw new ConfigurationException(msg, e);\n        }\n    }\n    \n    private Object getProperty(Object object, String propertyPath) {\n        try {\n            return PropertyUtils.getProperty(object, propertyPath);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Unable to access property '\" + propertyPath + \"'\", e);\n        }\n    }\n    \n    private void setIndexedProperty(Object object, String propertyPath, int index, Object value) {\n        try {\n            PropertyUtils.setIndexedProperty(object, propertyPath, index, value);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Unable to set array property '\" + propertyPath + \"'\", e);\n        }\n    }\n    \n    private Object getIndexedProperty(Object object, String propertyPath, int index) {\n        try {\n            return PropertyUtils.getIndexedProperty(object, propertyPath, index);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Unable to acquire array property '\" + propertyPath + \"'\", e);\n        }\n    }\n    \n    protected boolean isIndexedPropertyAssignment(String propertyPath) {\n        return propertyPath.endsWith(\"\" + MAP_PROPERTY_END_TOKEN);\n    }\n\n    protected void applyProperty(Object object, String propertyName, String stringValue) {\n\n        Object value;\n\n        if (NULL_VALUE_TOKEN.equals(stringValue)) {\n            value = null;\n        } else if (EMPTY_STRING_VALUE_TOKEN.equals(stringValue)) {\n            value = StringUtils.EMPTY_STRING;\n        } else if (isIndexedPropertyAssignment(propertyName)) {\n            String checked = checkForNullOrEmptyLiteral(stringValue);\n            value = resolveValue(checked);\n        } else if (isTypedProperty(object, propertyName, Set.class)) {\n            value = toSet(stringValue);\n        } else if (isTypedProperty(object, propertyName, Map.class)) {\n            value = toMap(stringValue);\n        } else if (isTypedProperty(object, propertyName, List.class) ||\n                isTypedProperty(object, propertyName, Collection.class)) {\n            value = toList(stringValue);\n        } else if (isTypedProperty(object, propertyName, byte[].class)) {\n            value = toBytes(stringValue);\n        } else if (isTypedProperty(object, propertyName, ByteSource.class)) {\n            byte[] bytes = toBytes(stringValue);\n            value = ByteSource.Util.bytes(bytes);\n        } else {\n            String checked = checkForNullOrEmptyLiteral(stringValue);\n            value = resolveValue(checked);\n        }\n\n        applyProperty(object, propertyName, value);\n    }\n\n}\n","lineNo":217}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.subject;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.config.Ini;\nimport org.apache.shiro.config.IniSecurityManagerFactory;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.subject.support.DelegatingSubject;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.util.LifecycleUtils;\nimport org.apache.shiro.util.ThreadContext;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.Serializable;\nimport java.util.concurrent.Callable;\n\nimport static org.easymock.EasyMock.createNiceMock;\nimport static org.junit.Assert.*;\n\n\n/**\n * @since Aug 1, 2008 2:11:17 PM\n */\npublic class DelegatingSubjectTest {\n\n    @Before\n    public void setup() {\n        ThreadContext.remove();\n    }\n\n    @After\n    public void tearDown() {\n        ThreadContext.remove();\n    }\n\n    @Test\n    public void testSessionStopThenStart() {\n        String key = \"testKey\";\n        String value = \"testValue\";\n        DefaultSecurityManager sm = new DefaultSecurityManager();\n\n        DelegatingSubject subject = new DelegatingSubject(sm);\n\n        Session session = subject.getSession();\n        session.setAttribute(key, value);\n        assertTrue(session.getAttribute(key).equals(value));\n        Serializable firstSessionId = session.getId();\n        assertNotNull(firstSessionId);\n\n        session.stop();\n\n        session = subject.getSession();\n        assertNotNull(session);\n        assertNull(session.getAttribute(key));\n        Serializable secondSessionId = session.getId();\n        assertNotNull(secondSessionId);\n        assertFalse(firstSessionId.equals(secondSessionId));\n\n        subject.logout();\n\n        sm.destroy();\n    }\n\n    @Test\n    public void testExecuteCallable() {\n\n        String username = \"jsmith\";\n\n        SecurityManager securityManager = createNiceMock(SecurityManager.class);\n        PrincipalCollection identity = new SimplePrincipalCollection(username, \"testRealm\");\n        final Subject sourceSubject = new DelegatingSubject(identity, true, null, null, securityManager);\n\n        assertNull(ThreadContext.getSubject());\n        assertNull(ThreadContext.getSecurityManager());\n\n        Callable<String> callable = new Callable<String>() {\n            public String call() throws Exception {\n                Subject callingSubject = SecurityUtils.getSubject();\n                assertNotNull(callingSubject);\n                assertNotNull(SecurityUtils.getSecurityManager());\n                assertEquals(callingSubject, sourceSubject);\n                return \"Hello \" + callingSubject.getPrincipal();\n            }\n        };\n        String response = sourceSubject.execute(callable);\n\n        assertNotNull(response);\n        assertEquals(\"Hello \" + username, response);\n\n        assertNull(ThreadContext.getSubject());\n        assertNull(ThreadContext.getSecurityManager());\n    }\n\n    @Test\n    public void testExecuteRunnable() {\n\n        String username = \"jsmith\";\n\n        SecurityManager securityManager = createNiceMock(SecurityManager.class);\n        PrincipalCollection identity = new SimplePrincipalCollection(username, \"testRealm\");\n        final Subject sourceSubject = new DelegatingSubject(identity, true, null, null, securityManager);\n\n        assertNull(ThreadContext.getSubject());\n        assertNull(ThreadContext.getSecurityManager());\n\n        Runnable runnable = new Runnable() {\n            public void run() {\n                Subject callingSubject = SecurityUtils.getSubject();\n                assertNotNull(callingSubject);\n                assertNotNull(SecurityUtils.getSecurityManager());\n                assertEquals(callingSubject, sourceSubject);\n            }\n        };\n        sourceSubject.execute(runnable);\n\n        assertNull(ThreadContext.getSubject());\n        assertNull(ThreadContext.getSecurityManager());\n    }\n\n    @Test\n    public void testRunAs() {\n\n        Ini ini = new Ini();\n        Ini.Section users = ini.addSection(\"users\");\n        users.put(\"user1\", \"user1,role1\");\n        users.put(\"user2\", \"user2,role2\");\n        users.put(\"user3\", \"user3,role3\");\n        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(ini);\n        SecurityManager sm = factory.getInstance();\n\n        //login as user1\n        Subject subject = new Subject.Builder(sm).buildSubject();\n        subject.login(new UsernamePasswordToken(\"user1\", \"user1\"));\n\n        assertFalse(subject.isRunAs());\n        assertEquals(\"user1\", subject.getPrincipal());\n        assertTrue(subject.hasRole(\"role1\"));\n        assertFalse(subject.hasRole(\"role2\"));\n        assertFalse(subject.hasRole(\"role3\"));\n        assertNull(subject.getPreviousPrincipals()); //no previous principals since we haven't called runAs yet\n\n        //runAs user2:\n        subject.runAs(new SimplePrincipalCollection(\"user2\", IniSecurityManagerFactory.INI_REALM_NAME));\n        assertTrue(subject.isRunAs());\n        assertEquals(\"user2\", subject.getPrincipal());\n        assertTrue(subject.hasRole(\"role2\"));\n        assertFalse(subject.hasRole(\"role1\"));\n        assertFalse(subject.hasRole(\"role3\"));\n\n        //assert we still have the previous (user1) principals:\n        PrincipalCollection previous = subject.getPreviousPrincipals();\n        assertFalse(CollectionUtils.isEmpty(previous));\n        assertTrue(previous.getPrimaryPrincipal().equals(\"user1\"));\n\n        //test the stack functionality:  While as user2, run as user3:\n        subject.runAs(new SimplePrincipalCollection(\"user3\", IniSecurityManagerFactory.INI_REALM_NAME));\n        assertTrue(subject.isRunAs());\n        assertEquals(\"user3\", subject.getPrincipal());\n        assertTrue(subject.hasRole(\"role3\"));\n        assertFalse(subject.hasRole(\"role1\"));\n        assertFalse(subject.hasRole(\"role2\"));\n\n        //assert we still have the previous (user2) principals in the stack:\n        previous = subject.getPreviousPrincipals();\n        assertFalse(CollectionUtils.isEmpty(previous));\n        assertTrue(previous.getPrimaryPrincipal().equals(\"user2\"));\n\n        //drop down to user2:\n        subject.releaseRunAs();\n\n        //assert still run as:\n        assertTrue(subject.isRunAs());\n        assertEquals(\"user2\", subject.getPrincipal());\n        assertTrue(subject.hasRole(\"role2\"));\n        assertFalse(subject.hasRole(\"role1\"));\n        assertFalse(subject.hasRole(\"role3\"));\n\n        //assert we still have the previous (user1) principals:\n        previous = subject.getPreviousPrincipals();\n        assertFalse(CollectionUtils.isEmpty(previous));\n        assertTrue(previous.getPrimaryPrincipal().equals(\"user1\"));\n\n        //drop down to original user1:\n        subject.releaseRunAs();\n\n        //assert we're no longer runAs:\n        assertFalse(subject.isRunAs());\n        assertEquals(\"user1\", subject.getPrincipal());\n        assertTrue(subject.hasRole(\"role1\"));\n        assertFalse(subject.hasRole(\"role2\"));\n        assertFalse(subject.hasRole(\"role3\"));\n        assertNull(subject.getPreviousPrincipals()); //no previous principals in orig state\n\n        subject.logout();\n\n        LifecycleUtils.destroy(sm);\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.subject;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.config.Ini;\nimport org.apache.shiro.config.IniSecurityManagerFactory;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.subject.support.DelegatingSubject;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.util.LifecycleUtils;\nimport org.apache.shiro.util.ThreadContext;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.Serializable;\nimport java.util.concurrent.Callable;\n\nimport static org.easymock.EasyMock.createNiceMock;\nimport static org.junit.Assert.*;\n\n\n/**\n * @since Aug 1, 2008 2:11:17 PM\n */\npublic class DelegatingSubjectTest {\n\n    @Before\n    public void setup() {\n        ThreadContext.remove();\n    }\n\n    @After\n    public void tearDown() {\n        ThreadContext.remove();\n    }\n\n    @Test\n    public void testSessionStopThenStart() {\n        String key = \"testKey\";\n        String value = \"testValue\";\n        DefaultSecurityManager sm = new DefaultSecurityManager();\n\n        DelegatingSubject subject = new DelegatingSubject(sm);\n\n        Session session = subject.getSession();\n        session.setAttribute(key, value);\n        assertTrue(session.getAttribute(key).equals(value));\n        Serializable firstSessionId = session.getId();\n        assertNotNull(firstSessionId);\n\n        session.stop();\n\n        session = subject.getSession();\n        assertNotNull(session);\n        assertNull(session.getAttribute(key));\n        Serializable secondSessionId = session.getId();\n        assertNotNull(secondSessionId);\n        assertFalse(firstSessionId.equals(secondSessionId));\n\n        subject.logout();\n\n        sm.destroy();\n    }\n\n    @Test\n    public void testExecuteCallable() {\n\n        String username = \"jsmith\";\n\n        SecurityManager securityManager = createNiceMock(SecurityManager.class);\n        PrincipalCollection identity = new SimplePrincipalCollection(username, \"testRealm\");\n        final Subject sourceSubject = new DelegatingSubject(identity, true, null, null, securityManager);\n\n        assertNull(ThreadContext.getSubject());\n        assertNull(ThreadContext.getSecurityManager());\n\n        Callable<String> callable = new Callable<String>() {\n            public String call() throws Exception {\n                Subject callingSubject = SecurityUtils.getSubject();\n                assertNotNull(callingSubject);\n                assertNotNull(SecurityUtils.getSecurityManager());\n                assertEquals(callingSubject, sourceSubject);\n                return \"Hello \" + callingSubject.getPrincipal();\n            }\n        };\n        String response = sourceSubject.execute(callable);\n\n        assertNotNull(response);\n        assertEquals(\"Hello \" + username, response);\n\n        assertNull(ThreadContext.getSubject());\n        assertNull(ThreadContext.getSecurityManager());\n    }\n\n    @Test\n    public void testExecuteRunnable() {\n\n        String username = \"jsmith\";\n\n        SecurityManager securityManager = createNiceMock(SecurityManager.class);\n        PrincipalCollection identity = new SimplePrincipalCollection(username, \"testRealm\");\n        final Subject sourceSubject = new DelegatingSubject(identity, true, null, null, securityManager);\n\n        assertNull(ThreadContext.getSubject());\n        assertNull(ThreadContext.getSecurityManager());\n\n        Runnable runnable = new Runnable() {\n            public void run() {\n                Subject callingSubject = SecurityUtils.getSubject();\n                assertNotNull(callingSubject);\n                assertNotNull(SecurityUtils.getSecurityManager());\n                assertEquals(callingSubject, sourceSubject);\n            }\n        };\n        sourceSubject.execute(runnable);\n\n        assertNull(ThreadContext.getSubject());\n        assertNull(ThreadContext.getSecurityManager());\n    }\n\n    /**\n     * TODO: This test fails on JDK 1.5 from the command line but not from within the IDE\n     * and I have no idea why at the moment - Les - 29 Oct 2010.\n     */\n    @Test\n    public void testRunAs() {\n\n        Ini ini = new Ini();\n        Ini.Section users = ini.addSection(\"users\");\n        users.put(\"user1\", \"user1,role1\");\n        users.put(\"user2\", \"user2,role2\");\n        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(ini);\n        SecurityManager sm = factory.getInstance();\n\n        Subject subject = new Subject.Builder(sm).buildSubject();\n        subject.login(new UsernamePasswordToken(\"user1\", \"user1\"));\n\n        assertTrue(subject.getPrincipal().equals(\"user1\"));\n        assertTrue(subject.hasRole(\"role1\"));\n        assertFalse(subject.isRunAs());\n        assertNull(subject.getPreviousPrincipals());\n\n        subject.runAs(new SimplePrincipalCollection(\"user2\", IniSecurityManagerFactory.INI_REALM_NAME));\n\n        assertFalse(subject.getPrincipal().equals(\"user1\"));\n        assertFalse(subject.hasRole(\"role1\"));\n        assertTrue(subject.getPrincipal().equals(\"user2\"));\n        assertTrue(subject.hasRole(\"role2\"));\n        assertTrue(subject.isRunAs());\n        assertFalse(CollectionUtils.isEmpty(subject.getPreviousPrincipals()));\n        assertTrue(subject.getPreviousPrincipals().getPrimaryPrincipal().equals(\"user1\"));\n\n        subject.releaseRunAs();\n        assertTrue(subject.getPrincipal().equals(\"user1\"));\n        assertTrue(subject.hasRole(\"role1\"));\n        assertFalse(subject.isRunAs());\n        assertNull(subject.getPreviousPrincipals());\n\n        subject.logout();\n        LifecycleUtils.destroy(sm);\n    }\n}\n","lineNo":173}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.config;\n\nimport org.apache.shiro.config.Ini;\nimport org.apache.shiro.config.IniFactorySupport;\nimport org.apache.shiro.config.IniSecurityManagerFactory;\nimport org.apache.shiro.config.ReflectionBuilder;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.util.Factory;\nimport org.apache.shiro.web.filter.mgt.FilterChainManager;\nimport org.apache.shiro.web.filter.mgt.FilterChainResolver;\nimport org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterConfig;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A {@link Factory} that creates {@link FilterChainResolver} instances based on {@link Ini} configuration.\n *\n * @since 1.0\n */\npublic class IniFilterChainResolverFactory extends IniFactorySupport<FilterChainResolver> {\n\n    public static final String FILTERS = \"filters\";\n    public static final String URLS = \"urls\";\n\n    private static transient final Logger log = LoggerFactory.getLogger(IniFilterChainResolverFactory.class);\n\n    private FilterConfig filterConfig;\n\n    private Map<String, ?> defaultBeans;\n\n    public IniFilterChainResolverFactory() {\n        super();\n    }\n\n    public IniFilterChainResolverFactory(Ini ini) {\n        super(ini);\n    }\n\n    public IniFilterChainResolverFactory(Ini ini, Map<String, ?> defaultBeans) {\n        this(ini);\n        this.defaultBeans = defaultBeans;\n    }\n\n    public FilterConfig getFilterConfig() {\n        return filterConfig;\n    }\n\n    public void setFilterConfig(FilterConfig filterConfig) {\n        this.filterConfig = filterConfig;\n    }\n\n    protected FilterChainResolver createInstance(Ini ini) {\n        FilterChainResolver filterChainResolver = createDefaultInstance();\n        if (filterChainResolver instanceof PathMatchingFilterChainResolver) {\n            PathMatchingFilterChainResolver resolver = (PathMatchingFilterChainResolver) filterChainResolver;\n            FilterChainManager manager = resolver.getFilterChainManager();\n            buildChains(manager, ini);\n        }\n        return filterChainResolver;\n    }\n\n    protected FilterChainResolver createDefaultInstance() {\n        FilterConfig filterConfig = getFilterConfig();\n        if (filterConfig != null) {\n            return new PathMatchingFilterChainResolver(filterConfig);\n        } else {\n            return new PathMatchingFilterChainResolver();\n        }\n    }\n\n    protected void buildChains(FilterChainManager manager, Ini ini) {\n        //filters section:\n        Ini.Section section = ini.getSection(FILTERS);\n\n        if (!CollectionUtils.isEmpty(section)) {\n            String msg = \"The [{}] section has been deprecated and will be removed in a future release!  Please \" +\n                    \"move all object configuration (filters and all other objects) to the [{}] section.\";\n            log.warn(msg, FILTERS, IniSecurityManagerFactory.MAIN_SECTION_NAME);\n        }\n\n        Map<String, Object> defaults = new LinkedHashMap<String, Object>();\n\n        Map<String, Filter> defaultFilters = manager.getFilters();\n\n        //now let's see if there are any object defaults in addition to the filters\n        //these can be used to configure the filters:\n        //create a Map of objects to use as the defaults:\n        if (!CollectionUtils.isEmpty(defaultFilters)) {\n            defaults.putAll(defaultFilters);\n        }\n        //User-provided objects must come _after_ the default filters - to allow the user-provided\n        //ones to override the default filters if necessary.\n        if (!CollectionUtils.isEmpty(this.defaultBeans)) {\n            defaults.putAll(this.defaultBeans);\n        }\n\n        Map<String, Filter> filters = getFilters(section, defaults);\n\n        //add the filters to the manager:\n        registerFilters(filters, manager);\n\n        //urls section:\n        section = ini.getSection(URLS);\n        createChains(section, manager);\n    }\n\n    protected void registerFilters(Map<String, Filter> filters, FilterChainManager manager) {\n        if (!CollectionUtils.isEmpty(filters)) {\n            boolean init = getFilterConfig() != null; //only call filter.init if there is a FilterConfig available\n            for (Map.Entry<String, Filter> entry : filters.entrySet()) {\n                String name = entry.getKey();\n                Filter filter = entry.getValue();\n                manager.addFilter(name, filter, init);\n            }\n        }\n    }\n\n    protected Map<String, Filter> getFilters(Map<String, String> section, Map<String, ?> defaults) {\n\n        Map<String, Filter> filters = extractFilters(defaults);\n\n        if (!CollectionUtils.isEmpty(section)) {\n            ReflectionBuilder builder = new ReflectionBuilder(defaults);\n            Map<String, ?> built = builder.buildObjects(section);\n            Map<String,Filter> sectionFilters = extractFilters(built);\n\n            if (CollectionUtils.isEmpty(filters)) {\n                filters = sectionFilters;\n            } else {\n                if (!CollectionUtils.isEmpty(sectionFilters)) {\n                    filters.putAll(sectionFilters);\n                }\n            }\n        }\n\n        return filters;\n    }\n\n    private Map<String, Filter> extractFilters(Map<String, ?> objects) {\n        if (CollectionUtils.isEmpty(objects)) {\n            return null;\n        }\n        Map<String, Filter> filterMap = new LinkedHashMap<String, Filter>();\n        for (Map.Entry<String, ?> entry : objects.entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            if (value instanceof Filter) {\n                filterMap.put(key, (Filter) value);\n            }\n        }\n        return filterMap;\n    }\n\n    protected void createChains(Map<String, String> urls, FilterChainManager manager) {\n        if (CollectionUtils.isEmpty(urls)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No urls to process.\");\n            }\n            return;\n        }\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Before url processing.\");\n        }\n\n        for (Map.Entry<String, String> entry : urls.entrySet()) {\n            String path = entry.getKey();\n            String value = entry.getValue();\n            manager.createChain(path, value);\n        }\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.config;\n\nimport org.apache.shiro.config.Ini;\nimport org.apache.shiro.config.IniFactorySupport;\nimport org.apache.shiro.config.IniSecurityManagerFactory;\nimport org.apache.shiro.config.ReflectionBuilder;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.util.Factory;\nimport org.apache.shiro.web.filter.mgt.FilterChainManager;\nimport org.apache.shiro.web.filter.mgt.FilterChainResolver;\nimport org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterConfig;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A {@link Factory} that creates {@link FilterChainResolver} instances based on {@link Ini} configuration.\n *\n * @since 1.0\n */\npublic class IniFilterChainResolverFactory extends IniFactorySupport<FilterChainResolver> {\n\n    public static final String FILTERS = \"filters\";\n    public static final String URLS = \"urls\";\n\n    private static transient final Logger log = LoggerFactory.getLogger(IniFilterChainResolverFactory.class);\n\n    private FilterConfig filterConfig;\n\n    private Map<String, ?> defaultBeans;\n\n    public IniFilterChainResolverFactory() {\n        super();\n    }\n\n    public IniFilterChainResolverFactory(Ini ini) {\n        super(ini);\n    }\n\n    public IniFilterChainResolverFactory(Ini ini, Map<String, ?> defaultBeans) {\n        this(ini);\n        this.defaultBeans = defaultBeans;\n    }\n\n    public FilterConfig getFilterConfig() {\n        return filterConfig;\n    }\n\n    public void setFilterConfig(FilterConfig filterConfig) {\n        this.filterConfig = filterConfig;\n    }\n\n    protected FilterChainResolver createInstance(Ini ini) {\n        FilterChainResolver filterChainResolver = createDefaultInstance();\n        if (filterChainResolver instanceof PathMatchingFilterChainResolver) {\n            PathMatchingFilterChainResolver resolver = (PathMatchingFilterChainResolver) filterChainResolver;\n            FilterChainManager manager = resolver.getFilterChainManager();\n            buildChains(manager, ini);\n        }\n        return filterChainResolver;\n    }\n\n    protected FilterChainResolver createDefaultInstance() {\n        FilterConfig filterConfig = getFilterConfig();\n        if (filterConfig != null) {\n            return new PathMatchingFilterChainResolver(filterConfig);\n        } else {\n            return new PathMatchingFilterChainResolver();\n        }\n    }\n\n    protected void buildChains(FilterChainManager manager, Ini ini) {\n        //filters section:\n        Ini.Section section = ini.getSection(FILTERS);\n\n        if (!CollectionUtils.isEmpty(section)) {\n            String msg = \"The [{}] section has been deprecated and will be removed in a future release!  Please \" +\n                    \"move all object configuration (filters and all other objects) to the [{}] section.\";\n            log.warn(msg, FILTERS, IniSecurityManagerFactory.MAIN_SECTION_NAME);\n        }\n\n        Map<String, Object> defaults = new LinkedHashMap<String, Object>();\n\n        Map<String, Filter> defaultFilters = manager.getFilters();\n\n        //now let's see if there are any object defaults in addition to the filters\n        //these can be used to configure the filters:\n        //create a Map of objects to use as the defaults:\n        if (!CollectionUtils.isEmpty(defaultFilters)) {\n            defaults.putAll(defaultFilters);\n        }\n        //User-provided objects must come _after_ the default filters - to allow the user-provided\n        //ones to override the default filters if necessary.\n        if (!CollectionUtils.isEmpty(this.defaultBeans)) {\n            defaults.putAll(this.defaultBeans);\n        }\n\n        Map<String, Filter> filters = getFilters(section, defaults);\n\n        //add the filters to the manager:\n        registerFilters(filters, manager);\n\n        //urls section:\n        section = ini.getSection(URLS);\n        createChains(section, manager);\n    }\n\n    protected void registerFilters(Map<String, Filter> filters, FilterChainManager manager) {\n        if (!CollectionUtils.isEmpty(filters)) {\n            boolean init = getFilterConfig() != null; //only call filter.init if there is a FilterConfig available\n            for (Map.Entry<String, Filter> entry : filters.entrySet()) {\n                String name = entry.getKey();\n                Filter filter = entry.getValue();\n                manager.addFilter(name, filter, init);\n            }\n        }\n    }\n\n    protected Map<String, Filter> getFilters(Map<String, String> section, Map<String, ?> defaults) {\n\n        Map<String, Filter> filters;\n\n        if (!CollectionUtils.isEmpty(section)) {\n            ReflectionBuilder builder = new ReflectionBuilder(defaults);\n            Map<String, ?> built = builder.buildObjects(section);\n            filters = extractFilters(built);\n        } else {\n            filters = extractFilters(defaults);\n        }\n\n        return filters;\n    }\n\n    private Map<String, Filter> extractFilters(Map<String, ?> objects) {\n        if (CollectionUtils.isEmpty(objects)) {\n            return null;\n        }\n        Map<String, Filter> filterMap = new LinkedHashMap<String, Filter>();\n        for (Map.Entry<String, ?> entry : objects.entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            if (value instanceof Filter) {\n                filterMap.put(key, (Filter) value);\n            }\n        }\n        return filterMap;\n    }\n\n    protected void createChains(Map<String, String> urls, FilterChainManager manager) {\n        if (CollectionUtils.isEmpty(urls)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No urls to process.\");\n            }\n            return;\n        }\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Before url processing.\");\n        }\n\n        for (Map.Entry<String, String> entry : urls.entrySet()) {\n            String path = entry.getKey();\n            String value = entry.getValue();\n            manager.createChain(path, value);\n        }\n    }\n}\n","lineNo":148}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.config;\n\nimport org.apache.commons.beanutils.BeanUtils;\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.shiro.codec.Base64;\nimport org.apache.shiro.codec.Hex;\nimport org.apache.shiro.util.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.beans.PropertyDescriptor;\nimport java.util.*;\n\n\n/**\n * Object builder that uses reflection and Apache Commons BeanUtils to build objects given a\n * map of \"property values\".  Typically these come from the Shiro INI configuration and are used\n * to construct or modify the SecurityManager, its dependencies, and web-based security filters.\n * <p/>\n * Recognizes {@link Factory} implementations and will call\n * {@link org.apache.shiro.util.Factory#getInstance() getInstance} to satisfy any reference to this bean.\n *\n * @since 0.9\n */\npublic class ReflectionBuilder {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(ReflectionBuilder.class);\n\n    private static final String OBJECT_REFERENCE_BEGIN_TOKEN = \"$\";\n    private static final String ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN = \"\\\\$\";\n    private static final String GLOBAL_PROPERTY_PREFIX = \"shiro\";\n    private static final char MAP_KEY_VALUE_DELIMITER = ':';\n    private static final String HEX_BEGIN_TOKEN = \"0x\";\n    private static final String NULL_VALUE_TOKEN = \"null\";\n    private static final String EMPTY_STRING_VALUE_TOKEN = \"\\\"\\\"\";\n    private static final char STRING_VALUE_DELIMETER = '\"';\n\n    private Map<String, ?> objects;\n\n    public ReflectionBuilder() {\n        this.objects = new LinkedHashMap<String, Object>();\n    }\n\n    public ReflectionBuilder(Map<String, ?> defaults) {\n        this.objects = CollectionUtils.isEmpty(defaults) ? new LinkedHashMap<String, Object>() : defaults;\n    }\n\n    public Map<String, ?> getObjects() {\n        return objects;\n    }\n\n    public void setObjects(Map<String, ?> objects) {\n        this.objects = CollectionUtils.isEmpty(objects) ? new LinkedHashMap<String, Object>() : objects;\n    }\n\n    public Object getBean(String id) {\n        return objects.get(id);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public <T> T getBean(String id, Class<T> requiredType) {\n        if (requiredType == null) {\n            throw new NullPointerException(\"requiredType argument cannot be null.\");\n        }\n        Object bean = getBean(id);\n        if (bean == null) {\n            return null;\n        }\n        if (!requiredType.isAssignableFrom(bean.getClass())) {\n            throw new IllegalStateException(\"Bean with id [\" + id + \"] is not of the required type [\" +\n                    requiredType.getName() + \"].\");\n        }\n        return (T) bean;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Map<String, ?> buildObjects(Map<String, String> kvPairs) {\n        if (kvPairs != null && !kvPairs.isEmpty()) {\n\n            // Separate key value pairs into object declarations and property assignment\n            // so that all objects can be created up front\n\n            //https://issues.apache.org/jira/browse/SHIRO-85 - need to use LinkedHashMaps here:\n            Map<String, String> instanceMap = new LinkedHashMap<String, String>();\n            Map<String, String> propertyMap = new LinkedHashMap<String, String>();\n\n            for (Map.Entry<String, String> entry : kvPairs.entrySet()) {\n                if (entry.getKey().indexOf('.') < 0 || entry.getKey().endsWith(\".class\")) {\n                    instanceMap.put(entry.getKey(), entry.getValue());\n                } else {\n                    propertyMap.put(entry.getKey(), entry.getValue());\n                }\n            }\n\n            // Create all instances\n            for (Map.Entry<String, String> entry : instanceMap.entrySet()) {\n                createNewInstance((Map<String, Object>) objects, entry.getKey(), entry.getValue());\n            }\n\n            // Set all properties\n            for (Map.Entry<String, String> entry : propertyMap.entrySet()) {\n                applyProperty(entry.getKey(), entry.getValue(), objects);\n            }\n        }\n\n        return objects;\n    }\n\n    protected void createNewInstance(Map<String, Object> objects, String name, String value) {\n\n        Object currentInstance = objects.get(name);\n        if (currentInstance != null) {\n            log.info(\"An instance with name '{}' already exists.  \" +\n                    \"Redefining this object as a new instance of type []\", name, value);\n        }\n\n        Object instance;//name with no property, assume right hand side of equals sign is the class name:\n        try {\n            instance = ClassUtils.newInstance(value);\n            if (instance instanceof Nameable) {\n                ((Nameable) instance).setName(name);\n            }\n        } catch (Exception e) {\n            String msg = \"Unable to instantiate class [\" + value + \"] for object named '\" + name + \"'.  \" +\n                    \"Please ensure you've specified the fully qualified class name correctly.\";\n            throw new ConfigurationException(msg, e);\n        }\n        objects.put(name, instance);\n    }\n\n    protected void applyProperty(String key, String value, Map objects) {\n\n        int index = key.indexOf('.');\n\n        if (index >= 0) {\n            String name = key.substring(0, index);\n            String property = key.substring(index + 1, key.length());\n\n            if (GLOBAL_PROPERTY_PREFIX.equalsIgnoreCase(name)) {\n                applyGlobalProperty(objects, property, value);\n            } else {\n                applySingleProperty(objects, name, property, value);\n            }\n\n        } else {\n            throw new IllegalArgumentException(\"All property keys must contain a '.' character. \" +\n                    \"(e.g. myBean.property = value)  These should already be separated out by buildObjects().\");\n        }\n    }\n\n    protected void applyGlobalProperty(Map objects, String property, String value) {\n        for (Object instance : objects.values()) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(instance, property);\n                if (pd != null) {\n                    applyProperty(instance, property, value);\n                }\n            } catch (Exception e) {\n                String msg = \"Error retrieving property descriptor for instance \" +\n                        \"of type [\" + instance.getClass().getName() + \"] \" +\n                        \"while setting property [\" + property + \"]\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected void applySingleProperty(Map objects, String name, String property, String value) {\n        Object instance = objects.get(name);\n        if (property.equals(\"class\")) {\n            throw new IllegalArgumentException(\"Property keys should not contain 'class' properties since these \" +\n                    \"should already be separated out by buildObjects().\");\n\n        } else if (instance == null) {\n            String msg = \"Configuration error.  Specified object [\" + name + \"] with property [\" +\n                    property + \"] without first defining that object's class.  Please first \" +\n                    \"specify the class property first, e.g. myObject = fully_qualified_class_name \" +\n                    \"and then define additional properties.\";\n            throw new IllegalArgumentException(msg);\n\n        } else {\n            applyProperty(instance, property, value);\n        }\n    }\n\n    protected boolean isReference(String value) {\n        return value != null && value.startsWith(OBJECT_REFERENCE_BEGIN_TOKEN);\n    }\n\n    protected String getId(String referenceToken) {\n        return referenceToken.substring(OBJECT_REFERENCE_BEGIN_TOKEN.length());\n    }\n\n    protected Object getReferencedObject(String id) {\n        Object o = objects != null && !objects.isEmpty() ? objects.get(id) : null;\n        if (o == null) {\n            String msg = \"The object with id [\" + id + \"] has not yet been defined and therefore cannot be \" +\n                    \"referenced.  Please ensure objects are defined in the order in which they should be \" +\n                    \"created and made available for future reference.\";\n            throw new UnresolveableReferenceException(msg);\n        }\n        return o;\n    }\n\n    protected String unescapeIfNecessary(String value) {\n        if (value != null && value.startsWith(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN)) {\n            return value.substring(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN.length() - 1);\n        }\n        return value;\n    }\n\n    protected Object resolveReference(String reference) {\n        String id = getId(reference);\n        log.debug(\"Encountered object reference '{}'.  Looking up object with id '{}'\", reference, id);\n        final Object referencedObject = getReferencedObject(id);\n        if (referencedObject instanceof Factory) {\n            return ((Factory) referencedObject).getInstance();\n        }\n        return referencedObject;\n    }\n\n    protected boolean isTypedProperty(Object object, String propertyName, Class clazz) {\n        if (clazz == null) {\n            throw new NullPointerException(\"type (class) argument cannot be null.\");\n        }\n        try {\n            PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(object, propertyName);\n            if (descriptor == null) {\n                String msg = \"Property '\" + propertyName + \"' does not exist for object of \" +\n                        \"type \" + object.getClass().getName() + \".\";\n                throw new ConfigurationException(msg);\n            }\n            Class propertyClazz = descriptor.getPropertyType();\n            return clazz.isAssignableFrom(propertyClazz);\n        } catch (ConfigurationException ce) {\n            //let it propagate:\n            throw ce;\n        } catch (Exception e) {\n            String msg = \"Unable to determine if property [\" + propertyName + \"] represents a \" + clazz.getName();\n            throw new ConfigurationException(msg, e);\n        }\n    }\n\n    protected Set<?> toSet(String sValue) {\n        String[] tokens = StringUtils.split(sValue);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n        Set<String> setTokens = new LinkedHashSet<String>(Arrays.asList(tokens));\n\n        //now convert into correct values and/or references:\n        Set<Object> values = new LinkedHashSet<Object>(setTokens.size());\n        for (String token : setTokens) {\n            Object value = resolveValue(token);\n            values.add(value);\n        }\n        return values;\n    }\n\n    protected Map<?, ?> toMap(String sValue) {\n        String[] tokens = StringUtils.split(sValue, StringUtils.DEFAULT_DELIMITER_CHAR,\n                StringUtils.DEFAULT_QUOTE_CHAR, StringUtils.DEFAULT_QUOTE_CHAR, true, true);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n\n        Map<String, String> mapTokens = new LinkedHashMap<String, String>(tokens.length);\n        for (String token : tokens) {\n            String[] kvPair = StringUtils.split(token, MAP_KEY_VALUE_DELIMITER);\n            if (kvPair == null || kvPair.length != 2) {\n                String msg = \"Map property value [\" + sValue + \"] contained key-value pair token [\" +\n                        token + \"] that does not properly split to a single key and pair.  This must be the \" +\n                        \"case for all map entries.\";\n                throw new ConfigurationException(msg);\n            }\n            mapTokens.put(kvPair[0], kvPair[1]);\n        }\n\n        //now convert into correct values and/or references:\n        Map<Object, Object> map = new LinkedHashMap<Object, Object>(mapTokens.size());\n        for (Map.Entry<String, String> entry : mapTokens.entrySet()) {\n            Object key = resolveValue(entry.getKey());\n            Object value = resolveValue(entry.getValue());\n            map.put(key, value);\n        }\n        return map;\n    }\n\n\n    protected List<?> toList(String sValue) {\n        String[] tokens = StringUtils.split(sValue);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n\n        //now convert into correct values and/or references:\n        List<Object> values = new ArrayList<Object>(tokens.length);\n        for (String token : tokens) {\n            Object value = resolveValue(token);\n            values.add(value);\n        }\n        return values;\n    }\n\n    protected byte[] toBytes(String sValue) {\n        if (sValue == null) {\n            return null;\n        }\n        byte[] bytes;\n        if (sValue.startsWith(HEX_BEGIN_TOKEN)) {\n            String hex = sValue.substring(HEX_BEGIN_TOKEN.length());\n            bytes = Hex.decode(hex);\n        } else {\n            //assume base64 encoded:\n            bytes = Base64.decode(sValue);\n        }\n        return bytes;\n    }\n\n    protected Object resolveValue(String stringValue) {\n        Object value;\n        if (isReference(stringValue)) {\n            value = resolveReference(stringValue);\n        } else {\n            value = unescapeIfNecessary(stringValue);\n        }\n        return value;\n    }\n\n    protected String checkForNullOrEmptyLiteral(String stringValue) {\n        if (stringValue == null) {\n            return null;\n        }\n        //check if the value is the actual literal string 'null' (expected to be wrapped in quotes):\n        if (stringValue.equals(\"\\\"null\\\"\")) {\n            return NULL_VALUE_TOKEN;\n        }\n        //or the actual literal string of two quotes '\"\"' (expected to be wrapped in quotes):\n        else if (stringValue.equals(\"\\\"\\\"\\\"\\\"\")) {\n            return EMPTY_STRING_VALUE_TOKEN;\n        } else {\n            return stringValue;\n        }\n    }\n\n    protected void applyProperty(Object object, String propertyName, String stringValue) {\n\n        Object value;\n\n        if (NULL_VALUE_TOKEN.equals(stringValue)) {\n            value = null;\n        } else if (EMPTY_STRING_VALUE_TOKEN.equals(stringValue)) {\n            value = StringUtils.EMPTY_STRING;\n        } else if (isTypedProperty(object, propertyName, Set.class)) {\n            value = toSet(stringValue);\n        } else if (isTypedProperty(object, propertyName, Map.class)) {\n            value = toMap(stringValue);\n        } else if (isTypedProperty(object, propertyName, List.class) ||\n                isTypedProperty(object, propertyName, Collection.class)) {\n            value = toList(stringValue);\n        } else if (isTypedProperty(object, propertyName, byte[].class)) {\n            value = toBytes(stringValue);\n        } else if (isTypedProperty(object, propertyName, ByteSource.class)) {\n            byte[] bytes = toBytes(stringValue);\n            value = ByteSource.Util.bytes(bytes);\n        } else {\n            String checked = checkForNullOrEmptyLiteral(stringValue);\n            value = resolveValue(checked);\n        }\n\n        try {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Applying property [{}] value [{}] on object of type [{}]\",\n                        new Object[]{propertyName, value, object.getClass().getName()});\n            }\n            BeanUtils.setProperty(object, propertyName, value);\n        } catch (Exception e) {\n            String msg = \"Unable to set property '\" + propertyName + \"' with value [\" + stringValue + \"] on object \" +\n                    \"of type \" + (object != null ? object.getClass().getName() : null) + \".  If \" +\n                    \"'\" + stringValue + \"' is a reference to another (previously defined) object, prefix it with \" +\n                    \"'\" + OBJECT_REFERENCE_BEGIN_TOKEN + \"' to indicate that the referenced \" +\n                    \"object should be used as the actual value.  \" +\n                    \"For example, \" + OBJECT_REFERENCE_BEGIN_TOKEN + stringValue;\n            throw new ConfigurationException(msg, e);\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.config;\n\nimport org.apache.commons.beanutils.BeanUtils;\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.shiro.codec.Base64;\nimport org.apache.shiro.codec.Hex;\nimport org.apache.shiro.util.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.beans.PropertyDescriptor;\nimport java.util.*;\n\n\n/**\n * Object builder that uses reflection and Apache Commons BeanUtils to build objects given a\n * map of \"property values\".  Typically these come from the Shiro INI configuration and are used\n * to construct or modify the SecurityManager, its dependencies, and web-based security filters.\n *\n * Recognizes {@link Factory} implementations and will call\n * {@link org.apache.shiro.util.Factory#getInstance() getInstance} to satisfy any reference to this bean.\n *\n * @since 0.9\n */\npublic class ReflectionBuilder {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(ReflectionBuilder.class);\n\n    private static final String OBJECT_REFERENCE_BEGIN_TOKEN = \"$\";\n    private static final String ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN = \"\\\\$\";\n    private static final String GLOBAL_PROPERTY_PREFIX = \"shiro\";\n    private static final char MAP_KEY_VALUE_DELIMITER = ':';\n    private static final String HEX_BEGIN_TOKEN = \"0x\";\n\n    private Map<String, ?> objects;\n\n    public ReflectionBuilder() {\n        this.objects = new LinkedHashMap<String, Object>();\n    }\n\n    public ReflectionBuilder(Map<String, ?> defaults) {\n        this.objects = CollectionUtils.isEmpty(defaults) ? new LinkedHashMap<String, Object>() : defaults;\n    }\n\n    public Map<String, ?> getObjects() {\n        return objects;\n    }\n\n    public void setObjects(Map<String, ?> objects) {\n        this.objects = CollectionUtils.isEmpty(objects) ? new LinkedHashMap<String, Object>() : objects;\n    }\n\n    public Object getBean(String id) {\n        return objects.get(id);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public <T> T getBean(String id, Class<T> requiredType) {\n        if (requiredType == null) {\n            throw new NullPointerException(\"requiredType argument cannot be null.\");\n        }\n        Object bean = getBean(id);\n        if (bean == null) {\n            return null;\n        }\n        if (!requiredType.isAssignableFrom(bean.getClass())) {\n            throw new IllegalStateException(\"Bean with id [\" + id + \"] is not of the required type [\" +\n                    requiredType.getName() + \"].\");\n        }\n        return (T) bean;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Map<String, ?> buildObjects(Map<String, String> kvPairs) {\n        if (kvPairs != null && !kvPairs.isEmpty()) {\n\n            // Separate key value pairs into object declarations and property assignment\n            // so that all objects can be created up front\n\n            //https://issues.apache.org/jira/browse/SHIRO-85 - need to use LinkedHashMaps here:\n            Map<String, String> instanceMap = new LinkedHashMap<String, String>();\n            Map<String, String> propertyMap = new LinkedHashMap<String, String>();\n\n            for (Map.Entry<String, String> entry : kvPairs.entrySet()) {\n                if (entry.getKey().indexOf('.') < 0 || entry.getKey().endsWith(\".class\")) {\n                    instanceMap.put(entry.getKey(), entry.getValue());\n                } else {\n                    propertyMap.put(entry.getKey(), entry.getValue());\n                }\n            }\n\n            // Create all instances\n            for (Map.Entry<String, String> entry : instanceMap.entrySet()) {\n                createNewInstance((Map<String, Object>) objects, entry.getKey(), entry.getValue());\n            }\n\n            // Set all properties\n            for (Map.Entry<String, String> entry : propertyMap.entrySet()) {\n                applyProperty(entry.getKey(), entry.getValue(), objects);\n            }\n        }\n\n        return objects;\n    }\n\n    protected void createNewInstance(Map<String, Object> objects, String name, String value) {\n\n        Object currentInstance = objects.get(name);\n        if (currentInstance != null) {\n            log.info(\"An instance with name '{}' already exists.  \" +\n                    \"Redefining this object as a new instance of type []\", name, value);\n        }\n\n        Object instance;//name with no property, assume right hand side of equals sign is the class name:\n        try {\n            instance = ClassUtils.newInstance(value);\n            if (instance instanceof Nameable) {\n                ((Nameable) instance).setName(name);\n            }\n        } catch (Exception e) {\n            String msg = \"Unable to instantiate class [\" + value + \"] for object named '\" + name + \"'.  \" +\n                    \"Please ensure you've specified the fully qualified class name correctly.\";\n            throw new ConfigurationException(msg, e);\n        }\n        objects.put(name, instance);\n    }\n\n    protected void applyProperty(String key, String value, Map objects) {\n\n        int index = key.indexOf('.');\n\n        if (index >= 0) {\n            String name = key.substring(0, index);\n            String property = key.substring(index + 1, key.length());\n\n            if (GLOBAL_PROPERTY_PREFIX.equalsIgnoreCase(name)) {\n                applyGlobalProperty(objects, property, value);\n            } else {\n                applySingleProperty(objects, name, property, value);\n            }\n\n        } else {\n            throw new IllegalArgumentException(\"All property keys must contain a '.' character. \" +\n                    \"(e.g. myBean.property = value)  These should already be separated out by buildObjects().\");\n        }\n    }\n\n    protected void applyGlobalProperty(Map objects, String property, String value) {\n        for (Object instance : objects.values()) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(instance, property);\n                if (pd != null) {\n                    applyProperty(instance, property, value);\n                }\n            } catch (Exception e) {\n                String msg = \"Error retrieving property descriptor for instance \" +\n                        \"of type [\" + instance.getClass().getName() + \"] \" +\n                        \"while setting property [\" + property + \"]\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected void applySingleProperty(Map objects, String name, String property, String value) {\n        Object instance = objects.get(name);\n        if (property.equals(\"class\")) {\n            throw new IllegalArgumentException(\"Property keys should not contain 'class' properties since these \" +\n                    \"should already be separated out by buildObjects().\");\n\n        } else if (instance == null) {\n            String msg = \"Configuration error.  Specified object [\" + name + \"] with property [\" +\n                    property + \"] without first defining that object's class.  Please first \" +\n                    \"specify the class property first, e.g. myObject = fully_qualified_class_name \" +\n                    \"and then define additional properties.\";\n            throw new IllegalArgumentException(msg);\n\n        } else {\n            applyProperty(instance, property, value);\n        }\n    }\n\n    protected boolean isReference(String value) {\n        return value != null && value.startsWith(OBJECT_REFERENCE_BEGIN_TOKEN);\n    }\n\n    protected String getId(String referenceToken) {\n        return referenceToken.substring(OBJECT_REFERENCE_BEGIN_TOKEN.length());\n    }\n\n    protected Object getReferencedObject(String id) {\n        Object o = objects != null && !objects.isEmpty() ? objects.get(id) : null;\n        if (o == null) {\n            String msg = \"The object with id [\" + id + \"] has not yet been defined and therefore cannot be \" +\n                    \"referenced.  Please ensure objects are defined in the order in which they should be \" +\n                    \"created and made available for future reference.\";\n            throw new UnresolveableReferenceException(msg);\n        }\n        return o;\n    }\n\n    protected String unescapeIfNecessary(String value) {\n        if (value != null && value.startsWith(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN)) {\n            return value.substring(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN.length() - 1);\n        }\n        return value;\n    }\n\n    protected Object resolveReference(String reference) {\n        String id = getId(reference);\n        log.debug(\"Encountered object reference '{}'.  Looking up object with id '{}'\", reference, id);\n        final Object referencedObject = getReferencedObject(id);\n        if(referencedObject instanceof Factory) {\n            return ((Factory)referencedObject).getInstance();\n        }\n        return referencedObject;\n    }\n\n    protected boolean isTypedProperty(Object object, String propertyName, Class clazz) {\n        if (clazz == null) {\n            throw new NullPointerException(\"type (class) argument cannot be null.\");\n        }\n        try {\n            PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(object, propertyName);\n            if (descriptor == null) {\n                String msg = \"Property '\" + propertyName + \"' does not exist for object of \" +\n                        \"type \" + object.getClass().getName() + \".\";\n                throw new ConfigurationException(msg);\n            }\n            Class propertyClazz = descriptor.getPropertyType();\n            return clazz.isAssignableFrom(propertyClazz);\n        } catch (ConfigurationException ce) {\n            //let it propagate:\n            throw ce;\n        } catch (Exception e) {\n            String msg = \"Unable to determine if property [\" + propertyName + \"] represents a \" + clazz.getName();\n            throw new ConfigurationException(msg, e);\n        }\n    }\n\n    protected Set<?> toSet(String sValue) {\n        String[] tokens = StringUtils.split(sValue);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n        Set<String> setTokens = new LinkedHashSet<String>(Arrays.asList(tokens));\n\n        //now convert into correct values and/or references:\n        Set<Object> values = new LinkedHashSet<Object>(setTokens.size());\n        for (String token : setTokens) {\n            Object value = resolveValue(token);\n            values.add(value);\n        }\n        return values;\n    }\n\n    protected Map<?, ?> toMap(String sValue) {\n        String[] tokens = StringUtils.split(sValue, StringUtils.DEFAULT_DELIMITER_CHAR,\n                StringUtils.DEFAULT_QUOTE_CHAR, StringUtils.DEFAULT_QUOTE_CHAR, true, true);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n\n        Map<String, String> mapTokens = new LinkedHashMap<String, String>(tokens.length);\n        for (String token : tokens) {\n            String[] kvPair = StringUtils.split(token, MAP_KEY_VALUE_DELIMITER);\n            if (kvPair == null || kvPair.length != 2) {\n                String msg = \"Map property value [\" + sValue + \"] contained key-value pair token [\" +\n                        token + \"] that does not properly split to a single key and pair.  This must be the \" +\n                        \"case for all map entries.\";\n                throw new ConfigurationException(msg);\n            }\n            mapTokens.put(kvPair[0], kvPair[1]);\n        }\n\n        //now convert into correct values and/or references:\n        Map<Object, Object> map = new LinkedHashMap<Object, Object>(mapTokens.size());\n        for (Map.Entry<String, String> entry : mapTokens.entrySet()) {\n            Object key = resolveValue(entry.getKey());\n            Object value = resolveValue(entry.getValue());\n            map.put(key, value);\n        }\n        return map;\n    }\n\n\n    protected List<?> toList(String sValue) {\n        String[] tokens = StringUtils.split(sValue);\n        if (tokens == null || tokens.length <= 0) {\n            return null;\n        }\n\n        //now convert into correct values and/or references:\n        List<Object> values = new ArrayList<Object>(tokens.length);\n        for (String token : tokens) {\n            Object value = resolveValue(token);\n            values.add(value);\n        }\n        return values;\n    }\n\n    protected byte[] toBytes(String sValue) {\n        if (sValue == null) {\n            return null;\n        }\n        byte[] bytes;\n        if (sValue.startsWith(HEX_BEGIN_TOKEN)) {\n            String hex = sValue.substring(HEX_BEGIN_TOKEN.length());\n            bytes = Hex.decode(hex);\n        } else {\n            //assume base64 encoded:\n            bytes = Base64.decode(sValue);\n        }\n        return bytes;\n    }\n\n    protected Object resolveValue(String stringValue) {\n        Object value;\n        if (isReference(stringValue)) {\n            value = resolveReference(stringValue);\n        } else {\n            value = unescapeIfNecessary(stringValue);\n        }\n        return value;\n    }\n\n\n    protected void applyProperty(Object object, String propertyName, String stringValue) {\n\n        Object value;\n\n        if (isTypedProperty(object, propertyName, Set.class)) {\n            value = toSet(stringValue);\n        } else if (isTypedProperty(object, propertyName, Map.class)) {\n            value = toMap(stringValue);\n        } else if (isTypedProperty(object, propertyName, List.class) ||\n                isTypedProperty(object, propertyName, Collection.class)) {\n            value = toList(stringValue);\n        } else if (isTypedProperty(object, propertyName, byte[].class)) {\n            value = toBytes(stringValue);\n        } else if (isTypedProperty(object, propertyName, ByteSource.class)) {\n            byte[] bytes = toBytes(stringValue);\n            value = ByteSource.Util.bytes(bytes);\n        } else {\n            value = resolveValue(stringValue);\n        }\n\n        try {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Applying property [{}] value [{}] on object of type [{}]\",\n                        new Object[]{propertyName, value, object.getClass().getName()});\n            }\n            BeanUtils.setProperty(object, propertyName, value);\n        } catch (Exception e) {\n            String msg = \"Unable to set property '\" + propertyName + \"' with value [\" + stringValue + \"] on object \" +\n                    \"of type \" + (object != null ? object.getClass().getName() : null) + \".  If \" +\n                    \"'\" + stringValue + \"' is a reference to another (previously defined) object, prefix it with \" +\n                    \"'\" + OBJECT_REFERENCE_BEGIN_TOKEN + \"' to indicate that the referenced \" +\n                    \"object should be used as the actual value.  \" +\n                    \"For example, \" + OBJECT_REFERENCE_BEGIN_TOKEN + stringValue;\n            throw new ConfigurationException(msg, e);\n        }\n    }\n\n}\n","lineNo":386}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.authc.credential;\n\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.crypto.hash.Hash;\n\n/**\n * A {@link CredentialsMatcher} that employs best-practices comparisons for hashed text passwords.\n * <p/>\n * This implementation delegates to an internal {@link PasswordService} to perform the actual password\n * comparison.  This class is essentially a bridge between the generic CredentialsMatcher interface and the\n * more specific {@code PasswordService} component.\n *\n * @since 1.2\n */\npublic class PasswordMatcher implements CredentialsMatcher {\n\n    private PasswordService passwordService;\n\n    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {\n\n        PasswordService service = ensurePasswordService();\n\n        Object submittedPassword = getSubmittedPassword(token);\n        Object storedCredentials = getStoredPassword(info);\n        assertStoredCredentialsType(storedCredentials);\n\n        if (storedCredentials instanceof Hash) {\n            Hash hashedPassword = (Hash)storedCredentials;\n            HashingPasswordService hashingService = assertHashingPasswordService(service);\n            return hashingService.passwordsMatch(submittedPassword, hashedPassword);\n        }\n        //otherwise they are a String (asserted in the 'assertStoredCredentialsType' method call above):\n        String formatted = (String)storedCredentials;\n        return passwordService.passwordsMatch(submittedPassword, formatted);\n    }\n\n    private HashingPasswordService assertHashingPasswordService(PasswordService service) {\n        if (service instanceof HashingPasswordService) {\n            return (HashingPasswordService) service;\n        }\n        String msg = \"AuthenticationInfo's stored credentials are a Hash instance, but the \" +\n                \"configured passwordService is not a \" +\n                HashingPasswordService.class.getName() + \" instance.  This is required to perform Hash \" +\n                \"object password comparisons.\";\n        throw new IllegalStateException(msg);\n    }\n\n    private PasswordService ensurePasswordService() {\n        PasswordService service = getPasswordService();\n        if (service == null) {\n            String msg = \"Required PasswordService has not been configured.\";\n            throw new IllegalStateException(msg);\n        }\n        return service;\n    }\n\n    protected Object getSubmittedPassword(AuthenticationToken token) {\n        return token != null ? token.getCredentials() : null;\n    }\n\n    private void assertStoredCredentialsType(Object credentials) {\n        if (credentials instanceof String || credentials instanceof Hash) {\n            return;\n        }\n\n        String msg = \"Stored account credentials are expected to be either a \" +\n                Hash.class.getName() + \" instance or a formatted hash String.\";\n        throw new IllegalArgumentException(msg);\n    }\n\n    protected Object getStoredPassword(AuthenticationInfo storedAccountInfo) {\n        return storedAccountInfo != null ? storedAccountInfo.getCredentials() : null;\n    }\n\n    public PasswordService getPasswordService() {\n        return passwordService;\n    }\n\n    public void setPasswordService(PasswordService passwordService) {\n        this.passwordService = passwordService;\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.authc.credential;\n\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.util.ByteSource;\n\n/**\n * A {@link CredentialsMatcher} that employs best-practices comparisons for hashed text passwords.\n * <p/>\n * This implementation delegates to an internal {@link PasswordService} to perform the actual password\n * comparison.  This class is essentially a bridge between the generic CredentialsMatcher interface and the\n * more specific {@code PasswordService} component.\n *\n * @since 1.2\n */\npublic class PasswordMatcher implements CredentialsMatcher {\n\n    private PasswordService passwordService;\n\n    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {\n        PasswordService service = ensurePasswordService();\n        ByteSource submittedPassword = getSubmittedPassword(token);\n        String hashedPassword = getStoredHashedPassword(info);\n        return service.passwordsMatch(submittedPassword, hashedPassword);\n    }\n\n    private PasswordService ensurePasswordService() {\n        PasswordService service = getPasswordService();\n        if (service == null) {\n            String msg = \"Required PasswordService has not been configured.\";\n            throw new IllegalStateException(msg);\n        }\n        return service;\n    }\n\n    protected ByteSource getSubmittedPassword(AuthenticationToken token) {\n        Object credentials = token.getCredentials();\n        if (credentials == null) {\n            return null;\n        }\n        return ByteSource.Util.bytes(credentials);\n    }\n\n    protected String getStoredHashedPassword(AuthenticationInfo storedAccountInfo) {\n        Object credentials = storedAccountInfo.getCredentials();\n        if (credentials == null) {\n            return null;\n        }\n        if (!(credentials instanceof String)) {\n            String msg = \"The stored account credentials is expected to be a String representation of a hashed password.\";\n            throw new IllegalArgumentException(msg);\n        }\n        return (String)credentials;\n    }\n\n    public PasswordService getPasswordService() {\n        return passwordService;\n    }\n\n    public void setPasswordService(PasswordService passwordService) {\n        this.passwordService = passwordService;\n    }\n}\n","lineNo":48}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.guice;\n\nimport com.google.common.primitives.Primitives;\nimport com.google.inject.*;\nimport com.google.inject.matcher.Matcher;\nimport com.google.inject.matcher.Matchers;\nimport com.google.inject.multibindings.MapBinder;\nimport com.google.inject.name.Names;\nimport com.google.inject.spi.TypeEncounter;\nimport com.google.inject.spi.TypeListener;\nimport com.google.inject.util.Types;\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.shiro.SecurityUtils;\n\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Type;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * TypeListener that injects setter methods on Shiro objects.\n */\nclass BeanTypeListener implements TypeListener {\n    public static final Package SHIRO_GUICE_PACKAGE = ShiroModule.class.getPackage();\n    public static final Package SHIRO_PACKAGE = SecurityUtils.class.getPackage();\n\n    private static Matcher<Class> shiroMatcher = Matchers.inSubpackage(SHIRO_PACKAGE.getName());\n    private static Matcher<Class> shiroGuiceMatcher = Matchers.inSubpackage(SHIRO_GUICE_PACKAGE.getName());\n\n    private static Matcher<Class> classMatcher = ShiroMatchers.ANY_PACKAGE.and(shiroMatcher.and(Matchers.not(shiroGuiceMatcher)));\n\n    public static final Matcher<TypeLiteral> MATCHER = ShiroMatchers.typeLiteral(classMatcher);\n\n    private static final String BEAN_TYPE_MAP_NAME = \"__SHIRO_BEAN_TYPES__\";\n    static final Key<?> MAP_KEY = Key.get(Types.mapOf(TypeLiteral.class, BeanTypeKey.class), Names.named(BEAN_TYPE_MAP_NAME));\n\n    public <I> void hear(TypeLiteral<I> type, final TypeEncounter<I> encounter) {\n        PropertyDescriptor propertyDescriptors[] = PropertyUtils.getPropertyDescriptors(type.getRawType());\n        final Map<PropertyDescriptor, Key<?>> propertyDependencies = new HashMap<PropertyDescriptor, Key<?>>(propertyDescriptors.length);\n        final Provider<Injector> injectorProvider = encounter.getProvider(Injector.class);\n        for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {\n            if (propertyDescriptor.getWriteMethod() != null && Modifier.isPublic(propertyDescriptor.getWriteMethod().getModifiers())) {\n                Type propertyType = propertyDescriptor.getWriteMethod().getGenericParameterTypes()[0];\n                propertyDependencies.put(propertyDescriptor, createDependencyKey(propertyDescriptor, propertyType));\n            }\n        }\n        encounter.register(new MembersInjector<I>() {\n            public void injectMembers(I instance) {\n                for (Map.Entry<PropertyDescriptor, Key<?>> dependency : propertyDependencies.entrySet()) {\n                    try {\n                        final Injector injector = injectorProvider.get();\n\n                        Object value = injector.getInstance(getMappedKey(injector, dependency.getValue()));\n                        dependency.getKey().getWriteMethod().invoke(instance, value);\n\n                    } catch (ConfigurationException e) {\n                        // This is ok, it simply means that we can't fulfill this dependency.\n                        // Is there a better way to do this?\n                    } catch (InvocationTargetException e) {\n                        throw new RuntimeException(\"Couldn't set property \" + dependency.getKey().getDisplayName(), e);\n                    } catch (IllegalAccessException e) {\n                        throw new RuntimeException(\"We shouldn't have ever reached this point, we don't try to inject to non-accessible methods.\", e);\n                    }\n                }\n\n            }\n        });\n    }\n\n    private static Key<?> getMappedKey(Injector injector, Key<?> key) {\n        Map<TypeLiteral, BeanTypeKey> beanTypeMap = getBeanTypeMap(injector);\n        if(key.getAnnotation() == null && beanTypeMap.containsKey(key.getTypeLiteral())) {\n            return beanTypeMap.get(key.getTypeLiteral()).key;\n        } else {\n            return key;\n        }\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private static Map<TypeLiteral, BeanTypeKey> getBeanTypeMap(Injector injector) {\n        return (Map<TypeLiteral, BeanTypeKey>) injector.getInstance(MAP_KEY);\n    }\n\n    private static Key<?> createDependencyKey(PropertyDescriptor propertyDescriptor, Type propertyType) {\n        if(requiresName(propertyType)) {\n            return Key.get(propertyType, Names.named(\"shiro.\" + propertyDescriptor.getName()));\n        } else {\n            return Key.get(propertyType);\n        }\n    }\n\n    private static boolean requiresName(Type propertyType) {\n        if (propertyType instanceof Class) {\n            Class<?> aClass = (Class<?>) propertyType;\n            return aClass.isPrimitive() || aClass.isEnum() || Primitives.isWrapperType(aClass) || CharSequence.class.isAssignableFrom(aClass);\n        } else {\n            return false;\n        }\n    }\n\n    static void ensureBeanTypeMapExists(Binder binder) {\n        beanTypeMapBinding(binder).addBinding(TypeLiteral.get(BeanTypeKey.class)).toInstance(new BeanTypeKey(null));\n    }\n\n    static <T> void bindBeanType(Binder binder, TypeLiteral<T> typeLiteral, Key<? extends T> key) {\n        beanTypeMapBinding(binder).addBinding(typeLiteral).toInstance(new BeanTypeKey(key));\n    }\n\n    private static MapBinder<TypeLiteral, BeanTypeKey> beanTypeMapBinding(Binder binder) {\n        return MapBinder.newMapBinder(binder, TypeLiteral.class, BeanTypeKey.class, Names.named(BEAN_TYPE_MAP_NAME));\n    }\n\n    private static class BeanTypeKey {\n        Key<?> key;\n\n        private BeanTypeKey(Key<?> key) {\n            this.key = key;\n        }\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.guice;\n\nimport com.google.common.primitives.Primitives;\nimport com.google.inject.*;\nimport com.google.inject.matcher.Matcher;\nimport com.google.inject.matcher.Matchers;\nimport com.google.inject.name.Names;\nimport com.google.inject.spi.TypeEncounter;\nimport com.google.inject.spi.TypeListener;\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.shiro.SecurityUtils;\n\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Type;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * TypeListener that injects setter methods on Shiro objects.\n */\nclass BeanTypeListener implements TypeListener {\n    public static final Package SHIRO_GUICE_PACKAGE = ShiroModule.class.getPackage();\n    public static final Package SHIRO_PACKAGE = SecurityUtils.class.getPackage();\n\n    private static Matcher<Class> shiroMatcher = Matchers.inSubpackage(SHIRO_PACKAGE.getName());\n    private static Matcher<Class> shiroGuiceMatcher = Matchers.inSubpackage(SHIRO_GUICE_PACKAGE.getName());\n\n    private static Matcher<Class> classMatcher = ShiroMatchers.ANY_PACKAGE.and(shiroMatcher.and(Matchers.not(shiroGuiceMatcher)));\n\n    public static final Matcher<TypeLiteral> MATCHER = ShiroMatchers.typeLiteral(classMatcher);\n\n    public <I> void hear(TypeLiteral<I> type, final TypeEncounter<I> encounter) {\n        PropertyDescriptor propertyDescriptors[] = PropertyUtils.getPropertyDescriptors(type.getRawType());\n        final Map<PropertyDescriptor, Key<?>> propertyDependencies = new HashMap<PropertyDescriptor, Key<?>>(propertyDescriptors.length);\n        final Provider<Injector> injectorProvider = encounter.getProvider(Injector.class);\n        for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {\n            if (propertyDescriptor.getWriteMethod() != null && Modifier.isPublic(propertyDescriptor.getWriteMethod().getModifiers())) {\n                Type propertyType = propertyDescriptor.getWriteMethod().getGenericParameterTypes()[0];\n                propertyDependencies.put(propertyDescriptor, requiresName(propertyType)\n                        ? Key.get(propertyType, Names.named(\"shiro.\" + propertyDescriptor.getName()))\n                        : Key.get(propertyType));\n            }\n        }\n        encounter.register(new MembersInjector<I>() {\n            public void injectMembers(I instance) {\n                for (Map.Entry<PropertyDescriptor, Key<?>> dependency : propertyDependencies.entrySet()) {\n                    try {\n                        Object value = injectorProvider.get().getInstance(dependency.getValue());\n                        dependency.getKey().getWriteMethod().invoke(instance, value);\n\n                    } catch (ConfigurationException e) {\n                        // This is ok, it simply means that we can't fulfill this dependency.\n                        // Is there a better way to do this?\n                    } catch (InvocationTargetException e) {\n                        throw new RuntimeException(\"Couldn't set property \" + dependency.getKey().getDisplayName(), e);\n                    } catch (IllegalAccessException e) {\n                        throw new RuntimeException(\"We shouldn't have ever reached this point, we don't try to inject to non-accessible methods.\", e);\n                    }\n                }\n\n            }\n        });\n    }\n\n    private static boolean requiresName(Type propertyType) {\n        if (propertyType instanceof Class) {\n            Class<?> aClass = (Class<?>) propertyType;\n            return aClass.isPrimitive() || aClass.isEnum() || Primitives.isWrapperType(aClass) || CharSequence.class.isAssignableFrom(aClass);\n        } else {\n            return false;\n        }\n    }\n}\n","lineNo":71}
{"Refactored Sample":"package org.apache.shiro.web.filter.authc;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.web.servlet.AdviceFilter;\nimport org.apache.shiro.web.util.WebUtils;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\n/**\n * Simple Filter that, upon receiving a request, will immediately log-out the currently executing\n * {@link #getSubject(javax.servlet.ServletRequest, javax.servlet.ServletResponse) subject}\n * and then redirect them to a configured {@link #getRedirectUrl() redirectUrl}.\n *\n * @since 1.2\n */\npublic class LogoutFilter extends AdviceFilter {\n\n    /**\n     * The default redirect URL to where the user will be redirected after logout.  The value is {@code \"/\"}, Shiro's\n     * representation of the web application's context root.\n     */\n    public static final String DEFAULT_REDIRECT_URL = \"/\";\n\n    /**\n     * The URL to where the user will be redirected after logout.\n     */\n    private String redirectUrl = DEFAULT_REDIRECT_URL;\n\n    /**\n     * Immediately logs out the currently executing {@link #getSubject(javax.servlet.ServletRequest, javax.servlet.ServletResponse) subject}\n     * and redirects the end-user to the configured {@link #getRedirectUrl() redirectUrl}.\n     *\n     * @param request  the incoming ServletRequest\n     * @param response the outgoing ServletResponse\n     * @return {@code false} always as typically no further interaction should be done after user logout.\n     * @throws Exception if there is any error.\n     */\n    @Override\n    protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {\n        Subject subject = getSubject(request, response);\n        subject.logout();\n        issueRedirect(request, response);\n        return false;\n    }\n\n    /**\n     * Returns the currently executing {@link Subject}.  This implementation merely defaults to calling\n     * {@code SecurityUtils.}{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()}, but can be overridden\n     * by subclasses for different retrieval strategies.\n     *\n     * @param request  the incoming Servlet request\n     * @param response the outgoing Servlet response\n     * @return the currently executing {@link Subject}.\n     */\n    protected Subject getSubject(ServletRequest request, ServletResponse response) {\n        return SecurityUtils.getSubject();\n    }\n\n    /**\n     * Issues an HTTP redirect after subject logout.  This implementation acquires the redirect URL returned from\n     * {@link #getRedirectUrl(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} and then calls\n     * {@code WebUtils.}{@link WebUtils#issueRedirect(javax.servlet.ServletRequest, javax.servlet.ServletResponse, String) issueRedirect(request,response,redirectUrl)}.\n     *\n     * @param request  the incoming Servlet request\n     * @param response the outgoing Servlet response\n     * @throws Exception if there is any error.\n     */\n    protected void issueRedirect(ServletRequest request, ServletResponse response) throws Exception {\n        String redirectUrl = getRedirectUrl(request, response);\n        WebUtils.issueRedirect(request, response, redirectUrl);\n    }\n\n    /**\n     * Returns the redirect URL to send the user after logout.  This default implementation returns the static\n     * configured {@link #getRedirectUrl() redirectUrl} property, but this method may be overridden by subclasses\n     * to dynamically construct the URL if necessary.\n     *\n     * @param request the incoming Servlet request\n     * @param response the outgoing ServletResponse\n     * @return the redirect URL to send the user after logout.\n     */\n    protected String getRedirectUrl(ServletRequest request, ServletResponse response) {\n        return getRedirectUrl();\n    }\n\n    /**\n     * Returns the URL to where the user will be redirected after logout.  Default is the web application's context\n     * root, i.e. {@code \"/\"}\n     *\n     * @return the URL to where the user will be redirected after logout.\n     */\n    public String getRedirectUrl() {\n        return redirectUrl;\n    }\n\n    /**\n     * Sets the URL to where the user will be redirected after logout.  Default is the web application's context\n     * root, i.e. {@code \"/\"}\n     *\n     * @param redirectUrl the url to where the user will be redirected after logout\n     */\n    public void setRedirectUrl(String redirectUrl) {\n        this.redirectUrl = redirectUrl;\n    }\n}\n","Smelly Sample":"package org.apache.shiro.web.filter.authc;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.web.servlet.AdviceFilter;\nimport org.apache.shiro.web.util.WebUtils;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\n/**\n * Simple Filter that, upon receiving a request, will immediately log-out the currently executing\n * {@link #getSubject(javax.servlet.ServletRequest, javax.servlet.ServletResponse) subject}\n * and then redirect them to a configured {@link #getRedirectUrl() redirectUrl}.\n *\n * @since 1.2\n */\npublic class LogoutFilter extends AdviceFilter {\n\n    /**\n     * The default redirect URL to where the user will be redirected after logout.  The value is {@code \"/\"}, Shiro's\n     * representation of the web application's context root.\n     */\n    public static final String DEFAULT_REDIRECT_URL = \"/\";\n\n    /**\n     * The URL to where the user will be redirected after logout.\n     */\n    private String redirectUrl = DEFAULT_REDIRECT_URL;\n\n    /**\n     * Immediately logs out the currently executing {@link #getSubject(javax.servlet.ServletRequest, javax.servlet.ServletResponse) subject}\n     * and redirects the end-user to the configured {@link #getRedirectUrl() redirectUrl}.\n     *\n     * @param request  the incoming ServletRequest\n     * @param response the outgoing ServletResponse\n     * @return {@code false} always as typically no further interaction should be done after user logout.\n     * @throws Exception if there is any error.\n     */\n    @Override\n    protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {\n        Subject subject = getSubject(request, response);\n        subject.logout();\n        issueRedirect(request, response);\n        return false;\n    }\n\n    /**\n     * Returns the currently executing {@link Subject}.  This implementation merely defaults to calling\n     * {@code SecurityUtils.}{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()}, but can be overridden\n     * by subclasses for different retrieval strategies.\n     *\n     * @param request  the incoming Servlet request\n     * @param response the outgoing Servlet response\n     * @return the currently executing {@link Subject}.\n     */\n    protected Subject getSubject(ServletRequest request, ServletResponse response) {\n        return SecurityUtils.getSubject();\n    }\n\n    /**\n     * Issues an HTTP redirect after subject logout.  This implementation calls\n     * {@code WebUtils.}{@link WebUtils#issueRedirect(javax.servlet.ServletRequest, javax.servlet.ServletResponse, String) issueRedirect(request,response,redirectUrl)}\n     * using the configured {@link #getRedirectUrl()}.\n     *\n     * @param request  the incoming Servlet request\n     * @param response the outgoing Servlet response\n     * @throws Exception if there is any error.\n     */\n    protected void issueRedirect(ServletRequest request, ServletResponse response) throws Exception {\n        WebUtils.issueRedirect(request, response, getRedirectUrl());\n    }\n\n    /**\n     * Returns the URL to where the user will be redirected after logout.  Default is the web application's context\n     * root, i.e. {@code \"/\"}\n     *\n     * @return the URL to where the user will be redirected after logout.\n     */\n    public String getRedirectUrl() {\n        return redirectUrl;\n    }\n\n    /**\n     * Sets the URL to where the user will be redirected after logout.  Default is the web application's context\n     * root, i.e. {@code \"/\"}\n     *\n     * @param redirectUrl the url to where the user will be redirected after logout\n     */\n    public void setRedirectUrl(String redirectUrl) {\n        this.redirectUrl = redirectUrl;\n    }\n}\n","lineNo":71}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.servlet;\n\nimport org.apache.shiro.config.ConfigurationException;\nimport org.apache.shiro.config.Ini;\nimport org.apache.shiro.config.IniFactorySupport;\nimport org.apache.shiro.io.ResourceUtils;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.util.StringUtils;\nimport org.apache.shiro.web.config.IniFilterChainResolverFactory;\nimport org.apache.shiro.web.config.WebIniSecurityManagerFactory;\nimport org.apache.shiro.web.filter.mgt.FilterChainResolver;\nimport org.apache.shiro.web.mgt.WebSecurityManager;\nimport org.apache.shiro.web.util.WebUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.InputStream;\nimport java.util.Map;\n\n/**\n * Main Servlet Filter that configures and enables all Shiro functions within a web application by using the\n * <a href=\"http://en.wikipedia.org/wiki/INI_file\">INI<\/a> configuration format.\n * <p/>\n * The actual INI configuration contents are not covered here, but instead in Shiro's\n * <a href=\"http://shiro.apache.org/configuration.html\">Configuration Documentation<\/a> and additional web-specific\n * <a href=\"http://shiro.apache.org/web.html\">Web Documentation<\/a>.\n * <h2>Usage<\/h2>\n * <h3>Default<\/h3>\n * By default, the simplest filter declaration expects a {@code shiro.ini} resource to be located at\n * {@code /WEB-INF/shiro.ini}, or, if not there, falls back to checking the root of the classpath\n * (i.e. {@code classpath:shiro.ini}):\n * <pre>\n * &lt;filter&gt;\n *     &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;\n *     &lt;filter-class&gt;org.apache.shiro.web.servlet.IniShiroFilter&lt;/filter-class&gt;\n * &lt;/filter&gt;\n * <\/pre>\n * <h3>Custom Path<\/h3>\n * If you want the INI configuration to be somewhere other than {@code /WEB-INF/shiro.ini} or\n * {@code classpath:shiro.ini}, you may specify an alternate location via the {@code configPath init-param}:\n * <pre>\n * &lt;filter&gt;\n *     &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;\n *     &lt;filter-class&gt;org.apache.shiro.web.servlet.IniShiroFilter&lt;/filter-class&gt;\n *     &lt;init-param&gt;\n *         &lt;param-name&gt;configPath&lt;/param-name&gt;\n *         &lt;param-value&gt;/WEB-INF/someFile.ini&lt;/param-value&gt;\n *     &lt;/init-param&gt;\n * &lt;/filter&gt;\n * <\/pre>\n * Unqualified (schemeless or 'non-prefixed') paths are assumed to be {@code ServletContext} resource paths, resolvable\n * via {@link javax.servlet.ServletContext#getResourceAsStream(String) ServletContext#getResourceAsStream}.\n * <p/>\n * Non-ServletContext resources may be loaded from qualified locations by specifying prefixes indicating the source,\n * e.g. {@code file:}, {@code url:}, and {@code classpath:}.  See the\n * {@link ResourceUtils#getInputStreamForPath(String)} JavaDoc for more.\n * <h3>Inline<\/h3>\n * For relatively simple environments, you can embed the INI config directly inside the filter declaration with\n * the {@code config init-param}:\n * <pre>\n * &lt;filter&gt;\n *     &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;\n *     &lt;filter-class&gt;org.apache.shiro.web.servlet.IniShiroFilter&lt;/filter-class&gt;\n *     &lt;init-param&gt;\n *         &lt;param-name&gt;config&lt;/param-name&gt;\n *         &lt;param-value&gt;\n *             #INI config goes here...\n *      &lt;/param-value&gt;\n *     &lt;/init-param&gt;\n * &lt;/filter&gt;\n * <\/pre>\n * Although this is typically not recommended because any Shiro configuration changes would contribute to version control\n * 'noise' in the web.xml file.\n * <p/>\n * When creating the shiro.ini configuration itself, please see Shiro's\n * <a href=\"http://shiro.apache.org/configuration.html\">Configuration Documentation<\/a> and\n * <a href=\"http://shiro.apache.org/web.html\">Web Documentation<\/a>.\n *\n * @since 1.0\n * @see <a href=\"http://shiro.apache.org/configuration.html\">Apache Shiro INI Configuration<\/a>\n * @see <a href=\"http://shiro.apache.org/web.html\">Apache Shiro Web Documentation<\/a>\n */\npublic class IniShiroFilter extends AbstractShiroFilter {\n\n    public static final String CONFIG_INIT_PARAM_NAME = \"config\";\n    public static final String CONFIG_PATH_INIT_PARAM_NAME = \"configPath\";\n\n    public static final String DEFAULT_WEB_INI_RESOURCE_PATH = \"/WEB-INF/shiro.ini\";\n\n    private static final Logger log = LoggerFactory.getLogger(IniShiroFilter.class);\n\n    private String config;\n    private String configPath;\n\n    public IniShiroFilter() {\n    }\n\n    /**\n     * Returns the actual INI configuration text to use to build the {@link SecurityManager} and\n     * {@link FilterChainResolver} used by the web application or {@code null} if the\n     * {@link #getConfigPath() configPath} should be used to load a fallback INI source.\n     * <p/>\n     * This value is {@code null} by default, but it will be automatically set to the value of the\n     * '{@code config}' {@code init-param} if it exists in the {@code FilterConfig} provided by the servlet\n     * container at startup.\n     *\n     * @return the actual INI configuration text to use to build the {@link SecurityManager} and\n     *         {@link FilterChainResolver} used by the web application or {@code null} if the\n     *         {@link #getConfigPath() configPath} should be used to load a fallback INI source.\n     */\n    public String getConfig() {\n        return this.config;\n    }\n\n    /**\n     * Sets the actual INI configuration text to use to build the {@link SecurityManager} and\n     * {@link FilterChainResolver} used by the web application.  If this value is {@code null}, the\n     * {@link #getConfigPath() configPath} will be checked to see if a .ini file should be loaded instead.\n     * <p/>\n     * This value is {@code null} by default, but it will be automatically set to the value of the\n     * '{@code config}' {@code init-param} if it exists in the {@code FilterConfig} provided by the servlet\n     * container at startup.\n     *\n     * @param config the actual INI configuration text to use to build the {@link SecurityManager} and\n     *               {@link FilterChainResolver} used by the web application.\n     */\n    public void setConfig(String config) {\n        this.config = config;\n    }\n\n    /**\n     * Returns the config path to be used to load a .ini file for configuration if a configuration is\n     * not specified via the {@link #getConfig() config} attribute.\n     * <p/>\n     * This value is {@code null} by default, but it will be automatically set to the value of the\n     * '{@code configPath}' {@code init-param} if it exists in the {@code FilterConfig} provided by the servlet\n     * container at startup.\n     *\n     * @return the config path to be used to load a .ini file for configuration if a configuration is\n     *         not specified via the {@link #getConfig() config} attribute.\n     */\n    public String getConfigPath() {\n        return configPath;\n    }\n\n    /**\n     * Sets the config path to be used to load a .ini file for configuration if a configuration is\n     * not specified via the {@link #getConfig() config} attribute.\n     * <p/>\n     * This value is {@code null} by default, but it will be automatically set to the value of the\n     * '{@code configPath}' {@code init-param} if it exists in the {@code FilterConfig} provided by the servlet\n     * container at startup.\n     *\n     * @param configPath the config path to be used to load a .ini file for configuration if a configuration is\n     *                   not specified via the {@link #getConfig() config} attribute.\n     */\n    public void setConfigPath(String configPath) {\n        String path = StringUtils.clean(configPath);\n        if (path != null) {\n            path = WebUtils.normalize(path);\n        }\n        this.configPath = path;\n    }\n\n    public void init() throws Exception {\n        applyInitParams();\n        configure();\n    }\n\n    protected void applyInitParams() throws Exception {\n        String config = getInitParam(CONFIG_INIT_PARAM_NAME);\n        if (config != null) {\n            setConfig(config);\n        }\n        String configPath = getInitParam(CONFIG_PATH_INIT_PARAM_NAME);\n        if (configPath != null) {\n            setConfigPath(configPath);\n        }\n    }\n\n    protected void configure() throws Exception {\n        Ini ini = loadIniFromConfig();\n\n        if (CollectionUtils.isEmpty(ini)) {\n            log.info(\"Null or empty configuration specified via 'config' init-param.  \" +\n                    \"Checking path-based configuration.\");\n            ini = loadIniFromPath();\n        }\n        //added for SHIRO-178:\n        if (CollectionUtils.isEmpty(ini)) {\n            log.info(\"Null or empty configuration specified via '\" + CONFIG_INIT_PARAM_NAME + \"' or '\" +\n                    CONFIG_PATH_INIT_PARAM_NAME + \"' filter parameters.  Trying the default \" +\n                    DEFAULT_WEB_INI_RESOURCE_PATH + \" file.\");\n            ini = getServletContextIniResource(DEFAULT_WEB_INI_RESOURCE_PATH);\n        }\n        //although the preferred default is /WEB-INF/shiro.ini per SHIRO-178, keep this\n        //for backwards compatibility:\n        if (CollectionUtils.isEmpty(ini)) {\n            log.info(\"Null or empty configuration specified via '\" + CONFIG_INIT_PARAM_NAME + \"' or '\" +\n                    CONFIG_PATH_INIT_PARAM_NAME + \"' filter parameters.  Trying the default \" +\n                    IniFactorySupport.DEFAULT_INI_RESOURCE_PATH + \" file.\");\n            ini = IniFactorySupport.loadDefaultClassPathIni();\n        }\n\n        Map<String, ?> objects = applySecurityManager(ini);\n        applyFilterChainResolver(ini, objects);\n    }\n\n    protected Ini loadIniFromConfig() {\n        Ini ini = null;\n        String config = getConfig();\n        if (config != null) {\n            ini = convertConfigToIni(config);\n        }\n        return ini;\n    }\n\n    protected Ini loadIniFromPath() {\n        Ini ini = null;\n        String path = getConfigPath();\n        if (path != null) {\n            ini = convertPathToIni(path);\n        }\n        return ini;\n    }\n\n    protected Map<String, ?> applySecurityManager(Ini ini) {\n        WebIniSecurityManagerFactory factory;\n        if (CollectionUtils.isEmpty(ini)) {\n            factory = new WebIniSecurityManagerFactory();\n        } else {\n            factory = new WebIniSecurityManagerFactory(ini);\n        }\n\n        // Create the security manager and check that it implements WebSecurityManager.\n        // Otherwise, it can't be used with the filter.\n        SecurityManager securityManager = factory.getInstance();\n        if (!(securityManager instanceof WebSecurityManager)) {\n            String msg = \"The configured security manager is not an instance of WebSecurityManager, so \" +\n                    \"it can not be used with the Shiro servlet filter.\";\n            throw new ConfigurationException(msg);\n        }\n\n        setSecurityManager((WebSecurityManager) securityManager);\n\n        return factory.getBeans();\n    }\n\n    protected void applyFilterChainResolver(Ini ini, Map<String, ?> defaults) {\n        if (ini == null || ini.isEmpty()) {\n            //nothing to use to create the resolver, just return\n            //(the AbstractShiroFilter allows a null resolver, in which case the original FilterChain is\n            // always used).\n            return;\n        }\n\n        //only create a resolver if the 'filters' or 'urls' sections are defined:\n        Ini.Section urls = ini.getSection(IniFilterChainResolverFactory.URLS);\n        Ini.Section filters = ini.getSection(IniFilterChainResolverFactory.FILTERS);\n        if ((urls != null && !urls.isEmpty()) || (filters != null && !filters.isEmpty())) {\n            //either the urls section or the filters section was defined.  Go ahead and create the resolver\n            //and set it:\n            IniFilterChainResolverFactory filterChainResolverFactory = new IniFilterChainResolverFactory(ini, defaults);\n            filterChainResolverFactory.setFilterConfig(getFilterConfig());\n            FilterChainResolver resolver = filterChainResolverFactory.getInstance();\n            setFilterChainResolver(resolver);\n        }\n    }\n\n    protected Ini convertConfigToIni(String config) {\n        Ini ini = new Ini();\n        ini.load(config);\n        return ini;\n    }\n\n    /**\n     * Returns the INI instance reflecting the specified servlet context resource path or {@code null} if no\n     * resource was found.\n     *\n     * @param servletContextPath the servlet context resource path of the INI file to load\n     * @return the INI instance reflecting the specified servlet context resource path or {@code null} if no\n     *         resource was found.\n     * @since 1.2\n     */\n    protected Ini getServletContextIniResource(String servletContextPath) {\n        String path = WebUtils.normalize(servletContextPath);\n        if (getServletContext() != null) {\n            InputStream is = getServletContext().getResourceAsStream(path);\n            if (is != null) {\n                Ini ini = new Ini();\n                ini.load(is);\n                if (CollectionUtils.isEmpty(ini)) {\n                    log.warn(\"ServletContext INI resource '\" + servletContextPath + \"' exists, but it did not contain \" +\n                            \"any data.\");\n                }\n                return ini;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified file path to an {@link Ini} instance.\n     * <p/>\n     * If the path does not have a resource prefix as defined by {@link ResourceUtils#hasResourcePrefix(String)}, the\n     * path is expected to be resolvable by the {@code ServletContext} via\n     * {@link javax.servlet.ServletContext#getResourceAsStream(String)}.\n     *\n     * @param path the path of the INI resource to load into an INI instance.\n     * @return an INI instance populated based on the given INI resource path.\n     */\n    protected Ini convertPathToIni(String path) {\n\n        Ini ini = new Ini();\n\n        //SHIRO-178: Check for servlet context resource and not\n        //only resource paths:\n        if (!ResourceUtils.hasResourcePrefix(path)) {\n            ini = getServletContextIniResource(path);\n            if (ini == null) {\n                String msg = \"There is no servlet context resource corresponding to configPath '\" + path + \"'  If \" +\n                        \"the resource is located elsewhere (not immediately resolveable in the servlet context), \" +\n                        \"specify an appropriate classpath:, url:, or file: resource prefix accordingly.\";\n                throw new ConfigurationException(msg);\n            }\n        } else {\n            //normal resource path - load as usual:\n            ini.loadFromPath(path);\n        }\n\n        return ini;\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.servlet;\n\nimport org.apache.shiro.config.ConfigurationException;\nimport org.apache.shiro.config.Ini;\nimport org.apache.shiro.config.IniFactorySupport;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.web.config.IniFilterChainResolverFactory;\nimport org.apache.shiro.web.config.WebIniSecurityManagerFactory;\nimport org.apache.shiro.web.filter.mgt.FilterChainResolver;\nimport org.apache.shiro.web.mgt.WebSecurityManager;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Map;\n\n/**\n * Main Servlet Filter that configures and enables all Shiro functions within a web application by using the\n * <a href=\"http://en.wikipedia.org/wiki/INI_file\">INI<\/a> configuration format.\n * <p/>\n * The following is a fully commented example that documents how to configure it:\n * <pre>&lt;filter&gt;\n * &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;\n * &lt;filter-class&gt;org.apache.shiro.web.servlet.IniShiroFilter&lt;/filter-class&gt;\n * &lt;init-param&gt;&lt;param-name&gt;config&lt;/param-name&gt;&lt;param-value&gt;\n * #\n * #NOTE:  This config looks pretty long - but its not - its only a few lines of actual config.\n * #       Everything else is just heavily commented to explain things in-depth. Feel free to delete any\n * #       comments that you don't want to read from your own configuration ;)\n * #\n * # Any commented values below that _don't_ start with 'example.pkg' are Shiro's defaults.  If you want to change any\n * # values on those lines, you only need to uncomment the lines you want to change.\n * #\n * [main]\n * # The 'main' section defines Shiro-wide configuration.\n * #\n * # Each section's configuration is essentially an object graph definition in a .properties style (name/value pair)\n * # format.  The beans defined would be those that are used to construct the application's SecurityManager.  It is\n * # essentially 'poor man's' dependency injection via a .properties format.\n * #\n * # --- Defining Realms ---\n * #\n * # Any Realm defined here will automatically be injected into Shiro's default SecurityManager created at start up.\n * # For example:\n * #\n * # myRealm = example.pkg.security.MyRealm\n * #\n * # This would instantiate the example.pkg.security.MyRealm class with a default no-arg constructor and inject it into\n * # the SecurityManager.  More than one realm can be defined if needed.  You can create graphs and reference\n * # other beans ('$' bean reference notation) while defining Realms and other objects:\n * #\n * # <b>connectionFactory<\/b> = example.pkg.ConnectionFactory\n * # connectionFactory.driverClassName = a.jdbc.Driver\n * # connectionFactory.username = aUsername\n * # connectionFactory.password = aPassword\n * # connectionFactory.minConnections = 3\n * # connectionFactory.maxConnections = 10\n * # ... etc...\n * #\n * # myJdbcRealm = example.pkg.jdbc.MyJdbcRealm\n * # myJdbcRealm.connectionFactory = <b>$connectionFactory<\/b>\n * # ... etc ...\n * #\n * # --- Realm Factories ---\n * #\n * # If the INI style isn't robust enough for your needs, you also have the option of implementing the\n * # {@link org.apache.shiro.realm.RealmFactory org.apache.shiro.realm.RealmFactory} interface with more complex construction\n * # logic.  Then you can declare the implementation here instead.  The realms it returns will be injected in to the\n * # SecurityManager just as the individual Realms are.  For example:\n * #\n * # aRealmFactory = example.pkg.ClassThatImplementsRealmFactory\n * #\n * # --- SessionManager properties ---\n * #\n * # Except for Realms and RealmFactories, all other objects should be defined and set on the SecurityManager directly.\n * # The default 'securityManager' bean is an instance of {@link org.apache.shiro.web.mgt.DefaultWebSecurityManager}, so you\n * # can set any of its corresponding properties as necessary:\n * #\n * # someObject = some.fully.qualified.ClassName\n * # someObject.propertyN = foo\n * # ...\n * # securityManager.someObject = $someObject\n * #\n * # For example, if you wanted to change Shiro's default session mechanism, you can change the 'sessionMode' property.\n * # By default, Shiro's Session infrastructure in a web environment will use the\n * # Servlet container's HttpSession.  However, if you need to share session state across client types\n * # (e.g. Web MVC plus Java Web Start or Flash), or are doing distributed/shared Sessions for\n * # Single Sign On, HttpSessions aren't good enough.  You'll need to use Shiro's more powerful\n * # (and client-agnostic) session management.  You can enable this by uncommenting the following line\n * # and changing 'http' to 'native'\n * #\n * #securityManager.{@link org.apache.shiro.web.mgt.DefaultWebSecurityManager#setSessionMode(String) sessionMode} = http\n * #\n * [filters]\n * # This section defines the 'pool' of all Filters available to the url path definitions in the [urls] section below.\n * #\n * # The following commented values are already provided by Shiro by default and are immediately usable\n * # in the [urls] definitions below.  If you like, you may override any values by uncommenting only the lines\n * # you need to change.\n * #\n * # Each Filter is configured based on its functionality and/or protocol.  You should read each\n * # Filter's JavaDoc to fully understand what each does and how it works as well as how it would\n * # affect the user experience.\n * #\n * # Form-based Authentication filter:\n * #<a name=\"authc\"><\/a>authc = {@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter}\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setLoginUrl(String) loginUrl} = /login.jsp\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setUsernameParam(String) usernameParam} = username\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setPasswordParam(String) passwordParam} = password\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setRememberMeParam(String) rememberMeParam} = rememberMe\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setSuccessUrl(String) successUrl}  = /login.jsp\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setFailureKeyAttribute(String) failureKeyAttribute} = {@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#DEFAULT_ERROR_KEY_ATTRIBUTE_NAME}\n * #\n * # Http BASIC Authentication filter:\n * #<a name=\"authcBasic\"><\/a>authcBasic = {@link org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter}\n * #authcBasic.{@link org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter#setApplicationName(String) applicationName} = application\n * #\n * # Roles filter: requires the requesting user to have one or more roles for the request to continue.\n * # If they do not have the specified roles, they are redirected to the specified URL.\n * #<a name=\"roles\"><\/a>roles = {@link org.apache.shiro.web.filter.authz.RolesAuthorizationFilter}\n * #roles.{@link org.apache.shiro.web.filter.authz.RolesAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.\n * #\n * # Permissions filter: requires the requesting user to have one or more permissions for the request to\n * # continue, and if they do not, redirects them to the specified URL.\n * #<a name=\"perms\"><\/a>perms = {@link org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter}\n * #perms.{@link org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.  Many\n * # applications like to use the same url specified in roles.unauthorizedUrl above.\n * #\n * #\n * # Define your own filters here as you would any other object as described in the '[main]' section above (properties,\n * # $references, etc).  To properly handle url path matching (see the [urls] section below), your\n * # filter should extend the {@link org.apache.shiro.web.filter.PathMatchingFilter PathMatchingFilter} abstract class.\n * #\n * [urls]\n * # This section defines url path mappings.  Each mapping entry must be on a single line and conform to the\n * # following representation:\n * #\n * # ant_path_expression = path_specific_filter_chain_definition\n * #\n * # For any request that matches a specified path, the corresponding value defines a comma-delimited chain of\n * # filters to execute for that request.\n * #\n * # This is incredibly powerful in that you can define arbitrary filter chains for any given request pattern\n * # to greatly customize the security experience.\n * #\n * # The path_specific_filter_chain_definition must match the following format:\n * #\n * # filter1[optional_config1], filter2[optional_config2], ..., filterN[optional_configN]\n * #\n * # where 'filterN' is the name of an filter defined above in the [filters] section and\n * # '[optional_configN]' is an optional bracketed string that has meaning for that particular filter for\n * # _that particular path_.  If the filter does not need specific config for that url path, you may\n * # discard the brackets so filterN[] just becomes filterN.\n * #\n * # And because filter tokens define chains, order matters!  Define the tokens for each path pattern\n * # in the order you want them to filter (comma-delimited).\n * #\n * # Finally, each filter is free to handle the response however it wants if its necessary\n * # conditions are not met (redirect, HTTP error code, direct rendering, etc).  Otherwise, it is expected to allow\n * # the request to continue through the chain on to the final destination view.\n * #\n * # Examples:\n * #\n * # To illustrate chain configuration, look at the /account/** mapping below.  This says\n * # &quot;apply the above 'authcBasic' filter to any request matching the '/account/**' pattern&quot;.  Since the\n * # 'authcBasic' filter does not need any path-specific config, it doesn't have any config brackets [].\n * #\n * # The /remoting/** definition on the other hand uses the 'roles' and 'perms' filters which do use\n * # bracket notation.  That definition says:\n * #\n * # &quot;To access /remoting/** urls, ensure that the user is first authenticated ('authcBasic'), then ensure that user\n * # has the 'b2bClient' role, and then finally ensure that they have the 'remote:invoke:lan,wan' permission.&quot;\n * #\n * # (Note that because elements within brackets [ ] are comma-delimited themselves, we needed to quote any config\n * # value which may require a comma. If we didn't do that, the permission filter below would interpret\n * # the text between the brackets as two permissions: 'remote:invoke:lan' and 'wan' instead of the\n * # single desired 'remote:invoke:lan,wan' token.  So, you can use quotes wherever you need to escape internal\n * # commas.)\n * #\n * /account/** = <a href=\"#authcBasic\">authcBasic<\/a>\n * /remoting/** = <a href=\"#authcBasic\">authcBasic<\/a>, <a href=\"#roles\">roles<\/a>[b2bClient], <a href=\"#perms\">perms<\/a>[\"remote:invoke:lan,wan\"]\n * &lt;/param-value&gt;&lt;/init-param&gt;\n * &lt;/filter&gt;\n * <p/>\n * &lt;filter-mapping&gt;\n *     &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;\n *     &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n * &lt;/filter-mapping&gt;<\/pre>\n *\n * @since 1.0\n */\npublic class IniShiroFilter extends AbstractShiroFilter {\n\n    public static final String CONFIG_INIT_PARAM_NAME = \"config\";\n    public static final String CONFIG_PATH_INIT_PARAM_NAME = \"configPath\";\n\n    private static final Logger log = LoggerFactory.getLogger(IniShiroFilter.class);\n\n    private String config;\n    private String configPath;\n\n    public IniShiroFilter() {\n    }\n\n    /**\n     * Returns the actual INI configuration text to use to build the {@link SecurityManager} and\n     * {@link FilterChainResolver} used by the web application or {@code null} if the\n     * {@link #getConfigPath() configPath} should be used to load a fallback INI source.\n     * <p/>\n     * This value is {@code null} by default, but it will be automatically set to the value of the\n     * '{@code config}' {@code init-param} if it exists in the {@code FilterConfig} provided by the servlet\n     * container at startup.\n     *\n     * @return the actual INI configuration text to use to build the {@link SecurityManager} and\n     *         {@link FilterChainResolver} used by the web application or {@code null} if the\n     *         {@link #getConfigPath() configPath} should be used to load a fallback INI source.\n     */\n    public String getConfig() {\n        return this.config;\n    }\n\n    /**\n     * Sets the actual INI configuration text to use to build the {@link SecurityManager} and\n     * {@link FilterChainResolver} used by the web application.  If this value is {@code null}, the\n     * {@link #getConfigPath() configPath} will be checked to see if a .ini file should be loaded instead.\n     * <p/>\n     * This value is {@code null} by default, but it will be automatically set to the value of the\n     * '{@code config}' {@code init-param} if it exists in the {@code FilterConfig} provided by the servlet\n     * container at startup.\n     *\n     * @param config the actual INI configuration text to use to build the {@link SecurityManager} and\n     *               {@link FilterChainResolver} used by the web application.\n     */\n    public void setConfig(String config) {\n        this.config = config;\n    }\n\n    /**\n     * Returns the config path to be used to load a .ini file for configuration if a configuration is\n     * not specified via the {@link #getConfig() config} attribute.\n     * <p/>\n     * This value is {@code null} by default, but it will be automatically set to the value of the\n     * '{@code configPath}' {@code init-param} if it exists in the {@code FilterConfig} provided by the servlet\n     * container at startup.\n     *\n     * @return the config path to be used to load a .ini file for configuration if a configuration is\n     *         not specified via the {@link #getConfig() config} attribute.\n     */\n    public String getConfigPath() {\n        return configPath;\n    }\n\n    /**\n     * Sets the config path to be used to load a .ini file for configuration if a configuration is\n     * not specified via the {@link #getConfig() config} attribute.\n     * <p/>\n     * This value is {@code null} by default, but it will be automatically set to the value of the\n     * '{@code configPath}' {@code init-param} if it exists in the {@code FilterConfig} provided by the servlet\n     * container at startup.\n     *\n     * @param configPath the config path to be used to load a .ini file for configuration if a configuration is\n     *                   not specified via the {@link #getConfig() config} attribute.\n     */\n    public void setConfigPath(String configPath) {\n        this.configPath = configPath;\n    }\n\n    public void init() throws Exception {\n        applyInitParams();\n        configure();\n    }\n\n    protected void applyInitParams() throws Exception {\n        String config = getInitParam(CONFIG_INIT_PARAM_NAME);\n        if (config != null) {\n            setConfig(config);\n        }\n        String configPath = getInitParam(CONFIG_PATH_INIT_PARAM_NAME);\n        if (configPath != null) {\n            setConfigPath(configPath);\n        }\n    }\n\n    protected void configure() throws Exception {\n        Ini ini = loadIniFromConfig();\n\n        if (CollectionUtils.isEmpty(ini)) {\n            log.info(\"Null or empty configuration specified via 'config' init-param.  \" +\n                    \"Checking path-based configuration.\");\n            ini = loadIniFromPath();\n        }\n        if (CollectionUtils.isEmpty(ini)) {\n            log.info(\"Null or empty configuration specified via '\" + CONFIG_INIT_PARAM_NAME + \"' or '\" +\n                    CONFIG_PATH_INIT_PARAM_NAME + \"' filter parameters.  Trying the default \" +\n                    IniFactorySupport.DEFAULT_INI_RESOURCE_PATH + \" file.\");\n            ini = IniFactorySupport.loadDefaultClassPathIni();\n        }\n\n        Map<String, ?> objects = applySecurityManager(ini);\n        applyFilterChainResolver(ini, objects);\n    }\n\n    protected Ini loadIniFromConfig() {\n        Ini ini = null;\n        String config = getConfig();\n        if (config != null) {\n            ini = convertConfigToIni(config);\n        }\n        return ini;\n    }\n\n    protected Ini loadIniFromPath() {\n        Ini ini = null;\n        String path = getConfigPath();\n        if (path != null) {\n            ini = convertPathToIni(path);\n        }\n        return ini;\n    }\n\n    protected Map<String, ?> applySecurityManager(Ini ini) {\n        WebIniSecurityManagerFactory factory;\n        if (CollectionUtils.isEmpty(ini)) {\n            factory = new WebIniSecurityManagerFactory();\n        } else {\n            factory = new WebIniSecurityManagerFactory(ini);\n        }\n\n        // Create the security manager and check that it implements WebSecurityManager.\n        // Otherwise, it can't be used with the filter.\n        SecurityManager securityManager = factory.getInstance();\n        if (!(securityManager instanceof WebSecurityManager)) {\n            String msg = \"The configured security manager is not an instance of WebSecurityManager, so \" +\n                    \"it can not be used with the Shiro servlet filter.\";\n            throw new ConfigurationException(msg);\n        }\n\n        setSecurityManager((WebSecurityManager) securityManager);\n\n        return factory.getBeans();\n    }\n\n    protected void applyFilterChainResolver(Ini ini, Map<String, ?> defaults) {\n        if (ini == null || ini.isEmpty()) {\n            //nothing to use to create the resolver, just return\n            //(the AbstractShiroFilter allows a null resolver, in which case the original FilterChain is\n            // always used).\n            return;\n        }\n\n        //only create a resolver if the 'filters' or 'urls' sections are defined:\n        Ini.Section urls = ini.getSection(IniFilterChainResolverFactory.URLS);\n        Ini.Section filters = ini.getSection(IniFilterChainResolverFactory.FILTERS);\n        if ((urls != null && !urls.isEmpty()) || (filters != null && !filters.isEmpty())) {\n            //either the urls section or the filters section was defined.  Go ahead and create the resolver\n            //and set it:\n            IniFilterChainResolverFactory filterChainResolverFactory = new IniFilterChainResolverFactory(ini, defaults);\n            filterChainResolverFactory.setFilterConfig(getFilterConfig());\n            FilterChainResolver resolver = filterChainResolverFactory.getInstance();\n            setFilterChainResolver(resolver);\n        }\n    }\n\n    protected Ini convertConfigToIni(String config) {\n        Ini ini = new Ini();\n        ini.load(config);\n        return ini;\n    }\n\n    protected Ini convertPathToIni(String path) {\n        Ini ini = new Ini();\n        ini.loadFromPath(path);\n        return ini;\n    }\n}\n","lineNo":177}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.tools.hasher;\n\nimport org.apache.commons.cli.*;\nimport org.apache.shiro.codec.Base64;\nimport org.apache.shiro.codec.Hex;\nimport org.apache.shiro.crypto.SecureRandomNumberGenerator;\nimport org.apache.shiro.crypto.UnknownAlgorithmException;\nimport org.apache.shiro.crypto.hash.SimpleHash;\nimport org.apache.shiro.io.ResourceUtils;\nimport org.apache.shiro.util.ByteSource;\nimport org.apache.shiro.util.JavaEnvironment;\nimport org.apache.shiro.util.SimpleByteSource;\nimport org.apache.shiro.util.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Arrays;\n\n/**\n * Commandline line utility to hash data such as strings, passwords, resources (files, urls, etc).\n * <p/>\n * Usage:\n * <pre>\n * java -jar shiro-tools-hasher<em>-version<\/em>-cli.jar\n * <\/pre>\n * This will print out all supported options with documentation.\n *\n * @since 1.2\n */\npublic final class Hasher {\n\n    private static final Option ALGORITHM = new Option(\"a\", \"algorithm\", true, \"hash algorithm name.  Defaults to MD5.\");\n    private static final Option DEBUG = new Option(\"d\", \"debug\", false, \"show additional error (stack trace) information.\");\n    private static final Option HELP = new Option(\"help\", \"help\", false, \"show this help message.\");\n    private static final Option HEX = new Option(\"h\", \"hex\", false, \"display a hex value instead of Base64.\");\n    private static final Option ITERATIONS = new Option(\"i\", \"iterations\", true, \"number of hash iterations.  Defaults to 1.\");\n    private static final Option NO_FORMAT = new Option(\"nf\", \"noformat\", false, \"turn off output formatting.  Any generated salt will be placed after the hash separated by a space.\");\n    private static final Option PASSWORD = new Option(\"p\", \"password\", false, \"hash a password (disable typing echo)\");\n    private static final Option PASSWORD_NC = new Option(\"pnc\", \"pnoconfirm\", false, \"disable password hash confirmation prompt.\");\n    private static final Option RESOURCE = new Option(\"r\", \"resource\", false, \"read and hash the resource located at <value>.  See below for more information.\");\n    private static final Option SALT = new Option(\"s\", \"salt\", true, \"use the specified salt.  <arg> is plaintext.\");\n    private static final Option SALT_BYTES = new Option(\"sb\", \"saltbytes\", true, \"use the specified salt bytes.  <arg> is hex or base64 encoded text.\");\n    private static final Option SALT_GEN = new Option(\"gs\", \"gensalt\", false, \"generate and use a random salt.\");\n    private static final Option SALT_GEN_HEX = new Option(\"gsh\", \"gensalthex\", false, \"display the generated salt's hex value instead of Base64.\");\n    private static final Option SALT_GEN_SIZE = new Option(\"gss\", \"gensaltsize\", true, \"the number of salt bits (not bytes!) to generate.  Defaults to 128.\");\n    private static final Option SHIRO = new Option(\"shiro\", \"shiro\", false, \"display output in the Shiro password file format (.ini [users] config).\");\n\n    private static final String HEX_PREFIX = \"0x\";\n    private static final String DEFAULT_ALGORITHM_NAME = \"MD5\";\n    private static final int DEFAULT_GENERATED_SALT_SIZE = 128;\n    private static final int DEFAULT_NUM_ITERATIONS = 1;\n    private static final String SALT_MUTEX_MSG = createMutexMessage(SALT, SALT_BYTES);\n\n\n    public static void main(String[] args) {\n\n        CommandLineParser parser = new PosixParser();\n\n        Options options = new Options();\n        options.addOption(HELP).addOption(DEBUG).addOption(ALGORITHM).addOption(HEX).addOption(ITERATIONS);\n        options.addOption(RESOURCE).addOption(PASSWORD).addOption(PASSWORD_NC);\n        options.addOption(SALT).addOption(SALT_BYTES).addOption(SALT_GEN).addOption(SALT_GEN_SIZE).addOption(SALT_GEN_HEX);\n        options.addOption(NO_FORMAT).addOption(SHIRO);\n\n        boolean debug = false;\n        String algorithm = DEFAULT_ALGORITHM_NAME;\n        int iterations = DEFAULT_NUM_ITERATIONS;\n        boolean base64 = true;\n        boolean resource = false;\n        boolean password = false;\n        boolean passwordConfirm = true;\n        String saltString = null;\n        String saltBytesString = null;\n        boolean generateSalt = false;\n        boolean generatedSaltBase64 = true;\n        int generatedSaltSize = DEFAULT_GENERATED_SALT_SIZE;\n\n        boolean shiroFormat = false;\n        boolean format = true;\n\n        char[] passwordChars = null;\n\n        try {\n            CommandLine line = parser.parse(options, args);\n\n            if (line.hasOption(HELP.getOpt())) {\n                printHelpAndExit(options, null, debug, 0);\n            }\n            if (line.hasOption(DEBUG.getOpt())) {\n                debug = true;\n            }\n            if (line.hasOption(ALGORITHM.getOpt())) {\n                algorithm = line.getOptionValue(ALGORITHM.getOpt());\n            }\n            if (line.hasOption(ITERATIONS.getOpt())) {\n                iterations = getRequiredPositiveInt(line, ITERATIONS);\n            }\n            if (line.hasOption(HEX.getOpt())) {\n                base64 = false;\n            }\n            if (line.hasOption(PASSWORD.getOpt())) {\n                password = true;\n            }\n            if (line.hasOption(RESOURCE.getOpt())) {\n                resource = true;\n            }\n            if (line.hasOption(PASSWORD_NC.getOpt())) {\n                passwordConfirm = false;\n            }\n            if (line.hasOption(SALT.getOpt())) {\n                saltString = line.getOptionValue(SALT.getOpt());\n            }\n            if (line.hasOption(SALT_BYTES.getOpt())) {\n                saltBytesString = line.getOptionValue(SALT_BYTES.getOpt());\n            }\n            if (line.hasOption(SALT_GEN.getOpt())) {\n                generateSalt = true;\n            }\n            if (line.hasOption(SALT_GEN_HEX.getOpt())) {\n                generateSalt = true;\n                generatedSaltBase64 = false;\n            }\n            if (line.hasOption(SALT_GEN_SIZE.getOpt())) {\n                generateSalt = true;\n                generatedSaltSize = getRequiredPositiveInt(line, SALT_GEN_SIZE);\n                if (generatedSaltSize % 8 != 0) {\n                    throw new IllegalArgumentException(\"Generated salt size must be a multiple of 8 (e.g. 128, 192, 256, 512, etc).\");\n                }\n            }\n            if (line.hasOption(NO_FORMAT.getOpt())) {\n                format = false;\n            }\n            if (line.hasOption(SHIRO.getOpt())) {\n                shiroFormat = true;\n            }\n\n            String sourceValue = null;\n\n            Object source;\n\n            if (password) {\n                passwordChars = readPassword(passwordConfirm);\n                source = passwordChars;\n            } else {\n                String[] remainingArgs = line.getArgs();\n                if (remainingArgs == null || remainingArgs.length != 1) {\n                    printHelpAndExit(options, null, debug, -1);\n                }\n\n                assert remainingArgs != null;\n                sourceValue = toString(remainingArgs);\n\n                if (resource) {\n                    if (!ResourceUtils.hasResourcePrefix(sourceValue)) {\n                        source = toFile(sourceValue);\n                    } else {\n                        source = ResourceUtils.getInputStreamForPath(sourceValue);\n                    }\n                } else {\n                    source = sourceValue;\n                }\n            }\n\n            ByteSource salt = getSalt(saltString, saltBytesString, generateSalt, generatedSaltSize);\n\n            SimpleHash hash = new SimpleHash(algorithm, source, salt, iterations);\n\n            StringBuilder output;\n            if (shiroFormat) {\n                output = formatForShiroIni(hash, base64, salt, generatedSaltBase64, generateSalt);\n            } else if (format) {\n                output = format(hash, base64, salt, generatedSaltBase64, generateSalt, algorithm, sourceValue);\n            } else {\n                output = formatMinimal(hash, base64, salt, generatedSaltBase64, generateSalt);\n            }\n\n            System.out.println(output);\n\n        } catch (IllegalArgumentException iae) {\n            exit(iae, debug);\n        } catch (UnknownAlgorithmException uae) {\n            exit(uae, debug);\n        } catch (IOException ioe) {\n            exit(ioe, debug);\n        } catch (Exception e) {\n            printHelpAndExit(options, e, debug, -1);\n        } finally {\n            if (passwordChars != null && passwordChars.length > 0) {\n                for (int i = 0; i < passwordChars.length; i++) {\n                    passwordChars[i] = ' ';\n                }\n            }\n        }\n    }\n\n    private static String createMutexMessage(Option... options) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"The \");\n\n        for (int i = 0; i < options.length; i++) {\n            if (i > 0) {\n                sb.append(\", \");\n            }\n            Option o = options[0];\n            sb.append(\"-\").append(o.getOpt()).append(\"/--\").append(o.getLongOpt());\n        }\n        sb.append(\" and generated salt options are mutually exclusive.  Only one of them may be used at a time\");\n        return sb.toString();\n    }\n\n    private static void exit(Exception e, boolean debug) {\n        printException(e, debug);\n        System.exit(-1);\n    }\n\n    private static StringBuilder format(ByteSource hash, boolean hashBase64, ByteSource salt, boolean saltBase64, boolean showSalt, String alg, String value) {\n        StringBuilder sb = new StringBuilder();\n\n        sb.append(alg).append(\"(\").append(value).append(\")\");\n\n        if (hashBase64) {\n            sb.append(\" base64 = \").append(hash.toBase64());\n        } else {\n            sb.append(\" hex = \").append(hash.toHex());\n        }\n\n        if (showSalt && salt != null) {\n            sb.append(\"\\nGenerated salt\");\n            if (saltBase64) {\n                sb.append(\" base64 = \").append(salt.toBase64());\n            } else {\n                sb.append(\" hex = \").append(salt.toHex());\n            }\n        }\n\n        return sb;\n    }\n\n    private static StringBuilder formatForShiroIni(ByteSource hash, boolean hashBase64, ByteSource salt, boolean saltBase64, boolean showSalt) {\n        StringBuilder sb = new StringBuilder();\n\n        if (hashBase64) {\n            sb.append(hash.toBase64());\n        } else {\n            //hex:\n            sb.append(HEX_PREFIX).append(hash.toHex());\n        }\n\n        if (showSalt && salt != null) {\n            sb.append(\" \");\n            if (saltBase64) {\n                sb.append(salt.toBase64());\n            } else {\n                //hex:\n                sb.append(HEX_PREFIX).append(salt.toHex());\n            }\n        }\n        return sb;\n    }\n\n    private static StringBuilder formatMinimal(ByteSource hash, boolean hashBase64, ByteSource salt, boolean saltBase64, boolean showSalt) {\n        StringBuilder sb = new StringBuilder();\n\n        if (hashBase64) {\n            sb.append(hash.toBase64());\n        } else {\n            sb.append(hash.toHex());\n        }\n\n        if (showSalt && salt != null) {\n            sb.append(\" \");\n            if (saltBase64) {\n                sb.append(salt.toBase64());\n            } else {\n                sb.append(salt.toHex());\n            }\n        }\n\n        return sb;\n    }\n\n    private static int getRequiredPositiveInt(CommandLine line, Option option) {\n        String iterVal = line.getOptionValue(option.getOpt());\n        try {\n            return Integer.parseInt(iterVal);\n        } catch (NumberFormatException e) {\n            String msg = \"'\" + option.getLongOpt() + \"' value must be a positive integer.\";\n            throw new IllegalArgumentException(msg, e);\n        }\n    }\n\n    private static ByteSource getSalt(String saltString, String saltBytesString, boolean generateSalt, int generatedSaltSize) {\n\n        if (saltString != null) {\n            if (generateSalt || (saltBytesString != null)) {\n                throw new IllegalArgumentException(SALT_MUTEX_MSG);\n            }\n            return new SimpleByteSource(saltString);\n        }\n\n        if (saltBytesString != null) {\n            if (generateSalt) {\n                throw new IllegalArgumentException(SALT_MUTEX_MSG);\n            }\n\n            String value = saltBytesString;\n            boolean base64 = true;\n            if (saltBytesString.startsWith(HEX_PREFIX)) {\n                //hex:\n                base64 = false;\n                value = value.substring(HEX_PREFIX.length());\n            }\n            byte[] bytes;\n            if (base64) {\n                bytes = Base64.decode(value);\n            } else {\n                bytes = Hex.decode(value);\n            }\n            return new SimpleByteSource(bytes);\n        }\n\n        if (generateSalt) {\n            SecureRandomNumberGenerator generator = new SecureRandomNumberGenerator();\n            int byteSize = generatedSaltSize / 8; //generatedSaltSize is in *bits* - convert to byte size:\n            return generator.nextBytes(byteSize);\n        }\n\n        //no salt used:\n        return null;\n    }\n\n    private static void printException(Exception e, boolean debug) {\n        if (e != null) {\n            System.out.println();\n            if (debug) {\n                System.out.println(\"Error: \");\n                e.printStackTrace(System.out);\n                System.out.println(e.getMessage());\n\n            } else {\n                System.out.println(\"Error: \" + e.getMessage());\n                System.out.println();\n                System.out.println(\"Specify -d or --debug for more information.\");\n            }\n        }\n    }\n\n    private static void printHelp(Options options, Exception e, boolean debug) {\n        HelpFormatter help = new HelpFormatter();\n        String command = \"java -jar shiro-tools-hasher-<version>.jar [options] [<value>]\";\n        String header = \"\\nPrint a cryptographic hash (aka message digest) of the specified <value>.\\n--\\nOptions:\";\n        String footer = \"\\n\" +\n                \"<value> is optional only when hashing passwords (see below).  It is\\n\" +\n                \"required all other times.\" +\n                \"\\n\\n\" +\n                \"Password Hashing:\\n\" +\n                \"---------------------------------\\n\" +\n                \"Specify the -p/--password option and DO NOT enter a <value>.  You will\\n\" +\n                \"be prompted for a password and characters will not echo as you type.\" +\n                \"\\n\\n\" +\n                \"Salting:\\n\" +\n                \"---------------------------------\\n\" +\n                \"Specifying a salt:\" +\n                \"\\n\\n\" +\n\n                \"You may specify a salt using the -s/--salt option followed by the salt\\n\" +\n                \"value.  If the salt value is a base64 or hex string representing a\\n\" +\n                \"byte array, you must specify the -sb/--saltbytes option to indicate this,\\n\" +\n                \"otherwise the text value bytes will be used directly.\" +\n                \"\\n\\n\" +\n                \"When using -sb/--saltbytes, the -s/--salt value is expected to be a\\n\" +\n                \"base64-encoded string by default.  If the value is a hex-encoded string,\\n\" +\n                \"you must prefix the string with 0x (zero x) to indicate a hex value.\" +\n                \"\\n\\n\" +\n                \"Generating a salt:\" +\n                \"\\n\\n\" +\n                \"Use the -sg/--saltgenerated option if you don't want to specify a salt,\\n\" +\n                \"but want a strong random salt to be generated and used during hashing.\\n\" +\n                \"The generated salt size defaults to 128 bytes.  You may specify\\n\" +\n                \"a different size by using the -sgs/--saltgeneratedsize option followed by\\n\" +\n                \"a positive integer.\" +\n                \"\\n\\n\" +\n                \"Because a salt must be specified if computing the\\n\" +\n                \"hash later, generated salts will be printed, defaulting to base64\\n\" +\n                \"encoding.  If you prefer to use hex encoding, additionally use the\\n\" +\n                \"-sgh/--saltgeneratedhex option.\" +\n                \"\\n\\n\" +\n                \"Files, URLs and classpath resources:\\n\" +\n                \"---------------------------------\\n\" +\n                \"If using the -r/--resource option, the <value> represents a resource path.\\n\" +\n                \"By default this is expected to be a file path, but you may specify\\n\" +\n                \"classpath or URL resources by using the classpath: or url: prefix\\n\" +\n                \"respectively.\" +\n                \"\\n\\n\" +\n                \"Some examples:\" +\n                \"\\n\\n\" +\n                \"<command> -r fileInCurrentDirectory.txt\\n\" +\n                \"<command> -r ../../relativePathFile.xml\\n\" +\n                \"<command> -r ~/documents/myfile.pdf\\n\" +\n                \"<command> -r /usr/local/logs/absolutePathFile.log\\n\" +\n                \"<command> -r url:http://foo.com/page.html\\n\" +\n                \"<command> -r classpath:/WEB-INF/lib/something.jar\";\n\n        printException(e, debug);\n\n        System.out.println();\n        help.printHelp(command, header, options, null);\n        System.out.println(footer);\n    }\n\n    private static void printHelpAndExit(Options options, Exception e, boolean debug, int exitCode) {\n        printHelp(options, e, debug);\n        System.exit(exitCode);\n    }\n\n    private static char[] readPassword(boolean confirm) {\n        if (!JavaEnvironment.isAtLeastVersion16()) {\n            String msg = \"Password hashing (prompt without echo) uses the java.io.Console to read passwords \" +\n                    \"safely.  This is only available on Java 1.6 platforms and later.\";\n            throw new IllegalArgumentException(msg);\n        }\n        java.io.Console console = System.console();\n        if (console == null) {\n            throw new IllegalStateException(\"java.io.Console is not available on the current JVM.  Cannot read passwords.\");\n        }\n        char[] first = console.readPassword(\"%s\", \"Password to hash: \");\n        if (first == null || first.length == 0) {\n            throw new IllegalArgumentException(\"No password specified.\");\n        }\n        if (confirm) {\n            char[] second = console.readPassword(\"%s\", \"Password to hash (confirm): \");\n            if (!Arrays.equals(first, second)) {\n                String msg = \"Password entries do not match.\";\n                throw new IllegalArgumentException(msg);\n            }\n        }\n        return first;\n    }\n\n    private static File toFile(String path) {\n        String resolved = path;\n        if (path.startsWith(\"~/\") || path.startsWith((\"~\\\\\"))) {\n            resolved = path.replaceFirst(\"\\\\~\", System.getProperty(\"user.home\"));\n        }\n        return new File(resolved);\n    }\n\n    private static String toString(String[] strings) {\n        int len = strings != null ? strings.length : 0;\n        if (len == 0) {\n            return null;\n        }\n        return StringUtils.toDelimitedString(strings, \" \");\n    }\n\n    static {\n        ALGORITHM.setArgName(\"name\");\n        SALT_GEN_SIZE.setArgName(\"numBits\");\n        ITERATIONS.setArgName(\"num\");\n        SALT.setArgName(\"sval\");\n        SALT_BYTES.setArgName(\"encTxt\");\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.tools.hasher;\n\nimport org.apache.commons.cli.*;\nimport org.apache.shiro.crypto.UnknownAlgorithmException;\nimport org.apache.shiro.crypto.hash.SimpleHash;\nimport org.apache.shiro.io.ResourceUtils;\nimport org.apache.shiro.util.JavaEnvironment;\nimport org.apache.shiro.util.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Arrays;\n\n/**\n * Commandline line utility to hash data such as strings, passwords, resources (files, urls, etc).\n * <p/>\n * Usage:\n * <pre>\n * java -jar shiro-tools-hasher<em>-version<\/em>.jar\n * <\/pre>\n * This will print out all supported options with documentation.\n *\n * @since 1.2\n */\npublic final class Hasher {\n\n\n    private static final String DEFAULT_ALGORITHM_NAME = \"MD5\";\n    private static final int DEFAULT_NUM_ITERATIONS = 1;\n\n    private static final String ALG_OPT = \"a\";\n    private static final String ALG_OPT_LONG = \"algorithm\";\n    private static final String DEBUG_OPT = \"d\";\n    private static final String DEBUG_OPT_LONG = \"debug\"; //show stack traces if there are any.\n    private static final String ITER_OPT = \"i\";\n    private static final String ITER_OPT_LONG = \"iterations\";\n    private static final String HEX_OPT = \"h\";\n    private static final String HEX_OPT_LONG = \"hex\";\n    private static final String HELP_OPT = \"help\";\n    private static final String HELP_OPT_LONG = \"help\";\n    private static final String PASSWORD_OPT = \"p\";\n    private static final String PASSWORD_OPT_LONG = \"password\";\n    private static final String PASSWORD_OPT_NOCONFIRM = \"pnc\";\n    private static final String PASSWORD_OPT_NOCONFIRM_LONG = \"pnoconfirm\";\n    private static final String RESOURCE_OPT = \"r\";\n    private static final String RESOURCE_OPT_LONG = \"resource\";\n\n\n    public static void main(String[] args) {\n\n        CommandLineParser parser = new PosixParser();\n\n        Options options = new Options();\n        options.addOption(ALG_OPT, ALG_OPT_LONG, true, \"hash algorithm name.  Defaults to MD5.\");\n        options.addOption(ITER_OPT, ITER_OPT_LONG, true, \"number of hash iterations.  Defaults to 1.\");\n        options.addOption(HEX_OPT, HEX_OPT_LONG, false, \"print hex value.  Defaults to Base64.\");\n        options.addOption(HELP_OPT, HELP_OPT_LONG, false, \"print this help message.\");\n        options.addOption(DEBUG_OPT, DEBUG_OPT_LONG, false, \"show additional error (stack trace) information.\");\n        options.addOption(PASSWORD_OPT, PASSWORD_OPT_LONG, false, \"hash a password (do not echo).\");\n        options.addOption(RESOURCE_OPT, RESOURCE_OPT_LONG, false, \"read and hash the resource located at <value>. See below for more information.\");\n        options.addOption(PASSWORD_OPT_NOCONFIRM, PASSWORD_OPT_NOCONFIRM_LONG, false, \"disable confirmation prompt for password hashing.\");\n\n        boolean debug = false;\n        String algorithm = DEFAULT_ALGORITHM_NAME;\n        int iterations = DEFAULT_NUM_ITERATIONS;\n        boolean base64 = true;\n        boolean resource = false;\n        boolean password = false;\n        boolean passwordConfirm = true;\n\n        char[] passwordChars = null;\n\n        try {\n            CommandLine line = parser.parse(options, args);\n\n            if (line.hasOption(HELP_OPT)) {\n                printHelpAndExit(options, null, debug, 0);\n            }\n            if (line.hasOption(DEBUG_OPT)) {\n                debug = true;\n            }\n            if (line.hasOption(ALG_OPT)) {\n                algorithm = line.getOptionValue(ALG_OPT);\n            }\n            if (line.hasOption(ITER_OPT)) {\n                iterations = getRequiredPositiveInt(line, ITER_OPT, ITER_OPT_LONG);\n            }\n            if (line.hasOption(HEX_OPT)) {\n                base64 = false;\n            }\n            if (line.hasOption(PASSWORD_OPT)) {\n                password = true;\n            }\n            if (line.hasOption(RESOURCE_OPT)) {\n                resource = true;\n            }\n            if (line.hasOption(PASSWORD_OPT_NOCONFIRM)) {\n                passwordConfirm = false;\n            }\n\n            Object source;\n\n            if (password) {\n                passwordChars = readPassword(passwordConfirm);\n                source = passwordChars;\n            } else {\n                String[] remainingArgs = line.getArgs();\n                if (remainingArgs == null || remainingArgs.length != 1) {\n                    printHelpAndExit(options, null, debug, -1);\n                }\n\n                assert remainingArgs != null;\n                String value = toString(remainingArgs);\n\n                if (resource) {\n                    if (!ResourceUtils.hasResourcePrefix(value)) {\n                        source = toFile(value);\n                    } else {\n                        source = ResourceUtils.getInputStreamForPath(value);\n                    }\n                } else {\n                    source = value;\n                }\n            }\n\n            SimpleHash hash = new SimpleHash(algorithm, source, /* salt not supported yet*/ null, iterations);\n            if (base64) {\n                System.out.println(hash.toBase64());\n            } else {\n                System.out.println(hash.toHex());\n            }\n        } catch (IllegalArgumentException iae) {\n            exit(iae, debug);\n        } catch (UnknownAlgorithmException uae) {\n            exit(uae, debug);\n        } catch (IOException ioe) {\n            exit(ioe, debug);\n        } catch (Exception e) {\n            printHelpAndExit(options, e, debug, -1);\n        } finally {\n            if (passwordChars != null && passwordChars.length > 0) {\n                for (int i = 0; i < passwordChars.length; i++) {\n                    passwordChars[i] = ' ';\n                }\n            }\n        }\n    }\n\n    private static String toString(String[] strings) {\n        int len = strings != null ? strings.length : 0;\n        if (len == 0) {\n            return null;\n        }\n        return StringUtils.toDelimitedString(strings, \" \");\n    }\n\n    private static int getRequiredPositiveInt(CommandLine line, String opt, String optLong) {\n        String iterVal = line.getOptionValue(opt);\n        try {\n            return Integer.parseInt(iterVal);\n        } catch (NumberFormatException e) {\n            String msg = \"'\" + optLong + \"' value must be a positive integer.\";\n            throw new IllegalArgumentException(msg, e);\n        }\n    }\n\n    private static File toFile(String path) {\n        String resolved = path;\n        if (path.startsWith(\"~/\") || path.startsWith((\"~\\\\\"))) {\n            resolved = path.replaceFirst(\"\\\\~\", System.getProperty(\"user.home\"));\n        }\n        return new File(resolved);\n    }\n\n    private static char[] readPassword(boolean confirm) {\n        if (!JavaEnvironment.isAtLeastVersion16()) {\n            String msg = \"Password hashing (prompt without echo) uses the java.io.Console to read passwords \" +\n                    \"safely.  This is only available on Java 1.6 platforms and later.\";\n            throw new IllegalArgumentException(msg);\n        }\n        java.io.Console console = System.console();\n        if (console == null) {\n            throw new IllegalStateException(\"java.io.Console is not available on the current JVM.  Cannot read passwords.\");\n        }\n        char[] first = console.readPassword(\"%s\", \"Password to hash: \");\n        if (first == null || first.length == 0) {\n            throw new IllegalArgumentException(\"No password specified.\");\n        }\n        if (confirm) {\n            char[] second = console.readPassword(\"%s\", \"Password to hash (confirm): \");\n            if (!Arrays.equals(first, second)) {\n                String msg = \"Password entries do not match.\";\n                throw new IllegalArgumentException(msg);\n            }\n        }\n        return first;\n    }\n\n    private static void printHelp(Options options, Exception e, boolean debug) {\n        HelpFormatter help = new HelpFormatter();\n        String command = \"java -jar shiro-tools-hasher-<version>.jar [options] [<value>]\";\n        String header = \"\\nPrint a cryptographic hash (aka message digest) of the specified <value>.\\n--\\nOptions:\";\n        String footer = \"\\n\" +\n                \"<value> is optional only when hashing passwords (see below).  It is\\n\" +\n                \"required all other times.\\n\\n\" +\n                \"Password Hashing:\\n--\\n\" +\n                \"Specify the -p/--password option and DO NOT enter a <value>.  You will\\n\" +\n                \"be prompted for a password and characters will not echo as you type.\\n\\n\" +\n                \"Files, URLs and classpath resources:\\n--\\n\" +\n                \"If using the -r/--resource option, the <value> represents a resource path.\\n\" +\n                \"By default this is expected to be a file path, but you may specify\\n\" +\n                \"classpath or URL resources by using the classpath: or url: prefix\\n\" +\n                \"respectively.\\n\\n\" +\n                \"Some examples:\\n\\n\" +\n                \"<command> -r fileInCurrentDirectory.txt\\n\" +\n                \"<command> -r ../../relativePathFile.xml\\n\" +\n                \"<command> -r ~/documents/myfile.pdf\\n\"+\n                \"<command> -r /usr/local/logs/absolutePathFile.log\\n\" +\n                \"<command> -r url:http://foo.com/page.html\\n\" +\n                \"<command> -r classpath:/WEB-INF/lib/something.jar\";\n\n        printException(e, debug);\n\n        System.out.println();\n        help.printHelp(command, header, options, null);\n        System.out.println(footer);\n    }\n\n    private static void exit(Exception e, boolean debug) {\n        printException(e, debug);\n        System.exit(-1);\n    }\n\n    private static void printException(Exception e, boolean debug) {\n        if (e != null) {\n            System.out.println();\n            if (debug) {\n                System.out.println(\"Error: \");\n                e.printStackTrace(System.out);\n                System.out.println(e.getMessage());\n\n            } else {\n                System.out.println(\"Error: \" + e.getMessage());\n                System.out.println();\n                System.out.println(\"Specify -d or --debug for more information.\");\n            }\n        }\n    }\n\n    private static void printHelpAndExit(Options options, Exception e, boolean debug, int exitCode) {\n        printHelp(options, e, debug);\n        System.exit(exitCode);\n    }\n}\n","lineNo":90}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.tools.hasher;\n\nimport org.apache.commons.cli.*;\nimport org.apache.shiro.codec.Base64;\nimport org.apache.shiro.codec.Hex;\nimport org.apache.shiro.crypto.SecureRandomNumberGenerator;\nimport org.apache.shiro.crypto.UnknownAlgorithmException;\nimport org.apache.shiro.crypto.hash.SimpleHash;\nimport org.apache.shiro.io.ResourceUtils;\nimport org.apache.shiro.util.ByteSource;\nimport org.apache.shiro.util.JavaEnvironment;\nimport org.apache.shiro.util.SimpleByteSource;\nimport org.apache.shiro.util.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Arrays;\n\n/**\n * Commandline line utility to hash data such as strings, passwords, resources (files, urls, etc).\n * <p/>\n * Usage:\n * <pre>\n * java -jar shiro-tools-hasher<em>-version<\/em>-cli.jar\n * <\/pre>\n * This will print out all supported options with documentation.\n *\n * @since 1.2\n */\npublic final class Hasher {\n\n    private static final Option ALGORITHM = new Option(\"a\", \"algorithm\", true, \"hash algorithm name.  Defaults to MD5.\");\n    private static final Option DEBUG = new Option(\"d\", \"debug\", false, \"show additional error (stack trace) information.\");\n    private static final Option HELP = new Option(\"help\", \"help\", false, \"show this help message.\");\n    private static final Option HEX = new Option(\"h\", \"hex\", false, \"display a hex value instead of Base64.\");\n    private static final Option ITERATIONS = new Option(\"i\", \"iterations\", true, \"number of hash iterations.  Defaults to 1.\");\n    private static final Option NO_FORMAT = new Option(\"nf\", \"noformat\", false, \"turn off output formatting.  Any generated salt will be placed after the hash separated by a space.\");\n    private static final Option PASSWORD = new Option(\"p\", \"password\", false, \"hash a password (disable typing echo)\");\n    private static final Option PASSWORD_NC = new Option(\"pnc\", \"pnoconfirm\", false, \"disable password hash confirmation prompt.\");\n    private static final Option RESOURCE = new Option(\"r\", \"resource\", false, \"read and hash the resource located at <value>.  See below for more information.\");\n    private static final Option SALT = new Option(\"s\", \"salt\", true, \"use the specified salt.  <arg> is plaintext.\");\n    private static final Option SALT_BYTES = new Option(\"sb\", \"saltbytes\", true, \"use the specified salt bytes.  <arg> is hex or base64 encoded text.\");\n    private static final Option SALT_GEN = new Option(\"gs\", \"gensalt\", false, \"generate and use a random salt.\");\n    private static final Option SALT_GEN_HEX = new Option(\"gsh\", \"gensalthex\", false, \"display the generated salt's hex value instead of Base64.\");\n    private static final Option SALT_GEN_SIZE = new Option(\"gss\", \"gensaltsize\", true, \"the number of salt bits (not bytes!) to generate.  Defaults to 128.\");\n    private static final Option SHIRO = new Option(\"shiro\", \"shiro\", false, \"display output in the Shiro password file format (.ini [users] config).\");\n\n    private static final String HEX_PREFIX = \"0x\";\n    private static final String DEFAULT_ALGORITHM_NAME = \"MD5\";\n    private static final int DEFAULT_GENERATED_SALT_SIZE = 128;\n    private static final int DEFAULT_NUM_ITERATIONS = 1;\n    private static final String SALT_MUTEX_MSG = createMutexMessage(SALT, SALT_BYTES);\n\n\n    public static void main(String[] args) {\n\n        CommandLineParser parser = new PosixParser();\n\n        Options options = new Options();\n        options.addOption(HELP).addOption(DEBUG).addOption(ALGORITHM).addOption(HEX).addOption(ITERATIONS);\n        options.addOption(RESOURCE).addOption(PASSWORD).addOption(PASSWORD_NC);\n        options.addOption(SALT).addOption(SALT_BYTES).addOption(SALT_GEN).addOption(SALT_GEN_SIZE).addOption(SALT_GEN_HEX);\n        options.addOption(NO_FORMAT).addOption(SHIRO);\n\n        boolean debug = false;\n        String algorithm = DEFAULT_ALGORITHM_NAME;\n        int iterations = DEFAULT_NUM_ITERATIONS;\n        boolean base64 = true;\n        boolean resource = false;\n        boolean password = false;\n        boolean passwordConfirm = true;\n        String saltString = null;\n        String saltBytesString = null;\n        boolean generateSalt = false;\n        boolean generatedSaltBase64 = true;\n        int generatedSaltSize = DEFAULT_GENERATED_SALT_SIZE;\n\n        boolean shiroFormat = false;\n        boolean format = true;\n\n        char[] passwordChars = null;\n\n        try {\n            CommandLine line = parser.parse(options, args);\n\n            if (line.hasOption(HELP.getOpt())) {\n                printHelpAndExit(options, null, debug, 0);\n            }\n            if (line.hasOption(DEBUG.getOpt())) {\n                debug = true;\n            }\n            if (line.hasOption(ALGORITHM.getOpt())) {\n                algorithm = line.getOptionValue(ALGORITHM.getOpt());\n            }\n            if (line.hasOption(ITERATIONS.getOpt())) {\n                iterations = getRequiredPositiveInt(line, ITERATIONS);\n            }\n            if (line.hasOption(HEX.getOpt())) {\n                base64 = false;\n            }\n            if (line.hasOption(PASSWORD.getOpt())) {\n                password = true;\n            }\n            if (line.hasOption(RESOURCE.getOpt())) {\n                resource = true;\n            }\n            if (line.hasOption(PASSWORD_NC.getOpt())) {\n                passwordConfirm = false;\n            }\n            if (line.hasOption(SALT.getOpt())) {\n                saltString = line.getOptionValue(SALT.getOpt());\n            }\n            if (line.hasOption(SALT_BYTES.getOpt())) {\n                saltBytesString = line.getOptionValue(SALT_BYTES.getOpt());\n            }\n            if (line.hasOption(SALT_GEN.getOpt())) {\n                generateSalt = true;\n            }\n            if (line.hasOption(SALT_GEN_HEX.getOpt())) {\n                generateSalt = true;\n                generatedSaltBase64 = false;\n            }\n            if (line.hasOption(SALT_GEN_SIZE.getOpt())) {\n                generateSalt = true;\n                generatedSaltSize = getRequiredPositiveInt(line, SALT_GEN_SIZE);\n                if (generatedSaltSize % 8 != 0) {\n                    throw new IllegalArgumentException(\"Generated salt size must be a multiple of 8 (e.g. 128, 192, 256, 512, etc).\");\n                }\n            }\n            if (line.hasOption(NO_FORMAT.getOpt())) {\n                format = false;\n            }\n            if (line.hasOption(SHIRO.getOpt())) {\n                shiroFormat = true;\n            }\n\n            String sourceValue = null;\n\n            Object source;\n\n            if (password) {\n                passwordChars = readPassword(passwordConfirm);\n                source = passwordChars;\n            } else {\n                String[] remainingArgs = line.getArgs();\n                if (remainingArgs == null || remainingArgs.length != 1) {\n                    printHelpAndExit(options, null, debug, -1);\n                }\n\n                assert remainingArgs != null;\n                sourceValue = toString(remainingArgs);\n\n                if (resource) {\n                    if (!ResourceUtils.hasResourcePrefix(sourceValue)) {\n                        source = toFile(sourceValue);\n                    } else {\n                        source = ResourceUtils.getInputStreamForPath(sourceValue);\n                    }\n                } else {\n                    source = sourceValue;\n                }\n            }\n\n            ByteSource salt = getSalt(saltString, saltBytesString, generateSalt, generatedSaltSize);\n\n            SimpleHash hash = new SimpleHash(algorithm, source, salt, iterations);\n\n            StringBuilder output;\n            if (shiroFormat) {\n                output = formatForShiroIni(hash, base64, salt, generatedSaltBase64, generateSalt);\n            } else if (format) {\n                output = format(hash, base64, salt, generatedSaltBase64, generateSalt, algorithm, sourceValue);\n            } else {\n                output = formatMinimal(hash, base64, salt, generatedSaltBase64, generateSalt);\n            }\n\n            System.out.println(output);\n\n        } catch (IllegalArgumentException iae) {\n            exit(iae, debug);\n        } catch (UnknownAlgorithmException uae) {\n            exit(uae, debug);\n        } catch (IOException ioe) {\n            exit(ioe, debug);\n        } catch (Exception e) {\n            printHelpAndExit(options, e, debug, -1);\n        } finally {\n            if (passwordChars != null && passwordChars.length > 0) {\n                for (int i = 0; i < passwordChars.length; i++) {\n                    passwordChars[i] = ' ';\n                }\n            }\n        }\n    }\n\n    private static String createMutexMessage(Option... options) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"The \");\n\n        for (int i = 0; i < options.length; i++) {\n            if (i > 0) {\n                sb.append(\", \");\n            }\n            Option o = options[0];\n            sb.append(\"-\").append(o.getOpt()).append(\"/--\").append(o.getLongOpt());\n        }\n        sb.append(\" and generated salt options are mutually exclusive.  Only one of them may be used at a time\");\n        return sb.toString();\n    }\n\n    private static void exit(Exception e, boolean debug) {\n        printException(e, debug);\n        System.exit(-1);\n    }\n\n    private static StringBuilder format(ByteSource hash, boolean hashBase64, ByteSource salt, boolean saltBase64, boolean showSalt, String alg, String value) {\n        StringBuilder sb = new StringBuilder();\n\n        sb.append(alg).append(\"(\").append(value).append(\")\");\n\n        if (hashBase64) {\n            sb.append(\" base64 = \").append(hash.toBase64());\n        } else {\n            sb.append(\" hex = \").append(hash.toHex());\n        }\n\n        if (showSalt && salt != null) {\n            sb.append(\"\\nGenerated salt\");\n            if (saltBase64) {\n                sb.append(\" base64 = \").append(salt.toBase64());\n            } else {\n                sb.append(\" hex = \").append(salt.toHex());\n            }\n        }\n\n        return sb;\n    }\n\n    private static StringBuilder formatForShiroIni(ByteSource hash, boolean hashBase64, ByteSource salt, boolean saltBase64, boolean showSalt) {\n        StringBuilder sb = new StringBuilder();\n\n        if (hashBase64) {\n            sb.append(hash.toBase64());\n        } else {\n            //hex:\n            sb.append(HEX_PREFIX).append(hash.toHex());\n        }\n\n        if (showSalt && salt != null) {\n            sb.append(\" \");\n            if (saltBase64) {\n                sb.append(salt.toBase64());\n            } else {\n                //hex:\n                sb.append(HEX_PREFIX).append(salt.toHex());\n            }\n        }\n        return sb;\n    }\n\n    private static StringBuilder formatMinimal(ByteSource hash, boolean hashBase64, ByteSource salt, boolean saltBase64, boolean showSalt) {\n        StringBuilder sb = new StringBuilder();\n\n        if (hashBase64) {\n            sb.append(hash.toBase64());\n        } else {\n            sb.append(hash.toHex());\n        }\n\n        if (showSalt && salt != null) {\n            sb.append(\" \");\n            if (saltBase64) {\n                sb.append(salt.toBase64());\n            } else {\n                sb.append(salt.toHex());\n            }\n        }\n\n        return sb;\n    }\n\n    private static int getRequiredPositiveInt(CommandLine line, Option option) {\n        String iterVal = line.getOptionValue(option.getOpt());\n        try {\n            return Integer.parseInt(iterVal);\n        } catch (NumberFormatException e) {\n            String msg = \"'\" + option.getLongOpt() + \"' value must be a positive integer.\";\n            throw new IllegalArgumentException(msg, e);\n        }\n    }\n\n    private static ByteSource getSalt(String saltString, String saltBytesString, boolean generateSalt, int generatedSaltSize) {\n\n        if (saltString != null) {\n            if (generateSalt || (saltBytesString != null)) {\n                throw new IllegalArgumentException(SALT_MUTEX_MSG);\n            }\n            return new SimpleByteSource(saltString);\n        }\n\n        if (saltBytesString != null) {\n            if (generateSalt) {\n                throw new IllegalArgumentException(SALT_MUTEX_MSG);\n            }\n\n            String value = saltBytesString;\n            boolean base64 = true;\n            if (saltBytesString.startsWith(HEX_PREFIX)) {\n                //hex:\n                base64 = false;\n                value = value.substring(HEX_PREFIX.length());\n            }\n            byte[] bytes;\n            if (base64) {\n                bytes = Base64.decode(value);\n            } else {\n                bytes = Hex.decode(value);\n            }\n            return new SimpleByteSource(bytes);\n        }\n\n        if (generateSalt) {\n            SecureRandomNumberGenerator generator = new SecureRandomNumberGenerator();\n            int byteSize = generatedSaltSize / 8; //generatedSaltSize is in *bits* - convert to byte size:\n            return generator.nextBytes(byteSize);\n        }\n\n        //no salt used:\n        return null;\n    }\n\n    private static void printException(Exception e, boolean debug) {\n        if (e != null) {\n            System.out.println();\n            if (debug) {\n                System.out.println(\"Error: \");\n                e.printStackTrace(System.out);\n                System.out.println(e.getMessage());\n\n            } else {\n                System.out.println(\"Error: \" + e.getMessage());\n                System.out.println();\n                System.out.println(\"Specify -d or --debug for more information.\");\n            }\n        }\n    }\n\n    private static void printHelp(Options options, Exception e, boolean debug) {\n        HelpFormatter help = new HelpFormatter();\n        String command = \"java -jar shiro-tools-hasher-<version>.jar [options] [<value>]\";\n        String header = \"\\nPrint a cryptographic hash (aka message digest) of the specified <value>.\\n--\\nOptions:\";\n        String footer = \"\\n\" +\n                \"<value> is optional only when hashing passwords (see below).  It is\\n\" +\n                \"required all other times.\" +\n                \"\\n\\n\" +\n                \"Password Hashing:\\n\" +\n                \"---------------------------------\\n\" +\n                \"Specify the -p/--password option and DO NOT enter a <value>.  You will\\n\" +\n                \"be prompted for a password and characters will not echo as you type.\" +\n                \"\\n\\n\" +\n                \"Salting:\\n\" +\n                \"---------------------------------\\n\" +\n                \"Specifying a salt:\" +\n                \"\\n\\n\" +\n\n                \"You may specify a salt using the -s/--salt option followed by the salt\\n\" +\n                \"value.  If the salt value is a base64 or hex string representing a\\n\" +\n                \"byte array, you must specify the -sb/--saltbytes option to indicate this,\\n\" +\n                \"otherwise the text value bytes will be used directly.\" +\n                \"\\n\\n\" +\n                \"When using -sb/--saltbytes, the -s/--salt value is expected to be a\\n\" +\n                \"base64-encoded string by default.  If the value is a hex-encoded string,\\n\" +\n                \"you must prefix the string with 0x (zero x) to indicate a hex value.\" +\n                \"\\n\\n\" +\n                \"Generating a salt:\" +\n                \"\\n\\n\" +\n                \"Use the -sg/--saltgenerated option if you don't want to specify a salt,\\n\" +\n                \"but want a strong random salt to be generated and used during hashing.\\n\" +\n                \"The generated salt size defaults to 128 bytes.  You may specify\\n\" +\n                \"a different size by using the -sgs/--saltgeneratedsize option followed by\\n\" +\n                \"a positive integer.\" +\n                \"\\n\\n\" +\n                \"Because a salt must be specified if computing the\\n\" +\n                \"hash later, generated salts will be printed, defaulting to base64\\n\" +\n                \"encoding.  If you prefer to use hex encoding, additionally use the\\n\" +\n                \"-sgh/--saltgeneratedhex option.\" +\n                \"\\n\\n\" +\n                \"Files, URLs and classpath resources:\\n\" +\n                \"---------------------------------\\n\" +\n                \"If using the -r/--resource option, the <value> represents a resource path.\\n\" +\n                \"By default this is expected to be a file path, but you may specify\\n\" +\n                \"classpath or URL resources by using the classpath: or url: prefix\\n\" +\n                \"respectively.\" +\n                \"\\n\\n\" +\n                \"Some examples:\" +\n                \"\\n\\n\" +\n                \"<command> -r fileInCurrentDirectory.txt\\n\" +\n                \"<command> -r ../../relativePathFile.xml\\n\" +\n                \"<command> -r ~/documents/myfile.pdf\\n\" +\n                \"<command> -r /usr/local/logs/absolutePathFile.log\\n\" +\n                \"<command> -r url:http://foo.com/page.html\\n\" +\n                \"<command> -r classpath:/WEB-INF/lib/something.jar\";\n\n        printException(e, debug);\n\n        System.out.println();\n        help.printHelp(command, header, options, null);\n        System.out.println(footer);\n    }\n\n    private static void printHelpAndExit(Options options, Exception e, boolean debug, int exitCode) {\n        printHelp(options, e, debug);\n        System.exit(exitCode);\n    }\n\n    private static char[] readPassword(boolean confirm) {\n        if (!JavaEnvironment.isAtLeastVersion16()) {\n            String msg = \"Password hashing (prompt without echo) uses the java.io.Console to read passwords \" +\n                    \"safely.  This is only available on Java 1.6 platforms and later.\";\n            throw new IllegalArgumentException(msg);\n        }\n        java.io.Console console = System.console();\n        if (console == null) {\n            throw new IllegalStateException(\"java.io.Console is not available on the current JVM.  Cannot read passwords.\");\n        }\n        char[] first = console.readPassword(\"%s\", \"Password to hash: \");\n        if (first == null || first.length == 0) {\n            throw new IllegalArgumentException(\"No password specified.\");\n        }\n        if (confirm) {\n            char[] second = console.readPassword(\"%s\", \"Password to hash (confirm): \");\n            if (!Arrays.equals(first, second)) {\n                String msg = \"Password entries do not match.\";\n                throw new IllegalArgumentException(msg);\n            }\n        }\n        return first;\n    }\n\n    private static File toFile(String path) {\n        String resolved = path;\n        if (path.startsWith(\"~/\") || path.startsWith((\"~\\\\\"))) {\n            resolved = path.replaceFirst(\"\\\\~\", System.getProperty(\"user.home\"));\n        }\n        return new File(resolved);\n    }\n\n    private static String toString(String[] strings) {\n        int len = strings != null ? strings.length : 0;\n        if (len == 0) {\n            return null;\n        }\n        return StringUtils.toDelimitedString(strings, \" \");\n    }\n\n    static {\n        ALGORITHM.setArgName(\"name\");\n        SALT_GEN_SIZE.setArgName(\"numBits\");\n        ITERATIONS.setArgName(\"num\");\n        SALT.setArgName(\"sval\");\n        SALT_BYTES.setArgName(\"encTxt\");\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.tools.hasher;\n\nimport org.apache.commons.cli.*;\nimport org.apache.shiro.crypto.UnknownAlgorithmException;\nimport org.apache.shiro.crypto.hash.SimpleHash;\nimport org.apache.shiro.io.ResourceUtils;\nimport org.apache.shiro.util.JavaEnvironment;\nimport org.apache.shiro.util.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Arrays;\n\n/**\n * Commandline line utility to hash data such as strings, passwords, resources (files, urls, etc).\n * <p/>\n * Usage:\n * <pre>\n * java -jar shiro-tools-hasher<em>-version<\/em>.jar\n * <\/pre>\n * This will print out all supported options with documentation.\n *\n * @since 1.2\n */\npublic final class Hasher {\n\n\n    private static final String DEFAULT_ALGORITHM_NAME = \"MD5\";\n    private static final int DEFAULT_NUM_ITERATIONS = 1;\n\n    private static final String ALG_OPT = \"a\";\n    private static final String ALG_OPT_LONG = \"algorithm\";\n    private static final String DEBUG_OPT = \"d\";\n    private static final String DEBUG_OPT_LONG = \"debug\"; //show stack traces if there are any.\n    private static final String ITER_OPT = \"i\";\n    private static final String ITER_OPT_LONG = \"iterations\";\n    private static final String HEX_OPT = \"h\";\n    private static final String HEX_OPT_LONG = \"hex\";\n    private static final String HELP_OPT = \"help\";\n    private static final String HELP_OPT_LONG = \"help\";\n    private static final String PASSWORD_OPT = \"p\";\n    private static final String PASSWORD_OPT_LONG = \"password\";\n    private static final String PASSWORD_OPT_NOCONFIRM = \"pnc\";\n    private static final String PASSWORD_OPT_NOCONFIRM_LONG = \"pnoconfirm\";\n    private static final String RESOURCE_OPT = \"r\";\n    private static final String RESOURCE_OPT_LONG = \"resource\";\n\n\n    public static void main(String[] args) {\n\n        CommandLineParser parser = new PosixParser();\n\n        Options options = new Options();\n        options.addOption(ALG_OPT, ALG_OPT_LONG, true, \"hash algorithm name.  Defaults to MD5.\");\n        options.addOption(ITER_OPT, ITER_OPT_LONG, true, \"number of hash iterations.  Defaults to 1.\");\n        options.addOption(HEX_OPT, HEX_OPT_LONG, false, \"print hex value.  Defaults to Base64.\");\n        options.addOption(HELP_OPT, HELP_OPT_LONG, false, \"print this help message.\");\n        options.addOption(DEBUG_OPT, DEBUG_OPT_LONG, false, \"show additional error (stack trace) information.\");\n        options.addOption(PASSWORD_OPT, PASSWORD_OPT_LONG, false, \"hash a password (do not echo).\");\n        options.addOption(RESOURCE_OPT, RESOURCE_OPT_LONG, false, \"read and hash the resource located at <value>. See below for more information.\");\n        options.addOption(PASSWORD_OPT_NOCONFIRM, PASSWORD_OPT_NOCONFIRM_LONG, false, \"disable confirmation prompt for password hashing.\");\n\n        boolean debug = false;\n        String algorithm = DEFAULT_ALGORITHM_NAME;\n        int iterations = DEFAULT_NUM_ITERATIONS;\n        boolean base64 = true;\n        boolean resource = false;\n        boolean password = false;\n        boolean passwordConfirm = true;\n\n        char[] passwordChars = null;\n\n        try {\n            CommandLine line = parser.parse(options, args);\n\n            if (line.hasOption(HELP_OPT)) {\n                printHelpAndExit(options, null, debug, 0);\n            }\n            if (line.hasOption(DEBUG_OPT)) {\n                debug = true;\n            }\n            if (line.hasOption(ALG_OPT)) {\n                algorithm = line.getOptionValue(ALG_OPT);\n            }\n            if (line.hasOption(ITER_OPT)) {\n                iterations = getRequiredPositiveInt(line, ITER_OPT, ITER_OPT_LONG);\n            }\n            if (line.hasOption(HEX_OPT)) {\n                base64 = false;\n            }\n            if (line.hasOption(PASSWORD_OPT)) {\n                password = true;\n            }\n            if (line.hasOption(RESOURCE_OPT)) {\n                resource = true;\n            }\n            if (line.hasOption(PASSWORD_OPT_NOCONFIRM)) {\n                passwordConfirm = false;\n            }\n\n            Object source;\n\n            if (password) {\n                passwordChars = readPassword(passwordConfirm);\n                source = passwordChars;\n            } else {\n                String[] remainingArgs = line.getArgs();\n                if (remainingArgs == null || remainingArgs.length != 1) {\n                    printHelpAndExit(options, null, debug, -1);\n                }\n\n                assert remainingArgs != null;\n                String value = toString(remainingArgs);\n\n                if (resource) {\n                    if (!ResourceUtils.hasResourcePrefix(value)) {\n                        source = toFile(value);\n                    } else {\n                        source = ResourceUtils.getInputStreamForPath(value);\n                    }\n                } else {\n                    source = value;\n                }\n            }\n\n            SimpleHash hash = new SimpleHash(algorithm, source, /* salt not supported yet*/ null, iterations);\n            if (base64) {\n                System.out.println(hash.toBase64());\n            } else {\n                System.out.println(hash.toHex());\n            }\n        } catch (IllegalArgumentException iae) {\n            exit(iae, debug);\n        } catch (UnknownAlgorithmException uae) {\n            exit(uae, debug);\n        } catch (IOException ioe) {\n            exit(ioe, debug);\n        } catch (Exception e) {\n            printHelpAndExit(options, e, debug, -1);\n        } finally {\n            if (passwordChars != null && passwordChars.length > 0) {\n                for (int i = 0; i < passwordChars.length; i++) {\n                    passwordChars[i] = ' ';\n                }\n            }\n        }\n    }\n\n    private static String toString(String[] strings) {\n        int len = strings != null ? strings.length : 0;\n        if (len == 0) {\n            return null;\n        }\n        return StringUtils.toDelimitedString(strings, \" \");\n    }\n\n    private static int getRequiredPositiveInt(CommandLine line, String opt, String optLong) {\n        String iterVal = line.getOptionValue(opt);\n        try {\n            return Integer.parseInt(iterVal);\n        } catch (NumberFormatException e) {\n            String msg = \"'\" + optLong + \"' value must be a positive integer.\";\n            throw new IllegalArgumentException(msg, e);\n        }\n    }\n\n    private static File toFile(String path) {\n        String resolved = path;\n        if (path.startsWith(\"~/\") || path.startsWith((\"~\\\\\"))) {\n            resolved = path.replaceFirst(\"\\\\~\", System.getProperty(\"user.home\"));\n        }\n        return new File(resolved);\n    }\n\n    private static char[] readPassword(boolean confirm) {\n        if (!JavaEnvironment.isAtLeastVersion16()) {\n            String msg = \"Password hashing (prompt without echo) uses the java.io.Console to read passwords \" +\n                    \"safely.  This is only available on Java 1.6 platforms and later.\";\n            throw new IllegalArgumentException(msg);\n        }\n        java.io.Console console = System.console();\n        if (console == null) {\n            throw new IllegalStateException(\"java.io.Console is not available on the current JVM.  Cannot read passwords.\");\n        }\n        char[] first = console.readPassword(\"%s\", \"Password to hash: \");\n        if (first == null || first.length == 0) {\n            throw new IllegalArgumentException(\"No password specified.\");\n        }\n        if (confirm) {\n            char[] second = console.readPassword(\"%s\", \"Password to hash (confirm): \");\n            if (!Arrays.equals(first, second)) {\n                String msg = \"Password entries do not match.\";\n                throw new IllegalArgumentException(msg);\n            }\n        }\n        return first;\n    }\n\n    private static void printHelp(Options options, Exception e, boolean debug) {\n        HelpFormatter help = new HelpFormatter();\n        String command = \"java -jar shiro-tools-hasher-<version>.jar [options] [<value>]\";\n        String header = \"\\nPrint a cryptographic hash (aka message digest) of the specified <value>.\\n--\\nOptions:\";\n        String footer = \"\\n\" +\n                \"<value> is optional only when hashing passwords (see below).  It is\\n\" +\n                \"required all other times.\\n\\n\" +\n                \"Password Hashing:\\n--\\n\" +\n                \"Specify the -p/--password option and DO NOT enter a <value>.  You will\\n\" +\n                \"be prompted for a password and characters will not echo as you type.\\n\\n\" +\n                \"Files, URLs and classpath resources:\\n--\\n\" +\n                \"If using the -r/--resource option, the <value> represents a resource path.\\n\" +\n                \"By default this is expected to be a file path, but you may specify\\n\" +\n                \"classpath or URL resources by using the classpath: or url: prefix\\n\" +\n                \"respectively.\\n\\n\" +\n                \"Some examples:\\n\\n\" +\n                \"<command> -r fileInCurrentDirectory.txt\\n\" +\n                \"<command> -r ../../relativePathFile.xml\\n\" +\n                \"<command> -r ~/documents/myfile.pdf\\n\"+\n                \"<command> -r /usr/local/logs/absolutePathFile.log\\n\" +\n                \"<command> -r url:http://foo.com/page.html\\n\" +\n                \"<command> -r classpath:/WEB-INF/lib/something.jar\";\n\n        printException(e, debug);\n\n        System.out.println();\n        help.printHelp(command, header, options, null);\n        System.out.println(footer);\n    }\n\n    private static void exit(Exception e, boolean debug) {\n        printException(e, debug);\n        System.exit(-1);\n    }\n\n    private static void printException(Exception e, boolean debug) {\n        if (e != null) {\n            System.out.println();\n            if (debug) {\n                System.out.println(\"Error: \");\n                e.printStackTrace(System.out);\n                System.out.println(e.getMessage());\n\n            } else {\n                System.out.println(\"Error: \" + e.getMessage());\n                System.out.println();\n                System.out.println(\"Specify -d or --debug for more information.\");\n            }\n        }\n    }\n\n    private static void printHelpAndExit(Options options, Exception e, boolean debug, int exitCode) {\n        printHelp(options, e, debug);\n        System.exit(exitCode);\n    }\n}\n","lineNo":182}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.tools.hasher;\n\nimport org.apache.commons.cli.*;\nimport org.apache.shiro.codec.Base64;\nimport org.apache.shiro.codec.Hex;\nimport org.apache.shiro.crypto.SecureRandomNumberGenerator;\nimport org.apache.shiro.crypto.UnknownAlgorithmException;\nimport org.apache.shiro.crypto.hash.SimpleHash;\nimport org.apache.shiro.io.ResourceUtils;\nimport org.apache.shiro.util.ByteSource;\nimport org.apache.shiro.util.JavaEnvironment;\nimport org.apache.shiro.util.SimpleByteSource;\nimport org.apache.shiro.util.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Arrays;\n\n/**\n * Commandline line utility to hash data such as strings, passwords, resources (files, urls, etc).\n * <p/>\n * Usage:\n * <pre>\n * java -jar shiro-tools-hasher<em>-version<\/em>-cli.jar\n * <\/pre>\n * This will print out all supported options with documentation.\n *\n * @since 1.2\n */\npublic final class Hasher {\n\n    private static final Option ALGORITHM = new Option(\"a\", \"algorithm\", true, \"hash algorithm name.  Defaults to MD5.\");\n    private static final Option DEBUG = new Option(\"d\", \"debug\", false, \"show additional error (stack trace) information.\");\n    private static final Option HELP = new Option(\"help\", \"help\", false, \"show this help message.\");\n    private static final Option HEX = new Option(\"h\", \"hex\", false, \"display a hex value instead of Base64.\");\n    private static final Option ITERATIONS = new Option(\"i\", \"iterations\", true, \"number of hash iterations.  Defaults to 1.\");\n    private static final Option NO_FORMAT = new Option(\"nf\", \"noformat\", false, \"turn off output formatting.  Any generated salt will be placed after the hash separated by a space.\");\n    private static final Option PASSWORD = new Option(\"p\", \"password\", false, \"hash a password (disable typing echo)\");\n    private static final Option PASSWORD_NC = new Option(\"pnc\", \"pnoconfirm\", false, \"disable password hash confirmation prompt.\");\n    private static final Option RESOURCE = new Option(\"r\", \"resource\", false, \"read and hash the resource located at <value>.  See below for more information.\");\n    private static final Option SALT = new Option(\"s\", \"salt\", true, \"use the specified salt.  <arg> is plaintext.\");\n    private static final Option SALT_BYTES = new Option(\"sb\", \"saltbytes\", true, \"use the specified salt bytes.  <arg> is hex or base64 encoded text.\");\n    private static final Option SALT_GEN = new Option(\"gs\", \"gensalt\", false, \"generate and use a random salt.\");\n    private static final Option SALT_GEN_HEX = new Option(\"gsh\", \"gensalthex\", false, \"display the generated salt's hex value instead of Base64.\");\n    private static final Option SALT_GEN_SIZE = new Option(\"gss\", \"gensaltsize\", true, \"the number of salt bits (not bytes!) to generate.  Defaults to 128.\");\n    private static final Option SHIRO = new Option(\"shiro\", \"shiro\", false, \"display output in the Shiro password file format (.ini [users] config).\");\n\n    private static final String HEX_PREFIX = \"0x\";\n    private static final String DEFAULT_ALGORITHM_NAME = \"MD5\";\n    private static final int DEFAULT_GENERATED_SALT_SIZE = 128;\n    private static final int DEFAULT_NUM_ITERATIONS = 1;\n    private static final String SALT_MUTEX_MSG = createMutexMessage(SALT, SALT_BYTES);\n\n\n    public static void main(String[] args) {\n\n        CommandLineParser parser = new PosixParser();\n\n        Options options = new Options();\n        options.addOption(HELP).addOption(DEBUG).addOption(ALGORITHM).addOption(HEX).addOption(ITERATIONS);\n        options.addOption(RESOURCE).addOption(PASSWORD).addOption(PASSWORD_NC);\n        options.addOption(SALT).addOption(SALT_BYTES).addOption(SALT_GEN).addOption(SALT_GEN_SIZE).addOption(SALT_GEN_HEX);\n        options.addOption(NO_FORMAT).addOption(SHIRO);\n\n        boolean debug = false;\n        String algorithm = DEFAULT_ALGORITHM_NAME;\n        int iterations = DEFAULT_NUM_ITERATIONS;\n        boolean base64 = true;\n        boolean resource = false;\n        boolean password = false;\n        boolean passwordConfirm = true;\n        String saltString = null;\n        String saltBytesString = null;\n        boolean generateSalt = false;\n        boolean generatedSaltBase64 = true;\n        int generatedSaltSize = DEFAULT_GENERATED_SALT_SIZE;\n\n        boolean shiroFormat = false;\n        boolean format = true;\n\n        char[] passwordChars = null;\n\n        try {\n            CommandLine line = parser.parse(options, args);\n\n            if (line.hasOption(HELP.getOpt())) {\n                printHelpAndExit(options, null, debug, 0);\n            }\n            if (line.hasOption(DEBUG.getOpt())) {\n                debug = true;\n            }\n            if (line.hasOption(ALGORITHM.getOpt())) {\n                algorithm = line.getOptionValue(ALGORITHM.getOpt());\n            }\n            if (line.hasOption(ITERATIONS.getOpt())) {\n                iterations = getRequiredPositiveInt(line, ITERATIONS);\n            }\n            if (line.hasOption(HEX.getOpt())) {\n                base64 = false;\n            }\n            if (line.hasOption(PASSWORD.getOpt())) {\n                password = true;\n            }\n            if (line.hasOption(RESOURCE.getOpt())) {\n                resource = true;\n            }\n            if (line.hasOption(PASSWORD_NC.getOpt())) {\n                passwordConfirm = false;\n            }\n            if (line.hasOption(SALT.getOpt())) {\n                saltString = line.getOptionValue(SALT.getOpt());\n            }\n            if (line.hasOption(SALT_BYTES.getOpt())) {\n                saltBytesString = line.getOptionValue(SALT_BYTES.getOpt());\n            }\n            if (line.hasOption(SALT_GEN.getOpt())) {\n                generateSalt = true;\n            }\n            if (line.hasOption(SALT_GEN_HEX.getOpt())) {\n                generateSalt = true;\n                generatedSaltBase64 = false;\n            }\n            if (line.hasOption(SALT_GEN_SIZE.getOpt())) {\n                generateSalt = true;\n                generatedSaltSize = getRequiredPositiveInt(line, SALT_GEN_SIZE);\n                if (generatedSaltSize % 8 != 0) {\n                    throw new IllegalArgumentException(\"Generated salt size must be a multiple of 8 (e.g. 128, 192, 256, 512, etc).\");\n                }\n            }\n            if (line.hasOption(NO_FORMAT.getOpt())) {\n                format = false;\n            }\n            if (line.hasOption(SHIRO.getOpt())) {\n                shiroFormat = true;\n            }\n\n            String sourceValue = null;\n\n            Object source;\n\n            if (password) {\n                passwordChars = readPassword(passwordConfirm);\n                source = passwordChars;\n            } else {\n                String[] remainingArgs = line.getArgs();\n                if (remainingArgs == null || remainingArgs.length != 1) {\n                    printHelpAndExit(options, null, debug, -1);\n                }\n\n                assert remainingArgs != null;\n                sourceValue = toString(remainingArgs);\n\n                if (resource) {\n                    if (!ResourceUtils.hasResourcePrefix(sourceValue)) {\n                        source = toFile(sourceValue);\n                    } else {\n                        source = ResourceUtils.getInputStreamForPath(sourceValue);\n                    }\n                } else {\n                    source = sourceValue;\n                }\n            }\n\n            ByteSource salt = getSalt(saltString, saltBytesString, generateSalt, generatedSaltSize);\n\n            SimpleHash hash = new SimpleHash(algorithm, source, salt, iterations);\n\n            StringBuilder output;\n            if (shiroFormat) {\n                output = formatForShiroIni(hash, base64, salt, generatedSaltBase64, generateSalt);\n            } else if (format) {\n                output = format(hash, base64, salt, generatedSaltBase64, generateSalt, algorithm, sourceValue);\n            } else {\n                output = formatMinimal(hash, base64, salt, generatedSaltBase64, generateSalt);\n            }\n\n            System.out.println(output);\n\n        } catch (IllegalArgumentException iae) {\n            exit(iae, debug);\n        } catch (UnknownAlgorithmException uae) {\n            exit(uae, debug);\n        } catch (IOException ioe) {\n            exit(ioe, debug);\n        } catch (Exception e) {\n            printHelpAndExit(options, e, debug, -1);\n        } finally {\n            if (passwordChars != null && passwordChars.length > 0) {\n                for (int i = 0; i < passwordChars.length; i++) {\n                    passwordChars[i] = ' ';\n                }\n            }\n        }\n    }\n\n    private static String createMutexMessage(Option... options) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"The \");\n\n        for (int i = 0; i < options.length; i++) {\n            if (i > 0) {\n                sb.append(\", \");\n            }\n            Option o = options[0];\n            sb.append(\"-\").append(o.getOpt()).append(\"/--\").append(o.getLongOpt());\n        }\n        sb.append(\" and generated salt options are mutually exclusive.  Only one of them may be used at a time\");\n        return sb.toString();\n    }\n\n    private static void exit(Exception e, boolean debug) {\n        printException(e, debug);\n        System.exit(-1);\n    }\n\n    private static StringBuilder format(ByteSource hash, boolean hashBase64, ByteSource salt, boolean saltBase64, boolean showSalt, String alg, String value) {\n        StringBuilder sb = new StringBuilder();\n\n        sb.append(alg).append(\"(\").append(value).append(\")\");\n\n        if (hashBase64) {\n            sb.append(\" base64 = \").append(hash.toBase64());\n        } else {\n            sb.append(\" hex = \").append(hash.toHex());\n        }\n\n        if (showSalt && salt != null) {\n            sb.append(\"\\nGenerated salt\");\n            if (saltBase64) {\n                sb.append(\" base64 = \").append(salt.toBase64());\n            } else {\n                sb.append(\" hex = \").append(salt.toHex());\n            }\n        }\n\n        return sb;\n    }\n\n    private static StringBuilder formatForShiroIni(ByteSource hash, boolean hashBase64, ByteSource salt, boolean saltBase64, boolean showSalt) {\n        StringBuilder sb = new StringBuilder();\n\n        if (hashBase64) {\n            sb.append(hash.toBase64());\n        } else {\n            //hex:\n            sb.append(HEX_PREFIX).append(hash.toHex());\n        }\n\n        if (showSalt && salt != null) {\n            sb.append(\" \");\n            if (saltBase64) {\n                sb.append(salt.toBase64());\n            } else {\n                //hex:\n                sb.append(HEX_PREFIX).append(salt.toHex());\n            }\n        }\n        return sb;\n    }\n\n    private static StringBuilder formatMinimal(ByteSource hash, boolean hashBase64, ByteSource salt, boolean saltBase64, boolean showSalt) {\n        StringBuilder sb = new StringBuilder();\n\n        if (hashBase64) {\n            sb.append(hash.toBase64());\n        } else {\n            sb.append(hash.toHex());\n        }\n\n        if (showSalt && salt != null) {\n            sb.append(\" \");\n            if (saltBase64) {\n                sb.append(salt.toBase64());\n            } else {\n                sb.append(salt.toHex());\n            }\n        }\n\n        return sb;\n    }\n\n    private static int getRequiredPositiveInt(CommandLine line, Option option) {\n        String iterVal = line.getOptionValue(option.getOpt());\n        try {\n            return Integer.parseInt(iterVal);\n        } catch (NumberFormatException e) {\n            String msg = \"'\" + option.getLongOpt() + \"' value must be a positive integer.\";\n            throw new IllegalArgumentException(msg, e);\n        }\n    }\n\n    private static ByteSource getSalt(String saltString, String saltBytesString, boolean generateSalt, int generatedSaltSize) {\n\n        if (saltString != null) {\n            if (generateSalt || (saltBytesString != null)) {\n                throw new IllegalArgumentException(SALT_MUTEX_MSG);\n            }\n            return new SimpleByteSource(saltString);\n        }\n\n        if (saltBytesString != null) {\n            if (generateSalt) {\n                throw new IllegalArgumentException(SALT_MUTEX_MSG);\n            }\n\n            String value = saltBytesString;\n            boolean base64 = true;\n            if (saltBytesString.startsWith(HEX_PREFIX)) {\n                //hex:\n                base64 = false;\n                value = value.substring(HEX_PREFIX.length());\n            }\n            byte[] bytes;\n            if (base64) {\n                bytes = Base64.decode(value);\n            } else {\n                bytes = Hex.decode(value);\n            }\n            return new SimpleByteSource(bytes);\n        }\n\n        if (generateSalt) {\n            SecureRandomNumberGenerator generator = new SecureRandomNumberGenerator();\n            int byteSize = generatedSaltSize / 8; //generatedSaltSize is in *bits* - convert to byte size:\n            return generator.nextBytes(byteSize);\n        }\n\n        //no salt used:\n        return null;\n    }\n\n    private static void printException(Exception e, boolean debug) {\n        if (e != null) {\n            System.out.println();\n            if (debug) {\n                System.out.println(\"Error: \");\n                e.printStackTrace(System.out);\n                System.out.println(e.getMessage());\n\n            } else {\n                System.out.println(\"Error: \" + e.getMessage());\n                System.out.println();\n                System.out.println(\"Specify -d or --debug for more information.\");\n            }\n        }\n    }\n\n    private static void printHelp(Options options, Exception e, boolean debug) {\n        HelpFormatter help = new HelpFormatter();\n        String command = \"java -jar shiro-tools-hasher-<version>.jar [options] [<value>]\";\n        String header = \"\\nPrint a cryptographic hash (aka message digest) of the specified <value>.\\n--\\nOptions:\";\n        String footer = \"\\n\" +\n                \"<value> is optional only when hashing passwords (see below).  It is\\n\" +\n                \"required all other times.\" +\n                \"\\n\\n\" +\n                \"Password Hashing:\\n\" +\n                \"---------------------------------\\n\" +\n                \"Specify the -p/--password option and DO NOT enter a <value>.  You will\\n\" +\n                \"be prompted for a password and characters will not echo as you type.\" +\n                \"\\n\\n\" +\n                \"Salting:\\n\" +\n                \"---------------------------------\\n\" +\n                \"Specifying a salt:\" +\n                \"\\n\\n\" +\n\n                \"You may specify a salt using the -s/--salt option followed by the salt\\n\" +\n                \"value.  If the salt value is a base64 or hex string representing a\\n\" +\n                \"byte array, you must specify the -sb/--saltbytes option to indicate this,\\n\" +\n                \"otherwise the text value bytes will be used directly.\" +\n                \"\\n\\n\" +\n                \"When using -sb/--saltbytes, the -s/--salt value is expected to be a\\n\" +\n                \"base64-encoded string by default.  If the value is a hex-encoded string,\\n\" +\n                \"you must prefix the string with 0x (zero x) to indicate a hex value.\" +\n                \"\\n\\n\" +\n                \"Generating a salt:\" +\n                \"\\n\\n\" +\n                \"Use the -sg/--saltgenerated option if you don't want to specify a salt,\\n\" +\n                \"but want a strong random salt to be generated and used during hashing.\\n\" +\n                \"The generated salt size defaults to 128 bytes.  You may specify\\n\" +\n                \"a different size by using the -sgs/--saltgeneratedsize option followed by\\n\" +\n                \"a positive integer.\" +\n                \"\\n\\n\" +\n                \"Because a salt must be specified if computing the\\n\" +\n                \"hash later, generated salts will be printed, defaulting to base64\\n\" +\n                \"encoding.  If you prefer to use hex encoding, additionally use the\\n\" +\n                \"-sgh/--saltgeneratedhex option.\" +\n                \"\\n\\n\" +\n                \"Files, URLs and classpath resources:\\n\" +\n                \"---------------------------------\\n\" +\n                \"If using the -r/--resource option, the <value> represents a resource path.\\n\" +\n                \"By default this is expected to be a file path, but you may specify\\n\" +\n                \"classpath or URL resources by using the classpath: or url: prefix\\n\" +\n                \"respectively.\" +\n                \"\\n\\n\" +\n                \"Some examples:\" +\n                \"\\n\\n\" +\n                \"<command> -r fileInCurrentDirectory.txt\\n\" +\n                \"<command> -r ../../relativePathFile.xml\\n\" +\n                \"<command> -r ~/documents/myfile.pdf\\n\" +\n                \"<command> -r /usr/local/logs/absolutePathFile.log\\n\" +\n                \"<command> -r url:http://foo.com/page.html\\n\" +\n                \"<command> -r classpath:/WEB-INF/lib/something.jar\";\n\n        printException(e, debug);\n\n        System.out.println();\n        help.printHelp(command, header, options, null);\n        System.out.println(footer);\n    }\n\n    private static void printHelpAndExit(Options options, Exception e, boolean debug, int exitCode) {\n        printHelp(options, e, debug);\n        System.exit(exitCode);\n    }\n\n    private static char[] readPassword(boolean confirm) {\n        if (!JavaEnvironment.isAtLeastVersion16()) {\n            String msg = \"Password hashing (prompt without echo) uses the java.io.Console to read passwords \" +\n                    \"safely.  This is only available on Java 1.6 platforms and later.\";\n            throw new IllegalArgumentException(msg);\n        }\n        java.io.Console console = System.console();\n        if (console == null) {\n            throw new IllegalStateException(\"java.io.Console is not available on the current JVM.  Cannot read passwords.\");\n        }\n        char[] first = console.readPassword(\"%s\", \"Password to hash: \");\n        if (first == null || first.length == 0) {\n            throw new IllegalArgumentException(\"No password specified.\");\n        }\n        if (confirm) {\n            char[] second = console.readPassword(\"%s\", \"Password to hash (confirm): \");\n            if (!Arrays.equals(first, second)) {\n                String msg = \"Password entries do not match.\";\n                throw new IllegalArgumentException(msg);\n            }\n        }\n        return first;\n    }\n\n    private static File toFile(String path) {\n        String resolved = path;\n        if (path.startsWith(\"~/\") || path.startsWith((\"~\\\\\"))) {\n            resolved = path.replaceFirst(\"\\\\~\", System.getProperty(\"user.home\"));\n        }\n        return new File(resolved);\n    }\n\n    private static String toString(String[] strings) {\n        int len = strings != null ? strings.length : 0;\n        if (len == 0) {\n            return null;\n        }\n        return StringUtils.toDelimitedString(strings, \" \");\n    }\n\n    static {\n        ALGORITHM.setArgName(\"name\");\n        SALT_GEN_SIZE.setArgName(\"numBits\");\n        ITERATIONS.setArgName(\"num\");\n        SALT.setArgName(\"sval\");\n        SALT_BYTES.setArgName(\"encTxt\");\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.tools.hasher;\n\nimport org.apache.commons.cli.*;\nimport org.apache.shiro.crypto.UnknownAlgorithmException;\nimport org.apache.shiro.crypto.hash.SimpleHash;\nimport org.apache.shiro.io.ResourceUtils;\nimport org.apache.shiro.util.JavaEnvironment;\nimport org.apache.shiro.util.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Arrays;\n\n/**\n * Commandline line utility to hash data such as strings, passwords, resources (files, urls, etc).\n * <p/>\n * Usage:\n * <pre>\n * java -jar shiro-tools-hasher<em>-version<\/em>.jar\n * <\/pre>\n * This will print out all supported options with documentation.\n *\n * @since 1.2\n */\npublic final class Hasher {\n\n\n    private static final String DEFAULT_ALGORITHM_NAME = \"MD5\";\n    private static final int DEFAULT_NUM_ITERATIONS = 1;\n\n    private static final String ALG_OPT = \"a\";\n    private static final String ALG_OPT_LONG = \"algorithm\";\n    private static final String DEBUG_OPT = \"d\";\n    private static final String DEBUG_OPT_LONG = \"debug\"; //show stack traces if there are any.\n    private static final String ITER_OPT = \"i\";\n    private static final String ITER_OPT_LONG = \"iterations\";\n    private static final String HEX_OPT = \"h\";\n    private static final String HEX_OPT_LONG = \"hex\";\n    private static final String HELP_OPT = \"help\";\n    private static final String HELP_OPT_LONG = \"help\";\n    private static final String PASSWORD_OPT = \"p\";\n    private static final String PASSWORD_OPT_LONG = \"password\";\n    private static final String PASSWORD_OPT_NOCONFIRM = \"pnc\";\n    private static final String PASSWORD_OPT_NOCONFIRM_LONG = \"pnoconfirm\";\n    private static final String RESOURCE_OPT = \"r\";\n    private static final String RESOURCE_OPT_LONG = \"resource\";\n\n\n    public static void main(String[] args) {\n\n        CommandLineParser parser = new PosixParser();\n\n        Options options = new Options();\n        options.addOption(ALG_OPT, ALG_OPT_LONG, true, \"hash algorithm name.  Defaults to MD5.\");\n        options.addOption(ITER_OPT, ITER_OPT_LONG, true, \"number of hash iterations.  Defaults to 1.\");\n        options.addOption(HEX_OPT, HEX_OPT_LONG, false, \"print hex value.  Defaults to Base64.\");\n        options.addOption(HELP_OPT, HELP_OPT_LONG, false, \"print this help message.\");\n        options.addOption(DEBUG_OPT, DEBUG_OPT_LONG, false, \"show additional error (stack trace) information.\");\n        options.addOption(PASSWORD_OPT, PASSWORD_OPT_LONG, false, \"hash a password (do not echo).\");\n        options.addOption(RESOURCE_OPT, RESOURCE_OPT_LONG, false, \"read and hash the resource located at <value>. See below for more information.\");\n        options.addOption(PASSWORD_OPT_NOCONFIRM, PASSWORD_OPT_NOCONFIRM_LONG, false, \"disable confirmation prompt for password hashing.\");\n\n        boolean debug = false;\n        String algorithm = DEFAULT_ALGORITHM_NAME;\n        int iterations = DEFAULT_NUM_ITERATIONS;\n        boolean base64 = true;\n        boolean resource = false;\n        boolean password = false;\n        boolean passwordConfirm = true;\n\n        char[] passwordChars = null;\n\n        try {\n            CommandLine line = parser.parse(options, args);\n\n            if (line.hasOption(HELP_OPT)) {\n                printHelpAndExit(options, null, debug, 0);\n            }\n            if (line.hasOption(DEBUG_OPT)) {\n                debug = true;\n            }\n            if (line.hasOption(ALG_OPT)) {\n                algorithm = line.getOptionValue(ALG_OPT);\n            }\n            if (line.hasOption(ITER_OPT)) {\n                iterations = getRequiredPositiveInt(line, ITER_OPT, ITER_OPT_LONG);\n            }\n            if (line.hasOption(HEX_OPT)) {\n                base64 = false;\n            }\n            if (line.hasOption(PASSWORD_OPT)) {\n                password = true;\n            }\n            if (line.hasOption(RESOURCE_OPT)) {\n                resource = true;\n            }\n            if (line.hasOption(PASSWORD_OPT_NOCONFIRM)) {\n                passwordConfirm = false;\n            }\n\n            Object source;\n\n            if (password) {\n                passwordChars = readPassword(passwordConfirm);\n                source = passwordChars;\n            } else {\n                String[] remainingArgs = line.getArgs();\n                if (remainingArgs == null || remainingArgs.length != 1) {\n                    printHelpAndExit(options, null, debug, -1);\n                }\n\n                assert remainingArgs != null;\n                String value = toString(remainingArgs);\n\n                if (resource) {\n                    if (!ResourceUtils.hasResourcePrefix(value)) {\n                        source = toFile(value);\n                    } else {\n                        source = ResourceUtils.getInputStreamForPath(value);\n                    }\n                } else {\n                    source = value;\n                }\n            }\n\n            SimpleHash hash = new SimpleHash(algorithm, source, /* salt not supported yet*/ null, iterations);\n            if (base64) {\n                System.out.println(hash.toBase64());\n            } else {\n                System.out.println(hash.toHex());\n            }\n        } catch (IllegalArgumentException iae) {\n            exit(iae, debug);\n        } catch (UnknownAlgorithmException uae) {\n            exit(uae, debug);\n        } catch (IOException ioe) {\n            exit(ioe, debug);\n        } catch (Exception e) {\n            printHelpAndExit(options, e, debug, -1);\n        } finally {\n            if (passwordChars != null && passwordChars.length > 0) {\n                for (int i = 0; i < passwordChars.length; i++) {\n                    passwordChars[i] = ' ';\n                }\n            }\n        }\n    }\n\n    private static String toString(String[] strings) {\n        int len = strings != null ? strings.length : 0;\n        if (len == 0) {\n            return null;\n        }\n        return StringUtils.toDelimitedString(strings, \" \");\n    }\n\n    private static int getRequiredPositiveInt(CommandLine line, String opt, String optLong) {\n        String iterVal = line.getOptionValue(opt);\n        try {\n            return Integer.parseInt(iterVal);\n        } catch (NumberFormatException e) {\n            String msg = \"'\" + optLong + \"' value must be a positive integer.\";\n            throw new IllegalArgumentException(msg, e);\n        }\n    }\n\n    private static File toFile(String path) {\n        String resolved = path;\n        if (path.startsWith(\"~/\") || path.startsWith((\"~\\\\\"))) {\n            resolved = path.replaceFirst(\"\\\\~\", System.getProperty(\"user.home\"));\n        }\n        return new File(resolved);\n    }\n\n    private static char[] readPassword(boolean confirm) {\n        if (!JavaEnvironment.isAtLeastVersion16()) {\n            String msg = \"Password hashing (prompt without echo) uses the java.io.Console to read passwords \" +\n                    \"safely.  This is only available on Java 1.6 platforms and later.\";\n            throw new IllegalArgumentException(msg);\n        }\n        java.io.Console console = System.console();\n        if (console == null) {\n            throw new IllegalStateException(\"java.io.Console is not available on the current JVM.  Cannot read passwords.\");\n        }\n        char[] first = console.readPassword(\"%s\", \"Password to hash: \");\n        if (first == null || first.length == 0) {\n            throw new IllegalArgumentException(\"No password specified.\");\n        }\n        if (confirm) {\n            char[] second = console.readPassword(\"%s\", \"Password to hash (confirm): \");\n            if (!Arrays.equals(first, second)) {\n                String msg = \"Password entries do not match.\";\n                throw new IllegalArgumentException(msg);\n            }\n        }\n        return first;\n    }\n\n    private static void printHelp(Options options, Exception e, boolean debug) {\n        HelpFormatter help = new HelpFormatter();\n        String command = \"java -jar shiro-tools-hasher-<version>.jar [options] [<value>]\";\n        String header = \"\\nPrint a cryptographic hash (aka message digest) of the specified <value>.\\n--\\nOptions:\";\n        String footer = \"\\n\" +\n                \"<value> is optional only when hashing passwords (see below).  It is\\n\" +\n                \"required all other times.\\n\\n\" +\n                \"Password Hashing:\\n--\\n\" +\n                \"Specify the -p/--password option and DO NOT enter a <value>.  You will\\n\" +\n                \"be prompted for a password and characters will not echo as you type.\\n\\n\" +\n                \"Files, URLs and classpath resources:\\n--\\n\" +\n                \"If using the -r/--resource option, the <value> represents a resource path.\\n\" +\n                \"By default this is expected to be a file path, but you may specify\\n\" +\n                \"classpath or URL resources by using the classpath: or url: prefix\\n\" +\n                \"respectively.\\n\\n\" +\n                \"Some examples:\\n\\n\" +\n                \"<command> -r fileInCurrentDirectory.txt\\n\" +\n                \"<command> -r ../../relativePathFile.xml\\n\" +\n                \"<command> -r ~/documents/myfile.pdf\\n\"+\n                \"<command> -r /usr/local/logs/absolutePathFile.log\\n\" +\n                \"<command> -r url:http://foo.com/page.html\\n\" +\n                \"<command> -r classpath:/WEB-INF/lib/something.jar\";\n\n        printException(e, debug);\n\n        System.out.println();\n        help.printHelp(command, header, options, null);\n        System.out.println(footer);\n    }\n\n    private static void exit(Exception e, boolean debug) {\n        printException(e, debug);\n        System.exit(-1);\n    }\n\n    private static void printException(Exception e, boolean debug) {\n        if (e != null) {\n            System.out.println();\n            if (debug) {\n                System.out.println(\"Error: \");\n                e.printStackTrace(System.out);\n                System.out.println(e.getMessage());\n\n            } else {\n                System.out.println(\"Error: \" + e.getMessage());\n                System.out.println();\n                System.out.println(\"Specify -d or --debug for more information.\");\n            }\n        }\n    }\n\n    private static void printHelpAndExit(Options options, Exception e, boolean debug, int exitCode) {\n        printHelp(options, e, debug);\n        System.exit(exitCode);\n    }\n}\n","lineNo":91}
{"Refactored Sample":"package org.apache.shiro.test;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.UnavailableSecurityManagerException;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.subject.support.SubjectThreadState;\nimport org.apache.shiro.util.LifecycleUtils;\nimport org.apache.shiro.util.ThreadState;\nimport org.junit.AfterClass;\n\n/**\n * Abstract test case showing how to use Shiro in testing environments.\n *\n * @since 1.1.1\n */\npublic abstract class AbstractShiroTest {\n\n    private static ThreadState subjectThreadState;\n\n    public AbstractShiroTest() {\n    }\n\n    /**\n     * Allows subclasses to set the currently executing {@link Subject} instance.\n     *\n     * @param subject the Subject instance\n     */\n    protected void setSubject(Subject subject) {\n        clearSubject();\n        subjectThreadState = createThreadState(subject);\n        subjectThreadState.bind();\n    }\n\n    protected Subject getSubject() {\n        return SecurityUtils.getSubject();\n    }\n\n    protected ThreadState createThreadState(Subject subject) {\n        return new SubjectThreadState(subject);\n    }\n\n    /**\n     * Clears Shiro's thread state, ensuring the thread remains clean for future test execution.\n     */\n    protected void clearSubject() {\n        doClearSubject();\n    }\n\n    private static void doClearSubject() {\n        if (subjectThreadState != null) {\n            subjectThreadState.clear();\n            subjectThreadState = null;\n        }\n    }\n\n    protected static void setSecurityManager(SecurityManager securityManager) {\n        SecurityUtils.setSecurityManager(securityManager);\n    }\n\n    protected static SecurityManager getSecurityManager() {\n        return SecurityUtils.getSecurityManager();\n    }\n\n    @AfterClass\n    public static void tearDownShiro() {\n        doClearSubject();\n        try {\n            SecurityManager securityManager = getSecurityManager();\n            LifecycleUtils.destroy(securityManager);\n        } catch (UnavailableSecurityManagerException e) {\n            //we don't care about this when cleaning up the test environment\n            //(for example, maybe the subclass is a unit test and it didn't\n            // need a SecurityManager instance because it was using only mock Subject instances)\n        }\n        setSecurityManager(null);\n    }\n}\n","Smelly Sample":"package org.apache.shiro.test;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.subject.support.SubjectThreadState;\nimport org.apache.shiro.util.LifecycleUtils;\nimport org.apache.shiro.util.ThreadState;\nimport org.junit.AfterClass;\n\n/**\n * Abstract test case showing how to use Shiro in testing environments.\n *\n * @since 1.1.1\n */\npublic abstract class AbstractShiroTest {\n\n    private static ThreadState subjectThreadState;\n\n    public AbstractShiroTest() {\n    }\n\n    /**\n     * Allows subclasses to set the currently executing {@link Subject} instance.\n     *\n     * @param subject the Subject instance\n     */\n    protected void setSubject(Subject subject) {\n        clearSubject();\n        subjectThreadState = createThreadState(subject);\n        subjectThreadState.bind();\n    }\n\n    protected Subject getSubject() {\n        return SecurityUtils.getSubject();\n    }\n\n    protected ThreadState createThreadState(Subject subject) {\n        return new SubjectThreadState(subject);\n    }\n\n    /**\n     * Clears Shiro's thread state, ensuring the thread remains clean for future test execution.\n     */\n    protected void clearSubject() {\n        doClearSubject();\n    }\n\n    private static void doClearSubject() {\n        if (subjectThreadState != null) {\n            subjectThreadState.clear();\n            subjectThreadState = null;\n        }\n    }\n\n    protected static void setSecurityManager(SecurityManager securityManager) {\n        SecurityUtils.setSecurityManager(securityManager);\n    }\n\n    protected static SecurityManager getSecurityManager() {\n        return SecurityUtils.getSecurityManager();\n    }\n\n    @AfterClass\n    public static void tearDownShiro() {\n        doClearSubject();\n        LifecycleUtils.destroy(getSecurityManager());\n        setSecurityManager(null);\n    }\n}\n","lineNo":69}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.config;\n\nimport org.apache.shiro.io.ResourceUtils;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.util.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * A class representing the <a href=\"http://en.wikipedia.org/wiki/INI_file\">INI<\/a> text configuration format.\n * <p/>\n * An Ini instance is a map of {@link Ini.Section Section}s, keyed by section name.  Each\n * {@code Section} is itself a map of {@code String} name/value pairs.  Name/value pairs are guaranteed to be unique\n * within each {@code Section} only - not across the entire {@code Ini} instance.\n *\n * @since 1.0\n */\npublic class Ini implements Map<String, Ini.Section> {\n\n    private static transient final Logger log = LoggerFactory.getLogger(Ini.class);\n\n    public static final String DEFAULT_SECTION_NAME = \"\"; //empty string means the first unnamed section\n    public static final String DEFAULT_CHARSET_NAME = \"UTF-8\";\n\n    public static final String COMMENT_POUND = \"#\";\n    public static final String COMMENT_SEMICOLON = \";\";\n    public static final String SECTION_PREFIX = \"[\";\n    public static final String SECTION_SUFFIX = \"]\";\n\n    protected static final char ESCAPE_TOKEN = '\\\\';\n\n    private final Map<String, Section> sections;\n\n    /**\n     * Creates a new empty {@code Ini} instance.\n     */\n    public Ini() {\n        this.sections = new LinkedHashMap<String, Section>();\n    }\n\n    /**\n     * Creates a new {@code Ini} instance with the specified defaults.\n     *\n     * @param defaults the default sections and/or key-value pairs to copy into the new instance.\n     */\n    public Ini(Ini defaults) {\n        this();\n        if (defaults == null) {\n            throw new NullPointerException(\"Defaults cannot be null.\");\n        }\n        for (Section section : defaults.getSections()) {\n            Section copy = new Section(section);\n            this.sections.put(section.getName(), copy);\n        }\n    }\n\n    /**\n     * Returns {@code true} if no sections have been configured, or if there are sections, but the sections themselves\n     * are all empty, {@code false} otherwise.\n     *\n     * @return {@code true} if no sections have been configured, or if there are sections, but the sections themselves\n     *         are all empty, {@code false} otherwise.\n     */\n    public boolean isEmpty() {\n        Collection<Section> sections = this.sections.values();\n        if (!sections.isEmpty()) {\n            for (Section section : sections) {\n                if (!section.isEmpty()) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the names of all sections managed by this {@code Ini} instance or an empty collection if there are\n     * no sections.\n     *\n     * @return the names of all sections managed by this {@code Ini} instance or an empty collection if there are\n     *         no sections.\n     */\n    public Set<String> getSectionNames() {\n        return Collections.unmodifiableSet(sections.keySet());\n    }\n\n    /**\n     * Returns the sections managed by this {@code Ini} instance or an empty collection if there are\n     * no sections.\n     *\n     * @return the sections managed by this {@code Ini} instance or an empty collection if there are\n     *         no sections.\n     */\n    public Collection<Section> getSections() {\n        return Collections.unmodifiableCollection(sections.values());\n    }\n\n    /**\n     * Returns the {@link Section} with the given name or {@code null} if no section with that name exists.\n     *\n     * @param sectionName the name of the section to retrieve.\n     * @return the {@link Section} with the given name or {@code null} if no section with that name exists.\n     */\n    public Section getSection(String sectionName) {\n        String name = cleanName(sectionName);\n        return sections.get(name);\n    }\n\n    /**\n     * Ensures a section with the specified name exists, adding a new one if it does not yet exist.\n     *\n     * @param sectionName the name of the section to ensure existence\n     * @return the section created if it did not yet exist, or the existing Section that already existed.\n     */\n    public Section addSection(String sectionName) {\n        String name = cleanName(sectionName);\n        Section section = getSection(name);\n        if (section == null) {\n            section = new Section(name);\n            this.sections.put(name, section);\n        }\n        return section;\n    }\n\n    /**\n     * Removes the section with the specified name and returns it, or {@code null} if the section did not exist.\n     *\n     * @param sectionName the name of the section to remove.\n     * @return the section with the specified name or {@code null} if the section did not exist.\n     */\n    public Section removeSection(String sectionName) {\n        String name = cleanName(sectionName);\n        return this.sections.remove(name);\n    }\n\n    private static String cleanName(String sectionName) {\n        String name = StringUtils.clean(sectionName);\n        if (name == null) {\n            log.trace(\"Specified name was null or empty.  Defaulting to the default section (name = \\\"\\\")\");\n            name = DEFAULT_SECTION_NAME;\n        }\n        return name;\n    }\n\n    /**\n     * Sets a name/value pair for the section with the given {@code sectionName}.  If the section does not yet exist,\n     * it will be created.  If the {@code sectionName} is null or empty, the name/value pair will be placed in the\n     * default (unnamed, empty string) section.\n     *\n     * @param sectionName   the name of the section to add the name/value pair\n     * @param propertyName  the name of the property to add\n     * @param propertyValue the property value\n     */\n    public void setSectionProperty(String sectionName, String propertyName, String propertyValue) {\n        String name = cleanName(sectionName);\n        Section section = getSection(name);\n        if (section == null) {\n            section = addSection(name);\n        }\n        section.put(propertyName, propertyValue);\n    }\n\n    /**\n     * Returns the value of the specified section property, or {@code null} if the section or property do not exist.\n     *\n     * @param sectionName  the name of the section to retrieve to acquire the property value\n     * @param propertyName the name of the section property for which to return the value\n     * @return the value of the specified section property, or {@code null} if the section or property do not exist.\n     */\n    public String getSectionProperty(String sectionName, String propertyName) {\n        Section section = getSection(sectionName);\n        return section != null ? section.get(propertyName) : null;\n    }\n\n    /**\n     * Returns the value of the specified section property, or the {@code defaultValue} if the section or\n     * property do not exist.\n     *\n     * @param sectionName  the name of the section to add the name/value pair\n     * @param propertyName the name of the property to add\n     * @param defaultValue the default value to return if the section or property do not exist.\n     * @return the value of the specified section property, or the {@code defaultValue} if the section or\n     *         property do not exist.\n     */\n    public String getSectionProperty(String sectionName, String propertyName, String defaultValue) {\n        String value = getSectionProperty(sectionName, propertyName);\n        return value != null ? value : defaultValue;\n    }\n\n    /**\n     * Creates a new {@code Ini} instance loaded with the INI-formatted data in the resource at the given path.  The\n     * resource path may be any value interpretable by the\n     * {@link ResourceUtils#getInputStreamForPath(String) ResourceUtils.getInputStreamForPath} method.\n     *\n     * @param resourcePath the resource location of the INI data to load when creating the {@code Ini} instance.\n     * @return a new {@code Ini} instance loaded with the INI-formatted data in the resource at the given path.\n     * @throws ConfigurationException if the path cannot be loaded into an {@code Ini} instance.\n     */\n    public static Ini fromResourcePath(String resourcePath) throws ConfigurationException {\n        if (!StringUtils.hasLength(resourcePath)) {\n            throw new IllegalArgumentException(\"Resource Path argument cannot be null or empty.\");\n        }\n        Ini ini = new Ini();\n        ini.loadFromPath(resourcePath);\n        return ini;\n    }\n\n    /**\n     * Loads data from the specified resource path into this current {@code Ini} instance.  The\n     * resource path may be any value interpretable by the\n     * {@link ResourceUtils#getInputStreamForPath(String) ResourceUtils.getInputStreamForPath} method.\n     *\n     * @param resourcePath the resource location of the INI data to load into this instance.\n     * @throws ConfigurationException if the path cannot be loaded\n     */\n    public void loadFromPath(String resourcePath) throws ConfigurationException {\n        InputStream is;\n        try {\n            is = ResourceUtils.getInputStreamForPath(resourcePath);\n        } catch (IOException e) {\n            throw new ConfigurationException(e);\n        }\n        load(is);\n    }\n\n    /**\n     * Loads the specified raw INI-formatted text into this instance.\n     *\n     * @param iniConfig the raw INI-formatted text to load into this instance.\n     * @throws ConfigurationException if the text cannot be loaded\n     */\n    public void load(String iniConfig) throws ConfigurationException {\n        load(new Scanner(iniConfig));\n    }\n\n    /**\n     * Loads the INI-formatted text backed by the given InputStream into this instance.  This implementation will\n     * close the input stream after it has finished loading.  It is expected that the stream's contents are\n     * UTF-8 encoded.\n     *\n     * @param is the {@code InputStream} from which to read the INI-formatted text\n     * @throws ConfigurationException if unable\n     */\n    public void load(InputStream is) throws ConfigurationException {\n        if (is == null) {\n            throw new NullPointerException(\"InputStream argument cannot be null.\");\n        }\n        InputStreamReader isr;\n        try {\n            isr = new InputStreamReader(is, DEFAULT_CHARSET_NAME);\n        } catch (UnsupportedEncodingException e) {\n            throw new ConfigurationException(e);\n        }\n        load(isr);\n    }\n\n    /**\n     * Loads the INI-formatted text backed by the given Reader into this instance.  This implementation will close the\n     * reader after it has finished loading.\n     *\n     * @param reader the {@code Reader} from which to read the INI-formatted text\n     */\n    public void load(Reader reader) {\n        Scanner scanner = new Scanner(reader);\n        try {\n            load(scanner);\n        } finally {\n            try {\n                scanner.close();\n            } catch (Exception e) {\n                log.debug(\"Unable to cleanly close the InputStream scanner.  Non-critical - ignoring.\", e);\n            }\n        }\n    }\n\n    private void addSection(String name, StringBuilder content) {\n        if (content.length() > 0) {\n            String contentString = content.toString();\n            String cleaned = StringUtils.clean(contentString);\n            if (cleaned != null) {\n                Section section = new Section(name, contentString);\n                if (!section.isEmpty()) {\n                    sections.put(name, section);\n                }\n            }\n        }\n    }\n\n    /**\n     * Loads the INI-formatted text backed by the given Scanner.  This implementation will close the\n     * scanner after it has finished loading.\n     *\n     * @param scanner the {@code Scanner} from which to read the INI-formatted text\n     */\n    public void load(Scanner scanner) {\n\n        String sectionName = DEFAULT_SECTION_NAME;\n        StringBuilder sectionContent = new StringBuilder();\n\n        while (scanner.hasNextLine()) {\n\n            String rawLine = scanner.nextLine();\n            String line = StringUtils.clean(rawLine);\n\n            if (line == null || line.startsWith(COMMENT_POUND) || line.startsWith(COMMENT_SEMICOLON)) {\n                //skip empty lines and comments:\n                continue;\n            }\n\n            String newSectionName = getSectionName(line);\n            if (newSectionName != null) {\n                //found a new section - convert the currently buffered one into a Section object\n                addSection(sectionName, sectionContent);\n\n                //reset the buffer for the new section:\n                sectionContent = new StringBuilder();\n\n                sectionName = newSectionName;\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Parsing \" + SECTION_PREFIX + sectionName + SECTION_SUFFIX);\n                }\n            } else {\n                //normal line - add it to the existing content buffer:\n                sectionContent.append(rawLine).append(\"\\n\");\n            }\n        }\n\n        //finish any remaining buffered content:\n        addSection(sectionName, sectionContent);\n    }\n\n    protected static boolean isSectionHeader(String line) {\n        String s = StringUtils.clean(line);\n        return s != null && s.startsWith(SECTION_PREFIX) && s.endsWith(SECTION_SUFFIX);\n    }\n\n    protected static String getSectionName(String line) {\n        String s = StringUtils.clean(line);\n        if (isSectionHeader(s)) {\n            return cleanName(s.substring(1, s.length() - 1));\n        }\n        return null;\n    }\n\n    public boolean equals(Object obj) {\n        if (obj instanceof Ini) {\n            Ini ini = (Ini) obj;\n            return this.sections.equals(ini.sections);\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return this.sections.hashCode();\n    }\n\n    public String toString() {\n        if (CollectionUtils.isEmpty(this.sections)) {\n            return \"<empty INI>\";\n        } else {\n            StringBuilder sb = new StringBuilder(\"sections=\");\n            int i = 0;\n            for (Ini.Section section : this.sections.values()) {\n                if (i > 0) {\n                    sb.append(\",\");\n                }\n                sb.append(section.toString());\n                i++;\n            }\n            return sb.toString();\n        }\n    }\n\n    public int size() {\n        return this.sections.size();\n    }\n\n    public boolean containsKey(Object key) {\n        return this.sections.containsKey(key);\n    }\n\n    public boolean containsValue(Object value) {\n        return this.sections.containsValue(value);\n    }\n\n    public Section get(Object key) {\n        return this.sections.get(key);\n    }\n\n    public Section put(String key, Section value) {\n        return this.sections.put(key, value);\n    }\n\n    public Section remove(Object key) {\n        return this.sections.remove(key);\n    }\n\n    public void putAll(Map<? extends String, ? extends Section> m) {\n        this.sections.putAll(m);\n    }\n\n    public void clear() {\n        this.sections.clear();\n    }\n\n    public Set<String> keySet() {\n        return Collections.unmodifiableSet(this.sections.keySet());\n    }\n\n    public Collection<Section> values() {\n        return Collections.unmodifiableCollection(this.sections.values());\n    }\n\n    public Set<Entry<String, Section>> entrySet() {\n        return Collections.unmodifiableSet(this.sections.entrySet());\n    }\n\n    /**\n     * An {@code Ini.Section} is String-key-to-String-value Map, identifiable by a\n     * {@link #getName() name} unique within an {@link Ini} instance.\n     */\n    public static class Section implements Map<String, String> {\n        private final String name;\n        private final Map<String, String> props;\n\n        private Section(String name) {\n            if (name == null) {\n                throw new NullPointerException(\"name\");\n            }\n            this.name = name;\n            this.props = new LinkedHashMap<String, String>();\n        }\n\n        private Section(String name, String sectionContent) {\n            if (name == null) {\n                throw new NullPointerException(\"name\");\n            }\n            this.name = name;\n            Map<String,String> props;\n            if (StringUtils.hasText(sectionContent) ) {\n                props = toMapProps(sectionContent);\n            } else {\n                props = new LinkedHashMap<String,String>();\n            }\n            if ( props != null ) {\n                this.props = props;\n            } else {\n                this.props = new LinkedHashMap<String,String>();\n            }\n        }\n\n        private Section(Section defaults) {\n            this(defaults.getName());\n            putAll(defaults.props);\n        }\n\n        //Protected to access in a test case - NOT considered part of Shiro's public API\n\n        protected static boolean isContinued(String line) {\n            if (line == null || line.isEmpty()) {\n                return false;\n            }\n            int length = line.length();\n            //find the number of backslashes at the end of the line.  If an even number, the\n            //backslashes are considered escaped.  If an odd number, the line is considered continued on the next line\n            int backslashCount = 0;\n            for (int i = length - 1; i > 0; i--) {\n                if (line.charAt(i) == ESCAPE_TOKEN) {\n                    backslashCount++;\n                } else {\n                    break;\n                }\n            }\n            return backslashCount % 2 != 0;\n        }\n\n        private static boolean isKeyValueSeparatorChar(char c) {\n            return Character.isWhitespace(c) || c == ':' || c == '=';\n        }\n\n        private static boolean isCharEscaped(CharSequence s, int index) {\n            return index > 0 && s.charAt(index - 1) == ESCAPE_TOKEN;\n        }\n\n        //Protected to access in a test case - NOT considered part of Shiro's public API\n        protected static String[] splitKeyValue(String keyValueLine) {\n            String line = StringUtils.clean(keyValueLine);\n            if (line == null) {\n                return null;\n            }\n            StringBuilder keyBuffer = new StringBuilder();\n            StringBuilder valueBuffer = new StringBuilder();\n\n            boolean buildingKey = true; //we'll build the value next:\n\n            for (int i = 0; i < line.length(); i++) {\n                char c = line.charAt(i);\n\n                if (buildingKey) {\n                    if (isKeyValueSeparatorChar(c) && !isCharEscaped(line, i)) {\n                        buildingKey = false;//now start building the value\n                    } else {\n                        keyBuffer.append(c);\n                    }\n                } else {\n                    if (valueBuffer.length() == 0 && isKeyValueSeparatorChar(c) && !isCharEscaped(line, i)) {\n                        //swallow the separator chars before we start building the value\n                    } else {\n                        valueBuffer.append(c);\n                    }\n                }\n            }\n\n            String key = StringUtils.clean(keyBuffer.toString());\n            String value = StringUtils.clean(valueBuffer.toString());\n\n            if (key == null || value == null) {\n                String msg = \"Line argument must contain a key and a value.  Only one string token was found.\";\n                throw new IllegalArgumentException(msg);\n            }\n\n            log.trace(\"Discovered key/value pair: {}={}\", key, value);\n\n            return new String[]{key, value};\n        }\n\n        private static Map<String, String> toMapProps(String content) {\n            Map<String, String> props = new LinkedHashMap<String, String>();\n            String line;\n            StringBuilder lineBuffer = new StringBuilder();\n            Scanner scanner = new Scanner(content);\n            while (scanner.hasNextLine()) {\n                line = StringUtils.clean(scanner.nextLine());\n                if (isContinued(line)) {\n                    //strip off the last continuation backslash:\n                    line = line.substring(0, line.length() - 1);\n                    lineBuffer.append(line);\n                    continue;\n                } else {\n                    lineBuffer.append(line);\n                }\n                line = lineBuffer.toString();\n                lineBuffer = new StringBuilder();\n                String[] kvPair = splitKeyValue(line);\n                props.put(kvPair[0], kvPair[1]);\n            }\n\n            return props;\n        }\n\n        public String getName() {\n            return this.name;\n        }\n\n        public void clear() {\n            this.props.clear();\n        }\n\n        public boolean containsKey(Object key) {\n            return this.props.containsKey(key);\n        }\n\n        public boolean containsValue(Object value) {\n            return this.props.containsValue(value);\n        }\n\n        public Set<Entry<String, String>> entrySet() {\n            return this.props.entrySet();\n        }\n\n        public String get(Object key) {\n            return this.props.get(key);\n        }\n\n        public boolean isEmpty() {\n            return this.props.isEmpty();\n        }\n\n        public Set<String> keySet() {\n            return this.props.keySet();\n        }\n\n        public String put(String key, String value) {\n            return this.props.put(key, value);\n        }\n\n        public void putAll(Map<? extends String, ? extends String> m) {\n            this.props.putAll(m);\n        }\n\n        public String remove(Object key) {\n            return this.props.remove(key);\n        }\n\n        public int size() {\n            return this.props.size();\n        }\n\n        public Collection<String> values() {\n            return this.props.values();\n        }\n\n        public String toString() {\n            String name = getName();\n            if (DEFAULT_SECTION_NAME.equals(name)) {\n                return \"<default>\";\n            }\n            return name;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof Section) {\n                Section other = (Section) obj;\n                return getName().equals(other.getName()) && this.props.equals(other.props);\n            }\n            return false;\n        }\n\n        @Override\n        public int hashCode() {\n            return this.name.hashCode() * 31 + this.props.hashCode();\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.config;\n\nimport org.apache.shiro.io.ResourceUtils;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.util.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * A class representing the <a href=\"http://en.wikipedia.org/wiki/INI_file\">INI<\/a> text configuration format.\n * <p/>\n * An Ini instance is a map of {@link Ini.Section Section}s, keyed by section name.  Each\n * {@code Section} is itself a map of {@code String} name/value pairs.  Name/value pairs are guaranteed to be unique\n * within each {@code Section} only - not across the entire {@code Ini} instance.\n *\n * @since 1.0\n */\npublic class Ini implements Map<String, Ini.Section> {\n\n    private static transient final Logger log = LoggerFactory.getLogger(Ini.class);\n\n    public static final String DEFAULT_SECTION_NAME = \"\"; //empty string means the first unnamed section\n    public static final String DEFAULT_CHARSET_NAME = \"ISO-8859-1\";\n\n    public static final String COMMENT_POUND = \"#\";\n    public static final String COMMENT_SEMICOLON = \";\";\n    public static final String SECTION_PREFIX = \"[\";\n    public static final String SECTION_SUFFIX = \"]\";\n\n    private final Map<String, Section> sections;\n\n    /**\n     * Creates a new empty {@code Ini} instance.\n     */\n    public Ini() {\n        this.sections = new LinkedHashMap<String, Section>();\n    }\n\n    /**\n     * Creates a new {@code Ini} instance with the specified defaults.\n     *\n     * @param defaults the default sections and/or key-value pairs to copy into the new instance.\n     */\n    public Ini(Ini defaults) {\n        this();\n        if (defaults == null) {\n            throw new NullPointerException(\"Defaults cannot be null.\");\n        }\n        for (Section section : defaults.getSections()) {\n            Section copy = new Section(section);\n            this.sections.put(section.getName(), copy);\n        }\n    }\n\n    /**\n     * Returns {@code true} if no sections have been configured, or if there are sections, but the sections themselves\n     * are all empty, {@code false} otherwise.\n     *\n     * @return {@code true} if no sections have been configured, or if there are sections, but the sections themselves\n     *         are all empty, {@code false} otherwise.\n     */\n    public boolean isEmpty() {\n        Collection<Section> sections = this.sections.values();\n        if (!sections.isEmpty()) {\n            for (Section section : sections) {\n                if (!section.isEmpty()) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the names of all sections managed by this {@code Ini} instance or an empty collection if there are\n     * no sections.\n     *\n     * @return the names of all sections managed by this {@code Ini} instance or an empty collection if there are\n     *         no sections.\n     */\n    public Set<String> getSectionNames() {\n        return Collections.unmodifiableSet(sections.keySet());\n    }\n\n    /**\n     * Returns the sections managed by this {@code Ini} instance or an empty collection if there are\n     * no sections.\n     *\n     * @return the sections managed by this {@code Ini} instance or an empty collection if there are\n     *         no sections.\n     */\n    public Collection<Section> getSections() {\n        return Collections.unmodifiableCollection(sections.values());\n    }\n\n    /**\n     * Returns the {@link Section} with the given name or {@code null} if no section with that name exists.\n     *\n     * @param sectionName the name of the section to retrieve.\n     * @return the {@link Section} with the given name or {@code null} if no section with that name exists.\n     */\n    public Section getSection(String sectionName) {\n        String name = cleanName(sectionName);\n        return sections.get(name);\n    }\n\n    /**\n     * Ensures a section with the specified name exists, adding a new one if it does not yet exist.\n     *\n     * @param sectionName the name of the section to ensure existence\n     * @return the section created if it did not yet exist, or the existing Section that already existed.\n     */\n    public Section addSection(String sectionName) {\n        String name = cleanName(sectionName);\n        Section section = getSection(name);\n        if (section == null) {\n            section = new Section(name);\n            this.sections.put(name, section);\n        }\n        return section;\n    }\n\n    /**\n     * Removes the section with the specified name and returns it, or {@code null} if the section did not exist.\n     *\n     * @param sectionName the name of the section to remove.\n     * @return the section with the specified name or {@code null} if the section did not exist.\n     */\n    public Section removeSection(String sectionName) {\n        String name = cleanName(sectionName);\n        return this.sections.remove(name);\n    }\n\n    private static String cleanName(String sectionName) {\n        String name = StringUtils.clean(sectionName);\n        if (name == null) {\n            log.trace(\"Specified name was null or empty.  Defaulting to the default section (name = \\\"\\\")\");\n            name = DEFAULT_SECTION_NAME;\n        }\n        return name;\n    }\n\n    /**\n     * Sets a name/value pair for the section with the given {@code sectionName}.  If the section does not yet exist,\n     * it will be created.  If the {@code sectionName} is null or empty, the name/value pair will be placed in the\n     * default (unnamed, empty string) section.\n     *\n     * @param sectionName   the name of the section to add the name/value pair\n     * @param propertyName  the name of the property to add\n     * @param propertyValue the property value\n     */\n    public void setSectionProperty(String sectionName, String propertyName, String propertyValue) {\n        String name = cleanName(sectionName);\n        Section section = getSection(name);\n        if (section == null) {\n            section = addSection(name);\n        }\n        section.put(propertyName, propertyValue);\n    }\n\n    /**\n     * Returns the value of the specified section property, or {@code null} if the section or property do not exist.\n     *\n     * @param sectionName  the name of the section to retrieve to acquire the property value\n     * @param propertyName the name of the section property for which to return the value\n     * @return the value of the specified section property, or {@code null} if the section or property do not exist.\n     */\n    public String getSectionProperty(String sectionName, String propertyName) {\n        Section section = getSection(sectionName);\n        return section != null ? section.get(propertyName) : null;\n    }\n\n    /**\n     * Returns the value of the specified section property, or the {@code defaultValue} if the section or\n     * property do not exist.\n     *\n     * @param sectionName  the name of the section to add the name/value pair\n     * @param propertyName the name of the property to add\n     * @param defaultValue the default value to return if the section or property do not exist.\n     * @return the value of the specified section property, or the {@code defaultValue} if the section or\n     *         property do not exist.\n     */\n    public String getSectionProperty(String sectionName, String propertyName, String defaultValue) {\n        String value = getSectionProperty(sectionName, propertyName);\n        return value != null ? value : defaultValue;\n    }\n\n    /**\n     * Creates a new {@code Ini} instance loaded with the INI-formatted data in the resource at the given path.  The\n     * resource path may be any value interpretable by the\n     * {@link ResourceUtils#getInputStreamForPath(String) ResourceUtils.getInputStreamForPath} method.\n     *\n     * @param resourcePath the resource location of the INI data to load when creating the {@code Ini} instance.\n     * @return a new {@code Ini} instance loaded with the INI-formatted data in the resource at the given path.\n     * @throws ConfigurationException if the path cannot be loaded into an {@code Ini} instance.\n     */\n    public static Ini fromResourcePath(String resourcePath) throws ConfigurationException {\n        if (!StringUtils.hasLength(resourcePath)) {\n            throw new IllegalArgumentException(\"Resource Path argument cannot be null or empty.\");\n        }\n        Ini ini = new Ini();\n        ini.loadFromPath(resourcePath);\n        return ini;\n    }\n\n    /**\n     * Loads data from the specified resource path into this current {@code Ini} instance.  The\n     * resource path may be any value interpretable by the\n     * {@link ResourceUtils#getInputStreamForPath(String) ResourceUtils.getInputStreamForPath} method.\n     *\n     * @param resourcePath the resource location of the INI data to load into this instance.\n     * @throws ConfigurationException if the path cannot be loaded\n     */\n    public void loadFromPath(String resourcePath) throws ConfigurationException {\n        InputStream is;\n        try {\n            is = ResourceUtils.getInputStreamForPath(resourcePath);\n        } catch (IOException e) {\n            throw new ConfigurationException(e);\n        }\n        load(is);\n    }\n\n    /**\n     * Loads the specified raw INI-formatted text into this instance.\n     *\n     * @param iniConfig the raw INI-formatted text to load into this instance.\n     * @throws ConfigurationException if the text cannot be loaded\n     */\n    public void load(String iniConfig) throws ConfigurationException {\n        load(new Scanner(iniConfig));\n    }\n\n    /**\n     * Loads the INI-formatted text backed by the given InputStream into this instance.  This implementation will\n     * close the input stream after it has finished loading.\n     *\n     * @param is the {@code InputStream} from which to read the INI-formatted text\n     * @throws ConfigurationException if unable\n     */\n    public void load(InputStream is) throws ConfigurationException {\n        if (is == null) {\n            throw new NullPointerException(\"InputStream argument cannot be null.\");\n        }\n        InputStreamReader isr;\n        try {\n            isr = new InputStreamReader(is, DEFAULT_CHARSET_NAME);\n        } catch (UnsupportedEncodingException e) {\n            throw new ConfigurationException(e);\n        }\n        load(isr);\n    }\n\n    /**\n     * Loads the INI-formatted text backed by the given Reader into this instance.  This implementation will close the\n     * reader after it has finished loading.\n     *\n     * @param reader the {@code Reader} from which to read the INI-formatted text\n     */\n    public void load(Reader reader) {\n        Scanner scanner = new Scanner(reader);\n        try {\n            load(scanner);\n        } finally {\n            try {\n                scanner.close();\n            } catch (Exception e) {\n                log.debug(\"Unable to cleanly close the InputStream scanner.  Non-critical - ignoring.\", e);\n            }\n        }\n    }\n\n    private static InputStream toInputStream(String content) {\n        byte[] bytes;\n        try {\n            bytes = content.getBytes(DEFAULT_CHARSET_NAME);\n        } catch (UnsupportedEncodingException e) {\n            throw new ConfigurationException(e);\n        }\n        return new ByteArrayInputStream(bytes);\n    }\n\n    private static Properties toProps(String content) {\n        InputStream is = toInputStream(content);\n        Properties props = new Properties();\n        try {\n            props.load(is);\n        } catch (IOException e) {\n            throw new ConfigurationException(e);\n        }\n        return props;\n    }\n\n    private void addSection(String name, StringBuffer content) {\n        if (content.length() > 0) {\n            String contentString = content.toString();\n            String cleaned = StringUtils.clean(contentString);\n            if (cleaned != null) {\n                Properties props = toProps(contentString);\n                if (!props.isEmpty()) {\n                    sections.put(name, new Section(name, props));\n                }\n            }\n        }\n    }\n\n    /**\n     * Loads the INI-formatted text backed by the given Scanner.  This implementation will close the\n     * scanner after it has finished loading.\n     *\n     * @param scanner the {@code Scanner} from which to read the INI-formatted text\n     */\n    public void load(Scanner scanner) {\n\n        String sectionName = DEFAULT_SECTION_NAME;\n        StringBuffer sectionContent = new StringBuffer();\n\n        while (scanner.hasNextLine()) {\n\n            String rawLine = scanner.nextLine();\n            String line = StringUtils.clean(rawLine);\n\n            if (line == null || line.startsWith(COMMENT_POUND) || line.startsWith(COMMENT_SEMICOLON)) {\n                //skip empty lines and comments:\n                continue;\n            }\n\n            String newSectionName = getSectionName(line);\n            if (newSectionName != null) {\n                //found a new section - convert the currently buffered one into a Section object\n                addSection(sectionName, sectionContent);\n\n                //reset the buffer for the new section:\n                sectionContent = new StringBuffer();\n\n                sectionName = newSectionName;\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Parsing \" + SECTION_PREFIX + sectionName + SECTION_SUFFIX);\n                }\n            } else {\n                //normal line - add it to the existing content buffer:\n                sectionContent.append(rawLine).append(\"\\n\");\n            }\n        }\n\n        //finish any remaining buffered content:\n        addSection(sectionName, sectionContent);\n    }\n\n    protected static boolean isSectionHeader(String line) {\n        String s = StringUtils.clean(line);\n        return s != null && s.startsWith(SECTION_PREFIX) && s.endsWith(SECTION_SUFFIX);\n    }\n\n    protected static String getSectionName(String line) {\n        String s = StringUtils.clean(line);\n        if (isSectionHeader(s)) {\n            return cleanName(s.substring(1, s.length() - 1));\n        }\n        return null;\n    }\n\n    public boolean equals(Object obj) {\n        if (obj instanceof Ini) {\n            Ini ini = (Ini) obj;\n            return this.sections.equals(ini.sections);\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return this.sections.hashCode();\n    }\n\n    public String toString() {\n        if (CollectionUtils.isEmpty(this.sections)) {\n            return \"<empty INI>\";\n        } else {\n            StringBuilder sb = new StringBuilder(\"sections=\");\n            int i = 0;\n            for (Ini.Section section : this.sections.values()) {\n                if (i > 0) {\n                    sb.append(\",\");\n                }\n                sb.append(section.toString());\n                i++;\n            }\n            return sb.toString();\n        }\n    }\n\n    public int size() {\n        return this.sections.size();\n    }\n\n    public boolean containsKey(Object key) {\n        return this.sections.containsKey(key);\n    }\n\n    public boolean containsValue(Object value) {\n        return this.sections.containsValue(value);\n    }\n\n    public Section get(Object key) {\n        return this.sections.get(key);\n    }\n\n    public Section put(String key, Section value) {\n        return this.sections.put(key, value);\n    }\n\n    public Section remove(Object key) {\n        return this.sections.remove(key);\n    }\n\n    public void putAll(Map<? extends String, ? extends Section> m) {\n        this.sections.putAll(m);\n    }\n\n    public void clear() {\n        this.sections.clear();\n    }\n\n    public Set<String> keySet() {\n        return Collections.unmodifiableSet(this.sections.keySet());\n    }\n\n    public Collection<Section> values() {\n        return Collections.unmodifiableCollection(this.sections.values());\n    }\n\n    public Set<Entry<String, Section>> entrySet() {\n        return Collections.unmodifiableSet(this.sections.entrySet());\n    }\n\n    /**\n     * An {@code Ini.Section} is String-key-to-String-value Map, identifiable by a\n     * {@link #getName() name} unique within an {@link Ini} instance.\n     */\n    public class Section implements Map<String, String> {\n        private final String name;\n        private final Map<String, String> props;\n\n        private Section(String name) {\n            if (name == null) {\n                throw new NullPointerException(\"name\");\n            }\n            this.name = name;\n            this.props = new LinkedHashMap<String, String>();\n        }\n\n        private Section(String name, Properties props) {\n            this(name);\n            Enumeration propNames = props.propertyNames();\n            while (propNames != null && propNames.hasMoreElements()) {\n                String key = propNames.nextElement().toString();\n                String value = props.getProperty(key);\n                if (value != null) {\n                    this.props.put(key, value.trim());\n                }\n            }\n        }\n\n        private Section(Section defaults) {\n            this(defaults.getName());\n            putAll(defaults.props);\n        }\n\n        public String getName() {\n            return this.name;\n        }\n\n        public void clear() {\n            this.props.clear();\n        }\n\n        public boolean containsKey(Object key) {\n            return this.props.containsKey(key);\n        }\n\n        public boolean containsValue(Object value) {\n            return this.props.containsValue(value);\n        }\n\n        public Set<Entry<String, String>> entrySet() {\n            return this.props.entrySet();\n        }\n\n        public String get(Object key) {\n            return this.props.get(key);\n        }\n\n        public boolean isEmpty() {\n            return this.props.isEmpty();\n        }\n\n        public Set<String> keySet() {\n            return this.props.keySet();\n        }\n\n        public String put(String key, String value) {\n            return this.props.put(key, value);\n        }\n\n        public void putAll(Map<? extends String, ? extends String> m) {\n            this.props.putAll(m);\n        }\n\n        public String remove(Object key) {\n            return this.props.remove(key);\n        }\n\n        public int size() {\n            return this.props.size();\n        }\n\n        public Collection<String> values() {\n            return this.props.values();\n        }\n\n        public String toString() {\n            String name = getName();\n            if (DEFAULT_SECTION_NAME.equals(name)) {\n                return \"<default>\";\n            }\n            return name;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof Section) {\n                Section other = (Section) obj;\n                return getName().equals(other.getName()) && this.props.equals(other.props);\n            }\n            return false;\n        }\n\n        @Override\n        public int hashCode() {\n            return this.name.hashCode() * 31 + this.props.hashCode();\n        }\n    }\n\n}\n","lineNo":302}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.session.mgt;\n\nimport org.apache.shiro.session.InvalidSessionException;\nimport org.apache.shiro.session.Session;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Date;\n\n/**\n * A DelegatingSession is a client-tier representation of a server side\n * {@link org.apache.shiro.session.Session Session}.\n * This implementation is basically a proxy to a server-side {@link NativeSessionManager NativeSessionManager},\n * which will return the proper results for each method call.\n * <p/>\n * <p>A <tt>DelegatingSession<\/tt> will cache data when appropriate to avoid a remote method invocation,\n * only communicating with the server when necessary.\n * <p/>\n * <p>Of course, if used in-process with a NativeSessionManager business POJO, as might be the case in a\n * web-based application where the web classes and server-side business pojos exist in the same\n * JVM, a remote method call will not be incurred.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DelegatingSession implements Session, Serializable {\n\n    //TODO - complete JavaDoc\n\n    private final SessionKey key;\n\n    //cached fields to avoid a server-side method call if out-of-process:\n    private Date startTimestamp = null;\n    private String host = null;\n\n    /**\n     * Handle to the target NativeSessionManager that will support the delegate calls.\n     */\n    private final transient NativeSessionManager sessionManager;\n\n\n    public DelegatingSession(NativeSessionManager sessionManager, SessionKey key) {\n        if (sessionManager == null) {\n            throw new IllegalArgumentException(\"sessionManager argument cannot be null.\");\n        }\n        if (key == null) {\n            throw new IllegalArgumentException(\"sessionKey argument cannot be null.\");\n        }\n        if (key.getSessionId() == null) {\n            String msg = \"The \" + DelegatingSession.class.getName() + \" implementation requires that the \" +\n                    \"SessionKey argument returns a non-null sessionId to support the \" +\n                    \"Session.getId() invocations.\";\n            throw new IllegalArgumentException(msg);\n        }\n        this.sessionManager = sessionManager;\n        this.key = key;\n    }\n\n    /**\n     * @see org.apache.shiro.session.Session#getId()\n     */\n    public Serializable getId() {\n        return key.getSessionId();\n    }\n\n    /**\n     * @see org.apache.shiro.session.Session#getStartTimestamp()\n     */\n    public Date getStartTimestamp() {\n        if (startTimestamp == null) {\n            startTimestamp = sessionManager.getStartTimestamp(key);\n        }\n        return startTimestamp;\n    }\n\n    /**\n     * @see org.apache.shiro.session.Session#getLastAccessTime()\n     */\n    public Date getLastAccessTime() {\n        //can't cache - only business pojo knows the accurate time:\n        return sessionManager.getLastAccessTime(key);\n    }\n\n    public long getTimeout() throws InvalidSessionException {\n        return sessionManager.getTimeout(key);\n    }\n\n    public void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException {\n        sessionManager.setTimeout(key, maxIdleTimeInMillis);\n    }\n\n    public String getHost() {\n        if (host == null) {\n            host = sessionManager.getHost(key);\n        }\n        return host;\n    }\n\n    /**\n     * @see org.apache.shiro.session.Session#touch()\n     */\n    public void touch() throws InvalidSessionException {\n        sessionManager.touch(key);\n    }\n\n    /**\n     * @see org.apache.shiro.session.Session#stop()\n     */\n    public void stop() throws InvalidSessionException {\n        sessionManager.stop(key);\n    }\n\n    /**\n     * @see org.apache.shiro.session.Session#getAttributeKeys\n     */\n    public Collection<Object> getAttributeKeys() throws InvalidSessionException {\n        return sessionManager.getAttributeKeys(key);\n    }\n\n    /**\n     * @see org.apache.shiro.session.Session#getAttribute(Object key)\n     */\n    public Object getAttribute(Object attributeKey) throws InvalidSessionException {\n        return sessionManager.getAttribute(this.key, attributeKey);\n    }\n\n    /**\n     * @see Session#setAttribute(Object key, Object value)\n     */\n    public void setAttribute(Object attributeKey, Object value) throws InvalidSessionException {\n        if (value == null) {\n            removeAttribute(attributeKey);\n        } else {\n            sessionManager.setAttribute(this.key, attributeKey, value);\n        }\n    }\n\n    /**\n     * @see Session#removeAttribute(Object key)\n     */\n    public Object removeAttribute(Object attributeKey) throws InvalidSessionException {\n        return sessionManager.removeAttribute(this.key, attributeKey);\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.session.mgt;\n\nimport org.apache.shiro.session.InvalidSessionException;\nimport org.apache.shiro.session.Session;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Date;\n\n/**\n * A DelegatingSession is a client-tier representation of a server side\n * {@link org.apache.shiro.session.Session Session}.\n * This implementation is basically a proxy to a server-side {@link SessionManager SessionManager},\n * which will return the proper results for each method call.\n * <p/>\n * <p>A <tt>DelegatingSession<\/tt> will cache data when appropriate to avoid a remote method invocation,\n * only communicating with the server when necessary.\n * <p/>\n * <p>Of course, if used in-process with a SessionManager business POJO, as might be the case in a\n * web-based application where the web classes and server-side business pojos exist in the same\n * JVM, a remote method call will not be incurred.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DelegatingSession implements Session, Serializable {\n\n    //TODO - complete JavaDoc\n\n    private Serializable id = null;\n\n    //cached fields to avoid a server-side method call if out-of-process:\n    private Date startTimestamp = null;\n    private String host = null;\n\n    /**\n     * Handle to a server-side SessionManager.  See {@link #setSessionManager} for details.\n     */\n    private transient SessionManager sessionManager = null;\n\n\n    public DelegatingSession() {\n    }\n\n    public DelegatingSession(SessionManager sessionManager, Serializable id) {\n        if (sessionManager == null) {\n            throw new IllegalArgumentException(\"sessionManager argument cannot be null.\");\n        }\n        if (id == null) {\n            throw new IllegalArgumentException(\"session id argument cannot be null.\");\n        }\n        this.sessionManager = sessionManager;\n        this.id = id;\n    }\n\n    public DelegatingSession(SessionManager sessionManager, Serializable id, String host) {\n        this(sessionManager, id);\n        this.host = host;\n    }\n\n    /**\n     * Returns the {@link SessionManager SessionManager} used by this handle to invoke\n     * all session-related methods.\n     *\n     * @return the {@link SessionManager SessionManager} used by this handle to invoke\n     *         all session-related methods.\n     */\n    public SessionManager getSessionManager() {\n        return sessionManager;\n    }\n\n    /**\n     * Sets the {@link SessionManager SessionManager} to which this <tt>DelegatingSession<\/tt> will\n     * delegate its method calls.  In a rich client environment, this <tt>SessionManager<\/tt> will\n     * probably be a remoting proxy which executes remote method invocations.  In a single-process\n     * environment (e.g. a web  application deployed in the same JVM of the application server),\n     * the <tt>SessionManager<\/tt> can be the actual business POJO implementation.\n     * <p/>\n     * <p>You'll notice the {@link Session Session} interface and the {@link SessionManager}\n     * interface are nearly identical.  This is to ensure the SessionManager can support\n     * most method calls in the Session interface, via this handle/proxy technique.  The session\n     * manager is implementated as a stateless business POJO, with the handle passing the\n     * session id as necessary.\n     *\n     * @param sessionManager the <tt>SessionManager<\/tt> this handle will use when delegating\n     *                       method calls.\n     */\n    public void setSessionManager(SessionManager sessionManager) {\n        this.sessionManager = sessionManager;\n    }\n\n    /**\n     * Sets the sessionId used by this handle for all future {@link SessionManager SessionManager}\n     * method invocations.\n     *\n     * @param id the <tt>sessionId<\/tt> to use for all <tt>SessionManager<\/tt> invocations.\n     * @see #setSessionManager(SessionManager sessionManager)\n     */\n    public void setId(Serializable id) {\n        this.id = id;\n    }\n\n    /**\n     * @see org.apache.shiro.session.Session#getId()\n     */\n    public Serializable getId() {\n        return id;\n    }\n\n    /**\n     * @see org.apache.shiro.session.Session#getStartTimestamp()\n     */\n    public Date getStartTimestamp() {\n        if (startTimestamp == null) {\n            startTimestamp = sessionManager.getStartTimestamp(id);\n        }\n        return startTimestamp;\n    }\n\n    /**\n     * @see org.apache.shiro.session.Session#getLastAccessTime()\n     */\n    public Date getLastAccessTime() {\n        //can't cache - only business pojo knows the accurate time:\n        return sessionManager.getLastAccessTime(id);\n    }\n\n    public long getTimeout() throws InvalidSessionException {\n        return sessionManager.getTimeout(id);\n    }\n\n    public void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException {\n        sessionManager.setTimeout(id, maxIdleTimeInMillis);\n    }\n\n    public String getHost() {\n        if (host == null) {\n            host = sessionManager.getHost(id);\n        }\n        return host;\n    }\n\n    /**\n     * @see org.apache.shiro.session.Session#touch()\n     */\n    public void touch() throws InvalidSessionException {\n        sessionManager.touch(id);\n    }\n\n    /**\n     * @see org.apache.shiro.session.Session#stop()\n     */\n    public void stop() throws InvalidSessionException {\n        sessionManager.stop(id);\n    }\n\n    /**\n     * @see org.apache.shiro.session.Session#getAttributeKeys\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public Collection<Object> getAttributeKeys() throws InvalidSessionException {\n        return sessionManager.getAttributeKeys(id);\n    }\n\n    /**\n     * @see org.apache.shiro.session.Session#getAttribute(Object key)\n     */\n    public Object getAttribute(Object key) throws InvalidSessionException {\n        return sessionManager.getAttribute(id, key);\n    }\n\n    /**\n     * @see Session#setAttribute(Object key, Object value)\n     */\n    public void setAttribute(Object key, Object value) throws InvalidSessionException {\n        if (value == null) {\n            removeAttribute(key);\n        } else {\n            sessionManager.setAttribute(id, key, value);\n        }\n    }\n\n    /**\n     * @see Session#removeAttribute(Object key)\n     */\n    public Object removeAttribute(Object key) throws InvalidSessionException {\n        return sessionManager.removeAttribute(id, key);\n    }\n}\n","lineNo":69}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.spring.remoting;\n\nimport org.aopalliance.intercept.MethodInvocation;\nimport org.apache.shiro.session.mgt.DefaultSessionKey;\nimport org.apache.shiro.session.mgt.SessionKey;\nimport org.apache.shiro.session.mgt.SessionManager;\nimport org.apache.shiro.util.ThreadContext;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.springframework.remoting.support.RemoteInvocation;\n\nimport java.lang.reflect.Method;\nimport java.util.UUID;\n\nimport static org.easymock.EasyMock.*;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\n\n/**\n * //TODO - Class JavaDoc!\n *\n * @author Les Hazlewood\n */\npublic class SecureRemoteInvocationFactoryTest {\n\n    @Before\n    public void setup() {\n        ThreadContext.remove();\n    }\n\n    @After\n    public void tearDown() {\n        ThreadContext.remove();\n    }\n\n    protected Method getMethod(String name, Class clazz) {\n        Method[] methods = clazz.getMethods();\n        for (Method method : methods) {\n            if (method.getName().equals(name)) {\n                return method;\n            }\n        }\n        throw new IllegalStateException(\"'\" + name + \"' method should exist.\");\n    }\n\n    @Test\n    public void testSessionManagerProxyStartRemoteInvocation() throws Exception {\n\n        SecureRemoteInvocationFactory factory = new SecureRemoteInvocationFactory();\n\n        MethodInvocation mi = createMock(MethodInvocation.class);\n        Method startMethod = getMethod(\"start\", SessionManager.class);\n        expect(mi.getMethod()).andReturn(startMethod).anyTimes();\n\n        Object[] args = {\"localhost\"};\n        expect(mi.getArguments()).andReturn(args).anyTimes();\n\n        replay(mi);\n\n        RemoteInvocation ri = factory.createRemoteInvocation(mi);\n\n        verify(mi);\n\n        assertNull(ri.getAttribute(SecureRemoteInvocationFactory.SESSION_ID_KEY));\n    }\n\n    @Test\n    public void testSessionManagerProxyNonStartRemoteInvocation() throws Exception {\n\n        SecureRemoteInvocationFactory factory = new SecureRemoteInvocationFactory();\n\n        MethodInvocation mi = createMock(MethodInvocation.class);\n        Method method = getMethod(\"getSession\", SessionManager.class);\n        expect(mi.getMethod()).andReturn(method).anyTimes();\n\n        String dummySessionId = UUID.randomUUID().toString();\n        SessionKey sessionKey = new DefaultSessionKey(dummySessionId);\n        Object[] args = {sessionKey};\n        expect(mi.getArguments()).andReturn(args).anyTimes();\n\n        replay(mi);\n\n        RemoteInvocation ri = factory.createRemoteInvocation(mi);\n\n        verify(mi);\n\n        assertEquals(dummySessionId, ri.getAttribute(SecureRemoteInvocationFactory.SESSION_ID_KEY));\n    }\n\n    /*@Test\n    public void testNonSessionManagerCall() throws Exception {\n\n        SecureRemoteInvocationFactory factory = new SecureRemoteInvocationFactory();\n\n        MethodInvocation mi = createMock(MethodInvocation.class);\n        Method method = getMethod(\"login\", SecurityManager.class);\n        expect(mi.getMethod()).andReturn(method).anyTimes();\n    }*/\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.spring.remoting;\n\nimport org.aopalliance.intercept.MethodInvocation;\nimport org.apache.shiro.session.mgt.SessionManager;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.util.ThreadContext;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.springframework.remoting.support.RemoteInvocation;\n\nimport java.lang.reflect.Method;\nimport java.util.UUID;\n\nimport static org.easymock.EasyMock.*;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\n\n/**\n * //TODO - Class JavaDoc!\n *\n * @author Les Hazlewood\n */\npublic class SecureRemoteInvocationFactoryTest {\n\n    @Before\n    public void setup() {\n        ThreadContext.remove();\n    }\n\n    protected void bind(Subject subject) {\n        ThreadContext.bind(subject);\n    }\n\n    @After\n    public void tearDown() {\n        ThreadContext.remove();\n    }\n\n    protected Method getMethod(String name, Class clazz) {\n        Method[] methods = clazz.getMethods();\n        for (Method method : methods) {\n            if (method.getName().equals(name)) {\n                return method;\n            }\n        }\n        throw new IllegalStateException(\"'\" + name + \"' method should exist.\");\n    }\n\n    @Test\n    public void testSessionManagerProxyStartRemoteInvocation() throws Exception {\n\n        SecureRemoteInvocationFactory factory = new SecureRemoteInvocationFactory();\n\n        MethodInvocation mi = createMock(MethodInvocation.class);\n        Method startMethod = getMethod(\"start\", SessionManager.class);\n        expect(mi.getMethod()).andReturn(startMethod).anyTimes();\n\n        Object[] args = {\"localhost\"};\n        expect(mi.getArguments()).andReturn(args).anyTimes();\n\n        replay(mi);\n\n        RemoteInvocation ri = factory.createRemoteInvocation(mi);\n\n        verify(mi);\n\n        assertNull(ri.getAttribute(SecureRemoteInvocationFactory.SESSION_ID_KEY));\n    }\n\n    @Test\n    public void testSessionManagerProxyNonStartRemoteInvocation() throws Exception {\n\n        SecureRemoteInvocationFactory factory = new SecureRemoteInvocationFactory();\n\n        MethodInvocation mi = createMock(MethodInvocation.class);\n        Method method = getMethod(\"isValid\", SessionManager.class);\n        expect(mi.getMethod()).andReturn(method).anyTimes();\n\n        String dummySessionId = UUID.randomUUID().toString();\n        Object[] args = {dummySessionId};\n        expect(mi.getArguments()).andReturn(args).anyTimes();\n\n        replay(mi);\n\n        RemoteInvocation ri = factory.createRemoteInvocation(mi);\n\n        verify(mi);\n\n        assertEquals(dummySessionId, ri.getAttribute(SecureRemoteInvocationFactory.SESSION_ID_KEY));\n    }\n\n    /*@Test\n    public void testNonSessionManagerCall() throws Exception {\n\n        SecureRemoteInvocationFactory factory = new SecureRemoteInvocationFactory();\n\n        MethodInvocation mi = createMock(MethodInvocation.class);\n        Method method = getMethod(\"login\", SecurityManager.class);\n        expect(mi.getMethod()).andReturn(method).anyTimes();\n    }*/\n\n}\n","lineNo":96}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.servlet;\n\nimport org.apache.shiro.util.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.TimeZone;\n\n/**\n * TODO - Class JavaDoc\n *\n * @author Les Hazlewood\n * @since 1.0\n */\npublic class SimpleCookie implements Cookie {\n\n    /**\n     * {@code -1}, indicating the cookie should expire when the browser closes.\n     */\n    public static final int DEFAULT_MAX_AGE = -1;\n\n    /**\n     * {@code -1} indicating that no version property should be set on the cookie.\n     */\n    public static final int DEFAULT_VERSION = -1;\n\n    //These constants are protected on purpose so that the test case can use them\n    protected static final String NAME_VALUE_DELIMITER = \"=\";\n    protected static final String ATTRIBUTE_DELIMITER = \"; \";\n    protected static final long DAY_MILLIS = 86400000; //1 day = 86,400,000 milliseconds\n    protected static final String GMT_TIME_ZONE_ID = \"GMT\";\n    protected static final String COOKIE_DATE_FORMAT_STRING = \"EEE, dd-MMM-yyyy HH:mm:ss z\";\n\n    protected static final String COOKIE_HEADER_NAME = \"Set-Cookie\";\n    protected static final String PATH_ATTRIBUTE_NAME = \"Path\";\n    protected static final String EXPIRES_ATTRIBUTE_NAME = \"Expires\";\n    protected static final String DOMAIN_ATTRIBUTE_NAME = \"Domain\";\n    protected static final String VERSION_ATTRIBUTE_NAME = \"Version\";\n    protected static final String COMMENT_ATTRIBUTE_NAME = \"Comment\";\n    protected static final String SECURE_ATTRIBUTE_NAME = \"Secure\";\n    protected static final String HTTP_ONLY_ATTRIBUTE_NAME = \"HttpOnly\";\n\n    private static final transient Logger log = LoggerFactory.getLogger(SimpleCookie.class);\n\n    private String name;\n    private String value;\n    private String comment;\n    private String domain;\n    private String path;\n    private int maxAge;\n    private int version;\n    private boolean secure;\n    private boolean httpOnly;\n\n    public SimpleCookie() {\n        this.maxAge = DEFAULT_MAX_AGE;\n        this.version = DEFAULT_VERSION;\n        this.httpOnly = true; //most of the cookies ever used by Shiro should be as secure as possible.\n    }\n\n    public SimpleCookie(String name) {\n        this();\n        this.name = name;\n    }\n\n    public SimpleCookie(Cookie cookie) {\n        this.name = cookie.getName();\n        this.value = cookie.getValue();\n        this.comment = cookie.getComment();\n        this.domain = cookie.getDomain();\n        this.path = cookie.getPath();\n        this.maxAge = Math.max(DEFAULT_MAX_AGE, cookie.getMaxAge());\n        this.version = Math.max(DEFAULT_VERSION, cookie.getVersion());\n        this.secure = cookie.isSecure();\n        this.httpOnly = cookie.isHttpOnly();\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        if (!StringUtils.hasText(name)) {\n            throw new IllegalArgumentException(\"Name cannot be null/empty.\");\n        }\n        this.name = name;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    public String getComment() {\n        return comment;\n    }\n\n    public void setComment(String comment) {\n        this.comment = comment;\n    }\n\n    public String getDomain() {\n        return domain;\n    }\n\n    public void setDomain(String domain) {\n        this.domain = domain;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    public int getMaxAge() {\n        return maxAge;\n    }\n\n    public void setMaxAge(int maxAge) {\n        this.maxAge = Math.max(DEFAULT_MAX_AGE, maxAge);\n    }\n\n    public int getVersion() {\n        return version;\n    }\n\n    public void setVersion(int version) {\n        this.version = Math.max(DEFAULT_VERSION, version);\n    }\n\n    public boolean isSecure() {\n        return secure;\n    }\n\n    public void setSecure(boolean secure) {\n        this.secure = secure;\n    }\n\n    public boolean isHttpOnly() {\n        return httpOnly;\n    }\n\n    public void setHttpOnly(boolean httpOnly) {\n        this.httpOnly = httpOnly;\n    }\n\n    /**\n     * Returns the Cookie's calculated path setting.  If the {@link javax.servlet.http.Cookie#getPath() path} is {@code null}, then the\n     * {@code request}'s {@link javax.servlet.http.HttpServletRequest#getContextPath() context path}\n     * will be returned. If getContextPath() is the empty string or null then the ROOT_PATH constant is returned.\n     *\n     * @param request the incoming HttpServletRequest\n     * @return the path to be used as the path when the cookie is created or removed\n     */\n    private String calculatePath(HttpServletRequest request) {\n        String path = StringUtils.clean(getPath());\n        if (!StringUtils.hasText(path)) {\n            path = StringUtils.clean(request.getContextPath());\n        }\n\n        //fix for http://issues.apache.org/jira/browse/SHIRO-9:\n        if (path == null) {\n            path = ROOT_PATH;\n        }\n        log.trace(\"calculated path: {}\", path);\n        return path;\n    }\n\n    public void saveTo(HttpServletRequest request, HttpServletResponse response) {\n\n        String name = getName();\n        String value = getValue();\n        String comment = getComment();\n        String domain = getDomain();\n        String path = calculatePath(request);\n        int maxAge = getMaxAge();\n        int version = getVersion();\n        boolean secure = isSecure();\n        boolean httpOnly = isHttpOnly();\n\n        addCookieHeader(response, name, value, comment, domain, path, maxAge, version, secure, httpOnly);\n    }\n\n    private void addCookieHeader(HttpServletResponse response, String name, String value, String comment,\n                                 String domain, String path, int maxAge, int version,\n                                 boolean secure, boolean httpOnly) {\n\n        String headerValue = buildHeaderValue(name, value, comment, domain, path, maxAge, version, secure, httpOnly);\n        response.addHeader(COOKIE_HEADER_NAME, headerValue);\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Added HttpServletResponse Cookie [{}]\", headerValue);\n        }\n    }\n\n    /*\n     * This implementation followed the grammar defined here for convenience:\n     * <a href=\"http://github.com/abarth/http-state/blob/master/notes/2009-11-07-Yui-Naruse.txt\">Cookie grammar<\/a>.\n     *\n     * @return the 'Set-Cookie' header value for this cookie instance.\n     */\n\n    protected String buildHeaderValue(String name, String value, String comment,\n                                      String domain, String path, int maxAge, int version,\n                                      boolean secure, boolean httpOnly) {\n\n        if (!StringUtils.hasText(name)) {\n            throw new IllegalStateException(\"Cookie name cannot be null/empty.\");\n        }\n\n        StringBuffer sb = new StringBuffer(name).append(NAME_VALUE_DELIMITER);\n\n        if (StringUtils.hasText(value)) {\n            sb.append(value);\n        }\n\n        appendComment(sb, comment);\n        appendDomain(sb, domain);\n        appendPath(sb, path);\n        appendExpires(sb, maxAge);\n        appendVersion(sb, version);\n        appendSecure(sb, secure);\n        appendHttpOnly(sb, httpOnly);\n\n        return sb.toString();\n\n    }\n\n    private void appendComment(StringBuffer sb, String comment) {\n        if (StringUtils.hasText(comment)) {\n            sb.append(ATTRIBUTE_DELIMITER);\n            sb.append(COMMENT_ATTRIBUTE_NAME).append(NAME_VALUE_DELIMITER).append(comment);\n        }\n    }\n\n    private void appendDomain(StringBuffer sb, String domain) {\n        if (StringUtils.hasText(domain)) {\n            sb.append(ATTRIBUTE_DELIMITER);\n            sb.append(DOMAIN_ATTRIBUTE_NAME).append(NAME_VALUE_DELIMITER).append(domain);\n        }\n    }\n\n    private void appendPath(StringBuffer sb, String path) {\n        if (StringUtils.hasText(path)) {\n            sb.append(ATTRIBUTE_DELIMITER);\n            sb.append(PATH_ATTRIBUTE_NAME).append(NAME_VALUE_DELIMITER).append(path);\n        }\n    }\n\n    private void appendExpires(StringBuffer sb, int maxAge) {\n        if (maxAge > DEFAULT_MAX_AGE) {\n            sb.append(ATTRIBUTE_DELIMITER);\n            Date expires;\n            if (maxAge == 0) {\n                //delete the cookie by specifying a time in the past (1 day ago):\n                expires = new Date(System.currentTimeMillis() - DAY_MILLIS);\n            } else {\n                //Value is in seconds.  So take 'now' and add that many seconds, and that's our expiration date:\n                Calendar cal = Calendar.getInstance();\n                cal.add(Calendar.SECOND, maxAge);\n                expires = cal.getTime();\n            }\n            String formatted = toCookieDate(expires);\n            sb.append(EXPIRES_ATTRIBUTE_NAME).append(NAME_VALUE_DELIMITER).append(formatted);\n        }\n    }\n\n    private void appendVersion(StringBuffer sb, int version) {\n        if (version > DEFAULT_VERSION) {\n            sb.append(ATTRIBUTE_DELIMITER);\n            sb.append(VERSION_ATTRIBUTE_NAME).append(NAME_VALUE_DELIMITER).append(version);\n        }\n    }\n\n    private void appendSecure(StringBuffer sb, boolean secure) {\n        if (secure) {\n            sb.append(ATTRIBUTE_DELIMITER);\n            sb.append(SECURE_ATTRIBUTE_NAME); //No value for this attribute\n        }\n    }\n\n    private void appendHttpOnly(StringBuffer sb, boolean httpOnly) {\n        if (httpOnly) {\n            sb.append(ATTRIBUTE_DELIMITER);\n            sb.append(HTTP_ONLY_ATTRIBUTE_NAME); //No value for this attribute\n        }\n    }\n\n    /**\n     * Formats a date into a cookie date compatible string (Netscape's specification).\n     *\n     * @param date the date to format\n     * @return an HTTP 1.0/1.1 Cookie compatible date string (GMT-based).\n     */\n    private static String toCookieDate(Date date) {\n        TimeZone tz = TimeZone.getTimeZone(GMT_TIME_ZONE_ID);\n        DateFormat fmt = new SimpleDateFormat(COOKIE_DATE_FORMAT_STRING);\n        fmt.setTimeZone(tz);\n        return fmt.format(date);\n    }\n\n    public void removeFrom(HttpServletRequest request, HttpServletResponse response) {\n        String name = getName();\n        String value = \"deleteMe\";\n        String comment = null; //don't need to add extra size to the response - comments are irrelevant for deletions\n        String domain = getDomain();\n        String path = calculatePath(request);\n        int maxAge = 0; //always zero for deletion\n        int version = getVersion();\n        boolean secure = isSecure();\n        boolean httpOnly = false; //no need to add the extra text, plus the value 'deleteMe' is not sensitive at all\n\n        addCookieHeader(response, name, value, comment, domain, path, maxAge, version, secure, httpOnly);\n\n        log.trace(\"Removed '{}' cookie by setting maxAge=0\", name);\n    }\n\n    public String readValue(HttpServletRequest request, HttpServletResponse ignored) {\n        String name = getName();\n        String value = null;\n        javax.servlet.http.Cookie cookie = getCookie(request, name);\n        if (cookie != null) {\n            value = cookie.getValue();\n            log.debug(\"Found string value [{}] from Cookie [{}]\", value, name);\n        } else {\n            log.trace(\"No value found in request Cookies under cookie name [{}]\", name);\n        }\n\n        return value;\n    }\n\n    /**\n     * Returns the cookie with the given name from the request or {@code null} if no cookie\n     * with that name could be found.\n     *\n     * @param request    the current executing http request.\n     * @param cookieName the name of the cookie to find and return.\n     * @return the cookie with the given name from the request or {@code null} if no cookie\n     *         with that name could be found.\n     */\n    private static javax.servlet.http.Cookie getCookie(HttpServletRequest request, String cookieName) {\n        javax.servlet.http.Cookie cookies[] = request.getCookies();\n        if (cookies != null) {\n            for (javax.servlet.http.Cookie cookie : cookies) {\n                if (cookie.getName().equals(cookieName)) {\n                    return cookie;\n                }\n            }\n        }\n        return null;\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.servlet;\n\nimport org.apache.shiro.util.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.TimeZone;\n\n/**\n * TODO - Class JavaDoc\n *\n * @author Les Hazlewood\n * @since 1.0\n */\npublic class SimpleCookie implements Cookie {\n\n    /**\n     * {@code -1}, indicating the cookie should expire when the browser closes.\n     */\n    public static final int DEFAULT_MAX_AGE = -1;\n\n    /**\n     * {@code -1} indicating that no version property should be set on the cookie.\n     */\n    public static final int DEFAULT_VERSION = -1;\n\n    //These constants are protected on purpose so that the test case can use them\n    protected static final String NAME_VALUE_DELIMITER = \"=\";\n    protected static final String ATTRIBUTE_DELIMITER = \"; \";\n    protected static final long DAY_MILLIS = 86400000; //1 day = 86,400,000 milliseconds\n    protected static final String GMT_TIME_ZONE_ID = \"GMT\";\n    protected static final String COOKIE_DATE_FORMAT_STRING = \"EEE, dd-MMM-yyyy HH:mm:ss z\";\n\n    protected static final String COOKIE_HEADER_NAME = \"Set-Cookie\";\n    protected static final String PATH_ATTRIBUTE_NAME = \"Path\";\n    protected static final String EXPIRES_ATTRIBUTE_NAME = \"Expires\";\n    protected static final String DOMAIN_ATTRIBUTE_NAME = \"Domain\";\n    protected static final String VERSION_ATTRIBUTE_NAME = \"Version\";\n    protected static final String COMMENT_ATTRIBUTE_NAME = \"Comment\";\n    protected static final String SECURE_ATTRIBUTE_NAME = \"Secure\";\n    protected static final String HTTP_ONLY_ATTRIBUTE_NAME = \"HttpOnly\";\n\n    private static final transient Logger log = LoggerFactory.getLogger(SimpleCookie.class);\n\n    private String name;\n    private String value;\n    private String comment;\n    private String domain;\n    private String path;\n    private int maxAge;\n    private int version;\n    private boolean secure;\n    private boolean httpOnly;\n\n    public SimpleCookie() {\n        this.maxAge = DEFAULT_MAX_AGE;\n        this.version = DEFAULT_VERSION;\n        this.httpOnly = true; //most of the cookies ever used by Shiro should be as secure as possible.\n    }\n\n    public SimpleCookie(String name) {\n        this();\n        this.name = name;\n    }\n\n    public SimpleCookie(Cookie cookie) {\n        this.name = cookie.getName();\n        this.value = cookie.getValue();\n        this.comment = cookie.getComment();\n        this.domain = cookie.getDomain();\n        this.path = cookie.getPath();\n        this.maxAge = Math.max(DEFAULT_MAX_AGE, cookie.getMaxAge());\n        this.version = Math.max(DEFAULT_VERSION, cookie.getVersion());\n        this.secure = cookie.isSecure();\n        this.httpOnly = cookie.isHttpOnly();\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        if (!StringUtils.hasText(name)) {\n            throw new IllegalArgumentException(\"Name cannot be null/empty.\");\n        }\n        this.name = name;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    public String getComment() {\n        return comment;\n    }\n\n    public void setComment(String comment) {\n        this.comment = comment;\n    }\n\n    public String getDomain() {\n        return domain;\n    }\n\n    public void setDomain(String domain) {\n        this.domain = domain;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    public int getMaxAge() {\n        return maxAge;\n    }\n\n    public void setMaxAge(int maxAge) {\n        this.maxAge = Math.max(DEFAULT_MAX_AGE, maxAge);\n    }\n\n    public int getVersion() {\n        return version;\n    }\n\n    public void setVersion(int version) {\n        this.version = Math.max(DEFAULT_VERSION, version);\n    }\n\n    public boolean isSecure() {\n        return secure;\n    }\n\n    public void setSecure(boolean secure) {\n        this.secure = secure;\n    }\n\n    public boolean isHttpOnly() {\n        return httpOnly;\n    }\n\n    public void setHttpOnly(boolean httpOnly) {\n        this.httpOnly = httpOnly;\n    }\n\n    /**\n     * Returns the Cookie's calculated path setting.  If the {@link javax.servlet.http.Cookie#getPath() path} is {@code null}, then the\n     * {@code request}'s {@link javax.servlet.http.HttpServletRequest#getContextPath() context path}\n     * will be returned. If getContextPath() is the empty string or null then the ROOT_PATH constant is returned.\n     *\n     * @param request the incoming HttpServletRequest\n     * @return the path to be used as the path when the cookie is created or removed\n     */\n    private String calculatePath(HttpServletRequest request) {\n        String path = StringUtils.clean(getPath());\n        if (!StringUtils.hasText(path)) {\n            path = StringUtils.clean(request.getContextPath());\n        }\n\n        //fix for http://issues.apache.org/jira/browse/SHIRO-9:\n        if (path == null) {\n            path = ROOT_PATH;\n        }\n        log.trace(\"calculated path: {}\", path);\n        return path;\n    }\n\n    public void saveTo(HttpServletRequest request, HttpServletResponse response) {\n\n        /*String name = getName();\n        String value = getValue();\n        String comment = getComment();\n        String domain = getDomain();\n        int version = getVersion();\n        int maxAge = getMaxAge();\n        String path = calculatePath(request);\n\n        javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(name, value);\n        cookie.setMaxAge(maxAge);\n        cookie.setPath(path);\n\n        if (comment != null) {\n            cookie.setComment(comment);\n        }\n        if (domain != null) {\n            cookie.setDomain(domain);\n        }\n        if (version > DEFAULT_VERSION) {\n            cookie.setVersion(version);\n        }\n\n        if (isSecure()) {\n            cookie.setSecure(true);\n        }\n\n        response.addCookie(cookie);*/\n\n        String headerValue = buildHeaderValue(request);\n        response.addHeader(COOKIE_HEADER_NAME, headerValue);\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Added HttpServletResponse Cookie [{}]\", headerValue);\n        }\n    }\n\n    /**\n     * This implementation followed the grammar defined here for convenience:\n     * <a href=\"http://github.com/abarth/http-state/blob/master/notes/2009-11-07-Yui-Naruse.txt\">Cookie grammar<\/a>.\n     *\n     * @param request the incoming request\n     * @return the 'Set-Cookie' header value for this cookie instance.\n     */\n    private String buildHeaderValue(HttpServletRequest request) {\n        String name = getName();\n        if (!StringUtils.hasText(name)) {\n            throw new IllegalStateException(\"Cookie name cannot be null/empty.\");\n        }\n\n        StringBuffer sb = new StringBuffer(name).append(NAME_VALUE_DELIMITER);\n\n        String value = getValue();\n        if (StringUtils.hasText(value)) {\n            sb.append(value);\n        }\n\n        appendPath(sb, request);\n        appendDomain(sb);\n        appendExpires(sb);\n        appendVersion(sb);\n        appendComment(sb);\n        appendSecure(sb);\n        appendHttpOnly(sb);\n\n        return sb.toString();\n    }\n\n    private void appendPath(StringBuffer sb, HttpServletRequest request) {\n        String path = calculatePath(request);\n        if (StringUtils.hasText(path)) {\n            sb.append(ATTRIBUTE_DELIMITER);\n            sb.append(PATH_ATTRIBUTE_NAME).append(NAME_VALUE_DELIMITER).append(path);\n        }\n    }\n\n    private void appendDomain(StringBuffer sb) {\n        String domain = getDomain();\n        if (StringUtils.hasText(domain)) {\n            sb.append(ATTRIBUTE_DELIMITER);\n            sb.append(DOMAIN_ATTRIBUTE_NAME).append(NAME_VALUE_DELIMITER).append(domain);\n        }\n    }\n\n    private void appendExpires(StringBuffer sb) {\n        int maxAge = getMaxAge();\n        if (maxAge > DEFAULT_MAX_AGE) {\n            sb.append(ATTRIBUTE_DELIMITER);\n            Date expires;\n            if (maxAge == 0) {\n                //delete the cookie by specifying a time in the past (1 day ago):\n                expires = new Date(System.currentTimeMillis() - DAY_MILLIS);\n            } else {\n                //Value is in seconds.  So take 'now' and add that many seconds, and that's our expiration date:\n                Calendar cal = Calendar.getInstance();\n                cal.add(Calendar.SECOND, maxAge);\n                expires = cal.getTime();\n            }\n            String formatted = toCookieDate(expires);\n            sb.append(EXPIRES_ATTRIBUTE_NAME).append(NAME_VALUE_DELIMITER).append(formatted);\n        }\n    }\n\n    private void appendVersion(StringBuffer sb) {\n        int version = getVersion();\n        if (version > DEFAULT_VERSION) {\n            sb.append(ATTRIBUTE_DELIMITER);\n            sb.append(VERSION_ATTRIBUTE_NAME).append(NAME_VALUE_DELIMITER).append(version);\n        }\n    }\n\n    private void appendComment(StringBuffer sb) {\n        String comment = getComment();\n        if (StringUtils.hasText(comment)) {\n            sb.append(ATTRIBUTE_DELIMITER);\n            sb.append(COMMENT_ATTRIBUTE_NAME).append(NAME_VALUE_DELIMITER).append(comment);\n        }\n    }\n\n    private void appendSecure(StringBuffer sb) {\n        if (isSecure()) {\n            sb.append(ATTRIBUTE_DELIMITER);\n            sb.append(SECURE_ATTRIBUTE_NAME); //No value for this attribute\n        }\n    }\n\n    private void appendHttpOnly(StringBuffer sb) {\n        if (isHttpOnly()) {\n            sb.append(ATTRIBUTE_DELIMITER);\n            sb.append(HTTP_ONLY_ATTRIBUTE_NAME); //No value for this attribute\n        }\n    }\n\n    /**\n     * Formats a date into a cookie date compatible string (Netscape's specification).\n     *\n     * @param date the date to format\n     * @return an HTTP 1.0/1.1 Cookie compatible date string (GMT-based).\n     */\n    private static String toCookieDate(Date date) {\n        TimeZone tz = TimeZone.getTimeZone(GMT_TIME_ZONE_ID);\n        DateFormat fmt = new SimpleDateFormat(COOKIE_DATE_FORMAT_STRING);\n        fmt.setTimeZone(tz);\n        return fmt.format(date);\n    }\n\n    /**\n     * Returns the cookie with the given name from the request or {@code null} if no cookie\n     * with that name could be found.\n     *\n     * @param request    the current executing http request.\n     * @param cookieName the name of the cookie to find and return.\n     * @return the cookie with the given name from the request or {@code null} if no cookie\n     *         with that name could be found.\n     */\n    private static javax.servlet.http.Cookie getCookie(HttpServletRequest request, String cookieName) {\n        javax.servlet.http.Cookie cookies[] = request.getCookies();\n        if (cookies != null) {\n            for (javax.servlet.http.Cookie cookie : cookies) {\n                if (cookie.getName().equals(cookieName)) {\n                    return cookie;\n                }\n            }\n        }\n        return null;\n    }\n\n    public void removeFrom(HttpServletRequest request, HttpServletResponse response) {\n        javax.servlet.http.Cookie cookie = getCookie(request, getName());\n\n        if (cookie != null) {\n            cookie.setMaxAge(0);\n            cookie.setValue(\"deleteMe\");\n\n            // JSEC-94: Must set the path on the outgoing cookie (some browsers don't retain it from the\n            // retrieved cookie?)\n            // Testing shows none of these browsers will remove cookie if setPath() is not invoked:\n            // FF3, Chrome, IE7, Safari windows\n            String path = calculatePath(request);\n            cookie.setPath(path);\n\n            String domain = getDomain();\n            if (StringUtils.hasText(domain)) {\n                cookie.setDomain(domain);\n            }\n\n            response.addCookie(cookie);\n            log.trace(\"Removed cookie[\" + getName() + \"] with path [\" + path + \"] from HttpServletResponse.\");\n        }\n    }\n\n    public String readValue(HttpServletRequest request, HttpServletResponse ignored) {\n        String name = getName();\n        String value = null;\n        javax.servlet.http.Cookie cookie = getCookie(request, name);\n        if (cookie != null) {\n            value = cookie.getValue();\n            log.debug(\"Found string value [{}] from Cookie [{}]\", value, name);\n        } else {\n            log.trace(\"No value found in request Cookies under cookie name [{}]\", name);\n        }\n\n        return value;\n    }\n}\n","lineNo":333}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.servlet;\n\nimport junit.framework.TestCase;\nimport org.easymock.IArgumentMatcher;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport static org.easymock.EasyMock.*;\n\n/**\n * TODO - Class JavaDoc\n *\n * @author Les Hazlewood\n * @since Apr 22, 2010 9:40:47 PM\n */\npublic class SimpleCookieTest extends TestCase {\n\n    private SimpleCookie cookie;\n\n    private HttpServletRequest mockRequest;\n    private HttpServletResponse mockResponse;\n\n    @Before\n    public void setUp() throws Exception {\n        this.mockRequest = createMock(HttpServletRequest.class);\n        this.mockResponse = createMock(HttpServletResponse.class);\n        this.cookie = new SimpleCookie(\"test\");\n    }\n\n    @Test\n    //Verifies fix for JSEC-94\n    public void testRemoveValue() throws Exception {\n\n        //verify that the cookie header starts with what we want\n        //we can't verify the exact date format string that is appended, so we resort to just\n        //simple 'startsWith' matching, which is good enough:\n        String name = \"test\";\n        String value = \"deleteMe\";\n        String path = \"/somepath\";\n\n        String headerValue = this.cookie.buildHeaderValue(name, value, null, null, path,\n                0, SimpleCookie.DEFAULT_VERSION, false, false);\n\n        String expectedStart = new StringBuffer()\n                .append(name).append(SimpleCookie.NAME_VALUE_DELIMITER).append(value)\n                .append(SimpleCookie.ATTRIBUTE_DELIMITER)\n                .append(SimpleCookie.PATH_ATTRIBUTE_NAME).append(SimpleCookie.NAME_VALUE_DELIMITER).append(path)\n                .toString();\n\n        assertTrue(headerValue.startsWith(expectedStart));\n\n        expect(mockRequest.getContextPath()).andReturn(path).times(1);\n        mockResponse.addHeader(eq(SimpleCookie.COOKIE_HEADER_NAME), isA(String.class)); //can't calculate the date format in the test\n        replay(mockRequest);\n        replay(mockResponse);\n\n        this.cookie.removeFrom(mockRequest, mockResponse);\n\n        verify(mockRequest);\n        verify(mockResponse);\n    }\n\n    private void testRootContextPath(String contextPath) {\n        this.cookie.setValue(\"blah\");\n\n        String expectedCookieValue = new StringBuffer()\n                .append(\"test\").append(SimpleCookie.NAME_VALUE_DELIMITER).append(\"blah\")\n                .append(SimpleCookie.ATTRIBUTE_DELIMITER)\n                .append(SimpleCookie.PATH_ATTRIBUTE_NAME).append(SimpleCookie.NAME_VALUE_DELIMITER).append(Cookie.ROOT_PATH)\n                .append(SimpleCookie.ATTRIBUTE_DELIMITER)\n                .append(SimpleCookie.HTTP_ONLY_ATTRIBUTE_NAME)\n                .toString();\n\n        expect(mockRequest.getContextPath()).andReturn(contextPath);\n        mockResponse.addHeader(SimpleCookie.COOKIE_HEADER_NAME, expectedCookieValue);\n\n        replay(mockRequest);\n        replay(mockResponse);\n\n        this.cookie.saveTo(mockRequest, mockResponse);\n\n        verify(mockRequest);\n        verify(mockResponse);\n    }\n\n    @Test\n    /** Verifies fix for <a href=\"http://issues.apache.org/jira/browse/JSEC-34\">JSEC-34<\/a> (1 of 2)*/\n    public void testEmptyContextPath() throws Exception {\n        testRootContextPath(\"\");\n    }\n\n\n    @Test\n    /** Verifies fix for <a href=\"http://issues.apache.org/jira/browse/JSEC-34\">JSEC-34<\/a> (2 of 2)*/\n    public void testNullContextPath() throws Exception {\n        testRootContextPath(null);\n    }\n\n    private static <T extends javax.servlet.http.Cookie> T eqCookie(final T in) {\n        reportMatcher(new IArgumentMatcher() {\n            public boolean matches(Object o) {\n                javax.servlet.http.Cookie c = (javax.servlet.http.Cookie) o;\n                return c.getName().equals(in.getName()) &&\n                        c.getValue().equals(in.getValue()) &&\n                        c.getPath().equals(in.getPath()) &&\n                        c.getMaxAge() == in.getMaxAge() &&\n                        c.getSecure() == in.getSecure() &&\n                        c.getValue().equals(in.getValue());\n            }\n\n            public void appendTo(StringBuffer sb) {\n                sb.append(\"eqCookie(\");\n                sb.append(in.getClass().getName());\n                sb.append(\")\");\n\n            }\n        });\n        return null;\n    }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.servlet;\n\nimport junit.framework.TestCase;\nimport org.easymock.IArgumentMatcher;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport static org.easymock.EasyMock.*;\n\n/**\n * TODO - Class JavaDoc\n *\n * @author Les Hazlewood\n * @since Apr 22, 2010 9:40:47 PM\n */\npublic class SimpleCookieTest extends TestCase {\n\n    private SimpleCookie cookie;\n\n    private HttpServletRequest mockRequest;\n    private HttpServletResponse mockResponse;\n\n    @Before\n    public void setUp() throws Exception {\n        this.mockRequest = createMock(HttpServletRequest.class);\n        this.mockResponse = createMock(HttpServletResponse.class);\n        this.cookie = new SimpleCookie(\"test\");\n    }\n\n    @Test\n    //Verifies fix for JSEC-94\n    public void testRemoveValue() throws Exception {\n\n        javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(\"test\", \"blah\");\n        cookie.setMaxAge(2351234); //doesn't matter what the time is\n        javax.servlet.http.Cookie[] cookies = new javax.servlet.http.Cookie[]{cookie};\n\n        expect(mockRequest.getCookies()).andReturn(cookies);\n        //no path set on the cookie, so we expect to retrieve it from the context path\n        expect(mockRequest.getContextPath()).andReturn(\"/somepath\").times(1);\n        mockResponse.addCookie(cookie);\n        replay(mockRequest);\n        replay(mockResponse);\n\n        this.cookie.removeFrom(mockRequest, mockResponse);\n\n        verify(mockRequest);\n        verify(mockResponse);\n\n        assertTrue(cookie.getMaxAge() == 0);\n        assertTrue(cookie.getPath().equals(\"/somepath\"));\n    }\n\n    private void testRootContextPath(String contextPath) {\n        this.cookie.setValue(\"blah\");\n\n        String expectedCookieValue = new StringBuffer()\n                .append(\"test\").append(SimpleCookie.NAME_VALUE_DELIMITER).append(\"blah\")\n                .append(SimpleCookie.ATTRIBUTE_DELIMITER)\n                .append(SimpleCookie.PATH_ATTRIBUTE_NAME).append(SimpleCookie.NAME_VALUE_DELIMITER).append(Cookie.ROOT_PATH)\n                .append(SimpleCookie.ATTRIBUTE_DELIMITER)\n                .append(SimpleCookie.HTTP_ONLY_ATTRIBUTE_NAME)\n                .toString();\n\n        expect(mockRequest.getContextPath()).andReturn(contextPath);\n        mockResponse.addHeader(SimpleCookie.COOKIE_HEADER_NAME, expectedCookieValue);\n\n        replay(mockRequest);\n        replay(mockResponse);\n\n        this.cookie.saveTo(mockRequest, mockResponse);\n\n        verify(mockRequest);\n        verify(mockResponse);\n    }\n\n    @Test\n    /** Verifies fix for <a href=\"http://issues.apache.org/jira/browse/JSEC-34\">JSEC-34<\/a> (1 of 2)*/\n    public void testEmptyContextPath() throws Exception {\n        testRootContextPath(\"\");\n    }\n\n\n    @Test\n    /** Verifies fix for <a href=\"http://issues.apache.org/jira/browse/JSEC-34\">JSEC-34<\/a> (2 of 2)*/\n    public void testNullContextPath() throws Exception {\n        testRootContextPath(null);\n    }\n\n    private static <T extends javax.servlet.http.Cookie> T eqCookie(final T in) {\n        reportMatcher(new IArgumentMatcher() {\n            public boolean matches(Object o) {\n                javax.servlet.http.Cookie c = (javax.servlet.http.Cookie) o;\n                return c.getName().equals(in.getName()) &&\n                        c.getValue().equals(in.getValue()) &&\n                        c.getPath().equals(in.getPath()) &&\n                        c.getMaxAge() == in.getMaxAge() &&\n                        c.getSecure() == in.getSecure() &&\n                        c.getValue().equals(in.getValue());\n            }\n\n            public void appendTo(StringBuffer sb) {\n                sb.append(\"eqCookie(\");\n                sb.append(in.getClass().getName());\n                sb.append(\")\");\n\n            }\n        });\n        return null;\n    }\n\n    @Test\n    //Verifies fix for JSEC-64\n    public void testRemoveValueWithNullContext() throws Exception {\n\n        javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(\"test\", \"blah\");\n        cookie.setMaxAge(2351234); //doesn't matter what the time is\n        javax.servlet.http.Cookie[] cookies = new javax.servlet.http.Cookie[]{cookie};\n\n        expect(mockRequest.getCookies()).andReturn(cookies);\n        //no path set on the cookie, so we expect to retrieve it from the context path\n        expect(mockRequest.getContextPath()).andReturn(null).times(1);\n        mockResponse.addCookie(cookie);\n        replay(mockRequest);\n        replay(mockResponse);\n\n        this.cookie.removeFrom(mockRequest, mockResponse);\n\n        verify(mockRequest);\n        verify(mockResponse);\n\n        assertTrue(cookie.getMaxAge() == 0);\n        assertTrue(cookie.getPath().equals(\"/\"));\n    }\n\n}\n","lineNo":60}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.session;\n\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.session.mgt.DefaultSessionManager;\nimport org.apache.shiro.web.WebUtils;\nimport org.apache.shiro.web.servlet.Cookie;\nimport org.apache.shiro.web.servlet.ShiroHttpServletRequest;\nimport org.apache.shiro.web.servlet.ShiroHttpSession;\nimport org.apache.shiro.web.servlet.SimpleCookie;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.Serializable;\n\n\n/**\n * Web-application capable {@link org.apache.shiro.session.mgt.SessionManager SessionManager} implementation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class DefaultWebSessionManager extends DefaultSessionManager implements WebSessionManager {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(DefaultWebSessionManager.class);\n\n    private Cookie sessionIdCookie;\n    private boolean sessionIdCookieEnabled;\n\n    public DefaultWebSessionManager() {\n        this.sessionIdCookie = new SimpleCookie(ShiroHttpSession.DEFAULT_SESSION_ID_NAME);\n        this.sessionIdCookie.setPath(Cookie.ROOT_PATH);\n        this.sessionIdCookieEnabled = true;\n    }\n\n    public Cookie getSessionIdCookie() {\n        return sessionIdCookie;\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public void setSessionIdCookie(Cookie sessionIdCookie) {\n        this.sessionIdCookie = sessionIdCookie;\n    }\n\n    public boolean isSessionIdCookieEnabled() {\n        return sessionIdCookieEnabled;\n    }\n\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public void setSessionIdCookieEnabled(boolean sessionIdCookieEnabled) {\n        this.sessionIdCookieEnabled = sessionIdCookieEnabled;\n    }\n\n    private void storeSessionId(Serializable currentId, ServletRequest request, ServletResponse response) {\n        if (currentId == null) {\n            String msg = \"sessionId cannot be null when persisting for subsequent requests.\";\n            throw new IllegalArgumentException(msg);\n        }\n        if (!(request instanceof HttpServletRequest)) {\n            log.debug(\"Current request is not an HttpServletRequest - cannot save session id cookie. Returning.\");\n            return;\n        }\n        Cookie template = getSessionIdCookie();\n        Cookie cookie = new SimpleCookie(template);\n        String idString = currentId.toString();\n        cookie.setValue(idString);\n        cookie.saveTo(WebUtils.toHttp(request), WebUtils.toHttp(response));\n        log.trace(\"Set session ID cookie for session with id {}\", idString);\n    }\n\n    private void markSessionIdValid(ServletRequest request) {\n        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);\n    }\n\n    private void markSessionIdInvalid(ServletRequest request) {\n        request.removeAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID);\n    }\n\n    private void removeSessionIdCookie(ServletRequest request, ServletResponse response) {\n        getSessionIdCookie().removeFrom(WebUtils.toHttp(request), WebUtils.toHttp(response));\n    }\n\n    private String getSessionIdCookieValue(ServletRequest request, ServletResponse response) {\n        if (!isSessionIdCookieEnabled()) {\n            log.debug(\"Session ID cookie is disabled - session id will not be acquired from a request cookie.\");\n            return null;\n        }\n        if (!(request instanceof HttpServletRequest)) {\n            log.debug(\"Current request is not an HttpServletRequest - cannot get session ID cookie.  Returning null.\");\n            return null;\n        }\n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n        return getSessionIdCookie().readValue(httpRequest, WebUtils.toHttp(response));\n    }\n\n    private Serializable getReferencedSessionId(ServletRequest request, ServletResponse response) {\n\n        String id = getSessionIdCookieValue(request, response);\n        if (id != null) {\n            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                    ShiroHttpServletRequest.COOKIE_SESSION_ID_SOURCE);\n        } else {\n            //not in a cookie, or cookie is disabled - try the request params as a fallback (i.e. URL rewriting):\n            id = request.getParameter(ShiroHttpSession.DEFAULT_SESSION_ID_NAME);\n            if (id == null) {\n                //try lowercase:\n                id = request.getParameter(ShiroHttpSession.DEFAULT_SESSION_ID_NAME.toLowerCase());\n            }\n            if (id != null) {\n                request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                        ShiroHttpServletRequest.URL_SESSION_ID_SOURCE);\n            }\n        }\n        if (id != null) {\n            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id);\n            //automatically mark it valid here.  If it is invalid, the\n            //onUnknownSession method below will be invoked and we'll remove the attribute at that time.\n            markSessionIdValid(request);\n        }\n        return id;\n    }\n\n    /**\n     * Stores the Session's ID, usually as a Cookie, to associate with future requests.\n     *\n     * @param session the session that was just {@link #createSession created}.\n     */\n    @Override\n    protected void onStart(Session session) {\n        ServletRequest request = WebUtils.getServletRequest();\n        ServletResponse response = WebUtils.getServletResponse();\n        if (request == null || response == null) {\n            log.debug(\"Request or response object is not bound to the thread.  Assuming this session start \" +\n                    \"activity is due to a non web request (possible in a web application that also services \" +\n                    \"non web clients.\");\n            return;\n        }\n        if (isSessionIdCookieEnabled()) {\n            Serializable sessionId = session.getId();\n            storeSessionId(sessionId, request, response);\n        } else {\n            log.debug(\"Session ID cookie is disabled.  No cookie has been set for new session with id {}\",\n                    session.getId());\n        }\n\n        request.removeAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE);\n        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_IS_NEW, Boolean.TRUE);\n    }\n\n    public Serializable getSessionId(ServletRequest request, ServletResponse response) {\n        return getReferencedSessionId(request, response);\n    }\n\n    @Override\n    public void onUnknownSession(Serializable sessionId) {\n        ServletRequest request = WebUtils.getServletRequest();\n        if (request != null) {\n            markSessionIdInvalid(request);\n        }\n        removeSessionIdCookie();\n    }\n\n    protected void onStop(Session session) {\n        super.onStop(session);\n        removeSessionIdCookie();\n    }\n\n    protected void onExpiration(Session session) {\n        super.onExpiration(session);\n        removeSessionIdCookie();\n    }\n\n    private void removeSessionIdCookie() {\n        ServletRequest request = WebUtils.getServletRequest();\n        ServletResponse response = WebUtils.getServletResponse();\n        if (request == null || response == null) {\n            log.debug(\"No request or response bound to the thread.  Session ID cookie cannot be removed.  This could \" +\n                    \"occur in a web application that also services non web clients (e.g. RMI remoting).\");\n            return;\n        }\n        removeSessionIdCookie(request, response);\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.session;\n\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.session.mgt.DefaultSessionManager;\nimport org.apache.shiro.web.WebUtils;\nimport org.apache.shiro.web.servlet.Cookie;\nimport org.apache.shiro.web.servlet.ShiroHttpServletRequest;\nimport org.apache.shiro.web.servlet.ShiroHttpSession;\nimport org.apache.shiro.web.servlet.SimpleCookie;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\n\n\n/**\n * Web-application capable {@link org.apache.shiro.session.mgt.SessionManager SessionManager} implementation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class DefaultWebSessionManager extends DefaultSessionManager implements WebSessionManager {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(DefaultWebSessionManager.class);\n\n    private Cookie sessionIdCookie;\n\n    public DefaultWebSessionManager() {\n        this.sessionIdCookie = new SimpleCookie(ShiroHttpSession.DEFAULT_SESSION_ID_NAME);\n        this.sessionIdCookie.setPath(Cookie.ROOT_PATH);\n    }\n\n    public Cookie getSessionIdCookie() {\n        return sessionIdCookie;\n    }\n\n    public void setSessionIdCookie(Cookie sessionIdCookie) {\n        this.sessionIdCookie = sessionIdCookie;\n    }\n\n    protected void storeSessionId(Serializable currentId, ServletRequest request, ServletResponse response) {\n        if (currentId == null) {\n            String msg = \"sessionId cannot be null when persisting for subsequent requests.\";\n            throw new IllegalArgumentException(msg);\n        }\n        Cookie template = getSessionIdCookie();\n        Cookie cookie = new SimpleCookie(template);\n        cookie.setValue(currentId.toString());\n        cookie.saveTo(WebUtils.toHttp(request), WebUtils.toHttp(response));\n    }\n\n    private void markSessionIdValid(Serializable sessionId, ServletRequest request) {\n        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);\n    }\n\n    private void markSessionIdInvalid(ServletRequest request) {\n        request.removeAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID);\n    }\n\n    private void removeSessionIdCookie(ServletRequest request, ServletResponse response) {\n        getSessionIdCookie().removeFrom(WebUtils.toHttp(request), WebUtils.toHttp(response));\n    }\n\n    protected Serializable getReferencedSessionId(ServletRequest request, ServletResponse response) {\n        String id = getSessionIdCookie().readValue(WebUtils.toHttp(request), WebUtils.toHttp(response));\n        if (id != null) {\n            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                    ShiroHttpServletRequest.COOKIE_SESSION_ID_SOURCE);\n        } else {\n            id = request.getParameter(ShiroHttpSession.DEFAULT_SESSION_ID_NAME);\n            if (id != null) {\n                request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                        ShiroHttpServletRequest.URL_SESSION_ID_SOURCE);\n            }\n        }\n        if (id != null) {\n            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id);\n            //automatically mark it valid here.  If it is invalid, the\n            //onUnknownSession method below will be invoked and we'll remove the attribute at that time.\n            markSessionIdValid(id, request);\n        }\n        return id;\n    }\n\n    /**\n     * Stores the Session's ID, usually as a Cookie, to associate with future requests.\n     *\n     * @param session the session that was just {@link #createSession created}.\n     */\n    @Override\n    protected void onStart(Session session) {\n        ServletRequest request = WebUtils.getRequiredServletRequest();\n        ServletResponse response = WebUtils.getRequiredServletResponse();\n        Serializable sessionId = session.getId();\n        storeSessionId(sessionId, request, response);\n        request.removeAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE);\n        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_IS_NEW, Boolean.TRUE);\n    }\n\n    public Serializable getSessionId(ServletRequest request, ServletResponse response) {\n        return getReferencedSessionId(request, response);\n    }\n\n    @Override\n    public void onUnknownSession(Serializable sessionId) {\n        markSessionIdInvalid(WebUtils.getRequiredServletRequest());\n        removeSessionIdCookie();\n    }\n\n    protected void onStop(Session session) {\n        super.onStop(session);\n        removeSessionIdCookie();\n    }\n\n    protected void onExpiration(Session session) {\n        super.onExpiration(session);\n        removeSessionIdCookie();\n    }\n\n    protected void removeSessionIdCookie() {\n        ServletRequest request = WebUtils.getRequiredServletRequest();\n        ServletResponse response = WebUtils.getRequiredServletResponse();\n        removeSessionIdCookie(request, response);\n    }\n}\n","lineNo":87}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.realm;\n\nimport org.apache.shiro.authc.credential.CredentialsMatcher;\nimport org.apache.shiro.authz.*;\nimport org.apache.shiro.authz.permission.*;\nimport org.apache.shiro.cache.Cache;\nimport org.apache.shiro.cache.CacheManager;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.util.Initializable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n\n/**\n * An {@code AuthorizingRealm} extends the {@code AuthenticatingRealm}'s capabilities by adding Authorization\n * (access control) support.\n * <p/>\n * This implementation will perform all role and permission checks automatically (and subclasses do not have to\n * write this logic) as long as the\n * {@link #getAuthorizationInfo(org.apache.shiro.subject.PrincipalCollection)} method returns an\n * {@link AuthorizationInfo}.  Please see that method's JavaDoc for an in-depth explanation.\n * <p/>\n * If you find that you do not want to utilize the {@link AuthorizationInfo AuthorizationInfo} construct,\n * you are of course free to subclass the {@link AuthenticatingRealm AuthenticatingRealm} directly instead and\n * implement the remaining Realm interface methods directly.  You might do this if you want have better control\n * over how the Role and Permission checks occur for your specific data source.  However, using AuthorizationInfo\n * (and its default implementation {@link org.apache.shiro.authz.SimpleAuthorizationInfo SimpleAuthorizationInfo}) is sufficient in the large\n * majority of Realm cases.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @see org.apache.shiro.authz.SimpleAuthorizationInfo\n * @since 0.2\n */\npublic abstract class AuthorizingRealm extends AuthenticatingRealm\n        implements Initializable, PermissionResolverAware, RolePermissionResolverAware {\n\n    //TODO - complete JavaDoc\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    private static final Logger log = LoggerFactory.getLogger(AuthorizingRealm.class);\n\n    /**\n     * The default suffix appended to the realm name for caching AuthorizationInfo instances.\n     */\n    private static final String DEFAULT_AUTHORIZATION_CACHE_SUFFIX = \"-authorization\";\n\n    private static final AtomicInteger INSTANCE_COUNT = new AtomicInteger();\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The cache used by this realm to store AuthorizationInfo instances associated with individual Subject principals.\n     */\n    private boolean authorizationCachingEnabled;\n    private Cache authorizationCache;\n    private String authorizationCacheName;\n\n    private PermissionResolver permissionResolver;\n\n    private RolePermissionResolver permissionRoleResolver;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    public AuthorizingRealm() {\n        this.authorizationCachingEnabled = true;\n        this.permissionResolver = new WildcardPermissionResolver();\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager) {\n        super(cacheManager);\n    }\n\n    public AuthorizingRealm(CredentialsMatcher matcher) {\n        super(matcher);\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager, CredentialsMatcher matcher) {\n        super(cacheManager, matcher);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    public void setAuthorizationCache(Cache authorizationCache) {\n        this.authorizationCache = authorizationCache;\n        if (this.authorizationCache != null) {\n            afterAuthorizationCacheSet();\n        }\n    }\n\n    public Cache getAuthorizationCache() {\n        return this.authorizationCache;\n    }\n\n    public String getAuthorizationCacheName() {\n        return authorizationCacheName;\n    }\n\n    public void setAuthorizationCacheName(String authorizationCacheName) {\n        this.authorizationCacheName = authorizationCacheName;\n    }\n\n    /**\n     * Returns {@code true} if authorization caching should be utilized if a {@link CacheManager} has been\n     * {@link #setCacheManager(org.apache.shiro.cache.CacheManager) configured}, {@code false} otherwise.\n     * <p/>\n     * The default value is {@code true}.\n     *\n     * @return {@code true} if authorization caching should be utilized, {@code false} otherwise.\n     */\n    public boolean isAuthorizationCachingEnabled() {\n        return isCachingEnabled() && authorizationCachingEnabled;\n    }\n\n    /**\n     * Sets whether or not authorization caching should be utilized if a {@link CacheManager} has been\n     * {@link #setCacheManager(org.apache.shiro.cache.CacheManager) configured}, {@code false} otherwise.\n     * <p/>\n     * The default value is {@code true}.\n     *\n     * @param authorizationCachingEnabled the value to set\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public void setAuthorizationCachingEnabled(boolean authorizationCachingEnabled) {\n        this.authorizationCachingEnabled = authorizationCachingEnabled;\n        if (authorizationCachingEnabled) {\n            setCachingEnabled(true);\n        }\n    }\n\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n\n    public RolePermissionResolver getRolePermissionResolver() {\n        return permissionRoleResolver;\n    }\n\n    public void setRolePermissionResolver(RolePermissionResolver permissionRoleResolver) {\n        this.permissionRoleResolver = permissionRoleResolver;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    /**\n     * Initializes this realm and potentially enables a cache, depending on configuration.\n     * <p/>\n     * When this method is called, the following logic is executed:\n     * <ol>\n     * <li>If the {@link #setAuthorizationCache cache} property has been set, it will be\n     * used to cache the AuthorizationInfo objects returned from {@link #getAuthorizationInfo}\n     * method invocations.\n     * All future calls to {@code getAuthorizationInfo} will attempt to use this cache first\n     * to alleviate any potentially unnecessary calls to an underlying data store.<\/li>\n     * <li>If the {@link #setAuthorizationCache cache} property has <b>not<\/b> been set,\n     * the {@link #setCacheManager cacheManager} property will be checked.\n     * If a {@code cacheManager} has been set, it will be used to create an authorization\n     * {@code cache}, and this newly created cache which will be used as specified in #1.<\/li>\n     * <li>If neither the {@link #setAuthorizationCache (org.apache.shiro.cache.Cache) cache}\n     * or {@link #setCacheManager(org.apache.shiro.cache.CacheManager) cacheManager}\n     * properties are set, caching will be disabled and authorization look-ups will be delegated to\n     * subclass implementations for each authorization check.<\/li>\n     * <\/ol>\n     */\n    public final void init() {\n        if (isAuthorizationCachingEnabled()) {\n            initAuthorizationCache();\n        }\n        onInit();\n    }\n\n    protected void onInit() {\n    }\n\n    protected void afterCacheManagerSet() {\n        this.authorizationCache = null;\n        if (isAuthorizationCachingEnabled()) {\n            initAuthorizationCache();\n        }\n    }\n\n    protected void afterAuthorizationCacheSet() {\n    }\n\n    protected final String generateAuthorizationCacheName() {\n        //Simple default in case they didn't provide one:\n        return getClass().getName() + \"-\" + INSTANCE_COUNT.getAndIncrement() + DEFAULT_AUTHORIZATION_CACHE_SUFFIX;\n    }\n\n    public void initAuthorizationCache() {\n        if (!isAuthorizationCachingEnabled()) {\n            log.debug(\"Authorization caching is disabled.  Returning immediately.\");\n            return;\n        }\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Initializing authorization cache.\");\n        }\n\n        Cache cache = getAuthorizationCache();\n\n        if (cache == null) {\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"No cache implementation set.  Checking cacheManager...\");\n            }\n\n            CacheManager cacheManager = getCacheManager();\n\n            if (cacheManager != null) {\n                String cacheName = getAuthorizationCacheName();\n                if (cacheName == null) {\n                    //Simple default in case they didn't provide one:\n                    cacheName = generateAuthorizationCacheName();\n                    setAuthorizationCacheName(cacheName);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"CacheManager [\" + cacheManager + \"] has been configured.  Building \" +\n                            \"authorization cache named [\" + cacheName + \"]\");\n                }\n                cache = cacheManager.getCache(cacheName);\n                setAuthorizationCache(cache);\n            } else {\n                if (log.isInfoEnabled()) {\n                    log.info(\"No cache or cacheManager properties have been set.  Authorization caching is \" +\n                            \"disabled.\");\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Returns an account's authorization-specific information for the specified {@code principals},\n     * or {@code null} if no account could be found.  The resulting {@code AuthorizationInfo} object is used\n     * by the other method implementations in this class to automatically perform access control checks for the\n     * corresponding {@code Subject}.\n     * <p/>\n     * This implementation obtains the actual {@code AuthorizationInfo} object from the subclass's\n     * implementation of\n     * {@link #doGetAuthorizationInfo(org.apache.shiro.subject.PrincipalCollection) doGetAuthorizationInfo}, and then\n     * caches it for efficient reuse if caching is enabled (see below).\n     * <p/>\n     * Invocations of this method should be thought of as completely orthogonal to acquiring\n     * {@link #getAuthenticationInfo(org.apache.shiro.authc.AuthenticationToken) authenticationInfo}, since either could\n     * occur in any order.\n     * <p/>\n     * For example, in &quot;Remember Me&quot; scenarios, the user identity is remembered (and\n     * assumed) for their current session and an authentication attempt during that session might never occur.\n     * But because their identity would be remembered, that is sufficient enough information to call this method to\n     * execute any necessary authorization checks.  For this reason, authentication and authorization should be\n     * loosely coupled and not depend on each other.\n     * <h3>Caching<\/h3>\n     * The {@code AuthorizationInfo} values returned from this method are cached for efficient reuse\n     * if caching is enabled.  Caching is enabled automatically when a {@code CacheManager} has been\n     * {@link #setCacheManager injected} and then the realm is {@link #init initialized}.  It can also be enabled by\n     * explicitly calling {@link #initAuthorizationCache() initAuthorizationCache()}.\n     * <p/>\n     * If caching is enabled, the authorization cache will be checked first and if found, will return the cached\n     * {@code AuthorizationInfo} immediately.  If caching is disabled, or there is a cache miss, the authorization\n     * info will be looked up from the underlying data store via the\n     * {@link #doGetAuthorizationInfo(org.apache.shiro.subject.PrincipalCollection)} method, which must be implemented\n     * by subclasses.\n     * <h4>Changed Data<\/h4>\n     * If caching is enabled and if any authorization data for an account is changed at\n     * runtime, such as adding or removing roles and/or permissions, the subclass implementation should clear the\n     * cached AuthorizationInfo for that account via the\n     * {@link #clearCachedAuthorizationInfo(org.apache.shiro.subject.PrincipalCollection) clearCachedAuthorizationInfo}\n     * method.  This ensures that the next call to {@code getAuthorizationInfo(PrincipalCollection)} will\n     * acquire the account's fresh authorization data, where it will then be cached for efficient reuse.  This\n     * ensures that stale authorization data will not be reused.\n     *\n     * @param principals the corresponding Subject's identifying principals with which to look up the Subject's\n     *                   {@code AuthorizationInfo}.\n     * @return the authorization information for the account associated with the specified {@code principals},\n     *         or {@code null} if no account could be found.\n     */\n    protected AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {\n\n        if (principals == null) {\n            return null;\n        }\n\n        AuthorizationInfo info = null;\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Retrieving AuthorizationInfo for principals [\" + principals + \"]\");\n        }\n\n        Cache cache = getAuthorizationCache();\n        if (cache != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to retrieve the AuthorizationInfo from cache.\");\n            }\n            Object key = getAuthorizationCacheKey(principals);\n            info = (AuthorizationInfo) cache.get(key);\n            if (log.isTraceEnabled()) {\n                if (info == null) {\n                    log.trace(\"No AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                } else {\n                    log.trace(\"AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                }\n            }\n        }\n\n\n        if (info == null) {\n            // Call template method if the info was not found in a cache\n            info = doGetAuthorizationInfo(principals);\n            // If the info is not null and the cache has been created, then cache the authorization info.\n            if (info != null && cache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching authorization info for principals: [\" + principals + \"].\");\n                }\n                Object key = getAuthorizationCacheKey(principals);\n                cache.put(key, info);\n            }\n        }\n\n        return info;\n    }\n\n    protected Object getAuthorizationCacheKey(PrincipalCollection principals) {\n        return principals;\n    }\n\n    /**\n     * Clears out the AuthorizationInfo cache entry for the specified account.\n     * <p/>\n     * This method is provided as a convenience to subclasses so they can invalidate a cache entry when they\n     * change an account's authorization data (add/remove roles or permissions) during runtime.  Because an account's\n     * AuthorizationInfo can be cached, there needs to be a way to invalidate the cache for only that account so that\n     * subsequent authorization operations don't used the (old) cached value if account data changes.\n     * <p/>\n     * After this method is called, the next authorization check for that same account will result in a call to\n     * {@link #getAuthorizationInfo(org.apache.shiro.subject.PrincipalCollection) getAuthorizationInfo}, and the\n     * resulting return value will be cached before being returned so it can be reused for later authorization checks.\n     *\n     * @param principals the principals of the account for which to clear the cached AuthorizationInfo.\n     */\n    protected void clearCachedAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return;\n        }\n\n        Cache cache = getAuthorizationCache();\n        //cache instance will be non-null if caching is enabled:\n        if (cache != null) {\n            Object key = getAuthorizationCacheKey(principals);\n            cache.remove(key);\n        }\n    }\n\n    /**\n     * Retrieves the AuthorizationInfo for the given principals from the underlying data store.  When returning\n     * an instance from this method, you might want to consider using an instance of\n     * {@link org.apache.shiro.authz.SimpleAuthorizationInfo SimpleAuthorizationInfo}, as it is suitable in most cases.\n     *\n     * @param principals the primary identifying principals of the AuthorizationInfo that should be retrieved.\n     * @return the AuthorizationInfo associated with this principals.\n     * @see org.apache.shiro.authz.SimpleAuthorizationInfo\n     */\n    protected abstract AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals);\n\n    @SuppressWarnings({\"unchecked\"})\n    private Collection<Permission> getPermissions(AuthorizationInfo info) {\n        Set<Permission> permissions = new HashSet<Permission>();\n\n        if (info != null) {\n            Collection<Permission> perms = info.getObjectPermissions();\n            if (!CollectionUtils.isEmpty(perms)) {\n                permissions.addAll(perms);\n            }\n            perms = resolvePermissions(info.getStringPermissions());\n            if (!CollectionUtils.isEmpty(perms)) {\n                permissions.addAll(perms);\n            }\n\n            perms = resolveRolePermissions(info.getRoles());\n            if (!CollectionUtils.isEmpty(perms)) {\n                permissions.addAll(perms);\n            }\n        }\n\n        if (permissions.isEmpty()) {\n            return Collections.EMPTY_SET;\n        } else {\n            return Collections.unmodifiableSet(permissions);\n        }\n    }\n\n    private Collection<Permission> resolvePermissions(Collection<String> stringPerms) {\n        Collection<Permission> perms = Collections.emptySet();\n        PermissionResolver resolver = getPermissionResolver();\n        if (resolver != null && !CollectionUtils.isEmpty(stringPerms)) {\n            perms = new LinkedHashSet<Permission>(stringPerms.size());\n            for (String strPermission : stringPerms) {\n                Permission permission = getPermissionResolver().resolvePermission(strPermission);\n                perms.add(permission);\n            }\n        }\n        return perms;\n    }\n\n    private Collection<Permission> resolveRolePermissions(Collection<String> roleNames) {\n        Collection<Permission> perms = Collections.emptySet();\n        RolePermissionResolver resolver = getRolePermissionResolver();\n        if (resolver != null && !CollectionUtils.isEmpty(roleNames)) {\n            perms = new LinkedHashSet<Permission>(roleNames.size());\n            for (String roleName : roleNames) {\n                Collection<Permission> resolved = resolver.resolvePermissionsInRole(roleName);\n                if (!CollectionUtils.isEmpty(resolved)) {\n                    perms.addAll(resolved);\n                }\n            }\n        }\n        return perms;\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        return isPermitted(principals, p);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean isPermitted(Permission permission, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permission);\n        }\n\n        Collection<Permission> perms = getPermissions(info);\n        if (perms != null && !perms.isEmpty()) {\n            for (Permission perm : perms) {\n                if (perm.implies(permission)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean[] isPermitted(PrincipalCollection subjectIdentifier, String... permissions) {\n        List<Permission> perms = new ArrayList<Permission>(permissions.length);\n        for (String permString : permissions) {\n            perms.add(getPermissionResolver().resolvePermission(permString));\n        }\n        return isPermitted(subjectIdentifier, perms);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] isPermitted(List<Permission> permissions, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permissions);\n        }\n\n        boolean[] result;\n        if (permissions != null && !permissions.isEmpty()) {\n            int size = permissions.size();\n            result = new boolean[size];\n            int i = 0;\n            for (Permission p : permissions) {\n                result[i++] = isPermitted(p, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection subjectIdentifier, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            Collection<Permission> perms = new ArrayList<Permission>(permissions.length);\n            for (String permString : permissions) {\n                perms.add(getPermissionResolver().resolvePermission(permString));\n            }\n            return isPermittedAll(subjectIdentifier, perms);\n        }\n        return false;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principal, Collection<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && isPermittedAll(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean isPermittedAll(Collection<Permission> permissions, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermittedAll(permissions);\n        }\n\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission p : permissions) {\n                if (!isPermitted(p, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkPermission(PrincipalCollection subjectIdentifier, String permission) throws AuthorizationException {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        checkPermission(subjectIdentifier, p);\n    }\n\n    public void checkPermission(PrincipalCollection principal, Permission permission) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermission(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermission(Permission permission, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermission(permission);\n        } else {\n            if (!isPermitted(permission, info)) {\n                String msg = \"User is not permitted [\" + permission + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection subjectIdentifier, String... permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (String permString : permissions) {\n                checkPermission(subjectIdentifier, permString);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection principal, Collection<Permission> permissions) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermissions(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermissions(Collection<Permission> permissions, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermissions(permissions);\n        } else {\n            if (permissions != null && !permissions.isEmpty()) {\n                for (Permission p : permissions) {\n                    checkPermission(p, info);\n                }\n            }\n        }\n    }\n\n    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return hasRole(roleIdentifier, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean hasRole(String roleIdentifier, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRole(roleIdentifier);\n        }\n        return info != null && info.getRoles() != null && info.getRoles().contains(roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principal, List<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        boolean[] result = new boolean[roleIdentifiers != null ? roleIdentifiers.size() : 0];\n        if (info != null) {\n            result = hasRoles(roleIdentifiers, info);\n        }\n        return result;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] hasRoles(List<String> roleIdentifiers, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRoles(roleIdentifiers);\n        }\n\n        boolean[] result;\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            int size = roleIdentifiers.size();\n            result = new boolean[size];\n            int i = 0;\n            for (String roleName : roleIdentifiers) {\n                result[i++] = hasRole(roleName, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principal, Collection<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && hasAllRoles(roleIdentifiers, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean hasAllRoles(Collection<String> roleIdentifiers, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasAllRoles(roleIdentifiers);\n        }\n\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            for (String roleName : roleIdentifiers) {\n                if (!hasRole(roleName, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkRole(PrincipalCollection principal, String role) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRole(role, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRole(String role, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRole(role);\n        } else {\n            if (!hasRole(role, info)) {\n                String msg = \"User does not have role [\" + role + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkRoles(PrincipalCollection principal, Collection<String> roles) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRoles(roles, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRoles(Collection<String> roles, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRoles(roles);\n        } else {\n            if (roles != null && !roles.isEmpty()) {\n                for (String roleName : roles) {\n                    checkRole(roleName, info);\n                }\n            }\n        }\n    }\n\n    /**\n     * If authorization caching is enabled, this will remove the AuthorizationInfo from the cache.\n     * Subclasses are free to override for additional behavior, but be sure to call {@code super.onLogout}\n     * to ensure cache cleanup.\n     *\n     * @param principals the application-specific Subject/user identifier.\n     */\n    public void onLogout(PrincipalCollection principals) {\n        clearCachedAuthorizationInfo(principals);\n    }\n\n    /**\n     * A utility method for subclasses that returns the first available principal of interest to this particular realm.\n     * The heuristic used to acquire the principal is as follows:\n     * <ul>\n     * <li>Attempt to get <em>this particular Realm's<\/em> 'primary' principal in the {@code PrincipalCollection} via a\n     * <code>principals.{@link PrincipalCollection#fromRealm(String) fromRealm}({@link #getName() getName()})<\/code>\n     * call.<\/li>\n     * <li>If the previous call does not result in any principals, attempt to get the overall 'primary' principal\n     * from the PrincipalCollection via {@link org.apache.shiro.subject.PrincipalCollection#getPrimaryPrincipal()}.<\/li>\n     * <li>If there are no principals from that call (or the PrincipalCollection argument was null to begin with),\n     * return {@code null}<\/li>\n     * <\/ul>\n     *\n     * @param principals the PrincipalCollection holding all principals (from all realms) associated with a single Subject.\n     * @return the 'primary' principal attributed to this particular realm, or the fallback 'master' principal if it\n     *         exists, or if not {@code null}.\n     * @since 1.0\n     */\n    protected Object getAvailablePrincipal(PrincipalCollection principals) {\n        if (principals == null || principals.isEmpty()) {\n            return null;\n        }\n        Object primary;\n        Collection thisPrincipals = principals.fromRealm(getName());\n        if (thisPrincipals != null && !thisPrincipals.isEmpty()) {\n            primary = thisPrincipals.iterator().next();\n        } else {\n            //no principals attributed to this particular realm.  Fall back to the 'master' primary:\n            primary = principals.getPrimaryPrincipal();\n        }\n        return primary;\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.realm;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.shiro.authc.credential.CredentialsMatcher;\nimport org.apache.shiro.authz.AuthorizationException;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.AuthorizingAccount;\nimport org.apache.shiro.authz.Permission;\nimport org.apache.shiro.authz.UnauthorizedException;\nimport org.apache.shiro.authz.permission.PermissionResolver;\nimport org.apache.shiro.authz.permission.PermissionResolverAware;\nimport org.apache.shiro.authz.permission.RolePermissionResolver;\nimport org.apache.shiro.authz.permission.RolePermissionResolverAware;\nimport org.apache.shiro.authz.permission.WildcardPermissionResolver;\nimport org.apache.shiro.cache.Cache;\nimport org.apache.shiro.cache.CacheManager;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.util.Initializable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\n/**\n * An {@code AuthorizingRealm} extends the {@code AuthenticatingRealm}'s capabilities by adding Authorization\n * (access control) support.\n * <p/>\n * This implementation will perform all role and permission checks automatically (and subclasses do not have to\n * write this logic) as long as the\n * {@link #getAuthorizationInfo(org.apache.shiro.subject.PrincipalCollection)} method returns an\n * {@link AuthorizationInfo}.  Please see that method's JavaDoc for an in-depth explanation.\n * <p/>\n * If you find that you do not want to utilize the {@link AuthorizationInfo AuthorizationInfo} construct,\n * you are of course free to subclass the {@link AuthenticatingRealm AuthenticatingRealm} directly instead and\n * implement the remaining Realm interface methods directly.  You might do this if you want have better control\n * over how the Role and Permission checks occur for your specific data source.  However, using AuthorizationInfo\n * (and its default implementation {@link org.apache.shiro.authz.SimpleAuthorizationInfo SimpleAuthorizationInfo}) is sufficient in the large\n * majority of Realm cases.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @see org.apache.shiro.authz.SimpleAuthorizationInfo\n * @since 0.2\n */\npublic abstract class AuthorizingRealm extends AuthenticatingRealm implements Initializable, PermissionResolverAware, RolePermissionResolverAware {\n\n    //TODO - complete JavaDoc\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    private static final Logger log = LoggerFactory.getLogger(AuthorizingRealm.class);\n\n    /**\n     * The default suffix appended to the realm name for caching AuthorizationInfo instances.\n     */\n    private static final String DEFAULT_AUTHORIZATION_CACHE_SUFFIX = \"-authorization\";\n\n    private static final AtomicInteger INSTANCE_COUNT = new AtomicInteger();\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The cache used by this realm to store AuthorizationInfo instances associated with individual Subject principals.\n     */\n    private boolean authorizationCachingEnabled = true;\n    private Cache authorizationCache = null;\n    private String authorizationCacheName = null;\n\n    private PermissionResolver permissionResolver = new WildcardPermissionResolver();\n    \n    private RolePermissionResolver permissionRoleResolver = null;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AuthorizingRealm() {\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager) {\n        super(cacheManager);\n    }\n\n    public AuthorizingRealm(CredentialsMatcher matcher) {\n        super(matcher);\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager, CredentialsMatcher matcher) {\n        super(cacheManager, matcher);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAuthorizationCache(Cache authorizationCache) {\n        this.authorizationCache = authorizationCache;\n        if (this.authorizationCache != null) {\n            afterAuthorizationCacheSet();\n        }\n    }\n\n    public Cache getAuthorizationCache() {\n        return this.authorizationCache;\n    }\n\n    public String getAuthorizationCacheName() {\n        return authorizationCacheName;\n    }\n\n    public void setAuthorizationCacheName(String authorizationCacheName) {\n        this.authorizationCacheName = authorizationCacheName;\n    }\n\n    /**\n     * Returns {@code true} if authorization caching should be utilized if a {@link CacheManager} has been\n     * {@link #setCacheManager(org.apache.shiro.cache.CacheManager) configured}, {@code false} otherwise.\n     * <p/>\n     * The default value is {@code true}.\n     *\n     * @return {@code true} if authorization caching should be utilized, {@code false} otherwise.\n     */\n    public boolean isAuthorizationCachingEnabled() {\n        return isCachingEnabled() && authorizationCachingEnabled;\n    }\n\n    /**\n     * Sets whether or not authorization caching should be utilized if a {@link CacheManager} has been\n     * {@link #setCacheManager(org.apache.shiro.cache.CacheManager) configured}, {@code false} otherwise.\n     * <p/>\n     * The default value is {@code true}.\n     *\n     * @param authorizationCachingEnabled the value to set\n     */\n    public void setAuthorizationCachingEnabled(boolean authorizationCachingEnabled) {\n        this.authorizationCachingEnabled = authorizationCachingEnabled;\n        if (authorizationCachingEnabled) {\n            setCachingEnabled(true);\n        }\n    }\n\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n    \n    public RolePermissionResolver getRolePermissionResolver() {\n        return permissionRoleResolver;\n    }\n\n    public void setRolePermissionResolver(RolePermissionResolver permissionRoleResolver) {\n        this.permissionRoleResolver = permissionRoleResolver;\n    }\n    \n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Initializes this realm and potentially enables a cache, depending on configuration.\n     * <p/>\n     * When this method is called, the following logic is executed:\n     * <ol>\n     * <li>If the {@link #setAuthorizationCache cache} property has been set, it will be\n     * used to cache the AuthorizationInfo objects returned from {@link #getAuthorizationInfo}\n     * method invocations.\n     * All future calls to {@code getAuthorizationInfo} will attempt to use this cache first\n     * to alleviate any potentially unnecessary calls to an underlying data store.<\/li>\n     * <li>If the {@link #setAuthorizationCache cache} property has <b>not<\/b> been set,\n     * the {@link #setCacheManager cacheManager} property will be checked.\n     * If a {@code cacheManager} has been set, it will be used to create an authorization\n     * {@code cache}, and this newly created cache which will be used as specified in #1.<\/li>\n     * <li>If neither the {@link #setAuthorizationCache (org.apache.shiro.cache.Cache) cache}\n     * or {@link #setCacheManager(org.apache.shiro.cache.CacheManager) cacheManager}\n     * properties are set, caching will be disabled and authorization look-ups will be delegated to\n     * subclass implementations for each authorization check.<\/li>\n     * <\/ol>\n     */\n    public final void init() {\n        if (isAuthorizationCachingEnabled()) {\n            initAuthorizationCache();\n        }\n        onInit();\n    }\n\n    protected void onInit() {\n    }\n\n    protected void afterCacheManagerSet() {\n        this.authorizationCache = null;\n        if (isAuthorizationCachingEnabled()) {\n            initAuthorizationCache();\n        }\n    }\n\n    protected void afterAuthorizationCacheSet() {\n    }\n\n    protected final String generateAuthorizationCacheName() {\n        //Simple default in case they didn't provide one:\n        return getClass().getName() + \"-\" + INSTANCE_COUNT.getAndIncrement() + DEFAULT_AUTHORIZATION_CACHE_SUFFIX;\n    }\n\n    public void initAuthorizationCache() {\n        if (!isAuthorizationCachingEnabled()) {\n            log.debug(\"Authorization caching is disabled.  Returning immediately.\");\n            return;\n        }\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Initializing authorization cache.\");\n        }\n\n        Cache cache = getAuthorizationCache();\n\n        if (cache == null) {\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"No cache implementation set.  Checking cacheManager...\");\n            }\n\n            CacheManager cacheManager = getCacheManager();\n\n            if (cacheManager != null) {\n                String cacheName = getAuthorizationCacheName();\n                if (cacheName == null) {\n                    //Simple default in case they didn't provide one:\n                    cacheName = generateAuthorizationCacheName();\n                    setAuthorizationCacheName(cacheName);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"CacheManager [\" + cacheManager + \"] has been configured.  Building \" +\n                            \"authorization cache named [\" + cacheName + \"]\");\n                }\n                cache = cacheManager.getCache(cacheName);\n                setAuthorizationCache(cache);\n            } else {\n                if (log.isInfoEnabled()) {\n                    log.info(\"No cache or cacheManager properties have been set.  Authorization caching is \" +\n                            \"disabled.\");\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Returns an account's authorization-specific information for the specified {@code principals},\n     * or {@code null} if no account could be found.  The resulting {@code AuthorizationInfo} object is used\n     * by the other method implementations in this class to automatically perform access control checks for the\n     * corresponding {@code Subject}.\n     * <p/>\n     * This implementation obtains the actual {@code AuthorizationInfo} object from the subclass's\n     * implementation of\n     * {@link #doGetAuthorizationInfo(org.apache.shiro.subject.PrincipalCollection) doGetAuthorizationInfo}, and then\n     * caches it for efficient reuse if caching is enabled (see below).\n     * <p/>\n     * Invocations of this method should be thought of as completely orthogonal to acquiring\n     * {@link #getAuthenticationInfo(org.apache.shiro.authc.AuthenticationToken) authenticationInfo}, since either could\n     * occur in any order.\n     * <p/>\n     * For example, in &quot;Remember Me&quot; scenarios, the user identity is remembered (and\n     * assumed) for their current session and an authentication attempt during that session might never occur.\n     * But because their identity would be remembered, that is sufficient enough information to call this method to\n     * execute any necessary authorization checks.  For this reason, authentication and authorization should be\n     * loosely coupled and not depend on each other.\n     * <h3>Caching<\/h3>\n     * The {@code AuthorizationInfo} values returned from this method are cached for efficient reuse\n     * if caching is enabled.  Caching is enabled automatically when a {@code CacheManager} has been\n     * {@link #setCacheManager injected} and then the realm is {@link #init initialized}.  It can also be enabled by\n     * explicitly calling {@link #initAuthorizationCache() initAuthorizationCache()}.\n     * <p/>\n     * If caching is enabled, the authorization cache will be checked first and if found, will return the cached\n     * {@code AuthorizationInfo} immediately.  If caching is disabled, or there is a cache miss, the authorization\n     * info will be looked up from the underlying data store via the\n     * {@link #doGetAuthorizationInfo(org.apache.shiro.subject.PrincipalCollection)} method, which must be implemented\n     * by subclasses.\n     * <h4>Changed Data<\/h4>\n     * If caching is enabled and if any authorization data for an account is changed at\n     * runtime, such as adding or removing roles and/or permissions, the subclass implementation should clear the\n     * cached AuthorizationInfo for that account via the\n     * {@link #clearCachedAuthorizationInfo(org.apache.shiro.subject.PrincipalCollection) clearCachedAuthorizationInfo}\n     * method.  This ensures that the next call to {@code getAuthorizationInfo(PrincipalCollection)} will\n     * acquire the account's fresh authorization data, where it will then be cached for efficient reuse.  This\n     * ensures that stale authorization data will not be reused.\n     *\n     * @param principals the corresponding Subject's identifying principals with which to look up the Subject's\n     *                   {@code AuthorizationInfo}.\n     * @return the authorization information for the account associated with the specified {@code principals},\n     *         or {@code null} if no account could be found.\n     */\n    protected AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {\n\n        if (principals == null) {\n            return null;\n        }\n\n        AuthorizationInfo info = null;\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Retrieving AuthorizationInfo for principals [\" + principals + \"]\");\n        }\n\n        Cache cache = getAuthorizationCache();\n        if (cache != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to retrieve the AuthorizationInfo from cache.\");\n            }\n            Object key = getAuthorizationCacheKey(principals);\n            info = (AuthorizationInfo) cache.get(key);\n            if (log.isTraceEnabled()) {\n                if (info == null) {\n                    log.trace(\"No AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                } else {\n                    log.trace(\"AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                }\n            }\n        }\n\n\n        if (info == null) {\n            // Call template method if the info was not found in a cache\n            info = doGetAuthorizationInfo(principals);\n            // If the info is not null and the cache has been created, then cache the authorization info.\n            if (info != null && cache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching authorization info for principals: [\" + principals + \"].\");\n                }\n                Object key = getAuthorizationCacheKey(principals);\n                cache.put(key, info);\n            }\n        }\n\n        return info;\n    }\n\n    protected Object getAuthorizationCacheKey(PrincipalCollection principals) {\n        return principals;\n    }\n\n    /**\n     * Clears out the AuthorizationInfo cache entry for the specified account.\n     * <p/>\n     * This method is provided as a convenience to subclasses so they can invalidate a cache entry when they\n     * change an account's authorization data (add/remove roles or permissions) during runtime.  Because an account's\n     * AuthorizationInfo can be cached, there needs to be a way to invalidate the cache for only that account so that\n     * subsequent authorization operations don't used the (old) cached value if account data changes.\n     * <p/>\n     * After this method is called, the next authorization check for that same account will result in a call to\n     * {@link #getAuthorizationInfo(org.apache.shiro.subject.PrincipalCollection) getAuthorizationInfo}, and the\n     * resulting return value will be cached before being returned so it can be reused for later authorization checks.\n     *\n     * @param principals the principals of the account for which to clear the cached AuthorizationInfo.\n     */\n    protected void clearCachedAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return;\n        }\n\n        Cache cache = getAuthorizationCache();\n        //cache instance will be non-null if caching is enabled:\n        if (cache != null) {\n            Object key = getAuthorizationCacheKey(principals);\n            cache.remove(key);\n        }\n    }\n\n    /**\n     * Retrieves the AuthorizationInfo for the given principals from the underlying data store.  When returning\n     * an instance from this method, you might want to consider using an instance of\n     * {@link org.apache.shiro.authz.SimpleAuthorizationInfo SimpleAuthorizationInfo}, as it is suitable in most cases.\n     *\n     * @param principals the primary identifying principals of the AuthorizationInfo that should be retrieved.\n     * @return the AuthorizationInfo associated with this principals.\n     * @see org.apache.shiro.authz.SimpleAuthorizationInfo\n     */\n    protected abstract AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals);\n\n    @SuppressWarnings({\"unchecked\"})\n    private Collection<Permission> getPermissions(AuthorizationInfo info) {\n        Set<Permission> permissions = new HashSet<Permission>();\n\n        if (info != null) {\n            if (info.getObjectPermissions() != null) {\n                permissions.addAll(info.getObjectPermissions());\n            }\n\n            if (info.getStringPermissions() != null) {\n                for (String strPermission : info.getStringPermissions()) {\n                    Permission permission = getPermissionResolver().resolvePermission(strPermission);\n                    permissions.add(permission);\n                }\n            }\n            if(info.getRoles() != null &&  getRolePermissionResolver() != null ) {\n                for (String role : info.getRoles()) {\n                    Collection<Permission> rolesPermissions = getRolePermissionResolver().resolvePermissionsInRole( role );\n                    permissions.addAll( rolesPermissions );\n                }\n            }\n        }\n\n        if (permissions.isEmpty()) {\n            return Collections.EMPTY_SET;\n        } else {\n            return Collections.unmodifiableSet(permissions);\n        }\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        return isPermitted(principals, p);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean isPermitted(Permission permission, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permission);\n        }\n\n        Collection<Permission> perms = getPermissions(info);\n        if (perms != null && !perms.isEmpty()) {\n            for (Permission perm : perms) {\n                if (perm.implies(permission)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean[] isPermitted(PrincipalCollection subjectIdentifier, String... permissions) {\n        List<Permission> perms = new ArrayList<Permission>(permissions.length);\n        for (String permString : permissions) {\n            perms.add(getPermissionResolver().resolvePermission(permString));\n        }\n        return isPermitted(subjectIdentifier, perms);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] isPermitted(List<Permission> permissions, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permissions);\n        }\n\n        boolean[] result;\n        if (permissions != null && !permissions.isEmpty()) {\n            int size = permissions.size();\n            result = new boolean[size];\n            int i = 0;\n            for (Permission p : permissions) {\n                result[i++] = isPermitted(p, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection subjectIdentifier, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            Collection<Permission> perms = new ArrayList<Permission>(permissions.length);\n            for (String permString : permissions) {\n                perms.add(getPermissionResolver().resolvePermission(permString));\n            }\n            return isPermittedAll(subjectIdentifier, perms);\n        }\n        return false;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principal, Collection<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && isPermittedAll(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean isPermittedAll(Collection<Permission> permissions, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermittedAll(permissions);\n        }\n\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission p : permissions) {\n                if (!isPermitted(p, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkPermission(PrincipalCollection subjectIdentifier, String permission) throws AuthorizationException {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        checkPermission(subjectIdentifier, p);\n    }\n\n    public void checkPermission(PrincipalCollection principal, Permission permission) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermission(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermission(Permission permission, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermission(permission);\n        } else {\n            if (!isPermitted(permission, info)) {\n                String msg = \"User is not permitted [\" + permission + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection subjectIdentifier, String... permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (String permString : permissions) {\n                checkPermission(subjectIdentifier, permString);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection principal, Collection<Permission> permissions) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermissions(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermissions(Collection<Permission> permissions, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermissions(permissions);\n        } else {\n            if (permissions != null && !permissions.isEmpty()) {\n                for (Permission p : permissions) {\n                    checkPermission(p, info);\n                }\n            }\n        }\n    }\n\n    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return hasRole(roleIdentifier, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean hasRole(String roleIdentifier, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRole(roleIdentifier);\n        }\n        return info != null && info.getRoles() != null && info.getRoles().contains(roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principal, List<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        boolean[] result = new boolean[roleIdentifiers != null ? roleIdentifiers.size() : 0];\n        if (info != null) {\n            result = hasRoles(roleIdentifiers, info);\n        }\n        return result;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] hasRoles(List<String> roleIdentifiers, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRoles(roleIdentifiers);\n        }\n\n        boolean[] result;\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            int size = roleIdentifiers.size();\n            result = new boolean[size];\n            int i = 0;\n            for (String roleName : roleIdentifiers) {\n                result[i++] = hasRole(roleName, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principal, Collection<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && hasAllRoles(roleIdentifiers, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean hasAllRoles(Collection<String> roleIdentifiers, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasAllRoles(roleIdentifiers);\n        }\n\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            for (String roleName : roleIdentifiers) {\n                if (!hasRole(roleName, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkRole(PrincipalCollection principal, String role) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRole(role, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRole(String role, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRole(role);\n        } else {\n            if (!hasRole(role, info)) {\n                String msg = \"User does not have role [\" + role + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkRoles(PrincipalCollection principal, Collection<String> roles) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRoles(roles, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRoles(Collection<String> roles, AuthorizationInfo info) {\n        //TODO Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRoles(roles);\n        } else {\n            if (roles != null && !roles.isEmpty()) {\n                for (String roleName : roles) {\n                    checkRole(roleName, info);\n                }\n            }\n        }\n    }\n\n    /**\n     * If authorization caching is enabled, this will remove the AuthorizationInfo from the cache.\n     * Subclasses are free to override for additional behavior, but be sure to call {@code super.onLogout}\n     * to ensure cache cleanup.\n     *\n     * @param principals the application-specific Subject/user identifier.\n     */\n    public void onLogout(PrincipalCollection principals) {\n        clearCachedAuthorizationInfo(principals);\n    }\n\n    /**\n     * A utility method for subclasses that returns the first available principal of interest to this particular realm.\n     * The heuristic used to acquire the principal is as follows:\n     * <ul>\n     * <li>Attempt to get <em>this particular Realm's<\/em> 'primary' principal in the {@code PrincipalCollection} via a\n     * <code>principals.{@link PrincipalCollection#fromRealm(String) fromRealm}({@link #getName() getName()})<\/code>\n     * call.<\/li>\n     * <li>If the previous call does not result in any principals, attempt to get the overall 'primary' principal\n     * from the PrincipalCollection via {@link org.apache.shiro.subject.PrincipalCollection#getPrimaryPrincipal()}.<\/li>\n     * <li>If there are no principals from that call (or the PrincipalCollection argument was null to begin with),\n     * return {@code null}<\/li>\n     * <\/ul>\n     *\n     * @param principals the PrincipalCollection holding all principals (from all realms) associated with a single Subject.\n     * @return the 'primary' principal attributed to this particular realm, or the fallback 'master' principal if it\n     *         exists, or if not {@code null}.\n     * @since 1.0\n     */\n    protected Object getAvailablePrincipal(PrincipalCollection principals) {\n        if (principals == null || principals.isEmpty()) {\n            return null;\n        }\n        Object primary;\n        Collection thisPrincipals = principals.fromRealm(getName());\n        if (thisPrincipals != null && !thisPrincipals.isEmpty()) {\n            primary = thisPrincipals.iterator().next();\n        } else {\n            //no principals attributed to this particular realm.  Fall back to the 'master' primary:\n            primary = principals.getPrimaryPrincipal();\n        }\n        return primary;\n    }\n}\n","lineNo":405}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.session.mgt;\n\nimport org.apache.shiro.session.ExpiredSessionException;\nimport org.apache.shiro.session.InvalidSessionException;\nimport org.apache.shiro.session.StoppedSessionException;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.text.DateFormat;\nimport java.util.*;\n\n\n/**\n * Simple {@link org.apache.shiro.session.Session} JavaBeans-compatible POJO implementation, intended to be used on the\n * business/server tier.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SimpleSession implements ValidatingSession, Serializable {\n\n    // Serialization reminder:\n    // You _MUST_ change this number if you introduce a change to this class\n    // that is NOT serialization backwards compatible.  Serialization-compatible\n    // changes do not require a change to this number.  If you need to generate\n    // a new number in this case, use the JDK's 'serialver' program to generate it.\n    private static final long serialVersionUID = -7125642695178165650L;\n\n    //TODO - complete JavaDoc\n    private transient static final Logger log = LoggerFactory.getLogger(SimpleSession.class);\n\n    protected static final long MILLIS_PER_SECOND = 1000;\n    protected static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n    protected static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n\n    //serialization bitmask fields. DO NOT CHANGE THE ORDER THEY ARE DECLARED!\n    static int bitIndexCounter = 0;\n    private static final int ID_BIT_MASK = 1 << bitIndexCounter++;\n    private static final int START_TIMESTAMP_BIT_MASK = 1 << bitIndexCounter++;\n    private static final int STOP_TIMESTAMP_BIT_MASK = 1 << bitIndexCounter++;\n    private static final int LAST_ACCESS_TIME_BIT_MASK = 1 << bitIndexCounter++;\n    private static final int TIMEOUT_BIT_MASK = 1 << bitIndexCounter++;\n    private static final int EXPIRED_BIT_MASK = 1 << bitIndexCounter++;\n    private static final int HOST_BIT_MASK = 1 << bitIndexCounter++;\n    private static final int ATTRIBUTES_BIT_MASK = 1 << bitIndexCounter++;\n\n    private Serializable id;\n    private Date startTimestamp;\n    private Date stopTimestamp;\n    private Date lastAccessTime;\n    private long timeout;\n    private boolean expired;\n    private String host;\n\n    private Map<Object, Object> attributes;\n\n    public SimpleSession() {\n        this.timeout = DefaultSessionManager.DEFAULT_GLOBAL_SESSION_TIMEOUT; //TODO - remove concrete reference to DefaultSessionManager\n        this.startTimestamp = new Date();\n        this.lastAccessTime = this.startTimestamp;\n    }\n\n    public SimpleSession(String host) {\n        this();\n        this.host = host;\n    }\n\n    public Serializable getId() {\n        return this.id;\n    }\n\n    public void setId(Serializable id) {\n        this.id = id;\n    }\n\n    public Date getStartTimestamp() {\n        return startTimestamp;\n    }\n\n    public void setStartTimestamp(Date startTimestamp) {\n        this.startTimestamp = startTimestamp;\n    }\n\n    /**\n     * Returns the time the session was stopped, or <tt>null<\/tt> if the session is still active.\n     * <p/>\n     * A session may become stopped under a number of conditions:\n     * <ul>\n     * <li>If the user logs out of the system, their current session is terminated (released).<\/li>\n     * <li>If the session expires<\/li>\n     * <li>The application explicitly calls {@link #stop()}<\/li>\n     * <li>If there is an internal system error and the session state can no longer accurately\n     * reflect the user's behavior, such in the case of a system crash<\/li>\n     * <\/ul>\n     * <p/>\n     * Once stopped, a session may no longer be used.  It is locked from all further activity.\n     *\n     * @return The time the session was stopped, or <tt>null<\/tt> if the session is still\n     *         active.\n     */\n    public Date getStopTimestamp() {\n        return stopTimestamp;\n    }\n\n    public void setStopTimestamp(Date stopTimestamp) {\n        this.stopTimestamp = stopTimestamp;\n    }\n\n    public Date getLastAccessTime() {\n        return lastAccessTime;\n    }\n\n    public void setLastAccessTime(Date lastAccessTime) {\n        this.lastAccessTime = lastAccessTime;\n    }\n\n    /**\n     * Returns true if this session has expired, false otherwise.  If the session has\n     * expired, no further user interaction with the system may be done under this session.\n     *\n     * @return true if this session has expired, false otherwise.\n     */\n    public boolean isExpired() {\n        return expired;\n    }\n\n    public void setExpired(boolean expired) {\n        this.expired = expired;\n    }\n\n    public long getTimeout() {\n        return timeout;\n    }\n\n    public void setTimeout(long timeout) {\n        this.timeout = timeout;\n    }\n\n    public String getHost() {\n        return host;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public Map<Object, Object> getAttributes() {\n        return attributes;\n    }\n\n    public void setAttributes(Map<Object, Object> attributes) {\n        this.attributes = attributes;\n    }\n\n    public void touch() {\n        this.lastAccessTime = new Date();\n    }\n\n    public void stop() {\n        if (this.stopTimestamp == null) {\n            this.stopTimestamp = new Date();\n        }\n    }\n\n    protected boolean isStopped() {\n        return getStopTimestamp() != null;\n    }\n\n    protected void expire() {\n        stop();\n        this.expired = true;\n    }\n\n    /**\n     * @since 0.9\n     */\n    public boolean isValid() {\n        return !isStopped() && !isExpired();\n    }\n\n    /**\n     * Determines if this session is expired.\n     *\n     * @return true if the specified session has expired, false otherwise.\n     */\n    protected boolean isTimedOut() {\n\n        if (isExpired()) {\n            return true;\n        }\n\n        long timeout = getTimeout();\n\n        if (timeout >= 0l) {\n\n            Date lastAccessTime = getLastAccessTime();\n\n            if (lastAccessTime == null) {\n                String msg = \"session.lastAccessTime for session with id [\" +\n                        getId() + \"] is null.  This value must be set at \" +\n                        \"least once, preferably at least upon instantiation.  Please check the \" +\n                        getClass().getName() + \" implementation and ensure \" +\n                        \"this value will be set (perhaps in the constructor?)\";\n                throw new IllegalStateException(msg);\n            }\n\n            // Calculate at what time a session would have been last accessed\n            // for it to be expired at this point.  In other words, subtract\n            // from the current time the amount of time that a session can\n            // be inactive before expiring.  If the session was last accessed\n            // before this time, it is expired.\n            long expireTimeMillis = System.currentTimeMillis() - timeout;\n            Date expireTime = new Date(expireTimeMillis);\n            return lastAccessTime.before(expireTime);\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"No timeout for session with id [\" + getId() +\n                        \"].  Session is not considered expired.\");\n            }\n        }\n\n        return false;\n    }\n\n    public void validate() throws InvalidSessionException {\n        //check for stopped:\n        if (isStopped()) {\n            //timestamp is set, so the session is considered stopped:\n            String msg = \"Session with id [\" + getId() + \"] has been \" +\n                    \"explicitly stopped.  No further interaction under this session is \" +\n                    \"allowed.\";\n            throw new StoppedSessionException(msg, getId());\n        }\n\n        //check for expiration\n        if (isTimedOut()) {\n            expire();\n\n            //throw an exception explaining details of why it expired:\n            Date lastAccessTime = getLastAccessTime();\n            long timeout = getTimeout();\n\n            Serializable sessionId = getId();\n\n            DateFormat df = DateFormat.getInstance();\n            String msg = \"Session with id [\" + sessionId + \"] has expired. \" +\n                    \"Last access time: \" + df.format(lastAccessTime) +\n                    \".  Current time: \" + df.format(new Date()) +\n                    \".  Session timeout is set to \" + timeout / MILLIS_PER_SECOND + \" seconds (\" +\n                    timeout / MILLIS_PER_MINUTE + \" minutes)\";\n            if (log.isTraceEnabled()) {\n                log.trace(msg);\n            }\n            throw new ExpiredSessionException(msg, sessionId);\n        }\n    }\n\n    private Map<Object, Object> getAttributesLazy() {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            attributes = new HashMap<Object, Object>();\n            setAttributes(attributes);\n        }\n        return attributes;\n    }\n\n    public Collection<Object> getAttributeKeys() throws InvalidSessionException {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            return Collections.emptySet();\n        }\n        return attributes.keySet();\n    }\n\n    public Object getAttribute(Object key) {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            return null;\n        }\n        return attributes.get(key);\n    }\n\n    public void setAttribute(Object key, Object value) {\n        if (value == null) {\n            removeAttribute(key);\n        } else {\n            getAttributesLazy().put(key, value);\n        }\n    }\n\n    public Object removeAttribute(Object key) {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            return null;\n        } else {\n            return attributes.remove(key);\n        }\n    }\n\n    /**\n     * Returns {@code true} if the specified argument is an {@code instanceof} {@code SimpleSession} and both\n     * {@link #getId() id}s are equal.  If the argument is a {@code SimpleSession} and either 'this' or the argument\n     * does not yet have an ID assigned, the value of {@link #onEquals(SimpleSession) onEquals} is returned, which\n     * does a necessary attribute-based comparison when IDs are not available.\n     * <p/>\n     * Do your best to ensure {@code SimpleSession} instances receive an ID very early in their lifecycle to\n     * avoid the more expensive attributes-based comparison.\n     *\n     * @param obj the object to compare with this one for equality.\n     * @return {@code true} if this object is equivalent to the specified argument, {@code false} otherwise.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof SimpleSession) {\n            SimpleSession other = (SimpleSession) obj;\n            Serializable thisId = getId();\n            Serializable otherId = other.getId();\n            if (thisId != null && otherId != null) {\n                return thisId.equals(otherId);\n            } else {\n                //fall back to an attribute based comparison:\n                return onEquals(other);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Provides an attribute-based comparison (no ID comparison) - incurred <em>only<\/em> when 'this' or the\n     * session object being compared for equality do not have a session id.\n     *\n     * @param ss the SimpleSession instance to compare for equality.\n     * @return true if all the attributes, except the id, are equal to this object's attributes.\n     * @since 1.0\n     */\n    protected boolean onEquals(SimpleSession ss) {\n        return (getStartTimestamp() != null ? getStartTimestamp().equals(ss.getStartTimestamp()) : ss.getStartTimestamp() == null) &&\n                (getStopTimestamp() != null ? getStopTimestamp().equals(ss.getStopTimestamp()) : ss.getStopTimestamp() == null) &&\n                (getLastAccessTime() != null ? getLastAccessTime().equals(ss.getLastAccessTime()) : ss.getLastAccessTime() == null) &&\n                (getTimeout() == ss.getTimeout()) &&\n                (isExpired() == ss.isExpired()) &&\n                (getHost() != null ? getHost().equals(ss.getHost()) : ss.getHost() == null) &&\n                (getAttributes() != null ? getAttributes().equals(ss.getAttributes()) : ss.getAttributes() == null);\n    }\n\n    /**\n     * Returns the hashCode.  If the {@link #getId() id} is not {@code null}, its hashcode is returned immediately.\n     * If it is {@code null}, an attributes-based hashCode will be calculated and returned.\n     * <p/>\n     * Do your best to ensure {@code SimpleSession} instances receive an ID very early in their lifecycle to\n     * avoid the more expensive attributes-based calculation.\n     *\n     * @return this object's hashCode\n     * @since 1.0\n     */\n    @Override\n    public int hashCode() {\n        Serializable id = getId();\n        if (id != null) {\n            return id.hashCode();\n        }\n        int hashCode = getStartTimestamp() != null ? getStartTimestamp().hashCode() : 0;\n        hashCode = 31 * hashCode + (getStopTimestamp() != null ? getStopTimestamp().hashCode() : 0);\n        hashCode = 31 * hashCode + (getLastAccessTime() != null ? getLastAccessTime().hashCode() : 0);\n        hashCode = 31 * hashCode + Long.valueOf(Math.max(getTimeout(), 0)).hashCode();\n        hashCode = 31 * hashCode + Boolean.valueOf(isExpired()).hashCode();\n        hashCode = 31 * hashCode + (getHost() != null ? getHost().hashCode() : 0);\n        hashCode = 31 * hashCode + (getAttributes() != null ? getAttributes().hashCode() : 0);\n        return hashCode;\n    }\n\n    /**\n     * Returns the string representation of this SimpleSession, equal to\n     * <code>getClass().getName() + &quot;,id=&quot; + getId()<\/code>.\n     *\n     * @return the string representation of this SimpleSession, equal to\n     *         <code>getClass().getName() + &quot;,id=&quot; + getId()<\/code>.\n     * @since 1.0\n     */\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(getClass().getName()).append(\",id=\").append(getId());\n        return sb.toString();\n    }\n\n    /**\n     * Serializes this object to the specified output stream for JDK Serialization.\n     *\n     * @param out output stream used for Object serialization.\n     * @throws IOException if any of this object's fields cannot be written to the stream.\n     * @since 1.0\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        short alteredFieldsBitMask = getAlteredFieldsBitMask();\n        out.writeShort(alteredFieldsBitMask);\n        if (id != null) {\n            out.writeObject(id);\n        }\n        if (startTimestamp != null) {\n            out.writeObject(startTimestamp);\n        }\n        if (stopTimestamp != null) {\n            out.writeObject(stopTimestamp);\n        }\n        if (lastAccessTime != null) {\n            out.writeObject(lastAccessTime);\n        }\n        if (timeout != 0l) {\n            out.writeLong(timeout);\n        }\n        if (expired) {\n            out.writeBoolean(expired);\n        }\n        if (host != null) {\n            out.writeUTF(host);\n        }\n        if (!CollectionUtils.isEmpty(attributes)) {\n            out.writeObject(attributes);\n        }\n    }\n\n    /**\n     * Reconstitutes this object based on the specified InputStream for JDK Serialization.\n     *\n     * @param in the input stream to use for reading data to populate this object.\n     * @throws IOException            if the input stream cannot be used.\n     * @throws ClassNotFoundException if a required class needed for instantiation is not available in the present JVM\n     * @since 1.0\n     */\n    @SuppressWarnings({\"unchecked\"})\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        short bitMask = in.readShort();\n\n        if (isFieldPresent(bitMask, ID_BIT_MASK)) {\n            this.id = (Serializable) in.readObject();\n        }\n        if (isFieldPresent(bitMask, START_TIMESTAMP_BIT_MASK)) {\n            this.startTimestamp = (Date) in.readObject();\n        }\n        if (isFieldPresent(bitMask, STOP_TIMESTAMP_BIT_MASK)) {\n            this.stopTimestamp = (Date) in.readObject();\n        }\n        if (isFieldPresent(bitMask, LAST_ACCESS_TIME_BIT_MASK)) {\n            this.lastAccessTime = (Date) in.readObject();\n        }\n        if (isFieldPresent(bitMask, TIMEOUT_BIT_MASK)) {\n            this.timeout = in.readLong();\n        }\n        if (isFieldPresent(bitMask, EXPIRED_BIT_MASK)) {\n            this.expired = in.readBoolean();\n        }\n        if (isFieldPresent(bitMask, HOST_BIT_MASK)) {\n            this.host = in.readUTF();\n        }\n        if (isFieldPresent(bitMask, ATTRIBUTES_BIT_MASK)) {\n            this.attributes = (Map<Object, Object>) in.readObject();\n        }\n    }\n\n    /**\n     * Returns a bit mask used during serialization indicating which fields have been serialized. Fields that have been\n     * altered (not null and/or not retaining the class defaults) will be serialized and have 1 in their respective\n     * index, fields that are null and/or retain class default values have 0.\n     *\n     * @return a bit mask used during serialization indicating which fields have been serialized.\n     * @since 1.0\n     */\n    private short getAlteredFieldsBitMask() {\n        int bitMask = 0;\n        bitMask = id != null ? bitMask | ID_BIT_MASK : bitMask;\n        bitMask = startTimestamp != null ? bitMask | START_TIMESTAMP_BIT_MASK : bitMask;\n        bitMask = stopTimestamp != null ? bitMask | STOP_TIMESTAMP_BIT_MASK : bitMask;\n        bitMask = lastAccessTime != null ? bitMask | LAST_ACCESS_TIME_BIT_MASK : bitMask;\n        bitMask = timeout != 0l ? bitMask | TIMEOUT_BIT_MASK : bitMask;\n        bitMask = !expired ? bitMask | EXPIRED_BIT_MASK : bitMask;\n        bitMask = host != null ? bitMask | HOST_BIT_MASK : bitMask;\n        bitMask = !CollectionUtils.isEmpty(attributes) ? bitMask | ATTRIBUTES_BIT_MASK : bitMask;\n        return (short) bitMask;\n    }\n\n    /**\n     * Returns {@code true} if the given {@code bitMask} argument indicates that the specified field has been\n     * serialized and therefore should be read during deserialization, {@code false} otherwise.\n     *\n     * @param bitMask      the aggregate bitmask for all fields that have been serialized.  Individual bits represent\n     *                     the fields that have been serialized.  A bit set to 1 means that corresponding field has\n     *                     been serialized, 0 means it hasn't been serialized.\n     * @param fieldBitMask the field bit mask constant identifying which bit to inspect (corresponds to a class attribute).\n     * @return {@code true} if the given {@code bitMask} argument indicates that the specified field has been\n     *         serialized and therefore should be read during deserialization, {@code false} otherwise.\n     * @since 1.0\n     */\n    private static boolean isFieldPresent(short bitMask, int fieldBitMask) {\n        return (bitMask & fieldBitMask) != 0;\n    }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.session.mgt;\n\nimport org.apache.shiro.session.ExpiredSessionException;\nimport org.apache.shiro.session.InvalidSessionException;\nimport org.apache.shiro.session.StoppedSessionException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.text.DateFormat;\nimport java.util.*;\n\n\n/**\n * Simple {@link org.apache.shiro.session.Session} JavaBeans-compatible POJO implementation, intended to be used on the\n * business/server tier.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SimpleSession implements ValidatingSession, Serializable {\n\n    //TODO - complete JavaDoc\n\n    protected static final long MILLIS_PER_SECOND = 1000;\n    protected static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n    protected static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n\n    private transient static final Logger log = LoggerFactory.getLogger(SimpleSession.class);\n\n    private Serializable id = null;\n    private Date startTimestamp = null;\n    private Date stopTimestamp = null;\n    private Date lastAccessTime = null;\n    private long timeout = DefaultSessionManager.DEFAULT_GLOBAL_SESSION_TIMEOUT;\n    private boolean expired = false;\n    private String host = null;\n\n    private Map<Object, Object> attributes = null;\n\n    public SimpleSession() {\n        this.startTimestamp = new Date();\n        this.lastAccessTime = this.startTimestamp;\n    }\n\n    public SimpleSession(String host) {\n        this();\n        this.host = host;\n    }\n\n    public Serializable getId() {\n        return this.id;\n    }\n\n    public void setId(Serializable id) {\n        this.id = id;\n    }\n\n    public Date getStartTimestamp() {\n        return startTimestamp;\n    }\n\n    public void setStartTimestamp(Date startTimestamp) {\n        this.startTimestamp = startTimestamp;\n    }\n\n    /**\n     * Returns the time the session was stopped, or <tt>null<\/tt> if the session is still active.\n     * <p/>\n     * A session may become stopped under a number of conditions:\n     * <ul>\n     * <li>If the user logs out of the system, their current session is terminated (released).<\/li>\n     * <li>If the session expires<\/li>\n     * <li>The application explicitly calls {@link #stop()}<\/li>\n     * <li>If there is an internal system error and the session state can no longer accurately\n     * reflect the user's behavior, such in the case of a system crash<\/li>\n     * <\/ul>\n     * <p/>\n     * Once stopped, a session may no longer be used.  It is locked from all further activity.\n     *\n     * @return The time the session was stopped, or <tt>null<\/tt> if the session is still\n     *         active.\n     */\n    public Date getStopTimestamp() {\n        return stopTimestamp;\n    }\n\n    public void setStopTimestamp(Date stopTimestamp) {\n        this.stopTimestamp = stopTimestamp;\n    }\n\n    public Date getLastAccessTime() {\n        return lastAccessTime;\n    }\n\n    public void setLastAccessTime(Date lastAccessTime) {\n        this.lastAccessTime = lastAccessTime;\n    }\n\n    /**\n     * Returns true if this session has expired, false otherwise.  If the session has\n     * expired, no further user interaction with the system may be done under this session.\n     *\n     * @return true if this session has expired, false otherwise.\n     */\n    public boolean isExpired() {\n        return expired;\n    }\n\n    public void setExpired(boolean expired) {\n        this.expired = expired;\n    }\n\n    public long getTimeout() {\n        return timeout;\n    }\n\n    public void setTimeout(long timeout) {\n        this.timeout = timeout;\n    }\n\n    public String getHost() {\n        return host;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public Map<Object, Object> getAttributes() {\n        return attributes;\n    }\n\n    public void setAttributes(Map<Object, Object> attributes) {\n        this.attributes = attributes;\n    }\n\n    public void touch() {\n        this.lastAccessTime = new Date();\n    }\n\n    public void stop() {\n        if (this.stopTimestamp == null) {\n            this.stopTimestamp = new Date();\n        }\n    }\n\n    protected boolean isStopped() {\n        return getStopTimestamp() != null;\n    }\n\n    protected void expire() {\n        stop();\n        if (!this.expired) {\n            this.expired = true;\n        }\n    }\n\n    /**\n     * @since 0.9\n     */\n    public boolean isValid() {\n        return !isStopped() && !isExpired();\n    }\n\n    /**\n     * Determines if this session is expired.\n     *\n     * @return true if the specified session has expired, false otherwise.\n     */\n    protected boolean isTimedOut() {\n\n        if (isExpired()) {\n            return true;\n        }\n\n        long timeout = getTimeout();\n\n        if (timeout >= 0l) {\n\n            Date lastAccessTime = getLastAccessTime();\n\n            if (lastAccessTime == null) {\n                String msg = \"session.lastAccessTime for session with id [\" +\n                        getId() + \"] is null.  This value must be set at \" +\n                        \"least once, preferably at least upon instantiation.  Please check the \" +\n                        getClass().getName() + \" implementation and ensure \" +\n                        \"this value will be set (perhaps in the constructor?)\";\n                throw new IllegalStateException(msg);\n            }\n\n            // Calculate at what time a session would have been last accessed\n            // for it to be expired at this point.  In other words, subtract\n            // from the current time the amount of time that a session can\n            // be inactive before expiring.  If the session was last accessed\n            // before this time, it is expired.\n            long expireTimeMillis = System.currentTimeMillis() - timeout;\n            Date expireTime = new Date(expireTimeMillis);\n            return lastAccessTime.before(expireTime);\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"No timeout for session with id [\" + getId() +\n                        \"].  Session is not considered expired.\");\n            }\n        }\n\n        return false;\n    }\n\n    public void validate() throws InvalidSessionException {\n        //check for stopped:\n        if (isStopped()) {\n            //timestamp is set, so the session is considered stopped:\n            String msg = \"Session with id [\" + getId() + \"] has been \" +\n                    \"explicitly stopped.  No further interaction under this session is \" +\n                    \"allowed.\";\n            throw new StoppedSessionException(msg, getId());\n        }\n\n        //check for expiration\n        if (isTimedOut()) {\n            expire();\n\n            //throw an exception explaining details of why it expired:\n            Date lastAccessTime = getLastAccessTime();\n            long timeout = getTimeout();\n\n            Serializable sessionId = getId();\n\n            DateFormat df = DateFormat.getInstance();\n            String msg = \"Session with id [\" + sessionId + \"] has expired. \" +\n                    \"Last access time: \" + df.format(lastAccessTime) +\n                    \".  Current time: \" + df.format(new Date()) +\n                    \".  Session timeout is set to \" + timeout / MILLIS_PER_SECOND + \" seconds (\" +\n                    timeout / MILLIS_PER_MINUTE + \" minutes)\";\n            if (log.isTraceEnabled()) {\n                log.trace(msg);\n            }\n            throw new ExpiredSessionException(msg, sessionId);\n        }\n    }\n\n    private Map<Object, Object> getAttributesLazy() {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            attributes = new HashMap<Object, Object>();\n            setAttributes(attributes);\n        }\n        return attributes;\n    }\n\n    public Collection<Object> getAttributeKeys() throws InvalidSessionException {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            //noinspection unchecked\n            return Collections.EMPTY_SET;\n        }\n        return attributes.keySet();\n    }\n\n    public Object getAttribute(Object key) {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            return null;\n        }\n        return attributes.get(key);\n    }\n\n    public void setAttribute(Object key, Object value) {\n        if (value == null) {\n            removeAttribute(key);\n        } else {\n            getAttributesLazy().put(key, value);\n        }\n    }\n\n    public Object removeAttribute(Object key) {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            return null;\n        } else {\n            return attributes.remove(key);\n        }\n    }\n\n    /**\n     * Returns {@code true} if the specified argument is an {@code instanceof} {@code SimpleSession} and both\n     * {@link #getId() id}s are equal.  If the argument is a {@code SimpleSession} and either 'this' or the argument\n     * does not yet have an ID assigned, the value of {@link #onEquals(SimpleSession) onEquals} is returned, which\n     * does a necessary attribute-based comparison when IDs are not available.\n     * <p/>\n     * Do your best to ensure {@code SimpleSession} instances receive an ID very early in their lifecycle to\n     * avoid the more expensive attributes-based comparison.\n     *\n     * @param obj the object to compare with this one for equality.\n     * @return {@code true} if this object is equivalent to the specified argument, {@code false} otherwise.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof SimpleSession) {\n            SimpleSession other = (SimpleSession) obj;\n            Serializable thisId = getId();\n            Serializable otherId = other.getId();\n            if (thisId != null && otherId != null) {\n                return thisId.equals(otherId);\n            } else {\n                //fall back to an attribute based comparison:\n                return onEquals(other);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Provides an attribute-based comparison (no ID comparison) - incurred <em>only<\/em> when 'this' or the\n     * session object being compared for equality do not have a session id.\n     *\n     * @param ss the SimpleSession instance to compare for equality.\n     * @return true if all the attributes, except the id, are equal to this object's attributes.\n     * @since 1.0\n     */\n    protected boolean onEquals(SimpleSession ss) {\n        return (getStartTimestamp() != null ? getStartTimestamp().equals(ss.getStartTimestamp()) : ss.getStartTimestamp() == null) &&\n                (getStopTimestamp() != null ? getStopTimestamp().equals(ss.getStopTimestamp()) : ss.getStopTimestamp() == null) &&\n                (getLastAccessTime() != null ? getLastAccessTime().equals(ss.getLastAccessTime()) : ss.getLastAccessTime() == null) &&\n                (getTimeout() == ss.getTimeout()) &&\n                (isExpired() == ss.isExpired()) &&\n                (getHost() != null ? getHost().equals(ss.getHost()) : ss.getHost() == null) &&\n                (getAttributes() != null ? getAttributes().equals(ss.getAttributes()) : ss.getAttributes() == null);\n    }\n\n    /**\n     * Returns the hashCode.  If the {@link #getId() id} is not {@code null}, its hashcode is returned immediately.\n     * If it is {@code null}, an attributes-based hashCode will be calculated and returned.\n     * <p/>\n     * Do your best to ensure {@code SimpleSession} instances receive an ID very early in their lifecycle to\n     * avoid the more expensive attributes-based calculation.\n     *\n     * @return this object's hashCode\n     * @since 1.0\n     */\n    @Override\n    public int hashCode() {\n        if (getId() != null) {\n            return getId().hashCode();\n        }\n        int hashCode = getStartTimestamp() != null ? getStartTimestamp().hashCode() : 0;\n        hashCode = 31 * hashCode + (getStopTimestamp() != null ? getStopTimestamp().hashCode() : 0);\n        hashCode = 31 * hashCode + (getLastAccessTime() != null ? getLastAccessTime().hashCode() : 0);\n        hashCode = 31 * hashCode + Long.valueOf(Math.max(getTimeout(), 0)).hashCode();\n        hashCode = 31 * hashCode + Boolean.valueOf(isExpired()).hashCode();\n        hashCode = 31 * hashCode + (getHost() != null ? getHost().hashCode() : 0);\n        hashCode = 31 * hashCode + (getAttributes() != null ? getAttributes().hashCode() : 0);\n        return hashCode;\n    }\n\n    /**\n     * Returns the string representation of this SimpleSession, equal to\n     * <code>getClass().getName() + &quot;,id=&quot; + getId()<\/code>.\n     *\n     * @return the string representation of this SimpleSession, equal to\n     *         <code>getClass().getName() + &quot;,id=&quot; + getId()<\/code>.\n     * @since 1.0\n     */\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(getClass().getName()).append(\",id=\").append(getId());\n        return sb.toString();\n    }\n}\n","lineNo":384}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.filter.authz;\n\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.util.StringUtils;\nimport org.apache.shiro.web.WebUtils;\nimport org.apache.shiro.web.filter.AccessControlFilter;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * Superclass for authorization-related filters.  If an request is unauthorized, response handling is delegated to the\n * {@link #onAccessDenied(javax.servlet.ServletRequest, javax.servlet.ServletResponse) onAccessDenied} method, which\n * provides reasonable handling for most applications.\n *\n * @see #onAccessDenied(javax.servlet.ServletRequest, javax.servlet.ServletResponse)\n * \n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.9\n */\npublic abstract class AuthorizationFilter extends AccessControlFilter {\n\n    /**\n     * The URL to which users should be redirected if they are denied access to an underlying path or resource,\n     * {@code null} by default which will issue a raw {@link HttpServletResponse#SC_UNAUTHORIZED} response\n     * (401 Unauthorized).\n     */\n    private String unauthorizedUrl;\n\n    /**\n     * Returns the URL to which users should be redirected if they are denied access to an underlying path or resource,\n     * or {@code null} if a raw {@link HttpServletResponse#SC_UNAUTHORIZED} response should be issued (401 Unauthorized).\n     * <p/>\n     * The default is {@code null}, ensuring default web server behavior.  Override this default by calling the\n     * {@link #setUnauthorizedUrl(String) setUnauthorizedUrl} method with a meaningful path within your application\n     * if you would like to show the user a 'nice' page in the event of unauthorized access.\n     *\n     * @return the URL to which users should be redirected if they are denied access to an underlying path or resource,\n     *         or {@code null} if a raw {@link HttpServletResponse#SC_UNAUTHORIZED} response should be issued (401 Unauthorized).\n     */\n    public String getUnauthorizedUrl() {\n        return unauthorizedUrl;\n    }\n\n    /**\n     * Sets the URL to which users should be redirected if they are denied access to an underlying path or resource.\n     * <p/>\n     * If the value is {@code null} a raw {@link HttpServletResponse#SC_UNAUTHORIZED} response will\n     * be issued (401 Unauthorized), retaining default web server behavior.\n     * <p/>\n     * Unless overridden by calling this method, the default value is {@code null}.  If desired, you can specify a\n     * meaningful path within your application if you would like to show the user a 'nice' page in the event of\n     * unauthorized access.\n     *\n     * @param unauthorizedUrl the URL to which users should be redirected if they are denied access to an underlying\n     *                        path or resource, or {@code null} to a ensure raw {@link HttpServletResponse#SC_UNAUTHORIZED} response is\n     *                        issued (401 Unauthorized).\n     */\n    public void setUnauthorizedUrl(String unauthorizedUrl) {\n        this.unauthorizedUrl = unauthorizedUrl;\n    }\n\n    /**\n     * Handles the response when access has been denied.  It behaves as follows:\n     * <ul>\n     * <li>If the {@code Subject} is unknown<sup><a href=\"#known\">[1]<\/a><\/sup>:\n     * <ol><li>The incoming request will be saved and they will be redirected to the login page for authentication\n     * (via the {@link #saveRequestAndRedirectToLogin(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}\n     * method).<\/li>\n     * <li>Once successfully authenticated, they will be redirected back to the originally attempted page.<\/li><\/ol>\n     * <\/li>\n     * <li>If the Subject is known:<\/li>\n     * <ol>\n     * <li>The HTTP {@link HttpServletResponse#SC_UNAUTHORIZED} header will be set (401 Unauthorized)<\/li>\n     * <li>If the {@link #getUnauthorizedUrl() unauthorizedUrl} has been configured, a redirect will be issued to that\n     * URL.  Otherwise the 401 response is rendered normally<\/li>\n     * <\/ul>\n     * <code><a name=\"known\">[1]<\/a><\/code>: A {@code Subject} is 'known' when\n     * <code>subject.{@link org.apache.shiro.subject.Subject#getPrincipal() getPrincipal()}<\/code> is not {@code null},\n     * which implicitly means that the subject is either currently authenticated or they have been remembered via\n     * 'remember me' services.\n     *\n     * @param request  the incoming <code>ServletRequest<\/code>\n     * @param response the outgoing <code>ServletResponse<\/code>\n     * @return {@code false} always for this implementation.\n     * @throws IOException if there is any servlet error.\n     */\n    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws IOException {\n\n        Subject subject = getSubject(request, response);\n        // If the subject isn't identified, redirect to login URL\n        if (subject.getPrincipal() == null) {\n            saveRequestAndRedirectToLogin(request, response);\n        } else {\n            // If subject is known but not authorized, redirect to the unauthorized URL if there is one\n            // If no unauthorized URL is specified, just return an unauthorized HTTP status code\n            String unauthorizedUrl = getUnauthorizedUrl();\n            //SHIRO-142 - ensure that redirect _or_ error code occurs - both cannot happen due to response commit:\n            if ( StringUtils.hasText(unauthorizedUrl) ) {\n                WebUtils.issueRedirect(request, response, unauthorizedUrl);\n            } else {\n                WebUtils.toHttp(response).sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            }\n        }\n        return false;\n    }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.filter.authz;\n\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.util.StringUtils;\nimport org.apache.shiro.web.WebUtils;\nimport org.apache.shiro.web.filter.AccessControlFilter;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * Superclass for authorization-related filters.  If an request is unauthorized, response handling is delegated to the\n * {@link #onAccessDenied(javax.servlet.ServletRequest, javax.servlet.ServletResponse) onAccessDenied} method, which\n * provides reasonable handling for most applications.\n *\n * @see #onAccessDenied(javax.servlet.ServletRequest, javax.servlet.ServletResponse)\n * \n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.9\n */\npublic abstract class AuthorizationFilter extends AccessControlFilter {\n\n    /**\n     * The URL to which users should be redirected if they are denied access to an underlying path or resource,\n     * {@code null} by default which will issue a raw {@link HttpServletResponse#SC_UNAUTHORIZED} response\n     * (401 Unauthorized).\n     */\n    private String unauthorizedUrl;\n\n    /**\n     * Returns the URL to which users should be redirected if they are denied access to an underlying path or resource,\n     * or {@code null} if a raw {@link HttpServletResponse#SC_UNAUTHORIZED} response should be issued (401 Unauthorized).\n     * <p/>\n     * The default is {@code null}, ensuring default web server behavior.  Override this default by calling the\n     * {@link #setUnauthorizedUrl(String) setUnauthorizedUrl} method with a meaningful path within your application\n     * if you would like to show the user a 'nice' page in the event of unauthorized access.\n     *\n     * @return the URL to which users should be redirected if they are denied access to an underlying path or resource,\n     *         or {@code null} if a raw {@link HttpServletResponse#SC_UNAUTHORIZED} response should be issued (401 Unauthorized).\n     */\n    public String getUnauthorizedUrl() {\n        return unauthorizedUrl;\n    }\n\n    /**\n     * Sets the URL to which users should be redirected if they are denied access to an underlying path or resource.\n     * <p/>\n     * If the value is {@code null} a raw {@link HttpServletResponse#SC_UNAUTHORIZED} response will\n     * be issued (401 Unauthorized), retaining default web server behavior.\n     * <p/>\n     * Unless overridden by calling this method, the default value is {@code null}.  If desired, you can specify a\n     * meaningful path within your application if you would like to show the user a 'nice' page in the event of\n     * unauthorized access.\n     *\n     * @param unauthorizedUrl the URL to which users should be redirected if they are denied access to an underlying\n     *                        path or resource, or {@code null} to a ensure raw {@link HttpServletResponse#SC_UNAUTHORIZED} response is\n     *                        issued (401 Unauthorized).\n     */\n    public void setUnauthorizedUrl(String unauthorizedUrl) {\n        this.unauthorizedUrl = unauthorizedUrl;\n    }\n\n    /**\n     * Handles the response when access has been denied.  It behaves as follows:\n     * <ul>\n     * <li>If the {@code Subject} is unknown<sup><a href=\"#known\">[1]<\/a><\/sup>:\n     * <ol><li>The incoming request will be saved and they will be redirected to the login page for authentication\n     * (via the {@link #saveRequestAndRedirectToLogin(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}\n     * method).<\/li>\n     * <li>Once successfully authenticated, they will be redirected back to the originally attempted page.<\/li><\/ol>\n     * <\/li>\n     * <li>If the Subject is known:<\/li>\n     * <ol>\n     * <li>The HTTP {@link HttpServletResponse#SC_UNAUTHORIZED} header will be set (401 Unauthorized)<\/li>\n     * <li>If the {@link #getUnauthorizedUrl() unauthorizedUrl} has been configured, a redirect will be issued to that\n     * URL.  Otherwise the 401 response is rendered normally<\/li>\n     * <\/ul>\n     * <code><a name=\"known\">[1]<\/a><\/code>: A {@code Subject} is 'known' when\n     * <code>subject.{@link org.apache.shiro.subject.Subject#getPrincipal() getPrincipal()}<\/code> is not {@code null},\n     * which implicitly means that the subject is either currently authenticated or they have been remembered via\n     * 'remember me' services.\n     *\n     * @param request  the incoming <code>ServletRequest<\/code>\n     * @param response the outgoing <code>ServletResponse<\/code>\n     * @return {@code false} always for this implementation.\n     * @throws IOException if there is any servlet error.\n     */\n    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws IOException {\n\n        Subject subject = getSubject(request, response);\n        // If the subject isn't identified, redirect to login URL\n        if (subject.getPrincipal() == null) {\n            saveRequestAndRedirectToLogin(request, response);\n        } else {\n            // If subject is known but not authorized, redirect to the unauthorized URL if there is one\n            // If no unauthorized URL is specified, just return an unauthorized HTTP status code\n            WebUtils.toHttp(response).sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            if (StringUtils.hasText(getUnauthorizedUrl())) {\n                WebUtils.issueRedirect(request, response, getUnauthorizedUrl());\n            }\n\n        }\n        return false;\n    }\n\n}\n","lineNo":118}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.servlet;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.config.Configuration;\nimport org.apache.shiro.config.ConfigurationException;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.util.ClassUtils;\nimport org.apache.shiro.util.LifecycleUtils;\nimport org.apache.shiro.util.ThreadContext;\nimport org.apache.shiro.util.ThreadState;\nimport org.apache.shiro.web.DefaultWebSecurityManager;\nimport org.apache.shiro.web.WebSecurityManager;\nimport org.apache.shiro.web.WebUtils;\nimport org.apache.shiro.web.config.IniWebConfiguration;\nimport org.apache.shiro.web.config.WebConfiguration;\nimport org.apache.shiro.web.filter.mgt.FilterChainResolver;\nimport org.apache.shiro.web.subject.WebSubject;\nimport org.apache.shiro.web.subject.support.WebSubjectThreadState;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.beans.PropertyDescriptor;\nimport java.io.IOException;\n\n/**\n * Main ServletFilter that configures and enables all Shiro functions within a web application.\n * <p/>\n * The following is a fully commented example that documents how to configure it:\n * <pre>&lt;filter&gt;\n * &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;\n * &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt;\n * &lt;init-param&gt;&lt;param-name&gt;config&lt;/param-name&gt;&lt;param-value&gt;\n * #\n * #NOTE:  This config looks pretty long - but its not - its only a few lines of actual config.\n * #       Everything else is just heavily commented to explain things in-depth. Feel free to delete any\n * #       comments that you don't want to read from your own configuration ;)\n * #\n * # Any commented values below that _don't_ start with 'example.pkg' are Shiro's defaults.  If you want to change any\n * # values on those lines, you only need to uncomment the lines you want to change.\n * #\n * [main]\n * # The 'main' section defines Shiro-wide configuration.\n * #\n * # The configuration is essentially an object graph definition in a .properties style format.  The beans defined\n * # would be those that are used to construct the application's SecurityManager.  It is essentially 'poor man's'\n * # dependency injection via a .properties format.\n * #\n * # --- Defining Realms ---\n * #\n * # Any Realm defined here will automatically be injected into Shiro's default SecurityManager created at start up.\n * # For example:\n * #\n * # myRealm = example.pkg.security.MyRealm\n * #\n * # This would instantiate the some.pkg.security.MyRealm class with a default no-arg constructor and inject it into\n * # the SecurityManager.  More than one realm can be defined if needed.  You can create graphs and reference\n * # other beans ('$' bean reference notation) while defining Realms and other objects:\n * #\n * # <b>connectionFactory<\/b> = example.pkg.ConnectionFactory\n * # connectionFactory.driverClassName = a.jdbc.Driver\n * # connectionFactory.username = aUsername\n * # connectionFactory.password = aPassword\n * # connectionFactory.minConnections = 3\n * # connectionFactory.maxConnections = 10\n * # ... etc...\n * #\n * # myJdbcRealm = example.pkg.jdbc.MyJdbcRealm\n * # myJdbcRealm.connectionFactory = <b>$connectionFactory<\/b>\n * # ... etc ...\n * #\n * # --- Realm Factories ---\n * #\n * # If the .properties style isn't robust enough for your needs, you also have the option of implementing the\n * # {@link org.apache.shiro.realm.RealmFactory org.apache.shiro.realm.RealmFactory} interface with more complex construction\n * # logic.  Then you can declare the implementation here instead.  The realms it returns will be injected in to the\n * # SecurityManager just as the individual Realms are.  For example:\n * #\n * # aRealmFactory = some.pkg.ClassThatImplementsRealmFactory\n * #\n * # --- SessionManager properties ---\n * #\n * # Except for Realms and RealmFactories, all other objects should be defined and set on the SecurityManager directly.\n * # The default 'securityManager' bean is an instance of {@link org.apache.shiro.web.DefaultWebSecurityManager}, so you\n * # can set any of its corresponding properties as necessary:\n * #\n * # someObject = some.fully.qualified.ClassName\n * # someObject.propertyN = foo\n * # ...\n * # securityManager.someObject = $someObject\n * #\n * # For example, if you wanted to change Shiro's default session mechanism, you can change the 'sessionMode' property.\n * # By default, Shiro's Session infrastructure in a web environment will use the\n * # Servlet container's HttpSession.  However, if you need to share session state across client types\n * # (e.g. Web MVC plus Java Web Start or Flash), or are doing distributed/shared Sessions for\n * # Single Sign On, HttpSessions aren't good enough.  You'll need to use Shiro's more powerful\n * # (and client-agnostic) session management.  You can enable this by uncommenting the following line\n * # and changing 'http' to 'native'\n * #\n * #securityManager.{@link org.apache.shiro.web.DefaultWebSecurityManager#setSessionMode(String) sessionMode} = http\n * #\n * [filters]\n * # This section defines the 'pool' of all Filters available to the url path definitions in the [urls] section below.\n * #\n * # The following commented values are already provided by Shiro by default and are immediately usable\n * # in the [urls] definitions below.  If you like, you may override any values by uncommenting only the lines\n * # you need to change.\n * #\n * # Each Filter is configured based on its functionality and/or protocol.  You should read each\n * # Filter's JavaDoc to fully understand what each does and how it works as well as how it would\n * # affect the user experience.\n * #\n * # Form-based Authentication filter:\n * #<a name=\"authc\"><\/a>authc = {@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter}\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setLoginUrl(String) loginUrl} = /login.jsp\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setUsernameParam(String) usernameParam} = username\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setPasswordParam(String) passwordParam} = password\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setRememberMeParam(String) rememberMeParam} = rememberMe\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setSuccessUrl(String) successUrl}  = /login.jsp\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setFailureKeyAttribute(String) failureKeyAttribute} = {@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#DEFAULT_ERROR_KEY_ATTRIBUTE_NAME}\n * #\n * # Http BASIC Authentication filter:\n * #<a name=\"authcBasic\"><\/a>authcBasic = {@link org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter}\n * #authcBasic.{@link org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter#setApplicationName(String) applicationName} = application\n * #\n * # Roles filter: requires the requesting user to have one or more roles for the request to continue.\n * # If they do not have the specified roles, they are redirected to the specified URL.\n * #<a name=\"roles\"><\/a>roles = {@link org.apache.shiro.web.filter.authz.RolesAuthorizationFilter}\n * #roles.{@link org.apache.shiro.web.filter.authz.RolesAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.\n * #\n * # Permissions filter: requires the requesting user to have one or more permissions for the request to\n * # continue, and if they do not, redirects them to the specified URL.\n * #<a name=\"perms\"><\/a>perms = {@link org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter}\n * #perms.{@link org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.  Many\n * # applications like to use the same url specified in roles.unauthorizedUrl above.\n * #\n * #\n * # Define your own filters here as you would any other object as described in the '[main]' section above (properties,\n * # $references, etc).  To properly handle url path matching (see the [urls] section below), your\n * # filter should extend the {@link org.apache.shiro.web.filter.PathMatchingFilter PathMatchingFilter} abstract class.\n * #\n * [urls]\n * # This section defines url path mappings.  Each mapping entry must be on a single line and conform to the\n * # following representation:\n * #\n * # ant_path_expression = path_specific_filter_chain_definition\n * #\n * # For any request that matches a specified path, the corresponding value defines a comma-delimited chain of\n * # filters to execute for that request.\n * #\n * # This is incredibly powerful in that you can define arbitrary filter chains for any given request pattern\n * # to greatly customize the security experience.\n * #\n * # The path_specific_filter_chain_definition must match the following format:\n * #\n * # filter1[optional_config1], filter2[optional_config2], ..., filterN[optional_configN]\n * #\n * # where 'filterN' is the name of an filter defined above in the [filters] section and\n * # '[optional_configN]' is an optional bracketed string that has meaning for that particular filter for\n * # _that particular path_.  If the filter does not need specific config for that url path, you may\n * # discard the brackets - that is, filterN[] just becomes filterN.\n * #\n * # And because filter tokens define chains, order matters!  Define the tokens for each path pattern\n * # in the order you want them to filter (comma-delimited).\n * #\n * # Finally, each filter is free to handle the response however it wants if its necessary\n * # conditions are not met (redirect, HTTP error code, direct rendering, etc).  Otherwise, it is expected to allow\n * # the request to continue through the chain on to the final destination view.\n * #\n * # Examples:\n * #\n * # To illustrate chain configuration, look at the /account/** mapping below.  This says\n * # &quot;apply the above 'authcBasic' filter to any request matching the '/account/**' pattern&quot;.  Since the\n * # 'authcBasic' filter does not need any path-specific config, it doesn't have any config brackets [].\n * #\n * # The /remoting/** definition on the other hand uses the 'roles' and 'perms' filters which do use\n * # bracket notation.  That definition says:\n * #\n * # &quot;To access /remoting/** urls, ensure that the user is first authenticated ('authcBasic'), then ensure that user\n * # has the 'b2bClient' role, and then finally ensure that they have the 'remote:invoke:lan,wan' permission.&quot;\n * #\n * # (Note that because elements within brackets [ ] are comma-delimited themselves, we needed to escape the permission\n * # actions of 'lan,wan' with quotes.  If we didn't do that, the permission filter would interpret\n * # the text between the brackets as two permissions: 'remote:invoke:lan' and 'wan' instead of the\n * # single desired 'remote:invoke:lan,wan' token.  So, you can use quotes wherever you need to escape internal\n * # commas.)\n * #\n * /account/** = <a href=\"#authcBasic\">authcBasic<\/a>\n * /remoting/** = <a href=\"#authcBasic\">authcBasic<\/a>, <a href=\"#roles\">roles<\/a>[b2bClient], <a href=\"#perms\">perms<\/a>[remote:invoke:\"lan,wan\"]\n * #\n * &lt;/param-value&gt;&lt;/init-param&gt;\n * &lt;/filter&gt;\n * #\n * #\n * &lt;filter-mapping&gt;\n * &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;\n * &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n * &lt;/filter-mapping&gt;<\/pre>\n * <p/>\n * <p/>\n * <b>Do not use this! It will be removed prior to 1.0 final!<\/b>\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @see IniShiroFilter\n * @since 0.1\n * @deprecated use {@link org.apache.shiro.web.servlet.IniShiroFilter} instead.\n *             <b>Will be removed prior to 1.0 final!<\/b>\n */\n@Deprecated\npublic class ShiroFilter extends OncePerRequestFilter {\n\n    //TODO - complete JavaDoc\n\n    public static final String CONFIG_CLASS_NAME_INIT_PARAM_NAME = \"configClassName\";\n    public static final String CONFIG_INIT_PARAM_NAME = \"config\";\n    public static final String CONFIG_URL_INIT_PARAM_NAME = \"configUrl\";\n\n    @SuppressWarnings({\"deprecation\"})\n    private static final Logger log = LoggerFactory.getLogger(ShiroFilter.class);\n\n    protected String config;\n    protected String configUrl;\n    protected String configClassName;\n    protected WebConfiguration configuration;\n\n    // Reference to the security manager used by this filter\n    protected WebSecurityManager securityManager;\n\n    // Used to determine which chain should handle an incoming request/response\n    private FilterChainResolver filterChainResolver;\n\n    public ShiroFilter() {\n        this.configClassName = IniWebConfiguration.class.getName();\n    }\n\n    public WebConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    public void setConfiguration(WebConfiguration configuration) {\n        this.configuration = configuration;\n    }\n\n    public WebSecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected void setSecurityManager(WebSecurityManager sm) {\n        this.securityManager = sm;\n    }\n\n    public FilterChainResolver getFilterChainResolver() {\n        return filterChainResolver;\n    }\n\n    public void setFilterChainResolver(FilterChainResolver filterChainResolver) {\n        this.filterChainResolver = filterChainResolver;\n    }\n\n    protected void onFilterConfigSet() throws Exception {\n        applyInitParams();\n        WebConfiguration config = configure();\n        setConfiguration(config);\n        ensureSecurityManager(config);\n        applyFilterChainResolver(config);\n    }\n\n    /**\n     * Ensures a SecurityManager exists, and if not, creates one automatically and ensures it is available for\n     * use during requests.\n     *\n     * @param config the configuration for this filter.\n     */\n    protected void ensureSecurityManager(Configuration config) {\n        WebSecurityManager securityManager = getSecurityManager();\n        boolean existing = securityManager != null;\n        if (!existing && config != null) {\n            // Get the configured security manager. If it isn't an implementation of\n            // WebSecurityManager, then we raise an error.\n            SecurityManager sm = config.getSecurityManager();\n            if (!(sm instanceof WebSecurityManager)) {\n                String msg = \"The configured security manager is not an instance of WebSecurityManager, so \" +\n                        \"it can not be used with the Shiro servlet filter.\";\n                throw new ConfigurationException(msg);\n            }\n            securityManager = (WebSecurityManager) sm;\n        }\n\n        // If the config doesn't return a security manager, build one by default.\n        if (securityManager == null) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Configuration instance [\" + config + \"] did not provide a SecurityManager.  No config \" +\n                        \"specified?  Defaulting to a \" + DefaultWebSecurityManager.class.getName() + \" instance...\");\n            }\n            securityManager = new DefaultWebSecurityManager();\n        }\n\n        if (!existing) {\n            setSecurityManager(securityManager);\n        }\n    }\n\n    protected void applyFilterChainResolver(WebConfiguration config) {\n        FilterChainResolver resolver = getFilterChainResolver();\n        if (resolver == null && config != null) {\n            resolver = config.getFilterChainResolver();\n            if (resolver != null) {\n                setFilterChainResolver(resolver);\n            }\n        }\n    }\n\n    protected void applyInitParams() {\n\n        String configCN = getInitParam(CONFIG_CLASS_NAME_INIT_PARAM_NAME);\n        if (configCN != null) {\n            if (ClassUtils.isAvailable(configCN)) {\n                this.configClassName = configCN;\n            } else {\n                String msg = \"configClassName fully qualified class name value [\" + configCN + \"] is not \" +\n                        \"available in the classpath.  Please ensure you have typed it correctly and the \" +\n                        \"corresponding class or jar is in the classpath.\";\n                throw new ConfigurationException(msg);\n            }\n        }\n\n        this.config = getInitParam(CONFIG_INIT_PARAM_NAME);\n        this.configUrl = getInitParam(CONFIG_URL_INIT_PARAM_NAME);\n    }\n\n    protected WebConfiguration configure() {\n        WebConfiguration webConfiguration = (WebConfiguration) ClassUtils.newInstance(this.configClassName);\n        applyFilterConfig(webConfiguration);\n        applyUrlConfig(webConfiguration);\n        applyEmbeddedConfig(webConfiguration);\n        LifecycleUtils.init(webConfiguration);\n        return webConfiguration;\n    }\n\n    protected void applyFilterConfig(WebConfiguration conf) {\n        if (log.isDebugEnabled()) {\n            String msg = \"Attempting to inject the FilterConfig (using 'setFilterConfig' method) into the \" +\n                    \"instantiated WebConfiguration for any wrapped Filter initialization...\";\n            log.debug(msg);\n        }\n        try {\n            PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"filterConfig\");\n            if (pd != null) {\n                PropertyUtils.setProperty(conf, \"filterConfig\", getFilterConfig());\n            }\n        } catch (Exception e) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Error setting FilterConfig on WebConfiguration instance.\", e);\n            }\n        }\n    }\n\n    protected void applyEmbeddedConfig(WebConfiguration conf) {\n        if (this.config != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"config\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"config\", this.config);\n                } else {\n                    String msg = \"The 'config' filter param was specified, but there is no \" +\n                            \"'setConfig(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                            \"not require the 'config' filter param, please comment it out, or if you do need it, \" +\n                            \"please ensure your Configuration class has a 'setConfig(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'config' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected void applyUrlConfig(WebConfiguration conf) {\n        if (this.configUrl != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"configUrl\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"configUrl\", this.configUrl);\n                } else {\n                    String msg = \"The 'configUrl' filter param was specified, but there is no \" +\n                            \"'setConfigUrl(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                            \"not require the 'configUrl' filter param, please comment it out, or if you do need it, \" +\n                            \"please ensure your Configuration class has a 'setConfigUrl(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'configUrl' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected boolean isHttpSessions() {\n        return getSecurityManager().isHttpSessionMode();\n    }\n\n    /**\n     * Wraps the original HttpServletRequest in a {@link ShiroHttpServletRequest}, which is required for supporting\n     * Servlet Specification behavior backed by a {@link org.apache.shiro.subject.Subject Subject} instance.\n     *\n     * @param orig the original Servlet Container-provided incoming {@code HttpServletRequest} instance.\n     * @return {@link ShiroHttpServletRequest ShiroHttpServletRequest} instance wrapping the original.\n     * @since 1.0\n     */\n    protected ServletRequest wrapServletRequest(HttpServletRequest orig) {\n        return new ShiroHttpServletRequest(orig, getServletContext(), isHttpSessions());\n    }\n\n    /**\n     * Prepares the {@code ServletRequest} instance that will be passed to the {@code FilterChain} for request\n     * processing.\n     * <p/>\n     * If the {@code ServletRequest} is an instance of {@link HttpServletRequest}, the value returned from this method\n     * is obtained by calling {@link #wrapServletRequest(javax.servlet.http.HttpServletRequest)} to allow Shiro-specific\n     * HTTP behavior, otherwise the original {@code ServletRequest} argument is returned.\n     *\n     * @param request  the incoming ServletRequest\n     * @param response the outgoing ServletResponse\n     * @param chain    the Servlet Container provided {@code FilterChain} that will receive the returned request.\n     * @return the {@code ServletRequest} instance that will be passed to the {@code FilterChain} for request processing.\n     * @since 1.0\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected ServletRequest prepareServletRequest(ServletRequest request, ServletResponse response, FilterChain chain) {\n        ServletRequest toUse = request;\n        if (request instanceof HttpServletRequest) {\n            HttpServletRequest http = (HttpServletRequest) request;\n            toUse = wrapServletRequest(http);\n        }\n        return toUse;\n    }\n\n    /**\n     * Returns a new {@link ShiroHttpServletResponse} instance, wrapping the {@code orig} argument, in order to provide\n     * correct URL rewriting behavior required by the Servlet Specification when using Shiro-based sessions (and not\n     * Servlet Container HTTP-based sessions).\n     *\n     * @param orig    the original {@code HttpServletResponse} instance provided by the Servlet Container.\n     * @param request the {@code ShiroHttpServletRequest} instance wrapping the original request.\n     * @return the wrapped ServletResponse instance to use during {@link FilterChain} execution.\n     * @since 1.0\n     */\n    protected ServletResponse wrapServletResponse(HttpServletResponse orig, ShiroHttpServletRequest request) {\n        return new ShiroHttpServletResponse(orig, getServletContext(), request);\n    }\n\n    /**\n     * Prepares the {@code ServletResponse} instance that will be passed to the {@code FilterChain} for request\n     * processing.\n     * <p/>\n     * This implementation delegates to {@link #wrapServletRequest(javax.servlet.http.HttpServletRequest)}\n     * only if Shiro-based sessions are enabled (that is, !{@link #isHttpSessions()}) and the request instance is a\n     * {@link ShiroHttpServletRequest}.  This ensures that any URL rewriting that occurs is handled correctly using the\n     * Shiro-managed Session's sessionId and not a servlet container session ID.\n     * <p/>\n     * If HTTP-based sessions are enabled (the default), then this method does nothing and just returns the\n     * {@code ServletResponse} argument as-is, relying on the default Servlet Container URL rewriting logic.\n     *\n     * @param request  the incoming ServletRequest\n     * @param response the outgoing ServletResponse\n     * @param chain    the Servlet Container provided {@code FilterChain} that will receive the returned request.\n     * @return the {@code ServletResponse} instance that will be passed to the {@code FilterChain} during request processing.\n     * @since 1.0\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected ServletResponse prepareServletResponse(ServletRequest request, ServletResponse response, FilterChain chain) {\n        ServletResponse toUse = response;\n        if (!isHttpSessions() && (request instanceof ShiroHttpServletRequest) &&\n                (response instanceof HttpServletResponse)) {\n            //the ShiroHttpServletResponse exists to support URL rewriting for session ids.  This is only needed if\n            //using Shiro sessions (i.e. not simple HttpSession based sessions):\n            toUse = wrapServletResponse((HttpServletResponse) response, (ShiroHttpServletRequest) request);\n        }\n        return toUse;\n    }\n\n    /**\n     * Binds the current request/response pair and additional information to a thread-local to be made available to Shiro\n     * during the course of the request/response process.  This implementation binds the request/response pair and\n     * any associated Subject (and its relevant thread-based data) via a {@link org.apache.shiro.web.subject.support.WebSubjectThreadState}.  That\n     * threadState is returned so it can be used during thread cleanup at the end of the request.\n     * <p/>\n     * To guarantee properly cleaned threads in a thread-pooled Servlet Container environment, the corresponding\n     * {@link #unbind} method must be called in a {@code finally} block to ensure that the thread remains clean even\n     * in the event of an exception thrown while processing the request.  This class's\n     * {@link #doFilterInternal(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)}\n     * method implementation does indeed function this way.\n     *\n     * @param request  the incoming ServletRequest\n     * @param response the outgoing ServletResponse\n     * @return ThreadStateManager the thread state used to bind necessary state for the request execution.\n     * @since 1.0\n     */\n    protected ThreadState bind(ServletRequest request, ServletResponse response) {\n        SecurityManager securityManager = getSecurityManager();\n        ThreadContext.bind(securityManager);\n        //currently the WebRememberMeManager needs the request/response bound in order to create the subject instance:\n        WebUtils.bind(request);\n        WebUtils.bind(response);\n\n        WebSubject subject = new WebSubject.Builder(securityManager, request, response).buildWebSubject();\n        ThreadState threadState = new WebSubjectThreadState(subject);\n        threadState.bind();\n        return threadState;\n    }\n\n    /**\n     * Unbinds (removes out of scope) the current {@code ServletRequest} and {@link ServletResponse}.\n     * <p/>\n     * This method implementation merely clears <em>all<\/em> thread state by calling\n     * {@link org.apache.shiro.subject.support.SubjectThreadState#clear()} to guarantee\n     * that <em>everything<\/em> that might have been bound to the thread by Shiro has been removed to ensure the\n     * underlying Thread may be safely re-used in a thread-pooled Servlet Container environment.\n     *\n     * @param threadState the web thread state created when the request and response first were initiated.\n     * @since 1.0\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected void unbind(ThreadState threadState) {\n        threadState.clear();\n    }\n\n    /**\n     * Updates any 'native'  Session's last access time that might exist to the timestamp when this method is called.\n     * If native sessions are not enabled (that is, standard Servlet container sessions are being used) or there is no\n     * session ({@code subject.getSession(false) == null}), this method does nothing.\n     * <p/>This method implementation merely calls\n     * <code>Session.{@link org.apache.shiro.session.Session#touch() touch}()<\/code> on the session.\n     *\n     * @param request  incoming request - ignored, but available to subclasses that might wish to override this method\n     * @param response outgoing response - ignored, but available to subclasses that might wish to override this method\n     * @since 1.0\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected void updateSessionLastAccessTime(ServletRequest request, ServletResponse response) {\n        if (!isHttpSessions()) { //'native' sessions\n            Subject subject = SecurityUtils.getSubject();\n            //Subject should never _ever_ be null, but just in case:\n            if (subject != null) {\n                Session session = subject.getSession(false);\n                if (session != null) {\n                    try {\n                        session.touch();\n                    } catch (Throwable t) {\n                        log.error(\"session.touch() method invocation has failed.  Unable to update\" +\n                                \"the corresponding session's last access time based on the incoming request.\", t);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * {@code doFilterInternal} implementation that sets-up, executes, and cleans-up a Shiro-filtered request.  It\n     * performs the following ordered operations:\n     * <ol>\n     * <li>{@link #prepareServletRequest(ServletRequest, ServletResponse, FilterChain) Prepares}\n     * the incoming {@code ServletRequest} for use during Shiro's processing<\/li>\n     * <li>{@link #prepareServletResponse(ServletRequest, ServletResponse, FilterChain) Prepares}\n     * the outgoing {@code ServletResponse} for use during Shiro's processing<\/li>\n     * <li>{@link #bind(ServletRequest,ServletResponse) Binds} the request/response pair\n     * and associated data to the currently executing thread for use during processing<\/li>\n     * <li>{@link #updateSessionLastAccessTime(javax.servlet.ServletRequest, javax.servlet.ServletResponse) Updates}\n     * any associated session's {@link org.apache.shiro.session.Session#getLastAccessTime() lastAccessTime} to ensure\n     * session timeouts are honored<\/li>\n     * <li>{@link #executeChain(ServletRequest,ServletResponse,FilterChain) Executes}\n     * the appropriate {@code FilterChain}<\/li>\n     * <li>{@link #unbind(org.apache.shiro.util.ThreadState) Unbinds} the request/response\n     * pair and any other associated data from the thread.\n     * <\/ul>\n     * <p/>\n     * The {@link #unbind(org.apache.shiro.util.ThreadState) unbind} method is called in a\n     * {@code finally} block to guarantee the thread may be cleanly re-used in a thread-pooled Servlet Container\n     * environment.\n     *\n     * @param servletRequest  the incoming {@code ServletRequest}\n     * @param servletResponse the outgoing {@code ServletResponse}\n     * @param chain           the container-provided {@code FilterChain} to execute\n     * @throws ServletException if an error occurs\n     * @throws IOException      if an IO error occurs\n     */\n    protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)\n            throws ServletException, IOException {\n\n        ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain);\n        ServletResponse response = prepareServletResponse(request, servletResponse, chain);\n\n        ThreadState threadState = bind(request, response);\n\n        try {\n            updateSessionLastAccessTime(request, response);\n            executeChain(request, response, chain);\n        } finally {\n            unbind(threadState);\n        }\n    }\n\n    /**\n     * Returns the {@code FilterChain} to execute for the given request.\n     * <p/>\n     * The {@code origChain} argument is the\n     * original {@code FilterChain} supplied by the Servlet Container, but it may be modified to provide\n     * more behavior by pre-pending further chains according to the Shiro configuration.\n     * <p/>\n     * This implementation returns the chain that will actually be executed by acquiring the chain from a\n     * {@link #getFilterChainResolver() filterChainResolver}.  The resolver determines exactly which chain to\n     * execute, typically based on URL configuration.  If no chain is returned from the resolver call\n     * (returns {@code null}), then the {@code origChain} will be returned by default.\n     *\n     * @param request   the incoming ServletRequest\n     * @param response  the outgoing ServletResponse\n     * @param origChain the original {@code FilterChain} provided by the Servlet Container\n     * @return the {@link FilterChain} to execute for the given request\n     * @since 1.0\n     */\n    protected FilterChain getExecutionChain(ServletRequest request, ServletResponse response, FilterChain origChain) {\n        FilterChain chain = origChain;\n        FilterChain resolved = null;\n        FilterChainResolver resolver = getFilterChainResolver();\n        if (resolver != null) {\n            resolved = resolver.getChain(request, response, origChain);\n        } else {\n            log.trace(\"No FilterChainResolver configured.  Attempting (deprecated) WebConfiguration resolution.\");\n            WebConfiguration config = getConfiguration();\n            if (config != null) {\n                //noinspection deprecation\n                resolved = config.getChain(request, response, origChain);\n            }\n        }\n        if (resolved != null) {\n            log.trace(\"Resolved a configured FilterChain for the current request.\");\n            chain = resolved;\n        } else {\n            log.trace(\"No FilterChain configured for the current request.  Using the default.\");\n        }\n\n        return chain;\n    }\n\n    /**\n     * Executes a {@link FilterChain} for the given request.\n     * <p/>\n     * This implementation first delegates to\n     * <code>{@link #getExecutionChain(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain) getExecutionChain}<\/code>\n     * to allow the application's Shiro configuration to determine exactly how the chain should execute.  The resulting\n     * value from that call is then executed directly by calling the returned {@code FilterChain}'s\n     * {@link FilterChain#doFilter doFilter} method.  That is:\n     * <pre>\n     * FilterChain chain = {@link #getExecutionChain}(request, response, origChain);\n     * chain.{@link FilterChain#doFilter doFilter}(request,response);<\/pre>\n     *\n     * @param request   the incoming ServletRequest\n     * @param response  the outgoing ServletResponse\n     * @param origChain the Servlet Container-provided chain that may be wrapped further by an application-configured\n     *                  chain of Filters.\n     * @throws IOException      if the underlying {@code chain.doFilter} call results in an IOException\n     * @throws ServletException if the underlying {@code chain.doFilter} call results in a ServletException\n     * @since 1.0\n     */\n    protected void executeChain(ServletRequest request, ServletResponse response, FilterChain origChain)\n            throws IOException, ServletException {\n        FilterChain chain = getExecutionChain(request, response, origChain);\n        chain.doFilter(request, response);\n    }\n\n    /**\n     * Destroys this Filter by destroying the {@link #getConfiguration() configuration} object.\n     */\n    public void destroy() {\n        LifecycleUtils.destroy(getConfiguration());\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.servlet;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.config.Configuration;\nimport org.apache.shiro.config.ConfigurationException;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.util.ClassUtils;\nimport org.apache.shiro.util.LifecycleUtils;\nimport org.apache.shiro.util.ThreadContext;\nimport org.apache.shiro.util.ThreadState;\nimport org.apache.shiro.web.DefaultWebSecurityManager;\nimport org.apache.shiro.web.WebSecurityManager;\nimport org.apache.shiro.web.WebUtils;\nimport org.apache.shiro.web.config.IniWebConfiguration;\nimport org.apache.shiro.web.config.WebConfiguration;\nimport org.apache.shiro.web.filter.mgt.FilterChainResolver;\nimport org.apache.shiro.web.subject.WebSubject;\nimport org.apache.shiro.web.subject.support.WebSubjectThreadState;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.beans.PropertyDescriptor;\nimport java.io.IOException;\n\n/**\n * Main ServletFilter that configures and enables all Shiro functions within a web application.\n * <p/>\n * The following is a fully commented example that documents how to configure it:\n * <pre>&lt;filter&gt;\n * &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;\n * &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt;\n * &lt;init-param&gt;&lt;param-name&gt;config&lt;/param-name&gt;&lt;param-value&gt;\n * #\n * #NOTE:  This config looks pretty long - but its not - its only a few lines of actual config.\n * #       Everything else is just heavily commented to explain things in-depth. Feel free to delete any\n * #       comments that you don't want to read from your own configuration ;)\n * #\n * # Any commented values below that _don't_ start with 'example.pkg' are Shiro's defaults.  If you want to change any\n * # values on those lines, you only need to uncomment the lines you want to change.\n * #\n * [main]\n * # The 'main' section defines Shiro-wide configuration.\n * #\n * # The configuration is essentially an object graph definition in a .properties style format.  The beans defined\n * # would be those that are used to construct the application's SecurityManager.  It is essentially 'poor man's'\n * # dependency injection via a .properties format.\n * #\n * # --- Defining Realms ---\n * #\n * # Any Realm defined here will automatically be injected into Shiro's default SecurityManager created at start up.\n * # For example:\n * #\n * # myRealm = example.pkg.security.MyRealm\n * #\n * # This would instantiate the some.pkg.security.MyRealm class with a default no-arg constructor and inject it into\n * # the SecurityManager.  More than one realm can be defined if needed.  You can create graphs and reference\n * # other beans ('$' bean reference notation) while defining Realms and other objects:\n * #\n * # <b>connectionFactory<\/b> = example.pkg.ConnectionFactory\n * # connectionFactory.driverClassName = a.jdbc.Driver\n * # connectionFactory.username = aUsername\n * # connectionFactory.password = aPassword\n * # connectionFactory.minConnections = 3\n * # connectionFactory.maxConnections = 10\n * # ... etc...\n * #\n * # myJdbcRealm = example.pkg.jdbc.MyJdbcRealm\n * # myJdbcRealm.connectionFactory = <b>$connectionFactory<\/b>\n * # ... etc ...\n * #\n * # --- Realm Factories ---\n * #\n * # If the .properties style isn't robust enough for your needs, you also have the option of implementing the\n * # {@link org.apache.shiro.realm.RealmFactory org.apache.shiro.realm.RealmFactory} interface with more complex construction\n * # logic.  Then you can declare the implementation here instead.  The realms it returns will be injected in to the\n * # SecurityManager just as the individual Realms are.  For example:\n * #\n * # aRealmFactory = some.pkg.ClassThatImplementsRealmFactory\n * #\n * # --- SessionManager properties ---\n * #\n * # Except for Realms and RealmFactories, all other objects should be defined and set on the SecurityManager directly.\n * # The default 'securityManager' bean is an instance of {@link org.apache.shiro.web.DefaultWebSecurityManager}, so you\n * # can set any of its corresponding properties as necessary:\n * #\n * # someObject = some.fully.qualified.ClassName\n * # someObject.propertyN = foo\n * # ...\n * # securityManager.someObject = $someObject\n * #\n * # For example, if you wanted to change Shiro's default session mechanism, you can change the 'sessionMode' property.\n * # By default, Shiro's Session infrastructure in a web environment will use the\n * # Servlet container's HttpSession.  However, if you need to share session state across client types\n * # (e.g. Web MVC plus Java Web Start or Flash), or are doing distributed/shared Sessions for\n * # Single Sign On, HttpSessions aren't good enough.  You'll need to use Shiro's more powerful\n * # (and client-agnostic) session management.  You can enable this by uncommenting the following line\n * # and changing 'http' to 'native'\n * #\n * #securityManager.{@link org.apache.shiro.web.DefaultWebSecurityManager#setSessionMode(String) sessionMode} = http\n * #\n * [filters]\n * # This section defines the 'pool' of all Filters available to the url path definitions in the [urls] section below.\n * #\n * # The following commented values are already provided by Shiro by default and are immediately usable\n * # in the [urls] definitions below.  If you like, you may override any values by uncommenting only the lines\n * # you need to change.\n * #\n * # Each Filter is configured based on its functionality and/or protocol.  You should read each\n * # Filter's JavaDoc to fully understand what each does and how it works as well as how it would\n * # affect the user experience.\n * #\n * # Form-based Authentication filter:\n * #<a name=\"authc\"><\/a>authc = {@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter}\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setLoginUrl(String) loginUrl} = /login.jsp\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setUsernameParam(String) usernameParam} = username\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setPasswordParam(String) passwordParam} = password\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setRememberMeParam(String) rememberMeParam} = rememberMe\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setSuccessUrl(String) successUrl}  = /login.jsp\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setFailureKeyAttribute(String) failureKeyAttribute} = {@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#DEFAULT_ERROR_KEY_ATTRIBUTE_NAME}\n * #\n * # Http BASIC Authentication filter:\n * #<a name=\"authcBasic\"><\/a>authcBasic = {@link org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter}\n * #authcBasic.{@link org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter#setApplicationName(String) applicationName} = application\n * #\n * # Roles filter: requires the requesting user to have one or more roles for the request to continue.\n * # If they do not have the specified roles, they are redirected to the specified URL.\n * #<a name=\"roles\"><\/a>roles = {@link org.apache.shiro.web.filter.authz.RolesAuthorizationFilter}\n * #roles.{@link org.apache.shiro.web.filter.authz.RolesAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.\n * #\n * # Permissions filter: requires the requesting user to have one or more permissions for the request to\n * # continue, and if they do not, redirects them to the specified URL.\n * #<a name=\"perms\"><\/a>perms = {@link org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter}\n * #perms.{@link org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.  Many\n * # applications like to use the same url specified in roles.unauthorizedUrl above.\n * #\n * #\n * # Define your own filters here as you would any other object as described in the '[main]' section above (properties,\n * # $references, etc).  To properly handle url path matching (see the [urls] section below), your\n * # filter should extend the {@link org.apache.shiro.web.filter.PathMatchingFilter PathMatchingFilter} abstract class.\n * #\n * [urls]\n * # This section defines url path mappings.  Each mapping entry must be on a single line and conform to the\n * # following representation:\n * #\n * # ant_path_expression = path_specific_filter_chain_definition\n * #\n * # For any request that matches a specified path, the corresponding value defines a comma-delimited chain of\n * # filters to execute for that request.\n * #\n * # This is incredibly powerful in that you can define arbitrary filter chains for any given request pattern\n * # to greatly customize the security experience.\n * #\n * # The path_specific_filter_chain_definition must match the following format:\n * #\n * # filter1[optional_config1], filter2[optional_config2], ..., filterN[optional_configN]\n * #\n * # where 'filterN' is the name of an filter defined above in the [filters] section and\n * # '[optional_configN]' is an optional bracketed string that has meaning for that particular filter for\n * # _that particular path_.  If the filter does not need specific config for that url path, you may\n * # discard the brackets - that is, filterN[] just becomes filterN.\n * #\n * # And because filter tokens define chains, order matters!  Define the tokens for each path pattern\n * # in the order you want them to filter (comma-delimited).\n * #\n * # Finally, each filter is free to handle the response however it wants if its necessary\n * # conditions are not met (redirect, HTTP error code, direct rendering, etc).  Otherwise, it is expected to allow\n * # the request to continue through the chain on to the final destination view.\n * #\n * # Examples:\n * #\n * # To illustrate chain configuration, look at the /account/** mapping below.  This says\n * # &quot;apply the above 'authcBasic' filter to any request matching the '/account/**' pattern&quot;.  Since the\n * # 'authcBasic' filter does not need any path-specific config, it doesn't have any config brackets [].\n * #\n * # The /remoting/** definition on the other hand uses the 'roles' and 'perms' filters which do use\n * # bracket notation.  That definition says:\n * #\n * # &quot;To access /remoting/** urls, ensure that the user is first authenticated ('authcBasic'), then ensure that user\n * # has the 'b2bClient' role, and then finally ensure that they have the 'remote:invoke:lan,wan' permission.&quot;\n * #\n * # (Note that because elements within brackets [ ] are comma-delimited themselves, we needed to escape the permission\n * # actions of 'lan,wan' with quotes.  If we didn't do that, the permission filter would interpret\n * # the text between the brackets as two permissions: 'remote:invoke:lan' and 'wan' instead of the\n * # single desired 'remote:invoke:lan,wan' token.  So, you can use quotes wherever you need to escape internal\n * # commas.)\n * #\n * /account/** = <a href=\"#authcBasic\">authcBasic<\/a>\n * /remoting/** = <a href=\"#authcBasic\">authcBasic<\/a>, <a href=\"#roles\">roles<\/a>[b2bClient], <a href=\"#perms\">perms<\/a>[remote:invoke:\"lan,wan\"]\n * #\n * &lt;/param-value&gt;&lt;/init-param&gt;\n * &lt;/filter&gt;\n * #\n * #\n * &lt;filter-mapping&gt;\n * &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;\n * &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n * &lt;/filter-mapping&gt;<\/pre>\n * <p/>\n * <p/>\n * <b>Do not use this! It will be removed prior to 1.0 final!<\/b>\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @see IniShiroFilter\n * @since 0.1\n * @deprecated use {@link org.apache.shiro.web.servlet.IniShiroFilter} instead.\n *             <b>Will be removed prior to 1.0 final!<\/b>\n */\n@Deprecated\npublic class ShiroFilter extends OncePerRequestFilter {\n\n    //TODO - complete JavaDoc\n\n    public static final String CONFIG_CLASS_NAME_INIT_PARAM_NAME = \"configClassName\";\n    public static final String CONFIG_INIT_PARAM_NAME = \"config\";\n    public static final String CONFIG_URL_INIT_PARAM_NAME = \"configUrl\";\n\n    @SuppressWarnings({\"deprecation\"})\n    private static final Logger log = LoggerFactory.getLogger(ShiroFilter.class);\n\n    protected String config;\n    protected String configUrl;\n    protected String configClassName;\n    protected WebConfiguration configuration;\n\n    // Reference to the security manager used by this filter\n    protected WebSecurityManager securityManager;\n\n    // Used to determine which chain should handle an incoming request/response\n    private FilterChainResolver filterChainResolver;\n\n    public ShiroFilter() {\n        this.configClassName = IniWebConfiguration.class.getName();\n    }\n\n    public WebConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    public void setConfiguration(WebConfiguration configuration) {\n        this.configuration = configuration;\n    }\n\n    public WebSecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected void setSecurityManager(WebSecurityManager sm) {\n        this.securityManager = sm;\n    }\n\n    public FilterChainResolver getFilterChainResolver() {\n        return filterChainResolver;\n    }\n\n    public void setFilterChainResolver(FilterChainResolver filterChainResolver) {\n        this.filterChainResolver = filterChainResolver;\n    }\n\n    protected void onFilterConfigSet() throws Exception {\n        applyInitParams();\n        WebConfiguration config = configure();\n        setConfiguration(config);\n        ensureSecurityManager(config);\n        applyFilterChainResolver(config);\n    }\n\n    /**\n     * Ensures a SecurityManager exists, and if not, creates one automatically and ensures it is available for\n     * use during requests.\n     *\n     * @param config the configuration for this filter.\n     */\n    protected void ensureSecurityManager(Configuration config) {\n        WebSecurityManager securityManager = getSecurityManager();\n        boolean existing = securityManager != null;\n        if (!existing && config != null) {\n            // Get the configured security manager. If it isn't an implementation of\n            // WebSecurityManager, then we raise an error.\n            SecurityManager sm = config.getSecurityManager();\n            if (!(sm instanceof WebSecurityManager)) {\n                String msg = \"The configured security manager is not an instance of WebSecurityManager, so \" +\n                        \"it can not be used with the Shiro servlet filter.\";\n                throw new ConfigurationException(msg);\n            }\n            securityManager = (WebSecurityManager) sm;\n        }\n\n        // If the config doesn't return a security manager, build one by default.\n        if (securityManager == null) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Configuration instance [\" + config + \"] did not provide a SecurityManager.  No config \" +\n                        \"specified?  Defaulting to a \" + DefaultWebSecurityManager.class.getName() + \" instance...\");\n            }\n            securityManager = new DefaultWebSecurityManager();\n        }\n\n        if (!existing) {\n            setSecurityManager(securityManager);\n        }\n    }\n\n    protected void applyFilterChainResolver(WebConfiguration config) {\n        FilterChainResolver resolver = getFilterChainResolver();\n        if (resolver == null && config != null) {\n            resolver = config.getFilterChainResolver();\n            if (resolver != null) {\n                setFilterChainResolver(resolver);\n            }\n        }\n    }\n\n    protected void applyInitParams() {\n\n        String configCN = getInitParam(CONFIG_CLASS_NAME_INIT_PARAM_NAME);\n        if (configCN != null) {\n            if (ClassUtils.isAvailable(configCN)) {\n                this.configClassName = configCN;\n            } else {\n                String msg = \"configClassName fully qualified class name value [\" + configCN + \"] is not \" +\n                        \"available in the classpath.  Please ensure you have typed it correctly and the \" +\n                        \"corresponding class or jar is in the classpath.\";\n                throw new ConfigurationException(msg);\n            }\n        }\n\n        this.config = getInitParam(CONFIG_INIT_PARAM_NAME);\n        this.configUrl = getInitParam(CONFIG_URL_INIT_PARAM_NAME);\n    }\n\n    protected WebConfiguration configure() {\n        WebConfiguration webConfiguration = (WebConfiguration) ClassUtils.newInstance(this.configClassName);\n        applyFilterConfig(webConfiguration);\n        applyUrlConfig(webConfiguration);\n        applyEmbeddedConfig(webConfiguration);\n        LifecycleUtils.init(webConfiguration);\n        return webConfiguration;\n    }\n\n    protected void applyFilterConfig(WebConfiguration conf) {\n        if (log.isDebugEnabled()) {\n            String msg = \"Attempting to inject the FilterConfig (using 'setFilterConfig' method) into the \" +\n                    \"instantiated WebConfiguration for any wrapped Filter initialization...\";\n            log.debug(msg);\n        }\n        try {\n            PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"filterConfig\");\n            if (pd != null) {\n                PropertyUtils.setProperty(conf, \"filterConfig\", getFilterConfig());\n            }\n        } catch (Exception e) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Error setting FilterConfig on WebConfiguration instance.\", e);\n            }\n        }\n    }\n\n    protected void applyEmbeddedConfig(WebConfiguration conf) {\n        if (this.config != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"config\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"config\", this.config);\n                } else {\n                    String msg = \"The 'config' filter param was specified, but there is no \" +\n                            \"'setConfig(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                            \"not require the 'config' filter param, please comment it out, or if you do need it, \" +\n                            \"please ensure your Configuration class has a 'setConfig(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'config' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected void applyUrlConfig(WebConfiguration conf) {\n        if (this.configUrl != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"configUrl\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"configUrl\", this.configUrl);\n                } else {\n                    String msg = \"The 'configUrl' filter param was specified, but there is no \" +\n                            \"'setConfigUrl(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                            \"not require the 'configUrl' filter param, please comment it out, or if you do need it, \" +\n                            \"please ensure your Configuration class has a 'setConfigUrl(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'configUrl' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected boolean isHttpSessions() {\n        return getSecurityManager().isHttpSessionMode();\n    }\n\n    /**\n     * Wraps the original HttpServletRequest in a {@link ShiroHttpServletRequest}, which is required for supporting\n     * Servlet Specification behavior backed by a {@link org.apache.shiro.subject.Subject Subject} instance.\n     *\n     * @param orig the original Servlet Container-provided incoming {@code HttpServletRequest} instance.\n     * @return {@link ShiroHttpServletRequest ShiroHttpServletRequest} instance wrapping the original.\n     * @since 1.0\n     */\n    protected ServletRequest wrapServletRequest(HttpServletRequest orig) {\n        return new ShiroHttpServletRequest(orig, getServletContext(), isHttpSessions());\n    }\n\n    /**\n     * Prepares the {@code ServletRequest} instance that will be passed to the {@code FilterChain} for request\n     * processing.\n     * <p/>\n     * If the {@code ServletRequest} is an instance of {@link HttpServletRequest}, the value returned from this method\n     * is obtained by calling {@link #wrapServletRequest(javax.servlet.http.HttpServletRequest)} to allow Shiro-specific\n     * HTTP behavior, otherwise the original {@code ServletRequest} argument is returned.\n     *\n     * @param request  the incoming ServletRequest\n     * @param response the outgoing ServletResponse\n     * @param chain    the Servlet Container provided {@code FilterChain} that will receive the returned request.\n     * @return the {@code ServletRequest} instance that will be passed to the {@code FilterChain} for request processing.\n     * @since 1.0\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected ServletRequest prepareServletRequest(ServletRequest request, ServletResponse response, FilterChain chain) {\n        ServletRequest toUse = request;\n        if (request instanceof HttpServletRequest) {\n            HttpServletRequest http = (HttpServletRequest) request;\n            toUse = wrapServletRequest(http);\n        }\n        return toUse;\n    }\n\n    /**\n     * Returns a new {@link ShiroHttpServletResponse} instance, wrapping the {@code orig} argument, in order to provide\n     * correct URL rewriting behavior required by the Servlet Specification when using Shiro-based sessions (and not\n     * Servlet Container HTTP-based sessions).\n     *\n     * @param orig    the original {@code HttpServletResponse} instance provided by the Servlet Container.\n     * @param request the {@code ShiroHttpServletRequest} instance wrapping the original request.\n     * @return the wrapped ServletResponse instance to use during {@link FilterChain} execution.\n     * @since 1.0\n     */\n    protected ServletResponse wrapServletResponse(HttpServletResponse orig, ShiroHttpServletRequest request) {\n        return new ShiroHttpServletResponse(orig, getServletContext(), request);\n    }\n\n    /**\n     * Prepares the {@code ServletResponse} instance that will be passed to the {@code FilterChain} for request\n     * processing.\n     * <p/>\n     * This implementation delegates to {@link #wrapServletRequest(javax.servlet.http.HttpServletRequest)}\n     * only if Shiro-based sessions are enabled (that is, !{@link #isHttpSessions()}) and the request instance is a\n     * {@link ShiroHttpServletRequest}.  This ensures that any URL rewriting that occurs is handled correctly using the\n     * Shiro-managed Session's sessionId and not a servlet container session ID.\n     * <p/>\n     * If HTTP-based sessions are enabled (the default), then this method does nothing and just returns the\n     * {@code ServletResponse} argument as-is, relying on the default Servlet Container URL rewriting logic.\n     *\n     * @param request  the incoming ServletRequest\n     * @param response the outgoing ServletResponse\n     * @param chain    the Servlet Container provided {@code FilterChain} that will receive the returned request.\n     * @return the {@code ServletResponse} instance that will be passed to the {@code FilterChain} during request processing.\n     * @since 1.0\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected ServletResponse prepareServletResponse(ServletRequest request, ServletResponse response, FilterChain chain) {\n        ServletResponse toUse = response;\n        if (!isHttpSessions() && (request instanceof ShiroHttpServletRequest) &&\n                (response instanceof HttpServletResponse)) {\n            //the ShiroHttpServletResponse exists to support URL rewriting for session ids.  This is only needed if\n            //using Shiro sessions (i.e. not simple HttpSession based sessions):\n            toUse = wrapServletResponse((HttpServletResponse) response, (ShiroHttpServletRequest) request);\n        }\n        return toUse;\n    }\n\n    /**\n     * Binds the current request/response pair and additional information to a thread-local to be made available to Shiro\n     * during the course of the request/response process.  This implementation binds the request/response pair and\n     * any associated Subject (and its relevant thread-based data) via a {@link org.apache.shiro.web.subject.support.WebSubjectThreadState}.  That\n     * threadState is returned so it can be used during thread cleanup at the end of the request.\n     * <p/>\n     * To guarantee properly cleaned threads in a thread-pooled Servlet Container environment, the corresponding\n     * {@link #unbind} method must be called in a {@code finally} block to ensure that the thread remains clean even\n     * in the event of an exception thrown while processing the request.  This class's\n     * {@link #doFilterInternal(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)}\n     * method implementation does indeed function this way.\n     *\n     * @param request  the incoming ServletRequest\n     * @param response the outgoing ServletResponse\n     * @return ThreadStateManager the thread state used to bind necessary state for the request execution.\n     * @since 1.0\n     */\n    protected ThreadState bind(ServletRequest request, ServletResponse response) {\n        ThreadContext.bind(getSecurityManager());\n        //currently the WebRememberMeManager needs the request/response bound in order to create the subject instance:\n        WebUtils.bind(request);\n        WebUtils.bind(response);\n\n        WebSubject subject = new WebSubject.Builder().buildWebSubject();\n        ThreadState threadState = new WebSubjectThreadState(subject);\n        threadState.bind();\n        return threadState;\n    }\n\n    /**\n     * Unbinds (removes out of scope) the current {@code ServletRequest} and {@link ServletResponse}.\n     * <p/>\n     * This method implementation merely clears <em>all<\/em> thread state by calling\n     * {@link org.apache.shiro.subject.support.SubjectThreadState#clear()} to guarantee\n     * that <em>everything<\/em> that might have been bound to the thread by Shiro has been removed to ensure the\n     * underlying Thread may be safely re-used in a thread-pooled Servlet Container environment.\n     *\n     * @param threadState the web thread state created when the request and response first were initiated.\n     * @since 1.0\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected void unbind(ThreadState threadState) {\n        threadState.clear();\n    }\n\n    /**\n     * Updates any 'native'  Session's last access time that might exist to the timestamp when this method is called.\n     * If native sessions are not enabled (that is, standard Servlet container sessions are being used) or there is no\n     * session ({@code subject.getSession(false) == null}), this method does nothing.\n     * <p/>This method implementation merely calls\n     * <code>Session.{@link org.apache.shiro.session.Session#touch() touch}()<\/code> on the session.\n     *\n     * @param request  incoming request - ignored, but available to subclasses that might wish to override this method\n     * @param response outgoing response - ignored, but available to subclasses that might wish to override this method\n     * @since 1.0\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected void updateSessionLastAccessTime(ServletRequest request, ServletResponse response) {\n        if (!isHttpSessions()) { //'native' sessions\n            Subject subject = SecurityUtils.getSubject();\n            //Subject should never _ever_ be null, but just in case:\n            if (subject != null) {\n                Session session = subject.getSession(false);\n                if (session != null) {\n                    try {\n                        session.touch();\n                    } catch (Throwable t) {\n                        log.error(\"session.touch() method invocation has failed.  Unable to update\" +\n                                \"the corresponding session's last access time based on the incoming request.\", t);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * {@code doFilterInternal} implementation that sets-up, executes, and cleans-up a Shiro-filtered request.  It\n     * performs the following ordered operations:\n     * <ol>\n     * <li>{@link #prepareServletRequest(ServletRequest, ServletResponse, FilterChain) Prepares}\n     * the incoming {@code ServletRequest} for use during Shiro's processing<\/li>\n     * <li>{@link #prepareServletResponse(ServletRequest, ServletResponse, FilterChain) Prepares}\n     * the outgoing {@code ServletResponse} for use during Shiro's processing<\/li>\n     * <li>{@link #bind(ServletRequest,ServletResponse) Binds} the request/response pair\n     * and associated data to the currently executing thread for use during processing<\/li>\n     * <li>{@link #updateSessionLastAccessTime(javax.servlet.ServletRequest, javax.servlet.ServletResponse) Updates}\n     * any associated session's {@link org.apache.shiro.session.Session#getLastAccessTime() lastAccessTime} to ensure\n     * session timeouts are honored<\/li>\n     * <li>{@link #executeChain(ServletRequest,ServletResponse,FilterChain) Executes}\n     * the appropriate {@code FilterChain}<\/li>\n     * <li>{@link #unbind(org.apache.shiro.util.ThreadState) Unbinds} the request/response\n     * pair and any other associated data from the thread.\n     * <\/ul>\n     * <p/>\n     * The {@link #unbind(org.apache.shiro.util.ThreadState) unbind} method is called in a\n     * {@code finally} block to guarantee the thread may be cleanly re-used in a thread-pooled Servlet Container\n     * environment.\n     *\n     * @param servletRequest  the incoming {@code ServletRequest}\n     * @param servletResponse the outgoing {@code ServletResponse}\n     * @param chain           the container-provided {@code FilterChain} to execute\n     * @throws ServletException if an error occurs\n     * @throws IOException      if an IO error occurs\n     */\n    protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)\n            throws ServletException, IOException {\n\n        ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain);\n        ServletResponse response = prepareServletResponse(request, servletResponse, chain);\n\n        ThreadState threadState = bind(request, response);\n\n        try {\n            updateSessionLastAccessTime(request, response);\n            executeChain(request, response, chain);\n        } finally {\n            unbind(threadState);\n        }\n    }\n\n    /**\n     * Returns the {@code FilterChain} to execute for the given request.\n     * <p/>\n     * The {@code origChain} argument is the\n     * original {@code FilterChain} supplied by the Servlet Container, but it may be modified to provide\n     * more behavior by pre-pending further chains according to the Shiro configuration.\n     * <p/>\n     * This implementation returns the chain that will actually be executed by acquiring the chain from a\n     * {@link #getFilterChainResolver() filterChainResolver}.  The resolver determines exactly which chain to\n     * execute, typically based on URL configuration.  If no chain is returned from the resolver call\n     * (returns {@code null}), then the {@code origChain} will be returned by default.\n     *\n     * @param request   the incoming ServletRequest\n     * @param response  the outgoing ServletResponse\n     * @param origChain the original {@code FilterChain} provided by the Servlet Container\n     * @return the {@link FilterChain} to execute for the given request\n     * @since 1.0\n     */\n    protected FilterChain getExecutionChain(ServletRequest request, ServletResponse response, FilterChain origChain) {\n        FilterChain chain = origChain;\n        FilterChain resolved = null;\n        FilterChainResolver resolver = getFilterChainResolver();\n        if (resolver != null) {\n            resolved = resolver.getChain(request, response, origChain);\n        } else {\n            log.trace(\"No FilterChainResolver configured.  Attempting (deprecated) WebConfiguration resolution.\");\n            WebConfiguration config = getConfiguration();\n            if (config != null) {\n                //noinspection deprecation\n                resolved = config.getChain(request, response, origChain);\n            }\n        }\n        if (resolved != null) {\n            log.trace(\"Resolved a configured FilterChain for the current request.\");\n            chain = resolved;\n        } else {\n            log.trace(\"No FilterChain configured for the current request.  Using the default.\");\n        }\n\n        return chain;\n    }\n\n    /**\n     * Executes a {@link FilterChain} for the given request.\n     * <p/>\n     * This implementation first delegates to\n     * <code>{@link #getExecutionChain(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain) getExecutionChain}<\/code>\n     * to allow the application's Shiro configuration to determine exactly how the chain should execute.  The resulting\n     * value from that call is then executed directly by calling the returned {@code FilterChain}'s\n     * {@link FilterChain#doFilter doFilter} method.  That is:\n     * <pre>\n     * FilterChain chain = {@link #getExecutionChain}(request, response, origChain);\n     * chain.{@link FilterChain#doFilter doFilter}(request,response);<\/pre>\n     *\n     * @param request   the incoming ServletRequest\n     * @param response  the outgoing ServletResponse\n     * @param origChain the Servlet Container-provided chain that may be wrapped further by an application-configured\n     *                  chain of Filters.\n     * @throws IOException      if the underlying {@code chain.doFilter} call results in an IOException\n     * @throws ServletException if the underlying {@code chain.doFilter} call results in a ServletException\n     * @since 1.0\n     */\n    protected void executeChain(ServletRequest request, ServletResponse response, FilterChain origChain)\n            throws IOException, ServletException {\n        FilterChain chain = getExecutionChain(request, response, origChain);\n        chain.doFilter(request, response);\n    }\n\n    /**\n     * Destroys this Filter by destroying the {@link #getConfiguration() configuration} object.\n     */\n    public void destroy() {\n        LifecycleUtils.destroy(getConfiguration());\n    }\n}\n","lineNo":533}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.spring.web;\n\nimport org.apache.shiro.config.Ini;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.util.Nameable;\nimport org.apache.shiro.util.StringUtils;\nimport org.apache.shiro.web.config.IniFilterChainResolverFactory;\nimport org.apache.shiro.web.filter.AccessControlFilter;\nimport org.apache.shiro.web.filter.authc.AuthenticationFilter;\nimport org.apache.shiro.web.filter.authz.AuthorizationFilter;\nimport org.apache.shiro.web.filter.mgt.DefaultFilterChainManager;\nimport org.apache.shiro.web.filter.mgt.FilterChainManager;\nimport org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver;\nimport org.apache.shiro.web.servlet.AbstractShiroFilter;\nimport org.apache.shiro.web.servlet.IniShiroFilter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanInitializationException;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.config.BeanPostProcessor;\n\nimport javax.servlet.Filter;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * {@link org.springframework.beans.factory.FactoryBean FactoryBean} to be used in Spring-based web applications for\n * defining the master Shiro Filter.\n * <h4>Usage<\/h4>\n * Declare a DelegatingFilterProxy in {@code web.xml}, matching the filter name to the bean id:\n * <pre>\n * &lt;filter&gt;\n *   &lt;filter-name&gt;<b>shiroFilter<\/b>&lt;/filter-name&gt;\n *   &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;filter-class&gt;\n * &lt;/filter&gt;\n * <\/pre>\n * Then, in your spring XML file that defines your web ApplicationContext:\n * <pre>\n * &lt;bean id=\"<b>shiroFilter<\/b>\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"&gt;\n *    &lt;property name=\"securityManager\" ref=\"securityManager\"/&gt;\n *    &lt;!-- other properties as necessary ... --&gt;\n * &lt;/bean&gt;\n * <\/pre>\n * <h4>Filter Auto-Discovery<\/h4>\n * While there is a {@link #setFilters(java.util.Map) filters} property that allows you to assign a filter beans\n * to the 'pool' of filters available when defining {@link #setFilterChainDefinitions(String) filter chains}, it is\n * optional.\n * <p/>\n * This implementation is also a {@link BeanPostProcessor} and will acquire\n * any {@link javax.servlet.Filter Filter} beans defined independently in your Spring application context.  Upon\n * discovery, they will be automatically added to the {@link #setFilters(java.util.Map) map} keyed by the bean ID.\n * That ID can then be used in the filter chain definitions, for example:\n *\n * <pre>\n * &lt;bean id=\"<b>myCustomFilter<\/b>\" class=\"com.class.that.implements.javax.servlet.Filter\"/&gt;\n * ...\n * &lt;bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"&gt;\n *    ...\n *    &lt;property name=\"filterChainDefinitions\"&gt;\n *        &lt;value&gt;\n *            /some/path/** = authc, <b>myCustomFilter<\/b>\n *        &lt;/value&gt;\n *    &lt;/property&gt;\n * &lt;/bean&gt;\n * <\/pre>\n * <h4>Global Property Values<\/h4>\n * Most Shiro servlet Filter implementations exist for defining custom Filter\n * {@link #setFilterChainDefinitions(String) chain definitions}.  Most implementations subclass one of the\n * {@link AccessControlFilter}, {@link AuthenticationFilter}, {@link AuthorizationFilter} classes to simplify things,\n * and each of these 3 classes has configurable properties that are application-specific.\n * <p/>\n * A dilemma arises where, if you want to for example set the application's 'loginUrl' for any Filter, you don't want\n * to have to manually specify that value for <em>each<\/em> filter instance definied.\n * <p/>\n * To prevent configuration duplication, this implementation provides the following properties to allow you\n * to set relevant values in only one place:\n * <ul>\n * <li>{@link #setLoginUrl(String)}<\/li>\n * <li>{@link #setSuccessUrl(String)}<\/li>\n * <li>{@link #setUnauthorizedUrl(String)}<\/li>\n * <\/ul>\n *\n * Then at startup, any values specified via these 3 properties will be applied to all configured\n * Filter instances so you don't have to specify them individually on each filter instance.  To ensure your own custom\n * filters benefit from this convenience, your filter implementation should subclass one of the 3 mentioned\n * earlier.\n *\n * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)\n * @since 1.0\n */\npublic class ShiroFilterFactoryBean implements FactoryBean, BeanPostProcessor {\n\n    private static transient final Logger log = LoggerFactory.getLogger(ShiroFilterFactoryBean.class);\n\n    private SecurityManager securityManager;\n\n    private Map<String, Filter> filters;\n\n    private Map<String, String> filterChainDefinitionMap; //urlPathExpression_to_comma-delimited-filter-chain-definition\n\n    private String loginUrl;\n    private String successUrl;\n    private String unauthorizedUrl;\n\n    private AbstractShiroFilter instance;\n\n    public ShiroFilterFactoryBean() {\n        this.filters = new LinkedHashMap<String, Filter>();\n        this.filterChainDefinitionMap = new LinkedHashMap<String, String>(); //order matters!\n    }\n\n    /**\n     * Sets the application {@code SecurityManager} instance to be used by the constructed Shiro Filter.  This is a\n     * required property - failure to set it will throw an initialization exception.\n     *\n     * @return the application {@code SecurityManager} instance to be used by the constructed Shiro Filter.\n     */\n    public SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    /**\n     * Sets the application {@code SecurityManager} instance to be used by the constructed Shiro Filter.  This is a\n     * required property - failure to set it will throw an initialization exception.\n     *\n     * @param securityManager the application {@code SecurityManager} instance to be used by the constructed Shiro Filter.\n     */\n    public void setSecurityManager(SecurityManager securityManager) {\n        this.securityManager = securityManager;\n    }\n\n    /**\n     * Returns the application's login URL to be assigned to all acquired Filters that subclass\n     * {@link AccessControlFilter} or {@code null} if no value should be assigned globally. The default value\n     * is {@code null}.\n     *\n     * @return the application's login URL to be assigned to all acquired Filters that subclass\n     *         {@link AccessControlFilter} or {@code null} if no value should be assigned globally.\n     * @see #setLoginUrl\n     */\n    public String getLoginUrl() {\n        return loginUrl;\n    }\n\n    /**\n     * Sets the application's login URL to be assigned to all acquired Filters that subclass\n     * {@link AccessControlFilter}.  This is a convenience mechanism: for all configured {@link #setFilters filters},\n     * as well for any default ones ({@code authc}, {@code user}, etc), this value will be passed on to each Filter\n     * via the {@link AccessControlFilter#setLoginUrl(String)} method<b>*<\/b>.  This eliminates the need to\n     * configure the 'loginUrl' property manually on each filter instance, and instead that can be configured once\n     * via this attribute.\n     * <p/>\n     * <b>*<\/b>If a filter already has already been explicitly configured with a value, it will\n     * <em>not<\/em> receive this value. Individual filter configuration overrides this global convenience property.\n     *\n     * @param loginUrl the application's login URL to apply to as a convenience to all discovered\n     *                 {@link AccessControlFilter} instances.\n     * @see AccessControlFilter#setLoginUrl(String)\n     */\n    public void setLoginUrl(String loginUrl) {\n        this.loginUrl = loginUrl;\n    }\n\n    /**\n     * Returns the application's after-login success URL to be assigned to all acquired Filters that subclass\n     * {@link AuthenticationFilter} or {@code null} if no value should be assigned globally. The default value\n     * is {@code null}.\n     *\n     * @return the application's after-login success URL to be assigned to all acquired Filters that subclass\n     *         {@link AuthenticationFilter} or {@code null} if no value should be assigned globally.\n     * @see #setSuccessUrl\n     */\n    public String getSuccessUrl() {\n        return successUrl;\n    }\n\n    /**\n     * Sets the application's after-login success URL to be assigned to all acquired Filters that subclass\n     * {@link AuthenticationFilter}.  This is a convenience mechanism: for all configured {@link #setFilters filters},\n     * as well for any default ones ({@code authc}, {@code user}, etc), this value will be passed on to each Filter\n     * via the {@link AuthenticationFilter#setSuccessUrl(String)} method<b>*<\/b>.  This eliminates the need to\n     * configure the 'successUrl' property manually on each filter instance, and instead that can be configured once\n     * via this attribute.\n     * <p/>\n     * <b>*<\/b>If a filter already has already been explicitly configured with a value, it will\n     * <em>not<\/em> receive this value. Individual filter configuration overrides this global convenience property.\n     *\n     * @param successUrl the application's after-login success URL to apply to as a convenience to all discovered\n     *                   {@link AccessControlFilter} instances.\n     * @see AuthenticationFilter#setSuccessUrl(String)\n     */\n    public void setSuccessUrl(String successUrl) {\n        this.successUrl = successUrl;\n    }\n\n    /**\n     * Returns the application's after-login success URL to be assigned to all acquired Filters that subclass\n     * {@link AuthenticationFilter} or {@code null} if no value should be assigned globally. The default value\n     * is {@code null}.\n     *\n     * @return the application's after-login success URL to be assigned to all acquired Filters that subclass\n     *         {@link AuthenticationFilter} or {@code null} if no value should be assigned globally.\n     * @see #setSuccessUrl\n     */\n    public String getUnauthorizedUrl() {\n        return unauthorizedUrl;\n    }\n\n    /**\n     * Sets the application's 'unauthorized' URL to be assigned to all acquired Filters that subclass\n     * {@link AuthorizationFilter}.  This is a convenience mechanism: for all configured {@link #setFilters filters},\n     * as well for any default ones ({@code roles}, {@code perms}, etc), this value will be passed on to each Filter\n     * via the {@link AuthorizationFilter#setUnauthorizedUrl(String)} method<b>*<\/b>.  This eliminates the need to\n     * configure the 'unauthorizedUrl' property manually on each filter instance, and instead that can be configured once\n     * via this attribute.\n     * <p/>\n     * <b>*<\/b>If a filter already has already been explicitly configured with a value, it will\n     * <em>not<\/em> receive this value. Individual filter configuration overrides this global convenience property.\n     *\n     * @param unauthorizedUrl the application's 'unauthorized' URL to apply to as a convenience to all discovered\n     *                        {@link AuthorizationFilter} instances.\n     * @see AuthorizationFilter#setUnauthorizedUrl(String)\n     */\n    public void setUnauthorizedUrl(String unauthorizedUrl) {\n        this.unauthorizedUrl = unauthorizedUrl;\n    }\n\n    /**\n     * Returns the filterName-to-Filter map of filters available for reference when defining filter chain definitions.\n     * All filter chain definitions will reference filters by the names in this map (i.e. the keys).\n     *\n     * @return the filterName-to-Filter map of filters available for reference when defining filter chain definitions.\n     */\n    public Map<String, Filter> getFilters() {\n        return filters;\n    }\n\n    /**\n     * Sets the filterName-to-Filter map of filters available for reference when creating\n     * {@link #setFilterChainDefinitionMap(java.util.Map) filter chain definitions}.\n     * <p/>\n     * <b>Note:<\/b> This property is optional:  this {@code FactoryBean} implementation will discover all beans in the\n     * web application context that implement the {@link Filter} interface and automatically add them to this filter\n     * map under their bean name.\n     * <p/>\n     * For example, just defining this bean in a web Spring XML application context:\n     * <pre>\n     * &lt;bean id=&quot;myFilter&quot; class=&quot;com.class.that.implements.javax.servlet.Filter&quot;&gt;\n     * ...\n     * &lt;/bean&gt;<\/pre>\n     * Will automatically place that bean into this Filters map under the key '<b>myFilter<\/b>'.\n     *\n     * @param filters the optional filterName-to-Filter map of filters available for reference when creating\n     *                {@link #setFilterChainDefinitionMap (java.util.Map) filter chain definitions}.\n     */\n    public void setFilters(Map<String, Filter> filters) {\n        this.filters = filters;\n    }\n\n    /**\n     * Returns the chainName-to-chainDefinition map of chain definitions to use for creating filter chains intercepted\n     * by the Shiro Filter.  Each map entry should conform to the format defined by the\n     * {@link FilterChainManager#createChain(String, String)} JavaDoc, where the map key is the chain name (e.g. URL\n     * path expression) and the map value is the comma-delimited string chain definition.\n     *\n     * @return he chainName-to-chainDefinition map of chain definitions to use for creating filter chains intercepted\n     *         by the Shiro Filter.\n     */\n    public Map<String, String> getFilterChainDefinitionMap() {\n        return filterChainDefinitionMap;\n    }\n\n    /**\n     * Sets the chainName-to-chainDefinition map of chain definitions to use for creating filter chains intercepted\n     * by the Shiro Filter.  Each map entry should conform to the format defined by the\n     * {@link FilterChainManager#createChain(String, String)} JavaDoc, where the map key is the chain name (e.g. URL\n     * path expression) and the map value is the comma-delimited string chain definition.\n     *\n     * @param filterChainDefinitionMap the chainName-to-chainDefinition map of chain definitions to use for creating\n     *                                 filter chains intercepted by the Shiro Filter.\n     */\n    public void setFilterChainDefinitionMap(Map<String, String> filterChainDefinitionMap) {\n        this.filterChainDefinitionMap = filterChainDefinitionMap;\n    }\n\n    /**\n     * A convenience method that sets the {@link #setFilterChainDefinitionMap(java.util.Map) filterChainDefinitionMap}\n     * property by accepting a {@link java.util.Properties Properties}-compatible string (multi-line key/value pairs).\n     * Each key/value pair must conform to the format defined by the\n     * {@link FilterChainManager#createChain(String,String)} JavaDoc - each property key is an ant URL\n     * path expression and the value is the comma-delimited chain definition.\n     *\n     * @param definitions a {@link java.util.Properties Properties}-compatible string (multi-line key/value pairs)\n     *                    where each key/value pair represents a single urlPathExpression-commaDelimitedChainDefinition.\n     */\n    public void setFilterChainDefinitions(String definitions) {\n        Ini ini = new Ini();\n        ini.load(definitions);\n        //did they explicitly state a 'urls' section?  Not necessary, but just in case:\n        Ini.Section section = ini.getSection(IniFilterChainResolverFactory.URLS);\n        if (CollectionUtils.isEmpty(section)) {\n            //no urls section.  Since this _is_ a urls chain definition property, just assume the\n            //default section contains only the definitions:\n            section = ini.getSection(Ini.DEFAULT_SECTION_NAME);\n        }\n        setFilterChainDefinitionMap(section);\n    }\n\n    /**\n     * Lazily creates and returns a {@link AbstractShiroFilter} concrete instance via the\n     * {@link #createInstance} method.\n     *\n     * @return the application's Shiro Filter instance used to filter incoming web requests.\n     * @throws Exception if there is a problem creating the {@code Filter} instance.\n     */\n    public Object getObject() throws Exception {\n        if (instance == null) {\n            instance = createInstance();\n        }\n        return instance;\n    }\n\n    /**\n     * Returns <code>{@link org.apache.shiro.web.servlet.AbstractShiroFilter}.class<\/code>\n     *\n     * @return <code>{@link org.apache.shiro.web.servlet.AbstractShiroFilter}.class<\/code>\n     */\n    public Class getObjectType() {\n        return AbstractShiroFilter.class;\n    }\n\n    /**\n     * Returns {@code true} always.  There is almost always only ever 1 Shiro {@code Filter} per web application.\n     *\n     * @return {@code true} always.  There is almost always only ever 1 Shiro {@code Filter} per web application.\n     */\n    public boolean isSingleton() {\n        return true;\n    }\n\n    protected FilterChainManager createFilterChainManager() {\n\n        DefaultFilterChainManager manager = new DefaultFilterChainManager();\n        Map<String, Filter> defaultFilters = manager.getFilters();\n        //apply global settings if necessary:\n        for (Filter filter : defaultFilters.values()) {\n            applyGlobalPropertiesIfNecessary(filter);\n        }\n\n        //Apply the acquired and/or configured filters:\n        Map<String, Filter> filters = getFilters();\n        if (!CollectionUtils.isEmpty(filters)) {\n            for (Map.Entry<String, Filter> entry : filters.entrySet()) {\n                String name = entry.getKey();\n                Filter filter = entry.getValue();\n                applyGlobalPropertiesIfNecessary(filter);\n                if (filter instanceof Nameable) {\n                    ((Nameable) filter).setName(name);\n                }\n                //'init' argument is false, since Spring-configured filters should be initialized\n                //in Spring (i.e. 'init-method=blah') or implement InitializingBean:\n                manager.addFilter(name, filter, false);\n            }\n        }\n\n        //build up the chains:\n        Map<String, String> chains = getFilterChainDefinitionMap();\n        if (!CollectionUtils.isEmpty(chains)) {\n            for (Map.Entry<String, String> entry : chains.entrySet()) {\n                String url = entry.getKey();\n                String chainDefinition = entry.getValue();\n                manager.createChain(url, chainDefinition);\n            }\n        }\n\n        return manager;\n    }\n\n    /**\n     * This implementation:\n     * <ol>\n     * <li>Ensures the required {@link #setSecurityManager(org.apache.shiro.mgt.SecurityManager) securityManager}\n     * property has been set<\/li>\n     * <li>{@link #createFilterChainManager() Creates} a {@link FilterChainManager} instance that reflects the\n     * configured {@link #setFilters(java.util.Map) filters} and\n     * {@link #setFilterChainDefinitionMap(java.util.Map) filter chain definitions}<\/li>\n     * <li>Wraps the FilterChainManager with a suitable\n     * {@link org.apache.shiro.web.filter.mgt.FilterChainResolver FilterChainResolver} since the Shiro Filter\n     * implementations do not know of {@code FilterChainManager}s<\/li>\n     * <li>Sets both the {@code SecurityManager} and {@code FilterChainResolver} instances on a new Shiro Filter\n     * instance and returns that filter instance.<\/li>\n     * <\/ol>\n     *\n     * @return a new Shiro Filter reflecting any configured filters and filter chain definitions.\n     * @throws Exception if there is a problem creating the ShiroFilter instance.\n     */\n    protected AbstractShiroFilter createInstance() throws Exception {\n\n        log.debug(\"Creating Shiro Filter instance.\");\n\n        SecurityManager securityManager = getSecurityManager();\n        if (securityManager == null) {\n            String msg = \"SecurityManager property must be set.\";\n            throw new BeanInitializationException(msg);\n        }\n\n        FilterChainManager manager = createFilterChainManager();\n\n        //Expose the constructed FilterChainManager by first wrapping it in a\n        // FilterChainResolver implementation. The ShiroFilter implementations\n        // do not know about FilterChainManagers - only resolvers:\n        PathMatchingFilterChainResolver chainResolver = new PathMatchingFilterChainResolver();\n        chainResolver.setFilterChainManager(manager);\n\n        //Now create a ShiroFilter and apply the acquired SecurityManager and built\n        //FilterChainResolver.  It doesn't matter that the ShiroFilter instance is an INI filter\n        //here - we're just using it because it is a concrete ShiroFilter instance that accepts\n        //injection of the SecurityManager and FilterChainResolver:\n        IniShiroFilter shiroFilter = new IniShiroFilter();\n        shiroFilter.setSecurityManager(securityManager);\n        shiroFilter.setFilterChainResolver(chainResolver);\n\n        return shiroFilter;\n    }\n\n    private void applyLoginUrlIfNecessary(Filter filter) {\n        String loginUrl = getLoginUrl();\n        if (StringUtils.hasText(loginUrl) && (filter instanceof AccessControlFilter)) {\n            AccessControlFilter acFilter = (AccessControlFilter) filter;\n            //only apply the login url if they haven't explicitly configured one already:\n            String existingLoginUrl = acFilter.getLoginUrl();\n            if (AccessControlFilter.DEFAULT_LOGIN_URL.equals(existingLoginUrl)) {\n                acFilter.setLoginUrl(loginUrl);\n            }\n        }\n    }\n\n    private void applySuccessUrlIfNecessary(Filter filter) {\n        String successUrl = getSuccessUrl();\n        if (StringUtils.hasText(successUrl) && (filter instanceof AuthenticationFilter)) {\n            AuthenticationFilter authcFilter = (AuthenticationFilter) filter;\n            //only apply the successUrl if they haven't explicitly configured one already:\n            String existingSuccessUrl = authcFilter.getSuccessUrl();\n            if (AuthenticationFilter.DEFAULT_SUCCESS_URL.equals(existingSuccessUrl)) {\n                authcFilter.setSuccessUrl(successUrl);\n            }\n        }\n    }\n\n    private void applyUnauthorizedUrlIfNecessary(Filter filter) {\n        String unauthorizedUrl = getUnauthorizedUrl();\n        if (StringUtils.hasText(unauthorizedUrl) && (filter instanceof AuthorizationFilter)) {\n            AuthorizationFilter authzFilter = (AuthorizationFilter) filter;\n            //only apply the unauthorizedUrl if they haven't explicitly configured one already:\n            String existingUnauthorizedUrl = authzFilter.getUnauthorizedUrl();\n            if (existingUnauthorizedUrl == null) {\n                authzFilter.setUnauthorizedUrl(unauthorizedUrl);\n            }\n        }\n    }\n\n    private void applyGlobalPropertiesIfNecessary(Filter filter) {\n        applyLoginUrlIfNecessary(filter);\n        applySuccessUrlIfNecessary(filter);\n        applyUnauthorizedUrlIfNecessary(filter);\n    }\n\n    /**\n     * Inspects a bean, and if it implements the {@link Filter} interface, automatically adds that filter\n     * instance to the internal {@link #setFilters(java.util.Map) filters map} that will be referenced\n     * later during filter chain construction.\n     */\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        if (bean instanceof Filter) {\n            log.debug(\"Found filter chain candidate filter '{}'\", beanName);\n            Filter filter = (Filter) bean;\n            applyGlobalPropertiesIfNecessary(filter);\n            getFilters().put(beanName, filter);\n        } else {\n            log.trace(\"Ignoring non-Filter bean '{}'\", beanName);\n        }\n        return bean;\n    }\n\n    /**\n     * Does nothing - only exists to satisfy the BeanPostProcessor interface and immediately returns the\n     * {@code bean} argument.\n     */\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        return bean;\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.spring.web;\n\nimport org.apache.shiro.config.Ini;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.util.Nameable;\nimport org.apache.shiro.web.config.IniFilterChainResolverFactory;\nimport org.apache.shiro.web.filter.mgt.DefaultFilterChainManager;\nimport org.apache.shiro.web.filter.mgt.FilterChainManager;\nimport org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver;\nimport org.apache.shiro.web.servlet.AbstractShiroFilter;\nimport org.apache.shiro.web.servlet.IniShiroFilter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanInitializationException;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.config.BeanPostProcessor;\n\nimport javax.servlet.Filter;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * {@link org.springframework.beans.factory.FactoryBean FactoryBean} to be used in Spring-based web applications.\n * <h4>Usage<\/h4>\n * Declare a DelegatingFilterProxy in {@code web.xml}:\n * <pre>\n * &lt;filter&gt;\n *   &lt;filter-name&gt;<b>shiroFilter<\/b>&lt;/filter-name&gt;\n *   &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;filter-class&gt;\n * &lt;/filter&gt;\n * <\/pre>\n * Then, in your spring XML file that defines your web ApplicationContext:\n * <pre>\n * <p/>\n * <\/pre>\n *\n * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)\n * @since 1.0\n */\npublic class ShiroFilterFactoryBean implements FactoryBean, BeanPostProcessor {\n\n    private static transient final Logger log = LoggerFactory.getLogger(ShiroFilterFactoryBean.class);\n\n    private SecurityManager securityManager;\n\n    private Map<String, Filter> filters;\n\n    private Map<String, String> filterChainDefinitionMap; //urlPathExpression_to_comma-delimited-filter-chain-definition\n\n    private AbstractShiroFilter instance;\n\n    public ShiroFilterFactoryBean() {\n        this.filters = new LinkedHashMap<String, Filter>();\n        this.filterChainDefinitionMap = new LinkedHashMap<String, String>(); //order matters!\n    }\n\n    public SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    public void setSecurityManager(SecurityManager securityManager) {\n        this.securityManager = securityManager;\n    }\n\n    /**\n     * Returns the filterName-to-Filter map of filters available for reference when defining filter chain definitions.\n     * All filter chain definitions will reference filters by the names in this map (i.e. the keys).\n     * <p/>\n     * Note that this map is often a merging of Shiro's default Filters ({@code authc}\n     * This map will contain all\n     * Note that most end-users will not need configure in spring the corresponding {@link #setFilters} method\n     *\n     * @return the filterName-to-Filter map of filters available for reference when defining filter chain definitions.\n     */\n    public Map<String, Filter> getFilters() {\n        return filters;\n    }\n\n    /**\n     * Sets the filterName-to-Filter map of filters available for reference when creating\n     * {@link #setFilterChainDefinitionMap(java.util.Map) filter chain definitions}.\n     * <p/>\n     * <b>Note:<\/b> This property is optional:  this {@code FactoryBean} implementation will discover all beans in the\n     * web application context that implement the {@link Filter} interface and automatically add them to this filter\n     * map under their bean name.\n     * <p/>\n     * For example, just defining this bean in a web Spring XML application context:\n     * <pre>\n     * &lt;bean id=&quot;myFilter&quot; class=&quot;com.class.that.implements.javax.servlet.Filter&quot;&gt;\n     * ...\n     * &lt;/bean&gt;<\/pre>\n     * Will automatically place that bean into this Filters map under the key '<b>myFilter<\/b>'.\n     *\n     * @param filters the optional filterName-to-Filter map of filters available for reference when creating\n     *                {@link #setFilterChainDefinitionMap (java.util.Map) filter chain definitions}.\n     */\n    public void setFilters(Map<String, Filter> filters) {\n        this.filters = filters;\n    }\n\n    /**\n     * Returns the chainName-to-chainDefinition map of chain definitions to use for creating filter chains intercepted\n     * by the Shiro Filter.  Each map entry should conform to the format defined by the\n     * {@link FilterChainManager#createChain(String, String)} JavaDoc, where the map key is the chain name (i.e. URL\n     * path expression) and the map value is the comma-delimited string chain definition.\n     *\n     * @return he chainName-to-chainDefinition map of chain definitions to use for creating filter chains intercepted\n     *         by the Shiro Filter.\n     */\n    public Map<String, String> getFilterChainDefinitionMap() {\n        return filterChainDefinitionMap;\n    }\n\n    /**\n     * Sets the chainName-to-chainDefinition map of chain definitions to use for creating filter chains intercepted\n     * by the Shiro Filter.  Each map entry should conform to the format defined by the\n     * {@link FilterChainManager#createChain(String, String)} JavaDoc, where the map key is the chain name (i.e. URL\n     * path expression) and the map value is the comma-delimited string chain definition.\n     *\n     * @param filterChainDefinitionMap the chainName-to-chainDefinition map of chain definitions to use for creating\n     *                               filter chains intercepted by the Shiro Filter.\n     */\n    public void setFilterChainDefinitionMap(Map<String, String> filterChainDefinitionMap) {\n        this.filterChainDefinitionMap = filterChainDefinitionMap;\n    }\n\n    public void setFilterChainDefinitions(String definitions) {\n        Ini ini = new Ini();\n        ini.load(definitions);\n        //did they explicitly state a 'urls' section?  Not necessary, but just in case:\n        Ini.Section section = ini.getSection(IniFilterChainResolverFactory.URLS);\n        if ( CollectionUtils.isEmpty(section) ) {\n            //no urls section.  Since this _is_ a urls chain definition property, just assume the\n            //default section contains only the definitions:\n            section = ini.getSection(Ini.DEFAULT_SECTION_NAME);\n        }\n        setFilterChainDefinitionMap(section);\n    }\n\n    public Object getObject() throws Exception {\n        if (instance == null) {\n            instance = (AbstractShiroFilter)createInstance();\n        }\n        return instance;\n    }\n\n    public Class getObjectType() {\n        return AbstractShiroFilter.class;\n    }\n\n    public boolean isSingleton() {\n        return true;\n    }\n\n    protected FilterChainManager createFilterChainManager() {\n\n        DefaultFilterChainManager manager = new DefaultFilterChainManager();\n\n        //Apply the acquired and/or configured filters:\n        Map<String, Filter> filters = getFilters();\n        if (!CollectionUtils.isEmpty(filters)) {\n            for (Map.Entry<String, Filter> entry : filters.entrySet()) {\n                String name = entry.getKey();\n                Filter filter = entry.getValue();\n                if (filter instanceof Nameable) {\n                    ((Nameable) filter).setName(name);\n                }\n                //'init' argument is false, since Spring-configured filters should be initialized\n                //in Spring (i.e. 'init-method=blah') or implement InitializingBean:\n                manager.addFilter(name, filter, false);\n            }\n        }\n\n        //build up the chains:\n        Map<String, String> chains = getFilterChainDefinitionMap();\n        if (!CollectionUtils.isEmpty(chains)) {\n            for (Map.Entry<String, String> entry : chains.entrySet()) {\n                String url = entry.getKey();\n                String chainDefinition = entry.getValue();\n                manager.createChain(url, chainDefinition);\n            }\n        }\n\n        return manager;\n    }\n\n    /**\n     * This implementation:\n     * <ol>\n     * <li>Ensures the {@link #setSecurityManager(org.apache.shiro.mgt.SecurityManager) securityManager} property\n     * has been set<\/li>\n     * <li>Creates a {@link FilterChainManager} instance that reflects the configured\n     * {@link #setFilters(java.util.Map) filters} and\n     * {@link #setFilterChainDefinitionMap(java.util.Map) filter chain definitions}<\/li>\n     * <li>Wraps the FilterChainManager with a suitable\n     * {@link org.apache.shiro.web.filter.mgt.FilterChainResolver FilterChainResolver} since the Shiro Filter\n     * implementations do not know of {@code FilterChainManager}s<\/li>\n     * <li>Sets both the {@code SecurityManager} and {@code FilterChainResolver} instances on a new Shiro Filter\n     * instance and returns that filter instance.<\/li>\n     * <\/ol>\n     *\n     * @return a new Shiro Filter reflecting any configured filters and filter chain definitions.\n     * @throws Exception if there is a problem creating the ShiroFilter instance.\n     */\n    protected Object createInstance() throws Exception {\n\n        log.debug(\"Creating Shiro Filter instance.\");\n\n        SecurityManager securityManager = getSecurityManager();\n        if (securityManager == null) {\n            String msg = \"SecurityManager property must be set.\";\n            throw new BeanInitializationException(msg);\n        }\n\n        FilterChainManager manager = createFilterChainManager();\n\n        //Expose the constructed FilterChainManager by first wrapping it in a\n        // FilterChainResolver implementation. The ShiroFilter implementations\n        // do not know about FilterChainManagers - only resolvers:\n        PathMatchingFilterChainResolver chainResolver = new PathMatchingFilterChainResolver();\n        chainResolver.setFilterChainManager(manager);\n\n        //Now create a ShiroFilter and apply the acquired SecurityManager and built\n        //FilterChainResolver.  It doesn't matter that the ShiroFilter instance is an INI filter\n        //here - we're just using it because it is a concrete ShiroFilter instance that accepts\n        //injection of the SecurityManager and FilterChainResolver:\n        IniShiroFilter shiroFilter = new IniShiroFilter();\n        shiroFilter.setSecurityManager(securityManager);\n        shiroFilter.setFilterChainResolver(chainResolver);\n\n        return shiroFilter;\n    }\n\n    /**\n     * Inspects a bean, and if it implements the {@link Filter} interface, automatically adds that filter\n     * instance to the internal {@link #setFilters(java.util.Map) filters map} that will be referenced\n     * later during filter chain construction.\n     */\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        if (bean instanceof Filter) {\n            log.debug(\"Found filter chain candidate filter '{}'\", beanName);\n            getFilters().put(beanName, (Filter) bean);\n        } else {\n            log.trace(\"Ignoring non-Filter bean '{}'\", beanName);\n        }\n        return bean;\n    }\n\n    /**\n     * Does nothing - only exists to satisfy the BeanPostProcessor interface and immediately returns the\n     * {@code bean} argument.\n     */\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        return bean;\n    }\n}\n","lineNo":496}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.mgt;\n\nimport org.apache.shiro.authc.*;\nimport org.apache.shiro.authz.Authorizer;\nimport org.apache.shiro.crypto.Cipher;\nimport org.apache.shiro.realm.Realm;\nimport org.apache.shiro.session.InvalidSessionException;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.session.SessionException;\nimport org.apache.shiro.session.mgt.DelegatingSession;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.subject.Subject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The Shiro framework's default concrete implementation of the {@link SecurityManager} interface,\n * based around a collection of {@link org.apache.shiro.realm.Realm}s.  This implementation delegates its\n * authentication, authorization, and session operations to wrapped {@link Authenticator}, {@link Authorizer}, and\n * {@link org.apache.shiro.session.mgt.SessionManager SessionManager} instances respectively via superclass\n * implementation.\n * <p/>\n * To greatly reduce and simplify configuration, this implementation (and its superclasses) will\n * create suitable defaults for all of its required dependencies, <em>except<\/em> the required one or more\n * {@link Realm Realm}s.  Because {@code Realm} implementations usually interact with an application's data model,\n * they are almost always application specific;  you will want to specify at least one custom\n * {@code Realm} implementation that 'knows' about your application's data/security model\n * (via {@link #setRealm} or one of the overloaded constructors).  All other attributes in this class hierarchy\n * will have suitable defaults for most enterprise applications.\n * <p/>\n * <b>RememberMe notice<\/b>: This class supports the ability to configure a\n * {@link #setRememberMeManager RememberMeManager}\n * for {@code RememberMe} identity services for login/logout, BUT, a default instance <em>will not<\/em> be created\n * for this attribute at startup.\n * <p/>\n * Because RememberMe services are inherently client tier-specific and\n * therefore aplication-dependent, if you want {@code RememberMe} services enabled, you will have to specify an\n * instance yourself via the {@link #setRememberMeManager(RememberMeManager) setRememberMeManager}\n * mutator.  However if you're reading this JavaDoc with the\n * expectation of operating in a Web environment, take a look at the\n * {@code org.apache.shiro.web.DefaultWebSecurityManager} implementation, which\n * <em>does<\/em> support {@code RememberMe} services by default at startup.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.2\n */\npublic class DefaultSecurityManager extends SessionsSecurityManager {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(DefaultSecurityManager.class);\n\n    protected RememberMeManager rememberMeManager;\n\n    protected SubjectFactory subjectFactory;\n\n    protected SubjectBinder subjectBinder;\n\n    /**\n     * Default no-arg constructor.\n     */\n    public DefaultSecurityManager() {\n        super();\n        this.subjectFactory = new DefaultSubjectFactory();\n        this.subjectBinder = new SessionSubjectBinder();\n    }\n\n    /**\n     * Supporting constructor for a single-realm application.\n     *\n     * @param singleRealm the single realm used by this SecurityManager.\n     */\n    public DefaultSecurityManager(Realm singleRealm) {\n        this();\n        setRealm(singleRealm);\n    }\n\n    /**\n     * Supporting constructor for multiple {@link #setRealms realms}.\n     *\n     * @param realms the realm instances backing this SecurityManager.\n     */\n    public DefaultSecurityManager(Collection<Realm> realms) {\n        this();\n        setRealms(realms);\n    }\n\n    public SubjectFactory getSubjectFactory() {\n        return subjectFactory;\n    }\n\n    public void setSubjectFactory(SubjectFactory subjectFactory) {\n        this.subjectFactory = subjectFactory;\n    }\n\n    public SubjectBinder getSubjectBinder() {\n        return subjectBinder;\n    }\n\n    public void setSubjectBinder(SubjectBinder subjectBinder) {\n        this.subjectBinder = subjectBinder;\n    }\n\n    public RememberMeManager getRememberMeManager() {\n        return rememberMeManager;\n    }\n\n    public void setRememberMeManager(RememberMeManager rememberMeManager) {\n        this.rememberMeManager = rememberMeManager;\n    }\n\n    private AbstractRememberMeManager getRememberMeManagerForCipherAttributes() {\n        if (!(this.rememberMeManager instanceof AbstractRememberMeManager)) {\n            String msg = \"The convenience passthrough methods for setting remember me cipher attributes \" +\n                    \"are only available when the underlying RememberMeManager implementation is a subclass of \" +\n                    AbstractRememberMeManager.class.getName() + \".\";\n            throw new IllegalStateException(msg);\n        }\n        return (AbstractRememberMeManager) this.rememberMeManager;\n    }\n\n    public void setRememberMeCipher(Cipher cipher) {\n        getRememberMeManagerForCipherAttributes().setCipher(cipher);\n    }\n\n    public void setRememberMeCipherKey(byte[] bytes) {\n        getRememberMeManagerForCipherAttributes().setCipherKey(bytes);\n    }\n\n    public void setRememberMeCipherKeyHex(String hex) {\n        getRememberMeManagerForCipherAttributes().setCipherKeyHex(hex);\n    }\n\n    public void setRememberMeCipherKeyBase64(String base64) {\n        getRememberMeManagerForCipherAttributes().setCipherKeyBase64(base64);\n    }\n\n    public void setRememberMeEncryptionCipherKey(byte[] bytes) {\n        getRememberMeManagerForCipherAttributes().setEncryptionCipherKey(bytes);\n    }\n\n    public void setRememberMeEncryptionCipherKeyHex(String hex) {\n        getRememberMeManagerForCipherAttributes().setEncryptionCipherKeyHex(hex);\n    }\n\n    public void setRememberMeEncryptionCipherKeyBase64(String base64) {\n        getRememberMeManagerForCipherAttributes().setEncryptionCipherKeyBase64(base64);\n    }\n\n    public void setRememberMeDecryptionCipherKey(byte[] bytes) {\n        getRememberMeManagerForCipherAttributes().setDecryptionCipherKey(bytes);\n    }\n\n    public void setRememberMeDecryptionCipherKeyHex(String hex) {\n        getRememberMeManagerForCipherAttributes().setDecryptionCipherKeyHex(hex);\n    }\n\n    public void setRememberMeDecryptionCipherKeyBase64(String base64) {\n        getRememberMeManagerForCipherAttributes().setDecryptionCipherKeyBase64(base64);\n    }\n\n    protected Session getSession(Serializable id) {\n        checkValid(id);\n        return new DelegatingSession(this, id);\n    }\n\n    /**\n     * Creates a {@code Subject} instance for the user represented by the given method arguments.\n     *\n     * @param token    the {@code AuthenticationToken} submitted for the successful authentication.\n     * @param info     the {@code AuthenticationInfo} of a newly authenticated user.\n     * @param existing the existing {@code Subject} instance that initiated the authentication attempt\n     * @return the {@code Subject} instance that represents the context and session data for the newly\n     *         authenticated subject.\n     */\n    protected Subject createSubject(AuthenticationToken token, AuthenticationInfo info, Subject existing) {\n        Map<String, Object> context = new HashMap<String, Object>();\n        context.put(SubjectFactory.AUTHENTICATED, Boolean.TRUE);\n        context.put(SubjectFactory.AUTHENTICATION_TOKEN, token);\n        context.put(SubjectFactory.AUTHENTICATION_INFO, info);\n        if (existing != null) {\n            context.put(SubjectFactory.SUBJECT, existing);\n        }\n        return createSubject(context);\n    }\n\n    /**\n     * Binds a {@code Subject} instance created after authentication to the application for later use.\n     * <p/>\n     * The default implementation simply delegates to the internal {@link #getSubjectBinder() subjectBinder}.\n     *\n     * @param subject the {@code Subject} instance created after authentication to be bound to the application\n     *                for later use.\n     */\n    protected void bind(Subject subject) {\n        getSubjectBinder().bind(subject);\n    }\n\n    protected void rememberMeSuccessfulLogin(AuthenticationToken token, AuthenticationInfo info) {\n        RememberMeManager rmm = getRememberMeManager();\n        if (rmm != null) {\n            try {\n                rmm.onSuccessfulLogin(token, info);\n            } catch (Exception e) {\n                if (log.isWarnEnabled()) {\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() +\n                            \"] threw an exception during onSuccessfulLogin.  RememberMe services will not be \" +\n                            \"performed for account [\" + info + \"].\";\n                    log.warn(msg, e);\n                }\n            }\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"This \" + getClass().getName() + \" instance does not have a \" +\n                        \"[\" + RememberMeManager.class.getName() + \"] instance configured.  RememberMe services \" +\n                        \"will not be performed for account [\" + info + \"].\");\n            }\n        }\n    }\n\n    protected void rememberMeFailedLogin(AuthenticationToken token, AuthenticationException ex) {\n        RememberMeManager rmm = getRememberMeManager();\n        if (rmm != null) {\n            try {\n                rmm.onFailedLogin(token, ex);\n            } catch (Exception e) {\n                if (log.isWarnEnabled()) {\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() +\n                            \"] threw an exception during onFailedLogin for AuthenticationToken [\" +\n                            token + \"].\";\n                    log.warn(msg, e);\n                }\n            }\n        }\n    }\n\n    protected void rememberMeLogout(PrincipalCollection subjectPrincipals) {\n        RememberMeManager rmm = getRememberMeManager();\n        if (rmm != null) {\n            try {\n                rmm.onLogout(subjectPrincipals);\n            } catch (Exception e) {\n                if (log.isWarnEnabled()) {\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() +\n                            \"] threw an exception during onLogout for subject with principals [\" +\n                            subjectPrincipals + \"]\";\n                    log.warn(msg, e);\n                }\n            }\n        }\n    }\n\n    /**\n     * First authenticates the {@code AuthenticationToken} argument, and if successful, constructs a\n     * {@code Subject} instance representing the authenticated account's identity.\n     * <p/>\n     * Once constructed, the {@code Subject} instance is then {@link #bind bound} to the application for\n     * subsequent access before being returned to the caller.\n     *\n     * @param token the authenticationToken to process for the login attempt.\n     * @return a Subject representing the authenticated user.\n     * @throws AuthenticationException if there is a problem authenticating the specified {@code token}.\n     */\n    public Subject login(Subject subject, AuthenticationToken token) throws AuthenticationException {\n        AuthenticationInfo info;\n        try {\n            info = authenticate(token);\n            onSuccessfulLogin(token, info);\n        } catch (AuthenticationException ae) {\n            try {\n                onFailedLogin(token, ae);\n            } catch (Exception e) {\n                if (log.isInfoEnabled()) {\n                    log.info(\"onFailedLogin(AuthenticationToken,AuthenticationException) method threw an \" +\n                            \"exception.  Logging and propagating original AuthenticationException.\", e);\n                }\n            }\n            throw ae; //propagate\n        }\n        Subject replaced = createSubject(token, info, subject);\n        //TODO - is binding necessary anymore?  Shouldn't the Builders or Builder callers do this now?\n        bind(replaced);\n        return replaced;\n    }\n\n    protected void onSuccessfulLogin(AuthenticationToken token, AuthenticationInfo info) {\n        rememberMeSuccessfulLogin(token, info);\n    }\n\n    protected void onFailedLogin(AuthenticationToken token, AuthenticationException ae) {\n        rememberMeFailedLogin(token, ae);\n    }\n\n    protected void beforeLogout(PrincipalCollection subjectIdentifier) {\n        rememberMeLogout(subjectIdentifier);\n    }\n\n    /**\n     * This implementation attempts to resolve any session ID that may exist in the context argument by\n     * passing it to the {@link #resolveSession(Map)} method.  The\n     * return value from that call is then used to attempt to resolve the subject identity via the\n     * {@link #resolvePrincipals(java.util.Map)} method.  The return value from that call is then used to create\n     * the {@code Subject} instance by calling\n     * <code>{@link #getSubjectFactory() getSubjectFactory()}.{@link SubjectFactory#createSubject(java.util.Map) createSubject}(resolvedContext);<\/code>\n     *\n     * @param context any data needed to direct how the Subject should be constructed.\n     * @return the {@code Subject} instance reflecting the specified initialization data.\n     * @see SubjectFactory#createSubject(java.util.Map)\n     * @since 1.0\n     */\n    public Subject createSubject(Map context) {\n        if (context == null) {\n            context = new HashMap();\n        }\n\n        //ensure that the context map has a SecurityManager instance, and if not, add one:\n        Map resolved = ensureSecurityManager(context);\n\n        //Translate a session id if it exists into a Session object before sending to the SubjectFactory\n        //The SubjectFactory should not need to know how to acquire sessions as it is often environment\n        //specific - better to shield the SF from these details:\n        resolved = resolveSession(resolved);\n\n        //Similarly, the SubjectFactory should not have any concept of RememberMe - translate that here first\n        //if possible before handing off to the SubjectFactory:\n        resolved = resolvePrincipals(resolved);\n\n        return getSubjectFactory().createSubject(resolved);\n    }\n\n    /**\n     * Determines if there is a {@code SecurityManager} instance in the context map under the\n     * {@link SubjectFactory#SECURITY_MANAGER} key, and if not, adds 'this' to the map under that key.  This ensures\n     * the SubjectFactory instance will have access to a SecurityManager during Subject construction if necessary.\n     *\n     * @param context the subject context data that may contain a SecurityManager instance.\n     * @return The context Map to use to pass to a {@link SubjectFactory} for subject creation.\n     * @since 1.0\n     */\n    @SuppressWarnings({\"unchecked\"})\n    protected Map ensureSecurityManager(Map context) {\n        if (context.containsKey(SubjectFactory.SECURITY_MANAGER)) {\n            log.debug(\"Context already contains a SecurityManager instance.  Returning.\");\n            return context;\n        }\n        log.trace(\"No SecurityManager found in context.  Adding self reference.\");\n        context.put(SubjectFactory.SECURITY_MANAGER, this);\n        return context;\n    }\n\n    /**\n     * Attempts to resolve any session id in the context to its corresponding {@link Session} and returns a\n     * context that represents this resolved {@code Session} to ensure it may be referenced if necessary by the\n     * invoked {@link SubjectFactory} that performs actual {@link Subject} construction.\n     * <p/>\n     * The session id, if it exists in the context map, should be available as a value under the\n     * <code>{@link SubjectFactory SubjectFactory}.{@link SubjectFactory#SESSION_ID SESSION_ID}<\/code> key constant.\n     * If a session is resolved, a copy of the original context Map is made to ensure the method argument is not\n     * changed, the resolved session is placed into the copy and the copy is returned.\n     * <p/>\n     * If there is a {@code Session} already in the context because that is what the caller wants to be used for\n     * {@code Subject} construction, or if no session is resolved, this method effectively does nothing and immediately\n     * returns the Map method argument unaltered.\n     *\n     * @param context the subject context data that may contain a session id that should be converted to a Session instance.\n     * @return The context Map to use to pass to a {@link SubjectFactory} for subject creation.\n     * @since 1.0\n     */\n    @SuppressWarnings({\"unchecked\"})\n    protected Map resolveSession(Map context) {\n        if (context.containsKey(SubjectFactory.SESSION)) {\n            log.debug(\"Context already contains a session.  Returning.\");\n            return context;\n        }\n        log.trace(\"No session found in context.  Looking for a session id to resolve in to a session.\");\n        //otherwise try to resolve a session if a session id exists:\n        Serializable sessionId = getSessionId(context);\n        if (sessionId != null) {\n            try {\n                Session session = getSession(sessionId);\n                context.put(SubjectFactory.SESSION, session);\n            } catch (InvalidSessionException e) {\n                onInvalidSessionId(sessionId, e);\n                log.debug(\"Context referenced sessionId is invalid.  Ignoring and creating an anonymous \" +\n                        \"(session-less) Subject instance.\", e);\n            }\n        }\n        return context;\n    }\n\n    /**\n     * Heuristically determines if the specified subject map can resolve a Subject identity ({@link PrincipalCollection})\n     * either directly or indirectly by value association.  This implementation returns {@code true} in the following\n     * two cases, {@code false} otherwise:\n     * <ol>\n     * <li>If the context {@link Map#containsKey contains} a key {@link SubjectFactory#PRINCIPALS}, it is assumed\n     * the identity has been explicitly provided already.<\/li>\n     * <li>If the context has a {@link Session} under the {@link SubjectFactory#SESSION} key, it attempts to resolve\n     * any identity associated with that {@code Session} instance.  If one can be found in the {@code Session}, it is\n     * assumed that {@code Session} identity should be used/retained.<\/li>\n     * <\/ol>\n     *\n     * @param context the subject context data that may provide (directly or indirectly through one of its values) a\n     *                {@link PrincipalCollection} identity.\n     * @return {@code true} if an identity can be resolved, {@code false} otherwise.\n     * @since 1.0\n     */\n    protected boolean containsIdentity(Map context) {\n        if (context.containsKey(SubjectFactory.PRINCIPALS)) {\n            log.trace(\"Context already contains an explicit identity.\");\n            return true;\n        }\n        if (context.containsKey(SubjectFactory.SESSION)) {\n            Session session = (Session) context.get(SubjectFactory.SESSION);\n            if (session != null) {\n                Object principals = session.getAttribute(SessionSubjectBinder.PRINCIPALS_SESSION_KEY);\n                if (principals != null) {\n                    log.trace(\"Context already contains an implicit (session-based) identity.\");\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Attempts to resolve an identity (a {@link PrincipalCollection}) for the context using heuristics.  The\n     * implementation strategy:\n     * <ol>\n     * <li>Check the context to see if it already {@link #containsIdentity(java.util.Map) contains an identity}.  If\n     * so, this method does nothing and returns the method argument unaltered.<\/li>\n     * <li>Check for a RememberMe identity by calling {@link #getRememberedIdentity()}.  If that method returns a\n     * non-null value, create a <em>copy<\/em> of the method argument, and place the remembered {@link PrincipalCollection}\n     * in the copied context map under the {@link SubjectFactory#PRINCIPALS} key and return that copied context.<\/li>\n     * <\/ol>\n     *\n     * @param context the subject context data that may provide (directly or indirectly through one of its values) a\n     *                {@link PrincipalCollection} identity.\n     * @return The context Map to use to pass to a {@link SubjectFactory} for subject creation.\n     * @since 1.0\n     */\n    @SuppressWarnings({\"unchecked\"})\n    protected Map resolvePrincipals(Map context) {\n        if (!containsIdentity(context)) {\n            log.trace(\"No identity (PrincipalCollection) found in the context.  Looking for a remembered identity.\");\n            PrincipalCollection principals = getRememberedIdentity();\n            if (principals != null) {\n                log.debug(\"Found remembered PrincipalCollection.  Adding to the context to be used \" +\n                        \"for subject construction by the SubjectFactory.\");\n                context.put(SubjectFactory.PRINCIPALS, principals);\n            } else {\n                log.trace(\"No remembered identity found.  Returning original context.\");\n            }\n        }\n\n        return context;\n    }\n\n    /**\n     * Allows subclasses to react to the fact that a specified/referenced session id was invalid.  Default\n     * implementation does nothing (no-op).\n     *\n     * @param sessionId the session id that was discovered to be invalid (no session, expired, etc).\n     * @param e         the exception thrown upon encountering the invalid session id\n     * @since 1.0\n     */\n    protected void onInvalidSessionId(Serializable sessionId, InvalidSessionException e) {\n    }\n\n    /**\n     * Utility method to retrieve the session id from the given subject context Map which will be used to resolve\n     * to a {@link Session} or {@code null} if there is no session id in the map.  If the session id exists, it is\n     * expected to be available in the map under the\n     * <code>{@link SubjectFactory SubjectFactory}.{@link SubjectFactory#SESSION_ID SESSION_ID}<\/code> constant.\n     *\n     * @param subjectContext the context map with data that will be used to construct a {@link Subject} instance via\n     *                       a {@link SubjectFactory}\n     * @return a session id to resolve to a {@link Session} instance or {@code null} if a session id could not be found.\n     * @see #createSubject(java.util.Map)\n     * @see SubjectFactory#createSubject(java.util.Map)\n     */\n    protected Serializable getSessionId(Map subjectContext) {\n        return (Serializable) subjectContext.get(SubjectFactory.SESSION_ID);\n    }\n\n    public void logout(Subject subject) {\n\n        if (subject == null) {\n            throw new IllegalArgumentException(\"Subject method argument cannot be null.\");\n        }\n\n        PrincipalCollection principals = subject.getPrincipals();\n\n        if (principals != null && !principals.isEmpty()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Logging out subject with primary principal {}\" + principals.getPrimaryPrincipal());\n            }\n            beforeLogout(principals);\n            Authenticator authc = getAuthenticator();\n            if (authc instanceof LogoutAware) {\n                ((LogoutAware) authc).onLogout(principals);\n            }\n        }\n\n        try {\n            unbind(subject);\n        } catch (Exception e) {\n            if (log.isDebugEnabled()) {\n                String msg = \"Unable to cleanly unbind Subject.  Ignoring (logging out).\";\n                log.debug(msg, e);\n            }\n        } finally {\n            try {\n                stopSession(subject);\n            } catch (Exception e) {\n                if (log.isDebugEnabled()) {\n                    String msg = \"Unable to cleanly stop Session for Subject [\" + subject.getPrincipal() + \"] \" +\n                            \"Ignoring (logging out).\";\n                    log.debug(msg, e);\n                }\n            }\n        }\n    }\n\n    protected void stopSession(Subject subject) {\n        Session s = subject.getSession(false);\n        if (s != null) {\n            //react to the id and not the session itself - the Session instance could be a proxy/delegate Session\n            //in which case the ID might be the only thing accessible.  Better to pass off the ID to the underlying\n            //SessionManager since this will successfully handle all cases.\n            Serializable sessionId = s.getId();\n            if (sessionId != null) {\n                try {\n                    stop(sessionId);\n                } catch (SessionException e) {\n                    //ignored - we're invalidating, and have no further need of the session anyway\n                    //log just in case someone wants to know:\n                    if (log.isDebugEnabled()) {\n                        String msg = \"Session for Subject [\" + (subject != null ? subject.getPrincipal() : null) +\n                                \"] has already been invalidated.  Logging exception since session exceptions are \" +\n                                \"irrelevant when the owning Subject has logged out.\";\n                        log.debug(msg, e);\n                    }\n                }\n            }\n        }\n    }\n\n    protected void unbind(Subject subject) {\n        getSubjectBinder().unbind(subject);\n    }\n\n    protected PrincipalCollection getRememberedIdentity() {\n        RememberMeManager rmm = getRememberMeManager();\n        if (rmm != null) {\n            try {\n                return rmm.getRememberedPrincipals();\n            } catch (Exception e) {\n                if (log.isWarnEnabled()) {\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() +\n                            \"] threw an exception during getRememberedPrincipals().\";\n                    log.warn(msg, e);\n                }\n            }\n        }\n        return null;\n    }\n\n    public Subject getSubject() {\n        Subject subject = getSubjectBinder().getSubject();\n        if (subject == null) {\n            subject = createSubject(new HashMap());\n            bind(subject);\n        }\n        return subject;\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.mgt;\n\nimport org.apache.shiro.authc.*;\nimport org.apache.shiro.authz.AuthorizationException;\nimport org.apache.shiro.authz.Authorizer;\nimport org.apache.shiro.crypto.Cipher;\nimport org.apache.shiro.realm.Realm;\nimport org.apache.shiro.session.InvalidSessionException;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.session.SessionException;\nimport org.apache.shiro.session.mgt.DelegatingSession;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.subject.Subject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The Shiro framework's default concrete implementation of the {@link SecurityManager} interface,\n * based around a collection of {@link org.apache.shiro.realm.Realm}s.  This implementation delegates its\n * authentication, authorization, and session operations to wrapped {@link Authenticator}, {@link Authorizer}, and\n * {@link org.apache.shiro.session.mgt.SessionManager SessionManager} instances respectively via superclass\n * implementation.\n * <p/>\n * To greatly reduce and simplify configuration, this implementation (and its superclasses) will\n * create suitable defaults for all of its required dependencies, <em>except<\/em> the required one or more\n * {@link Realm Realm}s.  Because {@code Realm} implementations usually interact with an application's data model,\n * they are almost always application specific;  you will want to specify at least one custom\n * {@code Realm} implementation that 'knows' about your application's data/security model\n * (via {@link #setRealm} or one of the overloaded constructors).  All other attributes in this class hierarchy\n * will have suitable defaults for most enterprise applications.\n * <p/>\n * <b>RememberMe notice<\/b>: This class supports the ability to configure a\n * {@link #setRememberMeManager RememberMeManager}\n * for {@code RememberMe} identity services for login/logout, BUT, a default instance <em>will not<\/em> be created\n * for this attribute at startup.\n * <p/>\n * Because RememberMe services are inherently client tier-specific and\n * therefore aplication-dependent, if you want {@code RememberMe} services enabled, you will have to specify an\n * instance yourself via the {@link #setRememberMeManager(RememberMeManager) setRememberMeManager}\n * mutator.  However if you're reading this JavaDoc with the\n * expectation of operating in a Web environment, take a look at the\n * {@code org.apache.shiro.web.DefaultWebSecurityManager} implementation, which\n * <em>does<\/em> support {@code RememberMe} services by default at startup.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.2\n */\npublic class DefaultSecurityManager extends SessionsSecurityManager {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(DefaultSecurityManager.class);\n\n    protected RememberMeManager rememberMeManager;\n\n    protected SubjectFactory subjectFactory;\n\n    protected SubjectBinder subjectBinder;\n\n    /**\n     * Default no-arg constructor.\n     */\n    public DefaultSecurityManager() {\n        super();\n        this.subjectFactory = new DefaultSubjectFactory(this);\n        this.subjectBinder = new SessionSubjectBinder();\n    }\n\n    /**\n     * Supporting constructor for a single-realm application.\n     *\n     * @param singleRealm the single realm used by this SecurityManager.\n     */\n    public DefaultSecurityManager(Realm singleRealm) {\n        this();\n        setRealm(singleRealm);\n    }\n\n    /**\n     * Supporting constructor for multiple {@link #setRealms realms}.\n     *\n     * @param realms the realm instances backing this SecurityManager.\n     */\n    public DefaultSecurityManager(Collection<Realm> realms) {\n        this();\n        setRealms(realms);\n    }\n\n    public SubjectFactory getSubjectFactory() {\n        return subjectFactory;\n    }\n\n    public void setSubjectFactory(SubjectFactory subjectFactory) {\n        this.subjectFactory = subjectFactory;\n        if (this.subjectFactory instanceof SecurityManagerAware) {\n            ((SecurityManagerAware) this.subjectFactory).setSecurityManager(this);\n        }\n    }\n\n    public SubjectBinder getSubjectBinder() {\n        return subjectBinder;\n    }\n\n    public void setSubjectBinder(SubjectBinder subjectBinder) {\n        this.subjectBinder = subjectBinder;\n    }\n\n    public RememberMeManager getRememberMeManager() {\n        return rememberMeManager;\n    }\n\n    public void setRememberMeManager(RememberMeManager rememberMeManager) {\n        this.rememberMeManager = rememberMeManager;\n    }\n\n    private AbstractRememberMeManager getRememberMeManagerForCipherAttributes() {\n        if (!(this.rememberMeManager instanceof AbstractRememberMeManager)) {\n            String msg = \"The convenience passthrough methods for setting remember me cipher attributes \" +\n                    \"are only available when the underlying RememberMeManager implementation is a subclass of \" +\n                    AbstractRememberMeManager.class.getName() + \".\";\n            throw new IllegalStateException(msg);\n        }\n        return (AbstractRememberMeManager) this.rememberMeManager;\n    }\n\n    public void setRememberMeCipher(Cipher cipher) {\n        getRememberMeManagerForCipherAttributes().setCipher(cipher);\n    }\n\n    public void setRememberMeCipherKey(byte[] bytes) {\n        getRememberMeManagerForCipherAttributes().setCipherKey(bytes);\n    }\n\n    public void setRememberMeCipherKeyHex(String hex) {\n        getRememberMeManagerForCipherAttributes().setCipherKeyHex(hex);\n    }\n\n    public void setRememberMeCipherKeyBase64(String base64) {\n        getRememberMeManagerForCipherAttributes().setCipherKeyBase64(base64);\n    }\n\n    public void setRememberMeEncryptionCipherKey(byte[] bytes) {\n        getRememberMeManagerForCipherAttributes().setEncryptionCipherKey(bytes);\n    }\n\n    public void setRememberMeEncryptionCipherKeyHex(String hex) {\n        getRememberMeManagerForCipherAttributes().setEncryptionCipherKeyHex(hex);\n    }\n\n    public void setRememberMeEncryptionCipherKeyBase64(String base64) {\n        getRememberMeManagerForCipherAttributes().setEncryptionCipherKeyBase64(base64);\n    }\n\n    public void setRememberMeDecryptionCipherKey(byte[] bytes) {\n        getRememberMeManagerForCipherAttributes().setDecryptionCipherKey(bytes);\n    }\n\n    public void setRememberMeDecryptionCipherKeyHex(String hex) {\n        getRememberMeManagerForCipherAttributes().setDecryptionCipherKeyHex(hex);\n    }\n\n    public void setRememberMeDecryptionCipherKeyBase64(String base64) {\n        getRememberMeManagerForCipherAttributes().setDecryptionCipherKeyBase64(base64);\n    }\n\n    protected Session getSession(Serializable id) {\n        checkValid(id);\n        return new DelegatingSession(this, id);\n    }\n\n    /**\n     * Creates a {@code Subject} instance for the user represented by the given method arguments.\n     *\n     * @param token    the {@code AuthenticationToken} submitted for the successful authentication.\n     * @param info     the {@code AuthenticationInfo} of a newly authenticated user.\n     * @param existing the existing {@code Subject} instance that initiated the authentication attempt\n     * @return the {@code Subject} instance that represents the context and session data for the newly\n     *         authenticated subject.\n     */\n    protected Subject createSubject(AuthenticationToken token, AuthenticationInfo info, Subject existing) {\n        Map<String, Object> context = new HashMap<String, Object>();\n        context.put(SubjectFactory.AUTHENTICATED, Boolean.TRUE);\n        context.put(SubjectFactory.AUTHENTICATION_TOKEN, token);\n        context.put(SubjectFactory.AUTHENTICATION_INFO, info);\n        if (existing != null) {\n            context.put(SubjectFactory.SUBJECT, existing);\n        }\n        return createSubject(context);\n    }\n\n    /**\n     * Binds a {@code Subject} instance created after authentication to the application for later use.\n     * <p/>\n     * The default implementation simply delegates to the internal {@link #getSubjectBinder() subjectBinder}.\n     *\n     * @param subject the {@code Subject} instance created after authentication to be bound to the application\n     *                for later use.\n     */\n    protected void bind(Subject subject) {\n        getSubjectBinder().bind(subject);\n    }\n\n    protected void rememberMeSuccessfulLogin(AuthenticationToken token, AuthenticationInfo info) {\n        RememberMeManager rmm = getRememberMeManager();\n        if (rmm != null) {\n            try {\n                rmm.onSuccessfulLogin(token, info);\n            } catch (Exception e) {\n                if (log.isWarnEnabled()) {\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() +\n                            \"] threw an exception during onSuccessfulLogin.  RememberMe services will not be \" +\n                            \"performed for account [\" + info + \"].\";\n                    log.warn(msg, e);\n                }\n            }\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"This \" + getClass().getName() + \" instance does not have a \" +\n                        \"[\" + RememberMeManager.class.getName() + \"] instance configured.  RememberMe services \" +\n                        \"will not be performed for account [\" + info + \"].\");\n            }\n        }\n    }\n\n    protected void rememberMeFailedLogin(AuthenticationToken token, AuthenticationException ex) {\n        RememberMeManager rmm = getRememberMeManager();\n        if (rmm != null) {\n            try {\n                rmm.onFailedLogin(token, ex);\n            } catch (Exception e) {\n                if (log.isWarnEnabled()) {\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() +\n                            \"] threw an exception during onFailedLogin for AuthenticationToken [\" +\n                            token + \"].\";\n                    log.warn(msg, e);\n                }\n            }\n        }\n    }\n\n    protected void rememberMeLogout(PrincipalCollection subjectPrincipals) {\n        RememberMeManager rmm = getRememberMeManager();\n        if (rmm != null) {\n            try {\n                rmm.onLogout(subjectPrincipals);\n            } catch (Exception e) {\n                if (log.isWarnEnabled()) {\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() +\n                            \"] threw an exception during onLogout for subject with principals [\" +\n                            subjectPrincipals + \"]\";\n                    log.warn(msg, e);\n                }\n            }\n        }\n    }\n\n    /**\n     * First authenticates the {@code AuthenticationToken} argument, and if successful, constructs a\n     * {@code Subject} instance representing the authenticated account's identity.\n     * <p/>\n     * Once constructed, the {@code Subject} instance is then {@link #bind bound} to the application for\n     * subsequent access before being returned to the caller.\n     *\n     * @param token the authenticationToken to process for the login attempt.\n     * @return a Subject representing the authenticated user.\n     * @throws AuthenticationException if there is a problem authenticating the specified {@code token}.\n     */\n    public Subject login(Subject subject, AuthenticationToken token) throws AuthenticationException {\n        AuthenticationInfo info;\n        try {\n            info = authenticate(token);\n            onSuccessfulLogin(token, info);\n        } catch (AuthenticationException ae) {\n            try {\n                onFailedLogin(token, ae);\n            } catch (Exception e) {\n                if (log.isInfoEnabled()) {\n                    log.info(\"onFailedLogin(AuthenticationToken,AuthenticationException) method threw an \" +\n                            \"exception.  Logging and propagating original AuthenticationException.\", e);\n                }\n            }\n            throw ae; //propagate\n        }\n        Subject replaced = createSubject(token, info, subject);\n        //TODO - is binding necessary anymore?  Shouldn't the Builders or Builder callers do this now?\n        bind(replaced);\n        return replaced;\n    }\n\n    protected void onSuccessfulLogin(AuthenticationToken token, AuthenticationInfo info) {\n        rememberMeSuccessfulLogin(token, info);\n    }\n\n    protected void onFailedLogin(AuthenticationToken token, AuthenticationException ae) {\n        rememberMeFailedLogin(token, ae);\n    }\n\n    protected void beforeLogout(PrincipalCollection subjectIdentifier) {\n        rememberMeLogout(subjectIdentifier);\n    }\n\n    /**\n     * This implementation attempts to resolve any session ID that may exist in the context argument by first\n     * passing it to the {@link #resolveSession(Map)} method.  The\n     * return value from that call is then used to attempt to resolve the subject identity via the\n     * {@link #resolvePrincipals(java.util.Map)} method.  The return value from that call is then used to create\n     * the {@code Subject} instance by calling\n     * <code>{@link #getSubjectFactory() getSubjectFactory()}.{@link SubjectFactory#createSubject(java.util.Map) createSubject}(resolvedContext);<\/code>\n     *\n     * @param context any data needed to direct how the Subject should be constructed.\n     * @return the {@code Subject} instance reflecting the specified initialization data.\n     * @see SubjectFactory#createSubject(java.util.Map)\n     * @since 1.0\n     */\n    public Subject createSubject(Map context) {\n        //Translate a session id if it exists into a Session object before sending to the SubjectFactory\n        //The SubjectFactory should not need to know how to acquire sessions as it is often environment\n        //specific - better to shield the SF from these details:\n        Map resolved = resolveSession(context);\n        //Similarly, the SubjectFactory should not have any concept of RememberMe - translate that here first\n        //if possible before handing off to the SubjectFactory:\n        resolved = resolvePrincipals(resolved);\n        return getSubjectFactory().createSubject(resolved);\n    }\n\n    /**\n     * Attempts to resolve any session id in the context to its corresponding {@link Session} and returns a\n     * context that represents this resolved {@code Session} to ensure it may be referenced if necessary by the\n     * invoked {@link SubjectFactory} that performs actual {@link Subject} construction.\n     * <p/>\n     * The session id, if it exists in the context map, should be available as a value under the\n     * <code>{@link SubjectFactory SubjectFactory}.{@link SubjectFactory#SESSION_ID SESSION_ID}<\/code> key constant.\n     * If a session is resolved, a copy of the original context Map is made to ensure the method argument is not\n     * changed, the resolved session is placed into the copy and the copy is returned.\n     * <p/>\n     * If there is a {@code Session} already in the context because that is what the caller wants to be used for\n     * {@code Subject} construction, or if no session is resolved, this method effectively does nothing and immediately\n     * returns the Map method argument unaltered.\n     *\n     * @param context the subject context data that may contain a session id that should be converted to a Session instance.\n     * @return The context Map to use to pass to a {@link SubjectFactory} for subject creation.\n     * @since 1.0\n     */\n    @SuppressWarnings({\"unchecked\"})\n    protected Map resolveSession(Map context) {\n        if (context.containsKey(SubjectFactory.SESSION)) {\n            log.debug(\"Context already contains a session.  Returning.\");\n            return context;\n        }\n        log.trace(\"No session found in context.  Looking for a session id to resolve in to a session.\");\n        //otherwise try to resolve a session if a session id exists:\n        Map copy = new HashMap(context);\n        Serializable sessionId = getSessionId(context);\n        if (sessionId != null) {\n            try {\n                Session session = getSession(sessionId);\n                copy.put(SubjectFactory.SESSION, session);\n            } catch (InvalidSessionException e) {\n                onInvalidSessionId(sessionId, e);\n                log.debug(\"Context referenced sessionId is invalid.  Ignoring and creating an anonymous \" +\n                        \"(session-less) Subject instance.\", e);\n            }\n        }\n        return copy;\n    }\n\n    /**\n     * Heuristically determines if the specified subject map can resolve a Subject identity ({@link PrincipalCollection})\n     * either directly or indirectly by value association.  This implementation returns {@code true} in the following\n     * two cases, {@code false} otherwise:\n     * <ol>\n     * <li>If the context {@link Map#containsKey contains} a key {@link SubjectFactory#PRINCIPALS}, it is assumed\n     * the identity has been explicitly provided already.<\/li>\n     * <li>If the context has a {@link Session} under the {@link SubjectFactory#SESSION} key, it attempts to resolve\n     * any identity associated with that {@code Session} instance.  If one can be found in the {@code Session}, it is\n     * assumed that {@code Session} identity should be used/retained.<\/li>\n     * <\/ol>\n     *\n     * @param context the subject context data that may provide (directly or indirectly through one of its values) a\n     *                {@link PrincipalCollection} identity.\n     * @return {@code true} if an identity can be resolved, {@code false} otherwise.\n     * @since 1.0\n     */\n    protected boolean containsIdentity(Map context) {\n        if (context.containsKey(SubjectFactory.PRINCIPALS)) {\n            log.trace(\"Context already contains an explicit identity.\");\n            return true;\n        }\n        if (context.containsKey(SubjectFactory.SESSION)) {\n            Session session = (Session) context.get(SubjectFactory.SESSION);\n            if (session != null) {\n                Object principals = session.getAttribute(SessionSubjectBinder.PRINCIPALS_SESSION_KEY);\n                if (principals != null) {\n                    log.trace(\"Context already contains an implicit (session-based) identity.\");\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Attempts to resolve an identity (a {@link PrincipalCollection}) for the context using heuristics.  The\n     * implementation strategy:\n     * <ol>\n     * <li>Check the context to see if it already {@link #containsIdentity(java.util.Map) contains an identity}.  If\n     * so, this method does nothing and returns the method argument unaltered.<\/li>\n     * <li>Check for a RememberMe identity by calling {@link #getRememberedIdentity()}.  If that method returns a\n     * non-null value, create a <em>copy<\/em> of the method argument, and place the remembered {@link PrincipalCollection}\n     * in the copied context map under the {@link SubjectFactory#PRINCIPALS} key and return that copied context.<\/li>\n     * <\/ol>\n     *\n     * @param context the subject context data that may provide (directly or indirectly through one of its values) a\n     *                {@link PrincipalCollection} identity.\n     * @return The context Map to use to pass to a {@link SubjectFactory} for subject creation.\n     * @since 1.0\n     */\n    @SuppressWarnings({\"unchecked\"})\n    protected Map resolvePrincipals(Map context) {\n        Map ctx = context;\n\n        if (!containsIdentity(context)) {\n            log.trace(\"No identity (PrincipalCollection) found in the context.  Looking for a remembered identity.\");\n            PrincipalCollection principals = getRememberedIdentity();\n            if (principals != null) {\n                log.debug(\"Found remembered PrincipalCollection.  Adding to the context to be used \" +\n                        \"for subject construction by the SubjectFactory.\");\n                ctx = new HashMap(context);\n                ctx.put(SubjectFactory.PRINCIPALS, principals);\n            } else {\n                log.trace(\"No remembered identity found.  Returning original context.\");\n            }\n        }\n\n        return ctx;\n    }\n\n    /**\n     * Allows subclasses to react to the fact that a specified/referenced session id was invalid.  Default\n     * implementation does nothing (no-op).\n     *\n     * @param sessionId the session id that was discovered to be invalid (no session, expired, etc).\n     * @param e         the exception thrown upon encountering the invalid session id\n     * @since 1.0\n     */\n    protected void onInvalidSessionId(Serializable sessionId, InvalidSessionException e) {\n    }\n\n    /**\n     * Utility method to retrieve the session id from the given subject context Map which will be used to resolve\n     * to a {@link Session} or {@code null} if there is no session id in the map.  If the session id exists, it is\n     * expected to be available in the map under the\n     * <code>{@link SubjectFactory SubjectFactory}.{@link SubjectFactory#SESSION_ID SESSION_ID}<\/code> constant.\n     *\n     * @param subjectContext the context map with data that will be used to construct a {@link Subject} instance via\n     *                       a {@link SubjectFactory}\n     * @return a session id to resolve to a {@link Session} instance or {@code null} if a session id could not be found.\n     * @see #createSubject(java.util.Map)\n     * @see SubjectFactory#createSubject(java.util.Map)\n     */\n    protected Serializable getSessionId(Map subjectContext) {\n        return (Serializable) subjectContext.get(SubjectFactory.SESSION_ID);\n    }\n\n    public void logout(Subject subject) {\n\n        if (subject == null) {\n            throw new IllegalArgumentException(\"Subject method argument cannot be null.\");\n        }\n\n        PrincipalCollection principals = subject.getPrincipals();\n\n        if (principals != null && !principals.isEmpty()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Logging out subject with primary principal {}\" + principals.getPrimaryPrincipal());\n            }\n            beforeLogout(principals);\n            Authenticator authc = getAuthenticator();\n            if (authc instanceof LogoutAware) {\n                ((LogoutAware) authc).onLogout(principals);\n            }\n        }\n\n        try {\n            unbind(subject);\n        } catch (Exception e) {\n            if (log.isDebugEnabled()) {\n                String msg = \"Unable to cleanly unbind Subject.  Ignoring (logging out).\";\n                log.debug(msg, e);\n            }\n        } finally {\n            try {\n                stopSession(subject);\n            } catch (Exception e) {\n                if (log.isDebugEnabled()) {\n                    String msg = \"Unable to cleanly stop Session for Subject [\" + subject.getPrincipal() + \"] \" +\n                            \"Ignoring (logging out).\";\n                    log.debug(msg, e);\n                }\n            }\n        }\n    }\n\n    protected void stopSession(Subject subject) {\n        Session s = subject.getSession(false);\n        if (s != null) {\n            //react to the id and not the session itself - the Session instance could be a proxy/delegate Session\n            //in which case the ID might be the only thing accessible.  Better to pass off the ID to the underlying\n            //SessionManager since this will successfully handle all cases.\n            Serializable sessionId = s.getId();\n            if (sessionId != null) {\n                try {\n                    stop(sessionId);\n                } catch (SessionException e) {\n                    //ignored - we're invalidating, and have no further need of the session anyway\n                    //log just in case someone wants to know:\n                    if (log.isDebugEnabled()) {\n                        String msg = \"Session for Subject [\" + (subject != null ? subject.getPrincipal() : null) +\n                                \"] has already been invalidated.  Logging exception since session exceptions are \" +\n                                \"irrelevant when the owning Subject has logged out.\";\n                        log.debug(msg, e);\n                    }\n                }\n            }\n        }\n    }\n\n    protected void unbind(Subject subject) {\n        getSubjectBinder().unbind(subject);\n    }\n\n    protected PrincipalCollection getRememberedIdentity() {\n        RememberMeManager rmm = getRememberMeManager();\n        if (rmm != null) {\n            try {\n                return rmm.getRememberedPrincipals();\n            } catch (Exception e) {\n                if (log.isWarnEnabled()) {\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() +\n                            \"] threw an exception during getRememberedPrincipals().\";\n                    log.warn(msg, e);\n                }\n            }\n        }\n        return null;\n    }\n\n    public Subject getSubject() {\n        Subject subject = getSubjectBinder().getSubject();\n        if (subject == null) {\n            subject = createSubject(Collections.EMPTY_MAP);\n            bind(subject);\n        }\n        return subject;\n    }\n\n    /**\n     * Acquires the {@link Subject Subject} that owns the {@link Session Session} with the specified {@code sessionId}.\n     * <p/>\n     * <b>Although simple in concept, this method provides incredibly powerful functionality:<\/b>\n     * <p/>\n     * The ability to reference a {@code Subject} and their server-side session\n     * <em>across clients of different mediums<\/em> such as web applications, Java applets,\n     * standalone C# clients over XMLRPC and/or SOAP, and many others. This is a <em>huge<\/em>\n     * benefit in heterogeneous enterprise applications.\n     * <p/>\n     * To maintain session integrity across client mediums, the {@code sessionId} <b>must<\/b> be transmitted\n     * to all client mediums securely (e.g. over SSL) to prevent man-in-the-middle attacks.  This\n     * is nothing new - all web applications are susceptible to the same problem when transmitting\n     * {@code Cookie}s or when using URL rewriting.  As long as the\n     * {@code sessionId} is transmitted securely, session integrity can be maintained.\n     *\n     * @param sessionId the id of the session that backs the desired Subject being acquired.\n     * @return the {@code Subject} that owns the {@code Session Session} with the specified {@code sessionId}\n     * @throws InvalidSessionException if the session identified by {@code sessionId} has been stopped, expired, or\n     *                                 doesn't exist.\n     * @throws AuthorizationException  if the executor of this method is not allowed to acquire the owning\n     *                                 {@code Subject}.  The reason for the exception is implementation-specific and\n     *                                 could be for any number of reasons.  A common reason in many systems would be\n     *                                 if one host tried to acquire a {@code Subject} based on a {@code Session} that\n     *                                 originated on an entirely different host (although it is not a Shiro requirement\n     *                                 this scenario is disallowed - its just an example that <em>may<\/em> throw an\n     *                                 Exception in some systems).\n     * @see org.apache.shiro.authz.HostUnauthorizedException\n     * @since 1.0\n     */\n    protected Subject getSubjectBySessionId(Serializable sessionId) throws InvalidSessionException, AuthorizationException {\n        Map<String, Object> context = new HashMap<String, Object>(1);\n        context.put(SubjectFactory.SESSION_ID, sessionId);\n        return createSubject(context);\n    }\n}\n","lineNo":341}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.mgt;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.HostAuthenticationToken;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.subject.DelegatingSubject;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Map;\n\n\n/**\n * Default {@link SubjectFactory SubjectFactory} implementation that creates {@link DelegatingSubject DelegatingSubject}\n * instances.\n *\n * @author Les Hazlewood\n * @since 1.0\n */\npublic class DefaultSubjectFactory implements SubjectFactory {\n\n    private static transient final Logger log = LoggerFactory.getLogger(DefaultSubjectFactory.class);\n\n    public DefaultSubjectFactory() {\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    protected static <E> E getTypedValue(Map context, String key, Class<E> type) {\n        E found = null;\n        Object o = context.get(key);\n        if (o != null) {\n            if (!type.isAssignableFrom(o.getClass())) {\n                String msg = \"Invalid object found in context Map under key [\" + key + \"].  Expected type \" +\n                        \"was [\" + type.getName() + \"], but the object under that key is of type \" +\n                        \"[\" + o.getClass().getName() + \"].\";\n                throw new IllegalArgumentException(msg);\n            }\n            found = (E) o;\n        }\n        return found;\n    }\n\n    protected SecurityManager getSecurityManager(Map context) {\n        SecurityManager securityManager = getTypedValue(context, SubjectFactory.SECURITY_MANAGER, SecurityManager.class);\n        if (securityManager == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No SecurityManager available in subject context map.  \" +\n                        \"Falling back to SecurityUtils.getSecurityManager() lookup.\");\n            }\n            securityManager = SecurityUtils.getSecurityManager();\n        }\n        if (securityManager == null) {\n            String msg = \"No \" + SecurityManager.class.getName() + \" instance was available in the subject context \" +\n                    \"via the \" + SubjectFactory.SECURITY_MANAGER + \" key.  \" +\n                    \"This is required for this \" + SubjectFactory.class.getSimpleName() + \" implementation to \" +\n                    \"function.\";\n            throw new IllegalStateException(msg);\n        }\n        return securityManager;\n    }\n\n    protected PrincipalCollection getPrincipals(Map context, Session session) {\n        PrincipalCollection principals = getTypedValue(context, SubjectFactory.PRINCIPALS, PrincipalCollection.class);\n\n        if (CollectionUtils.isEmpty(principals)) {\n            //check to see if they were just authenticated:\n            AuthenticationInfo info = getTypedValue(context, SubjectFactory.AUTHENTICATION_INFO, AuthenticationInfo.class);\n            if (info != null) {\n                principals = info.getPrincipals();\n            }\n        }\n\n        if (CollectionUtils.isEmpty(principals)) {\n            Subject subject = getTypedValue(context, SubjectFactory.SUBJECT, Subject.class);\n            if (subject != null) {\n                principals = subject.getPrincipals();\n            }\n        }\n\n        if (CollectionUtils.isEmpty(principals)) {\n            //try the session:\n            if (session != null) {\n                principals = (PrincipalCollection) session.getAttribute(SessionSubjectBinder.PRINCIPALS_SESSION_KEY);\n            }\n        }\n\n        return principals;\n    }\n\n    protected Session getSession(Map context) {\n        Session session = getTypedValue(context, SubjectFactory.SESSION, Session.class);\n\n        if (session == null) {\n            //try the Subject if it exists:\n            Subject existingSubject = getTypedValue(context, SubjectFactory.SUBJECT, Subject.class);\n            if (existingSubject != null) {\n                session = existingSubject.getSession(false);\n            }\n        }\n\n        return session;\n    }\n\n    protected String getHost(Map context, Session session) {\n        String host = getTypedValue(context, SubjectFactory.HOST, String.class);\n\n        if (host == null) {\n            //check to see if there is an AuthenticationToken from which to retrieve it:\n            AuthenticationToken token = getTypedValue(context, SubjectFactory.AUTHENTICATION_TOKEN, AuthenticationToken.class);\n            if (token instanceof HostAuthenticationToken) {\n                host = ((HostAuthenticationToken) token).getHost();\n            }\n        }\n\n        if (host == null) {\n            if (session != null) {\n                host = session.getHost();\n            }\n        }\n\n        return host;\n    }\n\n    protected boolean isAuthenticated(Map context, Session session) {\n        Boolean authc = getTypedValue(context, SubjectFactory.AUTHENTICATED, Boolean.class);\n        if (authc == null) {\n            //see if there is an AuthenticationInfo object.  If so, the very presence of one indicates a successful\n            //authentication attempt:\n            AuthenticationInfo info = getTypedValue(context, SubjectFactory.AUTHENTICATION_INFO, AuthenticationInfo.class);\n            authc = info != null;\n        }\n        if (!authc) {\n            //fall back to a session check:\n            if (session != null) {\n                Boolean sessionAuthc = (Boolean) session.getAttribute(SessionSubjectBinder.AUTHENTICATED_SESSION_KEY);\n                authc = sessionAuthc != null && sessionAuthc;\n            }\n        }\n        return authc;\n    }\n\n    public Subject createSubject(Map context) {\n        SecurityManager securityManager = getSecurityManager(context);\n        Session session = getSession(context);\n        PrincipalCollection principals = getPrincipals(context, session);\n        boolean authenticated = isAuthenticated(context, session);\n        String host = getHost(context, session);\n        return newSubjectInstance(principals, authenticated, host, session, securityManager);\n    }\n\n    protected Subject newSubjectInstance(PrincipalCollection principals, boolean authenticated, String host,\n                                         Session session, SecurityManager securityManager) {\n        return new DelegatingSubject(principals, authenticated, host, session, securityManager);\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.mgt;\n\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.HostAuthenticationToken;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.subject.DelegatingSubject;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.subject.Subject;\n\nimport java.util.Map;\n\n\n/**\n * Default {@link SubjectFactory SubjectFactory} implementation that creates {@link DelegatingSubject DelegatingSubject}\n * instances.\n *\n * @author Les Hazlewood\n * @since 1.0\n */\npublic class DefaultSubjectFactory implements SubjectFactory, SecurityManagerAware {\n\n    private SecurityManager securityManager;\n\n    public DefaultSubjectFactory() {\n    }\n\n    public DefaultSubjectFactory(SecurityManager securityManager) {\n        this.securityManager = securityManager;\n    }\n\n    public SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    public void setSecurityManager(SecurityManager securityManager) {\n        this.securityManager = securityManager;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    protected static <E> E getTypedValue(Map context, String key, Class<E> type) {\n        E found = null;\n        Object o = context.get(key);\n        if (o != null) {\n            if (!type.isAssignableFrom(o.getClass())) {\n                String msg = \"Invalid object found in context Map under key [\" + key + \"].  Expected type \" +\n                        \"was [\" + type.getName() + \"], but the object under that key is of type \" +\n                        \"[\" + o.getClass().getName() + \"].\";\n                throw new IllegalArgumentException(msg);\n            }\n            found = (E) o;\n        }\n        return found;\n    }\n\n    protected static boolean isEmpty(PrincipalCollection principals) {\n        return principals == null || principals.isEmpty();\n    }\n\n    protected PrincipalCollection getPrincipals(Map context, Session session) {\n        PrincipalCollection principals = getTypedValue(context, SubjectFactory.PRINCIPALS, PrincipalCollection.class);\n\n        if (isEmpty(principals)) {\n            //check to see if they were just authenticated:\n            AuthenticationInfo info = getTypedValue(context, SubjectFactory.AUTHENTICATION_INFO, AuthenticationInfo.class);\n            if (info != null) {\n                principals = info.getPrincipals();\n            }\n        }\n\n        if (isEmpty(principals)) {\n            Subject subject = getTypedValue(context, SubjectFactory.SUBJECT, Subject.class);\n            if (subject != null) {\n                principals = subject.getPrincipals();\n            }\n        }\n\n        if (isEmpty(principals)) {\n            //try the session:\n            if (session != null) {\n                principals = (PrincipalCollection) session.getAttribute(SessionSubjectBinder.PRINCIPALS_SESSION_KEY);\n            }\n        }\n\n        return principals;\n    }\n\n    protected Session getSession(Map context) {\n        Session session = getTypedValue(context, SubjectFactory.SESSION, Session.class);\n\n        if (session == null) {\n            //try the Subject if it exists:\n            Subject existingSubject = getTypedValue(context, SubjectFactory.SUBJECT, Subject.class);\n            if (existingSubject != null) {\n                session = existingSubject.getSession(false);\n            }\n        }\n\n        return session;\n    }\n\n    protected String getHost(Map context, Session session) {\n        String host = getTypedValue(context, SubjectFactory.HOST, String.class);\n\n        if (host == null) {\n            //check to see if there is an AuthenticationToken from which to retrieve it:\n            AuthenticationToken token = getTypedValue(context, SubjectFactory.AUTHENTICATION_TOKEN, AuthenticationToken.class);\n            if (token instanceof HostAuthenticationToken) {\n                host = ((HostAuthenticationToken) token).getHost();\n            }\n        }\n\n        if (host == null) {\n            if (session != null) {\n                host = session.getHost();\n            }\n        }\n\n        return host;\n    }\n\n    protected boolean isAuthenticated(Map context, Session session) {\n        Boolean authc = getTypedValue(context, SubjectFactory.AUTHENTICATED, Boolean.class);\n        if (authc == null) {\n            //see if there is an AuthenticationInfo object.  If so, the very presence of one indicates a successful\n            //authentication attempt:\n            AuthenticationInfo info = getTypedValue(context, SubjectFactory.AUTHENTICATION_INFO, AuthenticationInfo.class);\n            authc = info != null;\n        }\n        if (!authc) {\n            //fall back to a session check:\n            if (session != null) {\n                Boolean sessionAuthc = (Boolean) session.getAttribute(SessionSubjectBinder.AUTHENTICATED_SESSION_KEY);\n                authc = sessionAuthc != null && sessionAuthc;\n            }\n        }\n        return authc;\n    }\n\n    public Subject createSubject(Map context) {\n        Session session = getSession(context);\n        PrincipalCollection principals = getPrincipals(context, session);\n        boolean authenticated = isAuthenticated(context, session);\n        String host = getHost(context, session);\n        return newSubjectInstance(principals, authenticated, host, session, getSecurityManager());\n    }\n\n    protected Subject newSubjectInstance(PrincipalCollection principals, boolean authenticated, String host,\n                                         Session session, SecurityManager securityManager) {\n        return new DelegatingSubject(principals, authenticated, host, session, securityManager);\n    }\n}\n","lineNo":166}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.mgt;\n\nimport org.apache.shiro.mgt.DefaultSubjectFactory;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.mgt.SubjectFactory;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.web.WebUtils;\nimport org.apache.shiro.web.subject.WebDelegatingSubject;\nimport org.apache.shiro.web.subject.WebSubject;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.util.Map;\n\n/**\n * A {@code SubjectFactory} implementation that creates {@link WebDelegatingSubject} instances.\n * <p/>\n * {@code WebDelegatingSubject} instances are required if Request/Response objects are to be maintained across\n * threads when using the {@code Subject} {@link Subject#associateWith(java.util.concurrent.Callable) createCallable}\n * and {@link Subject#associateWith(Runnable) createRunnable} methods.\n *\n * @see #newSubjectInstance(org.apache.shiro.subject.PrincipalCollection, boolean, String, org.apache.shiro.session.Session, org.apache.shiro.mgt.SecurityManager)\n * @since 1.0\n */\npublic class DefaultWebSubjectFactory extends DefaultSubjectFactory {\n\n    public DefaultWebSubjectFactory() {\n        super();\n    }\n\n    protected ServletRequest getServletRequest(Map context) {\n        ServletRequest request = getTypedValue(context, SubjectFactory.SERVLET_REQUEST, ServletRequest.class);\n\n        //fall back on existing subject instance if it exists:\n        if (request == null) {\n            Subject existing = getTypedValue(context, SubjectFactory.SUBJECT, Subject.class);\n            if (existing instanceof WebSubject) {\n                request = ((WebSubject) existing).getServletRequest();\n            }\n        }\n        //last resort - try the thread-local (TODO - remove this if possible):\n        if (request == null) {\n            request = WebUtils.getServletRequest();\n        }\n\n        if (request == null) {\n            throw new IllegalStateException(\"ServletRequest is not available!  A ServletRequest must be present \" +\n                    \"in either the Subject context map, on an existing WebSubject or via the thread context.  This \" +\n                    \"exception is probably indicative of an erroneous application configuration.\");\n        }\n        return request;\n    }\n\n    protected ServletResponse getServletResponse(Map context) {\n        ServletResponse response = getTypedValue(context, SubjectFactory.SERVLET_RESPONSE, ServletResponse.class);\n\n        //fall back on existing subject instance if it exists:\n        if (response == null) {\n            Subject existing = getTypedValue(context, SubjectFactory.SUBJECT, Subject.class);\n            if (existing instanceof WebSubject) {\n                response = ((WebSubject) existing).getServletResponse();\n            }\n        }\n\n        //last resort - try the thread-local (TODO - remove this if possible):\n        if (response == null) {\n            response = WebUtils.getServletResponse();\n        }\n\n        if (response == null) {\n            throw new IllegalStateException(\"ServletResponse is not available!  A ServletResponse must be present \" +\n                    \"in either the Subject context map, on an existing WebSubject or via the thread context.  This \" +\n                    \"exception is probably indicative of an erroneous application configuration.\");\n        }\n\n        return response;\n    }\n\n    @Override\n    protected String getHost(Map context, Session session) {\n        String host = super.getHost(context, session);\n        if (host == null) {\n            ServletRequest request = getServletRequest(context);\n            host = request.getRemoteHost();\n        }\n        return host;\n    }\n\n    public Subject createSubject(Map context) {\n        SecurityManager securityManager = getSecurityManager(context);\n        Session session = getSession(context);\n        PrincipalCollection principals = getPrincipals(context, session);\n        boolean authenticated = isAuthenticated(context, session);\n        String host = getHost(context, session);\n        ServletRequest request = getServletRequest(context);\n        ServletResponse response = getServletResponse(context);\n        return newSubjectInstance(principals, authenticated, host, session, request, response, securityManager);\n    }\n\n    protected Subject newSubjectInstance(PrincipalCollection principals, boolean authenticated,\n                                         String host, Session session,\n                                         ServletRequest request, ServletResponse response,\n                                         SecurityManager securityManager) {\n        return new WebDelegatingSubject(principals, authenticated, host, session, request, response, securityManager);\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.mgt;\n\nimport org.apache.shiro.mgt.DefaultSubjectFactory;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.mgt.SubjectFactory;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.web.WebUtils;\nimport org.apache.shiro.web.subject.WebDelegatingSubject;\nimport org.apache.shiro.web.subject.WebSubject;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.util.Map;\n\n/**\n * A {@code SubjectFactory} implementation that creates {@link WebDelegatingSubject} instances.\n * <p/>\n * {@code WebDelegatingSubject} instances are required if Request/Response objects are to be maintained across\n * threads when using the {@code Subject} {@link Subject#associateWith(java.util.concurrent.Callable) createCallable}\n * and {@link Subject#associateWith(Runnable) createRunnable} methods.\n *\n * @see #newSubjectInstance(org.apache.shiro.subject.PrincipalCollection, boolean, String, org.apache.shiro.session.Session, org.apache.shiro.mgt.SecurityManager)\n * @since 1.0\n */\npublic class DefaultWebSubjectFactory extends DefaultSubjectFactory {\n\n    public DefaultWebSubjectFactory() {\n        super();\n    }\n\n    public DefaultWebSubjectFactory(SecurityManager securityManager) {\n        super(securityManager);\n    }\n\n    protected ServletRequest getServletRequest(Map context) {\n        ServletRequest request = getTypedValue(context, SubjectFactory.SERVLET_REQUEST, ServletRequest.class);\n\n        //fall back on existing subject instance if it exists:\n        if (request == null) {\n            Subject existing = getTypedValue(context, SubjectFactory.SUBJECT, Subject.class);\n            if (existing instanceof WebSubject) {\n                request = ((WebSubject) existing).getServletRequest();\n            }\n        }\n        //last resort - try the thread-local (TODO - remove this if possible):\n        if (request == null) {\n            request = WebUtils.getServletRequest();\n        }\n\n        if (request == null) {\n            throw new IllegalStateException(\"ServletRequest is not available!  A ServletRequest must be present \" +\n                    \"in either the Subject context map, on an existing WebSubject or via the thread context.  This \" +\n                    \"exception is probably indicative of an erroneous application configuration.\");\n        }\n        return request;\n    }\n\n    protected ServletResponse getServletResponse(Map context) {\n        ServletResponse response = getTypedValue(context, SubjectFactory.SERVLET_RESPONSE, ServletResponse.class);\n\n        //fall back on existing subject instance if it exists:\n        if (response == null) {\n            Subject existing = getTypedValue(context, SubjectFactory.SUBJECT, Subject.class);\n            if (existing instanceof WebSubject) {\n                response = ((WebSubject) existing).getServletResponse();\n            }\n        }\n\n        //last resort - try the thread-local (TODO - remove this if possible):\n        if (response == null) {\n            response = WebUtils.getServletResponse();\n        }\n\n        if (response == null) {\n            throw new IllegalStateException(\"ServletResponse is not available!  A ServletResponse must be present \" +\n                    \"in either the Subject context map, on an existing WebSubject or via the thread context.  This \" +\n                    \"exception is probably indicative of an erroneous application configuration.\");\n        }\n\n        return response;\n    }\n\n    @Override\n    protected String getHost(Map context, Session session) {\n        String host = super.getHost(context, session);\n        if (host == null) {\n            ServletRequest request = getServletRequest(context);\n            host = request.getRemoteHost();\n        }\n        return host;\n    }\n\n    public Subject createSubject(Map context) {\n        Session session = getSession(context);\n        PrincipalCollection principals = getPrincipals(context, session);\n        boolean authenticated = isAuthenticated(context, session);\n        String host = getHost(context, session);\n        ServletRequest request = getServletRequest(context);\n        ServletResponse response = getServletResponse(context);\n        return newSubjectInstance(principals, authenticated, host, session, request, response, getSecurityManager());\n    }\n\n    protected Subject newSubjectInstance(PrincipalCollection principals, boolean authenticated,\n                                         String host, Session session,\n                                         ServletRequest request, ServletResponse response,\n                                         SecurityManager securityManager) {\n        return new WebDelegatingSubject(principals, authenticated, host, session, request, response, securityManager);\n    }\n}\n","lineNo":110}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.cache;\n\nimport java.util.*;\n\n/**\n * A <code>MapCache<\/code> is a {@link Cache Cache} implementation that uses a backing {@link Map} instance to store\n * and retrieve cached data.\n *\n * @author Les Hazlewood\n * @since 1.0\n */\npublic class MapCache implements Cache {\n\n    /**\n     * Backing instance.\n     */\n    private final Map map;\n\n    /**\n     * The name of this cache.\n     */\n    private final String name;\n\n    public MapCache(String name, Map backingMap) {\n        if (name == null) {\n            throw new IllegalArgumentException(\"Cache name cannot be null.\");\n        }\n        if (backingMap == null) {\n            throw new IllegalArgumentException(\"Backing map cannot be null.\");\n        }\n        this.name = name;\n        this.map = backingMap;\n    }\n\n    public Object get(Object key) throws CacheException {\n        return map.get(key);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public void put(Object key, Object value) throws CacheException {\n        map.put(key, value);\n    }\n\n    public void remove(Object key) throws CacheException {\n        map.remove(key);\n    }\n\n    public void clear() throws CacheException {\n        map.clear();\n    }\n\n    public int size() {\n        return map.size();\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Set keys() {\n        Set keys = map.keySet();\n        if (!keys.isEmpty()) {\n            return Collections.unmodifiableSet(keys);\n        }\n        return Collections.EMPTY_SET;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Set values() {\n        if (!map.isEmpty()) {\n            Collection values = map.values();\n            if (values instanceof Set) {\n                return Collections.unmodifiableSet((Set) values);\n            } else {\n                return Collections.unmodifiableSet(new LinkedHashSet(values));\n            }\n        } else {\n            return Collections.EMPTY_SET;\n        }\n    }\n\n    public String toString() {\n        return getClass().getName() + \" : [\" + name + \"]\";\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.cache;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.shiro.util.Destroyable;\n\n/**\n * A <code>MapCache<\/code> is a {@link Cache Cache} implementation that uses a backing {@link Map} instance to store\n * and retrieve cached data.\n *\n * @author Les Hazlewood\n * @since 1.0\n */\npublic class MapCache implements Cache, Destroyable {\n\n    /**\n     * Backing instance.\n     */\n    private final Map map;\n\n    /**\n     * The name of this cache.\n     */\n    private final String name;\n\n    public MapCache(String name, Map backingMap) {\n        if (name == null) {\n            throw new IllegalArgumentException(\"Cache name cannot be null.\");\n        }\n        if (backingMap == null) {\n            throw new IllegalArgumentException(\"Backing map cannot be null.\");\n        }\n        this.name = name;\n        this.map = backingMap;\n    }\n\n    public Object get(Object key) throws CacheException {\n        return map.get(key);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public void put(Object key, Object value) throws CacheException {\n        map.put(key, value);\n    }\n\n    public void remove(Object key) throws CacheException {\n        map.remove(key);\n    }\n\n    public void clear() throws CacheException {\n        map.clear();\n    }\n\n    public int size() {\n        return map.size();\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Set keys() {\n        if (!map.isEmpty()) {\n            return Collections.unmodifiableSet(map.keySet());\n        } else {\n            return Collections.EMPTY_SET;\n        }\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Set values() {\n        if (!map.isEmpty()) {\n            Collection values = map.values();\n            if (values instanceof Set) {\n                return Collections.unmodifiableSet((Set) values);\n            } else {\n                return Collections.unmodifiableSet(new LinkedHashSet(values));\n            }\n        } else {\n            return Collections.EMPTY_SET;\n        }\n    }\n\n    public String toString() {\n        return getClass().getName() + \" : [\" + name + \"]\";\n    }\n\n    public void destroy() throws Exception {\n        clear();\n    }\n}\n","lineNo":76}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.servlet;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.config.Configuration;\nimport org.apache.shiro.config.ConfigurationException;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.util.ClassUtils;\nimport org.apache.shiro.util.LifecycleUtils;\nimport org.apache.shiro.util.ThreadContext;\nimport org.apache.shiro.util.ThreadState;\nimport org.apache.shiro.web.DefaultWebSecurityManager;\nimport org.apache.shiro.web.WebUtils;\nimport org.apache.shiro.web.config.IniWebConfiguration;\nimport org.apache.shiro.web.config.WebConfiguration;\nimport org.apache.shiro.web.filter.mgt.FilterChainResolver;\nimport org.apache.shiro.web.subject.WebSubject;\nimport org.apache.shiro.web.subject.support.WebSubjectThreadState;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.beans.PropertyDescriptor;\nimport java.io.IOException;\n\n/**\n * Main ServletFilter that configures and enables all Shiro functions within a web application.\n * <p/>\n * The following is a fully commented example that documents how to configure it:\n * <pre>&lt;filter&gt;\n * &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;\n * &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt;\n * &lt;init-param&gt;&lt;param-name&gt;config&lt;/param-name&gt;&lt;param-value&gt;\n * #\n * #NOTE:  This config looks pretty long - but its not - its only a few lines of actual config.\n * #       Everything else is just heavily commented to explain things in-depth. Feel free to delete any\n * #       comments that you don't want to read from your own configuration ;)\n * #\n * # Any commented values below that _don't_ start with 'example.pkg' are Shiro's defaults.  If you want to change any\n * # values on those lines, you only need to uncomment the lines you want to change.\n * #\n * [main]\n * # The 'main' section defines Shiro-wide configuration.\n * #\n * # The configuration is essentially an object graph definition in a .properties style format.  The beans defined\n * # would be those that are used to construct the application's SecurityManager.  It is essentially 'poor man's'\n * # dependency injection via a .properties format.\n * #\n * # --- Defining Realms ---\n * #\n * # Any Realm defined here will automatically be injected into Shiro's default SecurityManager created at start up.\n * # For example:\n * #\n * # myRealm = example.pkg.security.MyRealm\n * #\n * # This would instantiate the some.pkg.security.MyRealm class with a default no-arg constructor and inject it into\n * # the SecurityManager.  More than one realm can be defined if needed.  You can create graphs and reference\n * # other beans ('$' bean reference notation) while defining Realms and other objects:\n * #\n * # <b>connectionFactory<\/b> = example.pkg.ConnectionFactory\n * # connectionFactory.driverClassName = a.jdbc.Driver\n * # connectionFactory.username = aUsername\n * # connectionFactory.password = aPassword\n * # connectionFactory.minConnections = 3\n * # connectionFactory.maxConnections = 10\n * # ... etc...\n * #\n * # myJdbcRealm = example.pkg.jdbc.MyJdbcRealm\n * # myJdbcRealm.connectionFactory = <b>$connectionFactory<\/b>\n * # ... etc ...\n * #\n * # --- Realm Factories ---\n * #\n * # If the .properties style isn't robust enough for your needs, you also have the option of implementing the\n * # {@link org.apache.shiro.realm.RealmFactory org.apache.shiro.realm.RealmFactory} interface with more complex construction\n * # logic.  Then you can declare the implementation here instead.  The realms it returns will be injected in to the\n * # SecurityManager just as the individual Realms are.  For example:\n * #\n * # aRealmFactory = some.pkg.ClassThatImplementsRealmFactory\n * #\n * # --- SessionManager properties ---\n * #\n * # Except for Realms and RealmFactories, all other objects should be defined and set on the SecurityManager directly.\n * # The default 'securityManager' bean is an instance of {@link org.apache.shiro.web.DefaultWebSecurityManager}, so you\n * # can set any of its corresponding properties as necessary:\n * #\n * # someObject = some.fully.qualified.ClassName\n * # someObject.propertyN = foo\n * # ...\n * # securityManager.someObject = $someObject\n * #\n * # For example, if you wanted to change Shiro's default session mechanism, you can change the 'sessionMode' property.\n * # By default, Shiro's Session infrastructure in a web environment will use the\n * # Servlet container's HttpSession.  However, if you need to share session state across client types\n * # (e.g. Web MVC plus Java Web Start or Flash), or are doing distributed/shared Sessions for\n * # Single Sign On, HttpSessions aren't good enough.  You'll need to use Shiro's more powerful\n * # (and client-agnostic) session management.  You can enable this by uncommenting the following line\n * # and changing 'http' to 'native'\n * #\n * #securityManager.{@link org.apache.shiro.web.DefaultWebSecurityManager#setSessionMode(String) sessionMode} = http\n * #\n * [filters]\n * # This section defines the 'pool' of all Filters available to the url path definitions in the [urls] section below.\n * #\n * # The following commented values are already provided by Shiro by default and are immediately usable\n * # in the [urls] definitions below.  If you like, you may override any values by uncommenting only the lines\n * # you need to change.\n * #\n * # Each Filter is configured based on its functionality and/or protocol.  You should read each\n * # Filter's JavaDoc to fully understand what each does and how it works as well as how it would\n * # affect the user experience.\n * #\n * # Form-based Authentication filter:\n * #<a name=\"authc\"><\/a>authc = {@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter}\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setLoginUrl(String) loginUrl} = /login.jsp\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setUsernameParam(String) usernameParam} = username\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setPasswordParam(String) passwordParam} = password\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setRememberMeParam(String) rememberMeParam} = rememberMe\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setSuccessUrl(String) successUrl}  = /login.jsp\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setFailureKeyAttribute(String) failureKeyAttribute} = {@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#DEFAULT_ERROR_KEY_ATTRIBUTE_NAME}\n * #\n * # Http BASIC Authentication filter:\n * #<a name=\"authcBasic\"><\/a>authcBasic = {@link org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter}\n * #authcBasic.{@link org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter#setApplicationName(String) applicationName} = application\n * #\n * # Roles filter: requires the requesting user to have one or more roles for the request to continue.\n * # If they do not have the specified roles, they are redirected to the specified URL.\n * #<a name=\"roles\"><\/a>roles = {@link org.apache.shiro.web.filter.authz.RolesAuthorizationFilter}\n * #roles.{@link org.apache.shiro.web.filter.authz.RolesAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.\n * #\n * # Permissions filter: requires the requesting user to have one or more permissions for the request to\n * # continue, and if they do not, redirects them to the specified URL.\n * #<a name=\"perms\"><\/a>perms = {@link org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter}\n * #perms.{@link org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.  Many\n * # applications like to use the same url specified in roles.unauthorizedUrl above.\n * #\n * #\n * # Define your own filters here as you would any other object as described in the '[main]' section above (properties,\n * # $references, etc).  To properly handle url path matching (see the [urls] section below), your\n * # filter should extend the {@link org.apache.shiro.web.filter.PathMatchingFilter PathMatchingFilter} abstract class.\n * #\n * [urls]\n * # This section defines url path mappings.  Each mapping entry must be on a single line and conform to the\n * # following representation:\n * #\n * # ant_path_expression = path_specific_filter_chain_definition\n * #\n * # For any request that matches a specified path, the corresponding value defines a comma-delimited chain of\n * # filters to execute for that request.\n * #\n * # This is incredibly powerful in that you can define arbitrary filter chains for any given request pattern\n * # to greatly customize the security experience.\n * #\n * # The path_specific_filter_chain_definition must match the following format:\n * #\n * # filter1[optional_config1], filter2[optional_config2], ..., filterN[optional_configN]\n * #\n * # where 'filterN' is the name of an filter defined above in the [filters] section and\n * # '[optional_configN]' is an optional bracketed string that has meaning for that particular filter for\n * # _that particular path_.  If the filter does not need specific config for that url path, you may\n * # discard the brackets - that is, filterN[] just becomes filterN.\n * #\n * # And because filter tokens define chains, order matters!  Define the tokens for each path pattern\n * # in the order you want them to filter (comma-delimited).\n * #\n * # Finally, each filter is free to handle the response however it wants if its necessary\n * # conditions are not met (redirect, HTTP error code, direct rendering, etc).  Otherwise, it is expected to allow\n * # the request to continue through the chain on to the final destination view.\n * #\n * # Examples:\n * #\n * # To illustrate chain configuration, look at the /account/** mapping below.  This says\n * # &quot;apply the above 'authcBasic' filter to any request matching the '/account/**' pattern&quot;.  Since the\n * # 'authcBasic' filter does not need any path-specific config, it doesn't have any config brackets [].\n * #\n * # The /remoting/** definition on the other hand uses the 'roles' and 'perms' filters which do use\n * # bracket notation.  That definition says:\n * #\n * # &quot;To access /remoting/** urls, ensure that the user is first authenticated ('authcBasic'), then ensure that user\n * # has the 'b2bClient' role, and then finally ensure that they have the 'remote:invoke:lan,wan' permission.&quot;\n * #\n * # (Note that because elements within brackets [ ] are comma-delimited themselves, we needed to escape the permission\n * # actions of 'lan,wan' with quotes.  If we didn't do that, the permission filter would interpret\n * # the text between the brackets as two permissions: 'remote:invoke:lan' and 'wan' instead of the\n * # single desired 'remote:invoke:lan,wan' token.  So, you can use quotes wherever you need to escape internal\n * # commas.)\n * #\n * /account/** = <a href=\"#authcBasic\">authcBasic<\/a>\n * /remoting/** = <a href=\"#authcBasic\">authcBasic<\/a>, <a href=\"#roles\">roles<\/a>[b2bClient], <a href=\"#perms\">perms<\/a>[remote:invoke:\"lan,wan\"]\n * #\n * &lt;/param-value&gt;&lt;/init-param&gt;\n * &lt;/filter&gt;\n * #\n * #\n * &lt;filter-mapping&gt;\n * &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;\n * &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n * &lt;/filter-mapping&gt;<\/pre>\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class ShiroFilter extends OncePerRequestFilter {\n\n    //TODO - complete JavaDoc\n\n    public static final String CONFIG_CLASS_NAME_INIT_PARAM_NAME = \"configClassName\";\n    public static final String CONFIG_INIT_PARAM_NAME = \"config\";\n    public static final String CONFIG_URL_INIT_PARAM_NAME = \"configUrl\";\n\n    private static final Logger log = LoggerFactory.getLogger(ShiroFilter.class);\n\n    protected String config;\n    protected String configUrl;\n    protected String configClassName;\n    protected WebConfiguration configuration;\n\n    // Reference to the security manager used by this filter\n    protected SecurityManager securityManager;\n\n    // Used to determine which chain should handle an incoming request/response\n    private FilterChainResolver filterChainResolver;\n\n    public ShiroFilter() {\n        this.configClassName = IniWebConfiguration.class.getName();\n    }\n\n    public WebConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    public void setConfiguration(WebConfiguration configuration) {\n        this.configuration = configuration;\n    }\n\n    public SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected void setSecurityManager(SecurityManager sm) {\n        this.securityManager = sm;\n    }\n\n    public FilterChainResolver getFilterChainResolver() {\n        return filterChainResolver;\n    }\n\n    public void setFilterChainResolver(FilterChainResolver filterChainResolver) {\n        this.filterChainResolver = filterChainResolver;\n    }\n\n    protected void onFilterConfigSet() throws Exception {\n        applyInitParams();\n        WebConfiguration config = configure();\n        setConfiguration(config);\n        ensureSecurityManager(config);\n        applyFilterChainResolver(config);\n    }\n\n    /**\n     * Ensures a SecurityManager exists, and if not, creates one automatically and ensures it is available for\n     * use during requests.\n     *\n     * @param config the configuration for this filter.\n     */\n    protected void ensureSecurityManager(Configuration config) {\n        SecurityManager securityManager = getSecurityManager();\n        boolean existing = securityManager != null;\n        if (!existing && config != null) {\n            securityManager = config.getSecurityManager();\n        }\n\n        // If the config doesn't return a security manager, build one by default.\n        if (securityManager == null) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Configuration instance [\" + config + \"] did not provide a SecurityManager.  No config \" +\n                        \"specified?  Defaulting to a \" + DefaultWebSecurityManager.class.getName() + \" instance...\");\n            }\n            securityManager = new DefaultWebSecurityManager();\n        }\n\n        if (!existing) {\n            setSecurityManager(securityManager);\n        }\n    }\n\n    protected void applyFilterChainResolver(WebConfiguration config) {\n        FilterChainResolver resolver = getFilterChainResolver();\n        if (resolver == null && config != null) {\n            resolver = config.getFilterChainResolver();\n            if (resolver != null) {\n                setFilterChainResolver(resolver);\n            }\n        }\n    }\n\n    protected void applyInitParams() {\n\n        String configCN = getInitParam(CONFIG_CLASS_NAME_INIT_PARAM_NAME);\n        if (configCN != null) {\n            if (ClassUtils.isAvailable(configCN)) {\n                this.configClassName = configCN;\n            } else {\n                String msg = \"configClassName fully qualified class name value [\" + configCN + \"] is not \" +\n                        \"available in the classpath.  Please ensure you have typed it correctly and the \" +\n                        \"corresponding class or jar is in the classpath.\";\n                throw new ConfigurationException(msg);\n            }\n        }\n\n        this.config = getInitParam(CONFIG_INIT_PARAM_NAME);\n        this.configUrl = getInitParam(CONFIG_URL_INIT_PARAM_NAME);\n    }\n\n    protected WebConfiguration configure() {\n        WebConfiguration webConfiguration = (WebConfiguration) ClassUtils.newInstance(this.configClassName);\n        applyFilterConfig(webConfiguration);\n        applyUrlConfig(webConfiguration);\n        applyEmbeddedConfig(webConfiguration);\n        LifecycleUtils.init(webConfiguration);\n        return webConfiguration;\n    }\n\n    protected void applyFilterConfig(WebConfiguration conf) {\n        if (log.isDebugEnabled()) {\n            String msg = \"Attempting to inject the FilterConfig (using 'setFilterConfig' method) into the \" +\n                    \"instantiated WebConfiguration for any wrapped Filter initialization...\";\n            log.debug(msg);\n        }\n        try {\n            PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"filterConfig\");\n            if (pd != null) {\n                PropertyUtils.setProperty(conf, \"filterConfig\", getFilterConfig());\n            }\n        } catch (Exception e) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Error setting FilterConfig on WebConfiguration instance.\", e);\n            }\n        }\n    }\n\n    protected void applyEmbeddedConfig(WebConfiguration conf) {\n        if (this.config != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"config\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"config\", this.config);\n                } else {\n                    String msg = \"The 'config' filter param was specified, but there is no \" +\n                            \"'setConfig(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                            \"not require the 'config' filter param, please comment it out, or if you do need it, \" +\n                            \"please ensure your Configuration class has a 'setConfig(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'config' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected void applyUrlConfig(WebConfiguration conf) {\n        if (this.configUrl != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"configUrl\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"configUrl\", this.configUrl);\n                } else {\n                    String msg = \"The 'configUrl' filter param was specified, but there is no \" +\n                            \"'setConfigUrl(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                            \"not require the 'configUrl' filter param, please comment it out, or if you do need it, \" +\n                            \"please ensure your Configuration class has a 'setConfigUrl(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'configUrl' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected boolean isHttpSessions() {\n        SecurityManager secMgr = getSecurityManager();\n        return !(secMgr instanceof DefaultWebSecurityManager) || ((DefaultWebSecurityManager) secMgr).isHttpSessionMode();\n    }\n\n    /**\n     * Wraps the original HttpServletRequest in a {@link ShiroHttpServletRequest}, which is required for supporting\n     * Servlet Specification behavior backed by a {@link org.apache.shiro.subject.Subject Subject} instance.\n     *\n     * @param orig the original Servlet Container-provided incoming {@code HttpServletRequest} instance.\n     * @return {@link ShiroHttpServletRequest ShiroHttpServletRequest} instance wrapping the original.\n     * @since 1.0\n     */\n    protected ServletRequest wrapServletRequest(HttpServletRequest orig) {\n        return new ShiroHttpServletRequest(orig, getServletContext(), isHttpSessions());\n    }\n\n    /**\n     * Prepares the {@code ServletRequest} instance that will be passed to the {@code FilterChain} for request\n     * processing.\n     * <p/>\n     * If the {@code ServletRequest} is an instance of {@link HttpServletRequest}, the value returned from this method\n     * is obtained by calling {@link #wrapServletRequest(javax.servlet.http.HttpServletRequest)} to allow Shiro-specific\n     * HTTP behavior, otherwise the original {@code ServletRequest} argument is returned.\n     *\n     * @param request  the incoming ServletRequest\n     * @param response the outgoing ServletResponse\n     * @param chain    the Servlet Container provided {@code FilterChain} that will receive the returned request.\n     * @return the {@code ServletRequest} instance that will be passed to the {@code FilterChain} for request processing.\n     * @since 1.0\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected ServletRequest prepareServletRequest(ServletRequest request, ServletResponse response, FilterChain chain) {\n        ServletRequest toUse = request;\n        if (request instanceof HttpServletRequest) {\n            HttpServletRequest http = (HttpServletRequest) request;\n            toUse = wrapServletRequest(http);\n        }\n        return toUse;\n    }\n\n    /**\n     * Returns a new {@link ShiroHttpServletResponse} instance, wrapping the {@code orig} argument, in order to provide\n     * correct URL rewriting behavior required by the Servlet Specification when using Shiro-based sessions (and not\n     * Servlet Container HTTP-based sessions).\n     *\n     * @param orig    the original {@code HttpServletResponse} instance provided by the Servlet Container.\n     * @param request the {@code ShiroHttpServletRequest} instance wrapping the original request.\n     * @return the wrapped ServletResponse instance to use during {@link FilterChain} execution.\n     * @since 1.0\n     */\n    protected ServletResponse wrapServletResponse(HttpServletResponse orig, ShiroHttpServletRequest request) {\n        return new ShiroHttpServletResponse(orig, getServletContext(), request);\n    }\n\n    /**\n     * Prepares the {@code ServletResponse} instance that will be passed to the {@code FilterChain} for request\n     * processing.\n     * <p/>\n     * This implementation delegates to {@link #wrapServletRequest(javax.servlet.http.HttpServletRequest)}\n     * only if Shiro-based sessions are enabled (that is, !{@link #isHttpSessions()}) and the request instance is a\n     * {@link ShiroHttpServletRequest}.  This ensures that any URL rewriting that occurs is handled correctly using the\n     * Shiro-managed Session's sessionId and not a servlet container session ID.\n     * <p/>\n     * If HTTP-based sessions are enabled (the default), then this method does nothing and just returns the\n     * {@code ServletResponse} argument as-is, relying on the default Servlet Container URL rewriting logic.\n     *\n     * @param request  the incoming ServletRequest\n     * @param response the outgoing ServletResponse\n     * @param chain    the Servlet Container provided {@code FilterChain} that will receive the returned request.\n     * @return the {@code ServletResponse} instance that will be passed to the {@code FilterChain} during request processing.\n     * @since 1.0\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected ServletResponse prepareServletResponse(ServletRequest request, ServletResponse response, FilterChain chain) {\n        ServletResponse toUse = response;\n        if (!isHttpSessions() && (request instanceof ShiroHttpServletRequest) &&\n                (response instanceof HttpServletResponse)) {\n            //the ShiroHttpServletResponse exists to support URL rewriting for session ids.  This is only needed if\n            //using Shiro sessions (i.e. not simple HttpSession based sessions):\n            toUse = wrapServletResponse((HttpServletResponse) response, (ShiroHttpServletRequest) request);\n        }\n        return toUse;\n    }\n\n    /**\n     * Binds the current request/response pair and additional information to a thread-local to be made available to Shiro\n     * during the course of the request/response process.  This implementation binds the request/response pair and\n     * any associated Subject (and its relevant thread-based data) via a {@link org.apache.shiro.web.subject.support.WebSubjectThreadState}.  That\n     * threadState is returned so it can be used during thread cleanup at the end of the request.\n     * <p/>\n     * To guarantee properly cleaned threads in a thread-pooled Servlet Container environment, the corresponding\n     * {@link #unbind} method must be called in a {@code finally} block to ensure that the thread remains clean even\n     * in the event of an exception thrown while processing the request.  This class's\n     * {@link #doFilterInternal(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)}\n     * method implementation does indeed function this way.\n     *\n     * @param request  the incoming ServletRequest\n     * @param response the outgoing ServletResponse\n     * @return ThreadStateManager the thread state used to bind necessary state for the request execution.\n     * @since 1.0\n     */\n    protected ThreadState bind(ServletRequest request, ServletResponse response) {\n        ThreadContext.bind(getSecurityManager());\n        //currently the WebRememberMeManager needs the request/response bound in order to create the subject instance:\n        WebUtils.bind(request);\n        WebUtils.bind(response);\n\n        WebSubject subject = new WebSubject.Builder().buildWebSubject();\n        ThreadState threadState = new WebSubjectThreadState(subject);\n        threadState.bind();\n        return threadState;\n    }\n\n    /**\n     * Unbinds (removes out of scope) the current {@code ServletRequest} and {@link ServletResponse}.\n     * <p/>\n     * This method implementation merely clears <em>all<\/em> thread state by calling\n     * {@link org.apache.shiro.subject.support.SubjectThreadState#clear()} to guarantee\n     * that <em>everything<\/em> that might have been bound to the thread by Shiro has been removed to ensure the\n     * underlying Thread may be safely re-used in a thread-pooled Servlet Container environment.\n     *\n     * @param threadState the web thread state created when the request and response first were initiated.\n     * @since 1.0\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected void unbind(ThreadState threadState) {\n        threadState.clear();\n    }\n\n    /**\n     * Updates any 'native'  Session's last access time that might exist to the timestamp when this method is called.\n     * If native sessions are not enabled (that is, standard Servlet container sessions are being used) or there is no\n     * session ({@code subject.getSession(false) == null}), this method does nothing.\n     * <p/>This method implementation merely calls\n     * <code>Session.{@link org.apache.shiro.session.Session#touch() touch}()<\/code> on the session.\n     *\n     * @param request  incoming request - ignored, but available to subclasses that might wish to override this method\n     * @param response outgoing response - ignored, but available to subclasses that might wish to override this method\n     * @since 1.0\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected void updateSessionLastAccessTime(ServletRequest request, ServletResponse response) {\n        if (!isHttpSessions()) { //'native' sessions\n            Subject subject = SecurityUtils.getSubject();\n            //Subject should never _ever_ be null, but just in case:\n            if (subject != null) {\n                Session session = subject.getSession(false);\n                if (session != null) {\n                    try {\n                        session.touch();\n                    } catch (Throwable t) {\n                        log.error(\"session.touch() method invocation has failed.  Unable to update\" +\n                                \"the corresponding session's last access time based on the incoming request.\", t);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * {@code doFilterInternal} implementation that sets-up, executes, and cleans-up a Shiro-filtered request.  It\n     * performs the following ordered operations:\n     * <ol>\n     * <li>{@link #prepareServletRequest(ServletRequest, ServletResponse, FilterChain) Prepares}\n     * the incoming {@code ServletRequest} for use during Shiro's processing<\/li>\n     * <li>{@link #prepareServletResponse(ServletRequest, ServletResponse, FilterChain) Prepares}\n     * the outgoing {@code ServletResponse} for use during Shiro's processing<\/li>\n     * <li>{@link #bind(ServletRequest,ServletResponse) Binds} the request/response pair\n     * and associated data to the currently executing thread for use during processing<\/li>\n     * <li>{@link #updateSessionLastAccessTime(javax.servlet.ServletRequest, javax.servlet.ServletResponse) Updates}\n     * any associated session's {@link org.apache.shiro.session.Session#getLastAccessTime() lastAccessTime} to ensure\n     * session timeouts are honored<\/li>\n     * <li>{@link #executeChain(ServletRequest,ServletResponse,FilterChain) Executes}\n     * the appropriate {@code FilterChain}<\/li>\n     * <li>{@link #unbind(org.apache.shiro.util.ThreadState) Unbinds} the request/response\n     * pair and any other associated data from the thread.\n     * <\/ul>\n     * <p/>\n     * The {@link #unbind(org.apache.shiro.util.ThreadState) unbind} method is called in a\n     * {@code finally} block to guarantee the thread may be cleanly re-used in a thread-pooled Servlet Container\n     * environment.\n     *\n     * @param servletRequest  the incoming {@code ServletRequest}\n     * @param servletResponse the outgoing {@code ServletResponse}\n     * @param chain           the container-provided {@code FilterChain} to execute\n     * @throws ServletException if an error occurs\n     * @throws IOException      if an IO error occurs\n     */\n    protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)\n            throws ServletException, IOException {\n\n        ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain);\n        ServletResponse response = prepareServletResponse(request, servletResponse, chain);\n\n        ThreadState threadState = bind(request, response);\n\n        try {\n            updateSessionLastAccessTime(request, response);\n            executeChain(request, response, chain);\n        } finally {\n            unbind(threadState);\n        }\n    }\n\n    /**\n     * Returns the {@code FilterChain} to execute for the given request.\n     * <p/>\n     * The {@code origChain} argument is the\n     * original {@code FilterChain} supplied by the Servlet Container, but it may be modified to provide\n     * more behavior by pre-pending further chains according to the Shiro configuration.\n     * <p/>\n     * This implementation returns the chain that will actually be executed by acquiring the chain from a\n     * {@link #getFilterChainResolver() filterChainResolver}.  The resolver determines exactly which chain to\n     * execute, typically based on URL configuration.  If no chain is returned from the resolver call\n     * (returns {@code null}), then the {@code origChain} will be returned by default.\n     *\n     * @param request   the incoming ServletRequest\n     * @param response  the outgoing ServletResponse\n     * @param origChain the original {@code FilterChain} provided by the Servlet Container\n     * @return the {@link FilterChain} to execute for the given request\n     * @since 1.0\n     */\n    protected FilterChain getExecutionChain(ServletRequest request, ServletResponse response, FilterChain origChain) {\n        FilterChain chain = origChain;\n        FilterChain resolved = null;\n        FilterChainResolver resolver = getFilterChainResolver();\n        if (resolver != null) {\n            resolved = resolver.getChain(request, response, origChain);\n        } else {\n            log.trace(\"No FilterChainResolver configured.  Attempting (deprecated) WebConfiguration resolution.\");\n            WebConfiguration config = getConfiguration();\n            if (config != null) {\n                //noinspection deprecation\n                resolved = config.getChain(request, response, origChain);\n            }\n        }\n        if (resolved != null) {\n            log.trace(\"Resolved a configured FilterChain for the current request.\");\n            chain = resolved;\n        } else {\n            log.trace(\"No FilterChain configured for the current request.  Using the default.\");\n        }\n\n        return chain;\n    }\n\n    /**\n     * Executes a {@link FilterChain} for the given request.\n     * <p/>\n     * This implementation first delegates to\n     * <code>{@link #getExecutionChain(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain) getExecutionChain}<\/code>\n     * to allow the application's Shiro configuration to determine exactly how the chain should execute.  The resulting\n     * value from that call is then executed directly by calling the returned {@code FilterChain}'s\n     * {@link FilterChain#doFilter doFilter} method.  That is:\n     * <pre>\n     * FilterChain chain = {@link #getExecutionChain}(request, response, origChain);\n     * chain.{@link FilterChain#doFilter doFilter}(request,response);<\/pre>\n     *\n     * @param request   the incoming ServletRequest\n     * @param response  the outgoing ServletResponse\n     * @param origChain the Servlet Container-provided chain that may be wrapped further by an application-configured\n     *                  chain of Filters.\n     * @throws IOException      if the underlying {@code chain.doFilter} call results in an IOException\n     * @throws ServletException if the underlying {@code chain.doFilter} call results in a ServletException\n     * @since 1.0\n     */\n    protected void executeChain(ServletRequest request, ServletResponse response, FilterChain origChain)\n            throws IOException, ServletException {\n        FilterChain chain = getExecutionChain(request, response, origChain);\n        chain.doFilter(request, response);\n    }\n\n    /**\n     * Destroys this Filter by destroying the {@link #getConfiguration() configuration} object.\n     */\n    public void destroy() {\n        LifecycleUtils.destroy(getConfiguration());\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.servlet;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.shiro.config.Configuration;\nimport org.apache.shiro.config.ConfigurationException;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.util.ClassUtils;\nimport org.apache.shiro.util.LifecycleUtils;\nimport static org.apache.shiro.util.StringUtils.clean;\nimport org.apache.shiro.util.ThreadContext;\nimport org.apache.shiro.util.ThreadState;\nimport org.apache.shiro.web.DefaultWebSecurityManager;\nimport org.apache.shiro.web.WebUtils;\nimport org.apache.shiro.web.config.IniWebConfiguration;\nimport org.apache.shiro.web.config.WebConfiguration;\nimport org.apache.shiro.web.subject.WebSubject;\nimport org.apache.shiro.web.subject.support.WebSubjectThreadState;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.beans.PropertyDescriptor;\nimport java.io.IOException;\n\n/**\n * Main ServletFilter that configures and enables all Shiro functions within a web application.\n * <p/>\n * The following is a fully commented example that documents how to configure it:\n * <pre>&lt;filter&gt;\n * &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;\n * &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt;\n * &lt;init-param&gt;&lt;param-name&gt;config&lt;/param-name&gt;&lt;param-value&gt;\n * #\n * #NOTE:  This config looks pretty long - but its not - its only a few lines of actual config.\n * #       Everything else is just heavily commented to explain things in-depth. Feel free to delete any\n * #       comments that you don't want to read from your own configuration ;)\n * #\n * # Any commented values below that _don't_ start with 'example.pkg' are Shiro's defaults.  If you want to change any\n * # values on those lines, you only need to uncomment the lines you want to change.\n * #\n * [main]\n * # The 'main' section defines Shiro-wide configuration.\n * #\n * # The configuration is essentially an object graph definition in a .properties style format.  The beans defined\n * # would be those that are used to construct the application's SecurityManager.  It is essentially 'poor man's'\n * # dependency injection via a .properties format.\n * #\n * # --- Defining Realms ---\n * #\n * # Any Realm defined here will automatically be injected into Shiro's default SecurityManager created at start up.\n * # For example:\n * #\n * # myRealm = example.pkg.security.MyRealm\n * #\n * # This would instantiate the some.pkg.security.MyRealm class with a default no-arg constructor and inject it into\n * # the SecurityManager.  More than one realm can be defined if needed.  You can create graphs and reference\n * # other beans ('$' bean reference notation) while defining Realms and other objects:\n * #\n * # <b>connectionFactory<\/b> = example.pkg.ConnectionFactory\n * # connectionFactory.driverClassName = a.jdbc.Driver\n * # connectionFactory.username = aUsername\n * # connectionFactory.password = aPassword\n * # connectionFactory.minConnections = 3\n * # connectionFactory.maxConnections = 10\n * # ... etc...\n * #\n * # myJdbcRealm = example.pkg.jdbc.MyJdbcRealm\n * # myJdbcRealm.connectionFactory = <b>$connectionFactory<\/b>\n * # ... etc ...\n * #\n * # --- Realm Factories ---\n * #\n * # If the .properties style isn't robust enough for your needs, you also have the option of implementing the\n * # {@link org.apache.shiro.realm.RealmFactory org.apache.shiro.realm.RealmFactory} interface with more complex construction\n * # logic.  Then you can declare the implementation here instead.  The realms it returns will be injected in to the\n * # SecurityManager just as the individual Realms are.  For example:\n * #\n * # aRealmFactory = some.pkg.ClassThatImplementsRealmFactory\n * #\n * # --- SessionManager properties ---\n * #\n * # Except for Realms and RealmFactories, all other objects should be defined and set on the SecurityManager directly.\n * # The default 'securityManager' bean is an instance of {@link org.apache.shiro.web.DefaultWebSecurityManager}, so you\n * # can set any of its corresponding properties as necessary:\n * #\n * # someObject = some.fully.qualified.ClassName\n * # someObject.propertyN = foo\n * # ...\n * # securityManager.someObject = $someObject\n * #\n * # For example, if you wanted to change Shiro's default session mechanism, you can change the 'sessionMode' property.\n * # By default, Shiro's Session infrastructure in a web environment will use the\n * # Servlet container's HttpSession.  However, if you need to share session state across client types\n * # (e.g. Web MVC plus Java Web Start or Flash), or are doing distributed/shared Sessions for\n * # Single Sign On, HttpSessions aren't good enough.  You'll need to use Shiro's more powerful\n * # (and client-agnostic) session management.  You can enable this by uncommenting the following line\n * # and changing 'http' to 'native'\n * #\n * #securityManager.{@link org.apache.shiro.web.DefaultWebSecurityManager#setSessionMode(String) sessionMode} = http\n * #\n * [filters]\n * # This section defines the 'pool' of all Filters available to the url path definitions in the [urls] section below.\n * #\n * # The following commented values are already provided by Shiro by default and are immediately usable\n * # in the [urls] definitions below.  If you like, you may override any values by uncommenting only the lines\n * # you need to change.\n * #\n * # Each Filter is configured based on its functionality and/or protocol.  You should read each\n * # Filter's JavaDoc to fully understand what each does and how it works as well as how it would\n * # affect the user experience.\n * #\n * # Form-based Authentication filter:\n * #<a name=\"authc\"><\/a>authc = {@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter}\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setLoginUrl(String) loginUrl} = /login.jsp\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setUsernameParam(String) usernameParam} = username\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setPasswordParam(String) passwordParam} = password\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setRememberMeParam(String) rememberMeParam} = rememberMe\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setSuccessUrl(String) successUrl}  = /login.jsp\n * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setFailureKeyAttribute(String) failureKeyAttribute} = {@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#DEFAULT_ERROR_KEY_ATTRIBUTE_NAME}\n * #\n * # Http BASIC Authentication filter:\n * #<a name=\"authcBasic\"><\/a>authcBasic = {@link org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter}\n * #authcBasic.{@link org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter#setApplicationName(String) applicationName} = application\n * #\n * # Roles filter: requires the requesting user to have one or more roles for the request to continue.\n * # If they do not have the specified roles, they are redirected to the specified URL.\n * #<a name=\"roles\"><\/a>roles = {@link org.apache.shiro.web.filter.authz.RolesAuthorizationFilter}\n * #roles.{@link org.apache.shiro.web.filter.authz.RolesAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.\n * #\n * # Permissions filter: requires the requesting user to have one or more permissions for the request to\n * # continue, and if they do not, redirects them to the specified URL.\n * #<a name=\"perms\"><\/a>perms = {@link org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter}\n * #perms.{@link org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.  Many\n * # applications like to use the same url specified in roles.unauthorizedUrl above.\n * #\n * #\n * # Define your own filters here as you would any other object as described in the '[main]' section above (properties,\n * # $references, etc).  To properly handle url path matching (see the [urls] section below), your\n * # filter should extend the {@link org.apache.shiro.web.filter.PathMatchingFilter PathMatchingFilter} abstract class.\n * #\n * [urls]\n * # This section defines url path mappings.  Each mapping entry must be on a single line and conform to the\n * # following representation:\n * #\n * # ant_path_expression = path_specific_filter_chain_definition\n * #\n * # For any request that matches a specified path, the corresponding value defines a comma-delimited chain of\n * # filters to execute for that request.\n * #\n * # This is incredibly powerful in that you can define arbitrary filter chains for any given request pattern\n * # to greatly customize the security experience.\n * #\n * # The path_specific_filter_chain_definition must match the following format:\n * #\n * # filter1[optional_config1], filter2[optional_config2], ..., filterN[optional_configN]\n * #\n * # where 'filterN' is the name of an filter defined above in the [filters] section and\n * # '[optional_configN]' is an optional bracketed string that has meaning for that particular filter for\n * # _that particular path_.  If the filter does not need specific config for that url path, you may\n * # discard the brackets - that is, filterN[] just becomes filterN.\n * #\n * # And because filter tokens define chains, order matters!  Define the tokens for each path pattern\n * # in the order you want them to filter (comma-delimited).\n * #\n * # Finally, each filter is free to handle the response however it wants if its necessary\n * # conditions are not met (redirect, HTTP error code, direct rendering, etc).  Otherwise, it is expected to allow\n * # the request to continue through the chain on to the final destination view.\n * #\n * # Examples:\n * #\n * # To illustrate chain configuration, look at the /account/** mapping below.  This says\n * # &quot;apply the above 'authcBasic' filter to any request matching the '/account/**' pattern&quot;.  Since the\n * # 'authcBasic' filter does not need any path-specific config, it doesn't have any config brackets [].\n * #\n * # The /remoting/** definition on the other hand uses the 'roles' and 'perms' filters which do use\n * # bracket notation.  That definition says:\n * #\n * # &quot;To access /remoting/** urls, ensure that the user is first authenticated ('authcBasic'), then ensure that user\n * # has the 'b2bClient' role, and then finally ensure that they have the 'remote:invoke:lan,wan' permission.&quot;\n * #\n * # (Note that because elements within brackets [ ] are comma-delimited themselves, we needed to escape the permission\n * # actions of 'lan,wan' with quotes.  If we didn't do that, the permission filter would interpret\n * # the text between the brackets as two permissions: 'remote:invoke:lan' and 'wan' instead of the\n * # single desired 'remote:invoke:lan,wan' token.  So, you can use quotes wherever you need to escape internal\n * # commas.)\n * #\n * /account/** = <a href=\"#authcBasic\">authcBasic<\/a>\n * /remoting/** = <a href=\"#authcBasic\">authcBasic<\/a>, <a href=\"#roles\">roles<\/a>[b2bClient], <a href=\"#perms\">perms<\/a>[remote:invoke:\"lan,wan\"]\n * #\n * &lt;/param-value&gt;&lt;/init-param&gt;\n * &lt;/filter&gt;\n * #\n * #\n * &lt;filter-mapping&gt;\n * &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;\n * &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n * &lt;/filter-mapping&gt;<\/pre>\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class ShiroFilter extends OncePerRequestFilter {\n\n    //TODO - complete JavaDoc\n\n    public static final String CONFIG_CLASS_NAME_INIT_PARAM_NAME = \"configClassName\";\n    public static final String CONFIG_INIT_PARAM_NAME = \"config\";\n    public static final String CONFIG_URL_INIT_PARAM_NAME = \"configUrl\";\n\n    private static final Logger log = LoggerFactory.getLogger(ShiroFilter.class);\n\n    protected String config;\n    protected String configUrl;\n    protected String configClassName;\n    protected WebConfiguration configuration;\n\n    // Reference to the security manager used by this filter\n    protected SecurityManager securityManager;\n\n    public ShiroFilter() {\n        this.configClassName = IniWebConfiguration.class.getName();\n    }\n\n    public WebConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    public void setConfiguration(WebConfiguration configuration) {\n        this.configuration = configuration;\n    }\n\n    public SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected void setSecurityManager(org.apache.shiro.mgt.SecurityManager sm) {\n        this.securityManager = sm;\n    }\n\n    protected void onFilterConfigSet() throws Exception {\n        applyInitParams();\n        WebConfiguration config = configure();\n        setConfiguration(config);\n\n        // Retrieve and store a reference to the security manager\n        SecurityManager securityManager = ensureSecurityManager(config);\n        setSecurityManager(securityManager);\n    }\n\n    /**\n     * Retrieves the security manager for the given configuration.\n     *\n     * @param config the configuration for this filter.\n     * @return the security manager that this filter should use.\n     */\n    protected SecurityManager ensureSecurityManager(Configuration config) {\n        SecurityManager securityManager = config.getSecurityManager();\n\n        // If the config doesn't return a security manager, build one by default.\n        if (securityManager == null) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Configuration instance [\" + config + \"] did not provide a SecurityManager.  No config \" +\n                        \"specified?  Defaulting to a \" + DefaultWebSecurityManager.class.getName() + \" instance...\");\n            }\n            securityManager = new DefaultWebSecurityManager();\n        }\n\n        return securityManager;\n    }\n\n    protected void applyInitParams() {\n        FilterConfig config = getFilterConfig();\n\n        String configCN = clean(config.getInitParameter(CONFIG_CLASS_NAME_INIT_PARAM_NAME));\n        if (configCN != null) {\n            if (ClassUtils.isAvailable(configCN)) {\n                this.configClassName = configCN;\n            } else {\n                String msg = \"configClassName fully qualified class name value [\" + configCN + \"] is not \" +\n                        \"available in the classpath.  Please ensure you have typed it correctly and the \" +\n                        \"corresponding class or jar is in the classpath.\";\n                throw new ConfigurationException(msg);\n            }\n        }\n\n        this.config = clean(config.getInitParameter(CONFIG_INIT_PARAM_NAME));\n        this.configUrl = clean(config.getInitParameter(CONFIG_URL_INIT_PARAM_NAME));\n    }\n\n    protected WebConfiguration configure() {\n        WebConfiguration conf = (WebConfiguration) ClassUtils.newInstance(this.configClassName);\n        applyFilterConfig(conf);\n        applyUrlConfig(conf);\n        applyEmbeddedConfig(conf);\n        LifecycleUtils.init(conf);\n        return conf;\n    }\n\n    protected void applyFilterConfig(WebConfiguration conf) {\n        if (log.isDebugEnabled()) {\n            String msg = \"Attempting to inject the FilterConfig (using 'setFilterConfig' method) into the \" +\n                    \"instantiated WebConfiguration for any wrapped Filter initialization...\";\n            log.debug(msg);\n        }\n        try {\n            PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"filterConfig\");\n            if (pd != null) {\n                PropertyUtils.setProperty(conf, \"filterConfig\", getFilterConfig());\n            }\n        } catch (Exception e) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Error setting FilterConfig on WebConfiguration instance.\", e);\n            }\n        }\n    }\n\n    protected void applyEmbeddedConfig(WebConfiguration conf) {\n        if (this.config != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"config\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"config\", this.config);\n                } else {\n                    String msg = \"The 'config' filter param was specified, but there is no \" +\n                            \"'setConfig(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                            \"not require the 'config' filter param, please comment it out, or if you do need it, \" +\n                            \"please ensure your Configuration instance has a 'setConfig(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'config' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected void applyUrlConfig(WebConfiguration conf) {\n        if (this.configUrl != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"configUrl\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"configUrl\", this.configUrl);\n                } else {\n                    String msg = \"The 'configUrl' filter param was specified, but there is no \" +\n                            \"'setConfigUrl(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                            \"not require the 'configUrl' filter param, please comment it out, or if you do need it, \" +\n                            \"please ensure your Configuration instance has a 'setConfigUrl(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'configUrl' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected boolean isHttpSessions() {\n        SecurityManager secMgr = getSecurityManager();\n        return !(secMgr instanceof DefaultWebSecurityManager) || ((DefaultWebSecurityManager) secMgr).isHttpSessionMode();\n    }\n\n    /**\n     * Wraps the original HttpServletRequest in a {@link ShiroHttpServletRequest}, which is required for supporting\n     * Servlet Specification behavior backed by a {@link org.apache.shiro.subject.Subject Subject} instance.\n     *\n     * @param orig the original Servlet Container-provided incoming {@code HttpServletRequest} instance.\n     * @return {@link ShiroHttpServletRequest ShiroHttpServletRequest} instance wrapping the original.\n     * @since 1.0\n     */\n    protected ServletRequest wrapServletRequest(HttpServletRequest orig) {\n        return new ShiroHttpServletRequest(orig, getServletContext(), isHttpSessions());\n    }\n\n    /**\n     * 'Prepare's the {@code ServletRequest} instance that will be passed to the {@code FilterChain} for request\n     * processing.\n     * <p/>\n     * If the {@code ServletRequest} is an instance of {@link HttpServletRequest}, the value returned from this method\n     * is obtained by calling {@link #wrapServletRequest(javax.servlet.http.HttpServletRequest)} to allow Shiro-specific\n     * HTTP behavior, otherwise the original {@code ServletRequest} argument is returned.\n     *\n     * @param request  the incoming ServletRequest\n     * @param response the outgoing ServletResponse\n     * @param chain    the Servlet Container provided {@code FilterChain} that will receive the returned request.\n     * @return the {@code ServletRequest} instance that will be passed to the {@code FilterChain} for request processing.\n     * @since 1.0\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected ServletRequest prepareServletRequest(ServletRequest request, ServletResponse response, FilterChain chain) {\n        ServletRequest toUse = request;\n        if (request instanceof HttpServletRequest) {\n            HttpServletRequest http = (HttpServletRequest) request;\n            toUse = wrapServletRequest(http);\n        }\n        return toUse;\n    }\n\n    /**\n     * Returns a new {@link ShiroHttpServletResponse} instance, wrapping the {@code orig} argument, in order to provide\n     * correct URL rewriting behavior required by the Servlet Specification when using Shiro-based sessions (and not\n     * Servlet Container HTTP-based sessions).\n     *\n     * @param orig    the original {@code HttpServletResponse} instance provided by the Servlet Container.\n     * @param request the {@code ShiroHttpServletRequest} instance wrapping the original request.\n     * @return the wrapped ServletResponse instance to use during {@link FilterChain} execution.\n     * @since 1.0\n     */\n    protected ServletResponse wrapServletResponse(HttpServletResponse orig, ShiroHttpServletRequest request) {\n        return new ShiroHttpServletResponse(orig, getServletContext(), request);\n    }\n\n    /**\n     * 'Prepare's the {@code ServletResponse} instance that will be passed to the {@code FilterChain} for request\n     * processing.\n     * <p/>\n     * This implementation delegates to {@link #wrapServletRequest(javax.servlet.http.HttpServletRequest)}\n     * only if Shiro-based sessions are enabled (that is, !{@link #isHttpSessions()}) and the request instance is a\n     * {@link ShiroHttpServletRequest}.  This ensures that any URL rewriting that occurs is handled correctly using the\n     * Shiro-managed Session's sessionId and not a servlet container session ID.\n     * <p/>\n     * If HTTP-based sessions are enabled (the default), then this method does nothing and just returns the\n     * {@code ServletResponse} argument as-is, relying on the default Servlet Container URL rewriting logic.\n     *\n     * @param request  the incoming ServletRequest\n     * @param response the outgoing ServletResponse\n     * @param chain    the Servlet Container provided {@code FilterChain} that will receive the returned request.\n     * @return the {@code ServletResponse} instance that will be passed to the {@code FilterChain} during request processing.\n     * @since 1.0\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected ServletResponse prepareServletResponse(ServletRequest request, ServletResponse response, FilterChain chain) {\n        ServletResponse toUse = response;\n        if (!isHttpSessions() && (request instanceof ShiroHttpServletRequest) &&\n                (response instanceof HttpServletResponse)) {\n            //the ShiroHttpServletResponse exists to support URL rewriting for session ids.  This is only needed if\n            //using Shiro sessions (i.e. not simple HttpSession based sessions):\n            toUse = wrapServletResponse((HttpServletResponse) response, (ShiroHttpServletRequest) request);\n        }\n        return toUse;\n    }\n\n    /**\n     * Binds the current request/response pair and additional information to a thread-local to be made available to Shiro\n     * during the course of the request/response process.  This implementation binds the request/response pair and\n     * any associated Subject (and its relevant thread-based data) via a {@link org.apache.shiro.web.subject.support.WebSubjectThreadState}.  That\n     * threadState is returned so it can be used during thread cleanup at the end of the request.\n     * <p/>\n     * To guarantee properly cleaned threads in a thread-pooled Servlet Container environment, the corresponding\n     * {@link #unbind} method must be called in a {@code finally} block to ensure that the thread remains clean even\n     * in the event of an exception thrown while processing the request.  This class's\n     * {@link #doFilterInternal(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)}\n     * method implement does indeed perform this.\n     *\n     * @param request  the incoming ServletRequest\n     * @param response the outgoing ServletResponse\n     * @return ThreadStateManager the thread state used to bind necessary state for the request execution.\n     * @since 1.0\n     */\n    protected ThreadState bind(ServletRequest request, ServletResponse response) {\n        ThreadContext.bind(getSecurityManager());\n        //currently the WebRememberMeManager needs the request/response bound in order to create the subject instance:\n        WebUtils.bind(request);\n        WebUtils.bind(response);\n\n        WebSubject subject = new WebSubject.Builder().buildWebSubject();\n        ThreadState threadState = new WebSubjectThreadState(subject);\n        threadState.bind();\n        return threadState;\n    }\n\n    /**\n     * Unbinds (removes out of scope) the current {@code ServletRequest} and {@link ServletResponse}.\n     * <p/>\n     * This method implementation merely clears <em>all<\/em> thread state by calling\n     * {@link org.apache.shiro.subject.support.SubjectThreadState#clear()} to guarantee\n     * that <em>everything<\/em> that might have been bound to the thread by Shiro has been removed to ensure the\n     * underlying Thread may be safely re-used in a thread-pooled Servlet Container environment.\n     *\n     * @param threadState the web thread state created when the request and response first were initiated.\n     * @since 1.0\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected void unbind(ThreadState threadState) {\n        threadState.clear();\n    }\n\n    /**\n     * Updates any 'native'  Session's last access time that might exist to the timestamp when this method is called.\n     * If native sessions are not enabled (that is, standard Servlet container sessions are being used) or there is no\n     * session ({@code subject.getSession(false) == null}), this method does nothing.\n     * <p/>This method implementation merely calls\n     * <code>Session.{@link org.apache.shiro.session.Session#touch() touch}()<\/code> on the session.\n     *\n     * @param request  incoming request - ignored, but available to subclasses that might wish to override this method\n     * @param response outgoing response - ignored, but available to subclasses that might wish to override this method\n     * @since 1.0\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    protected void updateSessionLastAccessTime(ServletRequest request, ServletResponse response) {\n        if (!isHttpSessions()) { //'native' sessions\n            Subject subject = getSecurityManager().getSubject();\n            //Subject should never _ever_ be null, but just in case:\n            if (subject != null) {\n                Session session = subject.getSession(false);\n                if (session != null) {\n                    try {\n                        session.touch();\n                    } catch (Throwable t) {\n                        log.error(\"session.touch() method invocation has failed.  Unable to update\" +\n                                \"the corresponding session's last access time based on the incoming request.\", t);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * {@code doFilterInternal} implementation that sets-up, executes, and cleans-up a Shiro-filtered request.  It\n     * performs the following ordered operations:\n     * <ol>\n     * <li>{@link #prepareServletRequest(ServletRequest, ServletResponse, FilterChain) Prepares}\n     * the incoming {@code ServletRequest} for use during Shiro's processing<\/li>\n     * <li>{@link #prepareServletResponse(ServletRequest, ServletResponse, FilterChain) Prepares}\n     * the outgoing {@code ServletResponse} for use during Shiro's processing<\/li>\n     * <li>{@link #bind(ServletRequest,ServletResponse) Binds} the request/response pair\n     * and associated data to the currently executing thread for use during processing<\/li>\n     * <li>{@link #updateSessionLastAccessTime(javax.servlet.ServletRequest, javax.servlet.ServletResponse) Updates}\n     * any associated session's {@link org.apache.shiro.session.Session#getLastAccessTime() lastAccessTime} to ensure\n     * session timeouts are honored<\/li>\n     * <li>{@link #executeChain(ServletRequest,ServletResponse,FilterChain) Executes}\n     * the appropriate {@code FilterChain}<\/li>\n     * <li>{@link #unbind(org.apache.shiro.util.ThreadState) Unbinds} the request/response\n     * pair and any other associated data from the thread.\n     * <\/ul>\n     * <p/>\n     * The {@link #unbind(org.apache.shiro.util.ThreadState) unbind} method is called in a\n     * {@code finally} block to guarantee the thread may be cleanly re-used in a thread-pooled Servlet Container\n     * environment.\n     *\n     * @param servletRequest  the incoming {@code ServletRequest}\n     * @param servletResponse the outgoing {@code ServletResponse}\n     * @param chain           the container-provided {@code FilterChain} to execute\n     * @throws ServletException if an error occurs\n     * @throws IOException      if an IO error occurs\n     */\n    protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)\n            throws ServletException, IOException {\n\n        ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain);\n        ServletResponse response = prepareServletResponse(request, servletResponse, chain);\n\n        ThreadState threadState = bind(request, response);\n\n        try {\n            updateSessionLastAccessTime(request, response);\n            executeChain(request, response, chain);\n        } finally {\n            unbind(threadState);\n        }\n    }\n\n    /**\n     * Returns the {@code FilterChain} to execute for the given request.\n     * <p/>\n     * The {@code origChain} argument is the\n     * original {@code FilterChain} supplied by the Servlet Container, but it may be modified to provide\n     * more behavior by appending further chains according to the Shiro configuration.\n     * <p/>\n     * This implementation returns the chain that will actually be executed by acquiring the chain from a\n     * <code>{@link #getConfiguration() getConfiguration()}.{@link org.apache.shiro.web.config.WebConfiguration#getChain getChain}(request,response,origChain)<\/code>\n     * method call.  The configuration itself determines which chain to execute, typically based on URL configuration.\n     * If no chain is returned from this method call (returns {@code null}), then the {@code origChain}\n     * will be returned by default.\n     *\n     * @param request   the incoming ServletRequest\n     * @param response  the outgoing ServletResponse\n     * @param origChain the original {@code FilterChain} provided by the Servlet Container\n     * @return the {@link FilterChain} to execute for the given request\n     * @since 1.0\n     */\n    protected FilterChain getExecutionChain(ServletRequest request, ServletResponse response, FilterChain origChain) {\n        FilterChain chain = getConfiguration().getChain(request, response, origChain);\n        if (chain == null) {\n            chain = origChain;\n            log.trace(\"No security filter chain configured for the current request.  Using default.\");\n        } else {\n            log.trace(\" Using configured filter chain for the current request.\");\n        }\n        return chain;\n    }\n\n    /**\n     * Executes a {@link FilterChain} for the given request.\n     * <p/>\n     * This implementation first delegates to\n     * <code>{@link #getExecutionChain(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain) getExecutionChain}<\/code>\n     * to allow the application's Shiro configuration to determine exactly how the chain should execute.  The resulting\n     * value from that call is then executed directly by calling the returned {@code FilterChain}'s\n     * {@link FilterChain#doFilter doFilter} method.  That is:\n     * <p/>\n     * <pre>\n     * FilterChain chain = {@link #getExecutionChain}(request, response, origChain);\n     * chain.{@link FilterChain#doFilter doFilter}(request,response);<\/pre>\n     *\n     * @param request   the incoming ServletRequest\n     * @param response  the outgoing ServletResponse\n     * @param origChain the Servlet Container-provided chain that may be wrapped further by an application-configured\n     *                  chain of Filters.\n     * @throws IOException      if the underlying {@code chain.doFilter} call results in an IOException\n     * @throws ServletException if the underlying {@code chain.doFilter} call results in a ServletException\n     * @since 1.0\n     */\n    protected void executeChain(ServletRequest request, ServletResponse response, FilterChain origChain)\n            throws IOException, ServletException {\n        FilterChain chain = getExecutionChain(request, response, origChain);\n        chain.doFilter(request, response);\n    }\n\n    /**\n     * Destroys this Filter by destroying the {@link #getConfiguration() configuration} object.\n     */\n    public void destroy() {\n        LifecycleUtils.destroy(getConfiguration());\n    }\n}\n","lineNo":645}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.spring.remoting;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.subject.ExecutionException;\nimport org.apache.shiro.subject.Subject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.remoting.support.DefaultRemoteInvocationExecutor;\nimport org.springframework.remoting.support.RemoteInvocation;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.InetAddress;\nimport java.util.concurrent.Callable;\n\n\n/**\n * An implementation of the Spring {@link org.springframework.remoting.support.RemoteInvocationExecutor}\n * that binds a {@code sessionId} to the incoming thread to make it available to the {@code SecurityManager}\n * implementation during the thread execution.  The {@code SecurityManager} implementation can use this sessionId\n * to reconstitute the {@code Subject} instance based on persistent state in the corresponding {@code Session}.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SecureRemoteInvocationExecutor extends DefaultRemoteInvocationExecutor {\n\n    //TODO - complete JavaDoc\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    private static final Logger log = LoggerFactory.getLogger(SecureRemoteInvocationExecutor.class);\n\n    /**\n     * The SecurityManager used to retrieve realms that should be associated with the\n     * created <tt>Subject<\/tt>s upon remote invocation.\n     */\n    private SecurityManager securityManager;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    public void setSecurityManager(org.apache.shiro.mgt.SecurityManager securityManager) {\n        this.securityManager = securityManager;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    @SuppressWarnings({\"unchecked\"})\n    public Object invoke(final RemoteInvocation invocation, final Object targetObject)\n            throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n\n        try {\n            SecurityManager securityManager =\n                    this.securityManager != null ? this.securityManager : SecurityUtils.getSecurityManager();\n\n            Subject.Builder builder = new Subject.Builder(securityManager);\n\n            InetAddress inet = (InetAddress) invocation.getAttribute(SecureRemoteInvocationFactory.INET_ADDRESS_KEY);\n            if (inet != null) {\n                builder.inetAddress(inet);\n            }\n\n            Serializable sessionId = invocation.getAttribute(SecureRemoteInvocationFactory.SESSION_ID_KEY);\n            if (sessionId != null) {\n                builder.sessionId(sessionId);\n            } else {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"RemoteInvocation did not contain a Shiro Session id attribute under \" +\n                            \"key [\" + SecureRemoteInvocationFactory.SESSION_ID_KEY + \"].  A Subject based \" +\n                            \"on an existing Session will not be available during the method invocatin.\");\n                }\n            }\n\n            Subject subject = builder.buildSubject();\n            return subject.execute(new Callable() {\n                public Object call() throws Exception {\n                    return SecureRemoteInvocationExecutor.super.invoke(invocation, targetObject);\n                }\n            });\n        } catch (ExecutionException e) {\n            Throwable cause = e.getCause();\n            if (cause instanceof NoSuchMethodException) {\n                throw (NoSuchMethodException) cause;\n            } else if (cause instanceof IllegalAccessException) {\n                throw (IllegalAccessException) cause;\n            } else if (cause instanceof InvocationTargetException) {\n                throw (InvocationTargetException) cause;\n            } else {\n                throw new InvocationTargetException(cause);\n            }\n        } catch (Throwable t) {\n            throw new InvocationTargetException(t);\n        }\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.spring.remoting;\n\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.mgt.SubjectFactory;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.subject.support.SubjectThreadState;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.remoting.support.DefaultRemoteInvocationExecutor;\nimport org.springframework.remoting.support.RemoteInvocation;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\n\n\n/**\n * An implementation of the Spring {@link org.springframework.remoting.support.RemoteInvocationExecutor}\n * that binds a {@code sessionId} to the incoming thread to make it available to the {@code SecurityManager}\n * implementation during the thread execution.  The {@code SecurityManager} implementation can use this sessionId\n * to reconstitute the {@code Subject} instance based on persistent state in the corresponding {@code Session}.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SecureRemoteInvocationExecutor extends DefaultRemoteInvocationExecutor {\n\n    //TODO - complete JavaDoc\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    private static final Logger log = LoggerFactory.getLogger(SecureRemoteInvocationExecutor.class);\n\n    /**\n     * The SecurityManager used to retrieve realms that should be associated with the\n     * created <tt>Subject<\/tt>s upon remote invocation.\n     */\n    private SecurityManager securityManager;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    public void setSecurityManager(org.apache.shiro.mgt.SecurityManager securityManager) {\n        this.securityManager = securityManager;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    @SuppressWarnings({\"unchecked\"})\n    public Object invoke(RemoteInvocation invocation, Object targetObject) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n\n        SubjectThreadState subjectThreadState = null;\n\n        try {\n            Map context = new HashMap();\n            InetAddress inet = (InetAddress) invocation.getAttribute(SecureRemoteInvocationFactory.INET_ADDRESS_KEY);\n            if (inet != null) {\n                context.put(SubjectFactory.INET_ADDRESS, inet);\n            }\n\n            Serializable sessionId = invocation.getAttribute(SecureRemoteInvocationFactory.SESSION_ID_KEY);\n            if (sessionId != null) {\n                context.put(SubjectFactory.SESSION_ID, sessionId);\n            } else {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"RemoteInvocation did not contain a Shiro Session id attribute under \" +\n                            \"key [\" + SecureRemoteInvocationFactory.SESSION_ID_KEY + \"].  A Subject based \" +\n                            \"on an existing Session will not be available during the method invocatin.\");\n                }\n            }\n\n            Subject subject = securityManager.createSubject(context);\n            subjectThreadState = new SubjectThreadState(subject);\n            subjectThreadState.bind();\n\n            return super.invoke(invocation, targetObject);\n        } catch (NoSuchMethodException nsme) {\n            throw nsme;\n        } catch (IllegalAccessException iae) {\n            throw iae;\n        } catch (InvocationTargetException ite) {\n            throw ite;\n        } catch (Throwable t) {\n            throw new InvocationTargetException(t);\n        } finally {\n            if (subjectThreadState != null) {\n                subjectThreadState.clear();\n            }\n        }\n    }\n}\n","lineNo":88}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.session.mgt;\n\nimport org.apache.shiro.session.*;\nimport org.apache.shiro.session.mgt.eis.SessionDAO;\nimport org.apache.shiro.util.ThreadContext;\nimport org.easymock.EasyMock;\nimport static org.easymock.EasyMock.*;\nimport org.easymock.IArgumentMatcher;\nimport org.junit.After;\nimport static org.junit.Assert.*;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Map;\nimport java.util.UUID;\n\n/**\n * Unit test for the {@link DefaultSessionManager DefaultSessionManager} implementation.\n */\npublic class DefaultSessionManagerTest {\n\n    DefaultSessionManager sm = null;\n\n    @Before\n    public void setup() {\n        ThreadContext.clear();\n        sm = new DefaultSessionManager();\n    }\n\n    @After\n    public void tearDown() {\n        sm.destroy();\n        ThreadContext.clear();\n    }\n\n    public void sleep(long millis) {\n        try {\n            Thread.sleep(millis);\n        } catch (InterruptedException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    @Test\n    public void testGlobalTimeout() {\n\n        long timeout = 200;\n\n        //use the dao to simulate returned Sessions that are timed out:\n        SessionDAO mockDAO = createMock(SessionDAO.class);\n        Session mockSession = createNiceMock(Session.class);\n\n        Serializable mockSessionId = UUID.randomUUID().toString();\n        expect(mockSession.getId()).andReturn(mockSessionId).anyTimes();\n        expect(mockDAO.create(isA(Session.class))).andReturn(mockSessionId);\n\n        //this line verifies this test case - ensuring the DAO is called when an updated timeout:\n        mockDAO.update(eqSessionTimeout(timeout));\n\n        replay(mockDAO);\n\n        sm.setSessionDAO(mockDAO);\n\n        sm.setGlobalSessionTimeout(timeout);\n        sm.start((InetAddress) null);\n\n        verify(mockDAO);\n    }\n\n    @Test\n    public void testSessionListenerStartNotification() {\n        final boolean[] started = new boolean[1];\n        SessionListener listener = new SessionListenerAdapter() {\n            public void onStart(Session session) {\n                started[0] = true;\n            }\n        };\n        sm.add(listener);\n        sm.start((Map) null);\n        assertTrue(started[0]);\n    }\n\n    @Test\n    public void testSessionListenerStopNotification() {\n        final boolean[] stopped = new boolean[1];\n        SessionListener listener = new SessionListenerAdapter() {\n            public void onStop(Session session) {\n                stopped[0] = true;\n            }\n        };\n        sm.add(listener);\n        Serializable id = sm.start((Map) null);\n        sm.stop(id);\n        assertTrue(stopped[0]);\n    }\n\n    @Test\n    public void testSessionListenerExpiredNotification() {\n        final boolean[] expired = new boolean[1];\n        SessionListener listener = new SessionListenerAdapter() {\n            public void onExpiration(Session session) {\n                expired[0] = true;\n            }\n        };\n        sm.add(listener);\n        sm.setGlobalSessionTimeout(100);\n        Serializable id = sm.start((Map) null);\n        sleep(150);\n        try {\n            sm.checkValid(id);\n            fail(\"check should have thrown an exception.\");\n        } catch (InvalidSessionException expected) {\n            //do nothing - expected.\n        }\n        assertTrue(expired[0]);\n    }\n\n    @Test\n    public void testSessionDeleteOnExpiration() {\n        sm.setGlobalSessionTimeout(100);\n\n        SessionDAO sessionDAO = createMock(SessionDAO.class);\n        sm.setSessionDAO(sessionDAO);\n\n        String sessionId1 = UUID.randomUUID().toString();\n        final SimpleSession session1 = new SimpleSession();\n        session1.setId(sessionId1);\n\n        final Session[] activeSession = new SimpleSession[]{session1};\n        sm.setSessionFactory(new SessionFactory() {\n            public Session createSession(Map initData) {\n                return activeSession[0];\n            }\n        });\n\n        expect(sessionDAO.create(eq(session1))).andReturn(sessionId1);\n        sessionDAO.update(eq(session1));\n        expectLastCall().anyTimes();\n        replay(sessionDAO);\n        Serializable id = sm.start((InetAddress) null);\n        assertNotNull(id);\n        verify(sessionDAO);\n        reset(sessionDAO);\n\n        expect(sessionDAO.readSession(sessionId1)).andReturn(session1).anyTimes();\n        sessionDAO.update(eq(session1));\n        replay(sessionDAO);\n        sm.setTimeout(sessionId1, 1);\n        verify(sessionDAO);\n        reset(sessionDAO);\n\n        sleep(20);\n\n        expect(sessionDAO.readSession(sessionId1)).andReturn(session1);\n        sessionDAO.update(eq(session1)); //update's the stop timestamp\n        sessionDAO.delete(session1);\n        replay(sessionDAO);\n\n        //Try to access the same session, but it should throw an UnknownSessionException due to timeout:\n        try {\n            sm.getTimeout(sessionId1);\n            fail(\"Session with id [\" + sessionId1 + \"] should have expired due to timeout.\");\n        } catch (ExpiredSessionException expected) {\n            //expected\n        }\n\n        verify(sessionDAO); //verify that the delete call was actually made on the DAO\n    }\n\n    public static <T extends Session> T eqSessionTimeout(long timeout) {\n        EasyMock.reportMatcher(new SessionTimeoutMatcher(timeout));\n        return null;\n    }\n\n    private static class SessionTimeoutMatcher implements IArgumentMatcher {\n\n        private final long timeout;\n\n        public SessionTimeoutMatcher(long timeout) {\n            this.timeout = timeout;\n        }\n\n        public void appendTo(StringBuffer buffer) {\n            buffer.append(\"eqSession(timeout=\").append(this.timeout).append(\")\");\n        }\n\n        public boolean matches(Object o) {\n            return o instanceof Session && ((Session) o).getTimeout() == this.timeout;\n        }\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.session.mgt;\n\nimport org.apache.shiro.session.*;\nimport org.apache.shiro.session.mgt.eis.SessionDAO;\nimport org.apache.shiro.util.ThreadContext;\nimport static org.easymock.EasyMock.*;\nimport org.junit.After;\nimport static org.junit.Assert.*;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Map;\nimport java.util.UUID;\n\n/**\n * Unit test for the {@link DefaultSessionManager DefaultSessionManager} implementation.\n */\npublic class DefaultSessionManagerTest {\n\n    DefaultSessionManager sm = null;\n\n    @Before\n    public void setup() {\n        ThreadContext.clear();\n        sm = new DefaultSessionManager();\n    }\n\n    @After\n    public void tearDown() {\n        sm.destroy();\n        ThreadContext.clear();\n    }\n\n    public void sleep(long millis) {\n        try {\n            Thread.sleep(millis);\n        } catch (InterruptedException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    @Test\n    public void testGlobalTimeout() {\n        sm.setGlobalSessionTimeout(200);\n        Serializable sessionId = sm.start((InetAddress) null);\n        assertTrue(sm.isValid(sessionId));\n        sleep(300);\n        assertFalse(sm.isValid(sessionId));\n    }\n\n    @Test\n    public void testSessionListenerStartNotification() {\n        final boolean[] started = new boolean[1];\n        SessionListener listener = new SessionListenerAdapter() {\n            public void onStart(Session session) {\n                started[0] = true;\n            }\n        };\n        sm.add(listener);\n        sm.start((Map) null);\n        assertTrue(started[0]);\n    }\n\n    @Test\n    public void testSessionListenerStopNotification() {\n        final boolean[] stopped = new boolean[1];\n        SessionListener listener = new SessionListenerAdapter() {\n            public void onStop(Session session) {\n                stopped[0] = true;\n            }\n        };\n        sm.add(listener);\n        Serializable id = sm.start((Map) null);\n        sm.stop(id);\n        assertTrue(stopped[0]);\n    }\n\n    @Test\n    public void testSessionListenerExpiredNotification() {\n        final boolean[] expired = new boolean[1];\n        SessionListener listener = new SessionListenerAdapter() {\n            public void onExpiration(Session session) {\n                expired[0] = true;\n            }\n        };\n        sm.add(listener);\n        sm.setGlobalSessionTimeout(100);\n        Serializable id = sm.start((Map) null);\n        sleep(150);\n        try {\n            sm.checkValid(id);\n            fail(\"check should have thrown an exception.\");\n        } catch (InvalidSessionException expected) {\n            //do nothing - expected.\n        }\n        assertTrue(expired[0]);\n    }\n\n    @Test\n    public void testSessionDeleteOnExpiration() {\n        sm.setGlobalSessionTimeout(100);\n\n        SessionDAO sessionDAO = createMock(SessionDAO.class);\n        sm.setSessionDAO(sessionDAO);\n\n        String sessionId1 = UUID.randomUUID().toString();\n        final SimpleSession session1 = new SimpleSession();\n        session1.setId(sessionId1);\n\n        final Session[] activeSession = new SimpleSession[]{session1};\n        sm.setSessionFactory(new SessionFactory() {\n            public Session createSession(Map initData) {\n                return activeSession[0];\n            }\n        });\n\n        expect(sessionDAO.create(eq(session1))).andReturn(sessionId1);\n        sessionDAO.update(eq(session1));\n        expectLastCall().anyTimes();\n        replay(sessionDAO);\n        Serializable id = sm.start((InetAddress) null);\n        assertNotNull(id);\n        verify(sessionDAO);\n        reset(sessionDAO);\n\n        expect(sessionDAO.readSession(sessionId1)).andReturn(session1).anyTimes();\n        sessionDAO.update(eq(session1));\n        replay(sessionDAO);\n        sm.setTimeout(sessionId1, 1);\n        verify(sessionDAO);\n        reset(sessionDAO);\n\n        sleep(20);\n\n        expect(sessionDAO.readSession(sessionId1)).andReturn(session1);\n        sessionDAO.update(eq(session1)); //update's the stop timestamp\n        sessionDAO.delete(session1);\n        replay(sessionDAO);\n\n        //Try to access the same session, but it should throw an UnknownSessionException due to timeout:\n        try {\n            sm.getTimeout(sessionId1);\n            fail(\"Session with id [\" + sessionId1 + \"] should have expired due to timeout.\");\n        } catch (ExpiredSessionException expected) {\n            //expected\n        }\n\n        verify(sessionDAO); //verify that the delete call was actually made on the DAO\n    }\n}\n","lineNo":67}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.mgt;\n\nimport org.apache.shiro.authc.*;\nimport org.apache.shiro.authz.AuthorizationException;\nimport org.apache.shiro.authz.Authorizer;\nimport org.apache.shiro.crypto.Cipher;\nimport org.apache.shiro.realm.Realm;\nimport org.apache.shiro.session.InvalidSessionException;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.session.mgt.DelegatingSession;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.util.ThreadContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\n\n/**\n * The Shiro framework's default concrete implementation of the {@link SecurityManager} interface,\n * based around a collection of {@link org.apache.shiro.realm.Realm}s.  This implementation delegates its\n * authentication, authorization, and session operations to wrapped {@link Authenticator}, {@link Authorizer}, and\n * {@link org.apache.shiro.session.mgt.SessionManager SessionManager} instances respectively via superclass\n * implementation.\n * <p/>\n * To greatly reduce and simplify configuration, this implementation (and its superclasses) will\n * create suitable defaults for all of its required dependencies, <em>except<\/em> the required one or more\n * {@link Realm Realm}s.  Because {@code Realm} implementations usually interact with an application's data model,\n * they are almost always application specific;  you will want to specify at least one custom\n * {@code Realm} implementation that 'knows' about your application's data/security model\n * (via {@link #setRealm} or one of the overloaded constructors).  All other attributes in this class hierarchy\n * will have suitable defaults for most enterprise applications.\n * <p/>\n * <b>RememberMe notice<\/b>: This class supports the ability to configure a\n * {@link #setRememberMeManager RememberMeManager}\n * for {@code RememberMe} identity services for login/logout, BUT, a default instance <em>will not<\/em> be created\n * for this attribute at startup.\n * <p/>\n * Because RememberMe services are inherently client tier-specific and\n * therefore aplication-dependent, if you want {@code RememberMe} services enabled, you will have to specify an\n * instance yourself via the {@link #setRememberMeManager(RememberMeManager) setRememberMeManager}\n * mutator.  However if you're reading this JavaDoc with the\n * expectation of operating in a Web environment, take a look at the\n * {@code org.apache.shiro.web.DefaultWebSecurityManager} implementation, which\n * <em>does<\/em> support {@code RememberMe} services by default at startup.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.2\n */\npublic class DefaultSecurityManager extends SessionsSecurityManager {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(DefaultSecurityManager.class);\n\n    protected RememberMeManager rememberMeManager;\n\n    protected SubjectFactory subjectFactory;\n\n    protected SubjectBinder subjectBinder;\n\n    /**\n     * Default no-arg constructor.\n     */\n    public DefaultSecurityManager() {\n        super();\n        this.subjectFactory = new DefaultSubjectFactory(this);\n        this.subjectBinder = new SessionSubjectBinder();\n    }\n\n    /**\n     * Supporting constructor for a single-realm application.\n     *\n     * @param singleRealm the single realm used by this SecurityManager.\n     */\n    public DefaultSecurityManager(Realm singleRealm) {\n        this();\n        setRealm(singleRealm);\n    }\n\n    /**\n     * Supporting constructor for multiple {@link #setRealms realms}.\n     *\n     * @param realms the realm instances backing this SecurityManager.\n     */\n    public DefaultSecurityManager(Collection<Realm> realms) {\n        this();\n        setRealms(realms);\n    }\n\n    public SubjectFactory getSubjectFactory() {\n        return subjectFactory;\n    }\n\n    public void setSubjectFactory(SubjectFactory subjectFactory) {\n        this.subjectFactory = subjectFactory;\n        if (this.subjectFactory instanceof SecurityManagerAware) {\n            ((SecurityManagerAware) this.subjectFactory).setSecurityManager(this);\n        }\n    }\n\n    public SubjectBinder getSubjectBinder() {\n        return subjectBinder;\n    }\n\n    public void setSubjectBinder(SubjectBinder subjectBinder) {\n        this.subjectBinder = subjectBinder;\n    }\n\n    public RememberMeManager getRememberMeManager() {\n        return rememberMeManager;\n    }\n\n    public void setRememberMeManager(RememberMeManager rememberMeManager) {\n        this.rememberMeManager = rememberMeManager;\n    }\n\n    private AbstractRememberMeManager getRememberMeManagerForCipherAttributes() {\n        if (!(this.rememberMeManager instanceof AbstractRememberMeManager)) {\n            String msg = \"The convenience passthrough methods for setting remember me cipher attributes \" +\n                    \"are only available when the underlying RememberMeManager implementation is a subclass of \" +\n                    AbstractRememberMeManager.class.getName() + \".\";\n            throw new IllegalStateException(msg);\n        }\n        return (AbstractRememberMeManager) this.rememberMeManager;\n    }\n\n    public void setRememberMeCipher(Cipher cipher) {\n        getRememberMeManagerForCipherAttributes().setCipher(cipher);\n    }\n\n    public void setRememberMeCipherKey(byte[] bytes) {\n        getRememberMeManagerForCipherAttributes().setCipherKey(bytes);\n    }\n\n    public void setRememberMeCipherKeyHex(String hex) {\n        getRememberMeManagerForCipherAttributes().setCipherKeyHex(hex);\n    }\n\n    public void setRememberMeCipherKeyBase64(String base64) {\n        getRememberMeManagerForCipherAttributes().setCipherKeyBase64(base64);\n    }\n\n    public void setRememberMeEncryptionCipherKey(byte[] bytes) {\n        getRememberMeManagerForCipherAttributes().setEncryptionCipherKey(bytes);\n    }\n\n    public void setRememberMeEncryptionCipherKeyHex(String hex) {\n        getRememberMeManagerForCipherAttributes().setEncryptionCipherKeyHex(hex);\n    }\n\n    public void setRememberMeEncryptionCipherKeyBase64(String base64) {\n        getRememberMeManagerForCipherAttributes().setEncryptionCipherKeyBase64(base64);\n    }\n\n    public void setRememberMeDecryptionCipherKey(byte[] bytes) {\n        getRememberMeManagerForCipherAttributes().setDecryptionCipherKey(bytes);\n    }\n\n    public void setRememberMeDecryptionCipherKeyHex(String hex) {\n        getRememberMeManagerForCipherAttributes().setDecryptionCipherKeyHex(hex);\n    }\n\n    public void setRememberMeDecryptionCipherKeyBase64(String base64) {\n        getRememberMeManagerForCipherAttributes().setDecryptionCipherKeyBase64(base64);\n    }\n\n    protected Serializable getCurrentSessionId() {\n        return ThreadContext.getSessionId();\n    }\n\n    protected Session getSession(Serializable id) {\n        checkValid(id);\n        return new DelegatingSession(this, id);\n    }\n\n    protected Session getCurrentSession() {\n        Serializable sessionId = getCurrentSessionId();\n        Session session = null;\n        if (sessionId != null) {\n            try {\n                session = getSession(sessionId);\n            } catch (InvalidSessionException e) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Session id referenced on the current thread [\" + sessionId + \"] is invalid.  \" +\n                            \"Ignoring and creating a new Subject instance to continue.  This message can be \" +\n                            \"safely ignored.\", e);\n                }\n            } catch (AuthorizationException e) {\n                if (log.isWarnEnabled()) {\n                    log.warn(\"Session id referenced on the current thread [\" + sessionId + \"] is not allowed to be \" +\n                            \"referenced.  Ignoring and creating a Subject instance without a session to continue.\", e);\n                }\n            }\n        }\n        return session;\n    }\n\n    protected Subject createSubject() {\n        Session session = getCurrentSession();\n        PrincipalCollection remembered = null;\n        //only obtain a remembered identity if the session does not have one:\n        if (session != null) {\n            if (session.getAttribute(SessionSubjectBinder.PRINCIPALS_SESSION_KEY) == null) {\n                remembered = getRememberedIdentity();\n            }\n        }\n        return createSubject(remembered, session);\n    }\n\n    /**\n     * Returns a {@link Subject} instance that reflects the specified identity (principals), backed by the given\n     * {@link Session} instance.  Either argument can be null.\n     * <p/>\n     * This method is a convenience that assembles either argument into a context {@link Map Map} (if they are\n     * not null) and returns {@link #getSubject(java.util.Map)} using the Map as the parameter.\n     *\n     * @param principals the identity that the constructed {@code Subject} instance should have.\n     * @param session    the session to be associated with the constructed {@code Subject} instance.\n     * @return The Subject instance reflecting the specified identity (principals) and session.\n     * @since 1.0\n     */\n    protected Subject createSubject(PrincipalCollection principals, Session session) {\n        Map<String, Object> context = new HashMap<String, Object>(2);\n        if (principals != null && !principals.isEmpty()) {\n            context.put(SubjectFactory.PRINCIPALS, principals);\n        }\n        if (session != null) {\n            context.put(SubjectFactory.SESSION, session);\n        }\n        return getSubject(context);\n    }\n\n    /**\n     * Creates a {@code Subject} instance for the user represented by the given method arguments.\n     *\n     * @param token the {@code AuthenticationToken} submitted for the successful authentication.\n     * @param info  the {@code AuthenticationInfo} of a newly authenticated user.\n     * @return the {@code Subject} instance that represents the user and session data for the newly\n     *         authenticated user.\n     */\n    protected Subject createSubject(AuthenticationToken token, AuthenticationInfo info) {\n        Map<String, Object> context = new HashMap<String, Object>();\n        context.put(SubjectFactory.AUTHENTICATED, Boolean.TRUE);\n        context.put(SubjectFactory.AUTHENTICATION_TOKEN, token);\n        context.put(SubjectFactory.AUTHENTICATION_INFO, info);\n        Subject subject = getSubject(false);\n        if (subject != null) {\n            context.put(SubjectFactory.SUBJECT, subject);\n        }\n        return getSubject(context);\n    }\n\n    /**\n     * Binds a {@code Subject} instance created after authentication to the application for later use.\n     * <p/>\n     * The default implementation merely binds the argument to the thread local via the {@link ThreadContext}\n     * and overridden by subclasses for environment-specific binding (e.g. standalone application).\n     *\n     * @param subject the {@code Subject} instance created after authentication to be bound to the application\n     *                for later use.\n     */\n    protected void bind(Subject subject) {\n        getSubjectBinder().bind(subject);\n    }\n\n    protected void rememberMeSuccessfulLogin(AuthenticationToken token, AuthenticationInfo info) {\n        RememberMeManager rmm = getRememberMeManager();\n        if (rmm != null) {\n            try {\n                rmm.onSuccessfulLogin(token, info);\n            } catch (Exception e) {\n                if (log.isWarnEnabled()) {\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() +\n                            \"] threw an exception during onSuccessfulLogin.  RememberMe services will not be \" +\n                            \"performed for account [\" + info + \"].\";\n                    log.warn(msg, e);\n                }\n            }\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"This \" + getClass().getName() + \" instance does not have a \" +\n                        \"[\" + RememberMeManager.class.getName() + \"] instance configured.  RememberMe services \" +\n                        \"will not be performed for account [\" + info + \"].\");\n            }\n        }\n    }\n\n    protected void rememberMeFailedLogin(AuthenticationToken token, AuthenticationException ex) {\n        RememberMeManager rmm = getRememberMeManager();\n        if (rmm != null) {\n            try {\n                rmm.onFailedLogin(token, ex);\n            } catch (Exception e) {\n                if (log.isWarnEnabled()) {\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() +\n                            \"] threw an exception during onFailedLogin for AuthenticationToken [\" +\n                            token + \"].\";\n                    log.warn(msg, e);\n                }\n            }\n        }\n    }\n\n    protected void rememberMeLogout(PrincipalCollection subjectPrincipals) {\n        RememberMeManager rmm = getRememberMeManager();\n        if (rmm != null) {\n            try {\n                rmm.onLogout(subjectPrincipals);\n            } catch (Exception e) {\n                if (log.isWarnEnabled()) {\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() +\n                            \"] threw an exception during onLogout for subject with principals [\" +\n                            subjectPrincipals + \"]\";\n                    log.warn(msg, e);\n                }\n            }\n        }\n    }\n\n    /**\n     * First authenticates the {@code AuthenticationToken} argument, and if successful, constructs a\n     * {@code Subject} instance representing the authenticated account's identity.\n     * <p/>\n     * Once constructed, the {@code Subject} instance is then {@link #bind bound} to the application for\n     * subsequent access before being returned to the caller.\n     *\n     * @param token the authenticationToken to process for the login attempt.\n     * @return a Subject representing the authenticated user.\n     * @throws AuthenticationException if there is a problem authenticating the specified {@code token}.\n     */\n    public Subject login(AuthenticationToken token) throws AuthenticationException {\n        AuthenticationInfo info;\n        try {\n            info = authenticate(token);\n            onSuccessfulLogin(token, info);\n        } catch (AuthenticationException ae) {\n            try {\n                onFailedLogin(token, ae);\n            } catch (Exception e) {\n                if (log.isInfoEnabled()) {\n                    log.info(\"onFailedLogin(AuthenticationToken,AuthenticationException) method threw an \" +\n                            \"exception.  Logging and propagating original AuthenticationException.\", e);\n                }\n            }\n            throw ae; //propagate\n        }\n        Subject subject = createSubject(token, info);\n        bind(subject);\n        return subject;\n    }\n\n    protected void onSuccessfulLogin(AuthenticationToken token, AuthenticationInfo info) {\n        rememberMeSuccessfulLogin(token, info);\n    }\n\n    protected void onFailedLogin(AuthenticationToken token, AuthenticationException ae) {\n        rememberMeFailedLogin(token, ae);\n    }\n\n    protected void beforeLogout(PrincipalCollection subjectIdentifier) {\n        rememberMeLogout(subjectIdentifier);\n    }\n\n    /**\n     * This implementation attempts to resolve any session ID that may exist in the context argument by first\n     * passing it to the {@link #resolveSessionIfNecessary(java.util.Map) resolveSessionIfNecessary} method.  The\n     * return value from that call is then used to create the Subject instance by calling\n     * <code>{@link #getSubjectFactory() getSubjectFactory()}.{@link SubjectFactory#createSubject(java.util.Map) createSubject}(returnValue);<\/code>\n     *\n     * @param context any data needed to direct how the Subject should be constructed.\n     * @return the {@code Subject} instance reflecting the specified initialization data.\n     * @see SubjectFactory#createSubject(java.util.Map)\n     * @since 1.0\n     */\n    public Subject getSubject(Map context) {\n        //Translate a session id if it exists into a Session object before sending to the SubjectFactory\n        //The SubjectFactory should not need to know how to acquire sessions as it is often environment\n        //specific - better to shield the SF from these details:\n        Map resolved = resolveSessionIfNecessary(context);\n        return getSubjectFactory().createSubject(resolved);\n    }\n\n    /**\n     * Attempts to resolve any session id in the context to its corresponding {@link Session} and returns a\n     * context that represents this resolved {@code Session} to ensure it may be referenced if necessary by the\n     * invoked {@link SubjectFactory} that performs actual {@link Subject} construction.\n     * <p/>\n     * The session id, if it exists in the context map, should be available as a value under the\n     * <code>{@link SubjectFactory SubjectFactory}.{@link SubjectFactory#SESSION_ID SESSION_ID}<\/code> key constant.\n     * If a session is resolved, a copy of the original context Map is made to ensure the method argument is not\n     * changed, the resolved session is placed into the copy and the copy is returned.\n     * <p/>\n     * If there is a {@code Session} already in the context because that is what the caller wants to be used for\n     * {@code Subject} construction, or if no session is resolved, this method effectively does nothing and immediately\n     * returns the Map method argument without change.\n     *\n     * @param context the subject context data that may contain a session id that should be converted to a Session instance.\n     * @return The context Map to use to pass to a {@link SubjectFactory} for subject creation.\n     * @since 1.0\n     */\n    @SuppressWarnings({\"unchecked\"})\n    protected Map resolveSessionIfNecessary(Map context) {\n        if (context.containsKey(SubjectFactory.SESSION)) {\n            log.debug(\"Context already contains a session.  Returning.\");\n            return context;\n        }\n        log.trace(\"No session found in context.  Looking for a session id to resolve in to a session.\");\n        //otherwise try to resolve a session if a session id exists:\n        Map copy = new HashMap(context);\n        Serializable sessionId = getSessionId(context);\n        if (sessionId != null) {\n            try {\n                Session session = getSession(sessionId);\n                copy.put(SubjectFactory.SESSION, session);\n            } catch (InvalidSessionException e) {\n                onInvalidSessionId(sessionId);\n                log.debug(\"Context referenced sessionId is invalid.  Ignoring and creating an anonymous \" +\n                        \"(session-less) Subject instance.\", e);\n            }\n        }\n        return copy;\n    }\n\n    /**\n     * Allows subclasses to react to the fact that a provided session id was invalid.\n     *\n     * @param sessionId the session id that was discovered to be invalid (no session, expired, etc).\n     * @since 1.0\n     */\n    protected void onInvalidSessionId(Serializable sessionId) {\n    }\n\n    /**\n     * Utility method to retrieve the session id from the given subject context Map which will be used to resolve\n     * to a {@link Session} or {@code null} if there is no session id in the map.  If the session id exists, it is\n     * expected to be available in the map under the\n     * <code>{@link SubjectFactory SubjectFactory}.{@link SubjectFactory#SESSION_ID SESSION_ID}<\/code> constant.\n     *\n     * @param subjectContext the context map with data that will be used to construct a {@link Subject} instance via\n     *                       a {@link SubjectFactory}\n     * @return a session id to resolve to a {@link Session} instance or {@code null} if a session id could not be found.\n     * @see #getSubject(java.util.Map)\n     * @see SubjectFactory#createSubject(java.util.Map)\n     */\n    protected Serializable getSessionId(Map subjectContext) {\n        return (Serializable) subjectContext.get(SubjectFactory.SESSION_ID);\n    }\n\n    protected Subject getSubject(PrincipalCollection principals) {\n        //Method arg is ignored at the moment - retrieve from the environment if it exists:\n        return getSubject(false);\n    }\n\n    public void logout(PrincipalCollection principals) {\n\n        Subject subject;\n\n        if (principals != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Logging out subject with primary id {}\" + principals.iterator().next());\n            }\n            beforeLogout(principals);\n            Authenticator authc = getAuthenticator();\n            if (authc instanceof LogoutAware) {\n                ((LogoutAware) authc).onLogout(principals);\n            }\n            subject = getSubject(principals);\n        } else {\n            subject = getSubject(false);\n        }\n        if (subject == null) {\n            return;\n        }\n\n        try {\n            unbind(subject);\n        } catch (Exception e) {\n            if (log.isDebugEnabled()) {\n                String msg = \"Unable to cleanly unbind Subject.  Ignoring (logging out).\";\n                log.debug(msg, e);\n            }\n        } finally {\n            try {\n                stopSession(subject);\n            } catch (Exception e) {\n                if (log.isDebugEnabled()) {\n                    String msg = \"Unable to cleanly stop Session for Subject [\" + subject.getPrincipal() + \"] \" +\n                            \"Ignoring (logging out).\";\n                    log.debug(msg, e);\n                }\n            }\n        }\n    }\n\n    protected void stopSession(Subject subject) {\n        Session s = subject.getSession(false);\n        if (s != null) {\n            try {\n                s.stop();\n            } catch (InvalidSessionException ise) {\n                //ignored - we're invalidating, and have no further need of the session anyway\n                //log just in case someone wants to know:\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Session has already been invalidated for subject [\" +\n                            subject.getPrincipal() + \"].  Ignoring and continuing logout ...\", ise);\n                }\n            }\n        }\n    }\n\n    protected void unbind(Subject subject) {\n        getSubjectBinder().unbind(subject);\n    }\n\n    protected PrincipalCollection getRememberedIdentity() {\n        RememberMeManager rmm = getRememberMeManager();\n        if (rmm != null) {\n            try {\n                return rmm.getRememberedPrincipals();\n            } catch (Exception e) {\n                if (log.isWarnEnabled()) {\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() +\n                            \"] threw an exception during getRememberedPrincipals().\";\n                    log.warn(msg, e);\n                }\n            }\n        }\n        return null;\n    }\n\n    protected Subject getSubject(boolean create) {\n        Subject subject = getSubjectBinder().getSubject();\n        if (subject == null && create) {\n            subject = createSubject();\n            bind(subject);\n        }\n        return subject;\n    }\n\n    public Subject getSubject() {\n        return getSubject(true);\n    }\n\n    /**\n     * Acquires the {@link Subject Subject} that owns the {@link Session Session} with the specified {@code sessionId}.\n     * <p/>\n     * <b>Although simple in concept, this method provides incredibly powerful functionality:<\/b>\n     * <p/>\n     * The ability to reference a {@code Subject} and their server-side session\n     * <em>across clients of different mediums<\/em> such as web applications, Java applets,\n     * standalone C# clients over XMLRPC and/or SOAP, and many others. This is a <em>huge<\/em>\n     * benefit in heterogeneous enterprise applications.\n     * <p/>\n     * To maintain session integrity across client mediums, the {@code sessionId} <b>must<\/b> be transmitted\n     * to all client mediums securely (e.g. over SSL) to prevent man-in-the-middle attacks.  This\n     * is nothing new - all web applications are susceptible to the same problem when transmitting\n     * {@code Cookie}s or when using URL rewriting.  As long as the\n     * {@code sessionId} is transmitted securely, session integrity can be maintained.\n     *\n     * @param sessionId the id of the session that backs the desired Subject being acquired.\n     * @return the {@code Subject} that owns the {@code Session Session} with the specified {@code sessionId}\n     * @throws InvalidSessionException if the session identified by {@code sessionId} has been stopped, expired, or\n     *                                 doesn't exist.\n     * @throws AuthorizationException  if the executor of this method is not allowed to acquire the owning\n     *                                 {@code Subject}.  The reason for the exception is implementation-specific and\n     *                                 could be for any number of reasons.  A common reason in many systems would be\n     *                                 if one host tried to acquire a {@code Subject} based on a {@code Session} that\n     *                                 originated on an entirely different host (although it is not a Shiro requirement\n     *                                 this scenario is disallowed - its just an example that <em>may<\/em> throw an\n     *                                 Exception in some systems).\n     * @see org.apache.shiro.authz.HostUnauthorizedException\n     * @since 1.0\n     */\n    protected Subject getSubjectBySessionId(Serializable sessionId) throws InvalidSessionException, AuthorizationException {\n        Map<String, Object> context = new HashMap<String, Object>(1);\n        context.put(SubjectFactory.SESSION_ID, sessionId);\n        return getSubject(context);\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.mgt;\n\nimport org.apache.shiro.authc.*;\nimport org.apache.shiro.authz.AuthorizationException;\nimport org.apache.shiro.authz.Authorizer;\nimport org.apache.shiro.crypto.Cipher;\nimport org.apache.shiro.realm.Realm;\nimport org.apache.shiro.session.InvalidSessionException;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.session.mgt.DelegatingSession;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.util.ThreadContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\n\n/**\n * <p>The Shiro framework's default concrete implementation of the {@link SecurityManager} interface,\n * based around a collection of {@link org.apache.shiro.realm.Realm}s.  This implementation delegates its\n * authentication, authorization, and session operations to wrapped {@link Authenticator}, {@link Authorizer}, and\n * {@link org.apache.shiro.session.mgt.SessionManager SessionManager} instances respectively via superclass\n * implementation.<\/p>\n * <p/>\n * <p>To greatly reduce and simplify configuration, this implementation (and its superclasses) will\n * create suitable defaults for all of its required dependencies, <em>except<\/em> the required one or more\n * {@link Realm Realm}s.  Because <code>Realm<\/code> implementations usually interact with an application's data model,\n * they are almost always application specific;  you will want to specify at least one custom\n * <tt>Realm<\/tt> implementation that 'knows' about your application's data/security model\n * (via {@link #setRealm} or one of the overloaded constructors).  All other attributes in this class hierarchy\n * will have suitable defaults for most enterprise applications.<\/p>\n * <p/>\n * <p><b>RememberMe notice<\/b>: This class supports the ability to configure a\n * {@link #setRememberMeManager RememberMeManager}\n * for <tt>RememberMe<\/tt> identity services for login/logout, BUT, a default instance <em>will not<\/em> be created\n * for this attribute at startup.\n * <p/>\n * <p>Because RememberMe services are inherently client tier-specific and\n * therefore aplication-dependent, if you want <tt>RememberMe<\/tt> services enabled, you will have to specify an\n * instance yourself via the {@link #setRememberMeManager(RememberMeManager) setRememberMeManager}\n * mutator.  However if you're reading this JavaDoc with the\n * expectation of operating in a Web environment, take a look at the\n * {@code org.apache.shiro.web.DefaultWebSecurityManager} implementation, which\n * <em>does<\/em> support <tt>RememberMe<\/tt> services by default at startup.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.2\n */\npublic class DefaultSecurityManager extends SessionsSecurityManager {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(DefaultSecurityManager.class);\n\n    protected RememberMeManager rememberMeManager;\n\n    protected SubjectFactory subjectFactory;\n\n    protected SubjectBinder subjectBinder;\n\n    /**\n     * Default no-arg constructor.\n     */\n    public DefaultSecurityManager() {\n        super();\n        this.subjectFactory = new DefaultSubjectFactory(this);\n        this.subjectBinder = new SessionSubjectBinder();\n    }\n\n    /**\n     * Supporting constructor for a single-realm application.\n     *\n     * @param singleRealm the single realm used by this SecurityManager.\n     */\n    public DefaultSecurityManager(Realm singleRealm) {\n        this();\n        setRealm(singleRealm);\n    }\n\n    /**\n     * Supporting constructor for multiple {@link #setRealms realms}.\n     *\n     * @param realms the realm instances backing this SecurityManager.\n     */\n    public DefaultSecurityManager(Collection<Realm> realms) {\n        this();\n        setRealms(realms);\n    }\n\n    public SubjectFactory getSubjectFactory() {\n        return subjectFactory;\n    }\n\n    public void setSubjectFactory(SubjectFactory subjectFactory) {\n        this.subjectFactory = subjectFactory;\n        if (this.subjectFactory instanceof SecurityManagerAware) {\n            ((SecurityManagerAware) this.subjectFactory).setSecurityManager(this);\n        }\n    }\n\n    public SubjectBinder getSubjectBinder() {\n        return subjectBinder;\n    }\n\n    public void setSubjectBinder(SubjectBinder subjectBinder) {\n        this.subjectBinder = subjectBinder;\n    }\n\n    public RememberMeManager getRememberMeManager() {\n        return rememberMeManager;\n    }\n\n    public void setRememberMeManager(RememberMeManager rememberMeManager) {\n        this.rememberMeManager = rememberMeManager;\n    }\n\n    private AbstractRememberMeManager getRememberMeManagerForCipherAttributes() {\n        if (!(this.rememberMeManager instanceof AbstractRememberMeManager)) {\n            String msg = \"The convenience passthrough methods for setting remember me cipher attributes \" +\n                    \"are only available when the underlying RememberMeManager implementation is a subclass of \" +\n                    AbstractRememberMeManager.class.getName() + \".\";\n            throw new IllegalStateException(msg);\n        }\n        return (AbstractRememberMeManager) this.rememberMeManager;\n    }\n\n    public void setRememberMeCipher(Cipher cipher) {\n        getRememberMeManagerForCipherAttributes().setCipher(cipher);\n    }\n\n    public void setRememberMeCipherKey(byte[] bytes) {\n        getRememberMeManagerForCipherAttributes().setCipherKey(bytes);\n    }\n\n    public void setRememberMeCipherKeyHex(String hex) {\n        getRememberMeManagerForCipherAttributes().setCipherKeyHex(hex);\n    }\n\n    public void setRememberMeCipherKeyBase64(String base64) {\n        getRememberMeManagerForCipherAttributes().setCipherKeyBase64(base64);\n    }\n\n    public void setRememberMeEncryptionCipherKey(byte[] bytes) {\n        getRememberMeManagerForCipherAttributes().setEncryptionCipherKey(bytes);\n    }\n\n    public void setRememberMeEncryptionCipherKeyHex(String hex) {\n        getRememberMeManagerForCipherAttributes().setEncryptionCipherKeyHex(hex);\n    }\n\n    public void setRememberMeEncryptionCipherKeyBase64(String base64) {\n        getRememberMeManagerForCipherAttributes().setEncryptionCipherKeyBase64(base64);\n    }\n\n    public void setRememberMeDecryptionCipherKey(byte[] bytes) {\n        getRememberMeManagerForCipherAttributes().setDecryptionCipherKey(bytes);\n    }\n\n    public void setRememberMeDecryptionCipherKeyHex(String hex) {\n        getRememberMeManagerForCipherAttributes().setDecryptionCipherKeyHex(hex);\n    }\n\n    public void setRememberMeDecryptionCipherKeyBase64(String base64) {\n        getRememberMeManagerForCipherAttributes().setDecryptionCipherKeyBase64(base64);\n    }\n\n    protected Serializable getCurrentSessionId() {\n        return ThreadContext.getSessionId();\n    }\n\n    protected Session getSession(Serializable id) {\n        if (!isValid(id)) {\n            String msg = \"Specified id [\" + id + \"] does not correspond to a valid Session  It either \" +\n                    \"does not exist or the corresponding session has been stopped or expired.\";\n            throw new InvalidSessionException(msg, id);\n        }\n\n        return new DelegatingSession(this, id);\n    }\n\n    protected Subject createSubject() {\n        Serializable sessionId = getCurrentSessionId();\n        Session session = null;\n        if (sessionId != null) {\n            try {\n                session = getSession(sessionId);\n            } catch (InvalidSessionException e) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Session id referenced on the current thread [\" + sessionId + \"] is invalid.  \" +\n                            \"Ignoring and creating a new Subject instance to continue.  This message can be \" +\n                            \"safely ignored.\", e);\n                }\n            } catch (AuthorizationException e) {\n                if (log.isWarnEnabled()) {\n                    log.warn(\"Session id referenced on the current thread [\" + sessionId + \"] is not allowed to be \" +\n                            \"referenced.  Ignoring and creating a Subject instance without a session to continue.\", e);\n                }\n            }\n        }\n\n        PrincipalCollection principals = getRememberedIdentity();\n        return createSubject(principals, session);\n    }\n\n    protected Subject createSubject(PrincipalCollection principals, Session session) {\n        Map<String, Object> context = new HashMap<String, Object>(2);\n\n        if (principals != null && !principals.isEmpty()) {\n            context.put(SubjectFactory.PRINCIPALS, principals);\n        }\n        if (session != null) {\n            context.put(SubjectFactory.SESSION, session);\n        }\n\n        SubjectFactory sf = getSubjectFactory();\n        return sf.createSubject(context);\n    }\n\n    /**\n     * Creates a <tt>Subject<\/tt> instance for the user represented by the given method arguments.\n     *\n     * @param token the <tt>AuthenticationToken<\/tt> submitted for the successful authentication.\n     * @param info  the <tt>AuthenticationInfo<\/tt> of a newly authenticated user.\n     * @return the <tt>Subject<\/tt> instance that represents the user and session data for the newly\n     *         authenticated user.\n     */\n    protected Subject createSubject(AuthenticationToken token, AuthenticationInfo info) {\n        Map<String, Object> context = new HashMap<String, Object>();\n        context.put(SubjectFactory.AUTHENTICATED, Boolean.TRUE);\n        context.put(SubjectFactory.AUTHENTICATION_TOKEN, token);\n        context.put(SubjectFactory.AUTHENTICATION_INFO, info);\n        Subject subject = getSubject(false);\n        if (subject != null) {\n            context.put(SubjectFactory.SUBJECT, subject);\n        }\n        return getSubjectFactory().createSubject(context);\n    }\n\n    /**\n     * Binds a <tt>Subject<\/tt> instance created after authentication to the application for later use.\n     * <p/>\n     * <p>The default implementation merely binds the argument to the thread local via the {@link ThreadContext}.\n     * Should be overridden by subclasses for environment-specific binding (e.g. web environment, etc).\n     *\n     * @param subject the <tt>Subject<\/tt> instance created after authentication to be bound to the application\n     *                for later use.\n     */\n    protected void bind(Subject subject) {\n        getSubjectBinder().bind(subject);\n    }\n\n    private void assertCreation(Subject subject) throws IllegalStateException {\n        if (subject == null) {\n            String msg = \"Programming error - please verify that you have overridden the \" +\n                    getClass().getName() + \".createSubject( AuthenticationInfo info ) method to return \" +\n                    \"a non-null Subject instance\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    protected void rememberMeSuccessfulLogin(AuthenticationToken token, AuthenticationInfo info) {\n        RememberMeManager rmm = getRememberMeManager();\n        if (rmm != null) {\n            try {\n                rmm.onSuccessfulLogin(token, info);\n            } catch (Exception e) {\n                if (log.isWarnEnabled()) {\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() +\n                            \"] threw an exception during onSuccessfulLogin.  RememberMe services will not be \" +\n                            \"performed for account [\" + info + \"].\";\n                    log.warn(msg, e);\n                }\n            }\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"This \" + getClass().getName() + \" instance does not have a \" +\n                        \"[\" + RememberMeManager.class.getName() + \"] instance configured.  RememberMe services \" +\n                        \"will not be performed for account [\" + info + \"].\");\n            }\n        }\n    }\n\n    protected void rememberMeFailedLogin(AuthenticationToken token, AuthenticationException ex) {\n        RememberMeManager rmm = getRememberMeManager();\n        if (rmm != null) {\n            try {\n                rmm.onFailedLogin(token, ex);\n            } catch (Exception e) {\n                if (log.isWarnEnabled()) {\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() +\n                            \"] threw an exception during onFailedLogin for AuthenticationToken [\" +\n                            token + \"].\";\n                    log.warn(msg, e);\n                }\n            }\n        }\n    }\n\n    protected void rememberMeLogout(PrincipalCollection subjectPrincipals) {\n        RememberMeManager rmm = getRememberMeManager();\n        if (rmm != null) {\n            try {\n                rmm.onLogout(subjectPrincipals);\n            } catch (Exception e) {\n                if (log.isWarnEnabled()) {\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() +\n                            \"] threw an exception during onLogout for subject with principals [\" +\n                            subjectPrincipals + \"]\";\n                    log.warn(msg, e);\n                }\n            }\n        }\n    }\n\n    /**\n     * First authenticates the <tt>AuthenticationToken<\/tt> argument, and if successful, constructs a\n     * <tt>Subject<\/tt> instance representing the authenticated account's identity.\n     * <p/>\n     * <p>Once constructed, the <tt>Subject<\/tt> instance is then {@link #bind bound} to the application for\n     * subsequent access before being returned to the caller.\n     *\n     * @param token the authenticationToken to process for the login attempt.\n     * @return a Subject representing the authenticated user.\n     * @throws AuthenticationException if there is a problem authenticating the specified <tt>token<\/tt>.\n     */\n    public Subject login(AuthenticationToken token) throws AuthenticationException {\n        AuthenticationInfo info;\n        try {\n            info = authenticate(token);\n            onSuccessfulLogin(token, info);\n        } catch (AuthenticationException ae) {\n            try {\n                onFailedLogin(token, ae);\n            } catch (Exception e) {\n                if (log.isInfoEnabled()) {\n                    log.info(\"onFailedLogin(AuthenticationToken,AuthenticationException) method threw an \" +\n                            \"exception.  Logging and propagating original AuthenticationException.\", e);\n                }\n            }\n            throw ae; //propagate\n        }\n        Subject subject = createSubject(token, info);\n        assertCreation(subject);\n        bind(subject);\n        return subject;\n    }\n\n    protected void onSuccessfulLogin(AuthenticationToken token, AuthenticationInfo info) {\n        rememberMeSuccessfulLogin(token, info);\n    }\n\n    protected void onFailedLogin(AuthenticationToken token, AuthenticationException ae) {\n        rememberMeFailedLogin(token, ae);\n    }\n\n    protected void beforeLogout(PrincipalCollection subjectIdentifier) {\n        rememberMeLogout(subjectIdentifier);\n    }\n\n    /**\n     * @since 1.0\n     */\n    public Subject getSubject(Map context) {\n        return getSubjectFactory().createSubject(context);\n    }\n\n    protected Subject getSubject(PrincipalCollection principals) {\n        //Method arg is ignored at the moment - retrieve from the environment if it exists:\n        return getSubject(false);\n    }\n\n    public void logout(PrincipalCollection principals) {\n\n        Subject subject;\n\n        if (principals != null) {\n            beforeLogout(principals);\n            Authenticator authc = getAuthenticator();\n            if (authc instanceof LogoutAware) {\n                ((LogoutAware) authc).onLogout(principals);\n            }\n            subject = getSubject(principals);\n        } else {\n            subject = getSubject(false);\n        }\n\n        try {\n            unbind(subject);\n        } catch (Exception e) {\n            if (log.isDebugEnabled()) {\n                String msg = \"Unable to cleanly unbind Subject.  Ignoring (logging out).\";\n                log.debug(msg, e);\n            }\n        } finally {\n            try {\n                stopSession(subject);\n            } catch (Exception e) {\n                if (log.isDebugEnabled()) {\n                    String msg = \"Unable to cleanly stop Session for Subject [\" + subject.getPrincipal() + \"] \" +\n                            \"Ignoring (logging out).\";\n                    log.debug(msg, e);\n                }\n            }\n\n        }\n    }\n\n    protected void stopSession(Subject subject) {\n        Session s = subject.getSession(false);\n        if (s != null) {\n            try {\n                s.stop();\n            } catch (InvalidSessionException ise) {\n                //ignored - we're invalidating, and have no further need of the session anyway\n                //log just in case someone wants to know:\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Session has already been invalidated for subject [\" +\n                            subject.getPrincipal() + \"].  Ignoring and continuing logout ...\", ise);\n                }\n            }\n        }\n    }\n\n    protected void unbind(Subject subject) {\n        getSubjectBinder().unbind(subject);\n    }\n\n    protected PrincipalCollection getRememberedIdentity() {\n        RememberMeManager rmm = getRememberMeManager();\n        if (rmm != null) {\n            try {\n                return rmm.getRememberedPrincipals();\n            } catch (Exception e) {\n                if (log.isWarnEnabled()) {\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() +\n                            \"] threw an exception during getRememberedPrincipals().\";\n                    log.warn(msg, e);\n                }\n            }\n        }\n        return null;\n    }\n\n    protected Subject getSubject(boolean create) {\n        Subject subject = getSubjectBinder().getSubject();\n        if (subject == null && create) {\n            subject = createSubject();\n            bind(subject);\n        }\n        return subject;\n    }\n\n    public Subject getSubject() {\n        return getSubject(true);\n    }\n\n    /**\n     * Acquires the {@link Subject Subject} that owns the {@link Session Session} with the specified {@code sessionId}.\n     * <p/>\n     * <b>Although simple in concept, this method provides incredibly powerful functionality:<\/b>\n     * <p/>\n     * The ability to reference a {@code Subject} and their server-side session\n     * <em>across clients of different mediums<\/em> such as web applications, Java applets,\n     * standalone C# clients over XMLRPC and/or SOAP, and many others. This is a <em>huge<\/em>\n     * benefit in heterogeneous enterprise applications.\n     * <p/>\n     * To maintain session integrity across client mediums, the {@code sessionId} <b>must<\/b> be transmitted\n     * to all client mediums securely (e.g. over SSL) to prevent man-in-the-middle attacks.  This\n     * is nothing new - all web applications are susceptible to the same problem when transmitting\n     * {@code Cookie}s or when using URL rewriting.  As long as the\n     * {@code sessionId} is transmitted securely, session integrity can be maintained.\n     *\n     * @param sessionId the id of the session that backs the desired Subject being acquired.\n     * @return the {@code Subject} that owns the {@code Session Session} with the specified {@code sessionId}\n     * @throws org.apache.shiro.session.InvalidSessionException\n     *          if the session identified by <tt>sessionId<\/tt> has\n     *          been stopped, expired, or doesn't exist.\n     * @throws org.apache.shiro.authz.AuthorizationException\n     *          if the executor of this method is not allowed to acquire the owning {@code Subject}.  The reason\n     *          for the exception is implementation-specific and could be for any number of reasons.  A common\n     *          reason in many systems would be if one host tried to acquire a {@code Subject} based on a\n     *          {@code Session} that originated on an entirely different host (although it is not a Shiro\n     *          requirement this scenario is disallowed - its just an example that <em>may<\/em> throw an Exception in\n     *          some systems).\n     * @see org.apache.shiro.authz.HostUnauthorizedException\n     * @since 1.0\n     */\n    protected Subject getSubjectBySessionId(Serializable sessionId) throws InvalidSessionException, AuthorizationException {\n        Session session = getSession(sessionId);\n\n        Map<String, Object> context = new HashMap<String, Object>(1);\n        context.put(SubjectFactory.SESSION, session);\n\n        SubjectFactory sf = getSubjectFactory();\n        return sf.createSubject(context);\n    }\n}\n","lineNo":403}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.ki.web.attr;\n\nimport org.apache.ki.util.StringUtils;\nimport static org.apache.ki.web.WebUtils.toHttp;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.beans.PropertyEditor;\n\n/**\n * A <tt>CookieAttribute<\/tt> stores an object as a {@link Cookie} for access on later requests.\n *\n * @author Les Hazlewood\n * @author Peter Ledbrook\n * @since 0.2\n */\npublic class CookieAttribute<T> extends AbstractWebAttribute<T> {\n\n    //TODO - complete JavaDoc\n\n    /**\n     * Private internal log instance.\n     */\n    private static final Logger log = LoggerFactory.getLogger(CookieAttribute.class);\n\n    /**\n     * The number of seconds in one year (= 60 * 60 * 24 * 365).\n     */\n    public static final int ONE_YEAR = 60 * 60 * 24 * 365;\n    /**\n     * This is the same value as Integer.MAX_VALUE, and while Tomcat does fine with cookie max age with this value,\n     * Jetty apparently has problems with it.  If you're using Jetty, you might want to use the\n     * {@link #ONE_YEAR ONE_YEAR} constant or another value.\n     */\n    public static final int INDEFINITE = Integer.MAX_VALUE;\n\n    /**\n     * <code>null<\/code>, indicating the cookie should be set on the request context root.\n     */\n    public static final String DEFAULT_PATH = null;\n\n    /**\n     * Root path to use when the path hasn't been set and request context root is empty or null.\n     */\n    public static final String ROOT_PATH = \"/\";\n    /**\n     * <code>-1<\/code>, indicating the cookie should expire when the browser closes.\n     */\n    public static final int DEFAULT_MAX_AGE = -1;\n\n    /**\n     * <code>-1<\/code> indicating that no version property should be set on the cookie.\n     */\n    public static final int DEFAULT_VERSION = -1;\n\n    /**\n     * Default value is <code>false<\/code>.\n     */\n    public static final boolean DEFAULT_SECURE = false;\n\n    private String comment = null;\n    private String domain = null;\n    private int maxAge = DEFAULT_MAX_AGE;\n    private String path = DEFAULT_PATH;\n    private boolean secure = DEFAULT_SECURE;\n    private int version = DEFAULT_VERSION;\n\n    public CookieAttribute() {\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified {@link Cookie#getName() name}\n     * using the request context's path and with a {@link Cookie#setMaxAge(int) maxAge} of <tt>-1<\/tt>, indicating the\n     * Cookie will persist until browser shutdown.\n     *\n     * @param name the Cookie {@link Cookie#getName() name}\n     */\n    public CookieAttribute(String name) {\n        super(name);\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name} and {@link Cookie#getPath() path}.\n     * <p/>\n     * <p>A <tt>null<\/tt> <tt>path<\/tt> value means the request context's path will be used by default.\n     * <p/>\n     * <p>The Cookie's {@link Cookie#getMaxAge() maxAge} will be <tt>-1<\/tt>, indicating the Cookie will persist until\n     * browser shutdown.\n     *\n     * @param name the Cookie {@link Cookie#getName() name}\n     * @param path the Cookie {@link Cookie#setPath(String) path}.\n     */\n    public CookieAttribute(String name, String path) {\n        super(name);\n        setPath(path);\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name} and {@link Cookie#getMaxAge() maxAge}.\n     * <p/>\n     * <p>The Cookie's {@link javax.servlet.http.Cookie#getPath() path} will be the <tt>Request<\/tt>'s\n     * {@link javax.servlet.http.HttpServletRequest#getContextPath() context path}.\n     *\n     * @param name   the Cookie {@link javax.servlet.http.Cookie#getName() name};\n     * @param maxAge the Cookie {@link Cookie#getMaxAge() maxAge}\n     */\n    public CookieAttribute(String name, int maxAge) {\n        super(name);\n        setMaxAge(maxAge);\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name}, {@link javax.servlet.http.Cookie#getPath() path}, and\n     * {@link Cookie#getMaxAge() maxAge}.\n     *\n     * @param name   the Cookie {@link Cookie#getName() name}\n     * @param path   the Cookie {@link Cookie#setPath(String) path}.\n     * @param maxAge the Cookie {@link Cookie#getMaxAge() maxAge}\n     */\n    public CookieAttribute(String name, String path, int maxAge) {\n        this(name, path);\n        setMaxAge(maxAge);\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name}, {@link javax.servlet.http.Cookie#getPath() path}, and\n     * {@link Cookie#getMaxAge() maxAge}, utilizing the specified <tt>PropertyEditor<\/tt> to perform value/string\n     * conversion on the object stored as a cookie.\n     *\n     * @param name        the Cookie {@link Cookie#getName() name}\n     * @param path        the Cookie {@link Cookie#setPath(String) path}.\n     * @param maxAge      the Cookie {@link Cookie#getMaxAge() maxAge}\n     * @param editorClass the <tt>PropertyEditor<\/tt> to perform value/string conversion on the object stored as a\n     *                    Cookie.\n     */\n    public CookieAttribute(String name, String path, int maxAge, Class<? extends PropertyEditor> editorClass) {\n        super(name, editorClass);\n        setPath(path);\n        setMaxAge(maxAge);\n    }\n\n    public String getComment() {\n        return comment;\n    }\n\n    public void setComment(String comment) {\n        this.comment = comment;\n    }\n\n    public String getDomain() {\n        return domain;\n    }\n\n    public void setDomain(String domain) {\n        this.domain = domain;\n    }\n\n    /**\n     * Returns the Cookie's {@link Cookie#getPath() path} setting.  If <tt>null<\/tt>, the <tt>request<\/tt>'s\n     * {@link javax.servlet.http.HttpServletRequest#getContextPath() context path} will be used.\n     * <p/>\n     * The default is <code>null<\/code>.\n     *\n     * @return the Cookie's path, or <tt>null<\/tt> if the request's context path should be used as the path when the\n     *         cookie is created.\n     */\n    public String getPath() {\n        return path;\n    }\n\n\n    /**\n     * Sets the Cookie's {@link Cookie#getPath() path} setting.  If the argument is <tt>null<\/tt>, the <tt>request<\/tt>'s\n     * {@link javax.servlet.http.HttpServletRequest#getContextPath() context path} will be used.\n     * <p/>\n     * The default is <code>null<\/code>.\n     *\n     * @param path the Cookie's path, or <tt>null<\/tt> if the request's context path should be used as the path when the\n     *             cookie is created.\n     */\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    /**\n     * Returns the Cookie's {@link Cookie#setMaxAge(int) maxAge} setting.  Please see that JavaDoc for the semantics on\n     * the repercussions of negative, zero, and positive values for the maxAge.\n     * <p/>\n     * The default value is <code>-1<\/code>, meaning the cookie will expire when the browser is closed.\n     *\n     * @return the Cookie's {@link Cookie#setMaxAge(int) maxAge}\n     */\n    public int getMaxAge() {\n        return maxAge;\n    }\n\n    /**\n     * Sets the Cookie's {@link Cookie#setMaxAge(int) maxAge} setting.  Please see that JavaDoc for the semantics on\n     * the repercussions of negative, zero, and positive values for the maxAge.\n     * <p/>\n     * The default value is <code>-1<\/code>, meaning the cookie will expire when the browser is closed.\n     *\n     * @param maxAge the Cookie's {@link Cookie#setMaxAge(int) maxAge}\n     */\n    public void setMaxAge(int maxAge) {\n        this.maxAge = maxAge;\n    }\n\n    public boolean isSecure() {\n        return secure;\n    }\n\n    public void setSecure(boolean secure) {\n        this.secure = secure;\n    }\n\n    public int getVersion() {\n        return version;\n    }\n\n    public void setVersion(int version) {\n        this.version = version;\n    }\n\n    /**\n     * Returns the cookie with the given name from the request or <tt>null<\/tt> if no cookie\n     * with that name could be found.\n     *\n     * @param request    the current executing http request.\n     * @param cookieName the name of the cookie to find and return.\n     * @return the cookie with the given name from the request or <tt>null<\/tt> if no cookie\n     *         with that name could be found.\n     */\n    private static Cookie getCookie(HttpServletRequest request, String cookieName) {\n        Cookie cookies[] = request.getCookies();\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (cookie.getName().equals(cookieName)) {\n                    return cookie;\n                }\n            }\n        }\n        return null;\n    }\n\n    public T onRetrieveValue(ServletRequest request, ServletResponse response) {\n        T value = null;\n\n        String cookieName = getName();\n        String stringValue;\n        Cookie cookie = getCookie(toHttp(request), cookieName);\n        if (cookie != null && cookie.getMaxAge() != 0) {\n            stringValue = cookie.getValue();\n            log.debug(\"Found string value [{}] from Cookie [{}]\", stringValue, cookieName);\n            value = fromStringValue(stringValue);\n        } else {\n            log.debug(\"Not value found in request Cookies under cookie name [{}]\", cookieName);\n        }\n\n        return value;\n    }\n\n    /**\n     * Returns the Cookie's calculated path setting.  If {@link Cookie#getPath() path} <tt>null<\/tt>, then the\n     * <tt>request<\/tt>'s {@link javax.servlet.http.HttpServletRequest#getContextPath() context path}\n     * will be returned. If getContextPath() is the empty string or null then the ROOT_PATH constant is returned.\n     * <p/>\n     * The default is <code>null<\/code>.\n     *\n     * @return the path to be used as the path when the cookie is created or removed.\n     */\n    public String calculatePath(HttpServletRequest request) {\n        String calculatePath = getPath() != null ? getPath() : request.getContextPath();\n\n        //fix for http://issues.apache.org/jira/browse/JSEC-34:\n        calculatePath = StringUtils.clean(calculatePath);\n        if (calculatePath == null) {\n            calculatePath = ROOT_PATH;\n        }\n        log.trace(\"calculated path: {}\", calculatePath);\n        return calculatePath;\n    }\n\n    public void onStoreValue(T value, ServletRequest servletRequest, ServletResponse servletResponse) {\n\n        HttpServletRequest request = toHttp(servletRequest);\n        HttpServletResponse response = toHttp(servletResponse);\n\n        String name = getName();\n        String comment = getComment();\n        String domain = getDomain();\n        int version = getVersion();\n        int maxAge = getMaxAge();\n        String path = calculatePath(request);\n\n        //fix for http://issues.apache.org/jira/browse/JSEC-34:\n        path = StringUtils.clean(path);\n        if (path == null) {\n            path = ROOT_PATH;\n        }\n\n        String stringValue = toStringValue(value);\n        Cookie cookie = new Cookie(name, stringValue);\n        cookie.setMaxAge(maxAge);\n        cookie.setPath(path);\n\n        if (comment != null) {\n            cookie.setComment(comment);\n        }\n        if (domain != null) {\n            cookie.setDomain(domain);\n        }\n        if (version > DEFAULT_VERSION) {\n            cookie.setVersion(version);\n        }\n\n        if (isSecure()) {\n            cookie.setSecure(true);\n        }\n\n        response.addCookie(cookie);\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Added Cookie [{}] to path [{}] with value [{}] to the HttpServletResponse\",\n                    new Object[]{name, path, stringValue});\n        }\n    }\n\n    public void removeValue(ServletRequest servletRequest, ServletResponse response) {\n        HttpServletRequest request = toHttp(servletRequest);\n        Cookie cookie = getCookie(request, getName());\n\n        if (cookie != null) {\n            cookie.setMaxAge(0);\n            cookie.setValue(\"forgetme\");\n            //JSEC-94: Must set the path on the outgoing cookie (some browsers don't retain it from the\n            //retrieved cookie?)\n            // my testing shows none of these browsers will remove cookie if setPath() is not invoked: FF3, Chrome, IE7, Safari windows\n            cookie.setPath(calculatePath(request));\n\n            String domain = getDomain();\n            if (domain != null) {\n                cookie.setDomain(domain);\n            }\n\n            int version = getVersion();\n            if (version > DEFAULT_VERSION) {\n                cookie.setVersion(version);\n            }\n\n            cookie.setSecure(isSecure());\n            toHttp(response).addCookie(cookie);\n            log.trace(\"Removed cookie[\" + getName() + \"] with path [\" + calculatePath(request) + \"] from HttpServletResponse.\");\n        }\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.ki.web.attr;\n\nimport org.apache.ki.util.StringUtils;\nimport static org.apache.ki.web.WebUtils.toHttp;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.beans.PropertyEditor;\n\n/**\n * A <tt>CookieAttribute<\/tt> stores an object as a {@link Cookie} for access on later requests.\n *\n * @author Les Hazlewood\n * @author Peter Ledbrook\n * @since 0.2\n */\npublic class CookieAttribute<T> extends AbstractWebAttribute<T> {\n\n    //TODO - complete JavaDoc\n\n    /**\n     * Private internal log instance.\n     */\n    private static final Logger log = LoggerFactory.getLogger(CookieAttribute.class);\n\n    /**\n     * The number of seconds in one year (= 60 * 60 * 24 * 365).\n     */\n    public static final int ONE_YEAR = 60 * 60 * 24 * 365;\n    /**\n     * This is the same value as Integer.MAX_VALUE, and while Tomcat does fine with cookie max age with this value,\n     * Jetty apparently has problems with it.  If you're using Jetty, you might want to use the\n     * {@link #ONE_YEAR ONE_YEAR} constant or another value.\n     */\n    public static final int INDEFINITE = Integer.MAX_VALUE;\n\n    /**\n     * <code>null<\/code>, indicating the cookie should be set on the request context root.\n     */\n    public static final String DEFAULT_PATH = null;\n\n    /**\n     * Root path to use when the path hasn't been set and request context root is empty or null.\n     */\n    public static final String ROOT_PATH = \"/\";\n    /**\n     * <code>-1<\/code>, indicating the cookie should expire when the browser closes.\n     */\n    public static final int DEFAULT_MAX_AGE = -1;\n\n    /**\n     * <code>-1<\/code> indicating that no version property should be set on the cookie.\n     */\n    public static final int DEFAULT_VERSION = -1;\n\n    /**\n     * Default value is <code>false<\/code>.\n     */\n    public static final boolean DEFAULT_SECURE = false;\n\n    private String comment = null;\n    private String domain = null;\n    private int maxAge = DEFAULT_MAX_AGE;\n    private String path = DEFAULT_PATH;\n    private boolean secure = DEFAULT_SECURE;\n    private int version = DEFAULT_VERSION;\n\n    public CookieAttribute() {\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified {@link Cookie#getName() name}\n     * using the request context's path and with a {@link Cookie#setMaxAge(int) maxAge} of <tt>-1<\/tt>, indicating the\n     * Cookie will persist until browser shutdown.\n     *\n     * @param name the Cookie {@link Cookie#getName() name}\n     */\n    public CookieAttribute(String name) {\n        super(name);\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name} and {@link Cookie#getPath() path}.\n     * <p/>\n     * <p>A <tt>null<\/tt> <tt>path<\/tt> value means the request context's path will be used by default.\n     * <p/>\n     * <p>The Cookie's {@link Cookie#getMaxAge() maxAge} will be <tt>-1<\/tt>, indicating the Cookie will persist until\n     * browser shutdown.\n     *\n     * @param name the Cookie {@link Cookie#getName() name}\n     * @param path the Cookie {@link Cookie#setPath(String) path}.\n     */\n    public CookieAttribute(String name, String path) {\n        super(name);\n        setPath(path);\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name} and {@link Cookie#getMaxAge() maxAge}.\n     * <p/>\n     * <p>The Cookie's {@link javax.servlet.http.Cookie#getPath() path} will be the <tt>Request<\/tt>'s\n     * {@link javax.servlet.http.HttpServletRequest#getContextPath() context path}.\n     *\n     * @param name   the Cookie {@link javax.servlet.http.Cookie#getName() name};\n     * @param maxAge the Cookie {@link Cookie#getMaxAge() maxAge}\n     */\n    public CookieAttribute(String name, int maxAge) {\n        super(name);\n        setMaxAge(maxAge);\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name}, {@link javax.servlet.http.Cookie#getPath() path}, and\n     * {@link Cookie#getMaxAge() maxAge}.\n     *\n     * @param name   the Cookie {@link Cookie#getName() name}\n     * @param path   the Cookie {@link Cookie#setPath(String) path}.\n     * @param maxAge the Cookie {@link Cookie#getMaxAge() maxAge}\n     */\n    public CookieAttribute(String name, String path, int maxAge) {\n        this(name, path);\n        setMaxAge(maxAge);\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name}, {@link javax.servlet.http.Cookie#getPath() path}, and\n     * {@link Cookie#getMaxAge() maxAge}, utilizing the specified <tt>PropertyEditor<\/tt> to perform value/string\n     * conversion on the object stored as a cookie.\n     *\n     * @param name        the Cookie {@link Cookie#getName() name}\n     * @param path        the Cookie {@link Cookie#setPath(String) path}.\n     * @param maxAge      the Cookie {@link Cookie#getMaxAge() maxAge}\n     * @param editorClass the <tt>PropertyEditor<\/tt> to perform value/string conversion on the object stored as a\n     *                    Cookie.\n     */\n    public CookieAttribute(String name, String path, int maxAge, Class<? extends PropertyEditor> editorClass) {\n        super(name, editorClass);\n        setPath(path);\n        setMaxAge(maxAge);\n    }\n\n    public String getComment() {\n        return comment;\n    }\n\n    public void setComment(String comment) {\n        this.comment = comment;\n    }\n\n    public String getDomain() {\n        return domain;\n    }\n\n    public void setDomain(String domain) {\n        this.domain = domain;\n    }\n\n    /**\n     * Returns the Cookie's {@link Cookie#getPath() path} setting.  If <tt>null<\/tt>, the <tt>request<\/tt>'s\n     * {@link javax.servlet.http.HttpServletRequest#getContextPath() context path} will be used.\n     * <p/>\n     * The default is <code>null<\/code>.\n     *\n     * @return the Cookie's path, or <tt>null<\/tt> if the request's context path should be used as the path when the\n     *         cookie is created.\n     */\n    public String getPath() {\n        return path;\n    }\n\n\n    /**\n     * Sets the Cookie's {@link Cookie#getPath() path} setting.  If the argument is <tt>null<\/tt>, the <tt>request<\/tt>'s\n     * {@link javax.servlet.http.HttpServletRequest#getContextPath() context path} will be used.\n     * <p/>\n     * <p>The default is <code>null<\/code>.<\/p>\n     *\n     * @param path the Cookie's path, or <tt>null<\/tt> if the request's context path should be used as the path when the\n     *             cookie is created.\n     */\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    /**\n     * Returns the Cookie's {@link Cookie#setMaxAge(int) maxAge} setting.  Please see that JavaDoc for the semantics on\n     * the repercussions of negative, zero, and positive values for the maxAge.\n     * <p/>\n     * <p>The default value is <code>-1<\/code>, meaning the cookie will expire when the browser is closed.<\/p>\n     *\n     * @return the Cookie's {@link Cookie#setMaxAge(int) maxAge}\n     */\n    public int getMaxAge() {\n        return maxAge;\n    }\n\n    /**\n     * Sets the Cookie's {@link Cookie#setMaxAge(int) maxAge} setting.  Please see that JavaDoc for the semantics on\n     * the repercussions of negative, zero, and positive values for the maxAge.\n     * <p/>\n     * <p>The default value is <code>-1<\/code>, meaning the cookie will expire when the browser is closed.<\/p>\n     *\n     * @param maxAge the Cookie's {@link Cookie#setMaxAge(int) maxAge}\n     */\n    public void setMaxAge(int maxAge) {\n        this.maxAge = maxAge;\n    }\n\n    public boolean isSecure() {\n        return secure;\n    }\n\n    public void setSecure(boolean secure) {\n        this.secure = secure;\n    }\n\n    public int getVersion() {\n        return version;\n    }\n\n    public void setVersion(int version) {\n        this.version = version;\n    }\n\n    /**\n     * Returns the cookie with the given name from the request or <tt>null<\/tt> if no cookie\n     * with that name could be found.\n     *\n     * @param request    the current executing http request.\n     * @param cookieName the name of the cookie to find and return.\n     * @return the cookie with the given name from the request or <tt>null<\/tt> if no cookie\n     *         with that name could be found.\n     */\n    private static Cookie getCookie(HttpServletRequest request, String cookieName) {\n        Cookie cookies[] = request.getCookies();\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (cookie.getName().equals(cookieName)) {\n                    return cookie;\n                }\n            }\n        }\n        return null;\n    }\n\n    public T onRetrieveValue(ServletRequest request, ServletResponse response) {\n        T value = null;\n\n        String stringValue;\n        Cookie cookie = getCookie(toHttp(request), getName());\n        if (cookie != null && cookie.getMaxAge() != 0) {\n            stringValue = cookie.getValue();\n            if (log.isDebugEnabled()) {\n                log.debug(\"Found string value [\" + stringValue + \"] from HttpServletRequest Cookie [\" + getName() + \"]\");\n            }\n            value = fromStringValue(stringValue);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No value found in request Cookies under cookie name [\" + getName() + \"]\");\n            }\n        }\n\n        return value;\n    }\n\n    /**\n     * Returns the Cookie's calculated path setting.  If {@link Cookie#getPath() path} <tt>null<\/tt>, then the\n     * <tt>request<\/tt>'s {@link javax.servlet.http.HttpServletRequest#getContextPath() context path}\n     * will be returned. If getContextPath() is the empty string or null then the ROOT_PATH constant is returned.\n     * <p/>\n     * <p>The default is <code>null<\/code>.<\/p>\n     *\n     * @return the path to be used as the path when the cookie is created or removed.\n     */\n    public String calculatePath(HttpServletRequest request) {\n        String calculatePath = getPath() != null ? getPath() : request.getContextPath();\n\n        //fix for http://issues.apache.org/jira/browse/JSEC-34:\n        calculatePath = StringUtils.clean(calculatePath);\n        if (calculatePath == null) {\n            calculatePath = ROOT_PATH;\n        }\n        log.trace(\"calculatePath: returning=\" + calculatePath);\n        return calculatePath;\n    }\n\n    public void onStoreValue(T value, ServletRequest servletRequest, ServletResponse servletResponse) {\n\n        HttpServletRequest request = toHttp(servletRequest);\n        HttpServletResponse response = toHttp(servletResponse);\n\n        String name = getName();\n        String comment = getComment();\n        String domain = getDomain();\n        int version = getVersion();\n        int maxAge = getMaxAge();\n        String path = calculatePath(request);\n\n        //fix for http://issues.apache.org/jira/browse/JSEC-34:\n        path = StringUtils.clean(path);\n        if (path == null) {\n            path = ROOT_PATH;\n        }\n\n        String stringValue = toStringValue(value);\n        Cookie cookie = new Cookie(name, stringValue);\n        cookie.setMaxAge(maxAge);\n        cookie.setPath(path);\n\n        if (comment != null) {\n            cookie.setComment(comment);\n        }\n        if (domain != null) {\n            cookie.setDomain(domain);\n        }\n        if (version > DEFAULT_VERSION) {\n            cookie.setVersion(version);\n        }\n\n        if (isSecure()) {\n            cookie.setSecure(true);\n        }\n\n        response.addCookie(cookie);\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Added Cookie [\" + name + \"] to path [\" + path + \"] with value [\" +\n                    stringValue + \"] to the HttpServletResponse.\");\n        }\n    }\n\n    public void removeValue(ServletRequest servletRequest, ServletResponse response) {\n        HttpServletRequest request = toHttp(servletRequest);\n        Cookie cookie = getCookie(request, getName());\n\n        if (cookie != null) {\n            cookie.setMaxAge(0);\n            cookie.setValue(\"forgetme\");\n            //JSEC-94: Must set the path on the outgoing cookie (some browsers don't retain it from the\n            //retrieved cookie?)\n            // my testing shows none of these browsers will remove cookie if setPath() is not invoked: FF3, Chrome, IE7, Safari windows\n            cookie.setPath(calculatePath(request));\n\n            String domain = getDomain();\n            if (domain != null) {\n                cookie.setDomain(domain);\n            }\n\n            int version = getVersion();\n            if (version > DEFAULT_VERSION) {\n                cookie.setVersion(version);\n            }\n\n            cookie.setSecure(isSecure());\n            toHttp(response).addCookie(cookie);\n            log.trace(\"Removed cookie[\" + getName() + \"] with path [\" + calculatePath(request) + \"] from HttpServletResponse.\");\n        }\n    }\n}\n","lineNo":276}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.ki.subject;\n\nimport org.apache.ki.authc.AuthenticationException;\nimport org.apache.ki.authc.AuthenticationToken;\nimport org.apache.ki.authc.InetAuthenticationToken;\nimport org.apache.ki.authz.AuthorizationException;\nimport org.apache.ki.authz.Permission;\nimport org.apache.ki.authz.UnauthenticatedException;\nimport org.apache.ki.mgt.SecurityManager;\nimport org.apache.ki.session.InvalidSessionException;\nimport org.apache.ki.session.ProxiedSession;\nimport org.apache.ki.session.Session;\nimport org.apache.ki.session.mgt.DelegatingSession;\nimport org.apache.ki.util.ThreadContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * Implementation of the <tt>Subject<\/tt> interface that delegates\n * method calls to an underlying {@link org.apache.ki.mgt.SecurityManager SecurityManager} instance for security checks.\n * It is essentially a <tt>SecurityManager<\/tt> proxy.\n * <p/>\n * This implementation does not maintain state such as roles and permissions (only <code>Subject<\/code>\n * {@link #getPrincipals() principals}, such as usernames or user primary keys) for better performance in a stateless\n * architecture.  It instead asks the underlying <tt>SecurityManager<\/tt> every time to perform\n * the authorization check.\n * <p/>\n * A common misconception in using this implementation is that an EIS resource (RDBMS, etc) would\n * be &quot;hit&quot; every time a method is called.  This is not necessarily the case and is\n * up to the implementation of the underlying <tt>SecurityManager<\/tt> instance.  If caching of authorization\n * data is desired (to eliminate EIS round trips and therefore improve database performance), it is considered\n * much more elegant to let the underlying <tt>SecurityManager<\/tt> implementation or its delegate components\n * manage caching, not this class.  A <tt>SecurityManager<\/tt> is considered a business-tier component,\n * where caching strategies are better suited.\n * <p/>\n * Applications from large and clustered to simple and vm local all benefit from\n * stateless architectures.  This implementation plays a part in the stateless programming\n * paradigm and should be used whenever possible.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DelegatingSubject implements Subject {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(DelegatingSubject.class);\n\n    protected PrincipalCollection principals = new SimplePrincipalCollection();\n    protected boolean authenticated = false;\n    protected InetAddress inetAddress = null;\n    protected Session session = null;\n\n    protected SecurityManager securityManager;\n\n    public DelegatingSubject(SecurityManager securityManager) {\n        this(null, false, getLocalHost(), null, securityManager);\n    }\n\n    public DelegatingSubject(PrincipalCollection principals, boolean authenticated, InetAddress inetAddress,\n                             Session session, SecurityManager securityManager) {\n        if (securityManager == null) {\n            throw new IllegalArgumentException(\"SecurityManager argument cannot be null.\");\n        }\n        this.securityManager = securityManager;\n        this.principals = principals;\n\n        this.authenticated = authenticated;\n\n        if (inetAddress != null) {\n            this.inetAddress = inetAddress;\n        } else {\n            this.inetAddress = getLocalHost();\n        }\n        if (session != null) {\n            this.session = decorate(session);\n        }\n    }\n\n    protected static InetAddress getLocalHost() {\n        try {\n            return InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            return null;\n        }\n    }\n\n    protected Session decorate(Session session) {\n        if (session == null) {\n            throw new IllegalArgumentException(\"session cannot be null\");\n        }\n        return decorateSession(session.getId());\n    }\n\n    protected Session decorateSession(Serializable sessionId) {\n        if (sessionId == null) {\n            throw new IllegalArgumentException(\"sessionId cannot be null\");\n        }\n        DelegatingSession target = new DelegatingSession(getSecurityManager(), sessionId);\n        return new StoppingAwareProxiedSession(target, this);\n    }\n\n    public SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected boolean hasPrincipals() {\n        PrincipalCollection pc = getPrincipals();\n        return pc != null && !pc.isEmpty();\n    }\n\n    /**\n     * Returns the InetAddress associated with the client who created/is interacting with this Subject.\n     *\n     * @return the InetAddress associated with the client who created/is interacting with this Subject.\n     */\n    public InetAddress getInetAddress() {\n        return this.inetAddress;\n    }\n\n    /**\n     * @see Subject#getPrincipal()\n     */\n    public Object getPrincipal() {\n        PrincipalCollection principals = getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            return null;\n        }\n        return principals.asSet().iterator().next();\n    }\n\n    public PrincipalCollection getPrincipals() {\n        return this.principals;\n    }\n\n    public boolean isPermitted(String permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean isPermitted(Permission permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean[] isPermitted(String... permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.length];\n        }\n    }\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.size()];\n        }\n    }\n\n    public boolean isPermittedAll(String... permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    protected void assertAuthzCheckPossible() throws AuthorizationException {\n        if (!hasPrincipals()) {\n            String msg = \"Identity principals are not associated with this Subject instance - \" +\n                    \"authorization operations require an identity to check against.  A Subject instance will \" +\n                    \"acquire these identifying principals automatically after a successful login is performed \" +\n                    \"be executing \" + Subject.class.getName() + \".login(AuthenticationToken) or when 'Remember Me' \" +\n                    \"functionality is enabled.  This exception can also occur when the current Subject has logged out, \" +\n                    \"which relinquishes its identity and essentially makes it anonymous again.  \" +\n                    \"Because an identity is currently not known due to any of these conditions, \" +\n                    \"authorization is denied.\";\n            throw new UnauthenticatedException(msg);\n        }\n    }\n\n    public void checkPermission(String permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermissions(String... permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public boolean hasRole(String roleIdentifier) {\n        return hasPrincipals() && securityManager.hasRole(getPrincipals(), roleIdentifier);\n    }\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        if (hasPrincipals()) {\n            return securityManager.hasRoles(getPrincipals(), roleIdentifiers);\n        } else {\n            return new boolean[roleIdentifiers.size()];\n        }\n    }\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        return hasPrincipals() && securityManager.hasAllRoles(getPrincipals(), roleIdentifiers);\n    }\n\n    public void checkRole(String role) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRole(getPrincipals(), role);\n    }\n\n    public void checkRoles(Collection<String> roles) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRoles(getPrincipals(), roles);\n    }\n\n    public void login(AuthenticationToken token) throws AuthenticationException {\n        Subject subject = securityManager.login(token);\n        PrincipalCollection principals = subject.getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            String msg = \"Principals returned from securityManager.login( token ) returned a null or \" +\n                    \"empty value.  This value must be non null and populated with one or more elements.  \" +\n                    \"Please check the SecurityManager implementation to ensure this happens after a \" +\n                    \"successful login attempt.\";\n            throw new IllegalStateException(msg);\n        }\n        this.principals = principals;\n        Session session = subject.getSession(false);\n        if (session != null) {\n            this.session = decorate(session);\n        } else {\n            this.session = null;\n        }\n        this.authenticated = true;\n        if (token instanceof InetAuthenticationToken) {\n            InetAddress addy = ((InetAuthenticationToken) token).getInetAddress();\n            if (addy != null) {\n                this.inetAddress = addy;\n            }\n        }\n        ThreadContext.bind(this);\n    }\n\n    public boolean isAuthenticated() {\n        return authenticated;\n    }\n\n    public Session getSession() {\n        return getSession(true);\n    }\n\n    public Session getSession(boolean create) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"attempting to get session; create = \" + create + \"; session is null = \" + (this.session == null) + \"; session has id = \" + (this.session != null && session.getId() != null));\n        }\n\n        if (this.session == null && create) {\n            InetAddress host = getInetAddress();\n            log.trace(\"Starting session for host {}\", host);\n            Serializable sessionId = this.securityManager.start(host);\n            this.session = decorateSession(sessionId);\n        }\n        return this.session;\n    }\n\n    public void logout() {\n        try {\n            this.securityManager.logout(getPrincipals());\n        } finally {\n            this.session = null;\n            this.principals = null;\n            this.authenticated = false;\n            //Don't set securityManager to null here - the Subject can be continued to be\n            //used, it is just considered anonymous at this point.  The SecurityManager instance is\n            //necessary if the subject would log in again or acquire a new session.  This is in response to\n            //https://issues.apache.org/jira/browse/JSEC-22\n            //this.securityManager = null;\n\n            //also keep the inetAddress to retain their location:\n            //this.inetAddress = null;\n        }\n    }\n\n    private void sessionStopped() {\n        this.session = null;\n    }\n\n    private class StoppingAwareProxiedSession extends ProxiedSession {\n\n        private final DelegatingSubject owner;\n\n        private StoppingAwareProxiedSession(Session target, DelegatingSubject owningSubject) {\n            super(target);\n            owner = owningSubject;\n        }\n\n        public void stop() throws InvalidSessionException {\n            super.stop();\n            owner.sessionStopped();\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.ki.subject;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport org.apache.ki.authc.AuthenticationException;\nimport org.apache.ki.authc.AuthenticationToken;\nimport org.apache.ki.authc.InetAuthenticationToken;\nimport org.apache.ki.authz.AuthorizationException;\nimport org.apache.ki.authz.Permission;\nimport org.apache.ki.authz.UnauthenticatedException;\nimport org.apache.ki.mgt.SecurityManager;\nimport org.apache.ki.session.InvalidSessionException;\nimport org.apache.ki.session.ProxiedSession;\nimport org.apache.ki.session.Session;\nimport org.apache.ki.session.mgt.DelegatingSession;\nimport org.apache.ki.util.ThreadContext;\n\n/**\n * Implementation of the <tt>Subject<\/tt> interface that delegates\n * method calls to an underlying {@link org.apache.ki.mgt.SecurityManager SecurityManager} instance for security checks.\n * It is essentially a <tt>SecurityManager<\/tt> proxy.\n * <p/>\n * This implementation does not maintain state such as roles and permissions (only <code>Subject<\/code>\n * {@link #getPrincipals() principals}, such as usernames or user primary keys) for better performance in a stateless\n * architecture.  It instead asks the underlying <tt>SecurityManager<\/tt> every time to perform\n * the authorization check.\n * <p/>\n * A common misconception in using this implementation is that an EIS resource (RDBMS, etc) would\n * be &quot;hit&quot; every time a method is called.  This is not necessarily the case and is\n * up to the implementation of the underlying <tt>SecurityManager<\/tt> instance.  If caching of authorization\n * data is desired (to eliminate EIS round trips and therefore improve database performance), it is considered\n * much more elegant to let the underlying <tt>SecurityManager<\/tt> implementation or its delegate components\n * manage caching, not this class.  A <tt>SecurityManager<\/tt> is considered a business-tier component,\n * where caching strategies are better suited.\n * <p/>\n * Applications from large and clustered to simple and vm local all benefit from\n * stateless architectures.  This implementation plays a part in the stateless programming\n * paradigm and should be used whenever possible.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DelegatingSubject implements Subject {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(DelegatingSubject.class);\n\n    protected PrincipalCollection principals = new SimplePrincipalCollection();\n    protected boolean authenticated = false;\n    protected InetAddress inetAddress = null;\n    protected Session session = null;\n\n    protected SecurityManager securityManager;\n\n    public DelegatingSubject(SecurityManager securityManager) {\n        this(null, false, getLocalHost(), null, securityManager);\n    }\n\n    public DelegatingSubject(PrincipalCollection principals, boolean authenticated, InetAddress inetAddress,\n                             Session session, SecurityManager securityManager) {\n        if (securityManager == null) {\n            throw new IllegalArgumentException(\"SecurityManager argument cannot be null.\");\n        }\n        this.securityManager = securityManager;\n        this.principals = principals;\n\n        this.authenticated = authenticated;\n\n        if (inetAddress != null) {\n            this.inetAddress = inetAddress;\n        } else {\n            this.inetAddress = getLocalHost();\n        }\n        if (session != null) {\n            this.session = decorate(session);\n        }\n    }\n\n    protected static InetAddress getLocalHost() {\n        try {\n            return InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            return null;\n        }\n    }\n\n    protected Session decorate(Session session) {\n        if (session == null) {\n            throw new IllegalArgumentException(\"session cannot be null\");\n        }\n        return decorateSession(session.getId());\n    }\n\n    protected Session decorateSession(Serializable sessionId) {\n        if (sessionId == null) {\n            throw new IllegalArgumentException(\"sessionId cannot be null\");\n        }\n        DelegatingSession target = new DelegatingSession(getSecurityManager(), sessionId);\n        return new StoppingAwareProxiedSession(target, this);\n    }\n\n    public SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected boolean hasPrincipals() {\n        PrincipalCollection pc = getPrincipals();\n        return pc != null && !pc.isEmpty();\n    }\n\n    /**\n     * Returns the InetAddress associated with the client who created/is interacting with this Subject.\n     *\n     * @return the InetAddress associated with the client who created/is interacting with this Subject.\n     */\n    public InetAddress getInetAddress() {\n        return this.inetAddress;\n    }\n\n    /** @see Subject#getPrincipal() */\n    public Object getPrincipal() {\n        PrincipalCollection principals = getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            return null;\n        }\n        return principals.asSet().iterator().next();\n    }\n\n    public PrincipalCollection getPrincipals() {\n        return this.principals;\n    }\n\n    public boolean isPermitted(String permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean isPermitted(Permission permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean[] isPermitted(String... permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.length];\n        }\n    }\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.size()];\n        }\n    }\n\n    public boolean isPermittedAll(String... permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    protected void assertAuthzCheckPossible() throws AuthorizationException {\n        if (!hasPrincipals()) {\n            String msg = \"Identity principals are not associated with this Subject instance - \" +\n                    \"authorization operations require an identity to check against.  A Subject instance will \" +\n                    \"acquire these identifying principals automatically after a successful login is performed \" +\n                    \"be executing \" + Subject.class.getName() + \".login(AuthenticationToken) or when 'Remember Me' \" +\n                    \"functionality is enabled.  This exception can also occur when the current Subject has logged out, \" +\n                    \"which relinquishes its identity and essentially makes it anonymous again.  \" +\n                    \"Because an identity is currently not known due to any of these conditions, \" +\n                    \"authorization is denied.\";\n            throw new UnauthenticatedException(msg);\n        }\n    }\n\n    public void checkPermission(String permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermissions(String... permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public boolean hasRole(String roleIdentifier) {\n        return hasPrincipals() && securityManager.hasRole(getPrincipals(), roleIdentifier);\n    }\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        if (hasPrincipals()) {\n            return securityManager.hasRoles(getPrincipals(), roleIdentifiers);\n        } else {\n            return new boolean[roleIdentifiers.size()];\n        }\n    }\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        return hasPrincipals() && securityManager.hasAllRoles(getPrincipals(), roleIdentifiers);\n    }\n\n    public void checkRole(String role) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRole(getPrincipals(), role);\n    }\n\n    public void checkRoles(Collection<String> roles) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRoles(getPrincipals(), roles);\n    }\n\n    public void login(AuthenticationToken token) throws AuthenticationException {\n        Subject subject = securityManager.login(token);\n        PrincipalCollection principals = subject.getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            String msg = \"Principals returned from securityManager.login( token ) returned a null or \" +\n                    \"empty value.  This value must be non null and populated with one or more elements.  \" +\n                    \"Please check the SecurityManager implementation to ensure this happens after a \" +\n                    \"successful login attempt.\";\n            throw new IllegalStateException(msg);\n        }\n        this.principals = principals;\n        Session session = subject.getSession(false);\n        if (session != null) {\n            this.session = decorate(session);\n        } else {\n            this.session = null;\n        }\n        this.authenticated = true;\n        if (token instanceof InetAuthenticationToken) {\n            InetAddress addy = ((InetAuthenticationToken) token).getInetAddress();\n            if (addy != null) {\n                this.inetAddress = addy;\n            }\n        }\n        ThreadContext.bind(this);\n    }\n\n    public boolean isAuthenticated() {\n        return authenticated;\n    }\n\n    public Session getSession() {\n        return getSession(true);\n    }\n\n    public Session getSession(boolean create) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"attempting to get session; create = \" + create + \"; session is null = \" + (this.session == null) + \"; session has id = \" + (this.session != null && session.getId() != null));\n        }\n\n        if (this.session == null && create) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"starting session for address [\" + getInetAddress() + \"]\");\n            }\n            Serializable sessionId = this.securityManager.start(getInetAddress());\n            this.session = decorateSession(sessionId);\n        }\n        return this.session;\n    }\n\n    public void logout() {\n        try {\n            this.securityManager.logout(getPrincipals());\n        } finally {\n            this.session = null;\n            this.principals = null;\n            this.authenticated = false;\n            //Don't set securityManager to null here - the Subject can be continued to be\n            //used, it is just considered anonymous at this point.  The SecurityManager instance is\n            //necessary if the subject would log in again or acquire a new session.  This is in response to\n            //https://issues.apache.org/jira/browse/JSEC-22\n            //this.securityManager = null;\n\n            //also keep the inetAddress to retain their location:\n            //this.inetAddress = null;\n        }\n    }\n\n    private void sessionStopped() {\n        this.session = null;\n    }\n\n    private class StoppingAwareProxiedSession extends ProxiedSession {\n\n        private final DelegatingSubject owner;\n\n        private StoppingAwareProxiedSession(Session target, DelegatingSubject owningSubject) {\n            super(target);\n            owner = owningSubject;\n        }\n\n        public void stop() throws InvalidSessionException {\n            super.stop();\n            owner.sessionStopped();\n        }\n    }\n\n}\n","lineNo":294}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.ki.session.mgt;\n\nimport org.apache.ki.cache.CacheManager;\nimport org.apache.ki.cache.CacheManagerAware;\nimport org.apache.ki.session.InvalidSessionException;\nimport org.apache.ki.session.Session;\nimport org.apache.ki.session.mgt.eis.MemorySessionDAO;\nimport org.apache.ki.session.mgt.eis.SessionDAO;\nimport org.apache.ki.util.CollectionUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport java.util.Date;\n\n\n/**\n * Default business-tier implementation of a {@link ValidatingSessionManager}.  All session CRUD operations are\n * delegated to an internal {@link SessionDAO}.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class DefaultSessionManager extends AbstractValidatingSessionManager implements CacheManagerAware {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(DefaultSessionManager.class);\n\n    protected SessionDAO sessionDAO;\n\n    public DefaultSessionManager() {\n        this.sessionDAO = new MemorySessionDAO();\n    }\n\n    public void setSessionDAO(SessionDAO sessionDAO) {\n        this.sessionDAO = sessionDAO;\n    }\n\n    public SessionDAO getSessionDAO() {\n        return this.sessionDAO;\n    }\n\n    public void setCacheManager(CacheManager cacheManager) {\n        if (this.sessionDAO instanceof CacheManagerAware) {\n            ((CacheManagerAware) this.sessionDAO).setCacheManager(cacheManager);\n        }\n    }\n\n    protected Session doCreateSession(InetAddress originatingHost) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Creating session for originating host [\" + originatingHost + \"]\");\n        }\n        Session s = newSessionInstance(originatingHost);\n        create(s);\n        return s;\n    }\n\n    protected Session newSessionInstance(InetAddress inetAddress) {\n        return new SimpleSession(inetAddress);\n    }\n\n    protected void create(Session session) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Creating new EIS record for new session instance [\" + session + \"]\");\n        }\n        sessionDAO.create(session);\n    }\n\n    protected void onStop(Session session) {\n        if (session instanceof SimpleSession) {\n            SimpleSession ss = (SimpleSession)session;\n            Date stopTs = ss.getStopTimestamp();\n            ss.setLastAccessTime(stopTs);\n        }\n        onChange(session);\n    }\n\n    protected void onExpiration(Session session) {\n        if (session instanceof SimpleSession) {\n            ((SimpleSession) session).setExpired(true);\n        }\n        onChange(session);\n    }\n\n    protected void onChange(Session session) {\n        sessionDAO.update(session);\n    }\n\n    protected Session retrieveSession(Serializable sessionId) throws InvalidSessionException {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Attempting to retrieve session with id [\" + sessionId + \"]\");\n        }\n        return retrieveSessionFromDataSource(sessionId);\n    }\n\n    protected Session retrieveSessionFromDataSource(Serializable sessionId) throws InvalidSessionException {\n        return sessionDAO.readSession(sessionId);\n    }\n\n    protected Collection<Session> getActiveSessions() {\n        Collection<Session> active = sessionDAO.getActiveSessions();\n        return active != null ? active : CollectionUtils.emptyCollection(Session.class);\n    }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.ki.session.mgt;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport java.util.Date;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.apache.ki.cache.CacheManager;\nimport org.apache.ki.cache.CacheManagerAware;\nimport org.apache.ki.session.InvalidSessionException;\nimport org.apache.ki.session.ReplacedSessionException;\nimport org.apache.ki.session.Session;\nimport org.apache.ki.session.mgt.eis.MemorySessionDAO;\nimport org.apache.ki.session.mgt.eis.SessionDAO;\nimport org.apache.ki.util.CollectionUtils;\nimport org.apache.ki.util.ThreadContext;\n\n\n/**\n * Default business-tier implementation of the {@link ValidatingSessionManager} interface.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class DefaultSessionManager extends AbstractValidatingSessionManager implements CacheManagerAware {\n\n    //TODO - complete JavaDoc\n\n    private static final Log log = LogFactory.getLog(DefaultSessionManager.class);\n\n    protected SessionDAO sessionDAO;\n\n    public DefaultSessionManager() {\n        this.sessionDAO = new MemorySessionDAO();\n    }\n\n    public void setSessionDAO(SessionDAO sessionDAO) {\n        this.sessionDAO = sessionDAO;\n    }\n\n    public SessionDAO getSessionDAO() {\n        return this.sessionDAO;\n    }\n\n    public void setCacheManager(CacheManager cacheManager) {\n        if (this.sessionDAO instanceof CacheManagerAware) {\n            ((CacheManagerAware) this.sessionDAO).setCacheManager(cacheManager);\n        }\n    }\n\n    protected Session doCreateSession(InetAddress originatingHost) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Creating session for originating host [\" + originatingHost + \"]\");\n        }\n        Session s = newSessionInstance(originatingHost);\n        create(s);\n        return s;\n    }\n\n    protected Session newSessionInstance(InetAddress inetAddress) {\n        return new SimpleSession(inetAddress);\n    }\n\n    protected void create(Session session) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Creating new EIS record for new session instance [\" + session + \"]\");\n        }\n        sessionDAO.create(session);\n    }\n\n    protected void onStop(Session session) {\n        if (session instanceof SimpleSession) {\n            Date stopTs = ((SimpleSession) session).getStopTimestamp();\n            ((SimpleSession) session).setLastAccessTime(stopTs);\n        }\n        super.onStop(session);\n    }\n\n    protected void onExpiration(Session session) {\n        if (session instanceof SimpleSession) {\n            ((SimpleSession) session).setExpired(true);\n        }\n        onChange(session);\n    }\n\n    protected void onChange(Session session) {\n        sessionDAO.update(session);\n    }\n\n    protected Session retrieveSession(Serializable sessionId) throws InvalidSessionException {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Attempting to retrieve session with id [\" + sessionId + \"]\");\n        }\n        InetAddress hostAddress = null;\n        try {\n            Session s = sessionDAO.readSession(sessionId);\n            //save the host address in case the session will be invalidated.  We want to retain it for the\n            //replacement session:\n            hostAddress = s.getHostAddress();\n            validate(s);\n            return s;\n        } catch (InvalidSessionException ise) {\n            if (isAutoCreateAfterInvalidation()) {\n                if (hostAddress == null) {\n                    //try the threadContext as a last resort:\n                    hostAddress = ThreadContext.getInetAddress();\n                }\n                Serializable newId = start(hostAddress);\n                String msg = \"Session with id [\" + sessionId + \"] is invalid.  The SessionManager \" +\n                        \"has been configured to automatically re-create sessions upon invalidation.  Returnining \" +\n                        \"new session id [\" + newId + \"] with exception so the caller may react accordingly.\";\n                throw new ReplacedSessionException(msg, ise, sessionId, newId);\n            } else {\n                //propagate original exception:\n                throw ise;\n            }\n        }\n    }\n\n    protected Collection<Session> getActiveSessions() {\n        Collection<Session> active = sessionDAO.getActiveSessions();\n        return active != null ? active : CollectionUtils.emptyCollection(Session.class);\n    }\n\n}\n","lineNo":92}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.config.Configuration;\nimport org.jsecurity.config.ConfigurationException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.util.ClassUtils;\nimport org.jsecurity.util.LifecycleUtils;\nimport static org.jsecurity.util.StringUtils.clean;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.DefaultWebSecurityManager;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.config.IniWebConfiguration;\nimport org.jsecurity.web.config.WebConfiguration;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.beans.PropertyDescriptor;\nimport java.io.IOException;\nimport java.net.InetAddress;\n\n/**\n * Main ServletFilter that configures and enables all JSecurity functions within a web application.\n * <p/>\n * The following is a fully commented example that documents how to configure it:\n * <p/>\n * <pre>&lt;filter&gt;\n * &lt;filter-name&gt;JSecurityFilter&lt;/filter-name&gt;\n * &lt;filter-class&gt;org.jsecurity.web.servlet.JSecurityFilter&lt;/filter-class&gt;\n * &lt;init-param&gt;&lt;param-name&gt;config&lt;/param-name&gt;&lt;param-value&gt;\n * <p/>\n * #NOTE:  This config looks pretty long - but its not - its only 5 lines of actual config.\n * #       Everything else is just heavily commented to explain things in-depth. Feel free to delete any\n * #       comments that you don't want to read from your own configuration ;)\n * #\n * # Any commented values below are JSecurity's defaults.  If you want to change any values, you only\n * # need to uncomment the lines you want to change.\n * <p/>\n * [main]\n * # The 'main' section defines JSecurity-wide configuration.\n * #\n * # Session Mode: By default, JSecurity's Session infrastructure in a web environment will use the\n * # Servlet container's HttpSession.  However, if you need to share session state across client types\n * # (e.g. Web MVC plus Java Web Start or Flash), or are doing distributed/shared Sessions for\n * # Single Sign On, HttpSessions aren't good enough.  You'll need to use JSecurity's more powerful\n * # (and client-agnostic) session management.  You can enable this by uncommenting the following line\n * # and changing 'http' to 'jsecurity'\n * #\n * #securityManager = {@link org.jsecurity.web.DefaultWebSecurityManager org.jsecurity.web.DefaultWebSecurityManager}\n * #securityManager.{@link org.jsecurity.web.DefaultWebSecurityManager#setSessionMode(String) sessionMode} = http\n * <p/>\n * [filters]\n * # This section defines the 'pool' of all Filters available to the url path definitions in the [urls] section below.\n * #\n * # The following commented values are already provided by JSecurity by default and are immediately usable\n * # in the [urls] definitions below.  If you like, you may override any values by uncommenting only the lines\n * # you need to change.\n * #\n * # Each Filter is configured based on its functionality and/or protocol.  You should read each\n * # Filter's JavaDoc to fully understand what each does and how it works as well as how it would\n * # affect the user experience.\n * #\n * # Form-based Authentication filter:\n * #<a name=\"authc\"><\/a>authc = {@link org.jsecurity.web.filter.authc.FormAuthenticationFilter}\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setLoginUrl(String) loginUrl} = /login.jsp\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setUsernameParam(String) usernameParam} = username\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setPasswordParam(String) passwordParam} = password\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setRememberMeParam(String) rememberMeParam} = rememberMe\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setSuccessUrl(String) successUrl}  = /login.jsp\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setFailureKeyAttribute(String) failureKeyAttribute} = {@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#DEFAULT_ERROR_KEY_ATTRIBUTE_NAME}\n * #\n * # Http BASIC Authentication filter:\n * #<a name=\"authcBasic\"><\/a>authcBasic = {@link org.jsecurity.web.filter.authc.BasicHttpAuthenticationFilter}\n * #authcBasic.{@link org.jsecurity.web.filter.authc.BasicHttpAuthenticationFilter#setApplicationName(String) applicationName} = application\n * #\n * # Roles filter: requires the requesting user to have one or more roles for the request to continue.\n * # If they do not have the specified roles, they are redirected to the specified URL.\n * #<a name=\"roles\"><\/a>roles = {@link org.jsecurity.web.filter.authz.RolesAuthorizationFilter}\n * #roles.{@link org.jsecurity.web.filter.authz.RolesAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.\n * #\n * # Permissions filter: requires the requesting user to have one or more permissions for the request to\n * # continue, and if they do not, redirects them to the specified URL.\n * #<a name=\"perms\"><\/a>perms = {@link org.jsecurity.web.filter.authz.PermissionsAuthorizationFilter}\n * #perms.{@link org.jsecurity.web.filter.authz.PermissionsAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.  Many\n * # applications like to use the same url specified in roles.unauthorizedUrl above.\n * #\n * #\n * # Define your own filters here.  To properly handle url path matching (see the [urls] section below), your\n * # filter should extend the {@link org.jsecurity.web.filter.PathMatchingFilter PathMatchingFilter} abstract class.\n * <p/>\n * [urls]\n * # This section defines url path mappings.  Each mapping entry must be on a single line and conform to the\n * # following representation:\n * #\n * # ant_path_expression = path_specific_filter_chain_definition\n * #\n * # For any request that matches a specified path, the corresponding value defines a comma-delimited chain of\n * # filters to execute for that request.\n * #\n * # This is incredibly powerful in that you can define arbitrary filter chains for any given request pattern\n * # to greatly customize the security experience.\n * #\n * # The path_specific_filter_chain_definition must match the following format:\n * #\n * # filter1[optional_config1], filter2[optional_config2], ..., filterN[optional_configN]\n * #\n * # where 'filterN' is the name of an filter defined above in the [filters] section and\n * # '[optional_configN]' is an optional bracketed string that has meaning for that particular filter for\n * # _that particular path_.  If the filter does not need specific config for that url path, you may\n * # discard the brackets - that is, filterN[] just becomes filterN.\n * #\n * # And because filter tokens define chains, order matters!  Define the tokens for each path pattern\n * # in the order you want them to filter (comma-delimited).\n * #\n * # Finally, each filter is free to handle the response however it wants if its necessary\n * # conditions are not met (redirect, HTTP error code, direct rendering, etc).  Otherwise, it is expected to allow\n * # the request to continue through the chain on to the final destination view.\n * #\n * # Examples:\n * #\n * # To illustrate chain configuration, look at the /account/** mapping below.  This says\n * # &quot;apply the above 'authcBasic' filter to any request matching the '/account/**' pattern&quot;.  Since the\n * # 'authcBasic' filter does not need any path-specific config, it doesn't have any config brackets [].\n * #\n * # The /remoting/** definition on the other hand uses the 'roles' and 'perms' filters which do use\n * # bracket notation.  That definition says:\n * #\n * # &quot;To access /remoting/** urls, ensure that the user is first authenticated ('authcBasic'), then ensure that user\n * # has the 'b2bClient' role, and then finally ensure that they have the 'remote:invoke:lan,wan' permission.&quot;\n * #\n * # (Note that because elements within brackets [ ] are comma-delimited themselves, we needed to escape the permission\n * # actions of 'lan,wan' with quotes.  If we didn't do that, the permission filter would interpret\n * # the text between the brackets as two permissions: 'remote:invoke:lan' and 'wan' instead of the\n * # single desired 'remote:invoke:lan,wan' token.  So, you can use quotes wherever you need to escape internal\n * # commas.)\n * <p/>\n * /account/** = <a href=\"#authcBasic\">authcBasic<\/a>\n * /remoting/** = <a href=\"#authcBasic\">authcBasic<\/a>, <a href=\"#roles\">roles<\/a>[b2bClient], <a href=\"#perms\">perms<\/a>[remote:invoke:\"lan,wan\"]\n * <p/>\n * &lt;/param-value&gt;&lt;/init-param&gt;\n * &lt;/filter&gt;\n * <p/>\n * <p/>\n * &lt;filter-mapping&gt;\n * &lt;filter-name&gt;JSecurityFilter&lt;/filter-name&gt;\n * &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n * &lt;/filter-mapping&gt;<\/pre>\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class JSecurityFilter extends OncePerRequestFilter {\n\n    //TODO - complete JavaDoc\n\n    public static final String SECURITY_MANAGER_CONTEXT_KEY = SecurityManager.class.getName() + \"_SERVLET_CONTEXT_KEY\";\n\n    public static final String CONFIG_CLASS_NAME_INIT_PARAM_NAME = \"configClassName\";\n    public static final String CONFIG_INIT_PARAM_NAME = \"config\";\n    public static final String CONFIG_URL_INIT_PARAM_NAME = \"configUrl\";\n\n    private static final Log log = LogFactory.getLog(JSecurityFilter.class);\n\n    protected String config;\n    protected String configUrl;\n    protected String configClassName;\n    protected WebConfiguration configuration;\n\n    // Reference to the security manager used by this filter\n    protected SecurityManager securityManager;\n\n    public JSecurityFilter() {\n        this.configClassName = IniWebConfiguration.class.getName();\n    }\n\n    public WebConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    public void setConfiguration(WebConfiguration configuration) {\n        this.configuration = configuration;\n    }\n\n    public SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected void setSecurityManager(SecurityManager sm) {\n        this.securityManager = sm;\n    }\n\n    protected void onFilterConfigSet() throws Exception {\n        applyInitParams();\n        WebConfiguration config = configure();\n        setConfiguration(config);\n\n        // Retrieve and store a reference to the security manager\n        SecurityManager sm = ensureSecurityManager(config);\n        setSecurityManager(sm);\n    }\n\n    /**\n     * Retrieves the security manager for the given configuration.\n     *\n     * @param config the configuration for this filter.\n     * @return the security manager that this filter should use.\n     */\n    protected SecurityManager ensureSecurityManager(Configuration config) {\n        SecurityManager sm = config.getSecurityManager();\n\n        // If the config doesn't return a security manager, build one by default.\n        if (sm == null) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Configuration instance [\" + config + \"] did not provide a SecurityManager.  No config \" +\n                    \"specified?  Defaulting to a \" + DefaultWebSecurityManager.class.getName() + \" instance...\");\n            }\n            sm = new DefaultWebSecurityManager();\n        }\n\n        return sm;\n    }\n\n    protected void applyInitParams() {\n        FilterConfig config = getFilterConfig();\n\n        String configCN = clean(config.getInitParameter(CONFIG_CLASS_NAME_INIT_PARAM_NAME));\n        if (configCN != null) {\n            if (ClassUtils.isAvailable(configCN)) {\n                this.configClassName = configCN;\n            } else {\n                String msg = \"configClassName fully qualified class name value [\" + configCN + \"] is not \" +\n                    \"available in the classpath.  Please ensure you have typed it correctly and the \" +\n                    \"corresponding class or jar is in the classpath.\";\n                throw new ConfigurationException(msg);\n            }\n        }\n\n        this.config = clean(config.getInitParameter(CONFIG_INIT_PARAM_NAME));\n        this.configUrl = clean(config.getInitParameter(CONFIG_URL_INIT_PARAM_NAME));\n    }\n\n    protected WebConfiguration configure() {\n        WebConfiguration conf = (WebConfiguration) ClassUtils.newInstance(this.configClassName);\n        applyFilterConfig(conf);\n        applyUrlConfig(conf);\n        applyEmbeddedConfig(conf);\n        LifecycleUtils.init(conf);\n        return conf;\n    }\n\n    protected void applyFilterConfig(WebConfiguration conf) {\n        if (log.isDebugEnabled()) {\n            String msg = \"Attempting to inject the FilterConfig (using 'setFilterConfig' method) into the \" +\n                \"instantiated WebConfiguration for any wrapped Filter initialization...\";\n            log.debug(msg);\n        }\n        try {\n            PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"filterConfig\");\n            if (pd != null) {\n                PropertyUtils.setProperty(conf, \"filterConfig\", getFilterConfig());\n            }\n        } catch (Exception e) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Error setting FilterConfig on WebConfiguration instance.\", e);\n            }\n        }\n    }\n\n    protected void applyEmbeddedConfig(WebConfiguration conf) {\n        if (this.config != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"config\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"config\", this.config);\n                } else {\n                    String msg = \"The 'config' filter param was specified, but there is no \" +\n                        \"'setConfig(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                        \"not require the 'config' filter param, please comment it out, or if you do need it, \" +\n                        \"please ensure your Configuration instance has a 'setConfig(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'config' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected void applyUrlConfig(WebConfiguration conf) {\n        if (this.configUrl != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"configUrl\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"configUrl\", this.configUrl);\n                } else {\n                    String msg = \"The 'configUrl' filter param was specified, but there is no \" +\n                        \"'setConfigUrl(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                        \"not require the 'configUrl' filter param, please comment it out, or if you do need it, \" +\n                        \"please ensure your Configuration instance has a 'setConfigUrl(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'configUrl' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected boolean isHttpSessions() {\n        SecurityManager secMgr = getSecurityManager();\n        if (secMgr instanceof DefaultWebSecurityManager) {\n            return ((DefaultWebSecurityManager) secMgr).isHttpSessionMode();\n        } else {\n            return true;\n        }\n    }\n\n    protected InetAddress getInetAddress(ServletRequest request) {\n        return WebUtils.getInetAddress(request);\n    }\n\n    /**\n     * Wraps the original HttpServletRequest in a {@link JSecurityHttpServletRequest}\n     * @since 1.0\n     */\n    protected ServletRequest wrapServletRequest(HttpServletRequest orig) {\n        return new JSecurityHttpServletRequest(orig, getServletContext(), isHttpSessions());\n    }\n\n    /** @since 1.0 */\n    protected ServletRequest prepareServletRequest(ServletRequest request, ServletResponse response,\n                                                   FilterChain chain) {\n        ServletRequest toUse = request;\n        if (request instanceof HttpServletRequest) {\n            HttpServletRequest http = (HttpServletRequest) request;\n            toUse = wrapServletRequest(http);\n        }\n        return toUse;\n    }\n\n    /** @since 1.0 */\n    protected ServletResponse wrapServletResponse(HttpServletResponse orig, JSecurityHttpServletRequest request) {\n        return new JSecurityHttpServletResponse(orig, getServletContext(), request);\n    }\n\n    /** @since 1.0 */\n    protected ServletResponse prepareServletResponse(ServletRequest request, ServletResponse response,\n                                                     FilterChain chain) {\n        ServletResponse toUse = response;\n        if (isHttpSessions() && (request instanceof JSecurityHttpServletRequest) &&\n            (response instanceof HttpServletResponse)) {\n            //the JSecurityHttpServletResponse exists to support URL rewriting for session ids.  This is only needed if\n            //using JSecurity sessions (i.e. not simple HttpSession based sessions):\n            toUse = wrapServletResponse((HttpServletResponse) response, (JSecurityHttpServletRequest) request);\n        }\n        return toUse;\n    }\n\n    /** @since 1.0 */\n    protected void bind(ServletRequest request, ServletResponse response) {\n        WebUtils.bindInetAddressToThread(request);\n        WebUtils.bind(request);\n        WebUtils.bind(response);\n        ThreadContext.bind(getSecurityManager());\n        ThreadContext.bind(getSecurityManager().getSubject());\n    }\n\n    /** @since 1.0 */\n    protected void unbind(ServletRequest request, ServletResponse response) {\n        //arguments ignored, just clear the thread:\n        ThreadContext.unbindSubject();\n        ThreadContext.unbindSecurityManager();\n        WebUtils.unbindServletResponse();\n        WebUtils.unbindServletRequest();\n        ThreadContext.unbindInetAddress();\n    }\n\n    protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse,\n                                    FilterChain origChain) throws ServletException, IOException {\n\n        ServletRequest request = prepareServletRequest(servletRequest, servletResponse, origChain);\n        ServletResponse response = prepareServletResponse(request, servletResponse, origChain);\n\n        bind(request, response);\n\n        FilterChain chain = getConfiguration().getChain(request, response, origChain);\n        if (chain == null) {\n            chain = origChain;\n            if (log.isTraceEnabled()) {\n                log.trace(\"No security filter chain configured for the current request.  Using default.\");\n            }\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\" Using configured filter chain for the current request.\");\n            }\n        }\n\n        try {\n            chain.doFilter(request, response);\n        } finally {\n            unbind(request, response);\n        }\n    }\n\n    public void destroy() {\n        LifecycleUtils.destroy(getConfiguration());\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.config.Configuration;\nimport org.jsecurity.config.ConfigurationException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.util.ClassUtils;\nimport org.jsecurity.util.LifecycleUtils;\nimport static org.jsecurity.util.StringUtils.clean;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.DefaultWebSecurityManager;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.config.IniWebConfiguration;\nimport org.jsecurity.web.config.WebConfiguration;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.beans.PropertyDescriptor;\nimport java.io.IOException;\nimport java.net.InetAddress;\n\n/**\n * Main ServletFilter that configures and enables all JSecurity functions within a web application.\n *\n * The following is a fully commented example that documents how to configure it:\n *\n * <pre>&lt;filter&gt;\n * &lt;filter-name&gt;JSecurityFilter&lt;/filter-name&gt;\n * &lt;filter-class&gt;org.jsecurity.web.servlet.JSecurityFilter&lt;/filter-class&gt;\n * &lt;init-param&gt;&lt;param-name&gt;config&lt;/param-name&gt;&lt;param-value&gt;\n *\n * #NOTE:  This config looks pretty long - but its not - its only 5 lines of actual config.\n * #       Everything else is just heavily commented to explain things in-depth. Feel free to delete any\n * #       comments that you don't want to read from your own configuration ;)\n * #\n * # Any commented values below are JSecurity's defaults.  If you want to change any values, you only\n * # need to uncomment the lines you want to change.\n *\n * [main]\n * # The 'main' section defines JSecurity-wide configuration.\n * #\n * # Session Mode: By default, JSecurity's Session infrastructure in a web environment will use the\n * # Servlet container's HttpSession.  However, if you need to share session state across client types\n * # (e.g. Web MVC plus Java Web Start or Flash), or are doing distributed/shared Sessions for\n * # Single Sign On, HttpSessions aren't good enough.  You'll need to use JSecurity's more powerful\n * # (and client-agnostic) session management.  You can enable this by uncommenting the following line\n * # and changing 'http' to 'jsecurity'\n * #\n * #securityManager = {@link org.jsecurity.web.DefaultWebSecurityManager org.jsecurity.web.DefaultWebSecurityManager}\n * #securityManager.{@link org.jsecurity.web.DefaultWebSecurityManager#setSessionMode(String) sessionMode} = http\n *\n * [filters]\n * # This section defines the 'pool' of all Filters available to the url path definitions in the [urls] section below.\n * #\n * # The following commented values are already provided by JSecurity by default and are immediately usable\n * # in the [urls] definitions below.  If you like, you may override any values by uncommenting only the lines\n * # you need to change.\n * #\n * # Each Filter is configured based on its functionality and/or protocol.  You should read each\n * # Filter's JavaDoc to fully understand what each does and how it works as well as how it would\n * # affect the user experience.\n * #\n * # Form-based Authentication filter:\n * #<a name=\"authc\"><\/a>authc = {@link org.jsecurity.web.filter.authc.FormAuthenticationFilter}\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setLoginUrl(String) loginUrl} = /login.jsp\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setUsernameParam(String) usernameParam} = username\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setPasswordParam(String) passwordParam} = password\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setRememberMeParam(String) rememberMeParam} = rememberMe\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setSuccessUrl(String) successUrl}  = /login.jsp\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setFailureKeyAttribute(String) failureKeyAttribute} = {@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#DEFAULT_ERROR_KEY_ATTRIBUTE_NAME}\n * #\n * # Http BASIC Authentication filter:\n * #<a name=\"authcBasic\"><\/a>authcBasic = {@link org.jsecurity.web.filter.authc.BasicHttpAuthenticationFilter}\n * #authcBasic.{@link org.jsecurity.web.filter.authc.BasicHttpAuthenticationFilter#setApplicationName(String) applicationName} = application\n * #\n * # Roles filter: requires the requesting user to have one or more roles for the request to continue.\n * # If they do not have the specified roles, they are redirected to the specified URL.\n * #<a name=\"roles\"><\/a>roles = {@link org.jsecurity.web.filter.authz.RolesAuthorizationFilter}\n * #roles.{@link org.jsecurity.web.filter.authz.RolesAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.\n * #\n * # Permissions filter: requires the requesting user to have one or more permissions for the request to\n * # continue, and if they do not, redirects them to the specified URL.\n * #<a name=\"perms\"><\/a>perms = {@link org.jsecurity.web.filter.authz.PermissionsAuthorizationFilter}\n * #perms.{@link org.jsecurity.web.filter.authz.PermissionsAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.  Many\n * # applications like to use the same url specified in roles.unauthorizedUrl above.\n * #\n * #\n * # Define your own filters here.  To properly handle url path matching (see the [urls] section below), your\n * # filter should extend the {@link org.jsecurity.web.filter.PathMatchingFilter PathMatchingFilter} abstract class.\n *\n * [urls]\n * # This section defines url path mappings.  Each mapping entry must be on a single line and conform to the\n * # following representation:\n * #\n * # ant_path_expression = path_specific_filter_chain_definition\n * #\n * # For any request that matches a specified path, the corresponding value defines a comma-delimited chain of\n * # filters to execute for that request.\n * #\n * # This is incredibly powerful in that you can define arbitrary filter chains for any given request pattern\n * # to greatly customize the security experience.\n * #\n * # The path_specific_filter_chain_definition must match the following format:\n * #\n * # filter1[optional_config1], filter2[optional_config2], ..., filterN[optional_configN]\n * #\n * # where 'filterN' is the name of an filter defined above in the [filters] section and\n * # '[optional_configN]' is an optional bracketed string that has meaning for that particular filter for\n * # _that particular path_.  If the filter does not need specific config for that url path, you may\n * # discard the brackets - that is, filterN[] just becomes filterN.\n * #\n * # And because filter tokens define chains, order matters!  Define the tokens for each path pattern\n * # in the order you want them to filter (comma-delimited).\n * #\n * # Finally, each filter is free to handle the response however it wants if its necessary\n * # conditions are not met (redirect, HTTP error code, direct rendering, etc).  Otherwise, it is expected to allow\n * # the request to continue through the chain on to the final destination view.\n * #\n * # Examples:\n * #\n * # To illustrate chain configuration, look at the /account/** mapping below.  This says\n * # &quot;apply the above 'authcBasic' filter to any request matching the '/account/**' pattern&quot;.  Since the\n * # 'authcBasic' filter does not need any path-specific config, it doesn't have any config brackets [].\n * #\n * # The /remoting/** definition on the other hand uses the 'roles' and 'perms' filters which do use\n * # bracket notation.  That definition says:\n * #\n * # &quot;To access /remoting/** urls, ensure that the user is first authenticated ('authcBasic'), then ensure that user\n * # has the 'b2bClient' role, and then finally ensure that they have the 'remote:invoke:lan,wan' permission.&quot;\n * #\n * # (Note that because elements within brackets [ ] are comma-delimited themselves, we needed to escape the permission\n * # actions of 'lan,wan' with quotes.  If we didn't do that, the permission filter would interpret\n * # the text between the brackets as two permissions: 'remote:invoke:lan' and 'wan' instead of the\n * # single desired 'remote:invoke:lan,wan' token.  So, you can use quotes wherever you need to escape internal\n * # commas.)\n *\n * /account/** = <a href=\"#authcBasic\">authcBasic<\/a>\n * /remoting/** = <a href=\"#authcBasic\">authcBasic<\/a>, <a href=\"#roles\">roles<\/a>[b2bClient], <a href=\"#perms\">perms<\/a>[remote:invoke:\"lan,wan\"]\n *\n * &lt;/param-value&gt;&lt;/init-param&gt;\n * &lt;/filter&gt;\n *\n *\n * &lt;filter-mapping&gt;\n * &lt;filter-name&gt;JSecurityFilter&lt;/filter-name&gt;\n * &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n * &lt;/filter-mapping&gt;<\/pre>\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class JSecurityFilter extends OncePerRequestFilter {\n\n    //TODO - complete JavaDoc\n\n    public static final String SECURITY_MANAGER_CONTEXT_KEY = SecurityManager.class.getName() + \"_SERVLET_CONTEXT_KEY\";\n\n    public static final String CONFIG_CLASS_NAME_INIT_PARAM_NAME = \"configClassName\";\n    public static final String CONFIG_INIT_PARAM_NAME = \"config\";\n    public static final String CONFIG_URL_INIT_PARAM_NAME = \"configUrl\";\n\n    private static final Log log = LogFactory.getLog(JSecurityFilter.class);    \n\n    protected String config;\n    protected String configUrl;\n    protected String configClassName;\n    protected WebConfiguration configuration;\n\n    // Reference to the security manager used by this filter\n    protected SecurityManager securityManager;\n\n    public JSecurityFilter() {\n        this.configClassName = IniWebConfiguration.class.getName();\n    }\n\n    public WebConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    public void setConfiguration(WebConfiguration configuration) {\n        this.configuration = configuration;\n    }\n\n    public SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected void setSecurityManager(SecurityManager sm) {\n        this.securityManager = sm;\n    }\n\n    protected void onFilterConfigSet() throws Exception {\n        applyInitParams();\n        WebConfiguration config = configure();\n        setConfiguration(config);\n\n        // Retrieve and store a reference to the security manager\n        SecurityManager sm = ensureSecurityManager(config);\n        setSecurityManager(sm);\n    }\n\n    /**\n     * Retrieves the security manager for the given configuration.\n     *\n     * @param config the configuration for this filter.\n     * @return the security manager that this filter should use.\n     */\n    protected SecurityManager ensureSecurityManager(Configuration config) {\n        SecurityManager sm = config.getSecurityManager();\n\n        // If the config doesn't return a security manager, build one by default.\n        if (sm == null) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Configuration instance [\" + config + \"] did not provide a SecurityManager.  No config \" +\n                        \"specified?  Defaulting to a \" + DefaultWebSecurityManager.class.getName() + \" instance...\");\n            }\n            sm = new DefaultWebSecurityManager();\n        }\n\n        return sm;\n    }\n\n    protected void applyInitParams() {\n        FilterConfig config = getFilterConfig();\n\n        String configCN = clean(config.getInitParameter(CONFIG_CLASS_NAME_INIT_PARAM_NAME));\n        if (configCN != null) {\n            if (ClassUtils.isAvailable(configCN)) {\n                this.configClassName = configCN;\n            } else {\n                String msg = \"configClassName fully qualified class name value [\" + configCN + \"] is not \" +\n                        \"available in the classpath.  Please ensure you have typed it correctly and the \" +\n                        \"corresponding class or jar is in the classpath.\";\n                throw new ConfigurationException(msg);\n            }\n        }\n\n        this.config = clean(config.getInitParameter(CONFIG_INIT_PARAM_NAME));\n        this.configUrl = clean(config.getInitParameter(CONFIG_URL_INIT_PARAM_NAME));\n    }\n\n    protected WebConfiguration configure() {\n        WebConfiguration conf = (WebConfiguration) ClassUtils.newInstance(this.configClassName);\n        applyFilterConfig(conf);\n        applyUrlConfig(conf);\n        applyEmbeddedConfig(conf);\n        LifecycleUtils.init(conf);\n        return conf;\n    }\n\n    protected void applyFilterConfig(WebConfiguration conf) {\n        if (log.isDebugEnabled()) {\n            String msg = \"Attempting to inject the FilterConfig (using 'setFilterConfig' method) into the \" +\n                    \"instantiated WebConfiguration for any wrapped Filter initialization...\";\n            log.debug(msg);\n        }\n        try {\n            PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"filterConfig\");\n            if (pd != null) {\n                PropertyUtils.setProperty(conf, \"filterConfig\", getFilterConfig());\n            }\n        } catch (Exception e) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Error setting FilterConfig on WebConfiguration instance.\", e);\n            }\n        }\n    }\n\n    protected void applyEmbeddedConfig(WebConfiguration conf) {\n        if (this.config != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"config\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"config\", this.config);\n                } else {\n                    String msg = \"The 'config' filter param was specified, but there is no \" +\n                            \"'setConfig(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                            \"not require the 'config' filter param, please comment it out, or if you do need it, \" +\n                            \"please ensure your Configuration instance has a 'setConfig(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'config' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected void applyUrlConfig(WebConfiguration conf) {\n        if (this.configUrl != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"configUrl\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"configUrl\", this.configUrl);\n                } else {\n                    String msg = \"The 'configUrl' filter param was specified, but there is no \" +\n                            \"'setConfigUrl(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                            \"not require the 'configUrl' filter param, please comment it out, or if you do need it, \" +\n                            \"please ensure your Configuration instance has a 'setConfigUrl(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'configUrl' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected boolean isHttpSessions() {\n        SecurityManager secMgr = getSecurityManager();\n        if (secMgr instanceof DefaultWebSecurityManager) {\n            return ((DefaultWebSecurityManager) secMgr).isHttpSessionMode();\n        } else {\n            return true;\n        }\n    }\n\n    protected InetAddress getInetAddress(ServletRequest request) {\n        return WebUtils.getInetAddress(request);\n    }\n\n    protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse,\n                                    FilterChain origChain) throws ServletException, IOException {\n\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        HttpServletResponse response = (HttpServletResponse) servletResponse;\n\n        ThreadContext.bind(getInetAddress(request));\n\n        boolean httpSessions = isHttpSessions();\n        request = new JSecurityHttpServletRequest(request, getServletContext(), httpSessions);\n        if (!httpSessions) {\n            //the JSecurityHttpServletResponse exists to support URL rewriting for session ids.  This is only needed if\n            //using JSecurity sessions (i.e. not simple HttpSession based sessions):\n            response = new JSecurityHttpServletResponse(response, getServletContext(), (JSecurityHttpServletRequest) request);\n        }\n\n        WebUtils.bind(request);\n        WebUtils.bind(response);\n        ThreadContext.bind(getSecurityManager());\n        ThreadContext.bind(getSecurityManager().getSubject());\n\n        FilterChain chain = getConfiguration().getChain(request, response, origChain);\n        if (chain == null) {\n            chain = origChain;\n            if (log.isTraceEnabled()) {\n                log.trace(\"No security filter chain configured for the current request.  Using default.\");\n            }\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\" Using configured filter chain for the current request.\");\n            }\n        }\n\n        try {\n            chain.doFilter(request, response);\n        } finally {\n            ThreadContext.unbindSubject();\n            ThreadContext.unbindSecurityManager();\n            WebUtils.unbindServletResponse();\n            WebUtils.unbindServletRequest();\n            ThreadContext.unbindInetAddress();\n        }\n    }\n\n    public void destroy() {\n        LifecycleUtils.destroy(getConfiguration());\n    }\n}\n","lineNo":409}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.config.Configuration;\nimport org.jsecurity.config.ConfigurationException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.util.ClassUtils;\nimport org.jsecurity.util.LifecycleUtils;\nimport static org.jsecurity.util.StringUtils.clean;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.DefaultWebSecurityManager;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.config.IniWebConfiguration;\nimport org.jsecurity.web.config.WebConfiguration;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.beans.PropertyDescriptor;\nimport java.io.IOException;\nimport java.net.InetAddress;\n\n/**\n * Main ServletFilter that configures and enables all JSecurity functions within a web application.\n * <p/>\n * The following is a fully commented example that documents how to configure it:\n * <p/>\n * <pre>&lt;filter&gt;\n * &lt;filter-name&gt;JSecurityFilter&lt;/filter-name&gt;\n * &lt;filter-class&gt;org.jsecurity.web.servlet.JSecurityFilter&lt;/filter-class&gt;\n * &lt;init-param&gt;&lt;param-name&gt;config&lt;/param-name&gt;&lt;param-value&gt;\n * <p/>\n * #NOTE:  This config looks pretty long - but its not - its only 5 lines of actual config.\n * #       Everything else is just heavily commented to explain things in-depth. Feel free to delete any\n * #       comments that you don't want to read from your own configuration ;)\n * #\n * # Any commented values below are JSecurity's defaults.  If you want to change any values, you only\n * # need to uncomment the lines you want to change.\n * <p/>\n * [main]\n * # The 'main' section defines JSecurity-wide configuration.\n * #\n * # Session Mode: By default, JSecurity's Session infrastructure in a web environment will use the\n * # Servlet container's HttpSession.  However, if you need to share session state across client types\n * # (e.g. Web MVC plus Java Web Start or Flash), or are doing distributed/shared Sessions for\n * # Single Sign On, HttpSessions aren't good enough.  You'll need to use JSecurity's more powerful\n * # (and client-agnostic) session management.  You can enable this by uncommenting the following line\n * # and changing 'http' to 'jsecurity'\n * #\n * #securityManager = {@link org.jsecurity.web.DefaultWebSecurityManager org.jsecurity.web.DefaultWebSecurityManager}\n * #securityManager.{@link org.jsecurity.web.DefaultWebSecurityManager#setSessionMode(String) sessionMode} = http\n * <p/>\n * [filters]\n * # This section defines the 'pool' of all Filters available to the url path definitions in the [urls] section below.\n * #\n * # The following commented values are already provided by JSecurity by default and are immediately usable\n * # in the [urls] definitions below.  If you like, you may override any values by uncommenting only the lines\n * # you need to change.\n * #\n * # Each Filter is configured based on its functionality and/or protocol.  You should read each\n * # Filter's JavaDoc to fully understand what each does and how it works as well as how it would\n * # affect the user experience.\n * #\n * # Form-based Authentication filter:\n * #<a name=\"authc\"><\/a>authc = {@link org.jsecurity.web.filter.authc.FormAuthenticationFilter}\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setLoginUrl(String) loginUrl} = /login.jsp\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setUsernameParam(String) usernameParam} = username\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setPasswordParam(String) passwordParam} = password\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setRememberMeParam(String) rememberMeParam} = rememberMe\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setSuccessUrl(String) successUrl}  = /login.jsp\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setFailureKeyAttribute(String) failureKeyAttribute} = {@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#DEFAULT_ERROR_KEY_ATTRIBUTE_NAME}\n * #\n * # Http BASIC Authentication filter:\n * #<a name=\"authcBasic\"><\/a>authcBasic = {@link org.jsecurity.web.filter.authc.BasicHttpAuthenticationFilter}\n * #authcBasic.{@link org.jsecurity.web.filter.authc.BasicHttpAuthenticationFilter#setApplicationName(String) applicationName} = application\n * #\n * # Roles filter: requires the requesting user to have one or more roles for the request to continue.\n * # If they do not have the specified roles, they are redirected to the specified URL.\n * #<a name=\"roles\"><\/a>roles = {@link org.jsecurity.web.filter.authz.RolesAuthorizationFilter}\n * #roles.{@link org.jsecurity.web.filter.authz.RolesAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.\n * #\n * # Permissions filter: requires the requesting user to have one or more permissions for the request to\n * # continue, and if they do not, redirects them to the specified URL.\n * #<a name=\"perms\"><\/a>perms = {@link org.jsecurity.web.filter.authz.PermissionsAuthorizationFilter}\n * #perms.{@link org.jsecurity.web.filter.authz.PermissionsAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.  Many\n * # applications like to use the same url specified in roles.unauthorizedUrl above.\n * #\n * #\n * # Define your own filters here.  To properly handle url path matching (see the [urls] section below), your\n * # filter should extend the {@link org.jsecurity.web.filter.PathMatchingFilter PathMatchingFilter} abstract class.\n * <p/>\n * [urls]\n * # This section defines url path mappings.  Each mapping entry must be on a single line and conform to the\n * # following representation:\n * #\n * # ant_path_expression = path_specific_filter_chain_definition\n * #\n * # For any request that matches a specified path, the corresponding value defines a comma-delimited chain of\n * # filters to execute for that request.\n * #\n * # This is incredibly powerful in that you can define arbitrary filter chains for any given request pattern\n * # to greatly customize the security experience.\n * #\n * # The path_specific_filter_chain_definition must match the following format:\n * #\n * # filter1[optional_config1], filter2[optional_config2], ..., filterN[optional_configN]\n * #\n * # where 'filterN' is the name of an filter defined above in the [filters] section and\n * # '[optional_configN]' is an optional bracketed string that has meaning for that particular filter for\n * # _that particular path_.  If the filter does not need specific config for that url path, you may\n * # discard the brackets - that is, filterN[] just becomes filterN.\n * #\n * # And because filter tokens define chains, order matters!  Define the tokens for each path pattern\n * # in the order you want them to filter (comma-delimited).\n * #\n * # Finally, each filter is free to handle the response however it wants if its necessary\n * # conditions are not met (redirect, HTTP error code, direct rendering, etc).  Otherwise, it is expected to allow\n * # the request to continue through the chain on to the final destination view.\n * #\n * # Examples:\n * #\n * # To illustrate chain configuration, look at the /account/** mapping below.  This says\n * # &quot;apply the above 'authcBasic' filter to any request matching the '/account/**' pattern&quot;.  Since the\n * # 'authcBasic' filter does not need any path-specific config, it doesn't have any config brackets [].\n * #\n * # The /remoting/** definition on the other hand uses the 'roles' and 'perms' filters which do use\n * # bracket notation.  That definition says:\n * #\n * # &quot;To access /remoting/** urls, ensure that the user is first authenticated ('authcBasic'), then ensure that user\n * # has the 'b2bClient' role, and then finally ensure that they have the 'remote:invoke:lan,wan' permission.&quot;\n * #\n * # (Note that because elements within brackets [ ] are comma-delimited themselves, we needed to escape the permission\n * # actions of 'lan,wan' with quotes.  If we didn't do that, the permission filter would interpret\n * # the text between the brackets as two permissions: 'remote:invoke:lan' and 'wan' instead of the\n * # single desired 'remote:invoke:lan,wan' token.  So, you can use quotes wherever you need to escape internal\n * # commas.)\n * <p/>\n * /account/** = <a href=\"#authcBasic\">authcBasic<\/a>\n * /remoting/** = <a href=\"#authcBasic\">authcBasic<\/a>, <a href=\"#roles\">roles<\/a>[b2bClient], <a href=\"#perms\">perms<\/a>[remote:invoke:\"lan,wan\"]\n * <p/>\n * &lt;/param-value&gt;&lt;/init-param&gt;\n * &lt;/filter&gt;\n * <p/>\n * <p/>\n * &lt;filter-mapping&gt;\n * &lt;filter-name&gt;JSecurityFilter&lt;/filter-name&gt;\n * &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n * &lt;/filter-mapping&gt;<\/pre>\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class JSecurityFilter extends OncePerRequestFilter {\n\n    //TODO - complete JavaDoc\n\n    public static final String SECURITY_MANAGER_CONTEXT_KEY = SecurityManager.class.getName() + \"_SERVLET_CONTEXT_KEY\";\n\n    public static final String CONFIG_CLASS_NAME_INIT_PARAM_NAME = \"configClassName\";\n    public static final String CONFIG_INIT_PARAM_NAME = \"config\";\n    public static final String CONFIG_URL_INIT_PARAM_NAME = \"configUrl\";\n\n    private static final Log log = LogFactory.getLog(JSecurityFilter.class);\n\n    protected String config;\n    protected String configUrl;\n    protected String configClassName;\n    protected WebConfiguration configuration;\n\n    // Reference to the security manager used by this filter\n    protected SecurityManager securityManager;\n\n    public JSecurityFilter() {\n        this.configClassName = IniWebConfiguration.class.getName();\n    }\n\n    public WebConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    public void setConfiguration(WebConfiguration configuration) {\n        this.configuration = configuration;\n    }\n\n    public SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected void setSecurityManager(SecurityManager sm) {\n        this.securityManager = sm;\n    }\n\n    protected void onFilterConfigSet() throws Exception {\n        applyInitParams();\n        WebConfiguration config = configure();\n        setConfiguration(config);\n\n        // Retrieve and store a reference to the security manager\n        SecurityManager sm = ensureSecurityManager(config);\n        setSecurityManager(sm);\n    }\n\n    /**\n     * Retrieves the security manager for the given configuration.\n     *\n     * @param config the configuration for this filter.\n     * @return the security manager that this filter should use.\n     */\n    protected SecurityManager ensureSecurityManager(Configuration config) {\n        SecurityManager sm = config.getSecurityManager();\n\n        // If the config doesn't return a security manager, build one by default.\n        if (sm == null) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Configuration instance [\" + config + \"] did not provide a SecurityManager.  No config \" +\n                    \"specified?  Defaulting to a \" + DefaultWebSecurityManager.class.getName() + \" instance...\");\n            }\n            sm = new DefaultWebSecurityManager();\n        }\n\n        return sm;\n    }\n\n    protected void applyInitParams() {\n        FilterConfig config = getFilterConfig();\n\n        String configCN = clean(config.getInitParameter(CONFIG_CLASS_NAME_INIT_PARAM_NAME));\n        if (configCN != null) {\n            if (ClassUtils.isAvailable(configCN)) {\n                this.configClassName = configCN;\n            } else {\n                String msg = \"configClassName fully qualified class name value [\" + configCN + \"] is not \" +\n                    \"available in the classpath.  Please ensure you have typed it correctly and the \" +\n                    \"corresponding class or jar is in the classpath.\";\n                throw new ConfigurationException(msg);\n            }\n        }\n\n        this.config = clean(config.getInitParameter(CONFIG_INIT_PARAM_NAME));\n        this.configUrl = clean(config.getInitParameter(CONFIG_URL_INIT_PARAM_NAME));\n    }\n\n    protected WebConfiguration configure() {\n        WebConfiguration conf = (WebConfiguration) ClassUtils.newInstance(this.configClassName);\n        applyFilterConfig(conf);\n        applyUrlConfig(conf);\n        applyEmbeddedConfig(conf);\n        LifecycleUtils.init(conf);\n        return conf;\n    }\n\n    protected void applyFilterConfig(WebConfiguration conf) {\n        if (log.isDebugEnabled()) {\n            String msg = \"Attempting to inject the FilterConfig (using 'setFilterConfig' method) into the \" +\n                \"instantiated WebConfiguration for any wrapped Filter initialization...\";\n            log.debug(msg);\n        }\n        try {\n            PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"filterConfig\");\n            if (pd != null) {\n                PropertyUtils.setProperty(conf, \"filterConfig\", getFilterConfig());\n            }\n        } catch (Exception e) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Error setting FilterConfig on WebConfiguration instance.\", e);\n            }\n        }\n    }\n\n    protected void applyEmbeddedConfig(WebConfiguration conf) {\n        if (this.config != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"config\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"config\", this.config);\n                } else {\n                    String msg = \"The 'config' filter param was specified, but there is no \" +\n                        \"'setConfig(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                        \"not require the 'config' filter param, please comment it out, or if you do need it, \" +\n                        \"please ensure your Configuration instance has a 'setConfig(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'config' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected void applyUrlConfig(WebConfiguration conf) {\n        if (this.configUrl != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"configUrl\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"configUrl\", this.configUrl);\n                } else {\n                    String msg = \"The 'configUrl' filter param was specified, but there is no \" +\n                        \"'setConfigUrl(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                        \"not require the 'configUrl' filter param, please comment it out, or if you do need it, \" +\n                        \"please ensure your Configuration instance has a 'setConfigUrl(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'configUrl' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected boolean isHttpSessions() {\n        SecurityManager secMgr = getSecurityManager();\n        if (secMgr instanceof DefaultWebSecurityManager) {\n            return ((DefaultWebSecurityManager) secMgr).isHttpSessionMode();\n        } else {\n            return true;\n        }\n    }\n\n    protected InetAddress getInetAddress(ServletRequest request) {\n        return WebUtils.getInetAddress(request);\n    }\n\n    /**\n     * Wraps the original HttpServletRequest in a {@link JSecurityHttpServletRequest}\n     * @since 1.0\n     */\n    protected ServletRequest wrapServletRequest(HttpServletRequest orig) {\n        return new JSecurityHttpServletRequest(orig, getServletContext(), isHttpSessions());\n    }\n\n    /** @since 1.0 */\n    protected ServletRequest prepareServletRequest(ServletRequest request, ServletResponse response,\n                                                   FilterChain chain) {\n        ServletRequest toUse = request;\n        if (request instanceof HttpServletRequest) {\n            HttpServletRequest http = (HttpServletRequest) request;\n            toUse = wrapServletRequest(http);\n        }\n        return toUse;\n    }\n\n    /** @since 1.0 */\n    protected ServletResponse wrapServletResponse(HttpServletResponse orig, JSecurityHttpServletRequest request) {\n        return new JSecurityHttpServletResponse(orig, getServletContext(), request);\n    }\n\n    /** @since 1.0 */\n    protected ServletResponse prepareServletResponse(ServletRequest request, ServletResponse response,\n                                                     FilterChain chain) {\n        ServletResponse toUse = response;\n        if (isHttpSessions() && (request instanceof JSecurityHttpServletRequest) &&\n            (response instanceof HttpServletResponse)) {\n            //the JSecurityHttpServletResponse exists to support URL rewriting for session ids.  This is only needed if\n            //using JSecurity sessions (i.e. not simple HttpSession based sessions):\n            toUse = wrapServletResponse((HttpServletResponse) response, (JSecurityHttpServletRequest) request);\n        }\n        return toUse;\n    }\n\n    /** @since 1.0 */\n    protected void bind(ServletRequest request, ServletResponse response) {\n        WebUtils.bindInetAddressToThread(request);\n        WebUtils.bind(request);\n        WebUtils.bind(response);\n        ThreadContext.bind(getSecurityManager());\n        ThreadContext.bind(getSecurityManager().getSubject());\n    }\n\n    /** @since 1.0 */\n    protected void unbind(ServletRequest request, ServletResponse response) {\n        //arguments ignored, just clear the thread:\n        ThreadContext.unbindSubject();\n        ThreadContext.unbindSecurityManager();\n        WebUtils.unbindServletResponse();\n        WebUtils.unbindServletRequest();\n        ThreadContext.unbindInetAddress();\n    }\n\n    protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse,\n                                    FilterChain origChain) throws ServletException, IOException {\n\n        ServletRequest request = prepareServletRequest(servletRequest, servletResponse, origChain);\n        ServletResponse response = prepareServletResponse(request, servletResponse, origChain);\n\n        bind(request, response);\n\n        FilterChain chain = getConfiguration().getChain(request, response, origChain);\n        if (chain == null) {\n            chain = origChain;\n            if (log.isTraceEnabled()) {\n                log.trace(\"No security filter chain configured for the current request.  Using default.\");\n            }\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\" Using configured filter chain for the current request.\");\n            }\n        }\n\n        try {\n            chain.doFilter(request, response);\n        } finally {\n            unbind(request, response);\n        }\n    }\n\n    public void destroy() {\n        LifecycleUtils.destroy(getConfiguration());\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.config.Configuration;\nimport org.jsecurity.config.ConfigurationException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.util.ClassUtils;\nimport org.jsecurity.util.LifecycleUtils;\nimport static org.jsecurity.util.StringUtils.clean;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.DefaultWebSecurityManager;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.config.IniWebConfiguration;\nimport org.jsecurity.web.config.WebConfiguration;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.beans.PropertyDescriptor;\nimport java.io.IOException;\nimport java.net.InetAddress;\n\n/**\n * Main ServletFilter that configures and enables all JSecurity functions within a web application.\n *\n * The following is a fully commented example that documents how to configure it:\n *\n * <pre>&lt;filter&gt;\n * &lt;filter-name&gt;JSecurityFilter&lt;/filter-name&gt;\n * &lt;filter-class&gt;org.jsecurity.web.servlet.JSecurityFilter&lt;/filter-class&gt;\n * &lt;init-param&gt;&lt;param-name&gt;config&lt;/param-name&gt;&lt;param-value&gt;\n *\n * #NOTE:  This config looks pretty long - but its not - its only 5 lines of actual config.\n * #       Everything else is just heavily commented to explain things in-depth. Feel free to delete any\n * #       comments that you don't want to read from your own configuration ;)\n * #\n * # Any commented values below are JSecurity's defaults.  If you want to change any values, you only\n * # need to uncomment the lines you want to change.\n *\n * [main]\n * # The 'main' section defines JSecurity-wide configuration.\n * #\n * # Session Mode: By default, JSecurity's Session infrastructure in a web environment will use the\n * # Servlet container's HttpSession.  However, if you need to share session state across client types\n * # (e.g. Web MVC plus Java Web Start or Flash), or are doing distributed/shared Sessions for\n * # Single Sign On, HttpSessions aren't good enough.  You'll need to use JSecurity's more powerful\n * # (and client-agnostic) session management.  You can enable this by uncommenting the following line\n * # and changing 'http' to 'jsecurity'\n * #\n * #securityManager = {@link org.jsecurity.web.DefaultWebSecurityManager org.jsecurity.web.DefaultWebSecurityManager}\n * #securityManager.{@link org.jsecurity.web.DefaultWebSecurityManager#setSessionMode(String) sessionMode} = http\n *\n * [filters]\n * # This section defines the 'pool' of all Filters available to the url path definitions in the [urls] section below.\n * #\n * # The following commented values are already provided by JSecurity by default and are immediately usable\n * # in the [urls] definitions below.  If you like, you may override any values by uncommenting only the lines\n * # you need to change.\n * #\n * # Each Filter is configured based on its functionality and/or protocol.  You should read each\n * # Filter's JavaDoc to fully understand what each does and how it works as well as how it would\n * # affect the user experience.\n * #\n * # Form-based Authentication filter:\n * #<a name=\"authc\"><\/a>authc = {@link org.jsecurity.web.filter.authc.FormAuthenticationFilter}\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setLoginUrl(String) loginUrl} = /login.jsp\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setUsernameParam(String) usernameParam} = username\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setPasswordParam(String) passwordParam} = password\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setRememberMeParam(String) rememberMeParam} = rememberMe\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setSuccessUrl(String) successUrl}  = /login.jsp\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setFailureKeyAttribute(String) failureKeyAttribute} = {@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#DEFAULT_ERROR_KEY_ATTRIBUTE_NAME}\n * #\n * # Http BASIC Authentication filter:\n * #<a name=\"authcBasic\"><\/a>authcBasic = {@link org.jsecurity.web.filter.authc.BasicHttpAuthenticationFilter}\n * #authcBasic.{@link org.jsecurity.web.filter.authc.BasicHttpAuthenticationFilter#setApplicationName(String) applicationName} = application\n * #\n * # Roles filter: requires the requesting user to have one or more roles for the request to continue.\n * # If they do not have the specified roles, they are redirected to the specified URL.\n * #<a name=\"roles\"><\/a>roles = {@link org.jsecurity.web.filter.authz.RolesAuthorizationFilter}\n * #roles.{@link org.jsecurity.web.filter.authz.RolesAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.\n * #\n * # Permissions filter: requires the requesting user to have one or more permissions for the request to\n * # continue, and if they do not, redirects them to the specified URL.\n * #<a name=\"perms\"><\/a>perms = {@link org.jsecurity.web.filter.authz.PermissionsAuthorizationFilter}\n * #perms.{@link org.jsecurity.web.filter.authz.PermissionsAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.  Many\n * # applications like to use the same url specified in roles.unauthorizedUrl above.\n * #\n * #\n * # Define your own filters here.  To properly handle url path matching (see the [urls] section below), your\n * # filter should extend the {@link org.jsecurity.web.filter.PathMatchingFilter PathMatchingFilter} abstract class.\n *\n * [urls]\n * # This section defines url path mappings.  Each mapping entry must be on a single line and conform to the\n * # following representation:\n * #\n * # ant_path_expression = path_specific_filter_chain_definition\n * #\n * # For any request that matches a specified path, the corresponding value defines a comma-delimited chain of\n * # filters to execute for that request.\n * #\n * # This is incredibly powerful in that you can define arbitrary filter chains for any given request pattern\n * # to greatly customize the security experience.\n * #\n * # The path_specific_filter_chain_definition must match the following format:\n * #\n * # filter1[optional_config1], filter2[optional_config2], ..., filterN[optional_configN]\n * #\n * # where 'filterN' is the name of an filter defined above in the [filters] section and\n * # '[optional_configN]' is an optional bracketed string that has meaning for that particular filter for\n * # _that particular path_.  If the filter does not need specific config for that url path, you may\n * # discard the brackets - that is, filterN[] just becomes filterN.\n * #\n * # And because filter tokens define chains, order matters!  Define the tokens for each path pattern\n * # in the order you want them to filter (comma-delimited).\n * #\n * # Finally, each filter is free to handle the response however it wants if its necessary\n * # conditions are not met (redirect, HTTP error code, direct rendering, etc).  Otherwise, it is expected to allow\n * # the request to continue through the chain on to the final destination view.\n * #\n * # Examples:\n * #\n * # To illustrate chain configuration, look at the /account/** mapping below.  This says\n * # &quot;apply the above 'authcBasic' filter to any request matching the '/account/**' pattern&quot;.  Since the\n * # 'authcBasic' filter does not need any path-specific config, it doesn't have any config brackets [].\n * #\n * # The /remoting/** definition on the other hand uses the 'roles' and 'perms' filters which do use\n * # bracket notation.  That definition says:\n * #\n * # &quot;To access /remoting/** urls, ensure that the user is first authenticated ('authcBasic'), then ensure that user\n * # has the 'b2bClient' role, and then finally ensure that they have the 'remote:invoke:lan,wan' permission.&quot;\n * #\n * # (Note that because elements within brackets [ ] are comma-delimited themselves, we needed to escape the permission\n * # actions of 'lan,wan' with quotes.  If we didn't do that, the permission filter would interpret\n * # the text between the brackets as two permissions: 'remote:invoke:lan' and 'wan' instead of the\n * # single desired 'remote:invoke:lan,wan' token.  So, you can use quotes wherever you need to escape internal\n * # commas.)\n *\n * /account/** = <a href=\"#authcBasic\">authcBasic<\/a>\n * /remoting/** = <a href=\"#authcBasic\">authcBasic<\/a>, <a href=\"#roles\">roles<\/a>[b2bClient], <a href=\"#perms\">perms<\/a>[remote:invoke:\"lan,wan\"]\n *\n * &lt;/param-value&gt;&lt;/init-param&gt;\n * &lt;/filter&gt;\n *\n *\n * &lt;filter-mapping&gt;\n * &lt;filter-name&gt;JSecurityFilter&lt;/filter-name&gt;\n * &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n * &lt;/filter-mapping&gt;<\/pre>\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class JSecurityFilter extends OncePerRequestFilter {\n\n    //TODO - complete JavaDoc\n\n    public static final String SECURITY_MANAGER_CONTEXT_KEY = SecurityManager.class.getName() + \"_SERVLET_CONTEXT_KEY\";\n\n    public static final String CONFIG_CLASS_NAME_INIT_PARAM_NAME = \"configClassName\";\n    public static final String CONFIG_INIT_PARAM_NAME = \"config\";\n    public static final String CONFIG_URL_INIT_PARAM_NAME = \"configUrl\";\n\n    private static final Log log = LogFactory.getLog(JSecurityFilter.class);    \n\n    protected String config;\n    protected String configUrl;\n    protected String configClassName;\n    protected WebConfiguration configuration;\n\n    // Reference to the security manager used by this filter\n    protected SecurityManager securityManager;\n\n    public JSecurityFilter() {\n        this.configClassName = IniWebConfiguration.class.getName();\n    }\n\n    public WebConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    public void setConfiguration(WebConfiguration configuration) {\n        this.configuration = configuration;\n    }\n\n    public SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected void setSecurityManager(SecurityManager sm) {\n        this.securityManager = sm;\n    }\n\n    protected void onFilterConfigSet() throws Exception {\n        applyInitParams();\n        WebConfiguration config = configure();\n        setConfiguration(config);\n\n        // Retrieve and store a reference to the security manager\n        SecurityManager sm = ensureSecurityManager(config);\n        setSecurityManager(sm);\n    }\n\n    /**\n     * Retrieves the security manager for the given configuration.\n     *\n     * @param config the configuration for this filter.\n     * @return the security manager that this filter should use.\n     */\n    protected SecurityManager ensureSecurityManager(Configuration config) {\n        SecurityManager sm = config.getSecurityManager();\n\n        // If the config doesn't return a security manager, build one by default.\n        if (sm == null) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Configuration instance [\" + config + \"] did not provide a SecurityManager.  No config \" +\n                        \"specified?  Defaulting to a \" + DefaultWebSecurityManager.class.getName() + \" instance...\");\n            }\n            sm = new DefaultWebSecurityManager();\n        }\n\n        return sm;\n    }\n\n    protected void applyInitParams() {\n        FilterConfig config = getFilterConfig();\n\n        String configCN = clean(config.getInitParameter(CONFIG_CLASS_NAME_INIT_PARAM_NAME));\n        if (configCN != null) {\n            if (ClassUtils.isAvailable(configCN)) {\n                this.configClassName = configCN;\n            } else {\n                String msg = \"configClassName fully qualified class name value [\" + configCN + \"] is not \" +\n                        \"available in the classpath.  Please ensure you have typed it correctly and the \" +\n                        \"corresponding class or jar is in the classpath.\";\n                throw new ConfigurationException(msg);\n            }\n        }\n\n        this.config = clean(config.getInitParameter(CONFIG_INIT_PARAM_NAME));\n        this.configUrl = clean(config.getInitParameter(CONFIG_URL_INIT_PARAM_NAME));\n    }\n\n    protected WebConfiguration configure() {\n        WebConfiguration conf = (WebConfiguration) ClassUtils.newInstance(this.configClassName);\n        applyFilterConfig(conf);\n        applyUrlConfig(conf);\n        applyEmbeddedConfig(conf);\n        LifecycleUtils.init(conf);\n        return conf;\n    }\n\n    protected void applyFilterConfig(WebConfiguration conf) {\n        if (log.isDebugEnabled()) {\n            String msg = \"Attempting to inject the FilterConfig (using 'setFilterConfig' method) into the \" +\n                    \"instantiated WebConfiguration for any wrapped Filter initialization...\";\n            log.debug(msg);\n        }\n        try {\n            PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"filterConfig\");\n            if (pd != null) {\n                PropertyUtils.setProperty(conf, \"filterConfig\", getFilterConfig());\n            }\n        } catch (Exception e) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Error setting FilterConfig on WebConfiguration instance.\", e);\n            }\n        }\n    }\n\n    protected void applyEmbeddedConfig(WebConfiguration conf) {\n        if (this.config != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"config\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"config\", this.config);\n                } else {\n                    String msg = \"The 'config' filter param was specified, but there is no \" +\n                            \"'setConfig(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                            \"not require the 'config' filter param, please comment it out, or if you do need it, \" +\n                            \"please ensure your Configuration instance has a 'setConfig(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'config' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected void applyUrlConfig(WebConfiguration conf) {\n        if (this.configUrl != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"configUrl\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"configUrl\", this.configUrl);\n                } else {\n                    String msg = \"The 'configUrl' filter param was specified, but there is no \" +\n                            \"'setConfigUrl(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                            \"not require the 'configUrl' filter param, please comment it out, or if you do need it, \" +\n                            \"please ensure your Configuration instance has a 'setConfigUrl(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'configUrl' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected boolean isHttpSessions() {\n        SecurityManager secMgr = getSecurityManager();\n        if (secMgr instanceof DefaultWebSecurityManager) {\n            return ((DefaultWebSecurityManager) secMgr).isHttpSessionMode();\n        } else {\n            return true;\n        }\n    }\n\n    protected InetAddress getInetAddress(ServletRequest request) {\n        return WebUtils.getInetAddress(request);\n    }\n\n    protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse,\n                                    FilterChain origChain) throws ServletException, IOException {\n\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        HttpServletResponse response = (HttpServletResponse) servletResponse;\n\n        ThreadContext.bind(getInetAddress(request));\n\n        boolean httpSessions = isHttpSessions();\n        request = new JSecurityHttpServletRequest(request, getServletContext(), httpSessions);\n        if (!httpSessions) {\n            //the JSecurityHttpServletResponse exists to support URL rewriting for session ids.  This is only needed if\n            //using JSecurity sessions (i.e. not simple HttpSession based sessions):\n            response = new JSecurityHttpServletResponse(response, getServletContext(), (JSecurityHttpServletRequest) request);\n        }\n\n        WebUtils.bind(request);\n        WebUtils.bind(response);\n        ThreadContext.bind(getSecurityManager());\n        ThreadContext.bind(getSecurityManager().getSubject());\n\n        FilterChain chain = getConfiguration().getChain(request, response, origChain);\n        if (chain == null) {\n            chain = origChain;\n            if (log.isTraceEnabled()) {\n                log.trace(\"No security filter chain configured for the current request.  Using default.\");\n            }\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\" Using configured filter chain for the current request.\");\n            }\n        }\n\n        try {\n            chain.doFilter(request, response);\n        } finally {\n            ThreadContext.unbindSubject();\n            ThreadContext.unbindSecurityManager();\n            WebUtils.unbindServletResponse();\n            WebUtils.unbindServletRequest();\n            ThreadContext.unbindInetAddress();\n        }\n    }\n\n    public void destroy() {\n        LifecycleUtils.destroy(getConfiguration());\n    }\n}\n","lineNo":409}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.config.Configuration;\nimport org.jsecurity.config.ConfigurationException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.util.ClassUtils;\nimport org.jsecurity.util.LifecycleUtils;\nimport static org.jsecurity.util.StringUtils.clean;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.DefaultWebSecurityManager;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.config.IniWebConfiguration;\nimport org.jsecurity.web.config.WebConfiguration;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.beans.PropertyDescriptor;\nimport java.io.IOException;\nimport java.net.InetAddress;\n\n/**\n * Main ServletFilter that configures and enables all JSecurity functions within a web application.\n * <p/>\n * The following is a fully commented example that documents how to configure it:\n * <p/>\n * <pre>&lt;filter&gt;\n * &lt;filter-name&gt;JSecurityFilter&lt;/filter-name&gt;\n * &lt;filter-class&gt;org.jsecurity.web.servlet.JSecurityFilter&lt;/filter-class&gt;\n * &lt;init-param&gt;&lt;param-name&gt;config&lt;/param-name&gt;&lt;param-value&gt;\n * <p/>\n * #NOTE:  This config looks pretty long - but its not - its only 5 lines of actual config.\n * #       Everything else is just heavily commented to explain things in-depth. Feel free to delete any\n * #       comments that you don't want to read from your own configuration ;)\n * #\n * # Any commented values below are JSecurity's defaults.  If you want to change any values, you only\n * # need to uncomment the lines you want to change.\n * <p/>\n * [main]\n * # The 'main' section defines JSecurity-wide configuration.\n * #\n * # Session Mode: By default, JSecurity's Session infrastructure in a web environment will use the\n * # Servlet container's HttpSession.  However, if you need to share session state across client types\n * # (e.g. Web MVC plus Java Web Start or Flash), or are doing distributed/shared Sessions for\n * # Single Sign On, HttpSessions aren't good enough.  You'll need to use JSecurity's more powerful\n * # (and client-agnostic) session management.  You can enable this by uncommenting the following line\n * # and changing 'http' to 'jsecurity'\n * #\n * #securityManager = {@link org.jsecurity.web.DefaultWebSecurityManager org.jsecurity.web.DefaultWebSecurityManager}\n * #securityManager.{@link org.jsecurity.web.DefaultWebSecurityManager#setSessionMode(String) sessionMode} = http\n * <p/>\n * [filters]\n * # This section defines the 'pool' of all Filters available to the url path definitions in the [urls] section below.\n * #\n * # The following commented values are already provided by JSecurity by default and are immediately usable\n * # in the [urls] definitions below.  If you like, you may override any values by uncommenting only the lines\n * # you need to change.\n * #\n * # Each Filter is configured based on its functionality and/or protocol.  You should read each\n * # Filter's JavaDoc to fully understand what each does and how it works as well as how it would\n * # affect the user experience.\n * #\n * # Form-based Authentication filter:\n * #<a name=\"authc\"><\/a>authc = {@link org.jsecurity.web.filter.authc.FormAuthenticationFilter}\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setLoginUrl(String) loginUrl} = /login.jsp\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setUsernameParam(String) usernameParam} = username\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setPasswordParam(String) passwordParam} = password\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setRememberMeParam(String) rememberMeParam} = rememberMe\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setSuccessUrl(String) successUrl}  = /login.jsp\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setFailureKeyAttribute(String) failureKeyAttribute} = {@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#DEFAULT_ERROR_KEY_ATTRIBUTE_NAME}\n * #\n * # Http BASIC Authentication filter:\n * #<a name=\"authcBasic\"><\/a>authcBasic = {@link org.jsecurity.web.filter.authc.BasicHttpAuthenticationFilter}\n * #authcBasic.{@link org.jsecurity.web.filter.authc.BasicHttpAuthenticationFilter#setApplicationName(String) applicationName} = application\n * #\n * # Roles filter: requires the requesting user to have one or more roles for the request to continue.\n * # If they do not have the specified roles, they are redirected to the specified URL.\n * #<a name=\"roles\"><\/a>roles = {@link org.jsecurity.web.filter.authz.RolesAuthorizationFilter}\n * #roles.{@link org.jsecurity.web.filter.authz.RolesAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.\n * #\n * # Permissions filter: requires the requesting user to have one or more permissions for the request to\n * # continue, and if they do not, redirects them to the specified URL.\n * #<a name=\"perms\"><\/a>perms = {@link org.jsecurity.web.filter.authz.PermissionsAuthorizationFilter}\n * #perms.{@link org.jsecurity.web.filter.authz.PermissionsAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.  Many\n * # applications like to use the same url specified in roles.unauthorizedUrl above.\n * #\n * #\n * # Define your own filters here.  To properly handle url path matching (see the [urls] section below), your\n * # filter should extend the {@link org.jsecurity.web.filter.PathMatchingFilter PathMatchingFilter} abstract class.\n * <p/>\n * [urls]\n * # This section defines url path mappings.  Each mapping entry must be on a single line and conform to the\n * # following representation:\n * #\n * # ant_path_expression = path_specific_filter_chain_definition\n * #\n * # For any request that matches a specified path, the corresponding value defines a comma-delimited chain of\n * # filters to execute for that request.\n * #\n * # This is incredibly powerful in that you can define arbitrary filter chains for any given request pattern\n * # to greatly customize the security experience.\n * #\n * # The path_specific_filter_chain_definition must match the following format:\n * #\n * # filter1[optional_config1], filter2[optional_config2], ..., filterN[optional_configN]\n * #\n * # where 'filterN' is the name of an filter defined above in the [filters] section and\n * # '[optional_configN]' is an optional bracketed string that has meaning for that particular filter for\n * # _that particular path_.  If the filter does not need specific config for that url path, you may\n * # discard the brackets - that is, filterN[] just becomes filterN.\n * #\n * # And because filter tokens define chains, order matters!  Define the tokens for each path pattern\n * # in the order you want them to filter (comma-delimited).\n * #\n * # Finally, each filter is free to handle the response however it wants if its necessary\n * # conditions are not met (redirect, HTTP error code, direct rendering, etc).  Otherwise, it is expected to allow\n * # the request to continue through the chain on to the final destination view.\n * #\n * # Examples:\n * #\n * # To illustrate chain configuration, look at the /account/** mapping below.  This says\n * # &quot;apply the above 'authcBasic' filter to any request matching the '/account/**' pattern&quot;.  Since the\n * # 'authcBasic' filter does not need any path-specific config, it doesn't have any config brackets [].\n * #\n * # The /remoting/** definition on the other hand uses the 'roles' and 'perms' filters which do use\n * # bracket notation.  That definition says:\n * #\n * # &quot;To access /remoting/** urls, ensure that the user is first authenticated ('authcBasic'), then ensure that user\n * # has the 'b2bClient' role, and then finally ensure that they have the 'remote:invoke:lan,wan' permission.&quot;\n * #\n * # (Note that because elements within brackets [ ] are comma-delimited themselves, we needed to escape the permission\n * # actions of 'lan,wan' with quotes.  If we didn't do that, the permission filter would interpret\n * # the text between the brackets as two permissions: 'remote:invoke:lan' and 'wan' instead of the\n * # single desired 'remote:invoke:lan,wan' token.  So, you can use quotes wherever you need to escape internal\n * # commas.)\n * <p/>\n * /account/** = <a href=\"#authcBasic\">authcBasic<\/a>\n * /remoting/** = <a href=\"#authcBasic\">authcBasic<\/a>, <a href=\"#roles\">roles<\/a>[b2bClient], <a href=\"#perms\">perms<\/a>[remote:invoke:\"lan,wan\"]\n * <p/>\n * &lt;/param-value&gt;&lt;/init-param&gt;\n * &lt;/filter&gt;\n * <p/>\n * <p/>\n * &lt;filter-mapping&gt;\n * &lt;filter-name&gt;JSecurityFilter&lt;/filter-name&gt;\n * &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n * &lt;/filter-mapping&gt;<\/pre>\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class JSecurityFilter extends OncePerRequestFilter {\n\n    //TODO - complete JavaDoc\n\n    public static final String SECURITY_MANAGER_CONTEXT_KEY = SecurityManager.class.getName() + \"_SERVLET_CONTEXT_KEY\";\n\n    public static final String CONFIG_CLASS_NAME_INIT_PARAM_NAME = \"configClassName\";\n    public static final String CONFIG_INIT_PARAM_NAME = \"config\";\n    public static final String CONFIG_URL_INIT_PARAM_NAME = \"configUrl\";\n\n    private static final Log log = LogFactory.getLog(JSecurityFilter.class);\n\n    protected String config;\n    protected String configUrl;\n    protected String configClassName;\n    protected WebConfiguration configuration;\n\n    // Reference to the security manager used by this filter\n    protected SecurityManager securityManager;\n\n    public JSecurityFilter() {\n        this.configClassName = IniWebConfiguration.class.getName();\n    }\n\n    public WebConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    public void setConfiguration(WebConfiguration configuration) {\n        this.configuration = configuration;\n    }\n\n    public SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected void setSecurityManager(SecurityManager sm) {\n        this.securityManager = sm;\n    }\n\n    protected void onFilterConfigSet() throws Exception {\n        applyInitParams();\n        WebConfiguration config = configure();\n        setConfiguration(config);\n\n        // Retrieve and store a reference to the security manager\n        SecurityManager sm = ensureSecurityManager(config);\n        setSecurityManager(sm);\n    }\n\n    /**\n     * Retrieves the security manager for the given configuration.\n     *\n     * @param config the configuration for this filter.\n     * @return the security manager that this filter should use.\n     */\n    protected SecurityManager ensureSecurityManager(Configuration config) {\n        SecurityManager sm = config.getSecurityManager();\n\n        // If the config doesn't return a security manager, build one by default.\n        if (sm == null) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Configuration instance [\" + config + \"] did not provide a SecurityManager.  No config \" +\n                    \"specified?  Defaulting to a \" + DefaultWebSecurityManager.class.getName() + \" instance...\");\n            }\n            sm = new DefaultWebSecurityManager();\n        }\n\n        return sm;\n    }\n\n    protected void applyInitParams() {\n        FilterConfig config = getFilterConfig();\n\n        String configCN = clean(config.getInitParameter(CONFIG_CLASS_NAME_INIT_PARAM_NAME));\n        if (configCN != null) {\n            if (ClassUtils.isAvailable(configCN)) {\n                this.configClassName = configCN;\n            } else {\n                String msg = \"configClassName fully qualified class name value [\" + configCN + \"] is not \" +\n                    \"available in the classpath.  Please ensure you have typed it correctly and the \" +\n                    \"corresponding class or jar is in the classpath.\";\n                throw new ConfigurationException(msg);\n            }\n        }\n\n        this.config = clean(config.getInitParameter(CONFIG_INIT_PARAM_NAME));\n        this.configUrl = clean(config.getInitParameter(CONFIG_URL_INIT_PARAM_NAME));\n    }\n\n    protected WebConfiguration configure() {\n        WebConfiguration conf = (WebConfiguration) ClassUtils.newInstance(this.configClassName);\n        applyFilterConfig(conf);\n        applyUrlConfig(conf);\n        applyEmbeddedConfig(conf);\n        LifecycleUtils.init(conf);\n        return conf;\n    }\n\n    protected void applyFilterConfig(WebConfiguration conf) {\n        if (log.isDebugEnabled()) {\n            String msg = \"Attempting to inject the FilterConfig (using 'setFilterConfig' method) into the \" +\n                \"instantiated WebConfiguration for any wrapped Filter initialization...\";\n            log.debug(msg);\n        }\n        try {\n            PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"filterConfig\");\n            if (pd != null) {\n                PropertyUtils.setProperty(conf, \"filterConfig\", getFilterConfig());\n            }\n        } catch (Exception e) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Error setting FilterConfig on WebConfiguration instance.\", e);\n            }\n        }\n    }\n\n    protected void applyEmbeddedConfig(WebConfiguration conf) {\n        if (this.config != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"config\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"config\", this.config);\n                } else {\n                    String msg = \"The 'config' filter param was specified, but there is no \" +\n                        \"'setConfig(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                        \"not require the 'config' filter param, please comment it out, or if you do need it, \" +\n                        \"please ensure your Configuration instance has a 'setConfig(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'config' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected void applyUrlConfig(WebConfiguration conf) {\n        if (this.configUrl != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"configUrl\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"configUrl\", this.configUrl);\n                } else {\n                    String msg = \"The 'configUrl' filter param was specified, but there is no \" +\n                        \"'setConfigUrl(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                        \"not require the 'configUrl' filter param, please comment it out, or if you do need it, \" +\n                        \"please ensure your Configuration instance has a 'setConfigUrl(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'configUrl' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected boolean isHttpSessions() {\n        SecurityManager secMgr = getSecurityManager();\n        if (secMgr instanceof DefaultWebSecurityManager) {\n            return ((DefaultWebSecurityManager) secMgr).isHttpSessionMode();\n        } else {\n            return true;\n        }\n    }\n\n    protected InetAddress getInetAddress(ServletRequest request) {\n        return WebUtils.getInetAddress(request);\n    }\n\n    /**\n     * Wraps the original HttpServletRequest in a {@link JSecurityHttpServletRequest}\n     * @since 1.0\n     */\n    protected ServletRequest wrapServletRequest(HttpServletRequest orig) {\n        return new JSecurityHttpServletRequest(orig, getServletContext(), isHttpSessions());\n    }\n\n    /** @since 1.0 */\n    protected ServletRequest prepareServletRequest(ServletRequest request, ServletResponse response,\n                                                   FilterChain chain) {\n        ServletRequest toUse = request;\n        if (request instanceof HttpServletRequest) {\n            HttpServletRequest http = (HttpServletRequest) request;\n            toUse = wrapServletRequest(http);\n        }\n        return toUse;\n    }\n\n    /** @since 1.0 */\n    protected ServletResponse wrapServletResponse(HttpServletResponse orig, JSecurityHttpServletRequest request) {\n        return new JSecurityHttpServletResponse(orig, getServletContext(), request);\n    }\n\n    /** @since 1.0 */\n    protected ServletResponse prepareServletResponse(ServletRequest request, ServletResponse response,\n                                                     FilterChain chain) {\n        ServletResponse toUse = response;\n        if (isHttpSessions() && (request instanceof JSecurityHttpServletRequest) &&\n            (response instanceof HttpServletResponse)) {\n            //the JSecurityHttpServletResponse exists to support URL rewriting for session ids.  This is only needed if\n            //using JSecurity sessions (i.e. not simple HttpSession based sessions):\n            toUse = wrapServletResponse((HttpServletResponse) response, (JSecurityHttpServletRequest) request);\n        }\n        return toUse;\n    }\n\n    /** @since 1.0 */\n    protected void bind(ServletRequest request, ServletResponse response) {\n        WebUtils.bindInetAddressToThread(request);\n        WebUtils.bind(request);\n        WebUtils.bind(response);\n        ThreadContext.bind(getSecurityManager());\n        ThreadContext.bind(getSecurityManager().getSubject());\n    }\n\n    /** @since 1.0 */\n    protected void unbind(ServletRequest request, ServletResponse response) {\n        //arguments ignored, just clear the thread:\n        ThreadContext.unbindSubject();\n        ThreadContext.unbindSecurityManager();\n        WebUtils.unbindServletResponse();\n        WebUtils.unbindServletRequest();\n        ThreadContext.unbindInetAddress();\n    }\n\n    protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse,\n                                    FilterChain origChain) throws ServletException, IOException {\n\n        ServletRequest request = prepareServletRequest(servletRequest, servletResponse, origChain);\n        ServletResponse response = prepareServletResponse(request, servletResponse, origChain);\n\n        bind(request, response);\n\n        FilterChain chain = getConfiguration().getChain(request, response, origChain);\n        if (chain == null) {\n            chain = origChain;\n            if (log.isTraceEnabled()) {\n                log.trace(\"No security filter chain configured for the current request.  Using default.\");\n            }\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\" Using configured filter chain for the current request.\");\n            }\n        }\n\n        try {\n            chain.doFilter(request, response);\n        } finally {\n            unbind(request, response);\n        }\n    }\n\n    public void destroy() {\n        LifecycleUtils.destroy(getConfiguration());\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.config.Configuration;\nimport org.jsecurity.config.ConfigurationException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.util.ClassUtils;\nimport org.jsecurity.util.LifecycleUtils;\nimport static org.jsecurity.util.StringUtils.clean;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.DefaultWebSecurityManager;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.config.IniWebConfiguration;\nimport org.jsecurity.web.config.WebConfiguration;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.beans.PropertyDescriptor;\nimport java.io.IOException;\nimport java.net.InetAddress;\n\n/**\n * Main ServletFilter that configures and enables all JSecurity functions within a web application.\n *\n * The following is a fully commented example that documents how to configure it:\n *\n * <pre>&lt;filter&gt;\n * &lt;filter-name&gt;JSecurityFilter&lt;/filter-name&gt;\n * &lt;filter-class&gt;org.jsecurity.web.servlet.JSecurityFilter&lt;/filter-class&gt;\n * &lt;init-param&gt;&lt;param-name&gt;config&lt;/param-name&gt;&lt;param-value&gt;\n *\n * #NOTE:  This config looks pretty long - but its not - its only 5 lines of actual config.\n * #       Everything else is just heavily commented to explain things in-depth. Feel free to delete any\n * #       comments that you don't want to read from your own configuration ;)\n * #\n * # Any commented values below are JSecurity's defaults.  If you want to change any values, you only\n * # need to uncomment the lines you want to change.\n *\n * [main]\n * # The 'main' section defines JSecurity-wide configuration.\n * #\n * # Session Mode: By default, JSecurity's Session infrastructure in a web environment will use the\n * # Servlet container's HttpSession.  However, if you need to share session state across client types\n * # (e.g. Web MVC plus Java Web Start or Flash), or are doing distributed/shared Sessions for\n * # Single Sign On, HttpSessions aren't good enough.  You'll need to use JSecurity's more powerful\n * # (and client-agnostic) session management.  You can enable this by uncommenting the following line\n * # and changing 'http' to 'jsecurity'\n * #\n * #securityManager = {@link org.jsecurity.web.DefaultWebSecurityManager org.jsecurity.web.DefaultWebSecurityManager}\n * #securityManager.{@link org.jsecurity.web.DefaultWebSecurityManager#setSessionMode(String) sessionMode} = http\n *\n * [filters]\n * # This section defines the 'pool' of all Filters available to the url path definitions in the [urls] section below.\n * #\n * # The following commented values are already provided by JSecurity by default and are immediately usable\n * # in the [urls] definitions below.  If you like, you may override any values by uncommenting only the lines\n * # you need to change.\n * #\n * # Each Filter is configured based on its functionality and/or protocol.  You should read each\n * # Filter's JavaDoc to fully understand what each does and how it works as well as how it would\n * # affect the user experience.\n * #\n * # Form-based Authentication filter:\n * #<a name=\"authc\"><\/a>authc = {@link org.jsecurity.web.filter.authc.FormAuthenticationFilter}\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setLoginUrl(String) loginUrl} = /login.jsp\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setUsernameParam(String) usernameParam} = username\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setPasswordParam(String) passwordParam} = password\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setRememberMeParam(String) rememberMeParam} = rememberMe\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setSuccessUrl(String) successUrl}  = /login.jsp\n * #authc.{@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#setFailureKeyAttribute(String) failureKeyAttribute} = {@link org.jsecurity.web.filter.authc.FormAuthenticationFilter#DEFAULT_ERROR_KEY_ATTRIBUTE_NAME}\n * #\n * # Http BASIC Authentication filter:\n * #<a name=\"authcBasic\"><\/a>authcBasic = {@link org.jsecurity.web.filter.authc.BasicHttpAuthenticationFilter}\n * #authcBasic.{@link org.jsecurity.web.filter.authc.BasicHttpAuthenticationFilter#setApplicationName(String) applicationName} = application\n * #\n * # Roles filter: requires the requesting user to have one or more roles for the request to continue.\n * # If they do not have the specified roles, they are redirected to the specified URL.\n * #<a name=\"roles\"><\/a>roles = {@link org.jsecurity.web.filter.authz.RolesAuthorizationFilter}\n * #roles.{@link org.jsecurity.web.filter.authz.RolesAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.\n * #\n * # Permissions filter: requires the requesting user to have one or more permissions for the request to\n * # continue, and if they do not, redirects them to the specified URL.\n * #<a name=\"perms\"><\/a>perms = {@link org.jsecurity.web.filter.authz.PermissionsAuthorizationFilter}\n * #perms.{@link org.jsecurity.web.filter.authz.PermissionsAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.  Many\n * # applications like to use the same url specified in roles.unauthorizedUrl above.\n * #\n * #\n * # Define your own filters here.  To properly handle url path matching (see the [urls] section below), your\n * # filter should extend the {@link org.jsecurity.web.filter.PathMatchingFilter PathMatchingFilter} abstract class.\n *\n * [urls]\n * # This section defines url path mappings.  Each mapping entry must be on a single line and conform to the\n * # following representation:\n * #\n * # ant_path_expression = path_specific_filter_chain_definition\n * #\n * # For any request that matches a specified path, the corresponding value defines a comma-delimited chain of\n * # filters to execute for that request.\n * #\n * # This is incredibly powerful in that you can define arbitrary filter chains for any given request pattern\n * # to greatly customize the security experience.\n * #\n * # The path_specific_filter_chain_definition must match the following format:\n * #\n * # filter1[optional_config1], filter2[optional_config2], ..., filterN[optional_configN]\n * #\n * # where 'filterN' is the name of an filter defined above in the [filters] section and\n * # '[optional_configN]' is an optional bracketed string that has meaning for that particular filter for\n * # _that particular path_.  If the filter does not need specific config for that url path, you may\n * # discard the brackets - that is, filterN[] just becomes filterN.\n * #\n * # And because filter tokens define chains, order matters!  Define the tokens for each path pattern\n * # in the order you want them to filter (comma-delimited).\n * #\n * # Finally, each filter is free to handle the response however it wants if its necessary\n * # conditions are not met (redirect, HTTP error code, direct rendering, etc).  Otherwise, it is expected to allow\n * # the request to continue through the chain on to the final destination view.\n * #\n * # Examples:\n * #\n * # To illustrate chain configuration, look at the /account/** mapping below.  This says\n * # &quot;apply the above 'authcBasic' filter to any request matching the '/account/**' pattern&quot;.  Since the\n * # 'authcBasic' filter does not need any path-specific config, it doesn't have any config brackets [].\n * #\n * # The /remoting/** definition on the other hand uses the 'roles' and 'perms' filters which do use\n * # bracket notation.  That definition says:\n * #\n * # &quot;To access /remoting/** urls, ensure that the user is first authenticated ('authcBasic'), then ensure that user\n * # has the 'b2bClient' role, and then finally ensure that they have the 'remote:invoke:lan,wan' permission.&quot;\n * #\n * # (Note that because elements within brackets [ ] are comma-delimited themselves, we needed to escape the permission\n * # actions of 'lan,wan' with quotes.  If we didn't do that, the permission filter would interpret\n * # the text between the brackets as two permissions: 'remote:invoke:lan' and 'wan' instead of the\n * # single desired 'remote:invoke:lan,wan' token.  So, you can use quotes wherever you need to escape internal\n * # commas.)\n *\n * /account/** = <a href=\"#authcBasic\">authcBasic<\/a>\n * /remoting/** = <a href=\"#authcBasic\">authcBasic<\/a>, <a href=\"#roles\">roles<\/a>[b2bClient], <a href=\"#perms\">perms<\/a>[remote:invoke:\"lan,wan\"]\n *\n * &lt;/param-value&gt;&lt;/init-param&gt;\n * &lt;/filter&gt;\n *\n *\n * &lt;filter-mapping&gt;\n * &lt;filter-name&gt;JSecurityFilter&lt;/filter-name&gt;\n * &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n * &lt;/filter-mapping&gt;<\/pre>\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class JSecurityFilter extends OncePerRequestFilter {\n\n    //TODO - complete JavaDoc\n\n    public static final String SECURITY_MANAGER_CONTEXT_KEY = SecurityManager.class.getName() + \"_SERVLET_CONTEXT_KEY\";\n\n    public static final String CONFIG_CLASS_NAME_INIT_PARAM_NAME = \"configClassName\";\n    public static final String CONFIG_INIT_PARAM_NAME = \"config\";\n    public static final String CONFIG_URL_INIT_PARAM_NAME = \"configUrl\";\n\n    private static final Log log = LogFactory.getLog(JSecurityFilter.class);    \n\n    protected String config;\n    protected String configUrl;\n    protected String configClassName;\n    protected WebConfiguration configuration;\n\n    // Reference to the security manager used by this filter\n    protected SecurityManager securityManager;\n\n    public JSecurityFilter() {\n        this.configClassName = IniWebConfiguration.class.getName();\n    }\n\n    public WebConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    public void setConfiguration(WebConfiguration configuration) {\n        this.configuration = configuration;\n    }\n\n    public SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected void setSecurityManager(SecurityManager sm) {\n        this.securityManager = sm;\n    }\n\n    protected void onFilterConfigSet() throws Exception {\n        applyInitParams();\n        WebConfiguration config = configure();\n        setConfiguration(config);\n\n        // Retrieve and store a reference to the security manager\n        SecurityManager sm = ensureSecurityManager(config);\n        setSecurityManager(sm);\n    }\n\n    /**\n     * Retrieves the security manager for the given configuration.\n     *\n     * @param config the configuration for this filter.\n     * @return the security manager that this filter should use.\n     */\n    protected SecurityManager ensureSecurityManager(Configuration config) {\n        SecurityManager sm = config.getSecurityManager();\n\n        // If the config doesn't return a security manager, build one by default.\n        if (sm == null) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Configuration instance [\" + config + \"] did not provide a SecurityManager.  No config \" +\n                        \"specified?  Defaulting to a \" + DefaultWebSecurityManager.class.getName() + \" instance...\");\n            }\n            sm = new DefaultWebSecurityManager();\n        }\n\n        return sm;\n    }\n\n    protected void applyInitParams() {\n        FilterConfig config = getFilterConfig();\n\n        String configCN = clean(config.getInitParameter(CONFIG_CLASS_NAME_INIT_PARAM_NAME));\n        if (configCN != null) {\n            if (ClassUtils.isAvailable(configCN)) {\n                this.configClassName = configCN;\n            } else {\n                String msg = \"configClassName fully qualified class name value [\" + configCN + \"] is not \" +\n                        \"available in the classpath.  Please ensure you have typed it correctly and the \" +\n                        \"corresponding class or jar is in the classpath.\";\n                throw new ConfigurationException(msg);\n            }\n        }\n\n        this.config = clean(config.getInitParameter(CONFIG_INIT_PARAM_NAME));\n        this.configUrl = clean(config.getInitParameter(CONFIG_URL_INIT_PARAM_NAME));\n    }\n\n    protected WebConfiguration configure() {\n        WebConfiguration conf = (WebConfiguration) ClassUtils.newInstance(this.configClassName);\n        applyFilterConfig(conf);\n        applyUrlConfig(conf);\n        applyEmbeddedConfig(conf);\n        LifecycleUtils.init(conf);\n        return conf;\n    }\n\n    protected void applyFilterConfig(WebConfiguration conf) {\n        if (log.isDebugEnabled()) {\n            String msg = \"Attempting to inject the FilterConfig (using 'setFilterConfig' method) into the \" +\n                    \"instantiated WebConfiguration for any wrapped Filter initialization...\";\n            log.debug(msg);\n        }\n        try {\n            PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"filterConfig\");\n            if (pd != null) {\n                PropertyUtils.setProperty(conf, \"filterConfig\", getFilterConfig());\n            }\n        } catch (Exception e) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Error setting FilterConfig on WebConfiguration instance.\", e);\n            }\n        }\n    }\n\n    protected void applyEmbeddedConfig(WebConfiguration conf) {\n        if (this.config != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"config\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"config\", this.config);\n                } else {\n                    String msg = \"The 'config' filter param was specified, but there is no \" +\n                            \"'setConfig(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                            \"not require the 'config' filter param, please comment it out, or if you do need it, \" +\n                            \"please ensure your Configuration instance has a 'setConfig(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'config' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected void applyUrlConfig(WebConfiguration conf) {\n        if (this.configUrl != null) {\n            try {\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(conf, \"configUrl\");\n\n                if (pd != null) {\n                    PropertyUtils.setProperty(conf, \"configUrl\", this.configUrl);\n                } else {\n                    String msg = \"The 'configUrl' filter param was specified, but there is no \" +\n                            \"'setConfigUrl(String)' method on the Configuration instance [\" + conf + \"].  If you do \" +\n                            \"not require the 'configUrl' filter param, please comment it out, or if you do need it, \" +\n                            \"please ensure your Configuration instance has a 'setConfigUrl(String)' method to receive it.\";\n                    throw new ConfigurationException(msg);\n                }\n            } catch (Exception e) {\n                String msg = \"There was an error setting the 'configUrl' property of the Configuration object.\";\n                throw new ConfigurationException(msg, e);\n            }\n        }\n    }\n\n    protected boolean isHttpSessions() {\n        SecurityManager secMgr = getSecurityManager();\n        if (secMgr instanceof DefaultWebSecurityManager) {\n            return ((DefaultWebSecurityManager) secMgr).isHttpSessionMode();\n        } else {\n            return true;\n        }\n    }\n\n    protected InetAddress getInetAddress(ServletRequest request) {\n        return WebUtils.getInetAddress(request);\n    }\n\n    protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse,\n                                    FilterChain origChain) throws ServletException, IOException {\n\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        HttpServletResponse response = (HttpServletResponse) servletResponse;\n\n        ThreadContext.bind(getInetAddress(request));\n\n        boolean httpSessions = isHttpSessions();\n        request = new JSecurityHttpServletRequest(request, getServletContext(), httpSessions);\n        if (!httpSessions) {\n            //the JSecurityHttpServletResponse exists to support URL rewriting for session ids.  This is only needed if\n            //using JSecurity sessions (i.e. not simple HttpSession based sessions):\n            response = new JSecurityHttpServletResponse(response, getServletContext(), (JSecurityHttpServletRequest) request);\n        }\n\n        WebUtils.bind(request);\n        WebUtils.bind(response);\n        ThreadContext.bind(getSecurityManager());\n        ThreadContext.bind(getSecurityManager().getSubject());\n\n        FilterChain chain = getConfiguration().getChain(request, response, origChain);\n        if (chain == null) {\n            chain = origChain;\n            if (log.isTraceEnabled()) {\n                log.trace(\"No security filter chain configured for the current request.  Using default.\");\n            }\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\" Using configured filter chain for the current request.\");\n            }\n        }\n\n        try {\n            chain.doFilter(request, response);\n        } finally {\n            ThreadContext.unbindSubject();\n            ThreadContext.unbindSecurityManager();\n            WebUtils.unbindServletResponse();\n            WebUtils.unbindServletRequest();\n            ThreadContext.unbindInetAddress();\n        }\n    }\n\n    public void destroy() {\n        LifecycleUtils.destroy(getConfiguration());\n    }\n}\n","lineNo":410}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport java.lang.ref.ReferenceQueue;\nimport java.lang.ref.SoftReference;\nimport java.util.*;\n\n/**\n * A <code><em>Soft<\/em>HashMap<\/code> is a memory-constrained map that stores its <em>values<\/em> in\n * {@link SoftReference SoftReference}s.  (Contrast this with the JDK's\n * {@link WeakHashMap WeakHashMap}, which uses weak references for its <em>keys<\/em>, which is of little value if you\n * want the cache to auto-resize itself based on memory constraints).\n * <p/>\n * Having the values wrapped by soft references allows the cache to automatically reduce its size based on memory\n * limitations and garbage collection.  This ensures that the cache will not cause memory leaks by holding hard\n * references to all of its values.\n * <p/>\n * This class is a generics-enabled Map based on initial ideas from Hienz Kabutz's and Sydney Redelinghuys's\n * <a href=\"http://www.javaspecialists.eu/archive/Issue015.html\">publicly posted version<\/a>, with continued\n * modifications.\n *\n * @author Les Hazlewood\n * @since 1.0\n */\npublic class SoftHashMap<K, V> extends AbstractMap<K, V> {\n\n    /**\n     * The default value of the HARD_SIZE attribute, equal to 100.\n     */\n    private static final int DEFAULT_HARD_SIZE = 100;\n\n    /**\n     * The internal HashMap that will hold the SoftReference.\n     */\n    private final Map<K, SoftValue<V, K>> map = new HashMap<K, SoftValue<V, K>>();\n\n    /**\n     * The number of &quot;hard&quot; references to hold internally, that is, the number of instances to prevent\n     * from being garbage collected automatically (unlike other soft references).\n     */\n    private final int HARD_SIZE;\n\n    /**\n     * The FIFO list of hard references (not to be garbage collected), order of last access.\n     */\n    private final LinkedList<V> hardCache = new LinkedList<V>();\n\n    /**\n     * Reference queue for cleared SoftReference objects.\n     */\n    private final ReferenceQueue<? super V> queue = new ReferenceQueue<V>();\n\n    public SoftHashMap() {\n        this(DEFAULT_HARD_SIZE);\n    }\n\n    public SoftHashMap(int hardSize) {\n        HARD_SIZE = hardSize;\n    }\n\n    public V get(Object key) {\n\n        V result = null;\n\n        SoftValue<V, K> value = map.get(key);\n\n        if (value != null) {\n            //unwrap the 'real' value from the SoftReference\n            result = value.get();\n            if (result == null) {\n                //The wrapped value was garbage collected, so remove this entry from the backing map:\n                map.remove(key);\n            } else {\n                //Add this value to the beginning of the 'hard' reference queue (FIFO).\n                hardCache.addFirst(result);\n\n                //trim the hard ref queue if necessary:\n                if (hardCache.size() > HARD_SIZE) {\n                    hardCache.removeLast();\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * We define our own subclass of SoftReference which contains\n     * not only the value but also the key to make it easier to find\n     * the entry in the HashMap after it's been garbage collected.\n     */\n    private static class SoftValue<V, K> extends SoftReference<V> {\n\n        private final K key;\n\n        /**\n         * Constructs a new instance, wrapping the value, key, and queue, as\n         * required by the superclass.\n         *\n         * @param value the map value\n         * @param key   the map key\n         * @param queue the soft reference queue to poll to determine if the entry had been reaped by the GC.\n         */\n        private SoftValue(V value, K key, ReferenceQueue<? super V> queue) {\n            super(value, queue);\n            this.key = key;\n        }\n    }\n\n    /**\n     * Traverses the ReferenceQueue and removes garbage-collected SoftValue objects from the backing map\n     * by looking them up using the SoftValue.key data member.\n     */\n    private void processQueue() {\n        SoftValue sv;\n        while ((sv = (SoftValue) queue.poll()) != null) {\n            map.remove(sv.key); // we can access private data!\n        }\n    }\n\n    /**\n     * Creates a new entry, but wraps the value in a SoftValue instance to enable auto garbage collection.\n     */\n    public V put(K key, V value) {\n        processQueue(); // throw out garbage collected values first\n        SoftValue<V, K> sv = new SoftValue<V, K>(value, key, queue);\n        SoftValue<V, K> previous = map.put(key, sv);\n        return previous != null ? previous.get() : null;\n    }\n\n    public V remove(Object key) {\n        processQueue(); // throw out garbage collected values first\n        SoftValue<V, K> raw = map.remove(key);\n        return raw != null ? raw.get() : null;\n    }\n\n    public void clear() {\n        hardCache.clear();\n        processQueue(); // throw out garbage collected values\n        map.clear();\n    }\n\n    public int size() {\n        processQueue(); // throw out garbage collected values first\n        return map.size();\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Set<Map.Entry<K, V>> entrySet() {\n        processQueue(); // throw out garbage collected values first\n        Set set = map.entrySet();\n        return Collections.unmodifiableSet(set);\n    }\n\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport java.lang.ref.ReferenceQueue;\nimport java.lang.ref.SoftReference;\nimport java.util.*;\n\n/**\n * A <code><em>Soft<\/em>HashMap<\/code> is a memory-constrained map that stores its <em>values<\/em> in\n * {@link SoftReference SoftReference}s.  (Contrast this with the JDK's\n * {@link WeakHashMap WeakHashMap}, which uses weak references for its <em>keys<\/em>, which is of little value if you\n * want the cache to auto-resize itself based on memory constraints).\n * <p/>\n * Having the values wrapped by soft references allows the cache to automatically reduce its size based on memory\n * limitations and garbage collection.  This ensures that the cache will not cause memory leaks by holding hard\n * references to all of its values.\n * <p/>\n * This class is a generics-enabled Map based on initial ideas from Hienz Kabutz's and Sydney Redelinghuys's\n * <a href=\"http://www.javaspecialists.eu/archive/Issue015.html\">publicly posted version<\/a>, with continued\n * modifications.\n *\n * @author Les Hazlewood\n * @since 1.0\n */\npublic class SoftHashMap<K, V> extends AbstractMap<K, V> {\n\n    /**\n     * The default value of the HARD_SIZE attribute, equal to 100.\n     */\n    private static final int DEFAULT_HARD_SIZE = 100;\n\n    /**\n     * The internal HashMap that will hold the SoftReference.\n     */\n    private final Map<K, SoftValue<V, K>> map = new HashMap<K, SoftValue<V, K>>();\n\n    /**\n     * The number of &quot;hard&quot; references to hold internally, that is, the number of instances to prevent\n     * from being garbage collected automatically (unlike other soft references).\n     */\n    private final int HARD_SIZE;\n\n    /**\n     * The FIFO list of hard references (not to be garbage collected), order of last access.\n     */\n    private final LinkedList<V> hardCache = new LinkedList<V>();\n\n    /**\n     * Reference queue for cleared SoftReference objects.\n     */\n    private final ReferenceQueue<? super V> queue = new ReferenceQueue<V>();\n\n    public SoftHashMap() {\n        this(DEFAULT_HARD_SIZE);\n    }\n\n    public SoftHashMap(int hardSize) {\n        HARD_SIZE = hardSize;\n    }\n\n    public V get(Object key) {\n\n        V result = null;\n\n        SoftValue<V, K> value = map.get(key);\n\n        if (value != null) {\n            //unwrap the 'real' value from the SoftReference\n            result = value.get();\n            if (result == null) {\n                //The wrapped value was garbage collected, so remove this entry from the backing map:\n                map.remove(key);\n            } else {\n                //Add this value to the beginning of the 'hard' reference queue (FIFO).\n                hardCache.addFirst(result);\n\n                //trim the hard ref queue if necessary:\n                if (hardCache.size() > HARD_SIZE) {\n                    hardCache.removeLast();\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * We define our own subclass of SoftReference which contains\n     * not only the value but also the key to make it easier to find\n     * the entry in the HashMap after it's been garbage collected.\n     */\n    private static class SoftValue<V, K> extends SoftReference<V> {\n\n        private final K key;\n\n        /**\n         * Constructs a new instance, wrapping the value, key, and queue, as\n         * required by the superclass.\n         *\n         * @param value the map value\n         * @param key   the map key\n         * @param queue the soft reference queue to poll to determine if the entry had been reaped by the GC.\n         */\n        private SoftValue(V value, K key, ReferenceQueue<? super V> queue) {\n            super(value, queue);\n            this.key = key;\n        }\n    }\n\n    /**\n     * Traverses the ReferenceQueue and removes garbage-collected SoftValue objects from the backing map\n     * by looking them up using the SoftValue.key data member.\n     */\n    private void processQueue() {\n        SoftValue sv;\n        while ((sv = (SoftValue) queue.poll()) != null) {\n            map.remove(sv.key); // we can access private data!\n        }\n    }\n\n    /**\n     * Creates a new entry, but wraps the value in a SoftValue instance to enable auto garbage collection.\n     */\n    public V put(K key, V value) {\n        processQueue(); // throw out garbage collected values first\n        SoftValue<V, K> sv = new SoftValue<V, K>(value, key, queue);\n        return map.put(key, sv).get();\n    }\n\n    public V remove(Object key) {\n        processQueue(); // throw out garbage collected values first\n        SoftValue<V, K> raw = map.remove(key);\n        V removed = null;\n        if (raw != null) {\n            removed = raw.get();\n        }\n        return removed;\n    }\n\n    public void clear() {\n        hardCache.clear();\n        processQueue(); // throw out garbage collected values\n        map.clear();\n    }\n\n    public int size() {\n        processQueue(); // throw out garbage collected values first\n        return map.size();\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Set<Map.Entry<K, V>> entrySet() {\n        processQueue(); // throw out garbage collected values first\n        Set set = map.entrySet();\n        return Collections.unmodifiableSet(set);\n    }\n\n\n}\n","lineNo":143}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.subject.AbstractRememberMeManager;\nimport org.jsecurity.web.attr.CookieAttribute;\nimport org.jsecurity.web.attr.WebAttribute;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\n/**\n * Remembers a Subject's identity by using a {@link WebAttribute WebAttribute} instance to retain\n * the identity value between web requests.\n *\n * <p>This class's default <code>WebAttribute<\/code> instance is a {@link CookieAttribute CookieAttribute}, storing\n * the Subject's {@link org.jsecurity.subject.Subject#getPrincipals principals} in a <code>Cookie<\/code>.  Note that\n * because this class subclasses the <code>AbstractRememberMeManager<\/code> which already provides serialization and\n * encryption logic, this class utilizes both for added security before setting the cookie value.<\/p>\n *\n * <p>This class also contains &quot;passthrough&quot; JavaBeans-compatible getters/setters for the underlying\n * <code>CookieAttribute<\/code>'s properties to make configuration easier.<\/p>\n *\n * <p>Note however as a basic sanity check, these passthrough methods will first assert that the underlying\n * {@link #getIdentityAttribute identityAttribute} is actually a {@link CookieAttribute CookieAttribute}.  If it\n * is not, an {@link IllegalStateException} will be thrown.  Because the default instance of this class <em>is<\/em>\n * already <code>CookieAttribute<\/code>, you would only ever experience the exception if you explicitly\n * override the internal instance with a different type and accidentally call one of these JavaBeans passthrough\n * methods.<\/p>\n *\n * <p>Just be aware of this if you manually override the {@link #getIdentityAttribute identityAttribute} property\n * to be an instance of something <em>other<\/em> than a <code>CookieAttribute<\/code>.<\/p>\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class WebRememberMeManager extends AbstractRememberMeManager {\n\n    //TODO - complete JavaDoc\n\n    private static transient final Log log = LogFactory.getLog( WebRememberMeManager.class );\n\n    /**\n     * The default name of the underlying rememberMe cookie which is <code>rememberMe<\/code>.\n     */\n    public static final String DEFAULT_REMEMBER_ME_COOKIE_NAME = \"rememberMe\";\n\n    protected WebAttribute<String> identityAttribute = null;\n\n    public WebRememberMeManager() {\n        CookieAttribute<String> attr = new CookieAttribute<String>(DEFAULT_REMEMBER_ME_COOKIE_NAME);\n        attr.setCheckRequestParams(false);\n        //Peter (JSecurity developer) said that Jetty didn't like the CookieAttribute.INDEFINITE value\n        // (Tomcat was ok with it), so just default to a few years for now.  If anyone doesn't visit a site in 3 years\n        // after last login, I doubt any JSecurity users would mind their end-users to be forced to log in. - LAH.\n        attr.setMaxAge(CookieAttribute.ONE_YEAR * 3);\n        this.identityAttribute = attr;\n    }\n\n    public WebAttribute<String> getIdentityAttribute() {\n        return identityAttribute;\n    }\n\n    public void setIdentityAttribute(WebAttribute<String> identityAttribute) {\n        this.identityAttribute = identityAttribute;\n    }\n\n    protected void assertCookieAttribute() {\n        if (!(this.identityAttribute instanceof CookieAttribute)) {\n            String msg = \"Attempting to access a Cookie property, but the underlying \" +\n                    WebAttribute.class.getName() + \" instance is not a \" +\n                    CookieAttribute.class.getName() + \" instance.  This is expected if you \" +\n                    \"are accessing or modifying a cookie property.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * Passthrough JavaBeans property that will get the underyling rememberMe cookie's name.\n     *\n     * <p>The default value is {@link #DEFAULT_REMEMBER_ME_COOKIE_NAME}<\/p>\n     *\n     * <p>This method performs a quick <code>CookieAttribute<\/code> sanity check as described in the class-level JavaDoc.<\/p>\n     *\n     * @return the underlying rememberMe cookie's name\n     */\n    public String getCookieName() {\n        assertCookieAttribute();\n        return ((CookieAttribute) this.identityAttribute).getName();\n    }\n\n    /**\n     * Passthrough JavaBeans property that will set the underyling rememberMe cookie's name.\n     *\n     * <p>The default value is {@link #DEFAULT_REMEMBER_ME_COOKIE_NAME}<\/p>\n     *\n     * <p>This method performs a quick <code>CookieAttribute<\/code> sanity check as described in the class-level JavaDoc.<\/p>\n     *\n     * @param name the name to assign to the underlying rememberMe cookie\n     */\n    public void setCookieName(String name) {\n        assertCookieAttribute();\n        ((CookieAttribute) this.identityAttribute).setName(name);\n    }\n\n    /**\n     * Passthrough JavaBeans property that will get the underyling rememberMe cookie's path.\n     *\n     * <p>This method performs a quick <code>CookieAttribute<\/code> sanity check as described in the class-level JavaDoc.<\/p>\n     *\n     * @return the underlying rememberMe cookie's path\n     */\n    public String getCookiePath() {\n        assertCookieAttribute();\n        return ((CookieAttribute) this.identityAttribute).getPath();\n    }\n\n    /**\n     * Passthrough JavaBeans property that will set the underyling rememberMe cookie's path.\n     *\n     * <p>This method performs a quick <code>CookieAttribute<\/code> sanity check as described in the class-level JavaDoc.<\/p>\n     *\n     * @param path the path to assign to the underlying rememberMe cookie\n     */\n    public void setCookiePath(String path) {\n        assertCookieAttribute();\n        ((CookieAttribute) this.identityAttribute).setPath(path);\n    }\n\n    /**\n     * Passthrough JavaBeans property that will get the underyling rememberMe cookie's max age.\n     *\n     * <p>This method performs a quick <code>CookieAttribute<\/code> sanity check as described in the class-level JavaDoc.<\/p>\n     *\n     * @return the underlying rememberMe cookie's max age.\n     */\n    public int getCookieMaxAge() {\n        assertCookieAttribute();\n        return ((CookieAttribute) this.identityAttribute).getMaxAge();\n    }\n\n    /**\n     * Passthrough JavaBeans property that will get the underyling rememberMe cookie's max age.\n     *\n     * <p>This method performs a quick <code>CookieAttribute<\/code> sanity check as described in the class-level JavaDoc.<\/p>\n     *\n     * @param maxAge the max age to assign to the underlying rememberMe cookie\n     */\n    public void setCookieMaxAge(int maxAge) {\n        assertCookieAttribute();\n        ((CookieAttribute) this.identityAttribute).setMaxAge(maxAge);\n    }\n\n    /**\n     * Passthrough JavaBeans property that will get the underyling rememberMe cookie's 'secure' status.\n     *\n     * <p>This method performs a quick <code>CookieAttribute<\/code> sanity check as described in the class-level JavaDoc.<\/p>\n     *\n     * @return the underlying rememberMe cookie's 'secure' flag\n     */\n    public boolean isCookieSecure() {\n        assertCookieAttribute();\n        return ((CookieAttribute) this.identityAttribute).isSecure();\n    }\n\n    /**\n     * Passthrough JavaBeans property that will set the underyling rememberMe cookie's 'secure' status.\n     *\n     * <p>This method performs a quick <code>CookieAttribute<\/code> sanity check as described in the class-level JavaDoc.<\/p>\n     *\n     * @param secure the 'secure' flag to assign to the underlying rememberMe cookie.\n     */\n    public void setCookieSecure(boolean secure) {\n        assertCookieAttribute();\n        ((CookieAttribute) this.identityAttribute).setSecure(secure);\n    }\n\n    protected void rememberSerializedIdentity(byte[] serialized) {\n        ServletRequest request = WebUtils.getRequiredServletRequest();\n        ServletResponse response = WebUtils.getRequiredServletResponse();\n        //base 64 encode it and store as a cookie:\n        String base64 = Base64.encodeToString(serialized);\n        getIdentityAttribute().storeValue(base64, request, response);\n    }\n\n    protected byte[] getSerializedRememberedIdentity() {\n        ServletRequest request = WebUtils.getRequiredServletRequest();\n        ServletResponse response = WebUtils.getRequiredServletResponse();\n        String base64 = getIdentityAttribute().retrieveValue(request, response);\n        if (base64 != null) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Acquired Base64 encoded identity [\" + base64 + \"]\" );\n            }\n            byte[] decoded = Base64.decode(base64);\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Base64 decoded byte array length: \" + (decoded != null ? decoded.length : 0) + \" bytes.\" );\n            }\n            return decoded;\n        } else {\n            //no cookie set - new site visitor?\n            return null;\n        }\n    }\n\n    protected void forgetIdentity() {\n        ServletRequest request = WebUtils.getRequiredServletRequest();\n        ServletResponse response = WebUtils.getRequiredServletResponse();\n        getIdentityAttribute().removeValue(request, response);\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.subject.AbstractRememberMeManager;\nimport org.jsecurity.web.attr.CookieAttribute;\nimport org.jsecurity.web.attr.WebAttribute;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\n/**\n * Remembers a Subject's identity by using a {@link WebAttribute WebAttribute} instance to retain\n * the identity value between web requests.\n *\n * <p>This class's default <code>WebAttribute<\/code> instance is a {@link CookieAttribute CookieAttribute}, storing\n * the Subject's {@link org.jsecurity.subject.Subject#getPrincipals principals} in a <code>Cookie<\/code>.  Note that\n * because this class subclasses the <code>AbstractRememberMeManager<\/code> which already provides serialization and\n * encryption logic, this class utilizes both for added security before setting the cookie value.<\/p>\n *\n * <p>This class also contains &quot;passthrough&quot; JavaBeans-compatible getters/setters for the underlying\n * <code>CookieAttribute<\/code>'s properties to make configuration easier.<\/p>\n *\n * <p>Note however as a basic sanity check, these passthrough methods will first assert that the underlying\n * {@link #getIdentityAttribute identityAttribute} is actually a {@link CookieAttribute CookieAttribute}.  If it\n * is not, an {@link IllegalStateException} will be thrown.  Because the default instance of this class <em>is<\/em>\n * already <code>CookieAttribute<\/code>, you would only ever experience the exception if you explicitly\n * override the internal instance with a different type and accidentally call one of these JavaBeans passthrough\n * methods.<\/p>\n *\n * <p>Just be aware of this if you manually override the {@link #getIdentityAttribute identityAttribute} property\n * to be an instance of something <em>other<\/em> than a <code>CookieAttribute<\/code>.<\/p>\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class WebRememberMeManager extends AbstractRememberMeManager {\n\n    //TODO - complete JavaDoc\n\n    /**\n     * The default name of the underlying rememberMe cookie which is <code>rememberMe<\/code>.\n     */\n    public static final String DEFAULT_REMEMBER_ME_COOKIE_NAME = \"rememberMe\";\n\n    protected WebAttribute<String> identityAttribute = null;\n\n    public WebRememberMeManager() {\n        CookieAttribute<String> attr = new CookieAttribute<String>(DEFAULT_REMEMBER_ME_COOKIE_NAME);\n        attr.setCheckRequestParams(false);\n        //Peter (JSecurity developer) said that Jetty didn't like the CookieAttribute.INDEFINITE value\n        // (Tomcat was ok with it), so just default to a few years for now.  If anyone doesn't visit a site in 3 years\n        // after last login, I doubt any JSecurity users would mind their end-users to be forced to log in. - LAH.\n        attr.setMaxAge(CookieAttribute.ONE_YEAR * 3);\n        this.identityAttribute = attr;\n    }\n\n    public WebAttribute<String> getIdentityAttribute() {\n        return identityAttribute;\n    }\n\n    public void setIdentityAttribute(WebAttribute<String> identityAttribute) {\n        this.identityAttribute = identityAttribute;\n    }\n\n    protected void assertCookieAttribute() {\n        if (!(this.identityAttribute instanceof CookieAttribute)) {\n            String msg = \"Attempting to access a Cookie property, but the underlying \" +\n                    WebAttribute.class.getName() + \" instance is not a \" +\n                    CookieAttribute.class.getName() + \" instance.  This is expected if you \" +\n                    \"are accessing or modifying a cookie property.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * Passthrough JavaBeans property that will get the underyling rememberMe cookie's name.\n     *\n     * <p>The default value is {@link #DEFAULT_REMEMBER_ME_COOKIE_NAME}<\/p>\n     *\n     * <p>This method performs a quick <code>CookieAttribute<\/code> sanity check as described in the class-level JavaDoc.<\/p>\n     *\n     * @return the underlying rememberMe cookie's name\n     */\n    public String getCookieName() {\n        assertCookieAttribute();\n        return ((CookieAttribute) this.identityAttribute).getName();\n    }\n\n    /**\n     * Passthrough JavaBeans property that will set the underyling rememberMe cookie's name.\n     *\n     * <p>The default value is {@link #DEFAULT_REMEMBER_ME_COOKIE_NAME}<\/p>\n     *\n     * <p>This method performs a quick <code>CookieAttribute<\/code> sanity check as described in the class-level JavaDoc.<\/p>\n     *\n     * @param name the name to assign to the underlying rememberMe cookie\n     */\n    public void setCookieName(String name) {\n        assertCookieAttribute();\n        ((CookieAttribute) this.identityAttribute).setName(name);\n    }\n\n    /**\n     * Passthrough JavaBeans property that will get the underyling rememberMe cookie's path.\n     *\n     * <p>This method performs a quick <code>CookieAttribute<\/code> sanity check as described in the class-level JavaDoc.<\/p>\n     *\n     * @return the underlying rememberMe cookie's path\n     */\n    public String getCookiePath() {\n        assertCookieAttribute();\n        return ((CookieAttribute) this.identityAttribute).getPath();\n    }\n\n    /**\n     * Passthrough JavaBeans property that will set the underyling rememberMe cookie's path.\n     *\n     * <p>This method performs a quick <code>CookieAttribute<\/code> sanity check as described in the class-level JavaDoc.<\/p>\n     *\n     * @param path the path to assign to the underlying rememberMe cookie\n     */\n    public void setCookiePath(String path) {\n        assertCookieAttribute();\n        ((CookieAttribute) this.identityAttribute).setPath(path);\n    }\n\n    /**\n     * Passthrough JavaBeans property that will get the underyling rememberMe cookie's max age.\n     *\n     * <p>This method performs a quick <code>CookieAttribute<\/code> sanity check as described in the class-level JavaDoc.<\/p>\n     *\n     * @return the underlying rememberMe cookie's max age.\n     */\n    public int getCookieMaxAge() {\n        assertCookieAttribute();\n        return ((CookieAttribute) this.identityAttribute).getMaxAge();\n    }\n\n    /**\n     * Passthrough JavaBeans property that will get the underyling rememberMe cookie's max age.\n     *\n     * <p>This method performs a quick <code>CookieAttribute<\/code> sanity check as described in the class-level JavaDoc.<\/p>\n     *\n     * @param maxAge the max age to assign to the underlying rememberMe cookie\n     */\n    public void setCookieMaxAge(int maxAge) {\n        assertCookieAttribute();\n        ((CookieAttribute) this.identityAttribute).setMaxAge(maxAge);\n    }\n\n    /**\n     * Passthrough JavaBeans property that will get the underyling rememberMe cookie's 'secure' status.\n     *\n     * <p>This method performs a quick <code>CookieAttribute<\/code> sanity check as described in the class-level JavaDoc.<\/p>\n     *\n     * @return the underlying rememberMe cookie's 'secure' flag\n     */\n    public boolean isCookieSecure() {\n        assertCookieAttribute();\n        return ((CookieAttribute) this.identityAttribute).isSecure();\n    }\n\n    /**\n     * Passthrough JavaBeans property that will set the underyling rememberMe cookie's 'secure' status.\n     *\n     * <p>This method performs a quick <code>CookieAttribute<\/code> sanity check as described in the class-level JavaDoc.<\/p>\n     *\n     * @param secure the 'secure' flag to assign to the underlying rememberMe cookie.\n     */\n    public void setCookieSecure(boolean secure) {\n        assertCookieAttribute();\n        ((CookieAttribute) this.identityAttribute).setSecure(secure);\n    }\n\n    protected void rememberSerializedIdentity(byte[] serialized) {\n        ServletRequest request = WebUtils.getRequiredServletRequest();\n        ServletResponse response = WebUtils.getRequiredServletResponse();\n        //base 64 encode it and store as a cookie:\n        String base64 = Base64.encodeToString(serialized);\n        getIdentityAttribute().storeValue(base64, request, response);\n    }\n\n    protected byte[] getSerializedRememberedIdentity() {\n        ServletRequest request = WebUtils.getRequiredServletRequest();\n        ServletResponse response = WebUtils.getRequiredServletResponse();\n        String base64 = getIdentityAttribute().retrieveValue(request, response);\n        if (base64 != null) {\n            return Base64.decode(base64);\n        } else {\n            //no cookie set - new site visitor?\n            return null;\n        }\n    }\n\n    protected void forgetIdentity() {\n        ServletRequest request = WebUtils.getRequiredServletRequest();\n        ServletResponse response = WebUtils.getRequiredServletResponse();\n        getIdentityAttribute().removeValue(request, response);\n    }\n}\n","lineNo":213}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.*;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\n\n/**\n * @author Les Hazlewood\n * @since 0.1\n */\npublic abstract class AbstractSessionManager implements SessionManager, SessionListenerRegistrar {\n\n    protected transient final Log log = LogFactory.getLog(getClass());\n\n    protected Collection<SessionListener> listeners = new ArrayList<SessionListener>();\n\n    public AbstractSessionManager() {\n    }\n\n    public void setSessionListeners(Collection<SessionListener> listeners) {\n        if (listeners == null) {\n            this.listeners = new ArrayList<SessionListener>();\n        } else {\n            this.listeners = listeners;\n        }\n    }\n\n    public void add(SessionListener listener) {\n        this.listeners.add(listener);\n    }\n\n    public boolean remove(SessionListener listener) {\n        return this.listeners.remove(listener);\n    }\n\n    public Serializable start(InetAddress originatingHost) throws HostUnauthorizedException, IllegalArgumentException {\n        Session session = createSession(originatingHost);\n        notifyStart(session);\n        return session.getId();\n    }\n\n    /**\n     * Returns the session instance to use to pass to registered <code>SessionListener<\/code>s for notification\n     * that the session has been validated (stopped or expired).\n     * <p/>\n     * The default implementation returns an\n     * {@link org.jsecurity.session.mgt.ImmutableProxiedSession ImmutableProxiedSession} instance to ensure\n     * that the specified <code>session<\/code> argument is not modified by any listeners.\n     *\n     * @param session the <code>Session<\/code> object being invalidated.\n     * @return the <code>Session<\/code> instance to use to pass to registered <code>SessionListener<\/code>s for\n     *         notification.\n     */\n    protected Session beforeInvalidNotification(Session session) {\n        return new ImmutableProxiedSession(session);\n    }\n\n    protected void notifyStart(Session session) {\n        for (SessionListener listener : this.listeners) {\n            listener.onStart(session);\n        }\n    }\n\n    protected void notifyStop(Session session) {\n        Session forNotification = beforeInvalidNotification(session);\n        for (SessionListener listener : this.listeners) {\n            listener.onStop(forNotification);\n        }\n    }\n\n    protected void notifyExpiration(Session session) {\n        Session forNotification = beforeInvalidNotification(session);\n        for (SessionListener listener : this.listeners) {\n            listener.onExpiration(forNotification);\n        }\n    }\n\n    public Date getStartTimestamp(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public Date getStopTimestamp(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public Date getLastAccessTime(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public boolean isStopped(Serializable sessionId) {\n        Session session = getSession(sessionId);\n        return session.getStopTimestamp() != null || session.isExpired();\n    }\n\n    public boolean isExpired(Serializable sessionId) {\n        try {\n            Session session = getSession(sessionId);\n            return session.isExpired();\n        } catch (ExpiredSessionException e) {\n            return true;\n        }\n    }\n\n    public long getTimeout(Serializable sessionId) throws InvalidSessionException {\n        return getSession(sessionId).getTimeout();\n    }\n\n    public void setTimeout(Serializable sessionId, long maxIdleTimeInMillis) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        s.setTimeout(maxIdleTimeInMillis);\n        onChange(s);\n    }\n\n    public void touch(Serializable sessionId) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        s.touch();\n        onChange(s);\n    }\n\n    public InetAddress getHostAddress(Serializable sessionId) {\n        return getSession(sessionId).getHostAddress();\n    }\n\n    public void stop(Serializable sessionId) throws InvalidSessionException {\n        Session session = getSession(sessionId);\n        stop(session);\n    }\n\n    protected void stop(Session session) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Stopping session with id [\" + session.getId() + \"]\");\n        }\n        notifyStop(session);\n        session.stop();\n        onStop(session);\n    }\n\n    protected void onStop(Session session) {\n        onChange(session);\n    }\n\n    protected void expire(Session session) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Expiring session with id [\" + session.getId() + \"]\");\n        }\n        notifyExpiration(session);\n        session.stop();\n        onExpiration(session);\n    }\n\n    protected void onExpiration(Session session) {\n        onChange(session);\n    }\n\n    public Collection<Object> getAttributeKeys(Serializable sessionId) {\n        return getSession(sessionId).getAttributeKeys();\n    }\n\n    public Object getAttribute(Serializable sessionId, Object key) throws InvalidSessionException {\n        return getSession(sessionId).getAttribute(key);\n    }\n\n    public void setAttribute(Serializable sessionId, Object key, Object value) throws InvalidSessionException {\n        if (value == null) {\n            removeAttribute(sessionId, key);\n        } else {\n            Session s = getSession(sessionId);\n            s.setAttribute(key, value);\n            onChange(s);\n        }\n    }\n\n    public Object removeAttribute(Serializable sessionId, Object key) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        Object removed = s.removeAttribute(key);\n        if (removed != null) {\n            onChange(s);\n        }\n        return removed;\n    }\n\n    protected Session getSession(Serializable sessionId) throws InvalidSessionException {\n        Session session = doGetSession(sessionId);\n        if (session == null) {\n            String msg = \"There is no session with id [\" + sessionId + \"]\";\n            throw new UnknownSessionException(msg);\n        }\n        return session;\n    }\n\n    protected void onChange(Session s) {\n    }\n\n    protected abstract Session doGetSession(Serializable sessionId) throws InvalidSessionException;\n\n    protected abstract Session createSession(InetAddress originatingHost) throws HostUnauthorizedException, IllegalArgumentException;\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.*;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\n\n/**\n * @author Les Hazlewood\n * @since 0.1\n */\npublic abstract class AbstractSessionManager implements SessionManager, SessionListenerRegistrar {\n\n    protected transient final Log log = LogFactory.getLog(getClass());\n\n    protected Collection<SessionListener> listeners = new ArrayList<SessionListener>();\n\n    public AbstractSessionManager() {\n    }\n\n    public void setSessionListeners(Collection<SessionListener> listeners) {\n        if (listeners == null) {\n            this.listeners = new ArrayList<SessionListener>();\n        } else {\n            this.listeners = listeners;\n        }\n    }\n\n    public void add(SessionListener listener) {\n        this.listeners.add(listener);\n    }\n\n    public boolean remove(SessionListener listener) {\n        return this.listeners.remove(listener);\n    }\n\n    public Serializable start(InetAddress originatingHost) throws HostUnauthorizedException, IllegalArgumentException {\n        Session session = createSession(originatingHost);\n        notifyStart(session);\n        return session.getId();\n    }\n\n    protected void notifyStart(Session session) {\n        for (SessionListener listener : this.listeners) {\n            listener.onStart(session);\n        }\n    }\n\n    protected void notifyStop(Session session) {\n        for (SessionListener listener : this.listeners) {\n            listener.onStop(session);\n        }\n    }\n\n    protected void notifyExpiration(Session session) {\n        for (SessionListener listener : this.listeners) {\n            listener.onExpiration(session);\n        }\n    }\n\n    public Date getStartTimestamp(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public Date getStopTimestamp(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public Date getLastAccessTime(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public boolean isStopped(Serializable sessionId) {\n        Session session = getSession(sessionId);\n        return session.getStopTimestamp() != null || session.isExpired();\n    }\n\n    public boolean isExpired(Serializable sessionId) {\n        try {\n            Session session = getSession(sessionId);\n            return session.isExpired();\n        } catch (ExpiredSessionException e) {\n            return true;\n        }\n    }\n\n    public long getTimeout(Serializable sessionId) throws InvalidSessionException {\n        return getSession(sessionId).getTimeout();\n    }\n\n    public void setTimeout(Serializable sessionId, long maxIdleTimeInMillis) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        s.setTimeout(maxIdleTimeInMillis);\n        onChange(s);\n    }\n\n    public void touch(Serializable sessionId) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        s.touch();\n        onChange(s);\n    }\n\n    public InetAddress getHostAddress(Serializable sessionId) {\n        return getSession(sessionId).getHostAddress();\n    }\n\n    public void stop(Serializable sessionId) throws InvalidSessionException {\n        Session session = getSession(sessionId);\n        stop(session);\n    }\n\n    protected void stop(Session session) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Stopping session with id [\" + session.getId() + \"]\");\n        }\n        notifyStop(session);\n        session.stop();\n        onStop(session);\n    }\n\n    protected void onStop(Session session) {\n        onChange(session);\n    }\n\n    protected void expire(Session session) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Expiring session with id [\" + session.getId() + \"]\");\n        }\n        notifyExpiration(session);\n        session.stop();\n        onExpiration(session);\n    }\n\n    protected void onExpiration(Session session) {\n        onChange(session);\n    }\n\n    public Collection<Object> getAttributeKeys(Serializable sessionId) {\n        return getSession(sessionId).getAttributeKeys();\n    }\n\n    public Object getAttribute(Serializable sessionId, Object key) throws InvalidSessionException {\n        return getSession(sessionId).getAttribute(key);\n    }\n\n    public void setAttribute(Serializable sessionId, Object key, Object value) throws InvalidSessionException {\n        if (value == null) {\n            removeAttribute(sessionId, key);\n        } else {\n            Session s = getSession(sessionId);\n            s.setAttribute(key, value);\n            onChange(s);\n        }\n    }\n\n    public Object removeAttribute(Serializable sessionId, Object key) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        Object removed = s.removeAttribute(key);\n        if (removed != null) {\n            onChange(s);\n        }\n        return removed;\n    }\n\n    protected Session getSession(Serializable sessionId) throws InvalidSessionException {\n        Session session = doGetSession(sessionId);\n        if (session == null) {\n            String msg = \"There is no session with id [\" + sessionId + \"]\";\n            throw new UnknownSessionException(msg);\n        }\n        return session;\n    }\n\n    protected void onChange(Session s) {\n    }\n\n    protected abstract Session doGetSession(Serializable sessionId) throws InvalidSessionException;\n\n    protected abstract Session createSession(InetAddress originatingHost) throws HostUnauthorizedException, IllegalArgumentException;\n}\n","lineNo":90}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.*;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\n\n/**\n * @author Les Hazlewood\n * @since 0.1\n */\npublic abstract class AbstractSessionManager implements SessionManager, SessionListenerRegistrar {\n\n    protected transient final Log log = LogFactory.getLog(getClass());\n\n    protected Collection<SessionListener> listeners = new ArrayList<SessionListener>();\n\n    public AbstractSessionManager() {\n    }\n\n    public void setSessionListeners(Collection<SessionListener> listeners) {\n        if (listeners == null) {\n            this.listeners = new ArrayList<SessionListener>();\n        } else {\n            this.listeners = listeners;\n        }\n    }\n\n    public void add(SessionListener listener) {\n        this.listeners.add(listener);\n    }\n\n    public boolean remove(SessionListener listener) {\n        return this.listeners.remove(listener);\n    }\n\n    public Serializable start(InetAddress originatingHost) throws HostUnauthorizedException, IllegalArgumentException {\n        Session session = createSession(originatingHost);\n        notifyStart(session);\n        return session.getId();\n    }\n\n    /**\n     * Returns the session instance to use to pass to registered <code>SessionListener<\/code>s for notification\n     * that the session has been validated (stopped or expired).\n     * <p/>\n     * The default implementation returns an\n     * {@link org.jsecurity.session.mgt.ImmutableProxiedSession ImmutableProxiedSession} instance to ensure\n     * that the specified <code>session<\/code> argument is not modified by any listeners.\n     *\n     * @param session the <code>Session<\/code> object being invalidated.\n     * @return the <code>Session<\/code> instance to use to pass to registered <code>SessionListener<\/code>s for\n     *         notification.\n     */\n    protected Session beforeInvalidNotification(Session session) {\n        return new ImmutableProxiedSession(session);\n    }\n\n    protected void notifyStart(Session session) {\n        for (SessionListener listener : this.listeners) {\n            listener.onStart(session);\n        }\n    }\n\n    protected void notifyStop(Session session) {\n        Session forNotification = beforeInvalidNotification(session);\n        for (SessionListener listener : this.listeners) {\n            listener.onStop(forNotification);\n        }\n    }\n\n    protected void notifyExpiration(Session session) {\n        Session forNotification = beforeInvalidNotification(session);\n        for (SessionListener listener : this.listeners) {\n            listener.onExpiration(forNotification);\n        }\n    }\n\n    public Date getStartTimestamp(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public Date getStopTimestamp(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public Date getLastAccessTime(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public boolean isStopped(Serializable sessionId) {\n        Session session = getSession(sessionId);\n        return session.getStopTimestamp() != null || session.isExpired();\n    }\n\n    public boolean isExpired(Serializable sessionId) {\n        try {\n            Session session = getSession(sessionId);\n            return session.isExpired();\n        } catch (ExpiredSessionException e) {\n            return true;\n        }\n    }\n\n    public long getTimeout(Serializable sessionId) throws InvalidSessionException {\n        return getSession(sessionId).getTimeout();\n    }\n\n    public void setTimeout(Serializable sessionId, long maxIdleTimeInMillis) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        s.setTimeout(maxIdleTimeInMillis);\n        onChange(s);\n    }\n\n    public void touch(Serializable sessionId) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        s.touch();\n        onChange(s);\n    }\n\n    public InetAddress getHostAddress(Serializable sessionId) {\n        return getSession(sessionId).getHostAddress();\n    }\n\n    public void stop(Serializable sessionId) throws InvalidSessionException {\n        Session session = getSession(sessionId);\n        stop(session);\n    }\n\n    protected void stop(Session session) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Stopping session with id [\" + session.getId() + \"]\");\n        }\n        notifyStop(session);\n        session.stop();\n        onStop(session);\n    }\n\n    protected void onStop(Session session) {\n        onChange(session);\n    }\n\n    protected void expire(Session session) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Expiring session with id [\" + session.getId() + \"]\");\n        }\n        notifyExpiration(session);\n        session.stop();\n        onExpiration(session);\n    }\n\n    protected void onExpiration(Session session) {\n        onChange(session);\n    }\n\n    public Collection<Object> getAttributeKeys(Serializable sessionId) {\n        return getSession(sessionId).getAttributeKeys();\n    }\n\n    public Object getAttribute(Serializable sessionId, Object key) throws InvalidSessionException {\n        return getSession(sessionId).getAttribute(key);\n    }\n\n    public void setAttribute(Serializable sessionId, Object key, Object value) throws InvalidSessionException {\n        if (value == null) {\n            removeAttribute(sessionId, key);\n        } else {\n            Session s = getSession(sessionId);\n            s.setAttribute(key, value);\n            onChange(s);\n        }\n    }\n\n    public Object removeAttribute(Serializable sessionId, Object key) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        Object removed = s.removeAttribute(key);\n        if (removed != null) {\n            onChange(s);\n        }\n        return removed;\n    }\n\n    protected Session getSession(Serializable sessionId) throws InvalidSessionException {\n        Session session = doGetSession(sessionId);\n        if (session == null) {\n            String msg = \"There is no session with id [\" + sessionId + \"]\";\n            throw new UnknownSessionException(msg);\n        }\n        return session;\n    }\n\n    protected void onChange(Session s) {\n    }\n\n    protected abstract Session doGetSession(Serializable sessionId) throws InvalidSessionException;\n\n    protected abstract Session createSession(InetAddress originatingHost) throws HostUnauthorizedException, IllegalArgumentException;\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.*;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\n\n/**\n * @author Les Hazlewood\n * @since 0.1\n */\npublic abstract class AbstractSessionManager implements SessionManager, SessionListenerRegistrar {\n\n    protected transient final Log log = LogFactory.getLog(getClass());\n\n    protected Collection<SessionListener> listeners = new ArrayList<SessionListener>();\n\n    public AbstractSessionManager() {\n    }\n\n    public void setSessionListeners(Collection<SessionListener> listeners) {\n        if (listeners == null) {\n            this.listeners = new ArrayList<SessionListener>();\n        } else {\n            this.listeners = listeners;\n        }\n    }\n\n    public void add(SessionListener listener) {\n        this.listeners.add(listener);\n    }\n\n    public boolean remove(SessionListener listener) {\n        return this.listeners.remove(listener);\n    }\n\n    public Serializable start(InetAddress originatingHost) throws HostUnauthorizedException, IllegalArgumentException {\n        Session session = createSession(originatingHost);\n        notifyStart(session);\n        return session.getId();\n    }\n\n    protected void notifyStart(Session session) {\n        for (SessionListener listener : this.listeners) {\n            listener.onStart(session);\n        }\n    }\n\n    protected void notifyStop(Session session) {\n        for (SessionListener listener : this.listeners) {\n            listener.onStop(session);\n        }\n    }\n\n    protected void notifyExpiration(Session session) {\n        for (SessionListener listener : this.listeners) {\n            listener.onExpiration(session);\n        }\n    }\n\n    public Date getStartTimestamp(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public Date getStopTimestamp(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public Date getLastAccessTime(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public boolean isStopped(Serializable sessionId) {\n        Session session = getSession(sessionId);\n        return session.getStopTimestamp() != null || session.isExpired();\n    }\n\n    public boolean isExpired(Serializable sessionId) {\n        try {\n            Session session = getSession(sessionId);\n            return session.isExpired();\n        } catch (ExpiredSessionException e) {\n            return true;\n        }\n    }\n\n    public long getTimeout(Serializable sessionId) throws InvalidSessionException {\n        return getSession(sessionId).getTimeout();\n    }\n\n    public void setTimeout(Serializable sessionId, long maxIdleTimeInMillis) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        s.setTimeout(maxIdleTimeInMillis);\n        onChange(s);\n    }\n\n    public void touch(Serializable sessionId) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        s.touch();\n        onChange(s);\n    }\n\n    public InetAddress getHostAddress(Serializable sessionId) {\n        return getSession(sessionId).getHostAddress();\n    }\n\n    public void stop(Serializable sessionId) throws InvalidSessionException {\n        Session session = getSession(sessionId);\n        stop(session);\n    }\n\n    protected void stop(Session session) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Stopping session with id [\" + session.getId() + \"]\");\n        }\n        notifyStop(session);\n        session.stop();\n        onStop(session);\n    }\n\n    protected void onStop(Session session) {\n        onChange(session);\n    }\n\n    protected void expire(Session session) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Expiring session with id [\" + session.getId() + \"]\");\n        }\n        notifyExpiration(session);\n        session.stop();\n        onExpiration(session);\n    }\n\n    protected void onExpiration(Session session) {\n        onChange(session);\n    }\n\n    public Collection<Object> getAttributeKeys(Serializable sessionId) {\n        return getSession(sessionId).getAttributeKeys();\n    }\n\n    public Object getAttribute(Serializable sessionId, Object key) throws InvalidSessionException {\n        return getSession(sessionId).getAttribute(key);\n    }\n\n    public void setAttribute(Serializable sessionId, Object key, Object value) throws InvalidSessionException {\n        if (value == null) {\n            removeAttribute(sessionId, key);\n        } else {\n            Session s = getSession(sessionId);\n            s.setAttribute(key, value);\n            onChange(s);\n        }\n    }\n\n    public Object removeAttribute(Serializable sessionId, Object key) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        Object removed = s.removeAttribute(key);\n        if (removed != null) {\n            onChange(s);\n        }\n        return removed;\n    }\n\n    protected Session getSession(Serializable sessionId) throws InvalidSessionException {\n        Session session = doGetSession(sessionId);\n        if (session == null) {\n            String msg = \"There is no session with id [\" + sessionId + \"]\";\n            throw new UnknownSessionException(msg);\n        }\n        return session;\n    }\n\n    protected void onChange(Session s) {\n    }\n\n    protected abstract Session doGetSession(Serializable sessionId) throws InvalidSessionException;\n\n    protected abstract Session createSession(InetAddress originatingHost) throws HostUnauthorizedException, IllegalArgumentException;\n}\n","lineNo":97}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.filter;\n\nimport org.jsecurity.web.WebUtils;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.IOException;\n\n/**\n * Superclass for any filter that controls access to a resource and may redirect the user to the login page\n * if they are not authenticated.  This superclass provides the method\n * {@link #saveRequestAndRedirectToLogin(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}\n * which is used by many subclasses as the behavior when a user is unauthenticated.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AccessControlFilter extends PathMatchingFilter {\n\n    // Key used when storing a SavedRequest in the session\n    /**\n     * Simple default login URL equal to <code>/login.jsp<\/code>, which will probably be overridden in most\n     * applications.\n     */\n    public static final String DEFAULT_LOGIN_URL = \"/login.jsp\";\n    protected static final String GET_METHOD = \"get\";\n\n    /**\n     * The login url to used to authenticate a user, used when redirecting users if authentication is required.\n     */\n    private String loginUrl = DEFAULT_LOGIN_URL;\n\n    /**\n     * Returns the login URL used to authenticate a user.\n     * <p/>\n     * Most JSecurity filters use this url\n     * as the location to redirect a user when the filter requires authentication.  Unless overridden, the\n     * {@link #DEFAULT_LOGIN_URL DEFAULT_LOGIN_URL} is assumed, which can be overridden via\n     * {@link #setLoginUrl(String) setLoginUrl}.\n     *\n     * @return the login URL used to authenticate a user, used when redirecting users if authentication is required.\n     */\n    protected String getLoginUrl() {\n        return loginUrl;\n    }\n\n    /**\n     * Sets the login URL used to authenticate a user.\n     * <p/>\n     * Most JSecurity filters use this url as the location to redirect a user when the filter requires\n     * authentication.  Unless overridden, the {@link #DEFAULT_LOGIN_URL DEFAULT_LOGIN_URL} is assumed.\n     *\n     * @param loginUrl the login URL used to authenticate a user, used when redirecting users if authentication is required.\n     */\n    public void setLoginUrl(String loginUrl) {\n        this.loginUrl = loginUrl;\n    }\n\n    /**\n     * Returns <code>true<\/code> if the request is allowed to proceed through the filter normally, or <code>false<\/code>\n     * if the request should be handled by the\n     * {@link #onAccessDenied(javax.servlet.ServletRequest, javax.servlet.ServletResponse) onAccessDenied(request,response)}\n     * method instead.\n     *\n     * @param request     the incoming <code>ServletRequest<\/code>\n     * @param response    the outgoing <code>ServletResponse<\/code>\n     * @param mappedValue the filter-specific config value mapped to this filter in the URL rules mappings.\n     * @return <code>true<\/code> if the request should proceed through the filter normally, <code>false<\/code> if the\n     *         request should be processed by this filter's\n     *         {@link #onAccessDenied(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} method instead.\n     * @throws Exception if an error occurs during processing.\n     */\n    protected abstract boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;\n\n    /**\n     * Processes requests where the subject was denied access as determined by the\n     * {@link #isAccessAllowed(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Object) isAccessAllowed}\n     * method.\n     *\n     * @param request  the incoming <code>ServletRequest<\/code>\n     * @param response the outgoing <code>ServletResponse<\/code>\n     * @return <code>true<\/code> if the request should continue to be processed; false if the subclass will\n     *         handle/render the response directly.\n     * @throws Exception if there is an error processing the request.\n     */\n    protected abstract boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception;\n\n    /**\n     * Returns <code>true<\/code> if\n     * {@link #isAccessAllowed(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Object) isAccessAllowed},\n     * otherwise returns the result of\n     * {@link #onAccessDenied(javax.servlet.ServletRequest, javax.servlet.ServletResponse) onAccessDenied}.\n     *\n     * @param request     the incoming <code>ServletRequest<\/code>\n     * @param response    the outgoing <code>ServletResponse<\/code>\n     * @param mappedValue the filter-specific config value mapped to this filter in the URL rules mappings.\n     * @return <code>true<\/code> if\n     *         {@link #isAccessAllowed(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Object) isAccessAllowed},\n     *         otherwise returns the result of\n     *         {@link #onAccessDenied(javax.servlet.ServletRequest, javax.servlet.ServletResponse) onAccessDenied}.\n     * @throws Exception if an error occurs.\n     */\n    public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {\n        //mapped value is ignored - not needed for most (if not all) authc Filters.\n        if (isAccessAllowed(request, response, mappedValue)) {\n            return true;\n        } else {\n            return onAccessDenied(request, response);\n        }\n    }\n\n    /**\n     * Returns <code>true<\/code> if the incoming request is a login request, <code>false<\/code> otherwise.\n     * <p/>\n     * The default implementation merely returns <code>true<\/code> if the incoming request matches the configured\n     * {@link #getLoginUrl() loginUrl} by calling\n     * <code>{@link #pathsMatch(String, String) pathsMatch(loginUrl, request)}<\/code>.\n     *\n     * @param request  the incoming <code>ServletRequest<\/code>\n     * @param response the outgoing <code>ServletResponse<\/code>\n     * @return <code>true<\/code> if the incoming request is a login request, <code>false<\/code> otherwise.\n     */\n    protected boolean isLoginRequest(ServletRequest request, ServletResponse response) {\n        return pathsMatch(getLoginUrl(), request);\n    }\n\n    /**\n     * Convenience method for subclasses to use when a login redirect is required.\n     * <p/>\n     * This implementation simply calls {@link #saveRequest(javax.servlet.ServletRequest) saveRequest(request)}\n     * and then {@link #redirectToLogin(javax.servlet.ServletRequest, javax.servlet.ServletResponse) redirectToLogin(request,response)}.\n     *\n     * @param request  the incoming <code>ServletRequest<\/code>\n     * @param response the outgoing <code>ServletResponse<\/code>\n     * @throws IOException if an error occurs.\n     */\n    protected void saveRequestAndRedirectToLogin(ServletRequest request, ServletResponse response) throws IOException {\n        saveRequest(request);\n        redirectToLogin(request, response);\n    }\n\n    /**\n     * Convenience method merely delegates to\n     * {@link WebUtils#saveRequest(javax.servlet.ServletRequest) WebUtils.saveRequest(request)} to save the request\n     * state for reuse later.  This is mostly used to retain user request state when a redirect is issued to\n     * return the user to their originally requested url/resource.\n     * <p/>\n     * If you need to save and then immediately redirect the user to login, consider using\n     * {@link #saveRequestAndRedirectToLogin(javax.servlet.ServletRequest, javax.servlet.ServletResponse)\n     * saveRequestAndRedirectToLogin(request,response)} directly.\n     *\n     * @param request the incoming ServletRequest to save for re-use later (for example, after a redirect).\n     */\n    protected void saveRequest(ServletRequest request) {\n        WebUtils.saveRequest(request);\n    }\n\n    /**\n     * Convenience method for subclasses that merely acquires the {@link #getLoginUrl() getLoginUrl} and redirects\n     * the request to that url.\n     * <p/>\n     * <b>N.B.<\/b>  If you want to issue a redirect with the intention of allowing the user to then return to their\n     * originally requested URL, don't use this method directly.  Instead you should call\n     * {@link #saveRequestAndRedirectToLogin(javax.servlet.ServletRequest, javax.servlet.ServletResponse)\n     * saveRequestAndRedirectToLogin(request,response)}, which will save the current request state so that it can\n     * be reconstructed and re-used after a successful login.\n     *\n     * @param request  the incoming <code>ServletRequest<\/code>\n     * @param response the outgoing <code>ServletResponse<\/code>\n     * @throws IOException if an error occurs.\n     */\n    protected void redirectToLogin(ServletRequest request, ServletResponse response) throws IOException {\n        String loginUrl = getLoginUrl();\n        WebUtils.issueRedirect(request, response, loginUrl);\n    }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.filter;\n\nimport org.jsecurity.web.WebUtils;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.IOException;\n\n/**\n * Superclass for any filter that controls access to a resource and may redirect the user to the login page\n * if they are not authenticated.  This superclass provides the method {@link #saveRequestAndRedirectToLogin(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}\n * which is used by many subclasses as the behavior when a user is unauthenticated.\n *\n * @author Jeremy Haile\n * @since 0.9\n */\npublic abstract class AccessControlFilter extends PathMatchingFilter {\n\n    // Key used when storing a SavedRequest in the session\n    public static final String DEFAULT_LOGIN_URL = \"/login.jsp\";\n    protected static final String GET_METHOD = \"get\";\n\n    private String loginUrl = DEFAULT_LOGIN_URL;\n\n    protected String getLoginUrl() {\n        return loginUrl;\n    }\n\n    /**\n     * Sets the login URL used used to authenticate a user.  Most JSecurity filters will use this url\n     * as the location to redirect a user when the filter requires authentication.\n     *\n     * @param loginUrl the login URL.\n     */\n    public void setLoginUrl(String loginUrl) {\n        this.loginUrl = loginUrl;\n    }\n\n    /**\n     * Template method subclasses must implement.  This method determines whether or not the request is allowed to\n     * proceed normally, or whether the request should be handled by the logic in\n     * {@link #onAccessDenied(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}.\n     *\n     * @param request     the request.\n     * @param response    the response.\n     * @param mappedValue the value mapped to this filter in the URL rules.\n     * @return true if the reques should proceed normally, false if the request should be proceessed by this filter's\n     *         {@link #onAccessDenied(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} method.\n     * @throws IOException if an error occurs during processing.\n     */\n    protected abstract boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;\n\n    /**\n     * Template method sub-classes must implement. This method processes requests where the subject was denied access\n     * by the {@link #isAccessAllowed(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Object) isAccessAllowed}\n     * method.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @return true if the request should continue to be processed; false if the subclass will handle/render\n     *         the response directly.\n     * @throws Exception if there is an error processing the request.\n     */\n    protected abstract boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception;\n\n    public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {\n        //mapped value is ignored - not needed for most (if not all) authc Filters.\n        if (isAccessAllowed(request, response, mappedValue)) {\n            return true;\n        } else {\n            return onAccessDenied(request, response);\n        }\n    }\n\n    protected boolean isLoginRequest(ServletRequest servletRequest, ServletResponse response) {\n        return pathsMatch(getLoginUrl(), servletRequest);\n    }\n\n    protected void saveRequestAndRedirectToLogin(ServletRequest request, ServletResponse response) throws IOException {\n        WebUtils.saveRequest(request);\n        WebUtils.issueRedirect(request, response, getLoginUrl());\n    }\n\n}\n","lineNo":192}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.cache.CacheManagerAware;\nimport org.jsecurity.session.*;\nimport org.jsecurity.session.mgt.DefaultSessionManager;\nimport org.jsecurity.session.mgt.DelegatingSession;\nimport org.jsecurity.session.mgt.SessionManager;\nimport org.jsecurity.util.LifecycleUtils;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\n\n/**\n * JSecurity support of a {@link SecurityManager} class hierarchy that delegates all\n * {@link org.jsecurity.session.Session session} operations to a wrapped {@link SessionManager SessionManager}\n * instance.  That is, this class implements the methods in the\n * {@link SessionManager SessionManager} interface, but in reality, those methods are merely passthrough calls to\n * the underlying 'real' <tt>SessionManager<\/tt> instance.\n *\n * <p>The remaining <tt>SecurityManager<\/tt> methods not implemented by this class or its parents are left to be\n * implemented by subclasses.\n *\n * <p>In keeping with the other classes in this hierarchy and JSecurity's desire to minimize configuration whenever\n * possible, suitable default instances for all dependencies will be created upon instantiation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class SessionsSecurityManager extends AuthorizingSecurityManager implements SessionListenerRegistrar {\n\n    protected SessionManager sessionManager = createSessionManager();\n\n    /**\n     * Default no-arg constructor.\n     */\n    public SessionsSecurityManager() {\n    }\n\n    /**\n     * Sets the underlying delegate {@link SessionManager} instance that will be used to support this implementation's\n     * <tt>SessionManager<\/tt> method calls.\n     *\n     * <p>This <tt>SecurityManager<\/tt> implementation does not provide logic to support the inherited\n     * <tt>SessionManager<\/tt> interface, but instead delegates these calls to an internal\n     * <tt>SessionManager<\/tt> instance.\n     *\n     * <p>If a <tt>SessionManager<\/tt> instance is not set, a default one will be automatically created and\n     * initialized appropriately for the the existing runtime environment.\n     *\n     * @param sessionManager delegate instance to use to support this manager's <tt>SessionManager<\/tt> method calls.\n     */\n    public void setSessionManager(SessionManager sessionManager) {\n        this.sessionManager = sessionManager;\n    }\n\n    public SessionManager getSessionManager() {\n        return this.sessionManager;\n    }\n\n    protected SessionManager createSessionManager() {\n        SessionManager sm = newSessionManagerInstance();\n        CacheManager cm = getCacheManager();\n        if (cm != null) {\n            if (sm instanceof CacheManagerAware) {\n                ((CacheManagerAware) sm).setCacheManager(cm);\n            }\n        }\n        return sm;\n    }\n\n    protected SessionManager newSessionManagerInstance() {\n        return new DefaultSessionManager();\n    }\n\n    protected void afterCacheManagerSet() {\n        super.afterCacheManagerSet();\n        applyCacheManagerToSessionManager();\n    }\n\n    protected void applyCacheManagerToSessionManager() {\n        SessionManager sm = getSessionManager();\n        if (sm instanceof CacheManagerAware) {\n            ((CacheManagerAware) sm).setCacheManager(cacheManager);\n        }\n    }\n\n    /**\n     * This is a convenience method that allows registration of SessionEventListeners with the underlying delegate\n     * SessionManager at startup.\n     *\n     * <p>This is more convenient than having to configure your own SessionManager instance, inject the listeners on\n     * it, and then set that SessionManager instance as an attribute of this class.  Instead, you can just rely\n     * on the <tt>SecurityManager<\/tt> to apply these <tt>SessionEventListener<\/tt>s on your behalf.\n     *\n     * <p>One notice however: The underlying SessionManager delegate must implement the\n     * {@link SessionListenerRegistrar SessionListenerRegistrar} interface in order for these listeners to\n     * be applied.  If it does not implement this interface, it is considered a configuration error and an exception\n     * will be thrown.\n     *\n     * @param sessionEventListeners the <tt>SessionEventListener<\/tt>s to register with the underlying delegate\n     *                              <tt>SessionManager<\/tt> at startup.\n     */\n    public void setSessionListeners(Collection<SessionListener> sessionEventListeners) {\n        assertSessionListenerSupport();\n        ((SessionListenerRegistrar) this.sessionManager).setSessionListeners(sessionEventListeners);\n    }\n\n    private void assertSessionListenerSupport() {\n        if (!(this.sessionManager instanceof SessionListenerRegistrar)) {\n            String msg = \"SessionListener registration failed:  The underlying SessionManager instance of \" +\n                    \"type [\" + sessionManager.getClass().getName() + \"] does not implement the \" +\n                    SessionListenerRegistrar.class.getName() + \" interface and therefore cannot support \" +\n                    \"session notifications.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    public void add(SessionListener listener) {\n        assertSessionListenerSupport();\n        SessionManager sm = getSessionManager();\n        ((SessionListenerRegistrar) sm).add(listener);\n    }\n\n    public boolean remove(SessionListener listener) {\n        SessionManager sm = getSessionManager();\n        return (sm instanceof SessionListenerRegistrar) &&\n                ((SessionListenerRegistrar) sm).remove(listener);\n    }\n\n    protected void beforeSessionManagerDestroyed() {\n    }\n\n    protected void destroySessionManager() {\n        LifecycleUtils.destroy(getSessionManager());\n    }\n\n    protected void beforeAuthorizerDestroyed() {\n        beforeSessionManagerDestroyed();\n        destroySessionManager();\n    }\n\n    public Session start(InetAddress hostAddress) throws HostUnauthorizedException, IllegalArgumentException {\n        SessionManager sm = getSessionManager();\n        Serializable sessionId = sm.start(hostAddress);\n        return new DelegatingSession(sm, sessionId);\n    }\n\n    public Session getSession(Serializable sessionId) throws InvalidSessionException, AuthorizationException {\n        SessionManager sm = getSessionManager();\n        if (sm.isExpired(sessionId)) {\n            String msg = \"Session with id [\" + sessionId + \"] has expired and may not be used.\";\n            throw new ExpiredSessionException(msg);\n        } else if (sm.isStopped(sessionId)) {\n            String msg = \"Session with id [\" + sessionId + \"] has been stopped and may not be used.\";\n            throw new StoppedSessionException(msg);\n        }\n\n        return new DelegatingSession(sm, sessionId);\n    }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.session.ExpiredSessionException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.StoppedSessionException;\nimport org.jsecurity.session.event.SessionEventListener;\nimport org.jsecurity.session.event.mgt.SessionEventListenerRegistrar;\nimport org.jsecurity.session.mgt.DefaultSessionManager;\nimport org.jsecurity.session.mgt.DelegatingSession;\nimport org.jsecurity.session.mgt.SessionManager;\nimport org.jsecurity.util.LifecycleUtils;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\n\n/**\n * JSecurity support of a {@link SecurityManager} class hierarchy that delegates all\n * {@link org.jsecurity.session.Session session} operations to a wrapped {@link SessionManager SessionManager}\n * instance.  That is, this class implements the methods in the\n * {@link SessionManager SessionManager} interface, but in reality, those methods are merely passthrough calls to\n * the underlying 'real' <tt>SessionManager<\/tt> instance.\n *\n * <p>The remaining <tt>SecurityManager<\/tt> methods not implemented by this class or its parents are left to be\n * implemented by subclasses.\n *\n * <p>In keeping with the other classes in this hierarchy and JSecurity's desire to minimize configuration whenever\n * possible, suitable default instances for all dependencies will be created upon {@link #init() initialization} if\n * they have not been provided.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class SessionsSecurityManager extends AuthorizingSecurityManager implements SessionEventListenerRegistrar {\n\n    protected SessionManager sessionManager;\n    protected Collection<SessionEventListener> sessionEventListeners = null;\n\n    /**\n     * Default no-arg constructor - used in IoC environments or when the programmer wishes to explicitly call\n     * {@link #init()} after the necessary properties have been set.\n     */\n    public SessionsSecurityManager() {\n    }\n\n    /**\n     * Supporting constructor for a single-realm application (automatically calls {@link #init()} before returning).\n     *\n     * @param singleRealm the single realm used by this SecurityManager.\n     */\n    public SessionsSecurityManager(Realm singleRealm) {\n        super(singleRealm);\n    }\n\n    /**\n     * Supporting constructor that sets the {@link #setRealms realms} property and then automatically calls {@link #init()}.\n     *\n     * @param realms the realm instances backing this SecurityManager.\n     */\n    public SessionsSecurityManager(Collection<Realm> realms) {\n        super(realms);\n    }\n\n    /**\n     * Sets the underlying delegate {@link SessionManager} instance that will be used to support this implementation's\n     * <tt>SessionManager<\/tt> method calls.\n     *\n     * <p>This <tt>SecurityManager<\/tt> implementation does not provide logic to support the inherited\n     * <tt>SessionManager<\/tt> interface, but instead delegates these calls to an internal\n     * <tt>SessionManager<\/tt> instance.\n     *\n     * <p>If a <tt>SessionManager<\/tt> instance is not set, a default one will be automatically created and\n     * initialized appropriately for the the existing runtime environment.\n     *\n     * @param sessionManager delegate instance to use to support this manager's <tt>SessionManager<\/tt> method calls.\n     */\n    public void setSessionManager(SessionManager sessionManager) {\n        this.sessionManager = sessionManager;\n    }\n\n    public SessionManager getSessionManager() {\n        return this.sessionManager;\n    }\n\n    protected SessionManager createSessionManager() {\n        DefaultSessionManager sessionManager = new DefaultSessionManager();\n        if (getCacheManager() != null) {\n            sessionManager.setCacheManager(getCacheManager());\n        }\n        if (getSessionEventListeners() != null) {\n            sessionManager.setSessionEventListeners(getSessionEventListeners());\n        }\n        sessionManager.init();\n        return sessionManager;\n    }\n\n    protected void ensureSessionManager() {\n        if (getSessionManager() == null) {\n            if (log.isInfoEnabled()) {\n                log.info(\"No delegate SessionManager instance has been set as a property of this class.  Creating a \" +\n                        \"default SessionManager instance...\");\n            }\n            SessionManager sessionManager = createSessionManager();\n            setSessionManager(sessionManager);\n        }\n    }\n\n    protected SessionManager getRequiredSessionManager() {\n        if (getSessionManager() == null) {\n            ensureSessionManager();\n        }\n        return getSessionManager();\n    }\n\n    public Collection<SessionEventListener> getSessionEventListeners() {\n        return sessionEventListeners;\n    }\n\n    /**\n     * This is a convenience method that allows registration of SessionEventListeners with the underlying delegate\n     * SessionManager at startup.\n     *\n     * <p>This is more convenient than having to configure your own SessionManager instance, inject the listeners on\n     * it, and then set that SessionManager instance as an attribute of this class.  Instead, you can just rely\n     * on the <tt>SecurityManager<\/tt>'s default initialization logic to create the SessionManager instance for you\n     * and then apply these <tt>SessionEventListener<\/tt>s on your behalf.\n     *\n     * <p>One notice however: The underlying SessionManager delegate must implement the\n     * {@link SessionEventListenerRegistrar SessionEventListenerRegistrar} interface in order for these listeners to\n     * be applied.  If it does not implement this interface, it is considered a configuration error and an exception\n     * will be thrown during {@link #init() initialization}.\n     *\n     * @param sessionEventListeners the <tt>SessionEventListener<\/tt>s to register with the underlying delegate\n     *                              <tt>SessionManager<\/tt> at startup.\n     */\n    public void setSessionEventListeners(Collection<SessionEventListener> sessionEventListeners) {\n        this.sessionEventListeners = sessionEventListeners;\n    }\n\n    private void assertSessionEventListenerSupport(SessionManager sessionManager) {\n        if (!(sessionManager instanceof SessionEventListenerRegistrar)) {\n            String msg = \"SessionEventListener registration failed:  The underlying SessionManager instance of \" +\n                    \"type [\" + sessionManager.getClass().getName() + \"] does not implement the \" +\n                    SessionEventListenerRegistrar.class.getName() + \" interface and therefore cannot support \" +\n                    \"runtime SessionEvent propagation.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    public void add(SessionEventListener listener) {\n        ensureSessionManager();\n        SessionManager sm = getSessionManager();\n        assertSessionEventListenerSupport(sm);\n        ((SessionEventListenerRegistrar) sm).add(listener);\n    }\n\n    public boolean remove(SessionEventListener listener) {\n        SessionManager sm = getSessionManager();\n        return (sm instanceof SessionEventListenerRegistrar) &&\n                ((SessionEventListenerRegistrar) sm).remove(listener);\n    }\n\n    protected void afterAuthorizerSet() {\n        ensureSessionManager();\n        afterSessionManagerSet();\n    }\n\n    protected void afterSessionManagerSet() {\n    }\n\n    protected void beforeSessionManagerDestroyed() {\n    }\n\n    protected void destroySessionManager() {\n        LifecycleUtils.destroy(getSessionManager());\n        this.sessionManager = null;\n        this.sessionEventListeners = null;\n    }\n\n    protected void beforeAuthorizerDestroyed() {\n        beforeSessionManagerDestroyed();\n        destroySessionManager();\n    }\n\n    public Session start(InetAddress hostAddress) throws HostUnauthorizedException, IllegalArgumentException {\n        Serializable sessionId = getRequiredSessionManager().start(hostAddress);\n        return new DelegatingSession(sessionManager, sessionId);\n    }\n\n    public Session getSession(Serializable sessionId) throws InvalidSessionException, AuthorizationException {\n        SessionManager sm = getRequiredSessionManager();\n        if (sm.isExpired(sessionId)) {\n            String msg = \"Session with id [\" + sessionId + \"] has expired and may not be used.\";\n            throw new ExpiredSessionException(msg);\n        } else if (sm.isStopped(sessionId)) {\n            String msg = \"Session with id [\" + sessionId + \"] has been stopped and may not be used.\";\n            throw new StoppedSessionException(msg);\n        }\n\n        return new DelegatingSession(sm, sessionId);\n    }\n\n}\n","lineNo":84}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt.eis;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.cache.CacheManagerAware;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.UnknownSessionException;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * An CachingSessionDAO is a SessionDAO that provides a transparent caching layer between the components that\n * use it and the underlying EIS (Enterprise Information System) for enhanced performance.\n *\n * <p>This implementation caches all active sessions in a cache created by a\n * {@link org.jsecurity.cache.CacheManager}.  All <tt>SessionDAO<\/tt> methods are implemented by this class to employ\n * caching behavior and delegates the actual EIS operations to respective do* methods to be implemented by\n * subclasses (doCreate, doRead, etc).\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic abstract class CachingSessionDAO implements SessionDAO, CacheManagerAware {\n\n    public static final String ACTIVE_SESSION_CACHE_NAME = \"jsecurity-activeSessionCache\";\n\n    protected transient final Log log = LogFactory.getLog(getClass());\n\n    private CacheManager cacheManager;\n    private Cache activeSessions;\n    private String activeSessionsCacheName = ACTIVE_SESSION_CACHE_NAME;\n\n    /**\n     * JavaBeans compatible constructor.\n     */\n    public CachingSessionDAO() {\n    }\n\n    /**\n     * Sets the cacheManager to use for constructing the session cache.\n     *\n     * @param cacheManager the manager to use for constructing the session cache.\n     */\n    public void setCacheManager(CacheManager cacheManager) {\n        this.cacheManager = cacheManager;\n        //force cache reload:\n        this.activeSessions = null;\n        getActiveSessionsCacheLazy();\n    }\n\n    /**\n     * Returns the CacheManager used by the implementation that creates the activeSessions Cache.\n     *\n     * @return the CacheManager used by the implementation that creates the activeSessions Cache.\n     */\n    public CacheManager getCacheManager() {\n        return cacheManager;\n    }\n\n    public String getActiveSessionsCacheName() {\n        return activeSessionsCacheName;\n    }\n\n    public void setActiveSessionsCacheName(String activeSessionsCacheName) {\n        this.activeSessionsCacheName = activeSessionsCacheName;\n    }\n\n    public Cache getActiveSessionsCache() {\n        return this.activeSessions;\n    }\n\n    protected Cache getActiveSessionsCacheLazy() {\n        if (this.activeSessions == null) {\n            this.activeSessions = createActiveSessionsCache();\n        }\n        return this.activeSessions;\n    }\n\n    public void setActiveSessionsCache(Cache cache) {\n        this.activeSessions = cache;\n    }\n\n    protected Cache createActiveSessionsCache() {\n        Cache cache = null;\n        CacheManager mgr = getCacheManager();\n        if (mgr != null) {\n            String name = getActiveSessionsCacheName();\n            cache = mgr.getCache(name);\n        }\n        return cache;\n    }\n\n    /**\n     * Creates the session by delegating EIS creation to subclasses via the {@link #doCreate} method, and then\n     * caches the session.\n     *\n     * @param session Session object to create in the EIS and then cache.\n     */\n    public Serializable create(Session session) {\n        Serializable sessionId = doCreate(session);\n        verifySessionId(sessionId);\n        Cache cache = getActiveSessionsCacheLazy();\n        if (cache != null) {\n            cache.put(sessionId, session);\n        }\n        return sessionId;\n    }\n\n    /**\n     * Ensures the sessionId returned from the subclass implementation of {@link #doCreate} is not null and not\n     * already in use.\n     *\n     * @param sessionId session id returned from the subclass implementation of {@link #doCreate}\n     */\n    protected void verifySessionId(Serializable sessionId) {\n        if (sessionId == null) {\n            String msg = \"sessionId returned from doCreate implementation is null.  Please verify the implementation.\";\n            throw new IllegalStateException(msg);\n        }\n        ensureUncached(sessionId);\n    }\n\n    /**\n     * Ensures that there is no cache entry already in place for a session with id of <tt>sessionId<\/tt>.  Used by\n     * the {@link #verifySessionId} implementation.\n     *\n     * @param sessionId the session id to check for non-existence in the cache.\n     */\n    protected void ensureUncached(Serializable sessionId) {\n        Cache cache = getActiveSessionsCacheLazy();\n        if (cache != null && cache.get(sessionId) != null) {\n            String msg = \"There is an existing session already created with session id [\" +\n                    sessionId + \"].  Session ID's must be unique.\";\n            throw new IllegalArgumentException(msg);\n        }\n    }\n\n    /**\n     * Subclass hook to actually persist the given <tt>Session<\/tt> instance to the underlying EIS.\n     *\n     * @param session the Session instance to persist to the EIS.\n     * @return the id of the session created in the EIS (i.e. this is almost always a primary key and should be the\n     *         value returned from {@link org.jsecurity.session.Session#getId() Session.getId()}.\n     */\n    protected abstract Serializable doCreate(Session session);\n\n    /**\n     * Retrieves the Session object from the underlying EIS identified by <tt>sessionId<\/tt>.\n     *\n     * <p>Upon receiving the Session object from the subclass's {@link #doReadSession} implementation, it will be\n     * cached first and then returned to the caller.\n     *\n     * @param sessionId the id of the session to retrieve from the EIS.\n     * @return the session identified by <tt>sessionId<\/tt> in the EIS.\n     * @throws UnknownSessionException if the id specified does not correspond to any session in the cache or EIS.\n     */\n    public Session readSession(Serializable sessionId) throws UnknownSessionException {\n        Session s = null;\n\n        Cache cache = getActiveSessionsCacheLazy();\n        if (cache != null) {\n            s = (Session) cache.get(sessionId);\n        }\n\n        if (s == null) {\n            s = doReadSession(sessionId);\n            if (cache != null && s != null && !s.isExpired() && s.getStopTimestamp() == null) {\n                cache.put(sessionId, s);\n            }\n        }\n\n        if (s == null) {\n            throw new UnknownSessionException(\"There is no session with id [\" + sessionId + \"]\");\n        }\n        return s;\n    }\n\n    /**\n     * Subclass implmentation hook to actually retrieve the Session object from the underlying EIS.\n     *\n     * @param sessionId the id of the <tt>Session<\/tt> to retrieve.\n     * @return the Session in the EIS identified by <tt>sessionId<\/tt>\n     */\n    protected abstract Session doReadSession(Serializable sessionId);\n\n    /**\n     * Updates the state of the given session to the EIS.\n     *\n     * <p>If the specified session was previously cached, and the session is now\n     * {@link org.jsecurity.session.Session#getStopTimestamp() stopped} or\n     * {@link org.jsecurity.session.Session#isExpired() expired}, it will be removed from the cache.\n     *\n     * <p>If the specified session is not stopped or expired, and was not yet in the cache, it will be added to the\n     * cache.\n     *\n     * <p>Finally, this method calls {@link #doUpdate} for the subclass to actually push the object state to the EIS.\n     *\n     * @param session the session object to update in the EIS.\n     * @throws UnknownSessionException if no existing EIS session record exists with the\n     *                                 identifier of {@link Session#getId() session.getId()}\n     */\n    public void update(Session session) throws UnknownSessionException {\n\n        doUpdate(session);\n\n        Cache cache = getActiveSessionsCacheLazy();\n        Serializable id = session.getId();\n\n        if (session.getStopTimestamp() != null || session.isExpired()) {\n            if (cache != null) {\n                cache.remove(id);\n            }\n        } else {\n            if (cache != null) {\n                cache.put(id, session);\n            }\n        }\n    }\n\n    /**\n     * Subclass implementation hook to actually persist the <tt>Session<\/tt>'s state to the underlying EIS.\n     *\n     * @param session the session object whose state will be propagated to the EIS.\n     */\n    protected abstract void doUpdate(Session session);\n\n    /**\n     * Removes the specified session from any cache and then permanently deletes the session from the EIS by\n     * delegating to {@link #doDelete}.\n     *\n     * @param session the session to remove from caches and permanently delete from the EIS.\n     */\n    public void delete(Session session) {\n        Serializable id = session.getId();\n        doDelete(session);\n        Cache cache = getActiveSessionsCacheLazy();\n        if (cache != null) {\n            cache.remove(id);\n        }\n    }\n\n    /**\n     * Subclass implementation hook to permanently delete the given Session from the underlying EIS.\n     *\n     * @param session the session instance to permanently delete from the EIS.\n     */\n    protected abstract void doDelete(Session session);\n\n    /**\n     * Returns all active sessions in the system.\n     *\n     * <p>This implementation merely returns the sessions found in the activeSessions cache.  Subclass implementations\n     * may wish to override this method to retrieve them in a different way, perhaps by an RDBMS query or by other\n     * means.\n     *\n     * @return the sessions found in the activeSessions cache.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public Collection<Session> getActiveSessions() {\n        Cache cache = getActiveSessionsCacheLazy();\n        if (cache != null) {\n            return cache.values();\n        } else {\n            return Collections.EMPTY_LIST;\n        }\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt.eis;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.cache.CacheManagerAware;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.UnknownSessionException;\nimport org.jsecurity.util.Initializable;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * An CachingSessionDAO is a SessionDAO that provides a transparent caching layer between the components that\n * use it and the underlying EIS (Enterprise Information System) for enhanced performance.\n *\n * <p>This implementation caches all active sessions in a cache created by a required\n * {@link org.jsecurity.cache.CacheManager}.  All <tt>SessionDAO<\/tt> methods are implemented by this class to employ\n * caching behavior and delegates the actual EIS operations to respective do* methods to be implemented by\n * subclasses (doCreate, doRead, etc).\n *\n * <p>After instantiating an instance of this class (or subclass) and setting the <tt>CacheManager<\/tt> property,\n * the {@link #init} method must be called to properly initialize the cache.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic abstract class CachingSessionDAO implements SessionDAO, CacheManagerAware, Initializable {\n\n    public static final String ACTIVE_SESSION_CACHE_NAME = \"jsecurity-activeSessionCache\";\n\n    protected transient final Log log = LogFactory.getLog(getClass());\n\n    private CacheManager cacheManager = null;\n    private Cache activeSessions = null;\n    private String activeSessionsCacheName = ACTIVE_SESSION_CACHE_NAME;\n\n    /**\n     * JavaBeans compatible constructor.  The {@link #setCacheManager CacheManager} property must be set and the\n     * {@link #init} method called before the instance can be used.\n     */\n    public CachingSessionDAO() {\n    }\n\n    /**\n     * Constructor taking in the required <tt>CacheManager<\/tt> property.  This constructor will call init()\n     * automatically, thereby making the instance ready for use immediately after instantiation.\n     *\n     * @param manager the required <tt>CacheManager<\/tt> property necessary for cache initialization.\n     */\n    public CachingSessionDAO(CacheManager manager) {\n        setCacheManager(manager);\n        init();\n    }\n\n    /**\n     * Sets the cacheManager to use for constructing the session cache.\n     *\n     * @param cacheManager the manager to use for constructing the session cache.\n     */\n    public void setCacheManager(CacheManager cacheManager) {\n        this.cacheManager = cacheManager;\n    }\n\n    /**\n     * Returns the CacheManager used by the implementation that creates the activeSessions Cache.\n     *\n     * @return the CacheManager used by the implementation that creates the activeSessions Cache.\n     */\n    public CacheManager getCacheManager() {\n        return cacheManager;\n    }\n\n    public String getActiveSessionsCacheName() {\n        return activeSessionsCacheName;\n    }\n\n    public void setActiveSessionsCacheName(String activeSessionsCacheName) {\n        this.activeSessionsCacheName = activeSessionsCacheName;\n    }\n\n    public Cache getActiveSessionsCache() {\n        return this.activeSessions;\n    }\n\n    protected Cache getActiveSessionsCacheLazy() {\n        if (this.activeSessions == null) {\n            this.activeSessions = createActiveSessionsCache();\n        }\n        return this.activeSessions;\n    }\n\n    public void setActiveSessionsCache(Cache cache) {\n        this.activeSessions = cache;\n    }\n\n    protected Cache createActiveSessionsCache() {\n        CacheManager mgr = getCacheManager();\n        if (mgr == null) {\n            throw new IllegalStateException(\"CacheManager property must be set to perform Cache creation.\");\n        }\n        return mgr.getCache(getActiveSessionsCacheName());\n    }\n\n    /**\n     * Initializes this DAO's internal session cache.  Subclasses can override the {@link #onInit} method for\n     * additional custom startup behavior.\n     */\n    public void init() {\n        getActiveSessionsCacheLazy();\n        onInit();\n    }\n\n    /**\n     * Template callback methods for subclass custom initialization behavior, so they don't have to override\n     * the {@link #init} method.\n     */\n    protected void onInit() {\n    }\n\n    /**\n     * Creates the session by delegating EIS creation to subclasses via the {@link #doCreate} method, and then\n     * caches the session.\n     *\n     * @param session Session object to create in the EIS and then cache.\n     */\n    public Serializable create(Session session) {\n        Serializable sessionId = doCreate(session);\n        verifySessionId(sessionId);\n        getActiveSessionsCacheLazy().put(sessionId, session);\n        return sessionId;\n    }\n\n    /**\n     * Ensures the sessionId returned from the subclass implementation of {@link #doCreate} is not null and not\n     * already in use.\n     *\n     * @param sessionId session id returned from the subclass implementation of {@link #doCreate}\n     */\n    protected void verifySessionId(Serializable sessionId) {\n        if (sessionId == null) {\n            String msg = \"sessionId returned from doCreate implementation is null.  Please verify the implementation.\";\n            throw new IllegalStateException(msg);\n        }\n        ensureUncached(sessionId);\n    }\n\n    /**\n     * Ensures that there is no cache entry already in place for a session with id of <tt>sessionId<\/tt>.  Used by\n     * the {@link #verifySessionId} implementation.\n     *\n     * @param sessionId the session id to check for non-existence in the cache.\n     */\n    protected void ensureUncached(Serializable sessionId) {\n        Cache cache = getActiveSessionsCache();\n        if (cache != null && cache.get(sessionId) != null) {\n            String msg = \"There is an existing session already created with session id [\" +\n                    sessionId + \"].  Session ID's must be unique.\";\n            throw new IllegalArgumentException(msg);\n        }\n    }\n\n    /**\n     * Subclass hook to actually persist the given <tt>Session<\/tt> instance to the underlying EIS.\n     *\n     * @param session the Session instance to persist to the EIS.\n     * @return the id of the session created in the EIS (i.e. this is almost always a primary key and should be the\n     *         value returned from {@link org.jsecurity.session.Session#getId() Session.getId()}.\n     */\n    protected abstract Serializable doCreate(Session session);\n\n    /**\n     * Retrieves the Session object from the underlying EIS identified by <tt>sessionId<\/tt>.\n     *\n     * <p>Upon receiving the Session object from the subclass's {@link #doReadSession} implementation, it will be\n     * cached first and then returned to the caller.\n     *\n     * @param sessionId the id of the session to retrieve from the EIS.\n     * @return the session identified by <tt>sessionId<\/tt> in the EIS.\n     * @throws UnknownSessionException if the id specified does not correspond to any session in the cache or EIS.\n     */\n    public Session readSession(Serializable sessionId) throws UnknownSessionException {\n        Session s = null;\n\n        Cache cache = getActiveSessionsCache();\n        if (cache != null) {\n            s = (Session) cache.get(sessionId);\n        }\n\n        if (s == null) {\n            s = doReadSession(sessionId);\n            if (s != null) {\n                if (!s.isExpired() && s.getStopTimestamp() == null) {\n                    getActiveSessionsCacheLazy().put(sessionId, s);\n                }\n            }\n        }\n\n        if (s == null) {\n            throw new UnknownSessionException(\"There is no session with id [\" + sessionId + \"]\");\n        }\n        return s;\n    }\n\n    /**\n     * Subclass implmentation hook to actually retrieve the Session object from the underlying EIS.\n     *\n     * @param sessionId the id of the <tt>Session<\/tt> to retrieve.\n     * @return the Session in the EIS identified by <tt>sessionId<\/tt>\n     */\n    protected abstract Session doReadSession(Serializable sessionId);\n\n    /**\n     * Updates the state of the given session to the EIS.\n     *\n     * <p>If the specified session was previously cached, and the session is now\n     * {@link org.jsecurity.session.Session#getStopTimestamp() stopped} or\n     * {@link org.jsecurity.session.Session#isExpired() expired}, it will be removed from the cache.\n     *\n     * <p>If the specified session is not stopped or expired, and was not yet in the cache, it will be added to the\n     * cache.\n     *\n     * <p>Finally, this method calls {@link #doUpdate} for the subclass to actually push the object state to the EIS.\n     *\n     * @param session the session object to update in the EIS.\n     * @throws UnknownSessionException if no existing EIS session record exists with the\n     *                                 identifier of {@link Session#getId() session.getId()}\n     */\n    public void update(Session session) throws UnknownSessionException {\n\n        doUpdate(session);\n\n        Cache cache = getActiveSessionsCache();\n        Serializable id = session.getId();\n\n        if (session.getStopTimestamp() != null || session.isExpired()) {\n            if (cache != null) {\n                cache.remove(id);\n            }\n        } else {\n            getActiveSessionsCacheLazy().put(id, session);\n        }\n    }\n\n    /**\n     * Subclass implementation hook to actually persist the <tt>Session<\/tt>'s state to the underlying EIS.\n     *\n     * @param session the session object whose state will be propagated to the EIS.\n     */\n    protected abstract void doUpdate(Session session);\n\n    /**\n     * Removes the specified session from any cache and then permanently deletes the session from the EIS by\n     * delegating to {@link #doDelete}.\n     *\n     * @param session the session to remove from caches and permanently delete from the EIS.\n     */\n    public void delete(Session session) {\n        Serializable id = session.getId();\n        doDelete(session);\n        Cache cache = getActiveSessionsCache();\n        if (cache != null) {\n            cache.remove(id);\n        }\n    }\n\n    /**\n     * Subclass implementation hook to permanently delete the given Session from the underlying EIS.\n     *\n     * @param session the session instance to permanently delete from the EIS.\n     */\n    protected abstract void doDelete(Session session);\n\n    /**\n     * Returns all active sessions in the system.\n     *\n     * <p>This implementation merely returns the sessions found in the activeSessions cache.  Subclass implementations\n     * may wish to override this method to retrieve them in a different way, perhaps by an RDBMS query or by other\n     * means.\n     *\n     * @return the sessions found in the activeSessions cache.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public Collection<Session> getActiveSessions() {\n        Cache cache = getActiveSessionsCache();\n        if (cache != null) {\n            return cache.values();\n        } else {\n            return Collections.EMPTY_LIST;\n        }\n    }\n}\n","lineNo":109}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt.eis;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.cache.CacheManagerAware;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.UnknownSessionException;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * An CachingSessionDAO is a SessionDAO that provides a transparent caching layer between the components that\n * use it and the underlying EIS (Enterprise Information System) for enhanced performance.\n *\n * <p>This implementation caches all active sessions in a cache created by a\n * {@link org.jsecurity.cache.CacheManager}.  All <tt>SessionDAO<\/tt> methods are implemented by this class to employ\n * caching behavior and delegates the actual EIS operations to respective do* methods to be implemented by\n * subclasses (doCreate, doRead, etc).\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic abstract class CachingSessionDAO implements SessionDAO, CacheManagerAware {\n\n    public static final String ACTIVE_SESSION_CACHE_NAME = \"jsecurity-activeSessionCache\";\n\n    protected transient final Log log = LogFactory.getLog(getClass());\n\n    private CacheManager cacheManager;\n    private Cache activeSessions;\n    private String activeSessionsCacheName = ACTIVE_SESSION_CACHE_NAME;\n\n    /**\n     * JavaBeans compatible constructor.\n     */\n    public CachingSessionDAO() {\n    }\n\n    /**\n     * Sets the cacheManager to use for constructing the session cache.\n     *\n     * @param cacheManager the manager to use for constructing the session cache.\n     */\n    public void setCacheManager(CacheManager cacheManager) {\n        this.cacheManager = cacheManager;\n        //force cache reload:\n        this.activeSessions = null;\n        getActiveSessionsCacheLazy();\n    }\n\n    /**\n     * Returns the CacheManager used by the implementation that creates the activeSessions Cache.\n     *\n     * @return the CacheManager used by the implementation that creates the activeSessions Cache.\n     */\n    public CacheManager getCacheManager() {\n        return cacheManager;\n    }\n\n    public String getActiveSessionsCacheName() {\n        return activeSessionsCacheName;\n    }\n\n    public void setActiveSessionsCacheName(String activeSessionsCacheName) {\n        this.activeSessionsCacheName = activeSessionsCacheName;\n    }\n\n    public Cache getActiveSessionsCache() {\n        return this.activeSessions;\n    }\n\n    protected Cache getActiveSessionsCacheLazy() {\n        if (this.activeSessions == null) {\n            this.activeSessions = createActiveSessionsCache();\n        }\n        return this.activeSessions;\n    }\n\n    public void setActiveSessionsCache(Cache cache) {\n        this.activeSessions = cache;\n    }\n\n    protected Cache createActiveSessionsCache() {\n        Cache cache = null;\n        CacheManager mgr = getCacheManager();\n        if (mgr != null) {\n            String name = getActiveSessionsCacheName();\n            cache = mgr.getCache(name);\n        }\n        return cache;\n    }\n\n    /**\n     * Creates the session by delegating EIS creation to subclasses via the {@link #doCreate} method, and then\n     * caches the session.\n     *\n     * @param session Session object to create in the EIS and then cache.\n     */\n    public Serializable create(Session session) {\n        Serializable sessionId = doCreate(session);\n        verifySessionId(sessionId);\n        Cache cache = getActiveSessionsCacheLazy();\n        if (cache != null) {\n            cache.put(sessionId, session);\n        }\n        return sessionId;\n    }\n\n    /**\n     * Ensures the sessionId returned from the subclass implementation of {@link #doCreate} is not null and not\n     * already in use.\n     *\n     * @param sessionId session id returned from the subclass implementation of {@link #doCreate}\n     */\n    protected void verifySessionId(Serializable sessionId) {\n        if (sessionId == null) {\n            String msg = \"sessionId returned from doCreate implementation is null.  Please verify the implementation.\";\n            throw new IllegalStateException(msg);\n        }\n        ensureUncached(sessionId);\n    }\n\n    /**\n     * Ensures that there is no cache entry already in place for a session with id of <tt>sessionId<\/tt>.  Used by\n     * the {@link #verifySessionId} implementation.\n     *\n     * @param sessionId the session id to check for non-existence in the cache.\n     */\n    protected void ensureUncached(Serializable sessionId) {\n        Cache cache = getActiveSessionsCacheLazy();\n        if (cache != null && cache.get(sessionId) != null) {\n            String msg = \"There is an existing session already created with session id [\" +\n                    sessionId + \"].  Session ID's must be unique.\";\n            throw new IllegalArgumentException(msg);\n        }\n    }\n\n    /**\n     * Subclass hook to actually persist the given <tt>Session<\/tt> instance to the underlying EIS.\n     *\n     * @param session the Session instance to persist to the EIS.\n     * @return the id of the session created in the EIS (i.e. this is almost always a primary key and should be the\n     *         value returned from {@link org.jsecurity.session.Session#getId() Session.getId()}.\n     */\n    protected abstract Serializable doCreate(Session session);\n\n    /**\n     * Retrieves the Session object from the underlying EIS identified by <tt>sessionId<\/tt>.\n     *\n     * <p>Upon receiving the Session object from the subclass's {@link #doReadSession} implementation, it will be\n     * cached first and then returned to the caller.\n     *\n     * @param sessionId the id of the session to retrieve from the EIS.\n     * @return the session identified by <tt>sessionId<\/tt> in the EIS.\n     * @throws UnknownSessionException if the id specified does not correspond to any session in the cache or EIS.\n     */\n    public Session readSession(Serializable sessionId) throws UnknownSessionException {\n        Session s = null;\n\n        Cache cache = getActiveSessionsCacheLazy();\n        if (cache != null) {\n            s = (Session) cache.get(sessionId);\n        }\n\n        if (s == null) {\n            s = doReadSession(sessionId);\n            if (cache != null && s != null && !s.isExpired() && s.getStopTimestamp() == null) {\n                cache.put(sessionId, s);\n            }\n        }\n\n        if (s == null) {\n            throw new UnknownSessionException(\"There is no session with id [\" + sessionId + \"]\");\n        }\n        return s;\n    }\n\n    /**\n     * Subclass implmentation hook to actually retrieve the Session object from the underlying EIS.\n     *\n     * @param sessionId the id of the <tt>Session<\/tt> to retrieve.\n     * @return the Session in the EIS identified by <tt>sessionId<\/tt>\n     */\n    protected abstract Session doReadSession(Serializable sessionId);\n\n    /**\n     * Updates the state of the given session to the EIS.\n     *\n     * <p>If the specified session was previously cached, and the session is now\n     * {@link org.jsecurity.session.Session#getStopTimestamp() stopped} or\n     * {@link org.jsecurity.session.Session#isExpired() expired}, it will be removed from the cache.\n     *\n     * <p>If the specified session is not stopped or expired, and was not yet in the cache, it will be added to the\n     * cache.\n     *\n     * <p>Finally, this method calls {@link #doUpdate} for the subclass to actually push the object state to the EIS.\n     *\n     * @param session the session object to update in the EIS.\n     * @throws UnknownSessionException if no existing EIS session record exists with the\n     *                                 identifier of {@link Session#getId() session.getId()}\n     */\n    public void update(Session session) throws UnknownSessionException {\n\n        doUpdate(session);\n\n        Cache cache = getActiveSessionsCacheLazy();\n        Serializable id = session.getId();\n\n        if (session.getStopTimestamp() != null || session.isExpired()) {\n            if (cache != null) {\n                cache.remove(id);\n            }\n        } else {\n            if (cache != null) {\n                cache.put(id, session);\n            }\n        }\n    }\n\n    /**\n     * Subclass implementation hook to actually persist the <tt>Session<\/tt>'s state to the underlying EIS.\n     *\n     * @param session the session object whose state will be propagated to the EIS.\n     */\n    protected abstract void doUpdate(Session session);\n\n    /**\n     * Removes the specified session from any cache and then permanently deletes the session from the EIS by\n     * delegating to {@link #doDelete}.\n     *\n     * @param session the session to remove from caches and permanently delete from the EIS.\n     */\n    public void delete(Session session) {\n        Serializable id = session.getId();\n        doDelete(session);\n        Cache cache = getActiveSessionsCacheLazy();\n        if (cache != null) {\n            cache.remove(id);\n        }\n    }\n\n    /**\n     * Subclass implementation hook to permanently delete the given Session from the underlying EIS.\n     *\n     * @param session the session instance to permanently delete from the EIS.\n     */\n    protected abstract void doDelete(Session session);\n\n    /**\n     * Returns all active sessions in the system.\n     *\n     * <p>This implementation merely returns the sessions found in the activeSessions cache.  Subclass implementations\n     * may wish to override this method to retrieve them in a different way, perhaps by an RDBMS query or by other\n     * means.\n     *\n     * @return the sessions found in the activeSessions cache.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public Collection<Session> getActiveSessions() {\n        Cache cache = getActiveSessionsCacheLazy();\n        if (cache != null) {\n            return cache.values();\n        } else {\n            return Collections.EMPTY_LIST;\n        }\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt.eis;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.cache.CacheManagerAware;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.UnknownSessionException;\nimport org.jsecurity.util.Initializable;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * An CachingSessionDAO is a SessionDAO that provides a transparent caching layer between the components that\n * use it and the underlying EIS (Enterprise Information System) for enhanced performance.\n *\n * <p>This implementation caches all active sessions in a cache created by a required\n * {@link org.jsecurity.cache.CacheManager}.  All <tt>SessionDAO<\/tt> methods are implemented by this class to employ\n * caching behavior and delegates the actual EIS operations to respective do* methods to be implemented by\n * subclasses (doCreate, doRead, etc).\n *\n * <p>After instantiating an instance of this class (or subclass) and setting the <tt>CacheManager<\/tt> property,\n * the {@link #init} method must be called to properly initialize the cache.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic abstract class CachingSessionDAO implements SessionDAO, CacheManagerAware, Initializable {\n\n    public static final String ACTIVE_SESSION_CACHE_NAME = \"jsecurity-activeSessionCache\";\n\n    protected transient final Log log = LogFactory.getLog(getClass());\n\n    private CacheManager cacheManager = null;\n    private Cache activeSessions = null;\n    private String activeSessionsCacheName = ACTIVE_SESSION_CACHE_NAME;\n\n    /**\n     * JavaBeans compatible constructor.  The {@link #setCacheManager CacheManager} property must be set and the\n     * {@link #init} method called before the instance can be used.\n     */\n    public CachingSessionDAO() {\n    }\n\n    /**\n     * Constructor taking in the required <tt>CacheManager<\/tt> property.  This constructor will call init()\n     * automatically, thereby making the instance ready for use immediately after instantiation.\n     *\n     * @param manager the required <tt>CacheManager<\/tt> property necessary for cache initialization.\n     */\n    public CachingSessionDAO(CacheManager manager) {\n        setCacheManager(manager);\n        init();\n    }\n\n    /**\n     * Sets the cacheManager to use for constructing the session cache.\n     *\n     * @param cacheManager the manager to use for constructing the session cache.\n     */\n    public void setCacheManager(CacheManager cacheManager) {\n        this.cacheManager = cacheManager;\n    }\n\n    /**\n     * Returns the CacheManager used by the implementation that creates the activeSessions Cache.\n     *\n     * @return the CacheManager used by the implementation that creates the activeSessions Cache.\n     */\n    public CacheManager getCacheManager() {\n        return cacheManager;\n    }\n\n    public String getActiveSessionsCacheName() {\n        return activeSessionsCacheName;\n    }\n\n    public void setActiveSessionsCacheName(String activeSessionsCacheName) {\n        this.activeSessionsCacheName = activeSessionsCacheName;\n    }\n\n    public Cache getActiveSessionsCache() {\n        return this.activeSessions;\n    }\n\n    protected Cache getActiveSessionsCacheLazy() {\n        if (this.activeSessions == null) {\n            this.activeSessions = createActiveSessionsCache();\n        }\n        return this.activeSessions;\n    }\n\n    public void setActiveSessionsCache(Cache cache) {\n        this.activeSessions = cache;\n    }\n\n    protected Cache createActiveSessionsCache() {\n        CacheManager mgr = getCacheManager();\n        if (mgr == null) {\n            throw new IllegalStateException(\"CacheManager property must be set to perform Cache creation.\");\n        }\n        return mgr.getCache(getActiveSessionsCacheName());\n    }\n\n    /**\n     * Initializes this DAO's internal session cache.  Subclasses can override the {@link #onInit} method for\n     * additional custom startup behavior.\n     */\n    public void init() {\n        getActiveSessionsCacheLazy();\n        onInit();\n    }\n\n    /**\n     * Template callback methods for subclass custom initialization behavior, so they don't have to override\n     * the {@link #init} method.\n     */\n    protected void onInit() {\n    }\n\n    /**\n     * Creates the session by delegating EIS creation to subclasses via the {@link #doCreate} method, and then\n     * caches the session.\n     *\n     * @param session Session object to create in the EIS and then cache.\n     */\n    public Serializable create(Session session) {\n        Serializable sessionId = doCreate(session);\n        verifySessionId(sessionId);\n        getActiveSessionsCacheLazy().put(sessionId, session);\n        return sessionId;\n    }\n\n    /**\n     * Ensures the sessionId returned from the subclass implementation of {@link #doCreate} is not null and not\n     * already in use.\n     *\n     * @param sessionId session id returned from the subclass implementation of {@link #doCreate}\n     */\n    protected void verifySessionId(Serializable sessionId) {\n        if (sessionId == null) {\n            String msg = \"sessionId returned from doCreate implementation is null.  Please verify the implementation.\";\n            throw new IllegalStateException(msg);\n        }\n        ensureUncached(sessionId);\n    }\n\n    /**\n     * Ensures that there is no cache entry already in place for a session with id of <tt>sessionId<\/tt>.  Used by\n     * the {@link #verifySessionId} implementation.\n     *\n     * @param sessionId the session id to check for non-existence in the cache.\n     */\n    protected void ensureUncached(Serializable sessionId) {\n        Cache cache = getActiveSessionsCache();\n        if (cache != null && cache.get(sessionId) != null) {\n            String msg = \"There is an existing session already created with session id [\" +\n                    sessionId + \"].  Session ID's must be unique.\";\n            throw new IllegalArgumentException(msg);\n        }\n    }\n\n    /**\n     * Subclass hook to actually persist the given <tt>Session<\/tt> instance to the underlying EIS.\n     *\n     * @param session the Session instance to persist to the EIS.\n     * @return the id of the session created in the EIS (i.e. this is almost always a primary key and should be the\n     *         value returned from {@link org.jsecurity.session.Session#getId() Session.getId()}.\n     */\n    protected abstract Serializable doCreate(Session session);\n\n    /**\n     * Retrieves the Session object from the underlying EIS identified by <tt>sessionId<\/tt>.\n     *\n     * <p>Upon receiving the Session object from the subclass's {@link #doReadSession} implementation, it will be\n     * cached first and then returned to the caller.\n     *\n     * @param sessionId the id of the session to retrieve from the EIS.\n     * @return the session identified by <tt>sessionId<\/tt> in the EIS.\n     * @throws UnknownSessionException if the id specified does not correspond to any session in the cache or EIS.\n     */\n    public Session readSession(Serializable sessionId) throws UnknownSessionException {\n        Session s = null;\n\n        Cache cache = getActiveSessionsCache();\n        if (cache != null) {\n            s = (Session) cache.get(sessionId);\n        }\n\n        if (s == null) {\n            s = doReadSession(sessionId);\n            if (s != null) {\n                if (!s.isExpired() && s.getStopTimestamp() == null) {\n                    getActiveSessionsCacheLazy().put(sessionId, s);\n                }\n            }\n        }\n\n        if (s == null) {\n            throw new UnknownSessionException(\"There is no session with id [\" + sessionId + \"]\");\n        }\n        return s;\n    }\n\n    /**\n     * Subclass implmentation hook to actually retrieve the Session object from the underlying EIS.\n     *\n     * @param sessionId the id of the <tt>Session<\/tt> to retrieve.\n     * @return the Session in the EIS identified by <tt>sessionId<\/tt>\n     */\n    protected abstract Session doReadSession(Serializable sessionId);\n\n    /**\n     * Updates the state of the given session to the EIS.\n     *\n     * <p>If the specified session was previously cached, and the session is now\n     * {@link org.jsecurity.session.Session#getStopTimestamp() stopped} or\n     * {@link org.jsecurity.session.Session#isExpired() expired}, it will be removed from the cache.\n     *\n     * <p>If the specified session is not stopped or expired, and was not yet in the cache, it will be added to the\n     * cache.\n     *\n     * <p>Finally, this method calls {@link #doUpdate} for the subclass to actually push the object state to the EIS.\n     *\n     * @param session the session object to update in the EIS.\n     * @throws UnknownSessionException if no existing EIS session record exists with the\n     *                                 identifier of {@link Session#getId() session.getId()}\n     */\n    public void update(Session session) throws UnknownSessionException {\n\n        doUpdate(session);\n\n        Cache cache = getActiveSessionsCache();\n        Serializable id = session.getId();\n\n        if (session.getStopTimestamp() != null || session.isExpired()) {\n            if (cache != null) {\n                cache.remove(id);\n            }\n        } else {\n            getActiveSessionsCacheLazy().put(id, session);\n        }\n    }\n\n    /**\n     * Subclass implementation hook to actually persist the <tt>Session<\/tt>'s state to the underlying EIS.\n     *\n     * @param session the session object whose state will be propagated to the EIS.\n     */\n    protected abstract void doUpdate(Session session);\n\n    /**\n     * Removes the specified session from any cache and then permanently deletes the session from the EIS by\n     * delegating to {@link #doDelete}.\n     *\n     * @param session the session to remove from caches and permanently delete from the EIS.\n     */\n    public void delete(Session session) {\n        Serializable id = session.getId();\n        doDelete(session);\n        Cache cache = getActiveSessionsCache();\n        if (cache != null) {\n            cache.remove(id);\n        }\n    }\n\n    /**\n     * Subclass implementation hook to permanently delete the given Session from the underlying EIS.\n     *\n     * @param session the session instance to permanently delete from the EIS.\n     */\n    protected abstract void doDelete(Session session);\n\n    /**\n     * Returns all active sessions in the system.\n     *\n     * <p>This implementation merely returns the sessions found in the activeSessions cache.  Subclass implementations\n     * may wish to override this method to retrieve them in a different way, perhaps by an RDBMS query or by other\n     * means.\n     *\n     * @return the sessions found in the activeSessions cache.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public Collection<Session> getActiveSessions() {\n        Cache cache = getActiveSessionsCache();\n        if (cache != null) {\n            return cache.values();\n        } else {\n            return Collections.EMPTY_LIST;\n        }\n    }\n}\n","lineNo":124}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.filter.authz;\n\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.web.WebUtils;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.IOException;\n\n/**\n * Filter that allows access if the current user has the permissions specified by the mapped value, or denies access\n * if the user does not have all of the permissions specified.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.9\n */\npublic class PermissionsAuthorizationFilter extends AuthorizationFilter {\n\n    public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException {\n\n        Subject subject = WebUtils.getSubject(request, response);\n        String[] perms = (String[]) mappedValue;\n\n        boolean isPermitted = true;\n        if (perms != null && perms.length > 0) {\n            if (perms.length == 1) {\n                if (!subject.isPermitted(perms[0])) {\n                    isPermitted = false;\n                }\n            } else {\n                if (!subject.isPermittedAll(perms)) {\n                    isPermitted = false;\n                }\n            }\n        }\n\n        return isPermitted;\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.filter.authz;\n\nimport org.jsecurity.subject.Subject;\nimport static org.jsecurity.util.StringUtils.split;\nimport org.jsecurity.web.WebUtils;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\n/**\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.9\n */\npublic class PermissionsAuthorizationFilter extends AuthorizationFilter {\n\n    public void processPathConfig(String path, String config) {\n        if (config != null) {\n            String[] values = split(config);\n            if (values != null) {\n                this.appliedPaths.put(path, values);\n            }\n        }\n    }\n\n    public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {\n\n        Subject subject = WebUtils.getSubject(request, response);\n        String[] perms = (String[]) mappedValue;\n\n        if (perms != null && perms.length > 0) {\n            if (perms.length == 1) {\n                if (!subject.isPermitted(perms[0])) {\n                    WebUtils.issueRedirect(request, response, getUnauthorizedUrl());\n                }\n            } else {\n                if (!subject.isPermittedAll(perms)) {\n                    WebUtils.issueRedirect(request, response, getUnauthorizedUrl());\n                }\n            }\n        }\n\n        return true;\n    }\n}\n","lineNo":43}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.filter.authz;\n\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.web.WebUtils;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.IOException;\nimport java.util.Set;\n\n/**\n * Filter that allows access if the current user has the roles specified by the mapped value, or denies access\n * if the user does not have all of the roles specified.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.9\n */\npublic class RolesAuthorizationFilter extends AuthorizationFilter {\n\n    @SuppressWarnings({\"unchecked\"})\n    public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException {\n\n        Subject subject = WebUtils.getSubject(request, response);\n        Set<String> roles = (Set<String>) mappedValue;\n\n        boolean hasRoles = true;\n        if (roles != null && !roles.isEmpty()) {\n            if (roles.size() == 1) {\n                if (!subject.hasRole(roles.iterator().next())) {\n                    hasRoles = false;\n                }\n            } else {\n                if (!subject.hasAllRoles(roles)) {\n                    hasRoles = false;\n                }\n            }\n        }\n\n        return hasRoles;\n    }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.filter.authz;\n\nimport org.jsecurity.subject.Subject;\nimport static org.jsecurity.util.StringUtils.split;\nimport org.jsecurity.web.WebUtils;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\n/**\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.9\n */\npublic class RolesAuthorizationFilter extends AuthorizationFilter {\n\n    public void processPathConfig(String path, String config) {\n        if (config != null) {\n            String[] values = split(config);\n            if (values != null) {\n                Set<String> set = new LinkedHashSet<String>(Arrays.asList(values));\n                this.appliedPaths.put(path, set);\n            }\n        }\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {\n\n        Subject subject = WebUtils.getSubject(request, response);\n        Set<String> roles = (Set<String>) mappedValue;\n\n        if (roles != null && !roles.isEmpty()) {\n            if (roles.size() == 1) {\n                if (!subject.hasRole(roles.iterator().next())) {\n                    WebUtils.issueRedirect(request, response, getUnauthorizedUrl());\n                }\n            } else {\n                if (!subject.hasAllRoles(roles)) {\n                    WebUtils.issueRedirect(request, response, getUnauthorizedUrl());\n                }\n            }\n        }\n\n        return true;\n    }\n}\n","lineNo":45}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXST_KEY\";\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    // Key used to save a request and later restore it (e.g. when redirecting to a requested page after login)\n    public static final String SAVED_REQUEST_KEY = \"jsecuritySavedRequest\";\n\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding<\/code>\n     * returns <code>null<\/code>, according to the Servlet spec.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()<\/code> is <i>not<\/i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should<\/i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()<\/code> is <i>not<\/i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(org.springframework.web.util.WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)<\/code>.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see org.springframework.web.util.WebUtils#DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({\"deprecation\"})\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        }\n        catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc +\n                        \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request encoding,\n     * falling back to the default encoding specified for this resolver.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null<\/code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    public static InetAddress getInetAddress(ServletRequest request) {\n        InetAddress clientAddress = null;\n        //get the Host/IP the client is coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName(addrString);\n        } catch (UnknownHostException e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to acquire InetAddress from ServletRequest\", e);\n            }\n        }\n\n        return clientAddress;\n    }\n\n    public static Subject getSubject(ServletRequest request, ServletResponse response) {\n        return SecurityUtils.getSubject();\n    }\n\n    public static Session getSession(ServletRequest request, ServletResponse response) {\n\n        Session session = null;\n\n        Subject subject = getSubject(request, response);\n\n        if (subject != null) {\n            session = subject.getSession(false);\n        }\n\n        return session;\n    }\n\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    public static void bindInetAddressToThread(ServletRequest request) {\n        InetAddress ip = getInetAddress(request);\n        if (ip != null) {\n            ThreadContext.bind(ip);\n        }\n    }\n\n    public static void unbindInetAddressFromThread() {\n        ThreadContext.unbindInetAddress();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread, this method returns <tt>null<\/tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <pre>\n     * return (ServletRequest)get( SERVLET_REQUEST_KEY );<\/pre>\n     *\n     * <p>This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread, or <tt>null<\/tt> if there isn't one bound.\n     */\n    public static ServletRequest getServletRequest() {\n        return (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null<\/tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, session );\n     * }<\/pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletRequest servletRequest) {\n        if (servletRequest != null) {\n            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     *\n     * <p>The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     *\n     * <pre>\n     * return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );<\/pre>\n     *\n     * <p>If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getServletRequest() getServletRequest()} method for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null<\/tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest) ThreadContext.remove(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread, this method returns <tt>null<\/tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <pre>\n     * return (ServletResponse)ThreadContext.get( SERVLET_RESPONSE_KEY );<\/pre>\n     *\n     * <p>This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread, or <tt>null<\/tt> if there isn't one bound.\n     */\n    public static ServletResponse getServletResponse() {\n        return (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null<\/tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, session );\n     * }<\/pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletResponse servletResponse) {\n        if (servletResponse != null) {\n            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     *\n     * <p>The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     *\n     * <pre>\n     * return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );<\/pre>\n     *\n     * <p>If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getServletResponse() getServletResponse()} method for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null<\/tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse) ThreadContext.remove(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     * @param request the servlet request.\n     * @param response the servlet response.\n     * @param url the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     *\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect( ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible ) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     * @param request the servlet request.\n     * @param response the servlet response.\n     * @param url the URL to redirect the user to.\n     *\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect( ServletRequest request, ServletResponse response, String url ) throws IOException {\n        issueRedirect( request, response, url, null, true, true );\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     * @param request the servlet request.\n     * @param response the servlet response.\n     * @param url the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     *\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect( ServletRequest request, ServletResponse response, String url, Map queryParams ) throws IOException {\n        issueRedirect( request, response, url, queryParams, true, true );\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     * @param request the servlet request.\n     * @param response the servlet response.\n     * @param url the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     *\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect( ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative ) throws IOException {\n        issueRedirect( request, response, url, queryParams, contextRelative, true );\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.<\/p>\n     *\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.<\/p>\n     *\n     * @param request the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String paramValue = getCleanParam(request, paramName);\n\n        if( paramValue == null ) {\n            return false;\n        } else {\n            return paramValue.equalsIgnoreCase(\"true\") ||\n                   paramValue.equalsIgnoreCase(\"t\") ||\n                   paramValue.equalsIgnoreCase(\"1\") ||\n                   paramValue.equalsIgnoreCase(\"enabled\") ||\n                   paramValue.equalsIgnoreCase(\"y\") ||\n                   paramValue.equalsIgnoreCase(\"yes\") ||\n                   paramValue.equalsIgnoreCase(\"on\");\n        }\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     * @param request the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean( request.getParameter( paramName ) );\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        HttpServletRequest httpRequest = toHttp(request);\n        HttpSession session = httpRequest.getSession();\n\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute( SAVED_REQUEST_KEY, savedRequest );\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if( savedRequest != null ) {\n            HttpSession session = WebUtils.toHttp(request).getSession();\n            session.removeAttribute( SAVED_REQUEST_KEY );\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n\n        HttpSession session = WebUtils.toHttp(request).getSession(false);\n        if( session != null ) {\n            savedRequest = (SavedRequest) session.getAttribute( SAVED_REQUEST_KEY );\n        }\n\n        return savedRequest;\n    }\n\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXST_KEY\";\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding<\/code>\n     * returns <code>null<\/code>, according to the Servlet spec.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()<\/code> is <i>not<\/i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should<\/i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()<\/code> is <i>not<\/i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(org.springframework.web.util.WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)<\/code>.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see org.springframework.web.util.WebUtils#DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({\"deprecation\"})\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        }\n        catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc +\n                        \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request encoding,\n     * falling back to the default encoding specified for this resolver.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null<\/code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    public static InetAddress getInetAddress(ServletRequest request) {\n        InetAddress clientAddress = null;\n        //get the Host/IP the client is coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName(addrString);\n        } catch (UnknownHostException e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to acquire InetAddress from ServletRequest\", e);\n            }\n        }\n\n        return clientAddress;\n    }\n\n    public static Subject getSubject(ServletRequest request, ServletResponse response) {\n        return SecurityUtils.getSubject();\n    }\n\n    public static Session getSession(ServletRequest request, ServletResponse response) {\n\n        Session session = null;\n\n        Subject subject = getSubject(request, response);\n\n        if (subject != null) {\n            session = subject.getSession(false);\n        }\n\n        return session;\n    }\n\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    public static void bindInetAddressToThread(ServletRequest request) {\n        InetAddress ip = getInetAddress(request);\n        if (ip != null) {\n            ThreadContext.bind(ip);\n        }\n    }\n\n    public static void unbindInetAddressFromThread() {\n        ThreadContext.unbindInetAddress();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread, this method returns <tt>null<\/tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <pre>\n     * return (ServletRequest)get( SERVLET_REQUEST_KEY );<\/pre>\n     *\n     * <p>This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread, or <tt>null<\/tt> if there isn't one bound.\n     */\n    public static ServletRequest getServletRequest() {\n        return (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null<\/tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, session );\n     * }<\/pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletRequest servletRequest) {\n        if (servletRequest != null) {\n            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     *\n     * <p>The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     *\n     * <pre>\n     * return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );<\/pre>\n     *\n     * <p>If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getServletRequest() getServletRequest()} method for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null<\/tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest) ThreadContext.remove(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread, this method returns <tt>null<\/tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <pre>\n     * return (ServletResponse)ThreadContext.get( SERVLET_RESPONSE_KEY );<\/pre>\n     *\n     * <p>This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread, or <tt>null<\/tt> if there isn't one bound.\n     */\n    public static ServletResponse getServletResponse() {\n        return (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null<\/tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, session );\n     * }<\/pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletResponse servletResponse) {\n        if (servletResponse != null) {\n            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     *\n     * <p>The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     *\n     * <pre>\n     * return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );<\/pre>\n     *\n     * <p>If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getServletResponse() getServletResponse()} method for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null<\/tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse) ThreadContext.remove(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     * @param request the servlet request.\n     * @param response the servlet response.\n     * @param url the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     *\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect( ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible ) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     * @param request the servlet request.\n     * @param response the servlet response.\n     * @param url the URL to redirect the user to.\n     *\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect( ServletRequest request, ServletResponse response, String url ) throws IOException {\n        issueRedirect( request, response, url, null, true, true );\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     * @param request the servlet request.\n     * @param response the servlet response.\n     * @param url the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     *\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect( ServletRequest request, ServletResponse response, String url, Map queryParams ) throws IOException {\n        issueRedirect( request, response, url, queryParams, true, true );\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     * @param request the servlet request.\n     * @param response the servlet response.\n     * @param url the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     *\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect( ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative ) throws IOException {\n        issueRedirect( request, response, url, queryParams, contextRelative, true );\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.<\/p>\n     *\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.<\/p>\n     *\n     * @param request the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String paramValue = getCleanParam(request, paramName);\n\n        if( paramValue == null ) {\n            return false;\n        } else {\n            return paramValue.equalsIgnoreCase(\"true\") ||\n                   paramValue.equalsIgnoreCase(\"t\") ||\n                   paramValue.equalsIgnoreCase(\"1\") ||\n                   paramValue.equalsIgnoreCase(\"enabled\") ||\n                   paramValue.equalsIgnoreCase(\"y\") ||\n                   paramValue.equalsIgnoreCase(\"yes\") ||\n                   paramValue.equalsIgnoreCase(\"on\");\n        }\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     * @param request the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean( request.getParameter( paramName ) );\n    }\n}\n","lineNo":483}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.util.JavaEnvironment;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.util.Iterator;\nimport java.util.Map;\n\n/**\n * <p>View that redirects to an absolute, context relative, or current request\n * relative URL, exposing all model attributes as HTTP query parameters.\n *\n * <p>A URL for this view is supposed to be a HTTP redirect URL, i.e.\n * suitable for HttpServletResponse's <code>sendRedirect<\/code> method, which\n * is what actually does the redirect if the HTTP 1.0 flag is on, or via sending\n * back an HTTP 303 code - if the HTTP 1.0 compatibility flag is off.\n *\n * <p>Note that while the default value for the \"contextRelative\" flag is off,\n * you will probably want to almost always set it to true. With the flag off,\n * URLs starting with \"/\" are considered relative to the web server root, while\n * with the flag on, they are considered relative to the web application root.\n * Since most web apps will never know or care what their context path actually\n * is, they are much better off setting this flag to true, and submitting paths\n * which are to be considered relative to the web application root.\n *\n * <p>Note that in a Servlet 2.2 environment, i.e. a servlet container which\n * is only compliant to the limits of this spec, this class will probably fail\n * when feeding in URLs which are not fully absolute, or relative to the current\n * request (no leading \"/\"), as these are the only two types of URL that\n * <code>sendRedirect<\/code> supports in a Servlet 2.2 environment.\n *\n * <p><em>This class was borrowed from a nearly identical version found in\n * the <a href=\"http://www.springframework.org/\">Spring Framework<\/a>, with minor modifications to\n * avoid a dependency on Spring itself for a very small amount of code - we couldn't have done it better, and\n * don't want to repeat all of their great effort ;).\n * The original author names and copyright (Apache 2.0) has been left in place.  A special\n * thanks to Rod Johnson, Juergen Hoeller, and Colin Sampaleanu for making this available.<\/em>\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Colin Sampaleanu\n * @see #setContextRelative\n * @see #setHttp10Compatible\n * @see javax.servlet.http.HttpServletResponse#sendRedirect\n * @since 0.2\n */\n@SuppressWarnings({\"deprecation\"})\npublic class RedirectView {\n\n    /**\n     * The default encoding scheme: UTF-8\n     */\n    public static final String DEFAULT_ENCODING_SCHEME = \"UTF-8\";\n\n    protected transient final Log log = LogFactory.getLog(getClass());\n\n    private String url;\n\n    private boolean contextRelative = false;\n\n    private boolean http10Compatible = true;\n\n    private String encodingScheme = DEFAULT_ENCODING_SCHEME;\n\n    /**\n     * Constructor for use as a bean.\n     */\n    public RedirectView() {\n    }\n\n    /**\n     * Create a new RedirectView with the given URL.\n     * <p>The given URL will be considered as relative to the web server,\n     * not as relative to the current ServletContext.\n     *\n     * @param url the URL to redirect to\n     * @see #RedirectView(String, boolean)\n     */\n    public RedirectView(String url) {\n        setUrl(url);\n    }\n\n    /**\n     * Create a new RedirectView with the given URL.\n     *\n     * @param url             the URL to redirect to\n     * @param contextRelative whether to interpret the given URL as\n     *                        relative to the current ServletContext\n     */\n    public RedirectView(String url, boolean contextRelative) {\n        this(url);\n        this.contextRelative = contextRelative;\n    }\n\n    /**\n     * Create a new RedirectView with the given URL.\n     *\n     * @param url              the URL to redirect to\n     * @param contextRelative  whether to interpret the given URL as\n     *                         relative to the current ServletContext\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients\n     */\n    public RedirectView(String url, boolean contextRelative, boolean http10Compatible) {\n        this(url);\n        this.contextRelative = contextRelative;\n        this.http10Compatible = http10Compatible;\n    }\n\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    /**\n     * Set whether to interpret a given URL that starts with a slash (\"/\")\n     * as relative to the current ServletContext, i.e. as relative to the\n     * web application root.\n     * <p>Default is \"false\": A URL that starts with a slash will be interpreted\n     * as absolute, i.e. taken as-is. If true, the context path will be\n     * prepended to the URL in such a case.\n     *\n     * @see javax.servlet.http.HttpServletRequest#getContextPath\n     */\n    public void setContextRelative(boolean contextRelative) {\n        this.contextRelative = contextRelative;\n    }\n\n    /**\n     * Set whether to stay compatible with HTTP 1.0 clients.\n     * <p>In the default implementation, this will enforce HTTP status code 302\n     * in any case, i.e. delegate to <code>HttpServletResponse.sendRedirect<\/code>.\n     * Turning this off will send HTTP status code 303, which is the correct\n     * code for HTTP 1.1 clients, but not understood by HTTP 1.0 clients.\n     * <p>Many HTTP 1.1 clients treat 302 just like 303, not making any\n     * difference. However, some clients depend on 303 when redirecting\n     * after a POST request; turn this flag off in such a scenario.\n     *\n     * @see javax.servlet.http.HttpServletResponse#sendRedirect\n     */\n    public void setHttp10Compatible(boolean http10Compatible) {\n        this.http10Compatible = http10Compatible;\n    }\n\n    /**\n     * Set the encoding scheme for this view. Default is UTF-8.\n     */\n    public void setEncodingScheme(String encodingScheme) {\n        this.encodingScheme = encodingScheme;\n    }\n\n\n    /**\n     * Convert model to request parameters and redirect to the given URL.\n     *\n     * @see #appendQueryProperties\n     * @see #sendRedirect\n     */\n    public final void renderMergedOutputModel(\n            Map model, HttpServletRequest request, HttpServletResponse response) throws IOException {\n\n        // Prepare name URL.\n        StringBuffer targetUrl = new StringBuffer();\n        if (this.contextRelative && getUrl().startsWith(\"/\")) {\n            // Do not apply context path to relative URLs.\n            targetUrl.append(request.getContextPath());\n        }\n        targetUrl.append(getUrl());\n        appendQueryProperties(targetUrl, model, this.encodingScheme);\n\n        sendRedirect(request, response, targetUrl.toString(), this.http10Compatible);\n    }\n\n    /**\n     * Append query properties to the redirect URL.\n     * Stringifies, URL-encodes and formats model attributes as query properties.\n     *\n     * @param targetUrl      the StringBuffer to append the properties to\n     * @param model          Map that contains model attributes\n     * @param encodingScheme the encoding scheme to use\n     * @throws java.io.UnsupportedEncodingException\n     *          if string encoding failed\n     * @see #queryProperties\n     */\n    protected void appendQueryProperties(StringBuffer targetUrl, Map model, String encodingScheme)\n            throws UnsupportedEncodingException {\n\n        // Extract anchor fragment, if any.\n        // The following code does not use JDK 1.4's StringBuffer.indexOf(String)\n        // method to retain JDK 1.3 compatibility.\n        String fragment = null;\n        int anchorIndex = targetUrl.toString().indexOf('#');\n        if (anchorIndex > -1) {\n            fragment = targetUrl.substring(anchorIndex);\n            targetUrl.delete(anchorIndex, targetUrl.length());\n        }\n\n        // If there aren't already some parameters, we need a \"?\".\n        boolean first = (getUrl().indexOf('?') < 0);\n        Map queryProps = queryProperties(model);\n\n        if( queryProps != null ) {\n            Iterator entries = queryProps.entrySet().iterator();\n            while (entries.hasNext()) {\n                if (first) {\n                    targetUrl.append('?');\n                    first = false;\n                } else {\n                    targetUrl.append('&');\n                }\n                Map.Entry entry = (Map.Entry) entries.next();\n                String encodedKey = urlEncode(entry.getKey().toString(), encodingScheme);\n                String encodedValue =\n                        (entry.getValue() != null ? urlEncode(entry.getValue().toString(), encodingScheme) : \"\");\n                targetUrl.append(encodedKey).append('=').append(encodedValue);\n            }\n        }\n\n        // Append anchor fragment, if any, to end of URL.\n        if (fragment != null) {\n            targetUrl.append(fragment);\n        }\n    }\n\n    /**\n     * URL-encode the given input String with the given encoding scheme.\n     * <p>Default implementation uses <code>URLEncoder.encode(input, enc)<\/code>\n     * on JDK 1.4+, falling back to <code>URLEncoder.encode(input)<\/code>\n     * (which uses the platform default encoding) on JDK 1.3.\n     *\n     * @param input          the unencoded input String\n     * @param encodingScheme the encoding scheme\n     * @return the encoded output String\n     * @throws UnsupportedEncodingException if thrown by the JDK URLEncoder\n     * @see java.net.URLEncoder#encode(String, String)\n     * @see java.net.URLEncoder#encode(String)\n     */\n    protected String urlEncode(String input, String encodingScheme) throws UnsupportedEncodingException {\n        if (!JavaEnvironment.isAtLeastVersion14()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Only JDK 1.3 URLEncoder available: using platform default encoding \" +\n                        \"instead of the requested scheme '\" + encodingScheme + \"'\");\n            }\n            return URLEncoder.encode(input);\n        }\n        return URLEncoder.encode(input, encodingScheme);\n    }\n\n    /**\n     * Determine name-value pairs for query strings, which will be stringified,\n     * URL-encoded and formatted by appendQueryProperties.\n     * <p>This implementation returns all model elements as-is.\n     *\n     * @see #appendQueryProperties\n     */\n    protected Map queryProperties(Map model) {\n        return model;\n    }\n\n    /**\n     * Send a redirect back to the HTTP client\n     *\n     * @param request          current HTTP request (allows for reacting to request method)\n     * @param response         current HTTP response (for sending response headers)\n     * @param targetUrl        the name URL to redirect to\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients\n     * @throws IOException if thrown by response methods\n     */\n    protected void sendRedirect(\n            HttpServletRequest request, HttpServletResponse response, String targetUrl, boolean http10Compatible)\n            throws IOException {\n\n        if (http10Compatible) {\n            // Always send status code 302.\n            response.sendRedirect(response.encodeRedirectURL(targetUrl));\n\t\t}\n\t\telse {\n\t\t\t// Correct HTTP status code is 303, in particular for POST requests.\n\t\t\tresponse.setStatus(303);\n\t\t\tresponse.setHeader(\"Location\", response.encodeRedirectURL(targetUrl));\n\t\t}\n\t}\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.util.JavaEnvironment;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.util.Iterator;\nimport java.util.Map;\n\n/**\n * <p>View that redirects to an absolute, context relative, or current request\n * relative URL, exposing all model attributes as HTTP query parameters.\n *\n * <p>A URL for this view is supposed to be a HTTP redirect URL, i.e.\n * suitable for HttpServletResponse's <code>sendRedirect<\/code> method, which\n * is what actually does the redirect if the HTTP 1.0 flag is on, or via sending\n * back an HTTP 303 code - if the HTTP 1.0 compatibility flag is off.\n *\n * <p>Note that while the default value for the \"contextRelative\" flag is off,\n * you will probably want to almost always set it to true. With the flag off,\n * URLs starting with \"/\" are considered relative to the web server root, while\n * with the flag on, they are considered relative to the web application root.\n * Since most web apps will never know or care what their context path actually\n * is, they are much better off setting this flag to true, and submitting paths\n * which are to be considered relative to the web application root.\n *\n * <p>Note that in a Servlet 2.2 environment, i.e. a servlet container which\n * is only compliant to the limits of this spec, this class will probably fail\n * when feeding in URLs which are not fully absolute, or relative to the current\n * request (no leading \"/\"), as these are the only two types of URL that\n * <code>sendRedirect<\/code> supports in a Servlet 2.2 environment.\n *\n * <p><em>This class was borrowed from a nearly identical version found in\n * the <a href=\"http://www.springframework.org/\">Spring Framework<\/a>, with minor modifications to\n * avoid a dependency on Spring itself for a very small amount of code - we couldn't have done it better, and\n * don't want to repeat all of their great effort ;).\n * The original author names and copyright (Apache 2.0) has been left in place.  A special\n * thanks to Rod Johnson, Juergen Hoeller, and Colin Sampaleanu for making this available.<\/em>\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Colin Sampaleanu\n * @see #setContextRelative\n * @see #setHttp10Compatible\n * @see javax.servlet.http.HttpServletResponse#sendRedirect\n * @since 0.2\n */\n@SuppressWarnings({\"deprecation\"})\npublic class RedirectView {\n\n    /**\n     * The default encoding scheme: UTF-8\n     */\n    public static final String DEFAULT_ENCODING_SCHEME = \"UTF-8\";\n\n    protected transient final Log log = LogFactory.getLog(getClass());\n\n    private String url;\n\n    private boolean contextRelative = false;\n\n    private boolean http10Compatible = true;\n\n    private String encodingScheme = DEFAULT_ENCODING_SCHEME;\n\n    /**\n     * Constructor for use as a bean.\n     */\n    public RedirectView() {\n    }\n\n    /**\n     * Create a new RedirectView with the given URL.\n     * <p>The given URL will be considered as relative to the web server,\n     * not as relative to the current ServletContext.\n     *\n     * @param url the URL to redirect to\n     * @see #RedirectView(String, boolean)\n     */\n    public RedirectView(String url) {\n        setUrl(url);\n    }\n\n    /**\n     * Create a new RedirectView with the given URL.\n     *\n     * @param url             the URL to redirect to\n     * @param contextRelative whether to interpret the given URL as\n     *                        relative to the current ServletContext\n     */\n    public RedirectView(String url, boolean contextRelative) {\n        this(url);\n        this.contextRelative = contextRelative;\n    }\n\n    /**\n     * Create a new RedirectView with the given URL.\n     *\n     * @param url              the URL to redirect to\n     * @param contextRelative  whether to interpret the given URL as\n     *                         relative to the current ServletContext\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients\n     */\n    public RedirectView(String url, boolean contextRelative, boolean http10Compatible) {\n        this(url);\n        this.contextRelative = contextRelative;\n        this.http10Compatible = http10Compatible;\n    }\n\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    /**\n     * Set whether to interpret a given URL that starts with a slash (\"/\")\n     * as relative to the current ServletContext, i.e. as relative to the\n     * web application root.\n     * <p>Default is \"false\": A URL that starts with a slash will be interpreted\n     * as absolute, i.e. taken as-is. If true, the context path will be\n     * prepended to the URL in such a case.\n     *\n     * @see javax.servlet.http.HttpServletRequest#getContextPath\n     */\n    public void setContextRelative(boolean contextRelative) {\n        this.contextRelative = contextRelative;\n    }\n\n    /**\n     * Set whether to stay compatible with HTTP 1.0 clients.\n     * <p>In the default implementation, this will enforce HTTP status code 302\n     * in any case, i.e. delegate to <code>HttpServletResponse.sendRedirect<\/code>.\n     * Turning this off will send HTTP status code 303, which is the correct\n     * code for HTTP 1.1 clients, but not understood by HTTP 1.0 clients.\n     * <p>Many HTTP 1.1 clients treat 302 just like 303, not making any\n     * difference. However, some clients depend on 303 when redirecting\n     * after a POST request; turn this flag off in such a scenario.\n     *\n     * @see javax.servlet.http.HttpServletResponse#sendRedirect\n     */\n    public void setHttp10Compatible(boolean http10Compatible) {\n        this.http10Compatible = http10Compatible;\n    }\n\n    /**\n     * Set the encoding scheme for this view. Default is UTF-8.\n     */\n    public void setEncodingScheme(String encodingScheme) {\n        this.encodingScheme = encodingScheme;\n    }\n\n\n    /**\n     * Convert model to request parameters and redirect to the given URL.\n     *\n     * @see #appendQueryProperties\n     * @see #sendRedirect\n     */\n    public final void renderMergedOutputModel(\n            Map model, HttpServletRequest request, HttpServletResponse response) throws IOException {\n\n        // Prepare name URL.\n        StringBuffer targetUrl = new StringBuffer();\n        if (this.contextRelative && getUrl().startsWith(\"/\")) {\n            // Do not apply context path to relative URLs.\n            targetUrl.append(request.getContextPath());\n        }\n        targetUrl.append(getUrl());\n        appendQueryProperties(targetUrl, model, this.encodingScheme);\n\n        sendRedirect(request, response, targetUrl.toString(), this.http10Compatible);\n    }\n\n    /**\n     * Append query properties to the redirect URL.\n     * Stringifies, URL-encodes and formats model attributes as query properties.\n     *\n     * @param targetUrl      the StringBuffer to append the properties to\n     * @param model          Map that contains model attributes\n     * @param encodingScheme the encoding scheme to use\n     * @throws java.io.UnsupportedEncodingException\n     *          if string encoding failed\n     * @see #queryProperties\n     */\n    protected void appendQueryProperties(StringBuffer targetUrl, Map model, String encodingScheme)\n            throws UnsupportedEncodingException {\n\n        // Extract anchor fragment, if any.\n        // The following code does not use JDK 1.4's StringBuffer.indexOf(String)\n        // method to retain JDK 1.3 compatibility.\n        String fragment = null;\n        int anchorIndex = targetUrl.toString().indexOf('#');\n        if (anchorIndex > -1) {\n            fragment = targetUrl.substring(anchorIndex);\n            targetUrl.delete(anchorIndex, targetUrl.length());\n        }\n\n        // If there aren't already some parameters, we need a \"?\".\n        boolean first = (getUrl().indexOf('?') < 0);\n        Iterator entries = queryProperties(model).entrySet().iterator();\n        while (entries.hasNext()) {\n            if (first) {\n                targetUrl.append('?');\n                first = false;\n            } else {\n                targetUrl.append('&');\n            }\n            Map.Entry entry = (Map.Entry) entries.next();\n            String encodedKey = urlEncode(entry.getKey().toString(), encodingScheme);\n            String encodedValue =\n                    (entry.getValue() != null ? urlEncode(entry.getValue().toString(), encodingScheme) : \"\");\n            targetUrl.append(encodedKey).append('=').append(encodedValue);\n        }\n\n        // Append anchor fragment, if any, to end of URL.\n        if (fragment != null) {\n            targetUrl.append(fragment);\n        }\n    }\n\n    /**\n     * URL-encode the given input String with the given encoding scheme.\n     * <p>Default implementation uses <code>URLEncoder.encode(input, enc)<\/code>\n     * on JDK 1.4+, falling back to <code>URLEncoder.encode(input)<\/code>\n     * (which uses the platform default encoding) on JDK 1.3.\n     *\n     * @param input          the unencoded input String\n     * @param encodingScheme the encoding scheme\n     * @return the encoded output String\n     * @throws UnsupportedEncodingException if thrown by the JDK URLEncoder\n     * @see java.net.URLEncoder#encode(String, String)\n     * @see java.net.URLEncoder#encode(String)\n     */\n    protected String urlEncode(String input, String encodingScheme) throws UnsupportedEncodingException {\n        if (!JavaEnvironment.isAtLeastVersion14()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Only JDK 1.3 URLEncoder available: using platform default encoding \" +\n                        \"instead of the requested scheme '\" + encodingScheme + \"'\");\n            }\n            return URLEncoder.encode(input);\n        }\n        return URLEncoder.encode(input, encodingScheme);\n    }\n\n    /**\n     * Determine name-value pairs for query strings, which will be stringified,\n     * URL-encoded and formatted by appendQueryProperties.\n     * <p>This implementation returns all model elements as-is.\n     *\n     * @see #appendQueryProperties\n     */\n    protected Map queryProperties(Map model) {\n        return model;\n    }\n\n    /**\n     * Send a redirect back to the HTTP client\n     *\n     * @param request          current HTTP request (allows for reacting to request method)\n     * @param response         current HTTP response (for sending response headers)\n     * @param targetUrl        the name URL to redirect to\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients\n     * @throws IOException if thrown by response methods\n     */\n    protected void sendRedirect(\n            HttpServletRequest request, HttpServletResponse response, String targetUrl, boolean http10Compatible)\n            throws IOException {\n\n        if (http10Compatible) {\n            // Always send status code 302.\n            response.sendRedirect(response.encodeRedirectURL(targetUrl));\n\t\t}\n\t\telse {\n\t\t\t// Correct HTTP status code is 303, in particular for POST requests.\n\t\t\tresponse.setStatus(303);\n\t\t\tresponse.setHeader(\"Location\", response.encodeRedirectURL(targetUrl));\n\t\t}\n\t}\n\n}\n","lineNo":227}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.realm.activedirectory;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authz.AuthorizingAccount;\nimport org.jsecurity.authz.SimpleAuthorizingAccount;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.realm.ldap.AbstractLdapRealm;\nimport org.jsecurity.realm.ldap.LdapContextFactory;\nimport org.jsecurity.realm.ldap.LdapUtils;\nimport org.jsecurity.subject.PrincipalCollection;\n\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.naming.ldap.LdapContext;\nimport java.util.*;\n\n/**\n * <p>An {@link Realm} that authenticates with an active directory LDAP\n * server to determine the roles for a particular user.  This implementation\n * queries for the user's groups and then maps the group names to roles using the\n * {@link #groupRolesMap}.<\/p>\n *\n * @author Tim Veil\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class ActiveDirectoryRealm extends AbstractLdapRealm {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    private static final String ROLE_NAMES_DELIMETER = \",\";\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n\n    /**\n     * Mapping from fully qualified active directory\n     * group names (e.g. CN=Group,OU=Company,DC=MyDomain,DC=local)\n     * as returned by the active directory LDAP server to role names.\n     */\n    private Map<String, String> groupRolesMap;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    public void setGroupRolesMap(Map<String, String> groupRolesMap) {\n        this.groupRolesMap = groupRolesMap;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n\n    /**\n     * <p>Builds an {@link org.jsecurity.authc.Account} object by querying the active directory LDAP context for the\n     * specified username.  This method binds to the LDAP server using the provided username and password -\n     * which if successful, indicates that the password is correct.<\/p>\n     *\n     * <p>This method can be overridden by subclasses to query the LDAP server in a more complex way.<\/p>\n     *\n     * @param token              the authentication token provided by the user.\n     * @param ldapContextFactory the factory used to build connections to the LDAP server.\n     * @return an {@link org.jsecurity.authc.Account} instance containing information retrieved from LDAP\n     *         that can be used to build an {@link org.jsecurity.authc.Account} instance to return.\n     * @throws NamingException if any LDAP errors occur during the search.\n     */\n    protected Account queryForLdapAccount(AuthenticationToken token, LdapContextFactory ldapContextFactory) throws NamingException {\n\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n\n        // Binds using the username and password provided by the user.\n        LdapContext ctx = null;\n        try {\n            ctx = ldapContextFactory.getLdapContext(upToken.getUsername(), String.valueOf(upToken.getPassword()));\n        } finally {\n            LdapUtils.closeContext(ctx);\n        }\n\n        return createAccount(upToken.getUsername(), upToken.getPassword());\n    }\n\n    protected Account createAccount(String username, char[] password) {\n        return new SimpleAuthorizingAccount(username, password, getName());\n    }\n\n\n    /**\n     * <p>Builds an {@link org.jsecurity.authz.AuthorizingAccount} object by querying the active directory LDAP context for the\n     * groups that a user is a member of.  The groups are then translated to role names by using the\n     * configured {@link #groupRolesMap}.<\/p>\n     *\n     * <p>This implementation expects the <tt>principal<\/tt> argument to be a String username.\n     *\n     * <p>Subclasses can override this method to determine authorization data (roles, permissions, etc) in a more\n     * complex way.  Note that this default implementation does not support permissions, only roles.<\/p>\n     *\n     * @param principals         the principal of the Subject whose Account is being retrieved.\n     * @param ldapContextFactory the factory used to create LDAP connections.\n     * @return the Account for the given Subject principal.\n     * @throws NamingException if an error occurs when searching the LDAP server.\n     */\n    protected AuthorizingAccount queryForLdapAccount(PrincipalCollection principals, LdapContextFactory ldapContextFactory) throws NamingException {\n\n        String username;\n\n\n        username = (String) principals.fromRealm(getName()).iterator().next();\n\n        // Perform context search\n        LdapContext ldapContext = ldapContextFactory.getSystemLdapContext();\n\n        Set<String> roleNames;\n\n        try {\n            roleNames = getRoleNamesForUser(username, ldapContext);\n        } finally {\n            LdapUtils.closeContext(ldapContext);\n        }\n\n        return new SimpleAuthorizingAccount(username, null, getName(), roleNames, null);\n    }\n\n    private Set<String> getRoleNamesForUser(String username, LdapContext ldapContext) throws NamingException {\n        Set<String> roleNames;\n        roleNames = new LinkedHashSet<String>();\n\n        SearchControls searchCtls = new SearchControls();\n        searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        String userPrincipalName = username;\n        if( principalSuffix != null ) {\n            userPrincipalName += principalSuffix;\n        }\n\n        String searchFilter = \"(&(objectClass=*)(userPrincipalName=\" + userPrincipalName + \"))\";\n\n        NamingEnumeration answer = ldapContext.search(searchBase, searchFilter, searchCtls);\n\n        while (answer.hasMoreElements()) {\n            SearchResult sr = (SearchResult) answer.next();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Retrieving group names for user [\" + sr.getName() + \"]\");\n            }\n\n            Attributes attrs = sr.getAttributes();\n\n            if (attrs != null) {\n                NamingEnumeration ae = attrs.getAll();\n                while (ae.hasMore()) {\n                    Attribute attr = (Attribute) ae.next();\n\n                    if (attr.getID().equals(\"memberOf\")) {\n\n                        Collection<String> groupNames = LdapUtils.getAllAttributeValues(attr);\n\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Groups found for user [\" + username + \"]: \" + groupNames);\n                        }\n\n                        Collection<String> rolesForGroups = getRoleNamesForGroups(groupNames);\n                        roleNames.addAll(rolesForGroups);\n                    }\n                }\n            }\n        }\n        return roleNames;\n    }\n\n    /**\n     * This method is called by the default implementation to translate Active Directory group names\n     * to role names.  This implementation uses the {@link #groupRolesMap} to map group names to role names.\n     *\n     * @param groupNames the group names that apply to the current user.\n     * @return a collection of roles that are implied by the given role names.\n     */\n    protected Collection<String> getRoleNamesForGroups(Collection<String> groupNames) {\n        Set<String> roleNames = new HashSet<String>(groupNames.size());\n\n        if (groupRolesMap != null) {\n            for (String groupName : groupNames) {\n                String strRoleNames = groupRolesMap.get(groupName);\n                if (strRoleNames != null) {\n                    for (String roleName : strRoleNames.split(ROLE_NAMES_DELIMETER)) {\n\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"User is member of group [\" + groupName + \"] so adding role [\" + roleName + \"]\");\n                        }\n\n                        roleNames.add(roleName);\n\n                    }\n                }\n            }\n        }\n        return roleNames;\n    }\n\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.realm.activedirectory;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authz.AuthorizingAccount;\nimport org.jsecurity.authz.SimpleAuthorizingAccount;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.realm.ldap.AbstractLdapRealm;\nimport org.jsecurity.realm.ldap.LdapContextFactory;\nimport org.jsecurity.realm.ldap.LdapUtils;\nimport org.jsecurity.subject.PrincipalCollection;\n\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.naming.ldap.LdapContext;\nimport java.util.*;\n\n/**\n * <p>An {@link Realm} that authenticates with an active directory LDAP\n * server to determine the roles for a particular user.  This implementation\n * queries for the user's groups and then maps the group names to roles using the\n * {@link #groupRolesMap}.<\/p>\n *\n * @author Tim Veil\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class ActiveDirectoryRealm extends AbstractLdapRealm {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    private static final String ROLE_NAMES_DELIMETER = \",\";\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n\n    /**\n     * Mapping from fully qualified active directory\n     * group names (e.g. CN=Group,OU=Company,DC=MyDomain,DC=local)\n     * as returned by the active directory LDAP server to role names.\n     */\n    private Map<String, String> groupRolesMap;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    public void setGroupRolesMap(Map<String, String> groupRolesMap) {\n        this.groupRolesMap = groupRolesMap;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n\n    /**\n     * <p>Builds an {@link org.jsecurity.authc.Account} object by querying the active directory LDAP context for the\n     * specified username.  This method binds to the LDAP server using the provided username and password -\n     * which if successful, indicates that the password is correct.<\/p>\n     *\n     * <p>This method can be overridden by subclasses to query the LDAP server in a more complex way.<\/p>\n     *\n     * @param token              the authentication token provided by the user.\n     * @param ldapContextFactory the factory used to build connections to the LDAP server.\n     * @return an {@link org.jsecurity.authc.Account} instance containing information retrieved from LDAP\n     *         that can be used to build an {@link org.jsecurity.authc.Account} instance to return.\n     * @throws NamingException if any LDAP errors occur during the search.\n     */\n    protected Account queryForLdapAccount(AuthenticationToken token, LdapContextFactory ldapContextFactory) throws NamingException {\n\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n\n        // Binds using the username and password provided by the user.\n        LdapContext ctx = null;\n        try {\n            ctx = ldapContextFactory.getLdapContext(upToken.getUsername(), String.valueOf(upToken.getPassword()));\n        } finally {\n            LdapUtils.closeContext(ctx);\n        }\n\n        return createAccount(upToken.getUsername(), upToken.getPassword());\n    }\n\n    protected Account createAccount(String username, char[] password) {\n        return new SimpleAuthorizingAccount(username, password, getName());\n    }\n\n\n    /**\n     * <p>Builds an {@link org.jsecurity.authz.AuthorizingAccount} object by querying the active directory LDAP context for the\n     * groups that a user is a member of.  The groups are then translated to role names by using the\n     * configured {@link #groupRolesMap}.<\/p>\n     *\n     * <p>This implementation expects the <tt>principal<\/tt> argument to be a String username.\n     *\n     * <p>Subclasses can override this method to determine authorization data (roles, permissions, etc) in a more\n     * complex way.  Note that this default implementation does not support permissions, only roles.<\/p>\n     *\n     * @param principals         the principal of the Subject whose Account is being retrieved.\n     * @param ldapContextFactory the factory used to create LDAP connections.\n     * @return the Account for the given Subject principal.\n     * @throws NamingException if an error occurs when searching the LDAP server.\n     */\n    protected AuthorizingAccount queryForLdapAccount(PrincipalCollection principals, LdapContextFactory ldapContextFactory) throws NamingException {\n\n        String username;\n\n\n        username = (String) principals.fromRealm(getName()).iterator().next();\n\n        // Perform context search\n        LdapContext ldapContext = ldapContextFactory.getSystemLdapContext();\n\n        Set<String> roleNames;\n\n        try {\n            roleNames = getRoleNamesForUser(username, ldapContext);\n        } finally {\n            LdapUtils.closeContext(ldapContext);\n        }\n\n        return new SimpleAuthorizingAccount(username, null, getName(), roleNames, null);\n    }\n\n    private Set<String> getRoleNamesForUser(String username, LdapContext ldapContext) throws NamingException {\n        Set<String> roleNames;\n        roleNames = new LinkedHashSet<String>();\n\n        SearchControls searchCtls = new SearchControls();\n        searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        String searchFilter = \"(&(objectClass=*)(userPrincipalName=\" + username + \"))\";\n\n        NamingEnumeration answer = ldapContext.search(searchBase, searchFilter, searchCtls);\n\n        while (answer.hasMoreElements()) {\n            SearchResult sr = (SearchResult) answer.next();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Retrieving group names for user [\" + sr.getName() + \"]\");\n            }\n\n            Attributes attrs = sr.getAttributes();\n\n            if (attrs != null) {\n                NamingEnumeration ae = attrs.getAll();\n                while (ae.hasMore()) {\n                    Attribute attr = (Attribute) ae.next();\n\n                    if (attr.getID().equals(\"memberOf\")) {\n\n                        Collection<String> groupNames = LdapUtils.getAllAttributeValues(attr);\n\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Groups found for user [\" + username + \"]: \" + groupNames);\n                        }\n\n                        Collection<String> rolesForGroups = getRoleNamesForGroups(groupNames);\n                        roleNames.addAll(rolesForGroups);\n                    }\n                }\n            }\n        }\n        return roleNames;\n    }\n\n    /**\n     * This method is called by the default implementation to translate Active Directory group names\n     * to role names.  This implementation uses the {@link #groupRolesMap} to map group names to role names.\n     *\n     * @param groupNames the group names that apply to the current user.\n     * @return a collection of roles that are implied by the given role names.\n     */\n    protected Collection<String> getRoleNamesForGroups(Collection<String> groupNames) {\n        Set<String> roleNames = new HashSet<String>(groupNames.size());\n\n        if (groupRolesMap != null) {\n            for (String groupName : groupNames) {\n                String strRoleNames = groupRolesMap.get(groupName);\n                if (strRoleNames != null) {\n                    for (String roleName : strRoleNames.split(ROLE_NAMES_DELIMETER)) {\n\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"User is member of group [\" + groupName + \"] so adding role [\" + roleName + \"]\");\n                        }\n\n                        roleNames.add(roleName);\n\n                    }\n                }\n            }\n        }\n        return roleNames;\n    }\n\n\n}\n","lineNo":159}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity;\n\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.ThreadContext;\n\n/**\n * Accesses the currently accessible <tt>Subject<\/tt> for the calling code depending on runtime environment.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic abstract class SecurityUtils {\n\n    /**\n     * ONLY used as a 'backup' in VM Singleton environments (that is, standalone environments), since the\n     * ThreadContext should always be the primary source for Subject instances when possible.\n     */\n    private static SecurityManager securityManager;\n\n    /**\n     * Returns the currently accessible <tt>Subject<\/tt> available to the calling code depending on\n     * runtime environment.\n     *\n     * <p>This method is provided as a way of obtaining a <tt>Subject<\/tt> without having to resort to\n     * implementation-specific methods.  It also allows the JSecurity team to change the underlying implementation of\n     * this method in the future depending on requirements/updates without affecting your code that uses it.\n     *\n     * @return the currently accessible <tt>Subject<\/tt> accessible to the calling code.\n     */\n    public static Subject getSubject() {\n        Subject subject;\n        SecurityManager securityManager = ThreadContext.getSecurityManager();\n        if (securityManager != null) {\n            subject = securityManager.getSubject();\n        } else {\n            subject = ThreadContext.getSubject();\n            if (subject == null && SecurityUtils.securityManager != null) {\n                //fall back to the VM singleton if one exists:\n                subject = SecurityUtils.securityManager.getSubject();\n            }\n        }\n        return subject;\n    }\n\n    /**\n     * Sets a VM (static) singleton SecurityManager, specifically for transparent use in the\n     * {@link #getSubject() getSubject()} implementation.\n     *\n     * <p><b>This method call exists mainly for framework development support.  Application developers should rarely,\n     * if ever, need to call this method.<\/b><\/p>\n     *\n     * <p>The JSecurity development team prefers that SecurityManager instances are non-static application singletons\n     * and <em>not<\/em> VM static singletons.  Application singletons that do not use static memory require some sort\n     * of application configuration framework to maintain the application-wide SecurityManager instance for you\n     * (for example, Spring or EJB3 environments) such that the object reference does not need to be static.\n     *\n     * <p>In these environments, JSecurity acquires Subject data based on the currently executing Thread via its own\n     * framework integration code, and this is the preferred way to use JSecurity.<\/p>\n     *\n     * <p>However in some environments, such as a standalone desktop application or Applets that do not use Spring or\n     * EJB or similar config frameworks, a VM-singleton might make more sense (although the former is still preferred).<\/p>\n     * In these environments, setting the SecurityManager via this method will automatically enable the\n     * {@link #getSubject() getSubject()} call to function with little configuration.<\/p>\n     *\n     * <p>For example, in these environments, this will work:<\/p>\n     *\n     * <pre>       DefaultSecurityManager securityManager = new {@link org.jsecurity.mgt.DefaultSecurityManager DefaultSecurityManager}();\n     * securityManager.setRealms( ... ); //one or more Realms\n     * securityManager.init();\n     * <b>SecurityUtils.setSecurityManager( securityManager );<\/b><\/pre>\n     *\n     * <p>And then anywhere in the application code, the following call will return the application's Subject:<\/p>\n     *\n     * <pre>Subject currentUser = SecurityUtils.getSubject()<\/pre>\n     *\n     * <p>by calling the VM static {@link org.jsecurity.mgt.SecurityManager#getSubject() securityManager.getSubject()}\n     * method.  Note that the underlying injected SecurityManager still needs to know how to acquire a Subject\n     * instance for the calling code, which might mean from static memory, or a config file, or other\n     * environment-specific means.<\/p>\n     *\n     * @param securityManager\n     */\n    public static void setSecurityManager(SecurityManager securityManager) {\n        SecurityUtils.securityManager = securityManager;\n    }\n\n    /**\n     * Returns the VM (static) singleton SecurityManager.\n     *\n     * <p>This method is <b>only used in rare occasions<\/b>.  Please read the {@link #setSecurityManager setSecurityManager}\n     * JavaDoc for usage patterns.\n     *\n     * @return the VM (static) singleton SecurityManager, used only on rare occasions.\n     */\n    public static SecurityManager getSecurityManager() {\n        return SecurityUtils.securityManager;\n    }\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity;\n\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.ThreadContext;\n\n/**\n * Accesses the currently accessible <tt>Subject<\/tt> for the calling code depending on runtime environment.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic abstract class SecurityUtils {\n\n    /**\n     * ONLY used as a 'backup' in VM Singleton environments (that is, standalone environments), since the\n     * ThreadContext should always be the primary source for Subject instances when possible.\n     */\n    private static SecurityManager securityManager;\n\n    /**\n     * Returns the currently accessible <tt>Subject<\/tt> available to the calling code depending on\n     * runtime environment.\n     *\n     * <p>This method is provided as a way of obtaining a <tt>Subject<\/tt> without having to resort to\n     * implementation-specific methods.  It also allows the JSecurity team to change the underlying implementation of\n     * this method in the future depending on requirements/updates without affecting your code that uses it.\n     *\n     * @return the currently accessible <tt>Subject<\/tt> accessible to the calling code.\n     */\n    public static Subject getSubject() {\n        Subject subject = ThreadContext.getSubject();\n        //try from VM singleton if there is one:\n        if (subject == null && SecurityUtils.securityManager != null) {\n            subject = SecurityUtils.securityManager.getSubject();\n        }\n        return subject;\n    }\n\n    /**\n     * Sets a VM (static) singleton SecurityManager, specifically for transparent use in the\n     * {@link #getSubject() getSubject()} implementation.\n     *\n     * <p><b>This method call exists mainly for framework development support.  Application developers should rarely,\n     * if ever, need to call this method.<\/b><\/p>\n     *\n     * <p>The JSecurity development team prefers that SecurityManager instances are non-static application singletons\n     * and <em>not<\/em> VM static singletons.  Application singletons that do not use static memory require some sort\n     * of application configuration framework to maintain the application-wide SecurityManager instance for you\n     * (for example, Spring or EJB3 environments) such that the object reference does not need to be static.\n     *\n     * <p>In these environments, JSecurity acquires Subject data based on the currently executing Thread via its own\n     * framework integration code, and this is the preferred way to use JSecurity.<\/p>\n     *\n     * <p>However in some environments, such as a standalone desktop application or Applets that do not use Spring or\n     * EJB or similar config frameworks, a VM-singleton might make more sense (although the former is still preferred).<\/p>\n     * In these environments, setting the SecurityManager via this method will automatically enable the\n     * {@link #getSubject() getSubject()} call to function with little configuration.<\/p>\n     *\n     * <p>For example, in these environments, this will work:<\/p>\n     *\n     * <pre>       DefaultSecurityManager securityManager = new {@link org.jsecurity.mgt.DefaultSecurityManager DefaultSecurityManager}();\n     * securityManager.setRealms( ... ); //one or more Realms\n     * securityManager.init();\n     * <b>SecurityUtils.setSecurityManager( securityManager );<\/b><\/pre>\n     *\n     * <p>And then anywhere in the application code, the following call will return the application's Subject:<\/p>\n     *\n     * <pre>Subject currentUser = SecurityUtils.getSubject()<\/pre>\n     *\n     * <p>by calling the VM static {@link org.jsecurity.mgt.SecurityManager#getSubject() securityManager.getSubject()}\n     * method.  Note that the underlying injected SecurityManager still needs to know how to acquire a Subject\n     * instance for the calling code, which might mean from static memory, or a config file, or other\n     * environment-specific means.<\/p>\n     *\n     * @param securityManager\n     */\n    public static void setSecurityManager(SecurityManager securityManager) {\n        SecurityUtils.securityManager = securityManager;\n    }\n\n    /**\n     * Returns the VM (static) singleton SecurityManager.\n     *\n     * <p>This method is <b>only used in rare occasions<\/b>.  Please read the {@link #setSecurityManager setSecurityManager}\n     * JavaDoc for usage patterns.\n     *\n     * @return the VM (static) singleton SecurityManager, used only on rare occasions.\n     */\n    public static SecurityManager getSecurityManager() {\n        return SecurityUtils.securityManager;\n    }\n}\n","lineNo":48}
{"Refactored Sample":"/*\n * Copyright 2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web.config;\n\nimport org.jsecurity.config.ConfigurationException;\nimport org.jsecurity.config.IniConfiguration;\nimport org.jsecurity.config.ReflectionBuilder;\nimport org.jsecurity.mgt.RealmSecurityManager;\nimport org.jsecurity.util.AntPathMatcher;\nimport static org.jsecurity.util.StringUtils.split;\nimport org.jsecurity.web.DefaultWebSecurityManager;\nimport static org.jsecurity.web.WebUtils.getPathWithinApplication;\nimport static org.jsecurity.web.WebUtils.toHttp;\nimport org.jsecurity.web.filter.PathConfigProcessor;\nimport org.jsecurity.web.filter.authc.BasicHttpAuthenticationFilter;\nimport org.jsecurity.web.filter.authc.FormAuthenticationFilter;\nimport org.jsecurity.web.filter.authz.PermissionsAuthorizationFilter;\nimport org.jsecurity.web.filter.authz.RolesAuthorizationFilter;\nimport org.jsecurity.web.servlet.AdviceFilter;\nimport org.jsecurity.web.servlet.FilterChainWrapper;\n\nimport javax.servlet.*;\nimport java.util.*;\n\n/**\n * TODO - Class JavaDoc\n *\n * @author Les Hazlewood\n * @since Jun 1, 2008 11:02:44 PM\n */\npublic class IniWebConfiguration extends IniConfiguration implements WebConfiguration {\n\n    public static final String FILTERS = \"filters\";\n    public static final String URLS = \"urls\";\n\n    protected FilterConfig filterConfig;\n\n    protected Map<String, List<Filter>> chains;\n\n    protected AntPathMatcher pathMatcher = new AntPathMatcher();\n\n    public IniWebConfiguration() {\n        chains = new LinkedHashMap<String, List<Filter>>();\n    }\n\n    public FilterConfig getFilterConfig() {\n        return filterConfig;\n    }\n\n    public void setFilterConfig(FilterConfig filterConfig) {\n        this.filterConfig = filterConfig;\n    }\n\n    public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) {\n        if (this.chains == null || this.chains.isEmpty()) {\n            return null;\n        }\n\n        String requestURI = getPathWithinApplication(toHttp(request));\n\n        for (String path : this.chains.keySet()) {\n\n            // If the path does match, then pass on to the subclass implementation for specific checks:\n            if (pathMatcher.match(path, requestURI)) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Matched path [\" + path + \"] for requestURI [\" + requestURI + \"].  \" +\n                            \"Utilizing corresponding filter chain...\");\n                }\n                List<Filter> pathFilters = this.chains.get(path);\n                if (pathFilters != null && !pathFilters.isEmpty()) {\n                    return new FilterChainWrapper(originalChain, pathFilters);\n                }\n            }\n        }\n\n        return null;\n    }\n\n    protected RealmSecurityManager newSecurityManagerInstance() {\n        return new DefaultWebSecurityManager();\n    }\n\n    /**\n     * 1.  First builds the filter instances.\n     * 2.  Applys url mappings to these filters\n     * 3.  Creates a collection of Filter chains (list of Filter objects) that will be used by the JSecurityFilter.\n     *\n     * @param sections\n     */\n    protected void afterSecurityManagerSet(Map<String, Map<String, String>> sections) {\n        //filters section:\n        Map<String, String> section = sections.get(FILTERS);\n        Map<String, Filter> filters = getFilters(section);\n\n        //urls section:\n        section = sections.get(URLS);\n        this.chains = createChains(section, filters);\n\n        initFilters(this.chains);\n    }\n\n    protected void initFilters(Map<String, List<Filter>> chains) {\n        if (chains == null || chains.isEmpty()) {\n            return;\n        }\n\n        //add 'em to a set so we only initialize each one once:\n        Set<Filter> filters = new LinkedHashSet<Filter>();\n        for (List<Filter> pathFilters : chains.values()) {\n            filters.addAll(pathFilters);\n        }\n\n        //now initialize each one:\n        for (Filter filter : filters) {\n            initFilter(filter);\n        }\n    }\n\n    /**\n     * Initializes the filter by calling <code>filter.init( {@link #getFilterConfig() getFilterConfig()} );<\/code>.\n     *\n     * @param filter the filter to initialize with the <code>FilterConfig<\/code>.\n     */\n    protected void initFilter(Filter filter) {\n        try {\n            filter.init(getFilterConfig());\n        } catch (ServletException e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    protected Map<String, Filter> getFilters(Map<String, String> section) {\n\n        Map<String, Filter> filters = createDefaultFilters();\n\n        if (section != null && !section.isEmpty()) {\n            ReflectionBuilder builder = new ReflectionBuilder(filters);\n            Map built = builder.buildObjects(section);\n            assertFilters(built);\n            filters = (Map<String, Filter>) built;\n        }\n\n        return filters;\n    }\n\n    protected void assertFilters(Map<String, ?> map) {\n        if (map == null || map.isEmpty()) {\n            return;\n        }\n        for (Map.Entry<String, ?> entry : map.entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            assertFilter(key, value);\n        }\n    }\n\n    protected void assertFilter(String name, Object o) throws ConfigurationException {\n        if (!(o instanceof Filter)) {\n            String msg = \"[\" + FILTERS + \"] section specified a filter named '\" + name + \"', which does not \" +\n                    \"implement the \" + Filter.class.getName() + \" interface.  Only Filter implementations may be \" +\n                    \"defined.\";\n            throw new ConfigurationException(msg);\n        }\n    }\n\n    protected Map<String, Filter> createDefaultFilters() {\n        Map<String, Filter> filters = new LinkedHashMap<String, Filter>();\n\n        String name = \"authc\";\n        AdviceFilter filter = new FormAuthenticationFilter();\n        filter.setName(name);\n        filters.put(name, filter );\n        \n        name = \"authcBasic\";\n        filter = new BasicHttpAuthenticationFilter();\n        filter.setName(name);\n        filters.put(name,filter);\n\n        name = \"roles\";\n        filter = new RolesAuthorizationFilter();\n        filter.setName(name);\n        filters.put(name,filter);\n\n        name = \"perms\";\n        filter = new PermissionsAuthorizationFilter();\n        filter.setName(name);\n        filters.put(name,filter);\n\n        return filters;\n    }\n\n    public Map<String, List<Filter>> createChains(Map<String, String> urls, Map<String, Filter> filters) {\n        if (urls == null || urls.isEmpty()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No urls to process.\");\n            }\n            return null;\n        }\n        if (filters == null || filters.isEmpty()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No filters to process.\");\n            }\n            return null;\n        }\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Before url processing.\");\n        }\n\n        Map<String, List<Filter>> pathChains = new LinkedHashMap<String, List<Filter>>(urls.size());\n\n        for (Map.Entry<String, String> entry : urls.entrySet()) {\n            String path = entry.getKey();\n            String value = entry.getValue();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Processing path [\" + path + \"] with value [\" + value + \"]\");\n            }\n\n            List<Filter> pathFilters = new ArrayList<Filter>();\n\n            //parse the value by tokenizing it to get the resulting filter-specific config entries\n            //\n            //e.g. for a value of\n            //\n            //     \"authc, roles[admin,user], perms[file:edit]\"\n            //\n            // the resulting token array would equal\n            //\n            //     { \"authc\", \"roles[admin,user]\", \"perms[file:edit]\" }\n            //\n            String[] filterTokens = split(value, ',', '[', ']', true, true);\n\n            //each token is specific to each filter.\n            //strip the name and extract any filter-specific config between brackets [ ]\n            for (String token : filterTokens) {\n                String[] nameAndConfig = token.split(\"\\\\[\", 2);\n                String name = nameAndConfig[0];\n                String config = null;\n\n                if (nameAndConfig.length == 2) {\n                    config = nameAndConfig[1];\n                    //if there was an open bracket, there was a close bracket, so strip it too:\n                    config = config.substring(0, config.length() - 1);\n                }\n\n                //now we have the filter name, path and (possibly null) path-specific config.  Let's apply them:\n                Filter filter = filters.get(name);\n                if (filter == null) {\n                    String msg = \"Path [\" + path + \"] specified a filter named '\" + name + \"', but that \" +\n                            \"filter has not been specified in the [\" + FILTERS + \"] section.\";\n                    throw new ConfigurationException(msg);\n                }\n                if (filter instanceof PathConfigProcessor) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Applying path [\" + path + \"] to filter [\" + name + \"] \" +\n                                \"with config [\" + config + \"]\");\n                    }\n                    ((PathConfigProcessor) filter).processPathConfig(path, config);\n                }\n\n                pathFilters.add(filter);\n            }\n\n            if (!pathFilters.isEmpty()) {\n                pathChains.put(path, pathFilters);\n            }\n        }\n\n        if (pathChains.isEmpty()) {\n            return null;\n        }\n\n        return pathChains;\n    }\n}\n","Smelly Sample":"/*\n * Copyright 2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web.config;\n\nimport org.jsecurity.config.ConfigurationException;\nimport org.jsecurity.config.IniConfiguration;\nimport org.jsecurity.config.ReflectionBuilder;\nimport org.jsecurity.mgt.RealmSecurityManager;\nimport org.jsecurity.util.AntPathMatcher;\nimport static org.jsecurity.util.StringUtils.split;\nimport org.jsecurity.web.DefaultWebSecurityManager;\nimport static org.jsecurity.web.WebUtils.getPathWithinApplication;\nimport static org.jsecurity.web.WebUtils.toHttp;\nimport org.jsecurity.web.filter.PathConfigProcessor;\nimport org.jsecurity.web.filter.authc.BasicHttpAuthenticationFilter;\nimport org.jsecurity.web.filter.authc.FormAuthenticationFilter;\nimport org.jsecurity.web.filter.authz.PermissionsAuthorizationFilter;\nimport org.jsecurity.web.filter.authz.RolesAuthorizationFilter;\nimport org.jsecurity.web.servlet.FilterChainWrapper;\n\nimport javax.servlet.*;\nimport java.util.*;\n\n/**\n * TODO - Class JavaDoc\n *\n * @author Les Hazlewood\n * @since Jun 1, 2008 11:02:44 PM\n */\npublic class IniWebConfiguration extends IniConfiguration implements WebConfiguration {\n\n    public static final String FILTERS = \"filters\";\n    public static final String URLS = \"urls\";\n\n    protected FilterConfig filterConfig;\n\n    protected Map<String, List<Filter>> chains;\n\n    protected AntPathMatcher pathMatcher = new AntPathMatcher();\n\n    public IniWebConfiguration() {\n        chains = new LinkedHashMap<String, List<Filter>>();\n    }\n\n    public FilterConfig getFilterConfig() {\n        return filterConfig;\n    }\n\n    public void setFilterConfig(FilterConfig filterConfig) {\n        this.filterConfig = filterConfig;\n    }\n\n    public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) {\n        if (this.chains == null || this.chains.isEmpty()) {\n            return null;\n        }\n\n        String requestURI = getPathWithinApplication(toHttp(request));\n\n        for (String path : this.chains.keySet()) {\n\n            // If the path does match, then pass on to the subclass implementation for specific checks:\n            if (pathMatcher.match(path, requestURI)) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Matched path [\" + path + \"] for requestURI [\" + requestURI + \"].  \" +\n                            \"Utilizing corresponding filter chain...\");\n                }\n                List<Filter> pathFilters = this.chains.get(path);\n                if (pathFilters != null && !pathFilters.isEmpty()) {\n                    return new FilterChainWrapper(originalChain, pathFilters);\n                }\n            }\n        }\n\n        return null;\n    }\n\n    protected RealmSecurityManager newSecurityManagerInstance() {\n        return new DefaultWebSecurityManager();\n    }\n\n    /**\n     * 1.  First builds the filter instances.\n     * 2.  Applys url mappings to these filters\n     * 3.  Creates a collection of Filter chains (list of Filter objects) that will be used by the JSecurityFilter.\n     *\n     * @param sections\n     */\n    protected void afterSecurityManagerSet(Map<String, Map<String, String>> sections) {\n        //filters section:\n        Map<String, String> section = sections.get(FILTERS);\n        Map<String, Filter> filters = getFilters(section);\n\n        //urls section:\n        section = sections.get(URLS);\n        this.chains = createChains(section, filters);\n\n        initFilters(this.chains);\n    }\n\n    protected void initFilters(Map<String, List<Filter>> chains) {\n        if (chains == null || chains.isEmpty()) {\n            return;\n        }\n\n        //add 'em to a set so we only initialize each one once:\n        Set<Filter> filters = new LinkedHashSet<Filter>();\n        for (List<Filter> pathFilters : chains.values()) {\n            filters.addAll(pathFilters);\n        }\n\n        //now initialize each one:\n        for (Filter filter : filters) {\n            initFilter(filter);\n        }\n    }\n\n    /**\n     * Initializes the filter by calling <code>filter.init( {@link #getFilterConfig() getFilterConfig()} );<\/code>.\n     *\n     * @param filter the filter to initialize with the <code>FilterConfig<\/code>.\n     */\n    protected void initFilter(Filter filter) {\n        try {\n            filter.init(getFilterConfig());\n        } catch (ServletException e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    protected Map<String, Filter> getFilters(Map<String, String> section) {\n\n        Map<String, Filter> filters = createDefaultFilters();\n\n        if (section != null && !section.isEmpty()) {\n            ReflectionBuilder builder = new ReflectionBuilder(filters);\n            Map built = builder.buildObjects(section);\n            assertFilters(built);\n            filters = (Map<String, Filter>) built;\n        }\n\n        return filters;\n    }\n\n    protected void assertFilters(Map<String, ?> map) {\n        if (map == null || map.isEmpty()) {\n            return;\n        }\n        for (Map.Entry<String, ?> entry : map.entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            assertFilter(key, value);\n        }\n    }\n\n    protected void assertFilter(String name, Object o) throws ConfigurationException {\n        if (!(o instanceof Filter)) {\n            String msg = \"[\" + FILTERS + \"] section specified a filter named '\" + name + \"', which does not \" +\n                    \"implement the \" + Filter.class.getName() + \" interface.  Only Filter implementations may be \" +\n                    \"defined.\";\n            throw new ConfigurationException(msg);\n        }\n    }\n\n    protected Map<String, Filter> createDefaultFilters() {\n        Map<String, Filter> filters = new LinkedHashMap<String, Filter>();\n        filters.put(\"authc\", new FormAuthenticationFilter());\n        filters.put(\"authcBasic\", new BasicHttpAuthenticationFilter());\n        filters.put(\"roles\", new RolesAuthorizationFilter());\n        filters.put(\"perms\", new PermissionsAuthorizationFilter());\n        return filters;\n    }\n\n    public Map<String, List<Filter>> createChains(Map<String, String> urls, Map<String, Filter> filters) {\n        if (urls == null || urls.isEmpty()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No urls to process.\");\n            }\n            return null;\n        }\n        if (filters == null || filters.isEmpty()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No filters to process.\");\n            }\n            return null;\n        }\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Before url processing.\");\n        }\n\n        Map<String, List<Filter>> pathChains = new LinkedHashMap<String, List<Filter>>(urls.size());\n\n        for (Map.Entry<String, String> entry : urls.entrySet()) {\n            String path = entry.getKey();\n            String value = entry.getValue();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Processing path [\" + path + \"] with value [\" + value + \"]\");\n            }\n\n            List<Filter> pathFilters = new ArrayList<Filter>();\n\n            //parse the value by tokenizing it to get the resulting filter-specific config entries\n            //\n            //e.g. for a value of\n            //\n            //     \"authc, roles[admin,user], perms[file:edit]\"\n            //\n            // the resulting token array would equal\n            //\n            //     { \"authc\", \"roles[admin,user]\", \"perms[file:edit]\" }\n            //\n            String[] filterTokens = split(value, ',', '[', ']', true, true);\n\n            //each token is specific to each filter.\n            //strip the name and extract any filter-specific config between brackets [ ]\n            for (String token : filterTokens) {\n                String[] nameAndConfig = token.split(\"\\\\[\", 2);\n                String name = nameAndConfig[0];\n                String config = null;\n\n                if (nameAndConfig.length == 2) {\n                    config = nameAndConfig[1];\n                    //if there was an open bracket, there was a close bracket, so strip it too:\n                    config = config.substring(0, config.length() - 1);\n                }\n\n                //now we have the filter name, path and (possibly null) path-specific config.  Let's apply them:\n                Filter filter = filters.get(name);\n                if (filter == null) {\n                    String msg = \"Path [\" + path + \"] specified a filter named '\" + name + \"', but that \" +\n                            \"filter has not been specified in the [\" + FILTERS + \"] section.\";\n                    throw new ConfigurationException(msg);\n                }\n                if (filter instanceof PathConfigProcessor) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Applying path [\" + path + \"] to filter [\" + name + \"] \" +\n                                \"with config [\" + config + \"]\");\n                    }\n                    ((PathConfigProcessor) filter).processPathConfig(path, config);\n                }\n\n                pathFilters.add(filter);\n            }\n\n            if (!pathFilters.isEmpty()) {\n                pathChains.put(path, pathFilters);\n            }\n        }\n\n        if (pathChains.isEmpty()) {\n            return null;\n        }\n\n        return pathChains;\n    }\n}\n","lineNo":183}
{"Refactored Sample":"/*\n * Copyright 2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web.config;\n\nimport org.jsecurity.config.ConfigurationException;\nimport org.jsecurity.config.IniConfiguration;\nimport org.jsecurity.config.ReflectionBuilder;\nimport org.jsecurity.mgt.RealmSecurityManager;\nimport org.jsecurity.util.AntPathMatcher;\nimport static org.jsecurity.util.StringUtils.split;\nimport org.jsecurity.web.DefaultWebSecurityManager;\nimport static org.jsecurity.web.WebUtils.getPathWithinApplication;\nimport static org.jsecurity.web.WebUtils.toHttp;\nimport org.jsecurity.web.filter.PathConfigProcessor;\nimport org.jsecurity.web.filter.authc.BasicHttpAuthenticationFilter;\nimport org.jsecurity.web.filter.authc.FormAuthenticationFilter;\nimport org.jsecurity.web.filter.authz.PermissionsAuthorizationFilter;\nimport org.jsecurity.web.filter.authz.RolesAuthorizationFilter;\nimport org.jsecurity.web.servlet.AdviceFilter;\nimport org.jsecurity.web.servlet.FilterChainWrapper;\n\nimport javax.servlet.*;\nimport java.util.*;\n\n/**\n * TODO - Class JavaDoc\n *\n * @author Les Hazlewood\n * @since Jun 1, 2008 11:02:44 PM\n */\npublic class IniWebConfiguration extends IniConfiguration implements WebConfiguration {\n\n    public static final String FILTERS = \"filters\";\n    public static final String URLS = \"urls\";\n\n    protected FilterConfig filterConfig;\n\n    protected Map<String, List<Filter>> chains;\n\n    protected AntPathMatcher pathMatcher = new AntPathMatcher();\n\n    public IniWebConfiguration() {\n        chains = new LinkedHashMap<String, List<Filter>>();\n    }\n\n    public FilterConfig getFilterConfig() {\n        return filterConfig;\n    }\n\n    public void setFilterConfig(FilterConfig filterConfig) {\n        this.filterConfig = filterConfig;\n    }\n\n    public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) {\n        if (this.chains == null || this.chains.isEmpty()) {\n            return null;\n        }\n\n        String requestURI = getPathWithinApplication(toHttp(request));\n\n        for (String path : this.chains.keySet()) {\n\n            // If the path does match, then pass on to the subclass implementation for specific checks:\n            if (pathMatcher.match(path, requestURI)) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Matched path [\" + path + \"] for requestURI [\" + requestURI + \"].  \" +\n                            \"Utilizing corresponding filter chain...\");\n                }\n                List<Filter> pathFilters = this.chains.get(path);\n                if (pathFilters != null && !pathFilters.isEmpty()) {\n                    return new FilterChainWrapper(originalChain, pathFilters);\n                }\n            }\n        }\n\n        return null;\n    }\n\n    protected RealmSecurityManager newSecurityManagerInstance() {\n        return new DefaultWebSecurityManager();\n    }\n\n    /**\n     * 1.  First builds the filter instances.\n     * 2.  Applys url mappings to these filters\n     * 3.  Creates a collection of Filter chains (list of Filter objects) that will be used by the JSecurityFilter.\n     *\n     * @param sections\n     */\n    protected void afterSecurityManagerSet(Map<String, Map<String, String>> sections) {\n        //filters section:\n        Map<String, String> section = sections.get(FILTERS);\n        Map<String, Filter> filters = getFilters(section);\n\n        //urls section:\n        section = sections.get(URLS);\n        this.chains = createChains(section, filters);\n\n        initFilters(this.chains);\n    }\n\n    protected void initFilters(Map<String, List<Filter>> chains) {\n        if (chains == null || chains.isEmpty()) {\n            return;\n        }\n\n        //add 'em to a set so we only initialize each one once:\n        Set<Filter> filters = new LinkedHashSet<Filter>();\n        for (List<Filter> pathFilters : chains.values()) {\n            filters.addAll(pathFilters);\n        }\n\n        //now initialize each one:\n        for (Filter filter : filters) {\n            initFilter(filter);\n        }\n    }\n\n    /**\n     * Initializes the filter by calling <code>filter.init( {@link #getFilterConfig() getFilterConfig()} );<\/code>.\n     *\n     * @param filter the filter to initialize with the <code>FilterConfig<\/code>.\n     */\n    protected void initFilter(Filter filter) {\n        try {\n            filter.init(getFilterConfig());\n        } catch (ServletException e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    protected Map<String, Filter> getFilters(Map<String, String> section) {\n\n        Map<String, Filter> filters = createDefaultFilters();\n\n        if (section != null && !section.isEmpty()) {\n            ReflectionBuilder builder = new ReflectionBuilder(filters);\n            Map built = builder.buildObjects(section);\n            assertFilters(built);\n            filters = (Map<String, Filter>) built;\n        }\n\n        return filters;\n    }\n\n    protected void assertFilters(Map<String, ?> map) {\n        if (map == null || map.isEmpty()) {\n            return;\n        }\n        for (Map.Entry<String, ?> entry : map.entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            assertFilter(key, value);\n        }\n    }\n\n    protected void assertFilter(String name, Object o) throws ConfigurationException {\n        if (!(o instanceof Filter)) {\n            String msg = \"[\" + FILTERS + \"] section specified a filter named '\" + name + \"', which does not \" +\n                    \"implement the \" + Filter.class.getName() + \" interface.  Only Filter implementations may be \" +\n                    \"defined.\";\n            throw new ConfigurationException(msg);\n        }\n    }\n\n    protected Map<String, Filter> createDefaultFilters() {\n        Map<String, Filter> filters = new LinkedHashMap<String, Filter>();\n\n        String name = \"authc\";\n        AdviceFilter filter = new FormAuthenticationFilter();\n        filter.setName(name);\n        filters.put(name, filter );\n        \n        name = \"authcBasic\";\n        filter = new BasicHttpAuthenticationFilter();\n        filter.setName(name);\n        filters.put(name,filter);\n\n        name = \"roles\";\n        filter = new RolesAuthorizationFilter();\n        filter.setName(name);\n        filters.put(name,filter);\n\n        name = \"perms\";\n        filter = new PermissionsAuthorizationFilter();\n        filter.setName(name);\n        filters.put(name,filter);\n\n        return filters;\n    }\n\n    public Map<String, List<Filter>> createChains(Map<String, String> urls, Map<String, Filter> filters) {\n        if (urls == null || urls.isEmpty()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No urls to process.\");\n            }\n            return null;\n        }\n        if (filters == null || filters.isEmpty()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No filters to process.\");\n            }\n            return null;\n        }\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Before url processing.\");\n        }\n\n        Map<String, List<Filter>> pathChains = new LinkedHashMap<String, List<Filter>>(urls.size());\n\n        for (Map.Entry<String, String> entry : urls.entrySet()) {\n            String path = entry.getKey();\n            String value = entry.getValue();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Processing path [\" + path + \"] with value [\" + value + \"]\");\n            }\n\n            List<Filter> pathFilters = new ArrayList<Filter>();\n\n            //parse the value by tokenizing it to get the resulting filter-specific config entries\n            //\n            //e.g. for a value of\n            //\n            //     \"authc, roles[admin,user], perms[file:edit]\"\n            //\n            // the resulting token array would equal\n            //\n            //     { \"authc\", \"roles[admin,user]\", \"perms[file:edit]\" }\n            //\n            String[] filterTokens = split(value, ',', '[', ']', true, true);\n\n            //each token is specific to each filter.\n            //strip the name and extract any filter-specific config between brackets [ ]\n            for (String token : filterTokens) {\n                String[] nameAndConfig = token.split(\"\\\\[\", 2);\n                String name = nameAndConfig[0];\n                String config = null;\n\n                if (nameAndConfig.length == 2) {\n                    config = nameAndConfig[1];\n                    //if there was an open bracket, there was a close bracket, so strip it too:\n                    config = config.substring(0, config.length() - 1);\n                }\n\n                //now we have the filter name, path and (possibly null) path-specific config.  Let's apply them:\n                Filter filter = filters.get(name);\n                if (filter == null) {\n                    String msg = \"Path [\" + path + \"] specified a filter named '\" + name + \"', but that \" +\n                            \"filter has not been specified in the [\" + FILTERS + \"] section.\";\n                    throw new ConfigurationException(msg);\n                }\n                if (filter instanceof PathConfigProcessor) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Applying path [\" + path + \"] to filter [\" + name + \"] \" +\n                                \"with config [\" + config + \"]\");\n                    }\n                    ((PathConfigProcessor) filter).processPathConfig(path, config);\n                }\n\n                pathFilters.add(filter);\n            }\n\n            if (!pathFilters.isEmpty()) {\n                pathChains.put(path, pathFilters);\n            }\n        }\n\n        if (pathChains.isEmpty()) {\n            return null;\n        }\n\n        return pathChains;\n    }\n}\n","Smelly Sample":"/*\n * Copyright 2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web.config;\n\nimport org.jsecurity.config.ConfigurationException;\nimport org.jsecurity.config.IniConfiguration;\nimport org.jsecurity.config.ReflectionBuilder;\nimport org.jsecurity.mgt.RealmSecurityManager;\nimport org.jsecurity.util.AntPathMatcher;\nimport static org.jsecurity.util.StringUtils.split;\nimport org.jsecurity.web.DefaultWebSecurityManager;\nimport static org.jsecurity.web.WebUtils.getPathWithinApplication;\nimport static org.jsecurity.web.WebUtils.toHttp;\nimport org.jsecurity.web.filter.PathConfigProcessor;\nimport org.jsecurity.web.filter.authc.BasicHttpAuthenticationFilter;\nimport org.jsecurity.web.filter.authc.FormAuthenticationFilter;\nimport org.jsecurity.web.filter.authz.PermissionsAuthorizationFilter;\nimport org.jsecurity.web.filter.authz.RolesAuthorizationFilter;\nimport org.jsecurity.web.servlet.FilterChainWrapper;\n\nimport javax.servlet.*;\nimport java.util.*;\n\n/**\n * TODO - Class JavaDoc\n *\n * @author Les Hazlewood\n * @since Jun 1, 2008 11:02:44 PM\n */\npublic class IniWebConfiguration extends IniConfiguration implements WebConfiguration {\n\n    public static final String FILTERS = \"filters\";\n    public static final String URLS = \"urls\";\n\n    protected FilterConfig filterConfig;\n\n    protected Map<String, List<Filter>> chains;\n\n    protected AntPathMatcher pathMatcher = new AntPathMatcher();\n\n    public IniWebConfiguration() {\n        chains = new LinkedHashMap<String, List<Filter>>();\n    }\n\n    public FilterConfig getFilterConfig() {\n        return filterConfig;\n    }\n\n    public void setFilterConfig(FilterConfig filterConfig) {\n        this.filterConfig = filterConfig;\n    }\n\n    public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) {\n        if (this.chains == null || this.chains.isEmpty()) {\n            return null;\n        }\n\n        String requestURI = getPathWithinApplication(toHttp(request));\n\n        for (String path : this.chains.keySet()) {\n\n            // If the path does match, then pass on to the subclass implementation for specific checks:\n            if (pathMatcher.match(path, requestURI)) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Matched path [\" + path + \"] for requestURI [\" + requestURI + \"].  \" +\n                            \"Utilizing corresponding filter chain...\");\n                }\n                List<Filter> pathFilters = this.chains.get(path);\n                if (pathFilters != null && !pathFilters.isEmpty()) {\n                    return new FilterChainWrapper(originalChain, pathFilters);\n                }\n            }\n        }\n\n        return null;\n    }\n\n    protected RealmSecurityManager newSecurityManagerInstance() {\n        return new DefaultWebSecurityManager();\n    }\n\n    /**\n     * 1.  First builds the filter instances.\n     * 2.  Applys url mappings to these filters\n     * 3.  Creates a collection of Filter chains (list of Filter objects) that will be used by the JSecurityFilter.\n     *\n     * @param sections\n     */\n    protected void afterSecurityManagerSet(Map<String, Map<String, String>> sections) {\n        //filters section:\n        Map<String, String> section = sections.get(FILTERS);\n        Map<String, Filter> filters = getFilters(section);\n\n        //urls section:\n        section = sections.get(URLS);\n        this.chains = createChains(section, filters);\n\n        initFilters(this.chains);\n    }\n\n    protected void initFilters(Map<String, List<Filter>> chains) {\n        if (chains == null || chains.isEmpty()) {\n            return;\n        }\n\n        //add 'em to a set so we only initialize each one once:\n        Set<Filter> filters = new LinkedHashSet<Filter>();\n        for (List<Filter> pathFilters : chains.values()) {\n            filters.addAll(pathFilters);\n        }\n\n        //now initialize each one:\n        for (Filter filter : filters) {\n            initFilter(filter);\n        }\n    }\n\n    /**\n     * Initializes the filter by calling <code>filter.init( {@link #getFilterConfig() getFilterConfig()} );<\/code>.\n     *\n     * @param filter the filter to initialize with the <code>FilterConfig<\/code>.\n     */\n    protected void initFilter(Filter filter) {\n        try {\n            filter.init(getFilterConfig());\n        } catch (ServletException e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    protected Map<String, Filter> getFilters(Map<String, String> section) {\n\n        Map<String, Filter> filters = createDefaultFilters();\n\n        if (section != null && !section.isEmpty()) {\n            ReflectionBuilder builder = new ReflectionBuilder(filters);\n            Map built = builder.buildObjects(section);\n            assertFilters(built);\n            filters = (Map<String, Filter>) built;\n        }\n\n        return filters;\n    }\n\n    protected void assertFilters(Map<String, ?> map) {\n        if (map == null || map.isEmpty()) {\n            return;\n        }\n        for (Map.Entry<String, ?> entry : map.entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            assertFilter(key, value);\n        }\n    }\n\n    protected void assertFilter(String name, Object o) throws ConfigurationException {\n        if (!(o instanceof Filter)) {\n            String msg = \"[\" + FILTERS + \"] section specified a filter named '\" + name + \"', which does not \" +\n                    \"implement the \" + Filter.class.getName() + \" interface.  Only Filter implementations may be \" +\n                    \"defined.\";\n            throw new ConfigurationException(msg);\n        }\n    }\n\n    protected Map<String, Filter> createDefaultFilters() {\n        Map<String, Filter> filters = new LinkedHashMap<String, Filter>();\n        filters.put(\"authc\", new FormAuthenticationFilter());\n        filters.put(\"authcBasic\", new BasicHttpAuthenticationFilter());\n        filters.put(\"roles\", new RolesAuthorizationFilter());\n        filters.put(\"perms\", new PermissionsAuthorizationFilter());\n        return filters;\n    }\n\n    public Map<String, List<Filter>> createChains(Map<String, String> urls, Map<String, Filter> filters) {\n        if (urls == null || urls.isEmpty()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No urls to process.\");\n            }\n            return null;\n        }\n        if (filters == null || filters.isEmpty()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No filters to process.\");\n            }\n            return null;\n        }\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Before url processing.\");\n        }\n\n        Map<String, List<Filter>> pathChains = new LinkedHashMap<String, List<Filter>>(urls.size());\n\n        for (Map.Entry<String, String> entry : urls.entrySet()) {\n            String path = entry.getKey();\n            String value = entry.getValue();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Processing path [\" + path + \"] with value [\" + value + \"]\");\n            }\n\n            List<Filter> pathFilters = new ArrayList<Filter>();\n\n            //parse the value by tokenizing it to get the resulting filter-specific config entries\n            //\n            //e.g. for a value of\n            //\n            //     \"authc, roles[admin,user], perms[file:edit]\"\n            //\n            // the resulting token array would equal\n            //\n            //     { \"authc\", \"roles[admin,user]\", \"perms[file:edit]\" }\n            //\n            String[] filterTokens = split(value, ',', '[', ']', true, true);\n\n            //each token is specific to each filter.\n            //strip the name and extract any filter-specific config between brackets [ ]\n            for (String token : filterTokens) {\n                String[] nameAndConfig = token.split(\"\\\\[\", 2);\n                String name = nameAndConfig[0];\n                String config = null;\n\n                if (nameAndConfig.length == 2) {\n                    config = nameAndConfig[1];\n                    //if there was an open bracket, there was a close bracket, so strip it too:\n                    config = config.substring(0, config.length() - 1);\n                }\n\n                //now we have the filter name, path and (possibly null) path-specific config.  Let's apply them:\n                Filter filter = filters.get(name);\n                if (filter == null) {\n                    String msg = \"Path [\" + path + \"] specified a filter named '\" + name + \"', but that \" +\n                            \"filter has not been specified in the [\" + FILTERS + \"] section.\";\n                    throw new ConfigurationException(msg);\n                }\n                if (filter instanceof PathConfigProcessor) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Applying path [\" + path + \"] to filter [\" + name + \"] \" +\n                                \"with config [\" + config + \"]\");\n                    }\n                    ((PathConfigProcessor) filter).processPathConfig(path, config);\n                }\n\n                pathFilters.add(filter);\n            }\n\n            if (!pathFilters.isEmpty()) {\n                pathChains.put(path, pathFilters);\n            }\n        }\n\n        if (pathChains.isEmpty()) {\n            return null;\n        }\n\n        return pathChains;\n    }\n}\n","lineNo":184}
{"Refactored Sample":"/*\n * Copyright 2008 Les Hazlewood and original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n * <p/>\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXST_KEY\";\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     * <p/>\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     * <p/>\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding<\/code>\n     * returns <code>null<\/code>, according to the Servlet spec.\n     * <p/>\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()<\/code> is <i>not<\/i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should<\/i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     * <p/>\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     * <p/>\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()<\/code> is <i>not<\/i>\n     * decoded by the servlet container, this method will decode it.\n     * <p/>\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(org.springframework.web.util.WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)<\/code>.\n     * <p/>\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see org.springframework.web.util.WebUtils#DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({\"deprecation\"})\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        }\n        catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc +\n                        \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request encoding,\n     * falling back to the default encoding specified for this resolver.\n     * <p/>\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null<\/code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    public static InetAddress getInetAddress(ServletRequest request) {\n        InetAddress clientAddress = null;\n        //get the Host/IP the client is coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName(addrString);\n        } catch (UnknownHostException e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to acquire InetAddress from HttpServletRequest\", e);\n            }\n        }\n\n        return clientAddress;\n    }\n\n    public static Subject getSubject(ServletRequest request, ServletResponse response) {\n        return SecurityUtils.getSubject();\n    }\n\n    public static Session getSession(ServletRequest request, ServletResponse response) {\n\n        Session session = null;\n\n        Subject subject = getSubject(request, response);\n\n        if (subject != null) {\n            session = subject.getSession(false);\n        }\n\n        return session;\n    }\n\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    public static void bindInetAddressToThread(ServletRequest request) {\n        InetAddress ip = getInetAddress(request);\n        if (ip != null) {\n            ThreadContext.bind(ip);\n        }\n    }\n\n    public static void unbindInetAddressFromThread() {\n        ThreadContext.unbindInetAddress();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread, this method returns <tt>null<\/tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <pre>\n     * return (ServletRequest)get( SERVLET_REQUEST_KEY );<\/pre>\n     * <p/>\n     * <p>This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread, or <tt>null<\/tt> if there isn't one bound.\n     */\n    public static ServletRequest getServletRequest() {\n        return (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     * <p/>\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null<\/tt>,\n     * it binds it to the thread, i.e.:\n     * <p/>\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, session );\n     * }<\/pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletRequest servletRequest) {\n        if (servletRequest != null) {\n            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     * <p/>\n     * <p>The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <pre>\n     * return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );<\/pre>\n     * <p/>\n     * <p>If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getServletRequest() getServletRequest()} method for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null<\/tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest) ThreadContext.remove(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread, this method returns <tt>null<\/tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <pre>\n     * return (ServletResponse)ThreadContext.get( SERVLET_RESPONSE_KEY );<\/pre>\n     * <p/>\n     * <p>This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread, or <tt>null<\/tt> if there isn't one bound.\n     */\n    public static ServletResponse getServletResponse() {\n        return (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     * <p/>\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null<\/tt>,\n     * it binds it to the thread, i.e.:\n     * <p/>\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, session );\n     * }<\/pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletResponse servletResponse) {\n        if (servletResponse != null) {\n            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     * <p/>\n     * <p>The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <pre>\n     * return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );<\/pre>\n     * <p/>\n     * <p>If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getServletResponse() getServletResponse()} method for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null<\/tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse) ThreadContext.remove(SERVLET_RESPONSE_KEY);\n    }\n}\n","Smelly Sample":"/*\n * Copyright 2008 Les Hazlewood and original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXST_KEY\";\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding<\/code>\n     * returns <code>null<\/code>, according to the Servlet spec.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()<\/code> is <i>not<\/i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should<\/i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()<\/code> is <i>not<\/i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(org.springframework.web.util.WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)<\/code>.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see org.springframework.web.util.WebUtils#DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({\"deprecation\"})\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        }\n        catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc +\n                        \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request encoding,\n     * falling back to the default encoding specified for this resolver.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null<\/code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n\t\tString enc = request.getCharacterEncoding();\n\t\tif (enc == null) {\n\t\t\tenc = DEFAULT_CHARACTER_ENCODING;\n\t\t}\n\t\treturn enc;\n\t}\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread, this method returns <tt>null<\/tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <pre>\n     * return (ServletRequest)get( SERVLET_REQUEST_KEY );<\/pre>\n     *\n     * <p>This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread, or <tt>null<\/tt> if there isn't one bound.\n     */\n    public static ServletRequest getServletRequest() {\n        return (ServletRequest) ThreadContext.get( SERVLET_REQUEST_KEY );\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null<\/tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, session );\n     * }<\/pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind( ServletRequest servletRequest ) {\n        if ( servletRequest != null ) {\n            ThreadContext.put( SERVLET_REQUEST_KEY, servletRequest );\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     *\n     * <p>The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     *\n     * <pre>\n     * return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );<\/pre>\n     *\n     * <p>If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getServletRequest() getServletRequest()} method for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null<\/tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread, this method returns <tt>null<\/tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <pre>\n     * return (ServletResponse)ThreadContext.get( SERVLET_RESPONSE_KEY );<\/pre>\n     *\n     * <p>This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread, or <tt>null<\/tt> if there isn't one bound.\n     */\n    public static ServletResponse getServletResponse() {\n        return (ServletResponse)ThreadContext.get( SERVLET_RESPONSE_KEY );\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null<\/tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, session );\n     * }<\/pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind( ServletResponse servletResponse ) {\n        if ( servletResponse != null ) {\n            ThreadContext.put( SERVLET_RESPONSE_KEY, servletResponse );\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     *\n     * <p>The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     *\n     * <pre>\n     * return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );<\/pre>\n     *\n     * <p>If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getServletResponse() getServletResponse()} method for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null<\/tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );\n    }\n}\n","lineNo":218}
{"Refactored Sample":"package org.jsecurity.web.interceptor.authc;\n\nimport org.jsecurity.JSecurityException;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.web.RedirectView;\nimport org.jsecurity.web.WebUtils;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\n/**\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class FormAuthenticationWebInterceptor extends AuthenticationWebInterceptor {\n\n    public static final String DEFAULT_ERROR_KEY_ATTRIBUTE_NAME = FormAuthenticationWebInterceptor.class.getName() + \"_AUTHC_FAILURE_KEY\";\n\n    public static final String DEFAULT_LOGIN_URL = \"/login.jsp\";\n    public static final String DEFAULT_USERNAME_PARAM = \"username\";\n    public static final String DEFAULT_PASSWORD_PARAM = \"password\";\n    public static final String DEFAULT_REMEMBER_ME_PARAM = \"rememberMe\";\n\n    private String usernameParam = DEFAULT_USERNAME_PARAM;\n    private String passwordParam = DEFAULT_PASSWORD_PARAM;\n    private String rememberMeParam = DEFAULT_REMEMBER_ME_PARAM;\n\n    private String successUrl = DEFAULT_LOGIN_URL;\n    private String failureKeyAtribute = DEFAULT_ERROR_KEY_ATTRIBUTE_NAME;\n\n    public FormAuthenticationWebInterceptor() {\n        setUrl(DEFAULT_LOGIN_URL);\n    }\n\n    public String getUsernameParam() {\n        return usernameParam;\n    }\n\n    public void setUsernameParam(String usernameParam) {\n        this.usernameParam = usernameParam;\n    }\n\n    public String getPasswordParam() {\n        return passwordParam;\n    }\n\n    public void setPasswordParam(String passwordParam) {\n        this.passwordParam = passwordParam;\n    }\n\n    public String getRememberMeParam() {\n        return rememberMeParam;\n    }\n\n    public void setRememberMeParam(String rememberMeParam) {\n        this.rememberMeParam = rememberMeParam;\n    }\n\n    public String getSuccessUrl() {\n        return successUrl;\n    }\n\n    public void setSuccessUrl(String successUrl) {\n        this.successUrl = successUrl;\n    }\n\n    public String getFailureKeyAtribute() {\n        return failureKeyAtribute;\n    }\n\n    public void setFailureKeyAtribute(String failureKeyAtribute) {\n        this.failureKeyAtribute = failureKeyAtribute;\n    }\n\n    public void init() throws JSecurityException {\n        if ( log.isTraceEnabled() ) {\n            log.trace(\"Adding default login url to applied paths.\" );\n        }\n        this.appliedPaths.put(getUrl(),null);\n    }\n\n    protected boolean onUnauthenticatedRequest(ServletRequest request, ServletResponse response) throws Exception {\n        if ( isLoginRequest(request,response) ) {\n            if ( isLoginSubmission(request,response)) {\n                if ( log.isTraceEnabled() ) {\n                    log.trace(\"Login submission detected.  Attempting to execute login.\" );\n                }\n                return executeLogin(request, response);   \n            } else {\n                if ( log.isTraceEnabled() ) {\n                    log.trace(\"Login page view.\");\n                }\n                //allow them to see the login page ;)\n                return true;\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace(\"Attempting to access a path which requires authentication.  Forwarding to the \" +\n                        \"Authentication url [\" + getUrl() + \"]\" );\n            }\n            issueRedirect(request,response);\n            return false;\n        }\n    }\n\n    protected void saveRequest(ServletRequest servletRequest, ServletResponse response ) {\n        //save the page they were trying to visit so we can redirect them back to this location after\n        //a successful login:\n\n        //TODO - JSEC-92\n    }\n\n    protected boolean isLoginSubmission(ServletRequest servletRequest, ServletResponse response ) {\n        return toHttp(servletRequest).getMethod().equalsIgnoreCase(\"POST\");\n    }\n\n    protected boolean isLoginRequest(ServletRequest servletRequest, ServletResponse response ) {\n        HttpServletRequest request = toHttp(servletRequest);\n        String requestURI = WebUtils.getPathWithinApplication(request);\n        return pathMatcher.match( getUrl(), requestURI );\n    }\n\n    protected boolean executeLogin(ServletRequest request, ServletResponse response ) throws Exception {\n        String username = getUsername(request,response);\n        String password = getPassword(request,response);\n        boolean rememberMe = isRememberMe(request,response);\n        InetAddress inet = getInetAddress(request,response);\n\n        char[] passwordChars = null;\n        if( password != null ) {\n            passwordChars = password.toCharArray();\n        }\n\n        UsernamePasswordToken token = new UsernamePasswordToken(username, passwordChars, rememberMe, inet );\n\n        try {\n            getSubject(request,response).login(token);\n            issueSuccessRedirect(request,response);\n            return false;\n        } catch (AuthenticationException e) {\n            String className = e.getClass().getName();\n            request.setAttribute(getFailureKeyAtribute(), className );\n            //login failed, let request continue back to the login page:\n            return true;\n        }\n    }\n\n    protected void issueSuccessRedirect( ServletRequest request, ServletResponse response ) throws Exception {\n        RedirectView view = new RedirectView( getSuccessUrl(), isContextRelative(), isHttp10Compatible() );\n        view.renderMergedOutputModel(getQueryParams(), toHttp(request), toHttp(response) );\n    }\n\n    protected String getUsername( ServletRequest request, ServletResponse response ) {\n        return StringUtils.clean(request.getParameter(getUsernameParam()));\n    }\n\n    protected String getPassword( ServletRequest request, ServletResponse response ) {\n        return StringUtils.clean(request.getParameter(getPasswordParam()));\n    }\n\n    protected boolean isRememberMe( ServletRequest request, ServletResponse response ) {\n        String rememberMe = StringUtils.clean(request.getParameter(getRememberMeParam()));\n        return rememberMe != null &&\n                (rememberMe.equalsIgnoreCase(\"true\") ||\n                 rememberMe.equalsIgnoreCase(\"t\") ||\n                 rememberMe.equalsIgnoreCase(\"1\") ||\n                 rememberMe.equalsIgnoreCase(\"y\") || \n                 rememberMe.equalsIgnoreCase(\"yes\") ||\n                 rememberMe.equalsIgnoreCase(\"on\") );\n    }\n\n    protected InetAddress getInetAddress( ServletRequest request, ServletResponse response ) {\n        if ( request instanceof HttpServletRequest ) {\n            try {\n                return InetAddress.getByName( toHttp(request).getRemoteAddr() );\n            } catch (UnknownHostException e) {\n                if ( log.isTraceEnabled() ) {\n                    log.trace( \"Unable to acquire host for HttpServlet request.\", e );\n                }\n            }\n        }\n        return null;\n    }\n}\n","Smelly Sample":"package org.jsecurity.web.interceptor.authc;\n\nimport org.jsecurity.JSecurityException;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.web.RedirectView;\nimport org.jsecurity.web.WebUtils;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\n/**\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class FormAuthenticationWebInterceptor extends AuthenticationWebInterceptor {\n\n    public static final String DEFAULT_ERROR_KEY_ATTRIBUTE_NAME = FormAuthenticationWebInterceptor.class.getName() + \"_AUTHC_FAILURE_KEY\";\n\n    public static final String DEFAULT_LOGIN_URL = \"/login.jsp\";\n    public static final String DEFAULT_USERNAME_PARAM = \"username\";\n    public static final String DEFAULT_PASSWORD_PARAM = \"password\";\n    public static final String DEFAULT_REMEMBER_ME_PARAM = \"rememberMe\";\n\n    private String usernameParam = DEFAULT_USERNAME_PARAM;\n    private String passwordParam = DEFAULT_PASSWORD_PARAM;\n    private String rememberMeParam = DEFAULT_REMEMBER_ME_PARAM;\n\n    private String successUrl = DEFAULT_LOGIN_URL;\n    private String failureKeyAtribute = DEFAULT_ERROR_KEY_ATTRIBUTE_NAME;\n\n    public FormAuthenticationWebInterceptor() {\n        setUrl(DEFAULT_LOGIN_URL);\n    }\n\n    public String getUsernameParam() {\n        return usernameParam;\n    }\n\n    public void setUsernameParam(String usernameParam) {\n        this.usernameParam = usernameParam;\n    }\n\n    public String getPasswordParam() {\n        return passwordParam;\n    }\n\n    public void setPasswordParam(String passwordParam) {\n        this.passwordParam = passwordParam;\n    }\n\n    public String getRememberMeParam() {\n        return rememberMeParam;\n    }\n\n    public void setRememberMeParam(String rememberMeParam) {\n        this.rememberMeParam = rememberMeParam;\n    }\n\n    public String getSuccessUrl() {\n        return successUrl;\n    }\n\n    public void setSuccessUrl(String successUrl) {\n        this.successUrl = successUrl;\n    }\n\n    public String getFailureKeyAtribute() {\n        return failureKeyAtribute;\n    }\n\n    public void setFailureKeyAtribute(String failureKeyAtribute) {\n        this.failureKeyAtribute = failureKeyAtribute;\n    }\n\n    public void init() throws JSecurityException {\n        if ( log.isTraceEnabled() ) {\n            log.trace(\"Adding default login url to applied paths.\" );\n        }\n        this.appliedPaths.put(getUrl(),null);\n    }\n\n    protected boolean onUnauthenticatedRequest(ServletRequest request, ServletResponse response) throws Exception {\n        if ( isLoginRequest(request,response) ) {\n            if ( isLoginSubmission(request,response)) {\n                if ( log.isTraceEnabled() ) {\n                    log.trace(\"Login submission detected.  Attempting to execute login.\" );\n                }\n                return executeLogin(request, response);   \n            } else {\n                if ( log.isTraceEnabled() ) {\n                    log.trace(\"Login page view.\");\n                }\n                //allow them to see the login page ;)\n                return true;\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace(\"Attempting to access a path which requires authentication.  Forwarding to the \" +\n                        \"Authentication url [\" + getUrl() + \"]\" );\n            }\n            issueRedirect(request,response);\n            return false;\n        }\n    }\n\n    protected void saveRequest(ServletRequest servletRequest, ServletResponse response ) {\n        //save the page they were trying to visit so we can redirect them back to this location after\n        //a successful login:\n\n        //TODO - JSEC-92\n    }\n\n    protected boolean isLoginSubmission(ServletRequest servletRequest, ServletResponse response ) {\n        return toHttp(servletRequest).getMethod().equalsIgnoreCase(\"POST\");\n    }\n\n    protected boolean isLoginRequest(ServletRequest servletRequest, ServletResponse response ) {\n        HttpServletRequest request = toHttp(servletRequest);\n        String requestURI = WebUtils.getPathWithinApplication(request);\n        return pathMatcher.match( getUrl(), requestURI );\n    }\n\n    protected boolean executeLogin(ServletRequest request, ServletResponse response ) throws Exception {\n        String username = getUsername(request,response);\n        String password = getPassword(request,response);\n        boolean rememberMe = isRememberMe(request,response);\n        InetAddress inet = getInetAddress(request,response);\n        UsernamePasswordToken token = new UsernamePasswordToken(username, password.toCharArray(), rememberMe, inet );\n\n        try {\n            getSubject(request,response).login(token);\n            issueSuccessRedirect(request,response);\n            return false;\n        } catch (AuthenticationException e) {\n            String className = e.getClass().getName();\n            request.setAttribute(getFailureKeyAtribute(), className );\n            //login failed, let request continue back to the login page:\n            return true;\n        }\n    }\n\n    protected void issueSuccessRedirect( ServletRequest request, ServletResponse response ) throws Exception {\n        RedirectView view = new RedirectView( getSuccessUrl(), isContextRelative(), isHttp10Compatible() );\n        view.renderMergedOutputModel(getQueryParams(), toHttp(request), toHttp(response) );\n    }\n\n    protected String getUsername( ServletRequest request, ServletResponse response ) {\n        return StringUtils.clean(request.getParameter(getUsernameParam()));\n    }\n\n    protected String getPassword( ServletRequest request, ServletResponse response ) {\n        return StringUtils.clean(request.getParameter(getPasswordParam()));\n    }\n\n    protected boolean isRememberMe( ServletRequest request, ServletResponse response ) {\n        String rememberMe = StringUtils.clean(request.getParameter(getRememberMeParam()));\n        return rememberMe != null &&\n                (rememberMe.equalsIgnoreCase(\"true\") ||\n                 rememberMe.equalsIgnoreCase(\"t\") ||\n                 rememberMe.equalsIgnoreCase(\"1\") ||\n                 rememberMe.equalsIgnoreCase(\"y\") || \n                 rememberMe.equalsIgnoreCase(\"yes\") ||\n                 rememberMe.equalsIgnoreCase(\"on\") );\n    }\n\n    protected InetAddress getInetAddress( ServletRequest request, ServletResponse response ) {\n        if ( request instanceof HttpServletRequest ) {\n            try {\n                return InetAddress.getByName( toHttp(request).getRemoteAddr() );\n            } catch (UnknownHostException e) {\n                if ( log.isTraceEnabled() ) {\n                    log.trace( \"Unable to acquire host for HttpServlet request.\", e );\n                }\n            }\n        }\n        return null;\n    }\n}\n","lineNo":134}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Les Hazlewood, Jeremy Haile\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.apache.commons.beanutils.BeanUtils;\nimport org.jsecurity.config.ConfigurationException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.util.ClassUtils;\nimport org.jsecurity.util.LifecycleUtils;\nimport static org.jsecurity.util.StringUtils.clean;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.DefaultWebSecurityManager;\nimport org.jsecurity.web.SecurityWebSupport;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.config.WebConfiguration;\nimport org.jsecurity.web.config.WebIniConfiguration;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * Main ServletFilter that configures and enables all JSecurity functions within a web application.\n *\n * The following is a fully commented example that documents how to configure it:\n *\n * <pre>&lt;filter&gt;\n * &lt;filter-name&gt;JSecurityFilter&lt;/filter-name&gt;\n * &lt;filter-class&gt;org.jsecurity.web.servlet.JSecurityFilter&lt;/filter-class&gt;\n * &lt;init-param&gt;&lt;param-name&gt;config&lt;/param-name&gt;&lt;param-value&gt;\n *\n * #NOTE:  This config looks pretty long - but its not - its only 5 lines of actual config.\n * #       Everything else is just heavily commented to explain things in-depth. Feel free to delete any\n * #       comments that you don't want to read from your own configuration ;)\n * #\n * # Any commented values below are JSecurity's defaults.  If you want to change any values, you only\n * # need to uncomment the lines you want to change.\n *\n * [main]\n * # The 'main' section defines JSecurity-wide configuration.\n * #\n * # Session Mode: By default, JSecurity's Session infrastructure in a web environment will use the\n * # Servlet container's HttpSession.  However, if you need to share session state across client types\n * # (e.g. Web MVC plus Java Web Start or Flash), or are doing distributed/shared Sessions for\n * # Single Sign On, HttpSessions aren't good enough.  You'll need to use JSecurity's more powerful\n * # (and client-agnostic) session management.  You can enable this by uncommenting the following line\n * # and changing 'http' to 'jsecurity'\n * #\n * #sessionMode = http\n *\n * [interceptors]\n * # This section defines the 'pool' of all the available interceptors that are available to the url path\n * # definitions below in the [urls] section.\n * #\n * # The following commented values are already provided by JSecurity by default and are immediately usable\n * # in the [urls] definitions below.  If you like, you may override any values by uncommenting only the lines\n * # you need to change.\n * #\n * # Each interceptor is configured based on its functionality and/or protocol.  You should read each\n * # interceptor's JavaDoc to fully understand what each does and how it works as well as how it would\n * # affect the user experience.\n * #\n * # Form Authentication interceptor: requires the requestiing user to be authenticated for the request to continue\n * # and if they are not, forces the user to login via a login page that you specify.  If the login attempt fails\n * # the AuthenticationException fully qualified class name will be placed as a request attribute under the\n * # 'failureKeyAttribute' name below.  This FQCN can then be used as an i18n key or lookup mechanism that can then\n * # be used to show the user why their login attempt failed (e.g. no account, incorrect password, etc).\n * #authc = org.jsecurity.web.interceptor.authc.FormAuthenticationWebInterceptor\n * #authc.url = /login.jsp\n * #authc.usernameParam = username\n * #authc.passwordParam = password\n * #authc.rememberMeParam = rememberMe\n * #authc.successUrl = /login.jsp\n * #authc.failureKeyAttribute = org.jsecurity.web.interceptor.authc.FormAuthenticationWebInterceptor_AUTHC_FAILURE_KEY\n * #\n * # Http BASIC Authentication interceptor: requires the requesting user to be authenticated for the request\n * # to continue, and if they're not, forces the user to login via the HTTP Basic protocol-specific challenge.\n * # Upon successful login, they're allowed to continue on to the requested resource/url.\n * #authcBasic = org.jsecurity.web.interceptor.authc.BasicHttpAuthenticationWebInterceptor\n * #authcBasic.applicationName = JSecurity Quickstart\n * #\n * # Roles interceptor: requires the requesting user to have one or more roles for the request to continue.\n * # If they do not have the specified roles, they are redirected to the specified URL.\n * #roles = org.jsecurity.web.interceptor.authz.RolesAuthorizationWebInterceptor\n * #roles.url =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.\n * #\n * # Permissions interceptor: requires the requesting user to have one or more permissions for the request to\n * # continue, and if they do not, redirects them to the specified URL.\n * #perms = org.jsecurity.web.interceptor.authz.PermissionsAuthorizationWebInterceptor\n * #perms.url =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.  Many\n * # applications like to use the same url specified in roles.url above.\n * #\n * #\n * # Define your own interceptors here.  To properly handle path matching, all interceptor implementations\n * # should extend the org.jsecurity.web.interceptor.PathMatchingWebInterceptor abstract class.\n *\n * [urls]\n * # This section defines url path mappings.  Each mapping entry must be on a single line and conform to the\n * # following representation:\n * #\n * # ant_path_expression = path_specific_interceptor_chain_definition\n * #\n * # For any request that matches a specified path, the corresponding value defines a comma-delimited chain of\n * # filters/interceptors to execute for that request.\n * #\n * # This is incredibly powerful in that you can define arbitrary filter chains for any given request pattern\n * # to greatly customize the security experience.\n * #\n * # The path_specific_interceptor_chain_definition must match the following format:\n * #\n * # interceptor1[optional_config1], interceptor2[optional_config2], ..., interceptorN[optional_configN]\n * #\n * # where 'interceptorN' is the name of an interceptor defined above in the [interceptors] section and\n * # '[optional_configN]' is an optional bracketed string that has meaning for that particular interceptor for\n * # _that particular path_.  If the interceptor does not need specific config for that url path, you may\n * # discard the brackets - that is, interceptorN[] just becomes interceptorN.\n * #\n * # And because interceptor tokens define chains, order matters!  Define the tokens for each path pattern\n * # in the order you want them to filter (comma-delimited).\n * #\n * # Finally, each interceptor is free to handle the response however it wants if its necessary\n * # conditions are not met (redirect, HTTP error code, direct rendering, etc).  Otherwise, it is expected to allow\n * # the request to continue through the chain on to the final destination view.\n * #\n * # Examples:\n * #\n * # To illustrate chain configuration, look at the /account/** mapping below.  This says\n * # &quot;apply the above 'authcBasic' interceptor to any request matching the '/account/**' pattern&quot;.  Since the\n * # 'authcBasic' interceptor does not need any path-specific config, it doesn't have any config brackets [].\n * #\n * # The /remoting/** definition on the other hand uses the 'roles' and 'perms' interceptors which do use\n * # bracket notation.  That definition says:\n * #\n * # &quot;To access /remoting/** urls, ensure that the user is first authenticated ('authcBasic'), then ensure that user\n * # has the 'b2bClient' role, and then finally ensure that they have the 'remote:invoke:lan,wan' permission.&quot;\n * #\n * # (Note that because elements within brackets [ ] are comma-delimited themselves, we needed to escape the permission\n * # actions of 'lan,wan' with quotes.  If we didn't do that, the permission interceptor would interpret\n * # the text between the brackets as two permissions: 'remote:invoke:lan' and 'wan' instead of the\n * # single desired 'remote:invoke:lan,wan' token.  So, you can use quotes wherever you need to escape internal\n * # commas.)\n *\n * /account/** = authcBasic\n * /remoting/** = authcBasic, roles[b2bClient], perms[remote:invoke:\"lan,wan\"]\n *\n * &lt;/param-value&gt;&lt;/init-param&gt;\n * &lt;/filter&gt;\n *\n *\n * &lt;filter-mapping&gt;\n * &lt;filter-name&gt;JSecurityFilter&lt;/filter-name&gt;\n * &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n * &lt;/filter-mapping&gt;<\/pre>\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class JSecurityFilter extends SecurityManagerFilter {\n\n    public static final String CONFIG_CLASS_NAME_INIT_PARAM_NAME = \"configClassName\";\n    public static final String CONFIG_INIT_PARAM_NAME = \"config\";\n\n    protected String config = null;\n    protected String configClassName = WebIniConfiguration.class.getName();\n\n    private List<Filter> filters;\n\n    protected void onFilterConfigSet() throws Exception {\n        applyInitParams();\n        WebConfiguration config = configure();\n        SecurityManager sm = config.getSecurityManager();\n        if ( sm == null ) {\n            if ( log.isInfoEnabled() ) {\n                log.info(\"Configuration instance [\" + config + \"] did not provide a SecurityManager.  No config \" +\n                        \"specified?  Defaulting to a \" + DefaultWebSecurityManager.class.getName() + \" instance...\");   \n            }\n            sm = new DefaultWebSecurityManager();\n            LifecycleUtils.init(sm);\n        }\n        setSecurityManager(sm);\n        this.filters = config.getFilters();\n    }\n\n    protected void applyInitParams() {\n        FilterConfig config = getFilterConfig();\n\n        String configCN = clean(config.getInitParameter(CONFIG_CLASS_NAME_INIT_PARAM_NAME));\n        if (configCN != null) {\n            if (ClassUtils.isAvailable(configCN)) {\n                this.configClassName = configCN;\n            } else {\n                String msg = \"configClassName fully qualified class name value [\" + configCN + \"] is not \" +\n                        \"available in the classpath.  Please ensure you have typed it correctly and the \" +\n                        \"corresponding class or jar is in the classpath.\";\n                throw new ConfigurationException(msg);\n            }\n        }\n\n        this.config = clean(config.getInitParameter(CONFIG_INIT_PARAM_NAME));\n    }\n\n    protected WebConfiguration configure() {\n\n        WebConfiguration config = (WebConfiguration) ClassUtils.newInstance(this.configClassName);\n\n        if (log.isDebugEnabled()) {\n            String msg = \"Attempting to inject the FilterConfig (using 'setFilterConfig' method) into the \" +\n                    \"instantiated WebConfiguration for any wrapped Filter initialization...\";\n            log.debug(msg);\n        }\n        try {\n            BeanUtils.setProperty(config, \"filterConfig\", getFilterConfig());\n        } catch (Exception e) {\n            if (log.isInfoEnabled()) {\n                String msg = \"WebConfiguration instance does not have a setFilterConfig(FilterConfig) \" +\n                        \"method to allow for Filter initialization.  Ignoring and continuing (perhaps \" +\n                        \"instance does not require the FilterConfig?)\";\n                log.info(msg);\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"Exception for debugging purposes:\", e);\n            }\n        }\n\n        if ( this.config != null ) {\n            try {\n                BeanUtils.setProperty(config, \"config\", this.config );\n            } catch (Exception e) {\n                String msg = \"The 'config' filter param was specified, but there is no \" +\n                        \"'setConfig(String)' method on the Configuration instance [\" + config + \"].  If you do \" +\n                        \"not require the 'config' filter param, please comment it out, or if you do need it, \" +\n                        \"please ensure your Configuration instance has a 'setConfig(String)' method to receive it.\";\n                throw new ConfigurationException(msg);\n            }\n        }\n\n        LifecycleUtils.init(config);\n\n        return config;\n    }\n\n\n    protected boolean isHttpSessions() {\n        SecurityManager secMgr = getSecurityManager();\n        if (secMgr instanceof DefaultWebSecurityManager) {\n            return ((DefaultWebSecurityManager) secMgr).isHttpSessionMode();\n        } else {\n            return super.isHttpSessions();\n        }\n    }\n\n    protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse,\n                                    FilterChain origChain) throws ServletException, IOException {\n        FilterChain chain = origChain;\n        if (this.filters != null && !this.filters.isEmpty()) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Filters and/or WebInterceptors configured - wrapping FilterChain.\");\n            }\n            chain = new FilterChainWrapper(chain, this.filters);\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"No Filters or WebInterceptors configured - FilterChain will not be wrapped.\");\n            }\n        }\n\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        HttpServletResponse response = (HttpServletResponse) servletResponse;\n\n        ThreadContext.bind(SecurityWebSupport.getInetAddress(request));\n\n        boolean httpSessions = isHttpSessions();\n        request = new JSecurityHttpServletRequest(request, getServletContext(), httpSessions);\n        if (!httpSessions) {\n            //the JSecurityHttpServletResponse exists to support URL rewriting for session ids.  This is only needed if\n            //using JSecurity sessions (i.e. not simple HttpSession based sessions):\n            response = new JSecurityHttpServletResponse(response, getServletContext(), (JSecurityHttpServletRequest) request);\n        }\n\n        WebUtils.bind(request);\n        WebUtils.bind(response);\n        ThreadContext.bind(getSecurityManager().getSubject());\n\n        try {\n            chain.doFilter(request, response);\n        } finally {\n            WebUtils.unbindServletRequest();\n            WebUtils.unbindServletResponse();\n            ThreadContext.unbindInetAddress();\n            ThreadContext.unbindSubject();\n        }\n    }\n\n    public void destroy() {\n        if (filters == null || filters.isEmpty()) {\n            return;\n        }\n        for (Filter filter : filters) {\n            try {\n                filter.destroy();\n            } catch (Exception e) {\n                if (log.isWarnEnabled()) {\n                    log.warn(\"Unable to cleanly destroy filter [\" + filter + \"].  Ignoring (shutting down)...\", e);\n                }\n            }\n        }\n\n        super.destroy();\n    }\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Les Hazlewood, Jeremy Haile\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.apache.commons.beanutils.BeanUtils;\nimport org.jsecurity.config.ConfigurationException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.util.ClassUtils;\nimport static org.jsecurity.util.StringUtils.clean;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.DefaultWebSecurityManager;\nimport org.jsecurity.web.SecurityWebSupport;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.config.WebConfiguration;\nimport org.jsecurity.web.config.WebIniConfiguration;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * Main ServletFilter that configures and enables all JSecurity functions within a web application.\n *\n * The following is a fully commented example that documents how to configure it:\n *\n * <pre>&lt;filter&gt;\n * &lt;filter-name&gt;JSecurityFilter&lt;/filter-name&gt;\n * &lt;filter-class&gt;org.jsecurity.web.servlet.JSecurityFilter&lt;/filter-class&gt;\n * &lt;init-param&gt;&lt;param-name&gt;config&lt;/param-name&gt;&lt;param-value&gt;\n *\n * #NOTE:  This config looks pretty long - but its not - its only 5 lines of actual config.\n * #       Everything else is just heavily commented to explain things in-depth. Feel free to delete any\n * #       comments that you don't want to read from your own configuration ;)\n * #\n * # Any commented values below are JSecurity's defaults.  If you want to change any values, you only\n * # need to uncomment the lines you want to change.\n *\n * [main]\n * # The 'main' section defines JSecurity-wide configuration.\n * #\n * # Session Mode: By default, JSecurity's Session infrastructure in a web environment will use the\n * # Servlet container's HttpSession.  However, if you need to share session state across client types\n * # (e.g. Web MVC plus Java Web Start or Flash), or are doing distributed/shared Sessions for\n * # Single Sign On, HttpSessions aren't good enough.  You'll need to use JSecurity's more powerful\n * # (and client-agnostic) session management.  You can enable this by uncommenting the following line\n * # and changing 'http' to 'jsecurity'\n * #\n * #sessionMode = http\n *\n * [interceptors]\n * # This section defines the 'pool' of all the available interceptors that are available to the url path\n * # definitions below in the [urls] section.\n * #\n * # The following commented values are already provided by JSecurity by default and are immediately usable\n * # in the [urls] definitions below.  If you like, you may override any values by uncommenting only the lines\n * # you need to change.\n * #\n * # Each interceptor is configured based on its functionality and/or protocol.  You should read each\n * # interceptor's JavaDoc to fully understand what each does and how it works as well as how it would\n * # affect the user experience.\n * #\n * # Form Authentication interceptor: requires the requestiing user to be authenticated for the request to continue\n * # and if they are not, forces the user to login via a login page that you specify.  If the login attempt fails\n * # the AuthenticationException fully qualified class name will be placed as a request attribute under the\n * # 'failureKeyAttribute' name below.  This FQCN can then be used as an i18n key or lookup mechanism that can then\n * # be used to show the user why their login attempt failed (e.g. no account, incorrect password, etc).\n * #authc = org.jsecurity.web.interceptor.authc.FormAuthenticationWebInterceptor\n * #authc.url = /login.jsp\n * #authc.usernameParam = username\n * #authc.passwordParam = password\n * #authc.rememberMeParam = rememberMe\n * #authc.successUrl = /login.jsp\n * #authc.failureKeyAttribute = org.jsecurity.web.interceptor.authc.FormAuthenticationWebInterceptor_AUTHC_FAILURE_KEY\n * #\n * # Http BASIC Authentication interceptor: requires the requesting user to be authenticated for the request\n * # to continue, and if they're not, forces the user to login via the HTTP Basic protocol-specific challenge.\n * # Upon successful login, they're allowed to continue on to the requested resource/url.\n * #authcBasic = org.jsecurity.web.interceptor.authc.BasicHttpAuthenticationWebInterceptor\n * #authcBasic.applicationName = JSecurity Quickstart\n * #\n * # Roles interceptor: requires the requesting user to have one or more roles for the request to continue.\n * # If they do not have the specified roles, they are redirected to the specified URL.\n * #roles = org.jsecurity.web.interceptor.authz.RolesAuthorizationWebInterceptor\n * #roles.url =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.\n * #\n * # Permissions interceptor: requires the requesting user to have one or more permissions for the request to\n * # continue, and if they do not, redirects them to the specified URL.\n * #perms = org.jsecurity.web.interceptor.authz.PermissionsAuthorizationWebInterceptor\n * #perms.url =\n * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead\n * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.  Many\n * # applications like to use the same url specified in roles.url above.\n * #\n * #\n * # Define your own interceptors here.  To properly handle path matching, all interceptor implementations\n * # should extend the org.jsecurity.web.interceptor.PathMatchingWebInterceptor abstract class.\n *\n * [urls]\n * # This section defines url path mappings.  Each mapping entry must be on a single line and conform to the\n * # following representation:\n * #\n * # ant_path_expression = path_specific_interceptor_chain_definition\n * #\n * # For any request that matches a specified path, the corresponding value defines a comma-delimited chain of\n * # filters/interceptors to execute for that request.\n * #\n * # This is incredibly powerful in that you can define arbitrary filter chains for any given request pattern\n * # to greatly customize the security experience.\n * #\n * # The path_specific_interceptor_chain_definition must match the following format:\n * #\n * # interceptor1[optional_config1], interceptor2[optional_config2], ..., interceptorN[optional_configN]\n * #\n * # where 'interceptorN' is the name of an interceptor defined above in the [interceptors] section and\n * # '[optional_configN]' is an optional bracketed string that has meaning for that particular interceptor for\n * # _that particular path_.  If the interceptor does not need specific config for that url path, you may\n * # discard the brackets - that is, interceptorN[] just becomes interceptorN.\n * #\n * # And because interceptor tokens define chains, order matters!  Define the tokens for each path pattern\n * # in the order you want them to filter (comma-delimited).\n * #\n * # Finally, each interceptor is free to handle the response however it wants if its necessary\n * # conditions are not met (redirect, HTTP error code, direct rendering, etc).  Otherwise, it is expected to allow\n * # the request to continue through the chain on to the final destination view.\n * #\n * # Examples:\n * #\n * # To illustrate chain configuration, look at the /account/** mapping below.  This says\n * # &quot;apply the above 'authcBasic' interceptor to any request matching the '/account/**' pattern&quot;.  Since the\n * # 'authcBasic' interceptor does not need any path-specific config, it doesn't have any config brackets [].\n * #\n * # The /remoting/** definition on the other hand uses the 'roles' and 'perms' interceptors which do use\n * # bracket notation.  That definition says:\n * #\n * # &quot;To access /remoting/** urls, ensure that the user is first authenticated ('authcBasic'), then ensure that user\n * # has the 'b2bClient' role, and then finally ensure that they have the 'remote:invoke:lan,wan' permission.&quot;\n * #\n * # (Note that because elements within brackets [ ] are comma-delimited themselves, we needed to escape the permission\n * # actions of 'lan,wan' with quotes.  If we didn't do that, the permission interceptor would interpret\n * # the text between the brackets as two permissions: 'remote:invoke:lan' and 'wan' instead of the\n * # single desired 'remote:invoke:lan,wan' token.  So, you can use quotes wherever you need to escape internal\n * # commas.)\n *\n * /account/** = authcBasic\n * /remoting/** = authcBasic, roles[b2bClient], perms[remote:invoke:\"lan,wan\"]\n *\n * &lt;/param-value&gt;&lt;/init-param&gt;\n * &lt;/filter&gt;\n *\n *\n * &lt;filter-mapping&gt;\n * &lt;filter-name&gt;JSecurityFilter&lt;/filter-name&gt;\n * &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n * &lt;/filter-mapping&gt;<\/pre>\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class JSecurityFilter extends SecurityManagerFilter {\n\n    public static final String CONFIG_CLASS_NAME_INIT_PARAM_NAME = \"configClassName\";\n    public static final String CONFIG_INIT_PARAM_NAME = \"config\";\n\n    protected String config = null;\n    protected String configClassName = WebIniConfiguration.class.getName();\n\n    private List<Filter> filters;\n\n    protected void onFilterConfigSet() throws Exception {\n        applyInitParams();\n        WebConfiguration config = configure();\n        setSecurityManager(config.getSecurityManager());\n        this.filters = config.getFilters();\n    }\n\n    protected void applyInitParams() {\n        FilterConfig config = getFilterConfig();\n\n        String configCN = clean(config.getInitParameter(CONFIG_CLASS_NAME_INIT_PARAM_NAME));\n        if (configCN != null) {\n            if (ClassUtils.isAvailable(configCN)) {\n                this.configClassName = configCN;\n            } else {\n                String msg = \"configClassName fully qualified class name value [\" + configCN + \"] is not \" +\n                        \"available in the classpath.  Please ensure you have typed it correctly and the \" +\n                        \"corresponding class or jar is in the classpath.\";\n                throw new ConfigurationException(msg);\n            }\n        }\n\n        this.config = clean(config.getInitParameter(CONFIG_INIT_PARAM_NAME));\n    }\n\n    protected WebConfiguration configure() {\n\n        WebConfiguration config = (WebConfiguration) ClassUtils.newInstance(this.configClassName);\n\n        if (log.isDebugEnabled()) {\n            String msg = \"Attempting to inject the FilterConfig (using 'setFilterConfig' method) into the \" +\n                    \"instantiated WebConfiguration for any wrapped Filter initialization...\";\n            log.debug(msg);\n        }\n        try {\n            BeanUtils.setProperty(config, \"filterConfig\", getFilterConfig());\n        } catch (Exception e) {\n            if (log.isInfoEnabled()) {\n                String msg = \"WebConfiguration instance does not have a setFilterConfig(FilterConfig) \" +\n                        \"method to allow for Filter initialization.  Ignoring and continuing (perhaps \" +\n                        \"instance does not require the FilterConfig?)\";\n                log.info(msg);\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"Exception for debugging purposes:\", e);\n            }\n        }\n\n        //apply any in-line config:\n        if ( config instanceof WebIniConfiguration && this.config != null ) {\n            ((WebIniConfiguration)config).load(this.config);\n        }\n        \n        return config;\n    }\n\n\n    protected boolean isHttpSessions() {\n        SecurityManager secMgr = getSecurityManager();\n        if (secMgr instanceof DefaultWebSecurityManager) {\n            return ((DefaultWebSecurityManager) secMgr).isHttpSessionMode();\n        } else {\n            return super.isHttpSessions();\n        }\n    }\n\n    protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse,\n                                    FilterChain origChain) throws ServletException, IOException {\n        FilterChain chain = origChain;\n        if (this.filters != null && !this.filters.isEmpty()) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Filters and/or WebInterceptors configured - wrapping FilterChain.\");\n            }\n            chain = new FilterChainWrapper(chain, this.filters);\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"No Filters or WebInterceptors configured - FilterChain will not be wrapped.\");\n            }\n        }\n\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        HttpServletResponse response = (HttpServletResponse) servletResponse;\n\n        ThreadContext.bind(SecurityWebSupport.getInetAddress(request));\n\n        boolean httpSessions = isHttpSessions();\n        request = new JSecurityHttpServletRequest(request, getServletContext(), httpSessions);\n        if (!httpSessions) {\n            //the JSecurityHttpServletResponse exists to support URL rewriting for session ids.  This is only needed if\n            //using JSecurity sessions (i.e. not simple HttpSession based sessions):\n            response = new JSecurityHttpServletResponse(response, getServletContext(), (JSecurityHttpServletRequest) request);\n        }\n\n        WebUtils.bind(request);\n        WebUtils.bind(response);\n        ThreadContext.bind(getSecurityManager().getSubject());\n\n        try {\n            chain.doFilter(request, response);\n        } finally {\n            WebUtils.unbindServletRequest();\n            WebUtils.unbindServletResponse();\n            ThreadContext.unbindInetAddress();\n            ThreadContext.unbindSubject();\n        }\n    }\n\n    public void destroy() {\n        if (filters == null || filters.isEmpty()) {\n            return;\n        }\n        for (Filter filter : filters) {\n            try {\n                filter.destroy();\n            } catch (Exception e) {\n                if (log.isWarnEnabled()) {\n                    log.warn(\"Unable to cleanly destroy filter [\" + filter + \"].  Ignoring (shutting down)...\", e);\n                }\n            }\n        }\n\n        super.destroy();\n    }\n}\n","lineNo":191}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web;\n\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.mgt.DefaultSecurityManager;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.mgt.SessionManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.web.session.DefaultWebSessionManager;\nimport org.jsecurity.web.session.ServletContainerSessionManager;\nimport org.jsecurity.web.session.WebSessionManager;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.net.InetAddress;\nimport java.util.Collection;\n\n/**\n * SecurityManager implementation that should be used in web-based applications or any application that requires\n * HTTP connectivity (SOAP, http remoting, etc).\n * \n * @author Les Hazlewood\n * @since 0.2\n */\npublic class DefaultWebSecurityManager extends DefaultSecurityManager implements WebSecurityManager {\n\n    public static final String HTTP_SESSION_MODE = \"http\";\n    public static final String JSECURITY_SESSION_MODE = \"jsecurity\";\n\n    /** The key that is used to store subject principals in the session. */\n    public static final String PRINCIPALS_SESSION_KEY = DefaultWebSecurityManager.class.getName() + \"_PRINCIPALS_SESSION_KEY\";\n\n    /** The key that is used to store whether or not the user is authenticated in the session. */\n    public static final String AUTHENTICATED_SESSION_KEY = DefaultWebSecurityManager.class.getName() + \"_AUTHENTICATED_SESSION_KEY\";\n\n    private String sessionMode = HTTP_SESSION_MODE; //default\n\n    public DefaultWebSecurityManager() {\n        super();\n    }\n\n    public DefaultWebSecurityManager(Realm singleRealm) {\n        super(singleRealm);\n    }\n\n    public DefaultWebSecurityManager(Collection<Realm> realms) {\n        super(realms);\n    }\n\n    protected void afterSessionManagerSet() {\n        WebRememberMeManager rmm = new WebRememberMeManager();\n        setRememberMeManager(rmm);\n    }\n\n    public String getSessionMode() {\n        return sessionMode;\n    }\n\n    public void setSessionMode(String sessionMode) {\n        if ( sessionMode == null ||\n             (!sessionMode.equals(HTTP_SESSION_MODE) && !sessionMode.equals(JSECURITY_SESSION_MODE ) ) ) {\n            String msg = \"Invalid sessionMode [\" + sessionMode + \"].  Allowed values are \" +\n                    \"public static final String constants in the \" + getClass().getName() + \" class: '\" \n                    + HTTP_SESSION_MODE + \"' or '\" + JSECURITY_SESSION_MODE + \"', with '\" +\n                    HTTP_SESSION_MODE + \"' being the default.\";\n            throw new IllegalArgumentException(msg );\n        }\n        this.sessionMode = sessionMode;\n    }\n\n    public boolean isHttpSessionMode() {\n        return this.sessionMode.equals(HTTP_SESSION_MODE);\n    }\n\n    protected SessionManager createSessionManager() {\n\n        CacheManager cacheManager = getCacheManager();\n\n        if (isHttpSessionMode()) {\n            if ( log.isInfoEnabled() ) {\n                log.info( HTTP_SESSION_MODE + \" mode - enabling ServletContainerSessionManager (Http Sessions)\" );\n            }\n            ServletContainerSessionManager scsm = new ServletContainerSessionManager();\n            if ( cacheManager != null ) {\n                scsm.setCacheManager(cacheManager);\n            }\n            scsm.setSessionEventListeners(getSessionEventListeners());\n            return scsm;\n        } else {\n            if ( log.isInfoEnabled() ) {\n                log.info( JSECURITY_SESSION_MODE + \" mode - enabling WebSessionManager (JSecurity heterogenous sessions)\");\n            }\n            DefaultWebSessionManager wsm = new DefaultWebSessionManager();\n            if ( cacheManager != null ) {\n                wsm.setCacheManager(cacheManager);\n            }\n            wsm.setSessionEventListeners(getSessionEventListeners());\n            wsm.init();\n            return wsm;\n        }\n    }\n\n    protected PrincipalCollection getPrincipals(Session session) {\n        PrincipalCollection principals = null;\n        if (session != null) {\n            principals = (PrincipalCollection)session.getAttribute(PRINCIPALS_SESSION_KEY);\n        }\n        return principals;\n    }\n\n    protected PrincipalCollection getPrincipals(Session existing, ServletRequest servletRequest, ServletResponse servletResponse) {\n        PrincipalCollection principals = getPrincipals(existing);\n        if (principals == null) {\n            //check remember me:\n            principals = getRememberedIdentity();\n            if (principals != null && existing != null) {\n                existing.setAttribute(PRINCIPALS_SESSION_KEY, principals);\n            }\n        }\n        return principals;\n    }\n\n    protected boolean isAuthenticated(Session session) {\n        Boolean value = null;\n        if (session != null) {\n            value = (Boolean) session.getAttribute(AUTHENTICATED_SESSION_KEY);\n        }\n        return value != null && value;\n    }\n\n    protected boolean isAuthenticated(ServletRequest servletRequest, ServletResponse servletResponse, Session existing) {\n        return isAuthenticated(existing);\n    }\n\n    public Subject getSubject(ServletRequest request, ServletResponse response) {\n        return getSubject();\n    }\n\n    public Subject createSubject() {\n        ServletRequest request = WebUtils.getServletRequest();\n        ServletResponse response = WebUtils.getServletResponse();\n        return createSubject(request, response);\n    }\n\n    public Subject createSubject(ServletRequest request, ServletResponse response) {\n        Session session = ((WebSessionManager)getSessionManager()).getSession(request, response);\n        if ( session == null ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No session found for the incoming request.  The Subject instance created for \" +\n                        \"the incoming request will not have an associated Session.\" );\n            }\n        }\n        return createSubject(session, request, response);\n    }\n\n    public Subject createSubject(Session existing, ServletRequest request, ServletResponse response) {\n        PrincipalCollection principals = getPrincipals(existing, request, response);\n        boolean authenticated = isAuthenticated(request, response, existing);\n        return createSubject(request, response, existing, principals, authenticated);\n    }\n\n    protected Subject createSubject(ServletRequest request,\n                                    ServletResponse response,\n                                    Session existing,\n                                    PrincipalCollection principals,\n                                    boolean authenticated) {\n        InetAddress inetAddress = SecurityWebSupport.getInetAddress(request);\n        return createSubject(principals, existing, authenticated, inetAddress);\n    }\n\n    protected void bind(Subject subject) {\n        super.bind(subject);\n        ServletRequest request = WebUtils.getServletRequest();\n        ServletResponse response = WebUtils.getServletResponse();\n        bind(subject, request, response);\n    }\n\n    protected void bind(Subject subject, ServletRequest request, ServletResponse response) {\n\n        PrincipalCollection principals = subject.getPrincipals();\n        if (principals != null && !principals.isEmpty()) {\n            Session session = subject.getSession();\n            session.setAttribute(PRINCIPALS_SESSION_KEY, principals);\n        } else {\n            Session session = subject.getSession(false);\n            if (session != null) {\n                session.removeAttribute(PRINCIPALS_SESSION_KEY);\n            }\n        }\n\n        if (subject.isAuthenticated()) {\n            Session session = subject.getSession();\n            session.setAttribute(AUTHENTICATED_SESSION_KEY, subject.isAuthenticated());\n        } else {\n            Session session = subject.getSession(false);\n            if (session != null) {\n                session.removeAttribute(AUTHENTICATED_SESSION_KEY);\n            }\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web;\n\nimport org.jsecurity.mgt.DefaultSecurityManager;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.mgt.SessionManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.web.session.DefaultWebSessionManager;\nimport org.jsecurity.web.session.ServletContainerSessionManager;\nimport org.jsecurity.web.session.WebSessionManager;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.net.InetAddress;\nimport java.util.Collection;\n\n/**\n * SecurityManager implementation that should be used in web-based applications or any application that requires\n * HTTP connectivity (SOAP, http remoting, etc).\n * \n * @author Les Hazlewood\n * @since 0.2\n */\npublic class DefaultWebSecurityManager extends DefaultSecurityManager implements WebSecurityManager {\n\n    public static final String HTTP_SESSION_MODE = \"http\";\n    public static final String JSECURITY_SESSION_MODE = \"jsecurity\";\n\n    /** The key that is used to store subject principals in the session. */\n    public static final String PRINCIPALS_SESSION_KEY = DefaultWebSecurityManager.class.getName() + \"_PRINCIPALS_SESSION_KEY\";\n\n    /** The key that is used to store whether or not the user is authenticated in the session. */\n    public static final String AUTHENTICATED_SESSION_KEY = DefaultWebSecurityManager.class.getName() + \"_AUTHENTICATED_SESSION_KEY\";\n\n    private String sessionMode = HTTP_SESSION_MODE; //default\n\n    public DefaultWebSecurityManager() {\n        super();\n    }\n\n    public DefaultWebSecurityManager(Realm singleRealm) {\n        super(singleRealm);\n    }\n\n    public DefaultWebSecurityManager(Collection<Realm> realms) {\n        super(realms);\n    }\n\n    protected void afterSessionManagerSet() {\n        WebRememberMeManager rmm = new WebRememberMeManager();\n        setRememberMeManager(rmm);\n    }\n\n    public String getSessionMode() {\n        return sessionMode;\n    }\n\n    public void setSessionMode(String sessionMode) {\n        if ( sessionMode == null ||\n             (!sessionMode.equals(HTTP_SESSION_MODE) && !sessionMode.equals(JSECURITY_SESSION_MODE ) ) ) {\n            String msg = \"Invalid sessionMode [\" + sessionMode + \"].  Allowed values are \" +\n                    \"public static final String constants in the \" + getClass().getName() + \" class: '\" \n                    + HTTP_SESSION_MODE + \"' or '\" + JSECURITY_SESSION_MODE + \"', with '\" +\n                    HTTP_SESSION_MODE + \"' being the default.\";\n            throw new IllegalArgumentException(msg );\n        }\n        this.sessionMode = sessionMode;\n    }\n\n    public boolean isHttpSessionMode() {\n        return this.sessionMode.equals(HTTP_SESSION_MODE);\n    }\n\n    protected SessionManager createSessionManager() {\n\n        if (isHttpSessionMode()) {\n            if ( log.isInfoEnabled() ) {\n                log.info( HTTP_SESSION_MODE + \" mode - enabling ServletContainerSessionManager (Http Sessions)\" );\n            }\n            ServletContainerSessionManager scsm = new ServletContainerSessionManager();\n            scsm.setSessionEventListeners(getSessionEventListeners());\n            return scsm;\n        } else {\n            if ( log.isInfoEnabled() ) {\n                log.info( JSECURITY_SESSION_MODE + \" mode - enabling WebSessionManager (JSecurity heterogenous sessions)\");\n            }\n            DefaultWebSessionManager wsm = new DefaultWebSessionManager();\n            wsm.setCacheManager(getCacheManager());\n            wsm.setSessionEventListeners(getSessionEventListeners());\n            wsm.init();\n            return wsm;\n        }\n    }\n\n    protected PrincipalCollection getPrincipals(Session session) {\n        PrincipalCollection principals = null;\n        if (session != null) {\n            principals = (PrincipalCollection)session.getAttribute(PRINCIPALS_SESSION_KEY);\n        }\n        return principals;\n    }\n\n    protected PrincipalCollection getPrincipals(Session existing, ServletRequest servletRequest, ServletResponse servletResponse) {\n        PrincipalCollection principals = getPrincipals(existing);\n        if (principals == null) {\n            //check remember me:\n            principals = getRememberedIdentity();\n            if (principals != null && existing != null) {\n                existing.setAttribute(PRINCIPALS_SESSION_KEY, principals);\n            }\n        }\n        return principals;\n    }\n\n    protected boolean isAuthenticated(Session session) {\n        Boolean value = null;\n        if (session != null) {\n            value = (Boolean) session.getAttribute(AUTHENTICATED_SESSION_KEY);\n        }\n        return value != null && value;\n    }\n\n    protected boolean isAuthenticated(ServletRequest servletRequest, ServletResponse servletResponse, Session existing) {\n        return isAuthenticated(existing);\n    }\n\n    public Subject getSubject(ServletRequest request, ServletResponse response) {\n        return getSubject();\n    }\n\n    public Subject createSubject() {\n        ServletRequest request = WebUtils.getServletRequest();\n        ServletResponse response = WebUtils.getServletResponse();\n        return createSubject(request, response);\n    }\n\n    public Subject createSubject(ServletRequest request, ServletResponse response) {\n        Session session = ((WebSessionManager)getSessionManager()).getSession(request, response);\n        if ( session == null ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No session found for the incoming request.  The Subject instance created for \" +\n                        \"the incoming request will not have an associated Session.\" );\n            }\n        }\n        return createSubject(session, request, response);\n    }\n\n    public Subject createSubject(Session existing, ServletRequest request, ServletResponse response) {\n        PrincipalCollection principals = getPrincipals(existing, request, response);\n        boolean authenticated = isAuthenticated(request, response, existing);\n        return createSubject(request, response, existing, principals, authenticated);\n    }\n\n    protected Subject createSubject(ServletRequest request,\n                                    ServletResponse response,\n                                    Session existing,\n                                    PrincipalCollection principals,\n                                    boolean authenticated) {\n        InetAddress inetAddress = SecurityWebSupport.getInetAddress(request);\n        return createSubject(principals, existing, authenticated, inetAddress);\n    }\n\n    protected void bind(Subject subject) {\n        super.bind(subject);\n        ServletRequest request = WebUtils.getServletRequest();\n        ServletResponse response = WebUtils.getServletResponse();\n        bind(subject, request, response);\n    }\n\n    protected void bind(Subject subject, ServletRequest request, ServletResponse response) {\n\n        PrincipalCollection principals = subject.getPrincipals();\n        if (principals != null && !principals.isEmpty()) {\n            Session session = subject.getSession();\n            session.setAttribute(PRINCIPALS_SESSION_KEY, principals);\n        } else {\n            Session session = subject.getSession(false);\n            if (session != null) {\n                session.removeAttribute(PRINCIPALS_SESSION_KEY);\n            }\n        }\n\n        if (subject.isAuthenticated()) {\n            Session session = subject.getSession();\n            session.setAttribute(AUTHENTICATED_SESSION_KEY, subject.isAuthenticated());\n        } else {\n            Session session = subject.getSession(false);\n            if (session != null) {\n                session.removeAttribute(AUTHENTICATED_SESSION_KEY);\n            }\n        }\n    }\n}\n","lineNo":93}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.config;\n\nimport org.jsecurity.mgt.DefaultSecurityManager;\nimport org.jsecurity.mgt.RealmSecurityManager;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.realm.RealmFactory;\nimport org.jsecurity.util.LifecycleUtils;\nimport org.jsecurity.util.ResourceUtils;\nimport static org.jsecurity.util.StringUtils.clean;\nimport static org.jsecurity.util.StringUtils.splitKeyValue;\n\nimport java.text.ParseException;\nimport java.util.*;\n\n/**\n * @since 0.9\n * @author Les Hazlewood\n */\npublic class IniConfiguration extends TextConfiguration {\n\n    public static final String DEFAULT_INI_RESOURCE_PATH = \"classpath:jsecurity.ini\";\n   \n    public static final String MAIN = \"main\";\n    public static final String INTERCEPTORS = \"interceptors\";\n    public static final String URLS = \"urls\";\n\n    public static final String SESSION_MODE_PROPERTY_NAME = \"sessionMode\";\n\n    private static final String HEADER_PREFIX = \"[\";\n    private static final String HEADER_SUFFIX = \"]\";\n\n    private static final String[] SECTION_HEADERS = {\n            HEADER_PREFIX + MAIN + HEADER_SUFFIX,\n            HEADER_PREFIX + INTERCEPTORS + HEADER_SUFFIX,\n            HEADER_PREFIX + URLS + HEADER_SUFFIX\n    };\n\n    protected Map<String, String> sections = new LinkedHashMap<String, String>();\n\n    public IniConfiguration() {\n        if ( ResourceUtils.resourceExists( DEFAULT_INI_RESOURCE_PATH ) ) {\n            load( DEFAULT_INI_RESOURCE_PATH, null );\n        }\n        //else defaults are fine\n    }\n\n    public IniConfiguration(String configBodyOrResourcePath) {\n        super(configBodyOrResourcePath);\n    }\n\n    public IniConfiguration(String configBodyOrResourcePath, String charsetName) {\n        super(configBodyOrResourcePath, charsetName);\n    }\n\n    protected static boolean isSectionHeader(String name) {\n        for (String s : SECTION_HEADERS) {\n            if (s.equals(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected static String getSectionName(String header) {\n        if ( isSectionHeader( header ) ) {\n            return header.substring(1, header.length() - 1 );\n        }\n        return null;\n    }\n\n    protected void doLoad(Scanner scanner) throws Exception {\n\n        String currSectionName = null;\n\n        StringBuffer section = new StringBuffer();\n        \n        while (scanner.hasNextLine()) {\n\n            String line = clean(scanner.nextLine());\n\n            if (line == null || line.startsWith(\"#\")) {\n                //skip empty lines and comments:\n                continue;\n            }\n\n            String sectionName = getSectionName( line.toLowerCase() );\n            if ( sectionName != null ) {\n                String sectionBody = clean( section.toString() );\n                if ( sectionBody != null ) {\n                    sections.put( currSectionName, sectionBody );\n                }    \n                currSectionName = sectionName;\n                section = new StringBuffer();\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Parsing \" + HEADER_PREFIX + currSectionName + HEADER_SUFFIX );\n                }\n            } else {\n                section.append(line).append(\"\\n\");\n            }\n        }\n\n        if ( section.length() > 0 ) {\n            String sectionBody = clean( section.toString() );\n            if ( sectionBody != null ) {\n                sections.put( currSectionName, sectionBody );\n            }\n        }\n    }\n\n    protected void processSections( Map<String,String> sections ) {\n        SecurityManager securityManager = createSecurityManager( sections );\n        if ( securityManager == null ) {\n            String msg = \"A \" + SecurityManager.class + \" instance must be created at startup.\";\n            throw new ConfigurationException( msg );\n        }\n        setSecurityManager( securityManager );\n\n        afterSecurityManagerSet( sections );\n    }\n\n    protected SecurityManager createSecurityManager( Map<String,String> sections ) {\n        String mainSectionBody = sections.get( MAIN );\n        return createSecurityManager( mainSectionBody );\n    }\n\n    protected String getSessionMode( String main ) {\n        if ( main != null ) {\n            Scanner scanner = new Scanner(main);\n            while( scanner.hasNextLine() ) {\n                String line = scanner.nextLine();\n                //we only process sessionMode so far:\n                String[] nameAndValue;\n                try {\n                    nameAndValue = splitKeyValue(line);\n                } catch (ParseException e) {\n                    throw new ConfigurationException(e);\n                }\n                String name = nameAndValue[0];\n                String value = nameAndValue[1];\n                if ( SESSION_MODE_PROPERTY_NAME.equalsIgnoreCase(name) && value != null ) {\n                    return value;\n                }\n            }\n        }\n        return null;\n    }\n\n    protected RealmSecurityManager newSecurityManagerInstance() {\n        return new DefaultSecurityManager();\n    }\n\n    protected SecurityManager createSecurityManager( String mainSection ) {\n\n        Map<String,Object> defaults = new LinkedHashMap<String,Object>();\n\n        RealmSecurityManager securityManager = newSecurityManagerInstance();\n        defaults.put( \"securityManager\", securityManager );\n        ReflectionBuilder builder = new ReflectionBuilder(defaults);\n        Map<String,Object> objects = builder.buildObjects(mainSection);\n\n        //realms and realm factory might have been created - pull them out first so we can\n        //initialize the securityManager:\n\n        List<Realm> realms = new ArrayList<Realm>();\n\n        //iterate over the map entries to pull out the realm factory(s):\n\n        for( Map.Entry<String,Object> entry : objects.entrySet() ) {\n            String name = entry.getKey();\n            Object value = entry.getValue();\n            if ( value instanceof RealmFactory ) {\n                RealmFactory factory = (RealmFactory)value;\n                LifecycleUtils.init(factory);\n                Collection<Realm> factoryRealms = factory.getRealms();\n                if ( factoryRealms != null && !factoryRealms.isEmpty() ) {\n                    realms.addAll( factoryRealms );\n                }\n            } else if ( value instanceof Realm ) {\n                Realm realm = (Realm)value;\n                //set the name if null:\n                String existingName = realm.getName();\n                if ( existingName == null || existingName.startsWith( realm.getClass().getName() ) ) {\n                    try {\n                        builder.applyProperty( realm, \"name\", name );\n                    } catch ( Exception ignored ) {}\n                }\n                realms.add( realm );\n            }\n        }\n\n        //set them on the SecurityManager\n        if ( !realms.isEmpty() ) {\n            securityManager.setRealms(realms);\n        }\n\n        securityManager.init();\n\n        LifecycleUtils.init(realms);\n\n        return securityManager;\n    }\n\n    protected void afterSecurityManagerSet( Map<String,String> sections ) {}\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.config;\n\nimport org.jsecurity.mgt.DefaultSecurityManager;\nimport org.jsecurity.mgt.RealmSecurityManager;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.realm.RealmFactory;\nimport org.jsecurity.util.LifecycleUtils;\nimport org.jsecurity.util.ResourceUtils;\nimport static org.jsecurity.util.StringUtils.clean;\nimport static org.jsecurity.util.StringUtils.splitKeyValue;\n\nimport java.text.ParseException;\nimport java.util.*;\n\n/**\n * @since 0.9\n * @author Les Hazlewood\n */\npublic class IniConfiguration extends TextConfiguration {\n\n    public static final String DEFAULT_INI_RESOURCE_PATH = \"classpath:jsecurity.ini\";\n   \n    public static final String MAIN = \"main\";\n    public static final String INTERCEPTORS = \"interceptors\";\n    public static final String URLS = \"urls\";\n\n    public static final String SESSION_MODE_PROPERTY_NAME = \"sessionMode\";\n\n    private static final String HEADER_PREFIX = \"[\";\n    private static final String HEADER_SUFFIX = \"]\";\n\n    private static final String[] SECTION_HEADERS = {\n            HEADER_PREFIX + MAIN + HEADER_SUFFIX,\n            HEADER_PREFIX + INTERCEPTORS + HEADER_SUFFIX,\n            HEADER_PREFIX + URLS + HEADER_SUFFIX\n    };\n\n    protected Map<String, String> sections = new LinkedHashMap<String, String>();\n\n    public IniConfiguration() {\n        if ( ResourceUtils.resourceExists( DEFAULT_INI_RESOURCE_PATH ) ) {\n            load( DEFAULT_INI_RESOURCE_PATH, null );\n        }\n        //else defaults are fine\n    }\n\n    public IniConfiguration(String configBodyOrResourcePath) {\n        super(configBodyOrResourcePath);\n    }\n\n    public IniConfiguration(String configBodyOrResourcePath, String charsetName) {\n        super(configBodyOrResourcePath, charsetName);\n    }\n\n    protected static boolean isSectionHeader(String name) {\n        for (String s : SECTION_HEADERS) {\n            if (s.equals(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected static String getSectionName(String header) {\n        if ( isSectionHeader( header ) ) {\n            return header.substring(1, header.length() - 1 );\n        }\n        return null;\n    }\n\n    protected void doLoad(Scanner scanner) throws Exception {\n\n        String currSectionName = null;\n\n        StringBuffer section = new StringBuffer();\n        \n        while (scanner.hasNextLine()) {\n\n            String line = clean(scanner.nextLine());\n\n            if (line == null || line.startsWith(\"#\")) {\n                //skip empty lines and comments:\n                continue;\n            }\n\n            String sectionName = getSectionName( line.toLowerCase() );\n            if ( sectionName != null ) {\n                String sectionBody = clean( section.toString() );\n                if ( sectionBody != null ) {\n                    sections.put( currSectionName, sectionBody );\n                }    \n                currSectionName = sectionName;\n                section = new StringBuffer();\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Parsing \" + HEADER_PREFIX + currSectionName + HEADER_SUFFIX );\n                }\n            } else {\n                section.append(line).append(\"\\n\");\n            }\n        }\n\n        if ( section.length() > 0 ) {\n            String sectionBody = clean( section.toString() );\n            if ( sectionBody != null ) {\n                sections.put( currSectionName, sectionBody );\n            }\n        }\n    }\n\n    protected void processSections( Map<String,String> sections ) {\n        SecurityManager securityManager = createSecurityManager( sections );\n        if ( securityManager == null ) {\n            String msg = \"A \" + SecurityManager.class + \" instance must be created at startup.\";\n            throw new ConfigurationException( msg );\n        }\n        setSecurityManager( securityManager );\n\n        afterSecurityManagerSet( sections );\n    }\n\n    protected SecurityManager createSecurityManager( Map<String,String> sections ) {\n        String mainSectionBody = sections.get( MAIN );\n        return createSecurityManager( mainSectionBody );\n    }\n\n    protected String getSessionMode( String main ) {\n        if ( main != null ) {\n            Scanner scanner = new Scanner(main);\n            while( scanner.hasNextLine() ) {\n                String line = scanner.nextLine();\n                //we only process sessionMode so far:\n                String[] nameAndValue;\n                try {\n                    nameAndValue = splitKeyValue(line);\n                } catch (ParseException e) {\n                    throw new ConfigurationException(e);\n                }\n                String name = nameAndValue[0];\n                String value = nameAndValue[1];\n                if ( SESSION_MODE_PROPERTY_NAME.equalsIgnoreCase(name) && value != null ) {\n                    return value;\n                }\n            }\n        }\n        return null;\n    }\n\n    protected RealmSecurityManager newSecurityManagerInstance() {\n        return new DefaultSecurityManager();\n    }\n\n    protected SecurityManager createSecurityManager( String mainSection ) {\n\n        Map<String,Object> defaults = new LinkedHashMap<String,Object>();\n\n        RealmSecurityManager securityManager = newSecurityManagerInstance();\n        defaults.put( \"securityManager\", securityManager );\n        ReflectionBuilder builder = new ReflectionBuilder(defaults);\n        Map<String,Object> objects = builder.buildObjects(mainSection);\n\n        //realms and realm factory might have been created - pull them out first so we can\n        //initialize the securityManager:\n\n        List<Realm> realms = new ArrayList<Realm>();\n\n        //iterate over the map entries to pull out the realm factory(s):\n\n        for( Map.Entry<String,Object> entry : objects.entrySet() ) {\n            String name = entry.getKey();\n            Object value = entry.getValue();\n            if ( value instanceof RealmFactory ) {\n                Collection<Realm> factoryRealms = ((RealmFactory)value).getRealms();\n                if ( factoryRealms != null && !factoryRealms.isEmpty() ) {\n                    realms.addAll( factoryRealms );\n                }\n            } else if ( value instanceof Realm ) {\n                Realm realm = (Realm)value;\n                //set the name if null:\n                String existingName = realm.getName();\n                if ( existingName == null || existingName.startsWith( realm.getClass().getName() ) ) {\n                    try {\n                        builder.applyProperty( realm, \"name\", name );\n                    } catch ( Exception ignored ) {}\n                }\n                realms.add( realm );\n            }\n        }\n\n        //now init any realm objects that require initialization:\n        LifecycleUtils.init(realms);\n\n        //set them on the SecurityManager\n        if ( !realms.isEmpty() ) {\n            securityManager.setRealms(realms);\n        }\n\n        securityManager.init();\n\n        return securityManager;\n    }\n\n    protected void afterSecurityManagerSet( Map<String,String> sections ) {}\n}\n","lineNo":188}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web.session;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.mgt.DefaultSessionManager;\nimport org.jsecurity.web.SecurityWebSupport;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.attr.CookieAttribute;\nimport org.jsecurity.web.attr.RequestParamAttribute;\nimport org.jsecurity.web.attr.WebAttribute;\nimport org.jsecurity.web.servlet.JSecurityHttpServletRequest;\nimport org.jsecurity.web.servlet.JSecurityHttpSession;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\nimport java.net.InetAddress;\n\n/**\n * Web-application capable <tt>SessionManager<\/tt> implementation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class DefaultWebSessionManager extends DefaultSessionManager implements WebSessionManager {\n\n    /**\n     * Property specifying if, after a session object is acquired from the request, if that session should be\n     * validated to ensure the starting origin of the session is the same as the incoming request.\n     */\n    private boolean validateRequestOrigin = false; //default\n\n    protected CookieAttribute<Serializable> sessionIdCookieAttribute = null;\n    protected RequestParamAttribute<Serializable> sessionIdRequestParamAttribute = null;\n\n    public DefaultWebSessionManager() {\n    }\n\n    public CookieAttribute<Serializable> getSessionIdCookieAttribute() {\n        return sessionIdCookieAttribute;\n    }\n\n    public void setSessionIdCookieAttribute( CookieAttribute<Serializable> sessionIdCookieAttribute) {\n        this.sessionIdCookieAttribute = sessionIdCookieAttribute;\n    }\n\n    public RequestParamAttribute<Serializable> getSessionIdRequestParamAttribute() {\n        return sessionIdRequestParamAttribute;\n    }\n\n    public void setSessionIdRequestParamAttribute( RequestParamAttribute<Serializable> sessionIdRequestParamAttribute) {\n        this.sessionIdRequestParamAttribute = sessionIdRequestParamAttribute;\n    }\n\n    /**\n     * If set to <tt>true<\/tt>, this implementation will ensure that any\n     * <tt>HttpRequest<\/tt> attempting\n     * to join a session (i.e. via {@link #getSession getSession} must have the same\n     * IP Address of the <tt>HttpRequest<\/tt> that started the session.\n     * <p/>\n     * <p> If set to <tt>false<\/tt>, any <tt>HttpRequest<\/tt> with a reference to a valid\n     * session id may acquire that <tt>Session<\/tt>.\n     * <p/>\n     * <p>Although convenient, this should only be enabled in environments where the\n     * system can <em>guarantee<\/em> that each IP address represents one and only one\n     * machine accessing the system.\n     * <p/>\n     * <p>Public websites are not good candidates for enabling this\n     * feature since many browser clients often sit behind NAT routers (in\n     * which case many machines are viewed to come from the same IP, thereby making this\n     * validation check useless).  Also, some internet service providers (e.g. AOL) may change a\n     * client's IP in mid-session, making subsequent requests appear to come from a different\n     * location.  Again, this feature should only be enabled where IP Addresses can be guaranteed a\n     * 1-to-1 relationship with a user's session.\n     * <p/>\n     * <p>For the reasons specified above, this property is <tt>false<\/tt> by default.\n     *\n     * @return true if this factory will verify each HttpRequest joining a session\n     */\n    public boolean isValidateRequestOrigin() {\n        return validateRequestOrigin;\n    }\n\n    /**\n     * Sets whether or not a request's origin will be validated when accessing a session.  See\n     * the {@link #isValidateRequestOrigin} JavaDoc for an in-depth explanation of this property.\n     *\n     * @param validateRequestOrigin whether or not to validate the request's origin when accessing\n     *                              a session.\n     * @see #isValidateRequestOrigin\n     */\n    public void setValidateRequestOrigin( boolean validateRequestOrigin ) {\n        this.validateRequestOrigin = validateRequestOrigin;\n    }\n\n    public void init() {\n        super.init();\n        ensureCookieSessionIdStore();\n        ensureRequestParamSessionIdStore();\n    }\n\n    protected void ensureCookieSessionIdStore() {\n        CookieAttribute<Serializable> cookieStore = getSessionIdCookieAttribute();\n        if ( cookieStore == null ) {\n            cookieStore = new CookieAttribute<Serializable>( JSecurityHttpSession.DEFAULT_SESSION_ID_NAME );\n            cookieStore.setCheckRequestParams( false );\n            setSessionIdCookieAttribute( cookieStore );\n        }\n    }\n\n    protected void ensureRequestParamSessionIdStore() {\n        RequestParamAttribute<Serializable> reqParamStore = getSessionIdRequestParamAttribute();\n        if ( reqParamStore == null ) {\n            reqParamStore = new RequestParamAttribute<Serializable>( JSecurityHttpSession.DEFAULT_SESSION_ID_NAME );\n            setSessionIdRequestParamAttribute( reqParamStore );\n        }\n    }\n\n    protected void validateSessionOrigin( ServletRequest request, Session session )\n        throws HostUnauthorizedException {\n        InetAddress requestIp = SecurityWebSupport.getInetAddress( request );\n        InetAddress originIp = session.getHostAddress();\n        Serializable sessionId = session.getId();\n\n        if ( originIp == null ) {\n            if ( requestIp != null ) {\n                String msg = \"No IP Address was specified when creating session with id [\" +\n                    sessionId + \"].  Attempting to access session from \" +\n                    \"IP [\" + requestIp + \"].  Origin IP and request IP must match.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        } else {\n            if ( requestIp != null ) {\n                if ( !requestIp.equals( originIp ) ) {\n                    String msg = \"Session with id [\" + sessionId + \"] originated from [\" +\n                        originIp + \"], but the current HttpServletRequest originated \" +\n                        \"from [\" + requestIp + \"].  Disallowing session access: \" +\n                        \"session origin and request origin must match to allow access.\";\n                    throw new HostUnauthorizedException( msg );\n                }\n\n            } else {\n                String msg = \"No IP Address associated with the current HttpServletRequest.  \" +\n                    \"Session with id [\" + sessionId + \"] originated from \" +\n                    \"[\" + originIp + \"].  Request IP must match the session's origin \" +\n                    \"IP in order to gain access to that session.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        }\n    }\n\n    protected void storeSessionId( Serializable currentId, ServletRequest request, ServletResponse response ) {\n        if ( currentId == null ) {\n            String msg = \"sessionId cannot be null when persisting for subsequent requests.\";\n            throw new IllegalArgumentException( msg );\n        }\n        //ensure that the id has been set in the idStore, or if it already has, that it is not different than the\n        //'real' session value:\n        Serializable existingId = retrieveSessionId( request, response );\n        if ( existingId == null || !currentId.equals( existingId ) ) {\n            getSessionIdCookieAttribute().storeValue( currentId, request, response );\n        }\n    }\n\n    protected Serializable retrieveSessionId( ServletRequest request, ServletResponse response ) {\n        WebAttribute<Serializable> cookieSessionIdAttribute = getSessionIdCookieAttribute();\n        Serializable id = cookieSessionIdAttribute.retrieveValue( request, response );\n        if ( id != null ) {\n            request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                JSecurityHttpServletRequest.COOKIE_SESSION_ID_SOURCE );\n        } else {\n            id = getSessionIdRequestParamAttribute().retrieveValue( request, response );\n            if ( id != null ) {\n                request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                    JSecurityHttpServletRequest.URL_SESSION_ID_SOURCE );\n            }\n        }\n        return id;\n    }\n\n    public Serializable start(InetAddress hostAddress) throws HostUnauthorizedException, IllegalArgumentException {\n        ServletRequest request = WebUtils.getServletRequest();\n        ServletResponse response = WebUtils.getServletResponse();\n        return start( request, response, hostAddress );\n    }\n\n    protected Serializable start( ServletRequest request, ServletResponse response, InetAddress inetAddress ) {\n        Serializable sessionId = super.start( inetAddress );\n        storeSessionId( sessionId, request, response );\n        request.removeAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE );\n        request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_IS_NEW, Boolean.TRUE );\n        return sessionId;\n    }\n\n    public Session doGetSession(Serializable sessionId) throws InvalidSessionException, AuthorizationException {\n        if ( sessionId != null ) {\n            return super.doGetSession( sessionId );\n        } else {\n            ServletRequest request = WebUtils.getServletRequest();\n            ServletResponse response = WebUtils.getServletResponse();\n            return getSession( request, response );\n        }\n    }\n\n    /**\n     * Returns the Session associated with the specified request if it is valid or <tt>null<\/tt> if a Session doesn't\n     * exist or it was invalid.\n     *\n     * @param request  incoming servlet request\n     * @param response outgoing servlet response\n     * @return the Session associated with the incoming request or <tt>null<\/tt> if one does not exist.\n     * @throws org.jsecurity.session.InvalidSessionException if the associated Session has expired prior to invoking this method.\n     * @throws org.jsecurity.authz.AuthorizationException  if the caller is not authorized to access the session associated with the request.\n     */\n    public final Session getSession( ServletRequest request, ServletResponse response )\n        throws InvalidSessionException, AuthorizationException {\n\n        Session session;\n        try {\n            session = doGetSession( request, response );\n        } catch ( InvalidSessionException ise ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Request Session is invalid, message: [\" + ise.getMessage() + \"].  Removing any \" +\n                        \"associated session cookie...\" );\n            }\n            getSessionIdCookieAttribute().removeValue(request,response);\n\n            //give subclass a chance to do something additional if necessary.  Otherwise returning null is just fine:\n            session = handleInvalidSession( request, response, ise );\n        }\n\n        return session;\n    }\n\n    protected Session doGetSession( ServletRequest request, ServletResponse response ) {\n\n        Session session = null;\n        Serializable sessionId = retrieveSessionId( request, response );\n\n        if ( sessionId != null ) {\n            request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID, sessionId );\n            session = super.doGetSession( sessionId );\n            if ( isValidateRequestOrigin() ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"Validating request origin against session origin\" );\n                }\n                validateSessionOrigin( request, session );\n            }\n            if ( session != null ) {\n                request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE );\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No JSecurity session id associated with the given \" +\n                    \"HttpServletRequest.  A Session will not be returned.\" );\n            }\n        }\n\n        return session;\n    }\n\n    protected Session handleInvalidSession( ServletRequest request,\n                                            ServletResponse response,\n                                            InvalidSessionException ise ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Sesssion associated with the current request is nonexistent or invalid.  Returning null.\");\n        }\n        return null;\n    }\n\n    protected void onStop(Session session) {\n        super.onStop(session);\n        ServletRequest request = WebUtils.getServletRequest();\n        ServletResponse response = WebUtils.getServletResponse();\n        getSessionIdCookieAttribute().removeValue(request, response);\n    }\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web.session;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.mgt.DefaultSessionManager;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.SecurityWebSupport;\nimport org.jsecurity.web.attr.CookieAttribute;\nimport org.jsecurity.web.attr.RequestParamAttribute;\nimport org.jsecurity.web.attr.WebAttribute;\nimport org.jsecurity.web.servlet.JSecurityHttpServletRequest;\nimport org.jsecurity.web.servlet.JSecurityHttpSession;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\nimport java.net.InetAddress;\n\n/**\n * Web-application capable <tt>SessionManager<\/tt> implementation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class DefaultWebSessionManager extends DefaultSessionManager implements WebSessionManager {\n\n    /**\n     * Property specifying if, after a session object is acquired from the request, if that session should be\n     * validated to ensure the starting origin of the session is the same as the incoming request.\n     */\n    private boolean validateRequestOrigin = false; //default\n\n    protected CookieAttribute<Serializable> sessionIdCookieAttribute = null;\n    protected RequestParamAttribute<Serializable> sessionIdRequestParamAttribute = null;\n\n    public DefaultWebSessionManager() {\n    }\n\n    public CookieAttribute<Serializable> getSessionIdCookieAttribute() {\n        return sessionIdCookieAttribute;\n    }\n\n    public void setSessionIdCookieAttribute( CookieAttribute<Serializable> sessionIdCookieAttribute) {\n        this.sessionIdCookieAttribute = sessionIdCookieAttribute;\n    }\n\n    public RequestParamAttribute<Serializable> getSessionIdRequestParamAttribute() {\n        return sessionIdRequestParamAttribute;\n    }\n\n    public void setSessionIdRequestParamAttribute( RequestParamAttribute<Serializable> sessionIdRequestParamAttribute) {\n        this.sessionIdRequestParamAttribute = sessionIdRequestParamAttribute;\n    }\n\n    /**\n     * If set to <tt>true<\/tt>, this implementation will ensure that any\n     * <tt>HttpRequest<\/tt> attempting\n     * to join a session (i.e. via {@link #getSession getSession} must have the same\n     * IP Address of the <tt>HttpRequest<\/tt> that started the session.\n     * <p/>\n     * <p> If set to <tt>false<\/tt>, any <tt>HttpRequest<\/tt> with a reference to a valid\n     * session id may acquire that <tt>Session<\/tt>.\n     * <p/>\n     * <p>Although convenient, this should only be enabled in environments where the\n     * system can <em>guarantee<\/em> that each IP address represents one and only one\n     * machine accessing the system.\n     * <p/>\n     * <p>Public websites are not good candidates for enabling this\n     * feature since many browser clients often sit behind NAT routers (in\n     * which case many machines are viewed to come from the same IP, thereby making this\n     * validation check useless).  Also, some internet service providers (e.g. AOL) may change a\n     * client's IP in mid-session, making subsequent requests appear to come from a different\n     * location.  Again, this feature should only be enabled where IP Addresses can be guaranteed a\n     * 1-to-1 relationship with a user's session.\n     * <p/>\n     * <p>For the reasons specified above, this property is <tt>false<\/tt> by default.\n     *\n     * @return true if this factory will verify each HttpRequest joining a session\n     */\n    public boolean isValidateRequestOrigin() {\n        return validateRequestOrigin;\n    }\n\n    /**\n     * Sets whether or not a request's origin will be validated when accessing a session.  See\n     * the {@link #isValidateRequestOrigin} JavaDoc for an in-depth explanation of this property.\n     *\n     * @param validateRequestOrigin whether or not to validate the request's origin when accessing\n     *                              a session.\n     * @see #isValidateRequestOrigin\n     */\n    public void setValidateRequestOrigin( boolean validateRequestOrigin ) {\n        this.validateRequestOrigin = validateRequestOrigin;\n    }\n\n    public void init() {\n        super.init();\n        ensureCookieSessionIdStore();\n        ensureRequestParamSessionIdStore();\n    }\n\n    protected void ensureCookieSessionIdStore() {\n        CookieAttribute<Serializable> cookieStore = getSessionIdCookieAttribute();\n        if ( cookieStore == null ) {\n            cookieStore = new CookieAttribute<Serializable>( JSecurityHttpSession.DEFAULT_SESSION_ID_NAME );\n            cookieStore.setCheckRequestParams( false );\n            setSessionIdCookieAttribute( cookieStore );\n        }\n    }\n\n    protected void ensureRequestParamSessionIdStore() {\n        RequestParamAttribute<Serializable> reqParamStore = getSessionIdRequestParamAttribute();\n        if ( reqParamStore == null ) {\n            reqParamStore = new RequestParamAttribute<Serializable>( JSecurityHttpSession.DEFAULT_SESSION_ID_NAME );\n            setSessionIdRequestParamAttribute( reqParamStore );\n        }\n    }\n\n    protected void validateSessionOrigin( ServletRequest request, Session session )\n        throws HostUnauthorizedException {\n        InetAddress requestIp = SecurityWebSupport.getInetAddress( request );\n        InetAddress originIp = session.getHostAddress();\n        Serializable sessionId = session.getId();\n\n        if ( originIp == null ) {\n            if ( requestIp != null ) {\n                String msg = \"No IP Address was specified when creating session with id [\" +\n                    sessionId + \"].  Attempting to access session from \" +\n                    \"IP [\" + requestIp + \"].  Origin IP and request IP must match.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        } else {\n            if ( requestIp != null ) {\n                if ( !requestIp.equals( originIp ) ) {\n                    String msg = \"Session with id [\" + sessionId + \"] originated from [\" +\n                        originIp + \"], but the current HttpServletRequest originated \" +\n                        \"from [\" + requestIp + \"].  Disallowing session access: \" +\n                        \"session origin and request origin must match to allow access.\";\n                    throw new HostUnauthorizedException( msg );\n                }\n\n            } else {\n                String msg = \"No IP Address associated with the current HttpServletRequest.  \" +\n                    \"Session with id [\" + sessionId + \"] originated from \" +\n                    \"[\" + originIp + \"].  Request IP must match the session's origin \" +\n                    \"IP in order to gain access to that session.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        }\n    }\n\n    protected void storeSessionId( Serializable currentId, ServletRequest request, ServletResponse response ) {\n        if ( currentId == null ) {\n            String msg = \"sessionId cannot be null when persisting for subsequent requests.\";\n            throw new IllegalArgumentException( msg );\n        }\n        //ensure that the id has been set in the idStore, or if it already has, that it is not different than the\n        //'real' session value:\n        Serializable existingId = retrieveSessionId( request, response );\n        if ( existingId == null || !currentId.equals( existingId ) ) {\n            getSessionIdCookieAttribute().storeValue( currentId, request, response );\n        }\n    }\n\n    protected Serializable retrieveSessionId( ServletRequest request, ServletResponse response ) {\n        WebAttribute<Serializable> cookieSessionIdAttribute = getSessionIdCookieAttribute();\n        Serializable id = cookieSessionIdAttribute.retrieveValue( request, response );\n        if ( id != null ) {\n            request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                JSecurityHttpServletRequest.COOKIE_SESSION_ID_SOURCE );\n        } else {\n            id = getSessionIdRequestParamAttribute().retrieveValue( request, response );\n            if ( id != null ) {\n                request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                    JSecurityHttpServletRequest.URL_SESSION_ID_SOURCE );\n            }\n        }\n        return id;\n    }\n\n    public Serializable start(InetAddress hostAddress) throws HostUnauthorizedException, IllegalArgumentException {\n        ServletRequest request = ThreadContext.getServletRequest();\n        ServletResponse response = ThreadContext.getServletResponse();\n        return start( request, response, hostAddress );\n    }\n\n    protected Serializable start( ServletRequest request, ServletResponse response, InetAddress inetAddress ) {\n        Serializable sessionId = super.start( inetAddress );\n        storeSessionId( sessionId, request, response );\n        request.removeAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE );\n        request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_IS_NEW, Boolean.TRUE );\n        return sessionId;\n    }\n\n    public Session doGetSession(Serializable sessionId) throws InvalidSessionException, AuthorizationException {\n        if ( sessionId != null ) {\n            return super.doGetSession( sessionId );\n        } else {\n            ServletRequest request = ThreadContext.getServletRequest();\n            ServletResponse response = ThreadContext.getServletResponse();\n            return getSession( request, response );\n        }\n    }\n\n    /**\n     * Returns the Session associated with the specified request if it is valid or <tt>null<\/tt> if a Session doesn't\n     * exist or it was invalid.\n     *\n     * @param request  incoming servlet request\n     * @param response outgoing servlet response\n     * @return the Session associated with the incoming request or <tt>null<\/tt> if one does not exist.\n     * @throws org.jsecurity.session.InvalidSessionException if the associated Session has expired prior to invoking this method.\n     * @throws org.jsecurity.authz.AuthorizationException  if the caller is not authorized to access the session associated with the request.\n     */\n    public final Session getSession( ServletRequest request, ServletResponse response )\n        throws InvalidSessionException, AuthorizationException {\n\n        Session session;\n        try {\n            session = doGetSession( request, response );\n        } catch ( InvalidSessionException ise ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Request Session is invalid, message: [\" + ise.getMessage() + \"].  Removing any \" +\n                        \"associated session cookie...\" );\n            }\n            getSessionIdCookieAttribute().removeValue(request,response);\n\n            //give subclass a chance to do something additional if necessary.  Otherwise returning null is just fine:\n            session = handleInvalidSession( request, response, ise );\n        }\n\n        return session;\n    }\n\n    protected Session doGetSession( ServletRequest request, ServletResponse response ) {\n\n        Session session = null;\n        Serializable sessionId = retrieveSessionId( request, response );\n\n        if ( sessionId != null ) {\n            request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID, sessionId );\n            session = super.doGetSession( sessionId );\n            if ( isValidateRequestOrigin() ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"Validating request origin against session origin\" );\n                }\n                validateSessionOrigin( request, session );\n            }\n            if ( session != null ) {\n                request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE );\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No JSecurity session id associated with the given \" +\n                    \"HttpServletRequest.  A Session will not be returned.\" );\n            }\n        }\n\n        return session;\n    }\n\n    protected Session handleInvalidSession( ServletRequest request,\n                                            ServletResponse response,\n                                            InvalidSessionException ise ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Sesssion associated with the current request is nonexistent or invalid.  Returning null.\");\n        }\n        return null;\n    }\n\n    protected void onStop(Session session) {\n        super.onStop(session);\n        getSessionIdCookieAttribute().removeValue(ThreadContext.getServletRequest(), ThreadContext.getServletResponse());\n    }\n}\n","lineNo":290}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web.session;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.mgt.DefaultSessionManager;\nimport org.jsecurity.web.SecurityWebSupport;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.attr.CookieAttribute;\nimport org.jsecurity.web.attr.RequestParamAttribute;\nimport org.jsecurity.web.attr.WebAttribute;\nimport org.jsecurity.web.servlet.JSecurityHttpServletRequest;\nimport org.jsecurity.web.servlet.JSecurityHttpSession;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\nimport java.net.InetAddress;\n\n/**\n * Web-application capable <tt>SessionManager<\/tt> implementation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class DefaultWebSessionManager extends DefaultSessionManager implements WebSessionManager {\n\n    /**\n     * Property specifying if, after a session object is acquired from the request, if that session should be\n     * validated to ensure the starting origin of the session is the same as the incoming request.\n     */\n    private boolean validateRequestOrigin = false; //default\n\n    protected CookieAttribute<Serializable> sessionIdCookieAttribute = null;\n    protected RequestParamAttribute<Serializable> sessionIdRequestParamAttribute = null;\n\n    public DefaultWebSessionManager() {\n    }\n\n    public CookieAttribute<Serializable> getSessionIdCookieAttribute() {\n        return sessionIdCookieAttribute;\n    }\n\n    public void setSessionIdCookieAttribute( CookieAttribute<Serializable> sessionIdCookieAttribute) {\n        this.sessionIdCookieAttribute = sessionIdCookieAttribute;\n    }\n\n    public RequestParamAttribute<Serializable> getSessionIdRequestParamAttribute() {\n        return sessionIdRequestParamAttribute;\n    }\n\n    public void setSessionIdRequestParamAttribute( RequestParamAttribute<Serializable> sessionIdRequestParamAttribute) {\n        this.sessionIdRequestParamAttribute = sessionIdRequestParamAttribute;\n    }\n\n    /**\n     * If set to <tt>true<\/tt>, this implementation will ensure that any\n     * <tt>HttpRequest<\/tt> attempting\n     * to join a session (i.e. via {@link #getSession getSession} must have the same\n     * IP Address of the <tt>HttpRequest<\/tt> that started the session.\n     * <p/>\n     * <p> If set to <tt>false<\/tt>, any <tt>HttpRequest<\/tt> with a reference to a valid\n     * session id may acquire that <tt>Session<\/tt>.\n     * <p/>\n     * <p>Although convenient, this should only be enabled in environments where the\n     * system can <em>guarantee<\/em> that each IP address represents one and only one\n     * machine accessing the system.\n     * <p/>\n     * <p>Public websites are not good candidates for enabling this\n     * feature since many browser clients often sit behind NAT routers (in\n     * which case many machines are viewed to come from the same IP, thereby making this\n     * validation check useless).  Also, some internet service providers (e.g. AOL) may change a\n     * client's IP in mid-session, making subsequent requests appear to come from a different\n     * location.  Again, this feature should only be enabled where IP Addresses can be guaranteed a\n     * 1-to-1 relationship with a user's session.\n     * <p/>\n     * <p>For the reasons specified above, this property is <tt>false<\/tt> by default.\n     *\n     * @return true if this factory will verify each HttpRequest joining a session\n     */\n    public boolean isValidateRequestOrigin() {\n        return validateRequestOrigin;\n    }\n\n    /**\n     * Sets whether or not a request's origin will be validated when accessing a session.  See\n     * the {@link #isValidateRequestOrigin} JavaDoc for an in-depth explanation of this property.\n     *\n     * @param validateRequestOrigin whether or not to validate the request's origin when accessing\n     *                              a session.\n     * @see #isValidateRequestOrigin\n     */\n    public void setValidateRequestOrigin( boolean validateRequestOrigin ) {\n        this.validateRequestOrigin = validateRequestOrigin;\n    }\n\n    public void init() {\n        super.init();\n        ensureCookieSessionIdStore();\n        ensureRequestParamSessionIdStore();\n    }\n\n    protected void ensureCookieSessionIdStore() {\n        CookieAttribute<Serializable> cookieStore = getSessionIdCookieAttribute();\n        if ( cookieStore == null ) {\n            cookieStore = new CookieAttribute<Serializable>( JSecurityHttpSession.DEFAULT_SESSION_ID_NAME );\n            cookieStore.setCheckRequestParams( false );\n            setSessionIdCookieAttribute( cookieStore );\n        }\n    }\n\n    protected void ensureRequestParamSessionIdStore() {\n        RequestParamAttribute<Serializable> reqParamStore = getSessionIdRequestParamAttribute();\n        if ( reqParamStore == null ) {\n            reqParamStore = new RequestParamAttribute<Serializable>( JSecurityHttpSession.DEFAULT_SESSION_ID_NAME );\n            setSessionIdRequestParamAttribute( reqParamStore );\n        }\n    }\n\n    protected void validateSessionOrigin( ServletRequest request, Session session )\n        throws HostUnauthorizedException {\n        InetAddress requestIp = SecurityWebSupport.getInetAddress( request );\n        InetAddress originIp = session.getHostAddress();\n        Serializable sessionId = session.getId();\n\n        if ( originIp == null ) {\n            if ( requestIp != null ) {\n                String msg = \"No IP Address was specified when creating session with id [\" +\n                    sessionId + \"].  Attempting to access session from \" +\n                    \"IP [\" + requestIp + \"].  Origin IP and request IP must match.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        } else {\n            if ( requestIp != null ) {\n                if ( !requestIp.equals( originIp ) ) {\n                    String msg = \"Session with id [\" + sessionId + \"] originated from [\" +\n                        originIp + \"], but the current HttpServletRequest originated \" +\n                        \"from [\" + requestIp + \"].  Disallowing session access: \" +\n                        \"session origin and request origin must match to allow access.\";\n                    throw new HostUnauthorizedException( msg );\n                }\n\n            } else {\n                String msg = \"No IP Address associated with the current HttpServletRequest.  \" +\n                    \"Session with id [\" + sessionId + \"] originated from \" +\n                    \"[\" + originIp + \"].  Request IP must match the session's origin \" +\n                    \"IP in order to gain access to that session.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        }\n    }\n\n    protected void storeSessionId( Serializable currentId, ServletRequest request, ServletResponse response ) {\n        if ( currentId == null ) {\n            String msg = \"sessionId cannot be null when persisting for subsequent requests.\";\n            throw new IllegalArgumentException( msg );\n        }\n        //ensure that the id has been set in the idStore, or if it already has, that it is not different than the\n        //'real' session value:\n        Serializable existingId = retrieveSessionId( request, response );\n        if ( existingId == null || !currentId.equals( existingId ) ) {\n            getSessionIdCookieAttribute().storeValue( currentId, request, response );\n        }\n    }\n\n    protected Serializable retrieveSessionId( ServletRequest request, ServletResponse response ) {\n        WebAttribute<Serializable> cookieSessionIdAttribute = getSessionIdCookieAttribute();\n        Serializable id = cookieSessionIdAttribute.retrieveValue( request, response );\n        if ( id != null ) {\n            request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                JSecurityHttpServletRequest.COOKIE_SESSION_ID_SOURCE );\n        } else {\n            id = getSessionIdRequestParamAttribute().retrieveValue( request, response );\n            if ( id != null ) {\n                request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                    JSecurityHttpServletRequest.URL_SESSION_ID_SOURCE );\n            }\n        }\n        return id;\n    }\n\n    public Serializable start(InetAddress hostAddress) throws HostUnauthorizedException, IllegalArgumentException {\n        ServletRequest request = WebUtils.getServletRequest();\n        ServletResponse response = WebUtils.getServletResponse();\n        return start( request, response, hostAddress );\n    }\n\n    protected Serializable start( ServletRequest request, ServletResponse response, InetAddress inetAddress ) {\n        Serializable sessionId = super.start( inetAddress );\n        storeSessionId( sessionId, request, response );\n        request.removeAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE );\n        request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_IS_NEW, Boolean.TRUE );\n        return sessionId;\n    }\n\n    public Session doGetSession(Serializable sessionId) throws InvalidSessionException, AuthorizationException {\n        if ( sessionId != null ) {\n            return super.doGetSession( sessionId );\n        } else {\n            ServletRequest request = WebUtils.getServletRequest();\n            ServletResponse response = WebUtils.getServletResponse();\n            return getSession( request, response );\n        }\n    }\n\n    /**\n     * Returns the Session associated with the specified request if it is valid or <tt>null<\/tt> if a Session doesn't\n     * exist or it was invalid.\n     *\n     * @param request  incoming servlet request\n     * @param response outgoing servlet response\n     * @return the Session associated with the incoming request or <tt>null<\/tt> if one does not exist.\n     * @throws org.jsecurity.session.InvalidSessionException if the associated Session has expired prior to invoking this method.\n     * @throws org.jsecurity.authz.AuthorizationException  if the caller is not authorized to access the session associated with the request.\n     */\n    public final Session getSession( ServletRequest request, ServletResponse response )\n        throws InvalidSessionException, AuthorizationException {\n\n        Session session;\n        try {\n            session = doGetSession( request, response );\n        } catch ( InvalidSessionException ise ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Request Session is invalid, message: [\" + ise.getMessage() + \"].  Removing any \" +\n                        \"associated session cookie...\" );\n            }\n            getSessionIdCookieAttribute().removeValue(request,response);\n\n            //give subclass a chance to do something additional if necessary.  Otherwise returning null is just fine:\n            session = handleInvalidSession( request, response, ise );\n        }\n\n        return session;\n    }\n\n    protected Session doGetSession( ServletRequest request, ServletResponse response ) {\n\n        Session session = null;\n        Serializable sessionId = retrieveSessionId( request, response );\n\n        if ( sessionId != null ) {\n            request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID, sessionId );\n            session = super.doGetSession( sessionId );\n            if ( isValidateRequestOrigin() ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"Validating request origin against session origin\" );\n                }\n                validateSessionOrigin( request, session );\n            }\n            if ( session != null ) {\n                request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE );\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No JSecurity session id associated with the given \" +\n                    \"HttpServletRequest.  A Session will not be returned.\" );\n            }\n        }\n\n        return session;\n    }\n\n    protected Session handleInvalidSession( ServletRequest request,\n                                            ServletResponse response,\n                                            InvalidSessionException ise ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Sesssion associated with the current request is nonexistent or invalid.  Returning null.\");\n        }\n        return null;\n    }\n\n    protected void onStop(Session session) {\n        super.onStop(session);\n        ServletRequest request = WebUtils.getServletRequest();\n        ServletResponse response = WebUtils.getServletResponse();\n        getSessionIdCookieAttribute().removeValue(request, response);\n    }\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web.session;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.mgt.DefaultSessionManager;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.SecurityWebSupport;\nimport org.jsecurity.web.attr.CookieAttribute;\nimport org.jsecurity.web.attr.RequestParamAttribute;\nimport org.jsecurity.web.attr.WebAttribute;\nimport org.jsecurity.web.servlet.JSecurityHttpServletRequest;\nimport org.jsecurity.web.servlet.JSecurityHttpSession;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\nimport java.net.InetAddress;\n\n/**\n * Web-application capable <tt>SessionManager<\/tt> implementation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class DefaultWebSessionManager extends DefaultSessionManager implements WebSessionManager {\n\n    /**\n     * Property specifying if, after a session object is acquired from the request, if that session should be\n     * validated to ensure the starting origin of the session is the same as the incoming request.\n     */\n    private boolean validateRequestOrigin = false; //default\n\n    protected CookieAttribute<Serializable> sessionIdCookieAttribute = null;\n    protected RequestParamAttribute<Serializable> sessionIdRequestParamAttribute = null;\n\n    public DefaultWebSessionManager() {\n    }\n\n    public CookieAttribute<Serializable> getSessionIdCookieAttribute() {\n        return sessionIdCookieAttribute;\n    }\n\n    public void setSessionIdCookieAttribute( CookieAttribute<Serializable> sessionIdCookieAttribute) {\n        this.sessionIdCookieAttribute = sessionIdCookieAttribute;\n    }\n\n    public RequestParamAttribute<Serializable> getSessionIdRequestParamAttribute() {\n        return sessionIdRequestParamAttribute;\n    }\n\n    public void setSessionIdRequestParamAttribute( RequestParamAttribute<Serializable> sessionIdRequestParamAttribute) {\n        this.sessionIdRequestParamAttribute = sessionIdRequestParamAttribute;\n    }\n\n    /**\n     * If set to <tt>true<\/tt>, this implementation will ensure that any\n     * <tt>HttpRequest<\/tt> attempting\n     * to join a session (i.e. via {@link #getSession getSession} must have the same\n     * IP Address of the <tt>HttpRequest<\/tt> that started the session.\n     * <p/>\n     * <p> If set to <tt>false<\/tt>, any <tt>HttpRequest<\/tt> with a reference to a valid\n     * session id may acquire that <tt>Session<\/tt>.\n     * <p/>\n     * <p>Although convenient, this should only be enabled in environments where the\n     * system can <em>guarantee<\/em> that each IP address represents one and only one\n     * machine accessing the system.\n     * <p/>\n     * <p>Public websites are not good candidates for enabling this\n     * feature since many browser clients often sit behind NAT routers (in\n     * which case many machines are viewed to come from the same IP, thereby making this\n     * validation check useless).  Also, some internet service providers (e.g. AOL) may change a\n     * client's IP in mid-session, making subsequent requests appear to come from a different\n     * location.  Again, this feature should only be enabled where IP Addresses can be guaranteed a\n     * 1-to-1 relationship with a user's session.\n     * <p/>\n     * <p>For the reasons specified above, this property is <tt>false<\/tt> by default.\n     *\n     * @return true if this factory will verify each HttpRequest joining a session\n     */\n    public boolean isValidateRequestOrigin() {\n        return validateRequestOrigin;\n    }\n\n    /**\n     * Sets whether or not a request's origin will be validated when accessing a session.  See\n     * the {@link #isValidateRequestOrigin} JavaDoc for an in-depth explanation of this property.\n     *\n     * @param validateRequestOrigin whether or not to validate the request's origin when accessing\n     *                              a session.\n     * @see #isValidateRequestOrigin\n     */\n    public void setValidateRequestOrigin( boolean validateRequestOrigin ) {\n        this.validateRequestOrigin = validateRequestOrigin;\n    }\n\n    public void init() {\n        super.init();\n        ensureCookieSessionIdStore();\n        ensureRequestParamSessionIdStore();\n    }\n\n    protected void ensureCookieSessionIdStore() {\n        CookieAttribute<Serializable> cookieStore = getSessionIdCookieAttribute();\n        if ( cookieStore == null ) {\n            cookieStore = new CookieAttribute<Serializable>( JSecurityHttpSession.DEFAULT_SESSION_ID_NAME );\n            cookieStore.setCheckRequestParams( false );\n            setSessionIdCookieAttribute( cookieStore );\n        }\n    }\n\n    protected void ensureRequestParamSessionIdStore() {\n        RequestParamAttribute<Serializable> reqParamStore = getSessionIdRequestParamAttribute();\n        if ( reqParamStore == null ) {\n            reqParamStore = new RequestParamAttribute<Serializable>( JSecurityHttpSession.DEFAULT_SESSION_ID_NAME );\n            setSessionIdRequestParamAttribute( reqParamStore );\n        }\n    }\n\n    protected void validateSessionOrigin( ServletRequest request, Session session )\n        throws HostUnauthorizedException {\n        InetAddress requestIp = SecurityWebSupport.getInetAddress( request );\n        InetAddress originIp = session.getHostAddress();\n        Serializable sessionId = session.getId();\n\n        if ( originIp == null ) {\n            if ( requestIp != null ) {\n                String msg = \"No IP Address was specified when creating session with id [\" +\n                    sessionId + \"].  Attempting to access session from \" +\n                    \"IP [\" + requestIp + \"].  Origin IP and request IP must match.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        } else {\n            if ( requestIp != null ) {\n                if ( !requestIp.equals( originIp ) ) {\n                    String msg = \"Session with id [\" + sessionId + \"] originated from [\" +\n                        originIp + \"], but the current HttpServletRequest originated \" +\n                        \"from [\" + requestIp + \"].  Disallowing session access: \" +\n                        \"session origin and request origin must match to allow access.\";\n                    throw new HostUnauthorizedException( msg );\n                }\n\n            } else {\n                String msg = \"No IP Address associated with the current HttpServletRequest.  \" +\n                    \"Session with id [\" + sessionId + \"] originated from \" +\n                    \"[\" + originIp + \"].  Request IP must match the session's origin \" +\n                    \"IP in order to gain access to that session.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        }\n    }\n\n    protected void storeSessionId( Serializable currentId, ServletRequest request, ServletResponse response ) {\n        if ( currentId == null ) {\n            String msg = \"sessionId cannot be null when persisting for subsequent requests.\";\n            throw new IllegalArgumentException( msg );\n        }\n        //ensure that the id has been set in the idStore, or if it already has, that it is not different than the\n        //'real' session value:\n        Serializable existingId = retrieveSessionId( request, response );\n        if ( existingId == null || !currentId.equals( existingId ) ) {\n            getSessionIdCookieAttribute().storeValue( currentId, request, response );\n        }\n    }\n\n    protected Serializable retrieveSessionId( ServletRequest request, ServletResponse response ) {\n        WebAttribute<Serializable> cookieSessionIdAttribute = getSessionIdCookieAttribute();\n        Serializable id = cookieSessionIdAttribute.retrieveValue( request, response );\n        if ( id != null ) {\n            request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                JSecurityHttpServletRequest.COOKIE_SESSION_ID_SOURCE );\n        } else {\n            id = getSessionIdRequestParamAttribute().retrieveValue( request, response );\n            if ( id != null ) {\n                request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                    JSecurityHttpServletRequest.URL_SESSION_ID_SOURCE );\n            }\n        }\n        return id;\n    }\n\n    public Serializable start(InetAddress hostAddress) throws HostUnauthorizedException, IllegalArgumentException {\n        ServletRequest request = ThreadContext.getServletRequest();\n        ServletResponse response = ThreadContext.getServletResponse();\n        return start( request, response, hostAddress );\n    }\n\n    protected Serializable start( ServletRequest request, ServletResponse response, InetAddress inetAddress ) {\n        Serializable sessionId = super.start( inetAddress );\n        storeSessionId( sessionId, request, response );\n        request.removeAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE );\n        request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_IS_NEW, Boolean.TRUE );\n        return sessionId;\n    }\n\n    public Session doGetSession(Serializable sessionId) throws InvalidSessionException, AuthorizationException {\n        if ( sessionId != null ) {\n            return super.doGetSession( sessionId );\n        } else {\n            ServletRequest request = ThreadContext.getServletRequest();\n            ServletResponse response = ThreadContext.getServletResponse();\n            return getSession( request, response );\n        }\n    }\n\n    /**\n     * Returns the Session associated with the specified request if it is valid or <tt>null<\/tt> if a Session doesn't\n     * exist or it was invalid.\n     *\n     * @param request  incoming servlet request\n     * @param response outgoing servlet response\n     * @return the Session associated with the incoming request or <tt>null<\/tt> if one does not exist.\n     * @throws org.jsecurity.session.InvalidSessionException if the associated Session has expired prior to invoking this method.\n     * @throws org.jsecurity.authz.AuthorizationException  if the caller is not authorized to access the session associated with the request.\n     */\n    public final Session getSession( ServletRequest request, ServletResponse response )\n        throws InvalidSessionException, AuthorizationException {\n\n        Session session;\n        try {\n            session = doGetSession( request, response );\n        } catch ( InvalidSessionException ise ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Request Session is invalid, message: [\" + ise.getMessage() + \"].  Removing any \" +\n                        \"associated session cookie...\" );\n            }\n            getSessionIdCookieAttribute().removeValue(request,response);\n\n            //give subclass a chance to do something additional if necessary.  Otherwise returning null is just fine:\n            session = handleInvalidSession( request, response, ise );\n        }\n\n        return session;\n    }\n\n    protected Session doGetSession( ServletRequest request, ServletResponse response ) {\n\n        Session session = null;\n        Serializable sessionId = retrieveSessionId( request, response );\n\n        if ( sessionId != null ) {\n            request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID, sessionId );\n            session = super.doGetSession( sessionId );\n            if ( isValidateRequestOrigin() ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"Validating request origin against session origin\" );\n                }\n                validateSessionOrigin( request, session );\n            }\n            if ( session != null ) {\n                request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE );\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No JSecurity session id associated with the given \" +\n                    \"HttpServletRequest.  A Session will not be returned.\" );\n            }\n        }\n\n        return session;\n    }\n\n    protected Session handleInvalidSession( ServletRequest request,\n                                            ServletResponse response,\n                                            InvalidSessionException ise ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Sesssion associated with the current request is nonexistent or invalid.  Returning null.\");\n        }\n        return null;\n    }\n\n    protected void onStop(Session session) {\n        super.onStop(session);\n        getSessionIdCookieAttribute().removeValue(ThreadContext.getServletRequest(), ThreadContext.getServletResponse());\n    }\n}\n","lineNo":291}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.RememberMeAuthenticationToken;\nimport org.jsecurity.crypto.BlowfishCipher;\nimport org.jsecurity.crypto.Cipher;\nimport org.jsecurity.io.DefaultSerializer;\nimport org.jsecurity.io.SerializationException;\nimport org.jsecurity.io.Serializer;\n\n/**\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AbstractRememberMeManager implements RememberMeManager {\n\n    protected transient final Log log = LogFactory.getLog(getClass());\n\n    private Serializer serializer = new DefaultSerializer();\n    private Cipher cipher = new BlowfishCipher();\n\n    public AbstractRememberMeManager() {\n    }\n\n    public Serializer getSerializer() {\n        return serializer;\n    }\n\n    public void setSerializer(Serializer serializer) {\n        this.serializer = serializer;\n    }\n\n    public Cipher getCipher() {\n        return cipher;\n    }\n\n    public void setCipher(Cipher cipher) {\n        this.cipher = cipher;\n    }\n\n    protected boolean isRememberMe(AuthenticationToken token) {\n        return token != null && (token instanceof RememberMeAuthenticationToken) &&\n            ((RememberMeAuthenticationToken) token).isRememberMe();\n    }\n\n    public void onSuccessfulLogin(AuthenticationToken token, Account account) {\n        if (isRememberMe(token)) {\n            rememberIdentity(token, account);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"AuthenticationToken did not indicate RememberMe is requested.  \" +\n                    \"RememberMe functionality will not be executed for corresponding Account.\");\n            }\n        }\n    }\n\n    public void rememberIdentity(AuthenticationToken submittedToken, Account successfullyAuthenticated) {\n        rememberIdentity(successfullyAuthenticated);\n    }\n\n    public void rememberIdentity(Account successfullyAuthenticated) {\n        PrincipalCollection principals = getIdentityToRemember(successfullyAuthenticated);\n        rememberIdentity(principals);\n    }\n\n    protected PrincipalCollection getIdentityToRemember(Account account) {\n        return account.getPrincipals();\n    }\n\n    protected byte[] encrypt(byte[] serialized) {\n        byte[] value = serialized;\n        Cipher cipher = getCipher();\n        if (cipher != null) {\n            value = cipher.encrypt(serialized, null);\n        }\n        return value;\n    }\n\n    protected byte[] decrypt(byte[] encrypted) {\n        byte[] serialized = encrypted;\n        Cipher cipher = getCipher();\n        if (cipher != null) {\n            serialized = cipher.decrypt(encrypted, null);\n        }\n        return serialized;\n    }\n\n    protected void rememberIdentity(PrincipalCollection accountPrincipals) {\n        try {\n            byte[] bytes = serialize(accountPrincipals);\n            if (getCipher() != null) {\n                bytes = encrypt(bytes);\n            }\n            rememberSerializedIdentity(bytes);\n        } catch (SerializationException se) {\n            if ( log.isWarnEnabled() ) {\n                log.warn(\"Unable to serialize account principals [\" + accountPrincipals + \"].  Identity \" +\n                    \"cannot be remembered!  This is a non fatal exception as RememberMe identity services \" +\n                    \"are not considered critical and execution can continue as normal.  But please \" +\n                    \"investigate and resolve to prevent seeing this message again.\", se );\n            }\n        }\n    }\n\n    protected byte[] serialize(PrincipalCollection principals) {\n        return getSerializer().serialize(principals);\n    }\n\n    protected abstract void rememberSerializedIdentity(byte[] serialized);\n\n    public PrincipalCollection getRememberedPrincipals() {\n        PrincipalCollection principals = null;\n        byte[] bytes = getSerializedRememberedIdentity();\n        if (bytes != null) {\n            if (getCipher() != null) {\n                bytes = decrypt(bytes);\n            }\n            try {\n                principals = deserialize(bytes);\n            } catch (SerializationException e) {\n                if ( log.isWarnEnabled() ) {\n                    log.warn(\"Unable to deserialize stored identity byte array.  Remembered identity \" +\n                        \"cannot be reconstituted!  This is a non fatal exception as RememberMe identity services \" +\n                        \"are not considered critical and execution can continue as normal, but please \" +\n                        \"investigate and resolve to prevent seeing this message again.\", e );\n                }\n            }\n        }\n        return principals;\n    }\n\n    protected PrincipalCollection deserialize(byte[] serializedIdentity) {\n        return (PrincipalCollection)getSerializer().deserialize(serializedIdentity);\n    }\n\n    protected abstract byte[] getSerializedRememberedIdentity();\n\n    public void onFailedLogin(AuthenticationToken token, AuthenticationException ae) {\n        forgetIdentity(token, ae);\n    }\n\n    public void onLogout(PrincipalCollection subjectPrincipals) {\n        forgetIdentity();\n    }\n\n    protected void forgetIdentity(AuthenticationToken token, AuthenticationException ae) {\n        forgetIdentity(token);\n    }\n\n    protected void forgetIdentity(AuthenticationToken token) {\n        forgetIdentity();\n    }\n\n    protected abstract void forgetIdentity();\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.RememberMeAuthenticationToken;\nimport org.jsecurity.crypto.BlowfishCipher;\nimport org.jsecurity.crypto.Cipher;\nimport org.jsecurity.util.Serializer;\nimport org.jsecurity.util.XmlSerializer;\n\n/**\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AbstractRememberMeManager implements RememberMeManager {\n\n    protected transient final Log log = LogFactory.getLog(getClass());\n\n    private Serializer serializer = new XmlSerializer();\n    private Cipher cipher = new BlowfishCipher();\n\n    public AbstractRememberMeManager() {\n    }\n\n    public AbstractRememberMeManager(Serializer serializer) {\n        setSerializer(serializer);\n    }\n\n    public AbstractRememberMeManager(Serializer serializer, Cipher cipher) {\n        setSerializer(serializer);\n        setCipher(cipher);\n    }\n\n    public Serializer getSerializer() {\n        return serializer;\n    }\n\n    public void setSerializer(Serializer serializer) {\n        this.serializer = serializer;\n    }\n\n    public Cipher getCipher() {\n        return cipher;\n    }\n\n    public void setCipher(Cipher cipher) {\n        this.cipher = cipher;\n    }\n\n    protected boolean isRememberMe(AuthenticationToken token) {\n        return token != null && (token instanceof RememberMeAuthenticationToken) &&\n            ((RememberMeAuthenticationToken) token).isRememberMe();\n    }\n\n    public void onSuccessfulLogin(AuthenticationToken token, Account account) {\n        if (isRememberMe(token)) {\n            rememberIdentity(token, account);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"AuthenticationToken did not indicate RememberMe is requested.  \" +\n                    \"RememberMe functionality will not be executed for corresponding Account.\");\n            }\n        }\n    }\n\n    public void rememberIdentity(AuthenticationToken submittedToken, Account successfullyAuthenticated) {\n        rememberIdentity(successfullyAuthenticated);\n    }\n\n    public void rememberIdentity(Account successfullyAuthenticated) {\n        PrincipalCollection principals = getIdentityToRemember(successfullyAuthenticated);\n        rememberIdentity(principals);\n    }\n\n    protected PrincipalCollection getIdentityToRemember(Account account) {\n        return account.getPrincipals();\n    }\n\n    protected byte[] encrypt(byte[] serialized) {\n        Cipher cipher = getCipher();\n        if (cipher != null) {\n            return cipher.encrypt(serialized, null);\n        }\n        return serialized;\n    }\n\n    protected byte[] decrypt(byte[] encrypted) {\n        byte[] serialized = encrypted;\n        Cipher cipher = getCipher();\n        if (cipher != null) {\n            serialized = cipher.decrypt(encrypted, null);\n        }\n        return serialized;\n    }\n\n    protected void rememberIdentity(PrincipalCollection accountPrincipals) {\n        byte[] bytes = serialize(accountPrincipals);\n        if (getCipher() != null) {\n            bytes = encrypt(bytes);\n        }\n        rememberSerializedIdentity(bytes);\n    }\n\n    protected byte[] serialize(PrincipalCollection principals) {\n        return getSerializer().serialize(principals);\n    }\n\n    protected abstract void rememberSerializedIdentity(byte[] serialized);\n\n    public PrincipalCollection getRememberedPrincipals() {\n        byte[] bytes = getSerializedRememberedIdentity();\n        if (bytes != null) {\n            if (getCipher() != null) {\n                bytes = decrypt(bytes);\n            }\n            return deserialize(bytes);\n        }\n        return null;\n    }\n\n    protected PrincipalCollection deserialize(byte[] serializedIdentity) {\n        return (PrincipalCollection)getSerializer().deserialize(serializedIdentity);\n    }\n\n    protected abstract byte[] getSerializedRememberedIdentity();\n\n    public void onFailedLogin(AuthenticationToken token, AuthenticationException ae) {\n        forgetIdentity(token, ae);\n    }\n\n    public void onLogout(PrincipalCollection subjectPrincipals) {\n        forgetIdentity();\n    }\n\n    protected void forgetIdentity(AuthenticationToken token, AuthenticationException ae) {\n        forgetIdentity(token);\n    }\n\n    protected void forgetIdentity(AuthenticationToken token) {\n        forgetIdentity();\n    }\n\n    protected abstract void forgetIdentity();\n}\n","lineNo":90}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.RememberMeAuthenticationToken;\nimport org.jsecurity.crypto.BlowfishCipher;\nimport org.jsecurity.crypto.Cipher;\nimport org.jsecurity.io.DefaultSerializer;\nimport org.jsecurity.io.SerializationException;\nimport org.jsecurity.io.Serializer;\n\n/**\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AbstractRememberMeManager implements RememberMeManager {\n\n    protected transient final Log log = LogFactory.getLog(getClass());\n\n    private Serializer serializer = new DefaultSerializer();\n    private Cipher cipher = new BlowfishCipher();\n\n    public AbstractRememberMeManager() {\n    }\n\n    public Serializer getSerializer() {\n        return serializer;\n    }\n\n    public void setSerializer(Serializer serializer) {\n        this.serializer = serializer;\n    }\n\n    public Cipher getCipher() {\n        return cipher;\n    }\n\n    public void setCipher(Cipher cipher) {\n        this.cipher = cipher;\n    }\n\n    protected boolean isRememberMe(AuthenticationToken token) {\n        return token != null && (token instanceof RememberMeAuthenticationToken) &&\n            ((RememberMeAuthenticationToken) token).isRememberMe();\n    }\n\n    public void onSuccessfulLogin(AuthenticationToken token, Account account) {\n        if (isRememberMe(token)) {\n            rememberIdentity(token, account);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"AuthenticationToken did not indicate RememberMe is requested.  \" +\n                    \"RememberMe functionality will not be executed for corresponding Account.\");\n            }\n        }\n    }\n\n    public void rememberIdentity(AuthenticationToken submittedToken, Account successfullyAuthenticated) {\n        rememberIdentity(successfullyAuthenticated);\n    }\n\n    public void rememberIdentity(Account successfullyAuthenticated) {\n        PrincipalCollection principals = getIdentityToRemember(successfullyAuthenticated);\n        rememberIdentity(principals);\n    }\n\n    protected PrincipalCollection getIdentityToRemember(Account account) {\n        return account.getPrincipals();\n    }\n\n    protected byte[] encrypt(byte[] serialized) {\n        byte[] value = serialized;\n        Cipher cipher = getCipher();\n        if (cipher != null) {\n            value = cipher.encrypt(serialized, null);\n        }\n        return value;\n    }\n\n    protected byte[] decrypt(byte[] encrypted) {\n        byte[] serialized = encrypted;\n        Cipher cipher = getCipher();\n        if (cipher != null) {\n            serialized = cipher.decrypt(encrypted, null);\n        }\n        return serialized;\n    }\n\n    protected void rememberIdentity(PrincipalCollection accountPrincipals) {\n        try {\n            byte[] bytes = serialize(accountPrincipals);\n            if (getCipher() != null) {\n                bytes = encrypt(bytes);\n            }\n            rememberSerializedIdentity(bytes);\n        } catch (SerializationException se) {\n            if ( log.isWarnEnabled() ) {\n                log.warn(\"Unable to serialize account principals [\" + accountPrincipals + \"].  Identity \" +\n                    \"cannot be remembered!  This is a non fatal exception as RememberMe identity services \" +\n                    \"are not considered critical and execution can continue as normal.  But please \" +\n                    \"investigate and resolve to prevent seeing this message again.\", se );\n            }\n        }\n    }\n\n    protected byte[] serialize(PrincipalCollection principals) {\n        return getSerializer().serialize(principals);\n    }\n\n    protected abstract void rememberSerializedIdentity(byte[] serialized);\n\n    public PrincipalCollection getRememberedPrincipals() {\n        PrincipalCollection principals = null;\n        byte[] bytes = getSerializedRememberedIdentity();\n        if (bytes != null) {\n            if (getCipher() != null) {\n                bytes = decrypt(bytes);\n            }\n            try {\n                principals = deserialize(bytes);\n            } catch (SerializationException e) {\n                if ( log.isWarnEnabled() ) {\n                    log.warn(\"Unable to deserialize stored identity byte array.  Remembered identity \" +\n                        \"cannot be reconstituted!  This is a non fatal exception as RememberMe identity services \" +\n                        \"are not considered critical and execution can continue as normal, but please \" +\n                        \"investigate and resolve to prevent seeing this message again.\", e );\n                }\n            }\n        }\n        return principals;\n    }\n\n    protected PrincipalCollection deserialize(byte[] serializedIdentity) {\n        return (PrincipalCollection)getSerializer().deserialize(serializedIdentity);\n    }\n\n    protected abstract byte[] getSerializedRememberedIdentity();\n\n    public void onFailedLogin(AuthenticationToken token, AuthenticationException ae) {\n        forgetIdentity(token, ae);\n    }\n\n    public void onLogout(PrincipalCollection subjectPrincipals) {\n        forgetIdentity();\n    }\n\n    protected void forgetIdentity(AuthenticationToken token, AuthenticationException ae) {\n        forgetIdentity(token);\n    }\n\n    protected void forgetIdentity(AuthenticationToken token) {\n        forgetIdentity();\n    }\n\n    protected abstract void forgetIdentity();\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.RememberMeAuthenticationToken;\nimport org.jsecurity.crypto.BlowfishCipher;\nimport org.jsecurity.crypto.Cipher;\nimport org.jsecurity.util.Serializer;\nimport org.jsecurity.util.XmlSerializer;\n\n/**\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AbstractRememberMeManager implements RememberMeManager {\n\n    protected transient final Log log = LogFactory.getLog(getClass());\n\n    private Serializer serializer = new XmlSerializer();\n    private Cipher cipher = new BlowfishCipher();\n\n    public AbstractRememberMeManager() {\n    }\n\n    public AbstractRememberMeManager(Serializer serializer) {\n        setSerializer(serializer);\n    }\n\n    public AbstractRememberMeManager(Serializer serializer, Cipher cipher) {\n        setSerializer(serializer);\n        setCipher(cipher);\n    }\n\n    public Serializer getSerializer() {\n        return serializer;\n    }\n\n    public void setSerializer(Serializer serializer) {\n        this.serializer = serializer;\n    }\n\n    public Cipher getCipher() {\n        return cipher;\n    }\n\n    public void setCipher(Cipher cipher) {\n        this.cipher = cipher;\n    }\n\n    protected boolean isRememberMe(AuthenticationToken token) {\n        return token != null && (token instanceof RememberMeAuthenticationToken) &&\n            ((RememberMeAuthenticationToken) token).isRememberMe();\n    }\n\n    public void onSuccessfulLogin(AuthenticationToken token, Account account) {\n        if (isRememberMe(token)) {\n            rememberIdentity(token, account);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"AuthenticationToken did not indicate RememberMe is requested.  \" +\n                    \"RememberMe functionality will not be executed for corresponding Account.\");\n            }\n        }\n    }\n\n    public void rememberIdentity(AuthenticationToken submittedToken, Account successfullyAuthenticated) {\n        rememberIdentity(successfullyAuthenticated);\n    }\n\n    public void rememberIdentity(Account successfullyAuthenticated) {\n        PrincipalCollection principals = getIdentityToRemember(successfullyAuthenticated);\n        rememberIdentity(principals);\n    }\n\n    protected PrincipalCollection getIdentityToRemember(Account account) {\n        return account.getPrincipals();\n    }\n\n    protected byte[] encrypt(byte[] serialized) {\n        Cipher cipher = getCipher();\n        if (cipher != null) {\n            return cipher.encrypt(serialized, null);\n        }\n        return serialized;\n    }\n\n    protected byte[] decrypt(byte[] encrypted) {\n        byte[] serialized = encrypted;\n        Cipher cipher = getCipher();\n        if (cipher != null) {\n            serialized = cipher.decrypt(encrypted, null);\n        }\n        return serialized;\n    }\n\n    protected void rememberIdentity(PrincipalCollection accountPrincipals) {\n        byte[] bytes = serialize(accountPrincipals);\n        if (getCipher() != null) {\n            bytes = encrypt(bytes);\n        }\n        rememberSerializedIdentity(bytes);\n    }\n\n    protected byte[] serialize(PrincipalCollection principals) {\n        return getSerializer().serialize(principals);\n    }\n\n    protected abstract void rememberSerializedIdentity(byte[] serialized);\n\n    public PrincipalCollection getRememberedPrincipals() {\n        byte[] bytes = getSerializedRememberedIdentity();\n        if (bytes != null) {\n            if (getCipher() != null) {\n                bytes = decrypt(bytes);\n            }\n            return deserialize(bytes);\n        }\n        return null;\n    }\n\n    protected PrincipalCollection deserialize(byte[] serializedIdentity) {\n        return (PrincipalCollection)getSerializer().deserialize(serializedIdentity);\n    }\n\n    protected abstract byte[] getSerializedRememberedIdentity();\n\n    public void onFailedLogin(AuthenticationToken token, AuthenticationException ae) {\n        forgetIdentity(token, ae);\n    }\n\n    public void onLogout(PrincipalCollection subjectPrincipals) {\n        forgetIdentity();\n    }\n\n    protected void forgetIdentity(AuthenticationToken token, AuthenticationException ae) {\n        forgetIdentity(token);\n    }\n\n    protected void forgetIdentity(AuthenticationToken token) {\n        forgetIdentity();\n    }\n\n    protected abstract void forgetIdentity();\n}\n","lineNo":131}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.util.LifecycleUtils;\nimport org.jsecurity.web.WebSecurityManager;\n\nimport java.util.List;\n\n/**\n * Utility superclass for a web application that consolidates SecurityManager acquisition and/or creation logic during\n * application startup.  Subclasses are expected to utilize startup mechanisms/APIs supported by the Servlet Container\n * (for example, <tt>ServletContextListener<\/tt>, <tt>Servlet<\/tt>, etc), and call the methods in this class to\n * reduce the amount of code required.\n * <p/>\n * <p><b>Clean Architecture Note:<\/b> A JSecurity <tt>SecurityManager<\/tt> is really considered a business-tier\n * component and should be created in the application's business-tier configuration (e.g. Spring, Pico, Guice, JBoss,\n * etc) if such a configuration exists.  If this business-tier does exist, subclasses of this one should acquire and\n * return that instance by overriding the {@link #getSecurityManager() getSecurityManager()} method.<\/p>\n * <p/>\n * <p>If there is no business-tier, i.e. this is a 'pure' web application, then a <tt>SecurityManager<\/tt> instance\n * needs to be created (instantiated) explicitly.  This implementation will do this automatically by default, but if\n * you wish to change the default logic, you'll need to override the\n * {@link #createSecurityManager() createSecurityManager()} method.\n *\n * @see #getSecurityManager\n * @see #createSecurityManager\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class SecurityManagerLoader extends ServletContextSupport {\n\n    public static final String SECURITY_MANAGER_CONTEXT_KEY = SecurityManagerLoader.class.getName() + \"_SECURITY_MANAGER\";\n\n    private SecurityManager securityManager = null;\n\n    public void init() {\n        if (getServletContext() == null) {\n            throw new IllegalStateException(\"servletContext property must be set.\");\n        }\n        applySessionMode();\n        ensureSecurityManager();\n    }\n\n    public SecurityManager getSecurityManager() {\n        return this.securityManager;\n    }\n\n    protected List<Realm> getRealms() {\n        return null;\n    }\n\n    protected Realm getRealm() {\n        return null;\n    }\n\n    protected void bind(SecurityManager securityManager) {\n        bind(\"securityManager\", SECURITY_MANAGER_CONTEXT_KEY, securityManager);\n    }\n\n    protected SecurityManager createSecurityManager() {\n        WebSecurityManager defaultSecMgr = new WebSecurityManager();\n\n        String mode = getSessionMode();\n        if ( mode != null ) {\n            defaultSecMgr.setSessionMode( mode );\n        }\n\n        List<Realm> realms = getRealms();\n\n        if (realms != null && !realms.isEmpty()) {\n            defaultSecMgr.setRealms(realms);\n        } else {\n            Realm realm = getRealm();\n            if (realm != null) {\n                defaultSecMgr.setRealm(realm);\n            }\n        }\n\n        defaultSecMgr.init();\n\n        return defaultSecMgr;\n    }\n\n    public void ensureSecurityManager() {\n        SecurityManager securityManager = getSecurityManager();\n        if (securityManager == null) {\n            securityManager = createSecurityManager();\n            if (securityManager == null) {\n                String msg = \"securityManager instance returned from createSecurityManager() call cannot \" +\n                        \"be null.\";\n                throw new IllegalStateException(msg);\n            }\n            this.securityManager = securityManager;\n        }\n\n        bind(securityManager);\n    }\n\n    public void destroy() {\n        removeAttribute( SECURITY_MANAGER_CONTEXT_KEY );\n        LifecycleUtils.destroy( this.securityManager );\n        this.securityManager = null;\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.util.LifecycleUtils;\nimport org.jsecurity.web.WebSecurityManager;\n\nimport java.util.List;\n\n/**\n * Utility superclass for a web application that consolidates SecurityManager acquisition and/or creation logic during\n * application startup.  Subclasses are expected to utilize startup mechanisms/APIs supported by the Servlet Container\n * (for example, <tt>ServletContextListener<\/tt>, <tt>Servlet<\/tt>, etc), and call the methods in this class to\n * reduce the amount of code required.\n * <p/>\n * <p><b>Clean Architecture Note:<\/b> A JSecurity <tt>SecurityManager<\/tt> is really considered a business-tier\n * component and should be created in the application's business-tier configuration (e.g. Spring, Pico, Guice, JBoss,\n * etc) if such a configuration exists.  If this business-tier does exist, subclasses of this one should acquire and\n * return that instance by overriding the {@link #getSecurityManager() getSecurityManager()} method.<\/p>\n * <p/>\n * <p>If there is no business-tier, i.e. this is a 'pure' web application, then a <tt>SecurityManager<\/tt> instance\n * needs to be created (instantiated) explicitly.  This implementation will do this automatically by default, but if\n * you wish to change the default logic, you'll need to override the\n * {@link #createSecurityManager() createSecurityManager()} method.\n *\n * @see #getSecurityManager\n * @see #createSecurityManager\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class SecurityManagerLoader extends ServletContextSupport {\n\n    public static final String SECURITY_MANAGER_CONTEXT_KEY = SecurityManagerLoader.class.getName() + \"_SECURITY_MANAGER\";\n\n    private SecurityManager securityManager = null;\n\n    public void init() {\n        if (getServletContext() == null) {\n            throw new IllegalStateException(\"servletContext property must be set.\");\n        }\n        applySessionMode();\n        ensureSecurityManager();\n    }\n\n    public SecurityManager getSecurityManager() {\n        return this.securityManager;\n    }\n\n    protected List<Realm> getRealms() {\n        return null;\n    }\n\n    protected Realm getRealm() {\n        return null;\n    }\n\n    protected void bind(SecurityManager securityManager) {\n        bind(\"securityManager\", SECURITY_MANAGER_CONTEXT_KEY, securityManager);\n    }\n\n    protected SecurityManager createSecurityManager() {\n        WebSecurityManager defaultSecMgr = new WebSecurityManager();\n\n        defaultSecMgr.setSessionMode( getSessionMode() );\n\n        List<Realm> realms = getRealms();\n\n        if (realms != null && !realms.isEmpty()) {\n            defaultSecMgr.setRealms(realms);\n        } else {\n            Realm realm = getRealm();\n            if (realm != null) {\n                defaultSecMgr.setRealm(realm);\n            }\n        }\n\n        defaultSecMgr.init();\n\n        return defaultSecMgr;\n    }\n\n    public void ensureSecurityManager() {\n        org.jsecurity.mgt.SecurityManager securityManager = getSecurityManager();\n        if (securityManager == null) {\n            securityManager = createSecurityManager();\n            if (securityManager == null) {\n                String msg = \"securityManager instance returned from createSecurityManager() call cannot \" +\n                        \"be null.\";\n                throw new IllegalStateException(msg);\n            }\n            this.securityManager = securityManager;\n        }\n\n        bind(securityManager);\n    }\n\n    public void destroy() {\n        removeAttribute( SECURITY_MANAGER_CONTEXT_KEY );\n        LifecycleUtils.destroy( this.securityManager );\n        this.securityManager = null;\n    }\n\n}\n","lineNo":79}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.web.WebSecurityManager;\n\nimport javax.servlet.ServletContext;\n\n/**\n * TODO - class javadoc\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class ServletContextSupport {\n\n    public static final String SESSION_MODE_CONTEXT_PARAM_NAME = \"sessionMode\";\n    public static final String HTTP_SESSION_MODE = WebSecurityManager.HTTP_SESSION_MODE;\n    public static final String JSECURITY_SESSION_MODE = WebSecurityManager.JSECURITY_SESSION_MODE;\n\n    protected transient final Log log = LogFactory.getLog( getClass() );\n\n    private ServletContext servletContext = null;\n    private String sessionMode = null;\n\n    public ServletContext getServletContext() {\n        return servletContext;\n    }\n\n    public void setServletContext(ServletContext servletContext) {\n        this.servletContext = servletContext;\n    }\n\n    protected String getContextInitParam(String paramName) {\n        return getServletContext().getInitParameter(paramName);\n    }\n\n    private ServletContext getServletContextNullCheck() {\n        ServletContext servletContext = getServletContext();\n        if (servletContext == null) {\n            String msg = \"ServletContext property must be set via the setServletContext method.\";\n            throw new IllegalStateException(msg);\n        }\n        return servletContext;\n    }\n\n    protected void setAttribute( String key, Object value ) {\n        getServletContextNullCheck().setAttribute( key, value );\n    }\n\n    protected Object getAttribute( String key ) {\n        return getServletContextNullCheck().getAttribute( key );\n    }\n\n    protected void removeAttribute( String key ) {\n        getServletContextNullCheck().removeAttribute( key );\n    }\n\n    protected void bind(String name, String key, Object value) {\n        if (value == null) {\n            throw new IllegalArgumentException(name + \" argument cannot be null.\");\n        }\n        if (getAttribute(key) != null) {\n            String msg = name + \" already bound to ServletContext.  Please check your configuration to ensure \" +\n                    \"you don't have mutliple SecurityManager Loaders configured (listener, servlet, etc).\";\n            throw new IllegalStateException(msg);\n        }\n        setAttribute(key, value);\n    }\n\n    public String getSessionMode() {\n        return sessionMode;\n    }\n\n    public void setSessionMode(String mode) {\n        if (mode != null) {\n            mode = mode.trim().toLowerCase();\n            if (!mode.equals(HTTP_SESSION_MODE) && !mode.equals(JSECURITY_SESSION_MODE)) {\n                String msg = \"Unknown '\" + SESSION_MODE_CONTEXT_PARAM_NAME + \"' value [\" +\n                    mode + \"].  Recognized values are '\" +\n                        HTTP_SESSION_MODE + \"' and '\" + JSECURITY_SESSION_MODE +\n                    \"' (without quotes).  Please check your configuration and/or spelling.\";\n                throw new IllegalArgumentException(msg);\n            }\n            this.sessionMode = mode;\n        }\n    }\n\n    protected void applySessionMode() {\n        setSessionMode( getContextInitParam(SESSION_MODE_CONTEXT_PARAM_NAME) );\n    }\n\n    protected boolean isHttpSessions() {\n        String sessionMode = getSessionMode();\n        return sessionMode == null || sessionMode.equals(HTTP_SESSION_MODE);\n    }\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.web.WebSecurityManager;\n\nimport javax.servlet.ServletContext;\n\n/**\n * TODO - class javadoc\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class ServletContextSupport {\n\n    public static final String SESSION_MODE_CONTEXT_PARAM_NAME = \"sessionMode\";\n    public static final String HTTP_SESSION_MODE = WebSecurityManager.HTTP_SESSION_MODE;\n    public static final String JSECURITY_SESSION_MODE = WebSecurityManager.JSECURITY_SESSION_MODE;\n\n    protected transient final Log log = LogFactory.getLog( getClass() );\n\n    private ServletContext servletContext = null;\n    private String sessionMode = HTTP_SESSION_MODE; //default\n\n    public ServletContext getServletContext() {\n        return servletContext;\n    }\n\n    public void setServletContext(ServletContext servletContext) {\n        this.servletContext = servletContext;\n    }\n\n    protected String getContextInitParam(String paramName) {\n        return getServletContext().getInitParameter(paramName);\n    }\n\n    private ServletContext getServletContextNullCheck() {\n        ServletContext servletContext = getServletContext();\n        if (servletContext == null) {\n            String msg = \"ServletContext property must be set via the setServletContext method.\";\n            throw new IllegalStateException(msg);\n        }\n        return servletContext;\n    }\n\n    protected void setAttribute( String key, Object value ) {\n        getServletContextNullCheck().setAttribute( key, value );\n    }\n\n    protected Object getAttribute( String key ) {\n        return getServletContextNullCheck().getAttribute( key );\n    }\n\n    protected void removeAttribute( String key ) {\n        getServletContextNullCheck().removeAttribute( key );\n    }\n\n    protected void bind(String name, String key, Object value) {\n        if (value == null) {\n            throw new IllegalArgumentException(name + \" argument cannot be null.\");\n        }\n        if (getAttribute(key) != null) {\n            String msg = name + \" already bound to ServletContext.  Please check your configuration to ensure \" +\n                    \"you don't have mutliple SecurityManager Loaders configured (listener, servlet, etc).\";\n            throw new IllegalStateException(msg);\n        }\n        setAttribute(key, value);\n    }\n\n    public String getSessionMode() {\n        return sessionMode;\n    }\n\n    public void setSessionMode(String mode) {\n        if (mode != null) {\n            mode = mode.trim();\n            if (!mode.equalsIgnoreCase(HTTP_SESSION_MODE) &&\n                !mode.equalsIgnoreCase(JSECURITY_SESSION_MODE)) {\n                String msg = \"Unknown '\" + SESSION_MODE_CONTEXT_PARAM_NAME + \"' value [\" +\n                    mode + \"].  Recognized values are '\" +\n                        HTTP_SESSION_MODE + \"' and '\" + JSECURITY_SESSION_MODE +\n                    \"' (without quotes).  Please check your configuration and/or spelling.\";\n                throw new IllegalArgumentException(msg);\n            }\n            this.sessionMode = mode;\n        }\n    }\n\n    protected void applySessionMode() {\n        setSessionMode( getContextInitParam(SESSION_MODE_CONTEXT_PARAM_NAME) );\n    }\n\n    protected boolean isHttpSessions() {\n        return getSessionMode().equals(HTTP_SESSION_MODE);\n    }\n}\n","lineNo":109}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Les Hazlewood, Jeremy Haile\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * An <tt>AuthorizingRealm<\/tt> extends the <tt>AuthenticatingRealm<\/tt>'s capabilities by adding Authorization\n * (access control) support via the use of {@link AuthorizingAccount AuthorizingAccount} instances.\n *\n * <p>This implementation can only support Authorization operations if the subclass implementation's\n * {@link #getAccount(PrincipalCollection) getAccount(principals)} method returns an {@link AuthorizingAccount AuthorizingAccount}.\n * <p>If it does not, subclasses <em>must<\/em> override all {@link org.jsecurity.authz.Authorizer Authorizer} methods,\n * since the JSecurity default implementations cannot infer Role/Permission assignments via anything but\n * <tt>AuthorizingAccount<\/tt> instances.\n *\n * <p>If your Realm implementation does not want to deal with <tt>AuthorizingAccount<\/tt> constructs, you are of course\n * free to subclass the {@link AuthorizingRealm AuthorizingRealm} directly and implement the remaining\n * interface methods yourself.  Many people do this if they want to have better control over how the\n * Role and Permission checks occur for their specific data source.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.2\n */\npublic abstract class AuthorizingRealm extends AuthenticatingRealm implements Initializable, PermissionResolverAware {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * The default postfix appended to the realm name for caching Accounts.\n     */\n    private static final String DEFAULT_ACCOUNT_CACHE_POSTFIX = \"-accounts\";\n\n    private static int INSTANCE_COUNT = 0;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The cache used by this realm to store Accounts associated with individual Subject principals.\n     */\n    private Cache accountCache = null;\n    private String accountCacheName = null;\n\n    private PermissionResolver permissionResolver = new WildcardPermissionResolver();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AuthorizingRealm() {\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager) {\n        super(cacheManager);\n    }\n\n    public AuthorizingRealm(CredentialsMatcher matcher) {\n        super(matcher);\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager, CredentialsMatcher matcher) {\n        super(cacheManager, matcher);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAccountCache(Cache accountCache) {\n        this.accountCache = accountCache;\n    }\n\n    public Cache getAccountCache() {\n        return this.accountCache;\n    }\n\n    public String getAccountCacheName() {\n        return accountCacheName;\n    }\n\n    public void setAccountCacheName(String accountCacheName) {\n        this.accountCacheName = accountCacheName;\n    }\n\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Initializes this realm and potentially enables a cache, depending on configuration.\n     *\n     * <p>When this method is called, the following logic is executed:\n     * <ol>\n     * <li>If the {@link #setAccountCache cache} property has been set, it will be\n     * used to cache the Account objects returned from {@link #getAccount getAccount}\n     * method invocations.\n     * All future calls to <tt>getAccount<\/tt> will attempt to use this Account cache first\n     * to alleviate any potentially unnecessary calls to an underlying data store.<\/li>\n     * <li>If the {@link #setAccountCache cache} property has <b>not<\/b> been set,\n     * the {@link #setCacheManager cacheManager} property will be checked.\n     * If a <tt>cacheManager<\/tt> has been set, it will be used to create an Account\n     * <tt>cache<\/tt>, and this newly created cache which will be used as specified in #1.<\/li>\n     * <li>If neither the {@link #setAccountCache(org.jsecurity.cache.Cache) cache}\n     * or {@link #setCacheManager(org.jsecurity.cache.CacheManager) cacheManager}\n     * properties are set, caching will be disabled and Account lookups will be delegated to\n     * subclass implementations for each authorization check.<\/li>\n     * <\/ol>\n     */\n    public final void init() {\n        initAccountCache();\n        afterAccountCacheSet();\n    }\n\n    protected void afterAccountCacheSet() {\n    }\n\n    protected void initAccountCache() {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Initializing account cache.\");\n        }\n\n        Cache cache = getAccountCache();\n\n        if (cache == null) {\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"No cache implementation set.  Checking cacheManager...\");\n            }\n\n            CacheManager cacheManager = getCacheManager();\n\n            if (cacheManager != null) {\n                String cacheName = getAccountCacheName();\n                if (cacheName == null) {\n                    //Simple default in case they didn't provide one:\n                    cacheName = getClass().getName() + \"-\" + INSTANCE_COUNT++ + DEFAULT_ACCOUNT_CACHE_POSTFIX;\n                    setAccountCacheName(cacheName);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"CacheManager [\" + cacheManager + \"] has been configured.  Building \" +\n                            \"Account cache named [\" + cacheName + \"]\");\n                }\n                cache = cacheManager.getCache(cacheName);\n                setAccountCache(cache);\n            } else {\n                if (log.isInfoEnabled()) {\n                    log.info(\"No cache or cacheManager properties have been set.  Account caching is \" +\n                            \"disabled.\");\n                }\n            }\n        }\n    }\n\n\n\n    /**\n     * <p>Retrieves Account information for the given account principals.\n     *\n     * <p>If caching is enabled, the account cache will be checked first and if found, will return the cached account.\n     * If caching is disabled, or there is a cache miss from the cache lookup, the Account will be looked up from\n     * the underlying data store via the {@link #doGetAccount(PrincipalCollection)} method, which must be implemented by subclasses.\n     *\n     * <p>If caching is enabled, the retrieved Account from <tt>doGetAccount<\/tt> will be added to the account cache\n     * first and then returned.\n     *\n     * @param principals the primary identifying principals of the Account that should be retrieved.\n     * @return the Account associated with this princpal.\n     */\n    protected Account getAccount(PrincipalCollection principals) {\n\n        if (principals == null) {\n            return null;\n        }\n\n        Account account = null;\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Retrieving Account for principals [\" + principals + \"]\");\n        }\n\n        Cache accountCache = getAccountCache();\n        if (accountCache != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to retrieve the Account from cache.\");\n            }\n            Object key = getAccountCacheKey(principals);\n            account = (Account) accountCache.get(key);\n            if (log.isTraceEnabled()) {\n                if (account == null) {\n                    log.trace(\"No Account found in cache for principals [\" + principals + \"]\");\n                } else {\n                    log.trace(\"Account found in cache for principals [\" + principals + \"]\");\n                }\n            }\n        }\n\n\n        if (account == null) {\n            // Call template method if tbe Account was not found in a cache\n            account = doGetAccount(principals);\n            // If the account is not null and the cache has been created, then cache the account.\n            if (account != null && accountCache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching Account [\" + principals + \"].\");\n                }\n                Object key = getAccountCacheKey(principals);\n                accountCache.put(key, account);\n            }\n        }\n\n        return account;\n    }\n\n    protected Object getAccountCacheKey( PrincipalCollection principals ) {\n        return principals;\n    }\n\n    /**\n     * Template-pattern method to be implemented by subclasses to retrieve the Account for the given principal.\n     *\n     * @param principal the primary identifying principal of the Account that should be retrieved.\n     * @return the Account associated with this principal.\n     */\n    protected abstract AuthorizingAccount doGetAccount(PrincipalCollection principal);\n\n    protected AuthorizingAccount getAuthorizingAccount(PrincipalCollection principals) {\n        if (principals == null) {\n            throw new AuthorizationException(\"Specified principals argument is null and authorization checks cannot \" +\n                    \"occur without a known account identity.\");\n        }\n        Account account = getAccount(principals);\n        assertNotNullAccount(principals, account);\n        assertAuthorizingAccount(account);\n        return (AuthorizingAccount) account;\n    }\n\n    protected void assertNotNullAccount(PrincipalCollection principals, Account account) {\n        if (account == null) {\n            throw new MissingAccountException(\"No Account found for Subject principals [\" +\n                    principals + \"]\");\n        }\n    }\n\n    protected void assertAuthorizingAccount(Account account) {\n        if (!(account instanceof AuthorizingAccount)) {\n            String msg = \"Underlying Account instance [\" + account + \"] does not implement the \" +\n                    AuthorizingAccount.class.getName() + \" interface.  The JSecurity \" +\n                    AuthorizingRealm.class.getName() + \" class and its default implementations can only provide default \" +\n                    \"authorization (access control) support for Accounts that implement this interface.  If you do not \" +\n                    \"wish to implement this interface, you will need to override all of this Realm's Authorizer methods \" +\n                    \"to perform the authorization check explicitly.\\n\\nNote that there is nothing wrong with this \" +\n                    \"approach since it often gives finer control of how authorization checks occur, but you would have \" +\n                    \"to override these methods explicitly since JSecurity can't infer your application's security \" +\n                    \"data model.\";\n            throw new UnsupportedAccountException(msg);\n        }\n    }\n\n\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        return isPermitted(principals, p);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        AuthorizingAccount account = getAuthorizingAccount(principals);\n        return account.isPermitted(permission);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection subjectIdentifier, String... permissions) {\n        List<Permission> perms = new ArrayList<Permission>(permissions.length);\n        for (String permString : permissions) {\n            perms.add(getPermissionResolver().resolvePermission(permString));\n        }\n        return isPermitted(subjectIdentifier, perms);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        AuthorizingAccount account = getAuthorizingAccount(principals);\n        return account.isPermitted(permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection subjectIdentifier, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            Collection<Permission> perms = new ArrayList<Permission>(permissions.length);\n            for (String permString : permissions) {\n                perms.add(getPermissionResolver().resolvePermission(permString));\n            }\n            return isPermittedAll(subjectIdentifier, perms);\n        }\n        return false;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principal, Collection<Permission> permissions) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        return account != null && account.isPermittedAll(permissions);\n    }\n\n    public void checkPermission(PrincipalCollection subjectIdentifier, String permission) throws AuthorizationException {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        checkPermission(subjectIdentifier, p);\n    }\n\n    public void checkPermission(PrincipalCollection principal, Permission permission) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkPermission(permission);\n    }\n\n    public void checkPermissions(PrincipalCollection subjectIdentifier, String... permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (String permString : permissions) {\n                checkPermission(subjectIdentifier, permString);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection principal, Collection<Permission> permissions) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkPermissions(permissions);\n    }\n\n    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        return account.hasRole(roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principal, List<String> roleIdentifiers) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        boolean[] result = new boolean[roleIdentifiers != null ? roleIdentifiers.size() : 0];\n        if (account != null) {\n            result = account.hasRoles(roleIdentifiers);\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principal, Collection<String> roleIdentifiers) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        return account != null && account.hasAllRoles(roleIdentifiers);\n    }\n\n    public void checkRole(PrincipalCollection principal, String role) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkRole(role);\n    }\n\n    public void checkRoles(PrincipalCollection principal, Collection<String> roles) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkRoles(roles);\n    }\n\n    /**\n     * If account caching is enabled, this will remove the account from the cache.  Subclasses are free to override\n     * for additional behavior, but be sure to call <tt>super.onLogout<\/tt> to ensure cache cleanup.\n     *\n     * @param accountPrincipal the application-specific Subject/user identifier.\n     */\n    public void onLogout(PrincipalCollection accountPrincipal) {\n        Cache cache = getAccountCache();\n        //cache instance will be non-null if caching is enabled:\n        if (cache != null && accountPrincipal != null) {\n            Object key = getAccountCacheKey(accountPrincipal);\n            cache.remove(key);\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Les Hazlewood, Jeremy Haile\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * An <tt>AuthorizingRealm<\/tt> extends the <tt>AuthenticatingRealm<\/tt>'s capabilities by adding Authorization\n * (access control) support via the use of {@link AuthorizingAccount AuthorizingAccount} instances.\n *\n * <p>This implementation can only support Authorization operations if the subclass implementation's\n * {@link #getAccount(PrincipalCollection) getAccount(principals)} method returns an {@link AuthorizingAccount AuthorizingAccount}.\n * <p>If it does not, subclasses <em>must<\/em> override all {@link org.jsecurity.authz.Authorizer Authorizer} methods,\n * since the JSecurity default implementations cannot infer Role/Permission assignments via anything but\n * <tt>AuthorizingAccount<\/tt> instances.\n *\n * <p>If your Realm implementation does not want to deal with <tt>AuthorizingAccount<\/tt> constructs, you are of course\n * free to subclass the {@link AuthorizingRealm AuthorizingRealm} directly and implement the remaining\n * interface methods yourself.  Many people do this if they want to have better control over how the\n * Role and Permission checks occur for their specific data source.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.2\n */\npublic abstract class AuthorizingRealm extends AuthenticatingRealm implements Initializable, PermissionResolverAware {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * The default postfix appended to the realm name for caching Accounts.\n     */\n    private static final String DEFAULT_ACCOUNT_CACHE_POSTFIX = \"-accounts\";\n\n    private static int INSTANCE_COUNT = 0;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The cache used by this realm to store Accounts associated with individual Subject principals.\n     */\n    private Cache accountCache = null;\n    private String accountCacheName = null;\n\n    private PermissionResolver permissionResolver = new WildcardPermissionResolver();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AuthorizingRealm() {\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager) {\n        super(cacheManager);\n    }\n\n    public AuthorizingRealm(CredentialsMatcher matcher) {\n        super(matcher);\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager, CredentialsMatcher matcher) {\n        super(cacheManager, matcher);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAccountCache(Cache accountCache) {\n        this.accountCache = accountCache;\n    }\n\n    public Cache getAccountCache() {\n        return this.accountCache;\n    }\n\n    public String getAccountCacheName() {\n        return accountCacheName;\n    }\n\n    public void setAccountCacheName(String accountCacheName) {\n        this.accountCacheName = accountCacheName;\n    }\n\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Initializes this realm and potentially enables a cache, depending on configuration.\n     *\n     * <p>When this method is called, the following logic is executed:\n     * <ol>\n     * <li>If the {@link #setAccountCache cache} property has been set, it will be\n     * used to cache the Account objects returned from {@link #getAccount getAccount}\n     * method invocations.\n     * All future calls to <tt>getAccount<\/tt> will attempt to use this Account cache first\n     * to alleviate any potentially unnecessary calls to an underlying data store.<\/li>\n     * <li>If the {@link #setAccountCache cache} property has <b>not<\/b> been set,\n     * the {@link #setCacheManager cacheManager} property will be checked.\n     * If a <tt>cacheManager<\/tt> has been set, it will be used to create an Account\n     * <tt>cache<\/tt>, and this newly created cache which will be used as specified in #1.<\/li>\n     * <li>If neither the {@link #setAccountCache(org.jsecurity.cache.Cache) cache}\n     * or {@link #setCacheManager(org.jsecurity.cache.CacheManager) cacheManager}\n     * properties are set, caching will be disabled and Account lookups will be delegated to\n     * subclass implementations for each authorization check.<\/li>\n     * <\/ol>\n     */\n    public final void init() {\n        initAccountCache();\n        afterAccountCacheSet();\n    }\n\n    protected void afterAccountCacheSet() {\n    }\n\n    protected void initAccountCache() {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Initializing account cache.\");\n        }\n\n        Cache cache = getAccountCache();\n\n        if (cache == null) {\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"No cache implementation set.  Checking cacheManager...\");\n            }\n\n            CacheManager cacheManager = getCacheManager();\n\n            if (cacheManager != null) {\n                String cacheName = getAccountCacheName();\n                if (cacheName == null) {\n                    //Simple default in case they didn't provide one:\n                    cacheName = getClass().getName() + \"-\" + INSTANCE_COUNT++ + DEFAULT_ACCOUNT_CACHE_POSTFIX;\n                    setAccountCacheName(cacheName);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"CacheManager [\" + cacheManager + \"] has been configured.  Building \" +\n                            \"Account cache named [\" + cacheName + \"]\");\n                }\n                cache = cacheManager.getCache(cacheName);\n                setAccountCache(cache);\n            } else {\n                if (log.isInfoEnabled()) {\n                    log.info(\"No cache or cacheManager properties have been set.  Account caching is \" +\n                            \"disabled.\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Template-pattern method to be implemented by subclasses to retrieve the Account for the given principal.\n     *\n     * @param principal the primary identifying principal of the Account that should be retrieved.\n     * @return the Account associated with this principal.\n     */\n    protected abstract AuthorizingAccount doGetAccount(PrincipalCollection principal);\n\n    /**\n     * <p>Retrieves Account information for the given account principals.\n     *\n     * <p>If caching is enabled, the account cache will be checked first and if found, will return the cached account.\n     * If caching is disabled, or there is a cache miss from the cache lookup, the Account will be looked up from\n     * the underlying data store via the {@link #doGetAccount(PrincipalCollection)} method, which must be implemented by subclasses.\n     *\n     * <p>If caching is enabled, the retrieved Account from <tt>doGetAccount<\/tt> will be added to the account cache\n     * first and then returned.\n     *\n     * @param principals the primary identifying principals of the Account that should be retrieved.\n     * @return the Account associated with this princpal.\n     */\n    protected Account getAccount(PrincipalCollection principals) {\n\n        if (principals == null) {\n            return null;\n        }\n\n        Account account = null;\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Retrieving Account for principals [\" + principals + \"]\");\n        }\n\n        Cache accountCache = getAccountCache();\n        if (accountCache != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to retrieve the Account from cache.\");\n            }\n            account = (Account) accountCache.get(principals);\n            if (log.isTraceEnabled()) {\n                if (account == null) {\n                    log.trace(\"No Account found in cache for principals [\" + principals + \"]\");\n                } else {\n                    log.trace(\"Account found in cache for principals [\" + principals + \"]\");\n                }\n            }\n        }\n\n\n        if (account == null) {\n            // Call template method if tbe Account was not found in a cache\n            account = doGetAccount(principals);\n            // If the account is not null and the cache has been created, then cache the account.\n            if (account != null && accountCache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching Account [\" + principals + \"].\");\n                }\n                accountCache.put(principals, account);\n            }\n        }\n\n        return account;\n    }\n\n    protected AuthorizingAccount getAuthorizingAccount(PrincipalCollection principals) {\n        if (principals == null) {\n            throw new AuthorizationException(\"Specified principals argument is null and authorization checks cannot \" +\n                    \"occur without a known account identity.\");\n        }\n        Account account = getAccount(principals);\n        assertNotNullAccount(principals, account);\n        assertAuthorizingAccount(account);\n        return (AuthorizingAccount) account;\n    }\n\n    protected void assertNotNullAccount(PrincipalCollection principals, Account account) {\n        if (account == null) {\n            throw new MissingAccountException(\"No Account found for Subject principals [\" +\n                    principals + \"]\");\n        }\n    }\n\n    protected void assertAuthorizingAccount(Account account) {\n        if (!(account instanceof AuthorizingAccount)) {\n            String msg = \"Underlying Account instance [\" + account + \"] does not implement the \" +\n                    AuthorizingAccount.class.getName() + \" interface.  The JSecurity \" +\n                    AuthorizingRealm.class.getName() + \" class and its default implementations can only provide default \" +\n                    \"authorization (access control) support for Accounts that implement this interface.  If you do not \" +\n                    \"wish to implement this interface, you will need to override all of this Realm's Authorizer methods \" +\n                    \"to perform the authorization check explicitly.\\n\\nNote that there is nothing wrong with this \" +\n                    \"approach since it often gives finer control of how authorization checks occur, but you would have \" +\n                    \"to override these methods explicitly since JSecurity can't infer your application's security \" +\n                    \"data model.\";\n            throw new UnsupportedAccountException(msg);\n        }\n    }\n\n\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        return isPermitted(principals, p);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        AuthorizingAccount account = getAuthorizingAccount(principals);\n        return account.isPermitted(permission);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection subjectIdentifier, String... permissions) {\n        List<Permission> perms = new ArrayList<Permission>(permissions.length);\n        for (String permString : permissions) {\n            perms.add(getPermissionResolver().resolvePermission(permString));\n        }\n        return isPermitted(subjectIdentifier, perms);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        AuthorizingAccount account = getAuthorizingAccount(principals);\n        return account.isPermitted(permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection subjectIdentifier, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            Collection<Permission> perms = new ArrayList<Permission>(permissions.length);\n            for (String permString : permissions) {\n                perms.add(getPermissionResolver().resolvePermission(permString));\n            }\n            return isPermittedAll(subjectIdentifier, perms);\n        }\n        return false;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principal, Collection<Permission> permissions) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        return account != null && account.isPermittedAll(permissions);\n    }\n\n    public void checkPermission(PrincipalCollection subjectIdentifier, String permission) throws AuthorizationException {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        checkPermission(subjectIdentifier, p);\n    }\n\n    public void checkPermission(PrincipalCollection principal, Permission permission) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkPermission(permission);\n    }\n\n    public void checkPermissions(PrincipalCollection subjectIdentifier, String... permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (String permString : permissions) {\n                checkPermission(subjectIdentifier, permString);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection principal, Collection<Permission> permissions) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkPermissions(permissions);\n    }\n\n    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        return account.hasRole(roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principal, List<String> roleIdentifiers) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        boolean[] result = new boolean[roleIdentifiers != null ? roleIdentifiers.size() : 0];\n        if (account != null) {\n            result = account.hasRoles(roleIdentifiers);\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principal, Collection<String> roleIdentifiers) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        return account != null && account.hasAllRoles(roleIdentifiers);\n    }\n\n    public void checkRole(PrincipalCollection principal, String role) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkRole(role);\n    }\n\n    public void checkRoles(PrincipalCollection principal, Collection<String> roles) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkRoles(roles);\n    }\n\n    /**\n     * If account caching is enabled, this will remove the account from the cache.  Subclasses are free to override\n     * for additional behavior, but be sure to call <tt>super.onLogout<\/tt> to ensure cache cleanup.\n     *\n     * @param accountPrincipal the application-specific Subject/user identifier.\n     */\n    public void onLogout(PrincipalCollection accountPrincipal) {\n        Cache cache = getAccountCache();\n        //cache instance will be non-null if caching is enabled:\n        if (cache != null && accountPrincipal != null) {\n            cache.remove(accountPrincipal);\n        }\n    }\n}\n","lineNo":220}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Les Hazlewood, Jeremy Haile\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * An <tt>AuthorizingRealm<\/tt> extends the <tt>AuthenticatingRealm<\/tt>'s capabilities by adding Authorization\n * (access control) support via the use of {@link AuthorizingAccount AuthorizingAccount} instances.\n *\n * <p>This implementation can only support Authorization operations if the subclass implementation's\n * {@link #getAccount(PrincipalCollection) getAccount(principals)} method returns an {@link AuthorizingAccount AuthorizingAccount}.\n * <p>If it does not, subclasses <em>must<\/em> override all {@link org.jsecurity.authz.Authorizer Authorizer} methods,\n * since the JSecurity default implementations cannot infer Role/Permission assignments via anything but\n * <tt>AuthorizingAccount<\/tt> instances.\n *\n * <p>If your Realm implementation does not want to deal with <tt>AuthorizingAccount<\/tt> constructs, you are of course\n * free to subclass the {@link AuthorizingRealm AuthorizingRealm} directly and implement the remaining\n * interface methods yourself.  Many people do this if they want to have better control over how the\n * Role and Permission checks occur for their specific data source.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.2\n */\npublic abstract class AuthorizingRealm extends AuthenticatingRealm implements Initializable, PermissionResolverAware {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * The default postfix appended to the realm name for caching Accounts.\n     */\n    private static final String DEFAULT_ACCOUNT_CACHE_POSTFIX = \"-accounts\";\n\n    private static int INSTANCE_COUNT = 0;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The cache used by this realm to store Accounts associated with individual Subject principals.\n     */\n    private Cache accountCache = null;\n    private String accountCacheName = null;\n\n    private PermissionResolver permissionResolver = new WildcardPermissionResolver();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AuthorizingRealm() {\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager) {\n        super(cacheManager);\n    }\n\n    public AuthorizingRealm(CredentialsMatcher matcher) {\n        super(matcher);\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager, CredentialsMatcher matcher) {\n        super(cacheManager, matcher);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAccountCache(Cache accountCache) {\n        this.accountCache = accountCache;\n    }\n\n    public Cache getAccountCache() {\n        return this.accountCache;\n    }\n\n    public String getAccountCacheName() {\n        return accountCacheName;\n    }\n\n    public void setAccountCacheName(String accountCacheName) {\n        this.accountCacheName = accountCacheName;\n    }\n\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Initializes this realm and potentially enables a cache, depending on configuration.\n     *\n     * <p>When this method is called, the following logic is executed:\n     * <ol>\n     * <li>If the {@link #setAccountCache cache} property has been set, it will be\n     * used to cache the Account objects returned from {@link #getAccount getAccount}\n     * method invocations.\n     * All future calls to <tt>getAccount<\/tt> will attempt to use this Account cache first\n     * to alleviate any potentially unnecessary calls to an underlying data store.<\/li>\n     * <li>If the {@link #setAccountCache cache} property has <b>not<\/b> been set,\n     * the {@link #setCacheManager cacheManager} property will be checked.\n     * If a <tt>cacheManager<\/tt> has been set, it will be used to create an Account\n     * <tt>cache<\/tt>, and this newly created cache which will be used as specified in #1.<\/li>\n     * <li>If neither the {@link #setAccountCache(org.jsecurity.cache.Cache) cache}\n     * or {@link #setCacheManager(org.jsecurity.cache.CacheManager) cacheManager}\n     * properties are set, caching will be disabled and Account lookups will be delegated to\n     * subclass implementations for each authorization check.<\/li>\n     * <\/ol>\n     */\n    public final void init() {\n        initAccountCache();\n        afterAccountCacheSet();\n    }\n\n    protected void afterAccountCacheSet() {\n    }\n\n    protected void initAccountCache() {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Initializing account cache.\");\n        }\n\n        Cache cache = getAccountCache();\n\n        if (cache == null) {\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"No cache implementation set.  Checking cacheManager...\");\n            }\n\n            CacheManager cacheManager = getCacheManager();\n\n            if (cacheManager != null) {\n                String cacheName = getAccountCacheName();\n                if (cacheName == null) {\n                    //Simple default in case they didn't provide one:\n                    cacheName = getClass().getName() + \"-\" + INSTANCE_COUNT++ + DEFAULT_ACCOUNT_CACHE_POSTFIX;\n                    setAccountCacheName(cacheName);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"CacheManager [\" + cacheManager + \"] has been configured.  Building \" +\n                            \"Account cache named [\" + cacheName + \"]\");\n                }\n                cache = cacheManager.getCache(cacheName);\n                setAccountCache(cache);\n            } else {\n                if (log.isInfoEnabled()) {\n                    log.info(\"No cache or cacheManager properties have been set.  Account caching is \" +\n                            \"disabled.\");\n                }\n            }\n        }\n    }\n\n\n\n    /**\n     * <p>Retrieves Account information for the given account principals.\n     *\n     * <p>If caching is enabled, the account cache will be checked first and if found, will return the cached account.\n     * If caching is disabled, or there is a cache miss from the cache lookup, the Account will be looked up from\n     * the underlying data store via the {@link #doGetAccount(PrincipalCollection)} method, which must be implemented by subclasses.\n     *\n     * <p>If caching is enabled, the retrieved Account from <tt>doGetAccount<\/tt> will be added to the account cache\n     * first and then returned.\n     *\n     * @param principals the primary identifying principals of the Account that should be retrieved.\n     * @return the Account associated with this princpal.\n     */\n    protected Account getAccount(PrincipalCollection principals) {\n\n        if (principals == null) {\n            return null;\n        }\n\n        Account account = null;\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Retrieving Account for principals [\" + principals + \"]\");\n        }\n\n        Cache accountCache = getAccountCache();\n        if (accountCache != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to retrieve the Account from cache.\");\n            }\n            Object key = getAccountCacheKey(principals);\n            account = (Account) accountCache.get(key);\n            if (log.isTraceEnabled()) {\n                if (account == null) {\n                    log.trace(\"No Account found in cache for principals [\" + principals + \"]\");\n                } else {\n                    log.trace(\"Account found in cache for principals [\" + principals + \"]\");\n                }\n            }\n        }\n\n\n        if (account == null) {\n            // Call template method if tbe Account was not found in a cache\n            account = doGetAccount(principals);\n            // If the account is not null and the cache has been created, then cache the account.\n            if (account != null && accountCache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching Account [\" + principals + \"].\");\n                }\n                Object key = getAccountCacheKey(principals);\n                accountCache.put(key, account);\n            }\n        }\n\n        return account;\n    }\n\n    protected Object getAccountCacheKey( PrincipalCollection principals ) {\n        return principals;\n    }\n\n    /**\n     * Template-pattern method to be implemented by subclasses to retrieve the Account for the given principal.\n     *\n     * @param principal the primary identifying principal of the Account that should be retrieved.\n     * @return the Account associated with this principal.\n     */\n    protected abstract AuthorizingAccount doGetAccount(PrincipalCollection principal);\n\n    protected AuthorizingAccount getAuthorizingAccount(PrincipalCollection principals) {\n        if (principals == null) {\n            throw new AuthorizationException(\"Specified principals argument is null and authorization checks cannot \" +\n                    \"occur without a known account identity.\");\n        }\n        Account account = getAccount(principals);\n        assertNotNullAccount(principals, account);\n        assertAuthorizingAccount(account);\n        return (AuthorizingAccount) account;\n    }\n\n    protected void assertNotNullAccount(PrincipalCollection principals, Account account) {\n        if (account == null) {\n            throw new MissingAccountException(\"No Account found for Subject principals [\" +\n                    principals + \"]\");\n        }\n    }\n\n    protected void assertAuthorizingAccount(Account account) {\n        if (!(account instanceof AuthorizingAccount)) {\n            String msg = \"Underlying Account instance [\" + account + \"] does not implement the \" +\n                    AuthorizingAccount.class.getName() + \" interface.  The JSecurity \" +\n                    AuthorizingRealm.class.getName() + \" class and its default implementations can only provide default \" +\n                    \"authorization (access control) support for Accounts that implement this interface.  If you do not \" +\n                    \"wish to implement this interface, you will need to override all of this Realm's Authorizer methods \" +\n                    \"to perform the authorization check explicitly.\\n\\nNote that there is nothing wrong with this \" +\n                    \"approach since it often gives finer control of how authorization checks occur, but you would have \" +\n                    \"to override these methods explicitly since JSecurity can't infer your application's security \" +\n                    \"data model.\";\n            throw new UnsupportedAccountException(msg);\n        }\n    }\n\n\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        return isPermitted(principals, p);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        AuthorizingAccount account = getAuthorizingAccount(principals);\n        return account.isPermitted(permission);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection subjectIdentifier, String... permissions) {\n        List<Permission> perms = new ArrayList<Permission>(permissions.length);\n        for (String permString : permissions) {\n            perms.add(getPermissionResolver().resolvePermission(permString));\n        }\n        return isPermitted(subjectIdentifier, perms);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        AuthorizingAccount account = getAuthorizingAccount(principals);\n        return account.isPermitted(permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection subjectIdentifier, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            Collection<Permission> perms = new ArrayList<Permission>(permissions.length);\n            for (String permString : permissions) {\n                perms.add(getPermissionResolver().resolvePermission(permString));\n            }\n            return isPermittedAll(subjectIdentifier, perms);\n        }\n        return false;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principal, Collection<Permission> permissions) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        return account != null && account.isPermittedAll(permissions);\n    }\n\n    public void checkPermission(PrincipalCollection subjectIdentifier, String permission) throws AuthorizationException {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        checkPermission(subjectIdentifier, p);\n    }\n\n    public void checkPermission(PrincipalCollection principal, Permission permission) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkPermission(permission);\n    }\n\n    public void checkPermissions(PrincipalCollection subjectIdentifier, String... permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (String permString : permissions) {\n                checkPermission(subjectIdentifier, permString);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection principal, Collection<Permission> permissions) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkPermissions(permissions);\n    }\n\n    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        return account.hasRole(roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principal, List<String> roleIdentifiers) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        boolean[] result = new boolean[roleIdentifiers != null ? roleIdentifiers.size() : 0];\n        if (account != null) {\n            result = account.hasRoles(roleIdentifiers);\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principal, Collection<String> roleIdentifiers) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        return account != null && account.hasAllRoles(roleIdentifiers);\n    }\n\n    public void checkRole(PrincipalCollection principal, String role) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkRole(role);\n    }\n\n    public void checkRoles(PrincipalCollection principal, Collection<String> roles) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkRoles(roles);\n    }\n\n    /**\n     * If account caching is enabled, this will remove the account from the cache.  Subclasses are free to override\n     * for additional behavior, but be sure to call <tt>super.onLogout<\/tt> to ensure cache cleanup.\n     *\n     * @param accountPrincipal the application-specific Subject/user identifier.\n     */\n    public void onLogout(PrincipalCollection accountPrincipal) {\n        Cache cache = getAccountCache();\n        //cache instance will be non-null if caching is enabled:\n        if (cache != null && accountPrincipal != null) {\n            Object key = getAccountCacheKey(accountPrincipal);\n            cache.remove(key);\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Les Hazlewood, Jeremy Haile\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * An <tt>AuthorizingRealm<\/tt> extends the <tt>AuthenticatingRealm<\/tt>'s capabilities by adding Authorization\n * (access control) support via the use of {@link AuthorizingAccount AuthorizingAccount} instances.\n *\n * <p>This implementation can only support Authorization operations if the subclass implementation's\n * {@link #getAccount(PrincipalCollection) getAccount(principals)} method returns an {@link AuthorizingAccount AuthorizingAccount}.\n * <p>If it does not, subclasses <em>must<\/em> override all {@link org.jsecurity.authz.Authorizer Authorizer} methods,\n * since the JSecurity default implementations cannot infer Role/Permission assignments via anything but\n * <tt>AuthorizingAccount<\/tt> instances.\n *\n * <p>If your Realm implementation does not want to deal with <tt>AuthorizingAccount<\/tt> constructs, you are of course\n * free to subclass the {@link AuthorizingRealm AuthorizingRealm} directly and implement the remaining\n * interface methods yourself.  Many people do this if they want to have better control over how the\n * Role and Permission checks occur for their specific data source.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.2\n */\npublic abstract class AuthorizingRealm extends AuthenticatingRealm implements Initializable, PermissionResolverAware {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * The default postfix appended to the realm name for caching Accounts.\n     */\n    private static final String DEFAULT_ACCOUNT_CACHE_POSTFIX = \"-accounts\";\n\n    private static int INSTANCE_COUNT = 0;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The cache used by this realm to store Accounts associated with individual Subject principals.\n     */\n    private Cache accountCache = null;\n    private String accountCacheName = null;\n\n    private PermissionResolver permissionResolver = new WildcardPermissionResolver();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AuthorizingRealm() {\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager) {\n        super(cacheManager);\n    }\n\n    public AuthorizingRealm(CredentialsMatcher matcher) {\n        super(matcher);\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager, CredentialsMatcher matcher) {\n        super(cacheManager, matcher);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAccountCache(Cache accountCache) {\n        this.accountCache = accountCache;\n    }\n\n    public Cache getAccountCache() {\n        return this.accountCache;\n    }\n\n    public String getAccountCacheName() {\n        return accountCacheName;\n    }\n\n    public void setAccountCacheName(String accountCacheName) {\n        this.accountCacheName = accountCacheName;\n    }\n\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Initializes this realm and potentially enables a cache, depending on configuration.\n     *\n     * <p>When this method is called, the following logic is executed:\n     * <ol>\n     * <li>If the {@link #setAccountCache cache} property has been set, it will be\n     * used to cache the Account objects returned from {@link #getAccount getAccount}\n     * method invocations.\n     * All future calls to <tt>getAccount<\/tt> will attempt to use this Account cache first\n     * to alleviate any potentially unnecessary calls to an underlying data store.<\/li>\n     * <li>If the {@link #setAccountCache cache} property has <b>not<\/b> been set,\n     * the {@link #setCacheManager cacheManager} property will be checked.\n     * If a <tt>cacheManager<\/tt> has been set, it will be used to create an Account\n     * <tt>cache<\/tt>, and this newly created cache which will be used as specified in #1.<\/li>\n     * <li>If neither the {@link #setAccountCache(org.jsecurity.cache.Cache) cache}\n     * or {@link #setCacheManager(org.jsecurity.cache.CacheManager) cacheManager}\n     * properties are set, caching will be disabled and Account lookups will be delegated to\n     * subclass implementations for each authorization check.<\/li>\n     * <\/ol>\n     */\n    public final void init() {\n        initAccountCache();\n        afterAccountCacheSet();\n    }\n\n    protected void afterAccountCacheSet() {\n    }\n\n    protected void initAccountCache() {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Initializing account cache.\");\n        }\n\n        Cache cache = getAccountCache();\n\n        if (cache == null) {\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"No cache implementation set.  Checking cacheManager...\");\n            }\n\n            CacheManager cacheManager = getCacheManager();\n\n            if (cacheManager != null) {\n                String cacheName = getAccountCacheName();\n                if (cacheName == null) {\n                    //Simple default in case they didn't provide one:\n                    cacheName = getClass().getName() + \"-\" + INSTANCE_COUNT++ + DEFAULT_ACCOUNT_CACHE_POSTFIX;\n                    setAccountCacheName(cacheName);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"CacheManager [\" + cacheManager + \"] has been configured.  Building \" +\n                            \"Account cache named [\" + cacheName + \"]\");\n                }\n                cache = cacheManager.getCache(cacheName);\n                setAccountCache(cache);\n            } else {\n                if (log.isInfoEnabled()) {\n                    log.info(\"No cache or cacheManager properties have been set.  Account caching is \" +\n                            \"disabled.\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Template-pattern method to be implemented by subclasses to retrieve the Account for the given principal.\n     *\n     * @param principal the primary identifying principal of the Account that should be retrieved.\n     * @return the Account associated with this principal.\n     */\n    protected abstract AuthorizingAccount doGetAccount(PrincipalCollection principal);\n\n    /**\n     * <p>Retrieves Account information for the given account principals.\n     *\n     * <p>If caching is enabled, the account cache will be checked first and if found, will return the cached account.\n     * If caching is disabled, or there is a cache miss from the cache lookup, the Account will be looked up from\n     * the underlying data store via the {@link #doGetAccount(PrincipalCollection)} method, which must be implemented by subclasses.\n     *\n     * <p>If caching is enabled, the retrieved Account from <tt>doGetAccount<\/tt> will be added to the account cache\n     * first and then returned.\n     *\n     * @param principals the primary identifying principals of the Account that should be retrieved.\n     * @return the Account associated with this princpal.\n     */\n    protected Account getAccount(PrincipalCollection principals) {\n\n        if (principals == null) {\n            return null;\n        }\n\n        Account account = null;\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Retrieving Account for principals [\" + principals + \"]\");\n        }\n\n        Cache accountCache = getAccountCache();\n        if (accountCache != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to retrieve the Account from cache.\");\n            }\n            account = (Account) accountCache.get(principals);\n            if (log.isTraceEnabled()) {\n                if (account == null) {\n                    log.trace(\"No Account found in cache for principals [\" + principals + \"]\");\n                } else {\n                    log.trace(\"Account found in cache for principals [\" + principals + \"]\");\n                }\n            }\n        }\n\n\n        if (account == null) {\n            // Call template method if tbe Account was not found in a cache\n            account = doGetAccount(principals);\n            // If the account is not null and the cache has been created, then cache the account.\n            if (account != null && accountCache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching Account [\" + principals + \"].\");\n                }\n                accountCache.put(principals, account);\n            }\n        }\n\n        return account;\n    }\n\n    protected AuthorizingAccount getAuthorizingAccount(PrincipalCollection principals) {\n        if (principals == null) {\n            throw new AuthorizationException(\"Specified principals argument is null and authorization checks cannot \" +\n                    \"occur without a known account identity.\");\n        }\n        Account account = getAccount(principals);\n        assertNotNullAccount(principals, account);\n        assertAuthorizingAccount(account);\n        return (AuthorizingAccount) account;\n    }\n\n    protected void assertNotNullAccount(PrincipalCollection principals, Account account) {\n        if (account == null) {\n            throw new MissingAccountException(\"No Account found for Subject principals [\" +\n                    principals + \"]\");\n        }\n    }\n\n    protected void assertAuthorizingAccount(Account account) {\n        if (!(account instanceof AuthorizingAccount)) {\n            String msg = \"Underlying Account instance [\" + account + \"] does not implement the \" +\n                    AuthorizingAccount.class.getName() + \" interface.  The JSecurity \" +\n                    AuthorizingRealm.class.getName() + \" class and its default implementations can only provide default \" +\n                    \"authorization (access control) support for Accounts that implement this interface.  If you do not \" +\n                    \"wish to implement this interface, you will need to override all of this Realm's Authorizer methods \" +\n                    \"to perform the authorization check explicitly.\\n\\nNote that there is nothing wrong with this \" +\n                    \"approach since it often gives finer control of how authorization checks occur, but you would have \" +\n                    \"to override these methods explicitly since JSecurity can't infer your application's security \" +\n                    \"data model.\";\n            throw new UnsupportedAccountException(msg);\n        }\n    }\n\n\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        return isPermitted(principals, p);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        AuthorizingAccount account = getAuthorizingAccount(principals);\n        return account.isPermitted(permission);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection subjectIdentifier, String... permissions) {\n        List<Permission> perms = new ArrayList<Permission>(permissions.length);\n        for (String permString : permissions) {\n            perms.add(getPermissionResolver().resolvePermission(permString));\n        }\n        return isPermitted(subjectIdentifier, perms);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        AuthorizingAccount account = getAuthorizingAccount(principals);\n        return account.isPermitted(permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection subjectIdentifier, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            Collection<Permission> perms = new ArrayList<Permission>(permissions.length);\n            for (String permString : permissions) {\n                perms.add(getPermissionResolver().resolvePermission(permString));\n            }\n            return isPermittedAll(subjectIdentifier, perms);\n        }\n        return false;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principal, Collection<Permission> permissions) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        return account != null && account.isPermittedAll(permissions);\n    }\n\n    public void checkPermission(PrincipalCollection subjectIdentifier, String permission) throws AuthorizationException {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        checkPermission(subjectIdentifier, p);\n    }\n\n    public void checkPermission(PrincipalCollection principal, Permission permission) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkPermission(permission);\n    }\n\n    public void checkPermissions(PrincipalCollection subjectIdentifier, String... permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (String permString : permissions) {\n                checkPermission(subjectIdentifier, permString);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection principal, Collection<Permission> permissions) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkPermissions(permissions);\n    }\n\n    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        return account.hasRole(roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principal, List<String> roleIdentifiers) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        boolean[] result = new boolean[roleIdentifiers != null ? roleIdentifiers.size() : 0];\n        if (account != null) {\n            result = account.hasRoles(roleIdentifiers);\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principal, Collection<String> roleIdentifiers) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        return account != null && account.hasAllRoles(roleIdentifiers);\n    }\n\n    public void checkRole(PrincipalCollection principal, String role) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkRole(role);\n    }\n\n    public void checkRoles(PrincipalCollection principal, Collection<String> roles) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkRoles(roles);\n    }\n\n    /**\n     * If account caching is enabled, this will remove the account from the cache.  Subclasses are free to override\n     * for additional behavior, but be sure to call <tt>super.onLogout<\/tt> to ensure cache cleanup.\n     *\n     * @param accountPrincipal the application-specific Subject/user identifier.\n     */\n    public void onLogout(PrincipalCollection accountPrincipal) {\n        Cache cache = getAccountCache();\n        //cache instance will be non-null if caching is enabled:\n        if (cache != null && accountPrincipal != null) {\n            cache.remove(accountPrincipal);\n        }\n    }\n}\n","lineNo":240}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Les Hazlewood, Jeremy Haile\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * An <tt>AuthorizingRealm<\/tt> extends the <tt>AuthenticatingRealm<\/tt>'s capabilities by adding Authorization\n * (access control) support via the use of {@link AuthorizingAccount AuthorizingAccount} instances.\n *\n * <p>This implementation can only support Authorization operations if the subclass implementation's\n * {@link #getAccount(PrincipalCollection) getAccount(principals)} method returns an {@link AuthorizingAccount AuthorizingAccount}.\n * <p>If it does not, subclasses <em>must<\/em> override all {@link org.jsecurity.authz.Authorizer Authorizer} methods,\n * since the JSecurity default implementations cannot infer Role/Permission assignments via anything but\n * <tt>AuthorizingAccount<\/tt> instances.\n *\n * <p>If your Realm implementation does not want to deal with <tt>AuthorizingAccount<\/tt> constructs, you are of course\n * free to subclass the {@link AuthorizingRealm AuthorizingRealm} directly and implement the remaining\n * interface methods yourself.  Many people do this if they want to have better control over how the\n * Role and Permission checks occur for their specific data source.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.2\n */\npublic abstract class AuthorizingRealm extends AuthenticatingRealm implements Initializable, PermissionResolverAware {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * The default postfix appended to the realm name for caching Accounts.\n     */\n    private static final String DEFAULT_ACCOUNT_CACHE_POSTFIX = \"-accounts\";\n\n    private static int INSTANCE_COUNT = 0;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The cache used by this realm to store Accounts associated with individual Subject principals.\n     */\n    private Cache accountCache = null;\n    private String accountCacheName = null;\n\n    private PermissionResolver permissionResolver = new WildcardPermissionResolver();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AuthorizingRealm() {\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager) {\n        super(cacheManager);\n    }\n\n    public AuthorizingRealm(CredentialsMatcher matcher) {\n        super(matcher);\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager, CredentialsMatcher matcher) {\n        super(cacheManager, matcher);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAccountCache(Cache accountCache) {\n        this.accountCache = accountCache;\n    }\n\n    public Cache getAccountCache() {\n        return this.accountCache;\n    }\n\n    public String getAccountCacheName() {\n        return accountCacheName;\n    }\n\n    public void setAccountCacheName(String accountCacheName) {\n        this.accountCacheName = accountCacheName;\n    }\n\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Initializes this realm and potentially enables a cache, depending on configuration.\n     *\n     * <p>When this method is called, the following logic is executed:\n     * <ol>\n     * <li>If the {@link #setAccountCache cache} property has been set, it will be\n     * used to cache the Account objects returned from {@link #getAccount getAccount}\n     * method invocations.\n     * All future calls to <tt>getAccount<\/tt> will attempt to use this Account cache first\n     * to alleviate any potentially unnecessary calls to an underlying data store.<\/li>\n     * <li>If the {@link #setAccountCache cache} property has <b>not<\/b> been set,\n     * the {@link #setCacheManager cacheManager} property will be checked.\n     * If a <tt>cacheManager<\/tt> has been set, it will be used to create an Account\n     * <tt>cache<\/tt>, and this newly created cache which will be used as specified in #1.<\/li>\n     * <li>If neither the {@link #setAccountCache(org.jsecurity.cache.Cache) cache}\n     * or {@link #setCacheManager(org.jsecurity.cache.CacheManager) cacheManager}\n     * properties are set, caching will be disabled and Account lookups will be delegated to\n     * subclass implementations for each authorization check.<\/li>\n     * <\/ol>\n     */\n    public final void init() {\n        initAccountCache();\n        afterAccountCacheSet();\n    }\n\n    protected void afterAccountCacheSet() {\n    }\n\n    protected void initAccountCache() {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Initializing account cache.\");\n        }\n\n        Cache cache = getAccountCache();\n\n        if (cache == null) {\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"No cache implementation set.  Checking cacheManager...\");\n            }\n\n            CacheManager cacheManager = getCacheManager();\n\n            if (cacheManager != null) {\n                String cacheName = getAccountCacheName();\n                if (cacheName == null) {\n                    //Simple default in case they didn't provide one:\n                    cacheName = getClass().getName() + \"-\" + INSTANCE_COUNT++ + DEFAULT_ACCOUNT_CACHE_POSTFIX;\n                    setAccountCacheName(cacheName);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"CacheManager [\" + cacheManager + \"] has been configured.  Building \" +\n                            \"Account cache named [\" + cacheName + \"]\");\n                }\n                cache = cacheManager.getCache(cacheName);\n                setAccountCache(cache);\n            } else {\n                if (log.isInfoEnabled()) {\n                    log.info(\"No cache or cacheManager properties have been set.  Account caching is \" +\n                            \"disabled.\");\n                }\n            }\n        }\n    }\n\n\n\n    /**\n     * <p>Retrieves Account information for the given account principals.\n     *\n     * <p>If caching is enabled, the account cache will be checked first and if found, will return the cached account.\n     * If caching is disabled, or there is a cache miss from the cache lookup, the Account will be looked up from\n     * the underlying data store via the {@link #doGetAccount(PrincipalCollection)} method, which must be implemented by subclasses.\n     *\n     * <p>If caching is enabled, the retrieved Account from <tt>doGetAccount<\/tt> will be added to the account cache\n     * first and then returned.\n     *\n     * @param principals the primary identifying principals of the Account that should be retrieved.\n     * @return the Account associated with this princpal.\n     */\n    protected Account getAccount(PrincipalCollection principals) {\n\n        if (principals == null) {\n            return null;\n        }\n\n        Account account = null;\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Retrieving Account for principals [\" + principals + \"]\");\n        }\n\n        Cache accountCache = getAccountCache();\n        if (accountCache != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to retrieve the Account from cache.\");\n            }\n            Object key = getAccountCacheKey(principals);\n            account = (Account) accountCache.get(key);\n            if (log.isTraceEnabled()) {\n                if (account == null) {\n                    log.trace(\"No Account found in cache for principals [\" + principals + \"]\");\n                } else {\n                    log.trace(\"Account found in cache for principals [\" + principals + \"]\");\n                }\n            }\n        }\n\n\n        if (account == null) {\n            // Call template method if tbe Account was not found in a cache\n            account = doGetAccount(principals);\n            // If the account is not null and the cache has been created, then cache the account.\n            if (account != null && accountCache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching Account [\" + principals + \"].\");\n                }\n                Object key = getAccountCacheKey(principals);\n                accountCache.put(key, account);\n            }\n        }\n\n        return account;\n    }\n\n    protected Object getAccountCacheKey( PrincipalCollection principals ) {\n        return principals;\n    }\n\n    /**\n     * Template-pattern method to be implemented by subclasses to retrieve the Account for the given principal.\n     *\n     * @param principal the primary identifying principal of the Account that should be retrieved.\n     * @return the Account associated with this principal.\n     */\n    protected abstract AuthorizingAccount doGetAccount(PrincipalCollection principal);\n\n    protected AuthorizingAccount getAuthorizingAccount(PrincipalCollection principals) {\n        if (principals == null) {\n            throw new AuthorizationException(\"Specified principals argument is null and authorization checks cannot \" +\n                    \"occur without a known account identity.\");\n        }\n        Account account = getAccount(principals);\n        assertNotNullAccount(principals, account);\n        assertAuthorizingAccount(account);\n        return (AuthorizingAccount) account;\n    }\n\n    protected void assertNotNullAccount(PrincipalCollection principals, Account account) {\n        if (account == null) {\n            throw new MissingAccountException(\"No Account found for Subject principals [\" +\n                    principals + \"]\");\n        }\n    }\n\n    protected void assertAuthorizingAccount(Account account) {\n        if (!(account instanceof AuthorizingAccount)) {\n            String msg = \"Underlying Account instance [\" + account + \"] does not implement the \" +\n                    AuthorizingAccount.class.getName() + \" interface.  The JSecurity \" +\n                    AuthorizingRealm.class.getName() + \" class and its default implementations can only provide default \" +\n                    \"authorization (access control) support for Accounts that implement this interface.  If you do not \" +\n                    \"wish to implement this interface, you will need to override all of this Realm's Authorizer methods \" +\n                    \"to perform the authorization check explicitly.\\n\\nNote that there is nothing wrong with this \" +\n                    \"approach since it often gives finer control of how authorization checks occur, but you would have \" +\n                    \"to override these methods explicitly since JSecurity can't infer your application's security \" +\n                    \"data model.\";\n            throw new UnsupportedAccountException(msg);\n        }\n    }\n\n\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        return isPermitted(principals, p);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        AuthorizingAccount account = getAuthorizingAccount(principals);\n        return account.isPermitted(permission);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection subjectIdentifier, String... permissions) {\n        List<Permission> perms = new ArrayList<Permission>(permissions.length);\n        for (String permString : permissions) {\n            perms.add(getPermissionResolver().resolvePermission(permString));\n        }\n        return isPermitted(subjectIdentifier, perms);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        AuthorizingAccount account = getAuthorizingAccount(principals);\n        return account.isPermitted(permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection subjectIdentifier, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            Collection<Permission> perms = new ArrayList<Permission>(permissions.length);\n            for (String permString : permissions) {\n                perms.add(getPermissionResolver().resolvePermission(permString));\n            }\n            return isPermittedAll(subjectIdentifier, perms);\n        }\n        return false;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principal, Collection<Permission> permissions) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        return account != null && account.isPermittedAll(permissions);\n    }\n\n    public void checkPermission(PrincipalCollection subjectIdentifier, String permission) throws AuthorizationException {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        checkPermission(subjectIdentifier, p);\n    }\n\n    public void checkPermission(PrincipalCollection principal, Permission permission) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkPermission(permission);\n    }\n\n    public void checkPermissions(PrincipalCollection subjectIdentifier, String... permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (String permString : permissions) {\n                checkPermission(subjectIdentifier, permString);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection principal, Collection<Permission> permissions) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkPermissions(permissions);\n    }\n\n    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        return account.hasRole(roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principal, List<String> roleIdentifiers) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        boolean[] result = new boolean[roleIdentifiers != null ? roleIdentifiers.size() : 0];\n        if (account != null) {\n            result = account.hasRoles(roleIdentifiers);\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principal, Collection<String> roleIdentifiers) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        return account != null && account.hasAllRoles(roleIdentifiers);\n    }\n\n    public void checkRole(PrincipalCollection principal, String role) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkRole(role);\n    }\n\n    public void checkRoles(PrincipalCollection principal, Collection<String> roles) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkRoles(roles);\n    }\n\n    /**\n     * If account caching is enabled, this will remove the account from the cache.  Subclasses are free to override\n     * for additional behavior, but be sure to call <tt>super.onLogout<\/tt> to ensure cache cleanup.\n     *\n     * @param accountPrincipal the application-specific Subject/user identifier.\n     */\n    public void onLogout(PrincipalCollection accountPrincipal) {\n        Cache cache = getAccountCache();\n        //cache instance will be non-null if caching is enabled:\n        if (cache != null && accountPrincipal != null) {\n            Object key = getAccountCacheKey(accountPrincipal);\n            cache.remove(key);\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Les Hazlewood, Jeremy Haile\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * An <tt>AuthorizingRealm<\/tt> extends the <tt>AuthenticatingRealm<\/tt>'s capabilities by adding Authorization\n * (access control) support via the use of {@link AuthorizingAccount AuthorizingAccount} instances.\n *\n * <p>This implementation can only support Authorization operations if the subclass implementation's\n * {@link #getAccount(PrincipalCollection) getAccount(principals)} method returns an {@link AuthorizingAccount AuthorizingAccount}.\n * <p>If it does not, subclasses <em>must<\/em> override all {@link org.jsecurity.authz.Authorizer Authorizer} methods,\n * since the JSecurity default implementations cannot infer Role/Permission assignments via anything but\n * <tt>AuthorizingAccount<\/tt> instances.\n *\n * <p>If your Realm implementation does not want to deal with <tt>AuthorizingAccount<\/tt> constructs, you are of course\n * free to subclass the {@link AuthorizingRealm AuthorizingRealm} directly and implement the remaining\n * interface methods yourself.  Many people do this if they want to have better control over how the\n * Role and Permission checks occur for their specific data source.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.2\n */\npublic abstract class AuthorizingRealm extends AuthenticatingRealm implements Initializable, PermissionResolverAware {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * The default postfix appended to the realm name for caching Accounts.\n     */\n    private static final String DEFAULT_ACCOUNT_CACHE_POSTFIX = \"-accounts\";\n\n    private static int INSTANCE_COUNT = 0;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The cache used by this realm to store Accounts associated with individual Subject principals.\n     */\n    private Cache accountCache = null;\n    private String accountCacheName = null;\n\n    private PermissionResolver permissionResolver = new WildcardPermissionResolver();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AuthorizingRealm() {\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager) {\n        super(cacheManager);\n    }\n\n    public AuthorizingRealm(CredentialsMatcher matcher) {\n        super(matcher);\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager, CredentialsMatcher matcher) {\n        super(cacheManager, matcher);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAccountCache(Cache accountCache) {\n        this.accountCache = accountCache;\n    }\n\n    public Cache getAccountCache() {\n        return this.accountCache;\n    }\n\n    public String getAccountCacheName() {\n        return accountCacheName;\n    }\n\n    public void setAccountCacheName(String accountCacheName) {\n        this.accountCacheName = accountCacheName;\n    }\n\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Initializes this realm and potentially enables a cache, depending on configuration.\n     *\n     * <p>When this method is called, the following logic is executed:\n     * <ol>\n     * <li>If the {@link #setAccountCache cache} property has been set, it will be\n     * used to cache the Account objects returned from {@link #getAccount getAccount}\n     * method invocations.\n     * All future calls to <tt>getAccount<\/tt> will attempt to use this Account cache first\n     * to alleviate any potentially unnecessary calls to an underlying data store.<\/li>\n     * <li>If the {@link #setAccountCache cache} property has <b>not<\/b> been set,\n     * the {@link #setCacheManager cacheManager} property will be checked.\n     * If a <tt>cacheManager<\/tt> has been set, it will be used to create an Account\n     * <tt>cache<\/tt>, and this newly created cache which will be used as specified in #1.<\/li>\n     * <li>If neither the {@link #setAccountCache(org.jsecurity.cache.Cache) cache}\n     * or {@link #setCacheManager(org.jsecurity.cache.CacheManager) cacheManager}\n     * properties are set, caching will be disabled and Account lookups will be delegated to\n     * subclass implementations for each authorization check.<\/li>\n     * <\/ol>\n     */\n    public final void init() {\n        initAccountCache();\n        afterAccountCacheSet();\n    }\n\n    protected void afterAccountCacheSet() {\n    }\n\n    protected void initAccountCache() {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Initializing account cache.\");\n        }\n\n        Cache cache = getAccountCache();\n\n        if (cache == null) {\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"No cache implementation set.  Checking cacheManager...\");\n            }\n\n            CacheManager cacheManager = getCacheManager();\n\n            if (cacheManager != null) {\n                String cacheName = getAccountCacheName();\n                if (cacheName == null) {\n                    //Simple default in case they didn't provide one:\n                    cacheName = getClass().getName() + \"-\" + INSTANCE_COUNT++ + DEFAULT_ACCOUNT_CACHE_POSTFIX;\n                    setAccountCacheName(cacheName);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"CacheManager [\" + cacheManager + \"] has been configured.  Building \" +\n                            \"Account cache named [\" + cacheName + \"]\");\n                }\n                cache = cacheManager.getCache(cacheName);\n                setAccountCache(cache);\n            } else {\n                if (log.isInfoEnabled()) {\n                    log.info(\"No cache or cacheManager properties have been set.  Account caching is \" +\n                            \"disabled.\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Template-pattern method to be implemented by subclasses to retrieve the Account for the given principal.\n     *\n     * @param principal the primary identifying principal of the Account that should be retrieved.\n     * @return the Account associated with this principal.\n     */\n    protected abstract AuthorizingAccount doGetAccount(PrincipalCollection principal);\n\n    /**\n     * <p>Retrieves Account information for the given account principals.\n     *\n     * <p>If caching is enabled, the account cache will be checked first and if found, will return the cached account.\n     * If caching is disabled, or there is a cache miss from the cache lookup, the Account will be looked up from\n     * the underlying data store via the {@link #doGetAccount(PrincipalCollection)} method, which must be implemented by subclasses.\n     *\n     * <p>If caching is enabled, the retrieved Account from <tt>doGetAccount<\/tt> will be added to the account cache\n     * first and then returned.\n     *\n     * @param principals the primary identifying principals of the Account that should be retrieved.\n     * @return the Account associated with this princpal.\n     */\n    protected Account getAccount(PrincipalCollection principals) {\n\n        if (principals == null) {\n            return null;\n        }\n\n        Account account = null;\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Retrieving Account for principals [\" + principals + \"]\");\n        }\n\n        Cache accountCache = getAccountCache();\n        if (accountCache != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to retrieve the Account from cache.\");\n            }\n            account = (Account) accountCache.get(principals);\n            if (log.isTraceEnabled()) {\n                if (account == null) {\n                    log.trace(\"No Account found in cache for principals [\" + principals + \"]\");\n                } else {\n                    log.trace(\"Account found in cache for principals [\" + principals + \"]\");\n                }\n            }\n        }\n\n\n        if (account == null) {\n            // Call template method if tbe Account was not found in a cache\n            account = doGetAccount(principals);\n            // If the account is not null and the cache has been created, then cache the account.\n            if (account != null && accountCache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching Account [\" + principals + \"].\");\n                }\n                accountCache.put(principals, account);\n            }\n        }\n\n        return account;\n    }\n\n    protected AuthorizingAccount getAuthorizingAccount(PrincipalCollection principals) {\n        if (principals == null) {\n            throw new AuthorizationException(\"Specified principals argument is null and authorization checks cannot \" +\n                    \"occur without a known account identity.\");\n        }\n        Account account = getAccount(principals);\n        assertNotNullAccount(principals, account);\n        assertAuthorizingAccount(account);\n        return (AuthorizingAccount) account;\n    }\n\n    protected void assertNotNullAccount(PrincipalCollection principals, Account account) {\n        if (account == null) {\n            throw new MissingAccountException(\"No Account found for Subject principals [\" +\n                    principals + \"]\");\n        }\n    }\n\n    protected void assertAuthorizingAccount(Account account) {\n        if (!(account instanceof AuthorizingAccount)) {\n            String msg = \"Underlying Account instance [\" + account + \"] does not implement the \" +\n                    AuthorizingAccount.class.getName() + \" interface.  The JSecurity \" +\n                    AuthorizingRealm.class.getName() + \" class and its default implementations can only provide default \" +\n                    \"authorization (access control) support for Accounts that implement this interface.  If you do not \" +\n                    \"wish to implement this interface, you will need to override all of this Realm's Authorizer methods \" +\n                    \"to perform the authorization check explicitly.\\n\\nNote that there is nothing wrong with this \" +\n                    \"approach since it often gives finer control of how authorization checks occur, but you would have \" +\n                    \"to override these methods explicitly since JSecurity can't infer your application's security \" +\n                    \"data model.\";\n            throw new UnsupportedAccountException(msg);\n        }\n    }\n\n\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        return isPermitted(principals, p);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        AuthorizingAccount account = getAuthorizingAccount(principals);\n        return account.isPermitted(permission);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection subjectIdentifier, String... permissions) {\n        List<Permission> perms = new ArrayList<Permission>(permissions.length);\n        for (String permString : permissions) {\n            perms.add(getPermissionResolver().resolvePermission(permString));\n        }\n        return isPermitted(subjectIdentifier, perms);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        AuthorizingAccount account = getAuthorizingAccount(principals);\n        return account.isPermitted(permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection subjectIdentifier, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            Collection<Permission> perms = new ArrayList<Permission>(permissions.length);\n            for (String permString : permissions) {\n                perms.add(getPermissionResolver().resolvePermission(permString));\n            }\n            return isPermittedAll(subjectIdentifier, perms);\n        }\n        return false;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principal, Collection<Permission> permissions) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        return account != null && account.isPermittedAll(permissions);\n    }\n\n    public void checkPermission(PrincipalCollection subjectIdentifier, String permission) throws AuthorizationException {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        checkPermission(subjectIdentifier, p);\n    }\n\n    public void checkPermission(PrincipalCollection principal, Permission permission) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkPermission(permission);\n    }\n\n    public void checkPermissions(PrincipalCollection subjectIdentifier, String... permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (String permString : permissions) {\n                checkPermission(subjectIdentifier, permString);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection principal, Collection<Permission> permissions) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkPermissions(permissions);\n    }\n\n    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        return account.hasRole(roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principal, List<String> roleIdentifiers) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        boolean[] result = new boolean[roleIdentifiers != null ? roleIdentifiers.size() : 0];\n        if (account != null) {\n            result = account.hasRoles(roleIdentifiers);\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principal, Collection<String> roleIdentifiers) {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        return account != null && account.hasAllRoles(roleIdentifiers);\n    }\n\n    public void checkRole(PrincipalCollection principal, String role) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkRole(role);\n    }\n\n    public void checkRoles(PrincipalCollection principal, Collection<String> roles) throws AuthorizationException {\n        AuthorizingAccount account = getAuthorizingAccount(principal);\n        account.checkRoles(roles);\n    }\n\n    /**\n     * If account caching is enabled, this will remove the account from the cache.  Subclasses are free to override\n     * for additional behavior, but be sure to call <tt>super.onLogout<\/tt> to ensure cache cleanup.\n     *\n     * @param accountPrincipal the application-specific Subject/user identifier.\n     */\n    public void onLogout(PrincipalCollection accountPrincipal) {\n        Cache cache = getAccountCache();\n        //cache instance will be non-null if caching is enabled:\n        if (cache != null && accountPrincipal != null) {\n            cache.remove(accountPrincipal);\n        }\n    }\n}\n","lineNo":395}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Jeremy Haile, Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authz.AuthorizingAccount;\nimport org.jsecurity.authz.SimpleAuthorizingAccount;\nimport org.jsecurity.authz.SimpleRole;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.cache.HashtableCacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * <p>A simple implementation of the {@link org.jsecurity.realm.Realm Realm} interface that\n * uses a set of configured user accounts and roles to support authentication and authorization.  Each account entry\n * specifies the username, password, and roles for a user.  Roles can also be mapped\n * to permissions and associated with users.<\/p>\n *\n * <p>User accounts and roles are stored in two {@link Cache cache}s, so it is the Cache manager implementation that\n * determines if this class stores all data in memory or spools to disk or clusters it, etc based on the\n * Caches it creates.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SimpleAccountRealm extends AuthorizingRealm implements Initializable {\n\n    /**\n     * The default postfix appended to the Role cache name.\n     */\n    private static final String DEFAULT_ROLE_CACHE_POSTFIX = \"-roles\";\n\n    //parent class already has the user account cache, we just need to add a role cache:\n    protected Cache roleCache = null;\n    protected String roleCacheName;\n\n    public SimpleAccountRealm() {\n    }\n\n    public Cache getRoleCache() {\n        return roleCache;\n    }\n\n    public void setRoleCache(Cache roleCache) {\n        this.roleCache = roleCache;\n    }\n\n    public String getRoleCacheName() {\n        return roleCacheName;\n    }\n\n    public void setRoleCacheName(String roleCacheName) {\n        this.roleCacheName = roleCacheName;\n    }\n\n    public void afterAccountCacheSet() {\n        initRoleCache();\n        afterRoleCacheSet();\n    }\n\n    public void afterRoleCacheSet(){}\n\n    protected void initRoleCache() {\n        CacheManager manager = getCacheManager();\n\n        if ( manager == null ) {\n            manager = new HashtableCacheManager();\n            setCacheManager(manager);\n        }\n\n        if ( getAccountCache() == null ) {\n            initAccountCache();\n        }\n\n        String roleCacheName = getRoleCacheName();\n        if ( roleCacheName == null ) {\n            roleCacheName = getName() + DEFAULT_ROLE_CACHE_POSTFIX;\n            setRoleCacheName( roleCacheName );\n        }\n        Cache roleCache = manager.getCache( roleCacheName );\n        setRoleCache(roleCache);\n\n        userAndRoleCachesCreated();\n    }\n\n    protected SimpleAuthorizingAccount getUser( String username ) {\n        return (SimpleAuthorizingAccount)getAccountCache().get( username );\n    }\n\n    protected void add( SimpleAuthorizingAccount user ) {\n        Object key = getAccountCacheKey(user.getPrincipals());\n        getAccountCache().put( key, user );\n    }\n\n    protected SimpleRole getRole( String rolename ) {\n        return (SimpleRole)roleCache.get( rolename );\n    }\n\n    protected void add( SimpleRole role ) {\n        roleCache.put( role.getName(), role );\n    }\n\n    protected static Set<String> toSet( String delimited, String delimiter ) {\n        if ( delimited == null || delimited.trim().equals( \"\" ) ) {\n            return null;\n        }\n\n        Set<String> values = new HashSet<String>();\n        String[] rolenamesArray = delimited.split( delimiter );\n        for ( String s : rolenamesArray ) {\n            String trimmed = s.trim();\n            if ( trimmed.length() > 0 ) {\n                values.add( trimmed );\n            }\n        }\n\n        return values;\n    }\n\n    protected void userAndRoleCachesCreated(){}\n\n    protected Account doGetAccount( AuthenticationToken token ) throws AuthenticationException {\n        UsernamePasswordToken upToken = (UsernamePasswordToken)token;\n        return (SimpleAuthorizingAccount)getAccountCache().get(upToken.getUsername());\n    }\n\n    protected AuthorizingAccount doGetAccount(PrincipalCollection principals) {\n        return (SimpleAuthorizingAccount)getAccountCache().get(getAccountCacheKey(principals));\n    }\n\n    protected Object getAccountCacheKey(PrincipalCollection principals) {\n        return principals.fromRealm(getName()).iterator().next(); //returns the username\n    }\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Jeremy Haile, Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authz.AuthorizingAccount;\nimport org.jsecurity.authz.SimpleAuthorizingAccount;\nimport org.jsecurity.authz.SimpleRole;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.cache.HashtableCacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.SimplePrincipalCollection;\nimport org.jsecurity.util.Initializable;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * <p>A simple implementation of the {@link org.jsecurity.realm.Realm Realm} interface that\n * uses a set of configured user accounts and roles to support authentication and authorization.  Each account entry\n * specifies the username, password, and roles for a user.  Roles can also be mapped\n * to permissions and associated with users.<\/p>\n *\n * <p>User accounts and roles are stored in two {@link Cache cache}s, so it is the Cache manager implementation that\n * determines if this class stores all data in memory or spools to disk or clusters it, etc based on the\n * Caches it creates.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SimpleAccountRealm extends AuthorizingRealm implements Initializable {\n\n    /**\n     * The default postfix appended to the Role cache name.\n     */\n    private static final String DEFAULT_ROLE_CACHE_POSTFIX = \"-roles\";\n\n    //parent class already has the user account cache, we just need to add a role cache:\n    protected Cache roleCache = null;\n    protected String roleCacheName;\n\n    public SimpleAccountRealm() {\n    }\n\n    public Cache getRoleCache() {\n        return roleCache;\n    }\n\n    public void setRoleCache(Cache roleCache) {\n        this.roleCache = roleCache;\n    }\n\n    public String getRoleCacheName() {\n        return roleCacheName;\n    }\n\n    public void setRoleCacheName(String roleCacheName) {\n        this.roleCacheName = roleCacheName;\n    }\n\n    public void afterAccountCacheSet() {\n        initRoleCache();\n        afterRoleCacheSet();\n    }\n\n    public void afterRoleCacheSet(){}\n\n    protected void initRoleCache() {\n        CacheManager manager = getCacheManager();\n\n        if ( manager == null ) {\n            manager = new HashtableCacheManager();\n            setCacheManager(manager);\n        }\n\n        if ( getAccountCache() == null ) {\n            initAccountCache();\n        }\n\n        String roleCacheName = getRoleCacheName();\n        if ( roleCacheName == null ) {\n            roleCacheName = getName() + DEFAULT_ROLE_CACHE_POSTFIX;\n            setRoleCacheName( roleCacheName );\n        }\n        Cache roleCache = manager.getCache( roleCacheName );\n        setRoleCache(roleCache);\n\n        userAndRoleCachesCreated();\n    }\n\n    protected SimpleAuthorizingAccount getUser( String username ) {\n        return (SimpleAuthorizingAccount)getAccountCache().get( username );\n    }\n\n    protected void add( SimpleAuthorizingAccount user ) {\n        getAccountCache().put( user.getPrincipals(), user );\n    }\n\n    protected SimpleRole getRole( String rolename ) {\n        return (SimpleRole)roleCache.get( rolename );\n    }\n\n    protected void add( SimpleRole role ) {\n        roleCache.put( role.getName(), role );\n    }\n\n    protected static Set<String> toSet( String delimited, String delimiter ) {\n        if ( delimited == null || delimited.trim().equals( \"\" ) ) {\n            return null;\n        }\n\n        Set<String> values = new HashSet<String>();\n        String[] rolenamesArray = delimited.split( delimiter );\n        for ( String s : rolenamesArray ) {\n            String trimmed = s.trim();\n            if ( trimmed.length() > 0 ) {\n                values.add( trimmed );\n            }\n        }\n\n        return values;\n    }\n\n    protected void userAndRoleCachesCreated(){}\n\n    protected Account doGetAccount( AuthenticationToken token ) throws AuthenticationException {\n        UsernamePasswordToken upToken = (UsernamePasswordToken)token;\n        SimplePrincipalCollection principals = new SimplePrincipalCollection( \"simple\", upToken.getUsername() );\n        return doGetAccount( principals );\n    }\n\n    protected AuthorizingAccount doGetAccount(PrincipalCollection principal) {\n        return (SimpleAuthorizingAccount)getAccountCache().get(principal);\n    }\n}\n","lineNo":113}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Tim Veil, Jeremy Haile\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.realm.activedirectory;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authz.AuthorizingAccount;\nimport org.jsecurity.authz.SimpleAuthorizingAccount;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.realm.ldap.AbstractLdapRealm;\nimport org.jsecurity.realm.ldap.LdapContextFactory;\nimport org.jsecurity.realm.ldap.LdapUtils;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.SimplePrincipalCollection;\n\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.naming.ldap.LdapContext;\nimport java.util.*;\n\n/**\n * <p>An {@link Realm} that authenticates with an active directory LDAP\n * server to determine the roles for a particular user.  This implementation\n * queries for the user's groups and then maps the group names to roles using the\n * {@link #groupRolesMap}.<\/p>\n *\n *\n * @since 0.1\n * @author Tim Veil\n * @author Jeremy Haile\n */\npublic class ActiveDirectoryRealm extends AbstractLdapRealm {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    \n    private static final String ROLE_NAMES_DELIMETER = \",\";\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n\n    /**\n     * Mapping from fully qualified active directory\n     * group names (e.g. CN=Group,OU=Company,DC=MyDomain,DC=local)\n     * as returned by the active directory LDAP server to role names.\n     */\n    private Map<String, String> groupRolesMap;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    public void setGroupRolesMap(Map<String, String> groupRolesMap) {\n        this.groupRolesMap = groupRolesMap;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n\n    /**\n     * <p>Builds an {@link org.jsecurity.authc.Account} object by querying the active directory LDAP context for the\n     * specified username.  This method binds to the LDAP server using the provided username and password -\n     * which if successful, indicates that the password is correct.<\/p>\n     *\n     * <p>This method can be overridden by subclasses to query the LDAP server in a more complex way.<\/p>\n     *\n     * @param token the authentication token provided by the user.\n     * @param ldapContextFactory the factory used to build connections to the LDAP server.\n     * @return an {@link org.jsecurity.authc.Account} instance containing information retrieved from LDAP\n     * that can be used to build an {@link org.jsecurity.authc.Account} instance to return.\n     *\n     * @throws NamingException if any LDAP errors occur during the search.\n     */\n    protected Account queryForLdapAccount(AuthenticationToken token, LdapContextFactory ldapContextFactory) throws NamingException {\n\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n\n        // Binds using the username and password provided by the user.\n        LdapContext ctx = null;\n        try {\n            ctx = ldapContextFactory.getLdapContext( upToken.getUsername(), String.valueOf( upToken.getPassword() ) );\n        } finally {\n            LdapUtils.closeContext( ctx );\n        }\n\n        return createAccount( upToken.getUsername(), upToken.getPassword() );\n    }\n\n    protected Account createAccount( String username, char[] password ) {\n        SimplePrincipalCollection principals = new SimplePrincipalCollection(getName(),username);\n        return new SimpleAuthorizingAccount( principals, password );\n    }\n\n\n    /**\n     * <p>Builds an {@link org.jsecurity.authz.AuthorizingAccount} object by querying the active directory LDAP context for the\n     * groups that a user is a member of.  The groups are then translated to role names by using the\n     * configured {@link #groupRolesMap}.<\/p>\n     *\n     * <p>This implementation expects the <tt>principal<\/tt> argument to be a String username.\n     *\n     * <p>Subclasses can override this method to determine authorization data (roles, permissions, etc) in a more\n     * complex way.  Note that this default implementation does not support permissions, only roles.<\/p>\n     *\n     * @param principals the principal of the Subject whose Account is being retrieved.\n     * @param ldapContextFactory the factory used to create LDAP connections.\n     * @return the Account for the given Subject principal.\n     * @throws NamingException if an error occurs when searching the LDAP server.\n     */\n    protected AuthorizingAccount queryForLdapAccount( PrincipalCollection principals, LdapContextFactory ldapContextFactory) throws NamingException {\n\n        String username = null;\n\n        if ( !(principals instanceof String ) ) {\n            String msg = \"This implementation expects the principal argument to be a String.\";\n            throw new IllegalArgumentException( msg );\n        }\n\n        username = (String)principal;\n\n        // Perform context search\n        LdapContext ldapContext = ldapContextFactory.getSystemLdapContext();\n\n        Set<String> roleNames;\n\n        try {\n            roleNames = getRoleNamesForUser(username, ldapContext);\n        } finally {\n            LdapUtils.closeContext( ldapContext );\n        }\n\n        SimplePrincipalCollection principals = new SimplePrincipalCollection(getName(),username);\n        return new SimpleAuthorizingAccount( principals, null, roleNames, null );\n    }\n\n    private Set<String> getRoleNamesForUser( String username, LdapContext ldapContext) throws NamingException {\n        Set<String> roleNames;\n        roleNames = new LinkedHashSet<String>();\n\n        SearchControls searchCtls = new SearchControls();\n        searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        String searchFilter = \"(&(objectClass=*)(userPrincipalName=\" + username + \"))\";\n\n        NamingEnumeration answer = ldapContext.search(searchBase, searchFilter, searchCtls);\n\n        while (answer.hasMoreElements()) {\n            SearchResult sr = (SearchResult) answer.next();\n\n            if( log.isDebugEnabled() ) {\n                log.debug(\"Retrieving group names for user [\" + sr.getName() + \"]\");\n            }\n\n            Attributes attrs = sr.getAttributes();\n\n            if (attrs != null) {\n                NamingEnumeration ae = attrs.getAll();\n                while( ae.hasMore() ) {\n                    Attribute attr = (Attribute) ae.next();\n\n                    if( attr.getID().equals( \"memberOf\" ) ) {\n\n                        Collection<String> groupNames = LdapUtils.getAllAttributeValues( attr );\n\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Groups found for user [\" + username + \"]: \" + groupNames );\n                        }\n\n                        Collection<String> rolesForGroups = getRoleNamesForGroups(groupNames);\n                        roleNames.addAll(rolesForGroups);\n                    }\n                }\n            }\n        }\n        return roleNames;\n    }\n\n    /**\n     * This method is called by the default implementation to translate Active Directory group names\n     * to role names.  This implementation uses the {@link #groupRolesMap} to map group names to role names.\n     * @param groupNames the group names that apply to the current user.\n     * @return a collection of roles that are implied by the given role names.\n     */\n    protected Collection<String> getRoleNamesForGroups(Collection<String> groupNames) {\n        Set<String> roleNames = new HashSet<String>( groupNames.size() );\n\n        if( groupRolesMap != null ) {\n            for( String groupName : groupNames ) {\n                String strRoleNames = groupRolesMap.get( groupName );\n                if( strRoleNames != null ) {\n                    for( String roleName : strRoleNames.split( ROLE_NAMES_DELIMETER ) ) {\n\n                        if( log.isDebugEnabled() ) {\n                            log.debug( \"User is member of group [\" + groupName + \"] so adding role [\" + roleName + \"]\" );\n                        }\n\n                        roleNames.add( roleName );\n\n                    }\n                }\n            }\n        }\n        return roleNames;\n    }\n\n\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Tim Veil, Jeremy Haile\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.realm.activedirectory;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authz.AuthorizingAccount;\nimport org.jsecurity.authz.SimpleAuthorizingAccount;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.realm.ldap.AbstractLdapRealm;\nimport org.jsecurity.realm.ldap.LdapContextFactory;\nimport org.jsecurity.realm.ldap.LdapUtils;\n\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.naming.ldap.LdapContext;\nimport java.util.*;\n\n/**\n * <p>An {@link Realm} that authenticates with an active directory LDAP\n * server to determine the roles for a particular user.  This implementation\n * queries for the user's groups and then maps the group names to roles using the\n * {@link #groupRolesMap}.<\/p>\n *\n *\n * @since 0.1\n * @author Tim Veil\n * @author Jeremy Haile\n */\npublic class ActiveDirectoryRealm extends AbstractLdapRealm {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    \n    private static final String ROLE_NAMES_DELIMETER = \",\";\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n\n    /**\n     * Mapping from fully qualified active directory\n     * group names (e.g. CN=Group,OU=Company,DC=MyDomain,DC=local)\n     * as returned by the active directory LDAP server to role names.\n     */\n    private Map<String, String> groupRolesMap;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    public void setGroupRolesMap(Map<String, String> groupRolesMap) {\n        this.groupRolesMap = groupRolesMap;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n\n    /**\n     * <p>Builds an {@link org.jsecurity.authc.Account} object by querying the active directory LDAP context for the\n     * specified username.  This method binds to the LDAP server using the provided username and password -\n     * which if successful, indicates that the password is correct.<\/p>\n     *\n     * <p>This method can be overridden by subclasses to query the LDAP server in a more complex way.<\/p>\n     *\n     * @param token the authentication token provided by the user.\n     * @param ldapContextFactory the factory used to build connections to the LDAP server.\n     * @return an {@link org.jsecurity.authc.Account} instance containing information retrieved from LDAP\n     * that can be used to build an {@link org.jsecurity.authc.Account} instance to return.\n     *\n     * @throws NamingException if any LDAP errors occur during the search.\n     */\n    protected Account queryForLdapAccount(AuthenticationToken token, LdapContextFactory ldapContextFactory) throws NamingException {\n\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n\n        // Binds using the username and password provided by the user.\n        LdapContext ctx = null;\n        try {\n            ctx = ldapContextFactory.getLdapContext( upToken.getUsername(), String.valueOf( upToken.getPassword() ) );\n        } finally {\n            LdapUtils.closeContext( ctx );\n        }\n\n        return createAccount( upToken.getUsername(), upToken.getPassword() );\n    }\n\n    protected Account createAccount( String username, char[] password ) {\n        return new SimpleAuthorizingAccount( username, password );\n    }\n\n\n    /**\n     * <p>Builds an {@link org.jsecurity.authz.AuthorizingAccount} object by querying the active directory LDAP context for the\n     * groups that a user is a member of.  The groups are then translated to role names by using the\n     * configured {@link #groupRolesMap}.<\/p>\n     *\n     * <p>This implementation expects the <tt>principal<\/tt> argument to be a String username.\n     *\n     * <p>Subclasses can override this method to determine authorization data (roles, permissions, etc) in a more\n     * complex way.  Note that this default implementation does not support permissions, only roles.<\/p>\n     *\n     * @param principal the principal of the Subject whose Account is being retrieved.\n     * @param ldapContextFactory the factory used to create LDAP connections.\n     * @return the Account for the given Subject principal.\n     * @throws NamingException if an error occurs when searching the LDAP server.\n     */\n    protected AuthorizingAccount queryForLdapAccount( Object principal, LdapContextFactory ldapContextFactory) throws NamingException {\n\n        String username = null;\n\n        if ( !(principal instanceof String ) ) {\n            String msg = \"This implementation expects the principal argument to be a String.\";\n            throw new IllegalArgumentException( msg );\n        }\n\n        username = (String)principal;\n\n        // Perform context search\n        LdapContext ldapContext = ldapContextFactory.getSystemLdapContext();\n\n        Set<String> roleNames;\n\n        try {\n            roleNames = getRoleNamesForUser(username, ldapContext);\n        } finally {\n            LdapUtils.closeContext( ldapContext );\n        }\n\n        return new SimpleAuthorizingAccount( principal, null, roleNames, null );\n    }\n\n    private Set<String> getRoleNamesForUser( String username, LdapContext ldapContext) throws NamingException {\n        Set<String> roleNames;\n        roleNames = new LinkedHashSet<String>();\n\n        SearchControls searchCtls = new SearchControls();\n        searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        String searchFilter = \"(&(objectClass=*)(userPrincipalName=\" + username + \"))\";\n\n        NamingEnumeration answer = ldapContext.search(searchBase, searchFilter, searchCtls);\n\n        while (answer.hasMoreElements()) {\n            SearchResult sr = (SearchResult) answer.next();\n\n            if( log.isDebugEnabled() ) {\n                log.debug(\"Retrieving group names for user [\" + sr.getName() + \"]\");\n            }\n\n            Attributes attrs = sr.getAttributes();\n\n            if (attrs != null) {\n                NamingEnumeration ae = attrs.getAll();\n                while( ae.hasMore() ) {\n                    Attribute attr = (Attribute) ae.next();\n\n                    if( attr.getID().equals( \"memberOf\" ) ) {\n\n                        Collection<String> groupNames = LdapUtils.getAllAttributeValues( attr );\n\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Groups found for user [\" + username + \"]: \" + groupNames );\n                        }\n\n                        Collection<String> rolesForGroups = getRoleNamesForGroups(groupNames);\n                        roleNames.addAll(rolesForGroups);\n                    }\n                }\n            }\n        }\n        return roleNames;\n    }\n\n    /**\n     * This method is called by the default implementation to translate Active Directory group names\n     * to role names.  This implementation uses the {@link #groupRolesMap} to map group names to role names.\n     * @param groupNames the group names that apply to the current user.\n     * @return a collection of roles that are implied by the given role names.\n     */\n    protected Collection<String> getRoleNamesForGroups(Collection<String> groupNames) {\n        Set<String> roleNames = new HashSet<String>( groupNames.size() );\n\n        if( groupRolesMap != null ) {\n            for( String groupName : groupNames ) {\n                String strRoleNames = groupRolesMap.get( groupName );\n                if( strRoleNames != null ) {\n                    for( String roleName : strRoleNames.split( ROLE_NAMES_DELIMETER ) ) {\n\n                        if( log.isDebugEnabled() ) {\n                            log.debug( \"User is member of group [\" + groupName + \"] so adding role [\" + roleName + \"]\" );\n                        }\n\n                        roleNames.add( roleName );\n\n                    }\n                }\n            }\n        }\n        return roleNames;\n    }\n\n\n}\n","lineNo":112}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Jeremy Haile, Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authz.AuthorizingAccount;\nimport org.jsecurity.authz.SimpleAuthorizingAccount;\nimport org.jsecurity.authz.SimpleRole;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.cache.HashtableCacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.SimplePrincipalCollection;\nimport org.jsecurity.util.Initializable;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * <p>A simple implementation of the {@link org.jsecurity.realm.Realm Realm} interface that\n * uses a set of configured user accounts and roles to support authentication and authorization.  Each account entry\n * specifies the username, password, and roles for a user.  Roles can also be mapped\n * to permissions and associated with users.<\/p>\n *\n * <p>User accounts and roles are stored in two {@link Cache cache}s, so it is the Cache manager implementation that\n * determines if this class stores all data in memory or spools to disk or clusters it, etc based on the\n * Caches it creates.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SimpleAccountRealm extends AuthorizingRealm implements Initializable {\n\n    /**\n     * The default postfix appended to the Role cache name.\n     */\n    private static final String DEFAULT_ROLE_CACHE_POSTFIX = \"-roles\";\n    private static int INSTANCE_COUNT = 0;\n\n    //parent class already has the user account cache, we just need to add a role cache:\n    protected Cache roleCache = null;\n    protected String roleCacheName;\n\n    public SimpleAccountRealm() {\n    }\n\n    public Cache getRoleCache() {\n        return roleCache;\n    }\n\n    public void setRoleCache(Cache roleCache) {\n        this.roleCache = roleCache;\n    }\n\n    public String getRoleCacheName() {\n        return roleCacheName;\n    }\n\n    public void setRoleCacheName(String roleCacheName) {\n        this.roleCacheName = roleCacheName;\n    }\n\n    public void afterAccountCacheSet() {\n        initRoleCache();\n        afterRoleCacheSet();\n    }\n\n    public void afterRoleCacheSet(){}\n\n    protected void initRoleCache() {\n        CacheManager manager = getCacheManager();\n\n        if ( manager == null ) {\n            manager = new HashtableCacheManager();\n            setCacheManager(manager);\n        }\n\n        if ( getAccountCache() == null ) {\n            initAccountCache();\n        }\n\n        String roleCacheName = getRoleCacheName();\n        if ( roleCacheName == null ) {\n            roleCacheName = getClass().getName() + \"-\" + INSTANCE_COUNT++ + DEFAULT_ROLE_CACHE_POSTFIX;\n            setRoleCacheName( roleCacheName );\n        }\n        Cache roleCache = manager.getCache( roleCacheName );\n        setRoleCache(roleCache);\n\n        userAndRoleCachesCreated();\n    }\n\n    protected SimpleAuthorizingAccount getUser( PrincipalCollection principals ) {\n        return (SimpleAuthorizingAccount)getAccountCache().get( principals );\n    }\n\n    protected void add( SimpleAuthorizingAccount user ) {\n        getAccountCache().put( user.getPrincipals(), user );\n    }\n\n    protected SimpleRole getRole( String rolename ) {\n        return (SimpleRole)roleCache.get( rolename );\n    }\n\n    protected void add( SimpleRole role ) {\n        roleCache.put( role.getName(), role );\n    }\n\n    protected static Set<String> toSet( String delimited, String delimiter ) {\n        if ( delimited == null || delimited.trim().equals( \"\" ) ) {\n            return null;\n        }\n\n        Set<String> values = new HashSet<String>();\n        String[] rolenamesArray = delimited.split( delimiter );\n        for ( String s : rolenamesArray ) {\n            String trimmed = s.trim();\n            if ( trimmed.length() > 0 ) {\n                values.add( trimmed );\n            }\n        }\n\n        return values;\n    }\n\n    protected void userAndRoleCachesCreated(){}\n\n    protected Account doGetAccount( AuthenticationToken token ) throws AuthenticationException {\n        UsernamePasswordToken upToken = (UsernamePasswordToken)token;\n        SimplePrincipalCollection principals = new SimplePrincipalCollection( \"simple\", upToken.getUsername() );\n        return doGetAccount( principals );\n    }\n\n    protected AuthorizingAccount doGetAccount(PrincipalCollection principal) {\n        return (SimpleAuthorizingAccount)getAccountCache().get(principal);\n    }\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Jeremy Haile, Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authz.AuthorizingAccount;\nimport org.jsecurity.authz.SimpleAuthorizingAccount;\nimport org.jsecurity.authz.SimpleRole;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.cache.HashtableCacheManager;\nimport org.jsecurity.util.Initializable;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * <p>A simple implementation of the {@link org.jsecurity.realm.Realm Realm} interface that\n * uses a set of configured user accounts and roles to support authentication and authorization.  Each account entry\n * specifies the username, password, and roles for a user.  Roles can also be mapped\n * to permissions and associated with users.<\/p>\n *\n * <p>User accounts and roles are stored in two {@link Cache cache}s, so it is the Cache manager implementation that\n * determines if this class stores all data in memory or spools to disk or clusters it, etc based on the\n * Caches it creates.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SimpleAccountRealm extends AuthorizingRealm implements Initializable {\n\n    /**\n     * The default postfix appended to the Role cache name.\n     */\n    private static final String DEFAULT_ROLE_CACHE_POSTFIX = \"-roles\";\n    private static int INSTANCE_COUNT = 0;\n\n    //parent class already has the user account cache, we just need to add a role cache:\n    protected Cache roleCache = null;\n    protected String roleCacheName;\n\n    public SimpleAccountRealm() {\n    }\n\n    public Cache getRoleCache() {\n        return roleCache;\n    }\n\n    public void setRoleCache(Cache roleCache) {\n        this.roleCache = roleCache;\n    }\n\n    public String getRoleCacheName() {\n        return roleCacheName;\n    }\n\n    public void setRoleCacheName(String roleCacheName) {\n        this.roleCacheName = roleCacheName;\n    }\n\n    public void afterAccountCacheSet() {\n        initRoleCache();\n        afterRoleCacheSet();\n    }\n\n    public void afterRoleCacheSet(){}\n\n    protected void initRoleCache() {\n        CacheManager manager = getCacheManager();\n\n        if ( manager == null ) {\n            manager = new HashtableCacheManager();\n            setCacheManager(manager);\n        }\n\n        if ( getAccountCache() == null ) {\n            initAccountCache();\n        }\n\n        String roleCacheName = getRoleCacheName();\n        if ( roleCacheName == null ) {\n            roleCacheName = getClass().getName() + \"-\" + INSTANCE_COUNT++ + DEFAULT_ROLE_CACHE_POSTFIX;\n            setRoleCacheName( roleCacheName );\n        }\n        Cache roleCache = manager.getCache( roleCacheName );\n        setRoleCache(roleCache);\n\n        userAndRoleCachesCreated();\n    }\n\n    protected SimpleAuthorizingAccount getUser( String username ) {\n        return (SimpleAuthorizingAccount)getAccountCache().get( username );\n    }\n\n    protected void add( SimpleAuthorizingAccount user ) {\n        getAccountCache().put( user.getPrincipal(), user );\n    }\n\n    protected SimpleRole getRole( String rolename ) {\n        return (SimpleRole)roleCache.get( rolename );\n    }\n\n    protected void add( SimpleRole role ) {\n        roleCache.put( role.getName(), role );\n    }\n\n    protected static Set<String> toSet( String delimited, String delimiter ) {\n        if ( delimited == null || delimited.trim().equals( \"\" ) ) {\n            return null;\n        }\n\n        Set<String> values = new HashSet<String>();\n        String[] rolenamesArray = delimited.split( delimiter );\n        for ( String s : rolenamesArray ) {\n            String trimmed = s.trim();\n            if ( trimmed.length() > 0 ) {\n                values.add( trimmed );\n            }\n        }\n\n        return values;\n    }\n\n    protected void userAndRoleCachesCreated(){}\n\n    protected Account doGetAccount( AuthenticationToken token ) throws AuthenticationException {\n        UsernamePasswordToken upToken = (UsernamePasswordToken)token;\n        return doGetAccount( upToken.getUsername() );\n    }\n\n    protected AuthorizingAccount doGetAccount(Object principal) {\n        return (SimpleAuthorizingAccount)getAccountCache().get(principal);\n    }\n}\n","lineNo":147}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.realm.text;\n\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.SimpleAuthorizingAccount;\nimport org.jsecurity.authz.SimpleRole;\nimport org.jsecurity.realm.SimpleAccountRealm;\nimport org.jsecurity.subject.SimplePrincipalCollection;\nimport org.jsecurity.util.PermissionUtils;\nimport org.jsecurity.util.StringUtils;\n\nimport java.text.ParseException;\nimport java.util.*;\n\n/**\n * <p>a SimpleAccountRealm that enables text-based configuration of the initial User, Role, and Permission objects\n * created at startup.\n *\n * <p>Each User account definition specifies the username, password, and roles for a user.  Each Role definition\n * specifies a name and an optional collection of assigned Permissions.  Users can be assigned Roles, and Roles can be\n * assigned Permissions.  By transitive association, each User 'has' all of their Role's Permissions.<\/p>\n *\n * <p>User and user-to-role definitinos are specified via the {@link #setUserDefinitions} method and\n * Role-to-permission definitions are specified via the {@link #setRoleDefinitions} method.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class TextConfigurationRealm extends SimpleAccountRealm {\n\n    private String userDefinitions;\n    private String roleDefinitions;\n\n    public TextConfigurationRealm() {\n    }\n\n    public String getUserDefinitions() {\n        return userDefinitions;\n    }\n\n    /**\n     * <p>Sets a newline (\\n) delimited String that defines user-to-password-and-role(s) key/value pairs according\n     * to the following format:\n     *\n     * <p><code><em>username<\/em> = <em>password<\/em>, role1, role2,...<\/code><\/p>\n     *\n     * <p>Here are some examples of what these lines might look like:<\/p>\n     *\n     * <p><code>root = <em>reallyHardToGuessPassword<\/em>, administrator<br/>\n     * jsmith = <em>jsmithsPassword<\/em>, manager, engineer, employee<br/>\n     * abrown = <em>abrownsPassword<\/em>, qa, employee<br/>\n     * djones = <em>djonesPassword<\/em>, qa, contractor<br/>\n     * guest = <em>guestPassword<\/em><\/code><\/p>\n     *\n     * @param userDefinitions the user definitions to be parsed and converted to Map.Entry elements\n     */\n    public void setUserDefinitions(String userDefinitions) {\n        this.userDefinitions = userDefinitions;\n    }\n\n    public String getRoleDefinitions() {\n        return roleDefinitions;\n    }\n\n    /**\n     * Sets a newline (\\n) delimited String that defines role-to-permission definitions.\n     *\n     * <p>Each line within the string must define a role-to-permission(s) key/value mapping with the\n     * equals character signifies the key/value separation, like so:<\/p>\n     *\n     * <p><code><em>rolename<\/em> = <em>permissionDefinition1<\/em>, <em>permissionDefinition2<\/em>, ...<\/code><\/p>\n     *\n     * <p>where <em>permissionDefinition<\/em> is an arbitrary String, but must people will want to use\n     * Strings that conform to the {@link org.jsecurity.authz.permission.WildcardPermission WildcardPermission}\n     * format for ease of use and flexibility.  Note that if an individual <em>permissionDefnition<\/em> needs to\n     * be internally comma-delimited (e.g. <code>printer:5thFloor:print,info<\/code>), you will need to surround that\n     * definition with double quotes (&quot;) to avoid parsing errors (e.g.\n     * <code>&quot;printer:5thFloor:print,info&quot;<\/code>).\n     *\n     * <p><b>NOTE:<\/b> if you have roles that don't require permission associations, don't include them in this\n     * definition - just defining the role name in the {@link #setUserDefinitions(String) userDefinitions} is\n     * enough to create the role if it does not yet exist.  This property is really only for configuring realms that\n     * have one or more assigned Permission.\n     *\n     * @param roleDefinitions the role definitions to be parsed at initialization\n     */\n    public void setRoleDefinitions(String roleDefinitions) {\n        this.roleDefinitions = roleDefinitions;\n    }\n\n    protected void userAndRoleCachesCreated() {\n        processDefinitions();\n    }\n\n    protected void processDefinitions() {\n        try {\n            processRoleDefinitions();\n            processUserDefinitions();\n        } catch (ParseException e) {\n            String msg = \"Unable to parse user and/or role definitions.\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    protected void processRoleDefinitions() throws ParseException {\n        String roleDefinitions = getRoleDefinitions();\n        if (roleDefinitions == null) {\n            return;\n        }\n        Map<String, String> roleDefs = toMap( toLines(roleDefinitions) );\n        if (roleDefs == null || roleDefs.isEmpty()) {\n            return;\n        }\n\n        for (String rolename : roleDefs.keySet()) {\n            String value = roleDefs.get(rolename);\n\n            SimpleRole role = getRole(rolename);\n            if (role == null) {\n                role = new SimpleRole(rolename);\n                add(role);\n            }\n\n            Set<Permission> permissions = PermissionUtils.resolveDelimitedPermissions(value, getPermissionResolver());\n            role.setPermissions(permissions);\n        }\n    }\n\n    protected void processUserDefinitions() throws ParseException {\n\n        String userDefinitions = getUserDefinitions();\n        if ( userDefinitions == null ) {\n            return;\n        }\n\n        Map<String, String> userDefs = toMap( toLines(userDefinitions));\n        if (userDefs == null || userDefs.isEmpty()) {\n            return;\n        }\n\n        for (String username : userDefs.keySet()) {\n\n            String value = userDefs.get(username);\n\n            String[] passwordAndRolesArray = StringUtils.split(value);\n\n            String password = passwordAndRolesArray[0];\n\n            SimplePrincipalCollection principals = new SimplePrincipalCollection(getName(), username );\n            SimpleAuthorizingAccount user = getUser(principals);\n            if (user == null) {\n                user = new SimpleAuthorizingAccount(principals, password);\n                add(user);\n            }\n            user.setCredentials(password);\n\n            if (passwordAndRolesArray.length > 1) {\n                for( int i = 1; i < passwordAndRolesArray.length; i++ ) {\n                    String rolename = passwordAndRolesArray[i];\n                    SimpleRole role = getRole(rolename);\n                    if (role == null) {\n                        role = new SimpleRole(rolename);\n                        add(role);\n                    }\n                    user.add(role);\n                }\n            } else {\n                user.setRoles(null);\n            }\n        }\n    }\n\n    protected static Set<String> toLines( String s ) {\n        LinkedHashSet<String> set = new LinkedHashSet<String>();\n        Scanner scanner = new Scanner(s);\n        while (scanner.hasNextLine()) {\n            set.add(scanner.nextLine());\n        }\n        return set;\n    }\n\n    protected static Map<String, String> toMap(Collection<String> keyValuePairs) throws ParseException {\n        if (keyValuePairs == null || keyValuePairs.isEmpty()) {\n            return null;\n        }\n\n        Map<String, String> pairs = new HashMap<String, String>();\n        for (String pairString : keyValuePairs) {\n            String[] pair = StringUtils.splitKeyValue(pairString);\n            pairs.put(pair[0].trim(), pair[1].trim());\n        }\n\n        return pairs;\n    }\n\n    public void onLogout(Object accountPrincipal) {\n        //override parent method of removing user from cache\n        //we don't want that to happen on cache-only realm since that would permanently\n        //remove the user from the realm.\n    }\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.realm.text;\n\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.SimpleAuthorizingAccount;\nimport org.jsecurity.authz.SimpleRole;\nimport org.jsecurity.realm.SimpleAccountRealm;\nimport org.jsecurity.util.PermissionUtils;\nimport org.jsecurity.util.StringUtils;\n\nimport java.text.ParseException;\nimport java.util.*;\n\n/**\n * <p>a SimpleAccountRealm that enables text-based configuration of the initial User, Role, and Permission objects\n * created at startup.\n *\n * <p>Each User account definition specifies the username, password, and roles for a user.  Each Role definition\n * specifies a name and an optional collection of assigned Permissions.  Users can be assigned Roles, and Roles can be\n * assigned Permissions.  By transitive association, each User 'has' all of their Role's Permissions.<\/p>\n *\n * <p>User and user-to-role definitinos are specified via the {@link #setUserDefinitions} method and\n * Role-to-permission definitions are specified via the {@link #setRoleDefinitions} method.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class TextConfigurationRealm extends SimpleAccountRealm {\n\n    private String userDefinitions;\n    private String roleDefinitions;\n\n    public TextConfigurationRealm() {\n    }\n\n    public String getUserDefinitions() {\n        return userDefinitions;\n    }\n\n    /**\n     * <p>Sets a newline (\\n) delimited String that defines user-to-password-and-role(s) key/value pairs according\n     * to the following format:\n     *\n     * <p><code><em>username<\/em> = <em>password<\/em>, role1, role2,...<\/code><\/p>\n     *\n     * <p>Here are some examples of what these lines might look like:<\/p>\n     *\n     * <p><code>root = <em>reallyHardToGuessPassword<\/em>, administrator<br/>\n     * jsmith = <em>jsmithsPassword<\/em>, manager, engineer, employee<br/>\n     * abrown = <em>abrownsPassword<\/em>, qa, employee<br/>\n     * djones = <em>djonesPassword<\/em>, qa, contractor<br/>\n     * guest = <em>guestPassword<\/em><\/code><\/p>\n     *\n     * @param userDefinitions the user definitions to be parsed and converted to Map.Entry elements\n     */\n    public void setUserDefinitions(String userDefinitions) {\n        this.userDefinitions = userDefinitions;\n    }\n\n    public String getRoleDefinitions() {\n        return roleDefinitions;\n    }\n\n    /**\n     * Sets a newline (\\n) delimited String that defines role-to-permission definitions.\n     *\n     * <p>Each line within the string must define a role-to-permission(s) key/value mapping with the\n     * equals character signifies the key/value separation, like so:<\/p>\n     *\n     * <p><code><em>rolename<\/em> = <em>permissionDefinition1<\/em>, <em>permissionDefinition2<\/em>, ...<\/code><\/p>\n     *\n     * <p>where <em>permissionDefinition<\/em> is an arbitrary String, but must people will want to use\n     * Strings that conform to the {@link org.jsecurity.authz.permission.WildcardPermission WildcardPermission}\n     * format for ease of use and flexibility.  Note that if an individual <em>permissionDefnition<\/em> needs to\n     * be internally comma-delimited (e.g. <code>printer:5thFloor:print,info<\/code>), you will need to surround that\n     * definition with double quotes (&quot;) to avoid parsing errors (e.g.\n     * <code>&quot;printer:5thFloor:print,info&quot;<\/code>).\n     *\n     * <p><b>NOTE:<\/b> if you have roles that don't require permission associations, don't include them in this\n     * definition - just defining the role name in the {@link #setUserDefinitions(String) userDefinitions} is\n     * enough to create the role if it does not yet exist.  This property is really only for configuring realms that\n     * have one or more assigned Permission.\n     *\n     * @param roleDefinitions the role definitions to be parsed at initialization\n     */\n    public void setRoleDefinitions(String roleDefinitions) {\n        this.roleDefinitions = roleDefinitions;\n    }\n\n    protected void userAndRoleCachesCreated() {\n        processDefinitions();\n    }\n\n    protected void processDefinitions() {\n        try {\n            processRoleDefinitions();\n            processUserDefinitions();\n        } catch (ParseException e) {\n            String msg = \"Unable to parse user and/or role definitions.\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    protected void processRoleDefinitions() throws ParseException {\n        String roleDefinitions = getRoleDefinitions();\n        if (roleDefinitions == null) {\n            return;\n        }\n        Map<String, String> roleDefs = toMap( toLines(roleDefinitions) );\n        if (roleDefs == null || roleDefs.isEmpty()) {\n            return;\n        }\n\n        for (String rolename : roleDefs.keySet()) {\n            String value = roleDefs.get(rolename);\n\n            SimpleRole role = getRole(rolename);\n            if (role == null) {\n                role = new SimpleRole(rolename);\n                add(role);\n            }\n\n            Set<Permission> permissions = PermissionUtils.resolveDelimitedPermissions(value, getPermissionResolver());\n            role.setPermissions(permissions);\n        }\n    }\n\n    protected void processUserDefinitions() throws ParseException {\n\n        String userDefinitions = getUserDefinitions();\n        if ( userDefinitions == null ) {\n            return;\n        }\n\n        Map<String, String> userDefs = toMap( toLines(userDefinitions));\n        if (userDefs == null || userDefs.isEmpty()) {\n            return;\n        }\n\n        for (String username : userDefs.keySet()) {\n\n            String value = userDefs.get(username);\n\n            String[] passwordAndRolesArray = StringUtils.split(value);\n\n            String password = passwordAndRolesArray[0];\n            SimpleAuthorizingAccount user = getUser(username);\n            if (user == null) {\n                user = new SimpleAuthorizingAccount(username, password);\n                add(user);\n            }\n            user.setCredentials(password);\n\n            if (passwordAndRolesArray.length > 1) {\n                for( int i = 1; i < passwordAndRolesArray.length; i++ ) {\n                    String rolename = passwordAndRolesArray[i];\n                    SimpleRole role = getRole(rolename);\n                    if (role == null) {\n                        role = new SimpleRole(rolename);\n                        add(role);\n                    }\n                    user.add(role);\n                }\n            } else {\n                user.setRoles(null);\n            }\n        }\n    }\n\n    protected static Set<String> toLines( String s ) {\n        LinkedHashSet<String> set = new LinkedHashSet<String>();\n        Scanner scanner = new Scanner(s);\n        while (scanner.hasNextLine()) {\n            set.add(scanner.nextLine());\n        }\n        return set;\n    }\n\n    protected static Map<String, String> toMap(Collection<String> keyValuePairs) throws ParseException {\n        if (keyValuePairs == null || keyValuePairs.isEmpty()) {\n            return null;\n        }\n\n        Map<String, String> pairs = new HashMap<String, String>();\n        for (String pairString : keyValuePairs) {\n            String[] pair = StringUtils.splitKeyValue(pairString);\n            pairs.put(pair[0].trim(), pair[1].trim());\n        }\n\n        return pairs;\n    }\n\n    public void onLogout(Object accountPrincipal) {\n        //override parent method of removing user from cache\n        //we don't want that to happen on cache-only realm since that would permanently\n        //remove the user from the realm.\n    }\n}\n","lineNo":163}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Tim Veil\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authc.credential.AllowAllCredentialsMatcher;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.AuthorizingAccount;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.SimpleAuthorizingAccount;\nimport org.jsecurity.mgt.DefaultSecurityManager;\nimport org.jsecurity.realm.AuthorizingRealm;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.SimplePrincipalCollection;\nimport org.jsecurity.subject.Subject;\nimport org.junit.After;\nimport static org.junit.Assert.*;\nimport org.junit.Before;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Simple test case for AuthorizingRealm.\n *\n * TODO - this could/should be expaned to be more robust end to end test for the AuthorizingRealm\n *\n * @author Tim Veil\n */\npublic class AuthorizingRealmTest {\n\n    DefaultSecurityManager securityManager = null;\n    AuthorizingRealm realm;\n\n    private static final String USERNAME = \"testuser\";\n    private static final String PASSWORD = \"password\";\n    private static final int USER_ID = 12345;\n    private static final String ROLE = \"admin\";\n    private InetAddress localhost;\n\n    {\n        try {\n            localhost = InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            fail( \"Error creating localhost\" );\n        }\n    }\n\n    @Before\n    public void setup() {\n        realm = new AllowAllRealm();\n        securityManager = new DefaultSecurityManager();\n        // Not using constructor to prevent init() from running automatically (so tests can alter SM before init())\n        // Tests must call init() on SM before using.\n        securityManager.setRealm( realm );\n\n    }\n\n    @After\n    public void tearDown() {\n        securityManager.destroy();\n        securityManager = null;\n        realm = null;\n    }\n\n    //TODO - re-enable\n    public void testDefaultConfig() {\n        securityManager.init();\n        InetAddress localhost = null;\n        try {\n            localhost = InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n        Subject subject = securityManager.login(new UsernamePasswordToken(USERNAME, PASSWORD, localhost));\n        assertTrue(subject.isAuthenticated());\n        assertTrue(subject.hasRole(ROLE));\n        Object principals = subject.getPrincipal();\n        assertTrue(principals instanceof Collection && ((Collection)principals).size() == 3);\n\n        UsernamePrincipal usernamePrincipal = subject.getPrincipals().oneByType(UsernamePrincipal.class);\n        assertTrue(usernamePrincipal.getUsername().equals(USERNAME));\n\n        UserIdPrincipal userIdPrincipal = subject.getPrincipals().oneByType(UserIdPrincipal.class);\n        assertTrue(userIdPrincipal.getUserId() == USER_ID);\n\n        String stringPrincipal = subject.getPrincipals().oneByType(String.class);\n        assertTrue(stringPrincipal.equals(USER_ID + USERNAME));\n\n\n        subject.logout();\n    }\n\n    //TODO - re-enable\n    public void testCreateAccountOverride() {\n\n        Realm realm = new AllowAllRealm() {\n            protected Account createAccount(Object principal, Object credentials) {\n                String username = (String) principal;\n                UsernamePrincipal customPrincipal = new UsernamePrincipal( username );\n                SimplePrincipalCollection principals = new SimplePrincipalCollection(\"allowAll\",customPrincipal);\n                return new SimpleAuthorizingAccount( principals, credentials );\n            }\n        };\n\n        securityManager.setRealm( realm );\n        securityManager.init();\n\n        // Do login\n        Subject subject = securityManager.login(new UsernamePasswordToken(USERNAME, PASSWORD, localhost));\n        assertTrue(subject.isAuthenticated());\n        assertTrue(subject.hasRole(ROLE));\n        assertTrue( (subject.getPrincipal() instanceof UsernamePrincipal) );\n        assertEquals( USERNAME, ((UsernamePrincipal) subject.getPrincipal()).getUsername() );\n\n\n    }\n\n    public class AllowAllRealm extends AuthorizingRealm {\n\n        CredentialsMatcher credentialsMatcher;\n\n        public AllowAllRealm() {\n            super();\n            setCredentialsMatcher( new AllowAllCredentialsMatcher() );\n        }\n\n        protected Account doGetAccount(AuthenticationToken token) throws AuthenticationException {\n            PrincipalCollection principals = new SimplePrincipalCollection(\"allowAll\", token.getPrincipal() );\n            return doGetAccount( principals );\n        }\n\n        protected AuthorizingAccount doGetAccount(PrincipalCollection principals) {\n            Set<String> roles = new HashSet<String>();\n            roles.add(ROLE);\n            return new SimpleAuthorizingAccount(principals, null, roles, new HashSet<Permission>());\n        }\n\n        protected Account createAccount(Object principal, Object credentials) {\n            SimplePrincipalCollection principals = new SimplePrincipalCollection();\n            principals.add( \"allowAll\", new UserIdPrincipal(USER_ID));\n            principals.add( \"allowAll\", new UsernamePrincipal(USERNAME));\n            principals.add( \"allowAll\", USER_ID + USERNAME );\n            return new SimpleAccount(principals,PASSWORD);\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Tim Veil\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authc.credential.AllowAllCredentialsMatcher;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.AuthorizingAccount;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.SimpleAuthorizingAccount;\nimport org.jsecurity.mgt.DefaultSecurityManager;\nimport org.jsecurity.realm.AuthorizingRealm;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.Subject;\nimport org.junit.After;\nimport static org.junit.Assert.*;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.*;\n\n/**\n * Simple test case for AuthorizingRealm.\n *\n * TODO - this could/should be expaned to be more robust end to end test for the AuthorizingRealm\n *\n * @author Tim Veil\n */\npublic class AuthorizingRealmTest {\n\n    DefaultSecurityManager securityManager = null;\n    AuthorizingRealm realm;\n\n    private static final String USERNAME = \"testuser\";\n    private static final String PASSWORD = \"password\";\n    private static final int USER_ID = 12345;\n    private static final String ROLE = \"admin\";\n    private InetAddress localhost;\n\n    {\n        try {\n            localhost = InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            fail( \"Error creating localhost\" );\n        }\n    }\n\n    @Before\n    public void setup() {\n        realm = new AllowAllRealm();\n        securityManager = new DefaultSecurityManager();\n        // Not using constructor to prevent init() from running automatically (so tests can alter SM before init())\n        // Tests must call init() on SM before using.\n        securityManager.setRealm( realm );\n\n    }\n\n    @After\n    public void tearDown() {\n        securityManager.destroy();\n        securityManager = null;\n        realm = null;\n    }\n\n    @Test\n    public void testDefaultConfig() {\n        securityManager.init();\n        InetAddress localhost = null;\n        try {\n            localhost = InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n        Subject subject = securityManager.login(new UsernamePasswordToken(USERNAME, PASSWORD, localhost));\n        assertTrue(subject.isAuthenticated());\n        assertTrue(subject.hasRole(ROLE));\n        Object principals = subject.getPrincipal();\n        assertTrue(principals instanceof Collection && ((Collection)principals).size() == 3);\n\n        UsernamePrincipal usernamePrincipal = subject.getPrincipalByType(UsernamePrincipal.class);\n        assertTrue(usernamePrincipal.getUsername().equals(USERNAME));\n\n        UserIdPrincipal userIdPrincipal = subject.getPrincipalByType(UserIdPrincipal.class);\n        assertTrue(userIdPrincipal.getUserId() == USER_ID);\n\n        String stringPrincipal = subject.getPrincipalByType(String.class);\n        assertTrue(stringPrincipal.equals(USER_ID + USERNAME));\n\n\n        subject.logout();\n    }\n\n    @Test\n    public void testCreateAccountOverride() {\n\n        Realm realm = new AllowAllRealm() {\n            protected Account createAccount(Object principal, Object credentials) {\n                String username = (String) principal;\n                CustomUsernamePrincipal customPrincipal = new CustomUsernamePrincipal( username );\n                return new SimpleAuthorizingAccount( customPrincipal, credentials );\n            }\n        };\n\n        securityManager.setRealm( realm );\n        securityManager.init();\n\n        // Do login\n        Subject subject = securityManager.login(new UsernamePasswordToken(USERNAME, PASSWORD, localhost));\n        assertTrue(subject.isAuthenticated());\n        assertTrue(subject.hasRole(ROLE));\n        assertTrue( (subject.getPrincipal() instanceof CustomUsernamePrincipal) );\n        assertEquals( USERNAME, ((CustomUsernamePrincipal) subject.getPrincipal()).getUsername() );\n\n\n    }\n\n    public class AllowAllRealm extends AuthorizingRealm {\n\n        CredentialsMatcher credentialsMatcher;\n\n        public AllowAllRealm() {\n            super();\n            setCredentialsMatcher( new AllowAllCredentialsMatcher() );\n        }\n\n        protected Account doGetAccount(AuthenticationToken token) throws AuthenticationException {\n            return doGetAccount( token.getPrincipal() );\n        }\n\n        protected AuthorizingAccount doGetAccount(Object principal) {\n            Set<String> roles = new HashSet<String>();\n            roles.add(ROLE);\n            return new SimpleAuthorizingAccount(principal, null, roles, new HashSet<Permission>());\n        }\n\n        protected Account createAccount(Object principal, Object credentials) {\n            List<Object> principals = new ArrayList<Object>();\n            principals.add(new UserIdPrincipal(USER_ID));\n            principals.add(new UsernamePrincipal(USERNAME));\n            principals.add(USER_ID + USERNAME);\n            return new SimpleAccount(principals,null);\n        }\n    }\n\n    public class CustomUsernamePrincipal {\n        private String username;\n\n        public CustomUsernamePrincipal(String username) {\n            this.username = username;\n        }\n\n        public String getUsername() {\n            return username;\n        }\n    }\n\n}\n","lineNo":146}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Tim Veil\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authc.credential.AllowAllCredentialsMatcher;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.AuthorizingAccount;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.SimpleAuthorizingAccount;\nimport org.jsecurity.mgt.DefaultSecurityManager;\nimport org.jsecurity.realm.AuthorizingRealm;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.SimplePrincipalCollection;\nimport org.jsecurity.subject.Subject;\nimport org.junit.After;\nimport static org.junit.Assert.*;\nimport org.junit.Before;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Simple test case for AuthorizingRealm.\n *\n * TODO - this could/should be expaned to be more robust end to end test for the AuthorizingRealm\n *\n * @author Tim Veil\n */\npublic class AuthorizingRealmTest {\n\n    DefaultSecurityManager securityManager = null;\n    AuthorizingRealm realm;\n\n    private static final String USERNAME = \"testuser\";\n    private static final String PASSWORD = \"password\";\n    private static final int USER_ID = 12345;\n    private static final String ROLE = \"admin\";\n    private InetAddress localhost;\n\n    {\n        try {\n            localhost = InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            fail( \"Error creating localhost\" );\n        }\n    }\n\n    @Before\n    public void setup() {\n        realm = new AllowAllRealm();\n        securityManager = new DefaultSecurityManager();\n        // Not using constructor to prevent init() from running automatically (so tests can alter SM before init())\n        // Tests must call init() on SM before using.\n        securityManager.setRealm( realm );\n\n    }\n\n    @After\n    public void tearDown() {\n        securityManager.destroy();\n        securityManager = null;\n        realm = null;\n    }\n\n    //TODO - re-enable\n    public void testDefaultConfig() {\n        securityManager.init();\n        InetAddress localhost = null;\n        try {\n            localhost = InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n        Subject subject = securityManager.login(new UsernamePasswordToken(USERNAME, PASSWORD, localhost));\n        assertTrue(subject.isAuthenticated());\n        assertTrue(subject.hasRole(ROLE));\n        Object principals = subject.getPrincipal();\n        assertTrue(principals instanceof Collection && ((Collection)principals).size() == 3);\n\n        UsernamePrincipal usernamePrincipal = subject.getPrincipals().oneByType(UsernamePrincipal.class);\n        assertTrue(usernamePrincipal.getUsername().equals(USERNAME));\n\n        UserIdPrincipal userIdPrincipal = subject.getPrincipals().oneByType(UserIdPrincipal.class);\n        assertTrue(userIdPrincipal.getUserId() == USER_ID);\n\n        String stringPrincipal = subject.getPrincipals().oneByType(String.class);\n        assertTrue(stringPrincipal.equals(USER_ID + USERNAME));\n\n\n        subject.logout();\n    }\n\n    //TODO - re-enable\n    public void testCreateAccountOverride() {\n\n        Realm realm = new AllowAllRealm() {\n            protected Account createAccount(Object principal, Object credentials) {\n                String username = (String) principal;\n                UsernamePrincipal customPrincipal = new UsernamePrincipal( username );\n                SimplePrincipalCollection principals = new SimplePrincipalCollection(\"allowAll\",customPrincipal);\n                return new SimpleAuthorizingAccount( principals, credentials );\n            }\n        };\n\n        securityManager.setRealm( realm );\n        securityManager.init();\n\n        // Do login\n        Subject subject = securityManager.login(new UsernamePasswordToken(USERNAME, PASSWORD, localhost));\n        assertTrue(subject.isAuthenticated());\n        assertTrue(subject.hasRole(ROLE));\n        assertTrue( (subject.getPrincipal() instanceof UsernamePrincipal) );\n        assertEquals( USERNAME, ((UsernamePrincipal) subject.getPrincipal()).getUsername() );\n\n\n    }\n\n    public class AllowAllRealm extends AuthorizingRealm {\n\n        CredentialsMatcher credentialsMatcher;\n\n        public AllowAllRealm() {\n            super();\n            setCredentialsMatcher( new AllowAllCredentialsMatcher() );\n        }\n\n        protected Account doGetAccount(AuthenticationToken token) throws AuthenticationException {\n            PrincipalCollection principals = new SimplePrincipalCollection(\"allowAll\", token.getPrincipal() );\n            return doGetAccount( principals );\n        }\n\n        protected AuthorizingAccount doGetAccount(PrincipalCollection principals) {\n            Set<String> roles = new HashSet<String>();\n            roles.add(ROLE);\n            return new SimpleAuthorizingAccount(principals, null, roles, new HashSet<Permission>());\n        }\n\n        protected Account createAccount(Object principal, Object credentials) {\n            SimplePrincipalCollection principals = new SimplePrincipalCollection();\n            principals.add( \"allowAll\", new UserIdPrincipal(USER_ID));\n            principals.add( \"allowAll\", new UsernamePrincipal(USERNAME));\n            principals.add( \"allowAll\", USER_ID + USERNAME );\n            return new SimpleAccount(principals,PASSWORD);\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Tim Veil\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authc.credential.AllowAllCredentialsMatcher;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.AuthorizingAccount;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.SimpleAuthorizingAccount;\nimport org.jsecurity.mgt.DefaultSecurityManager;\nimport org.jsecurity.realm.AuthorizingRealm;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.Subject;\nimport org.junit.After;\nimport static org.junit.Assert.*;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.*;\n\n/**\n * Simple test case for AuthorizingRealm.\n *\n * TODO - this could/should be expaned to be more robust end to end test for the AuthorizingRealm\n *\n * @author Tim Veil\n */\npublic class AuthorizingRealmTest {\n\n    DefaultSecurityManager securityManager = null;\n    AuthorizingRealm realm;\n\n    private static final String USERNAME = \"testuser\";\n    private static final String PASSWORD = \"password\";\n    private static final int USER_ID = 12345;\n    private static final String ROLE = \"admin\";\n    private InetAddress localhost;\n\n    {\n        try {\n            localhost = InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            fail( \"Error creating localhost\" );\n        }\n    }\n\n    @Before\n    public void setup() {\n        realm = new AllowAllRealm();\n        securityManager = new DefaultSecurityManager();\n        // Not using constructor to prevent init() from running automatically (so tests can alter SM before init())\n        // Tests must call init() on SM before using.\n        securityManager.setRealm( realm );\n\n    }\n\n    @After\n    public void tearDown() {\n        securityManager.destroy();\n        securityManager = null;\n        realm = null;\n    }\n\n    @Test\n    public void testDefaultConfig() {\n        securityManager.init();\n        InetAddress localhost = null;\n        try {\n            localhost = InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n        Subject subject = securityManager.login(new UsernamePasswordToken(USERNAME, PASSWORD, localhost));\n        assertTrue(subject.isAuthenticated());\n        assertTrue(subject.hasRole(ROLE));\n        Object principals = subject.getPrincipal();\n        assertTrue(principals instanceof Collection && ((Collection)principals).size() == 3);\n\n        UsernamePrincipal usernamePrincipal = subject.getPrincipalByType(UsernamePrincipal.class);\n        assertTrue(usernamePrincipal.getUsername().equals(USERNAME));\n\n        UserIdPrincipal userIdPrincipal = subject.getPrincipalByType(UserIdPrincipal.class);\n        assertTrue(userIdPrincipal.getUserId() == USER_ID);\n\n        String stringPrincipal = subject.getPrincipalByType(String.class);\n        assertTrue(stringPrincipal.equals(USER_ID + USERNAME));\n\n\n        subject.logout();\n    }\n\n    @Test\n    public void testCreateAccountOverride() {\n\n        Realm realm = new AllowAllRealm() {\n            protected Account createAccount(Object principal, Object credentials) {\n                String username = (String) principal;\n                CustomUsernamePrincipal customPrincipal = new CustomUsernamePrincipal( username );\n                return new SimpleAuthorizingAccount( customPrincipal, credentials );\n            }\n        };\n\n        securityManager.setRealm( realm );\n        securityManager.init();\n\n        // Do login\n        Subject subject = securityManager.login(new UsernamePasswordToken(USERNAME, PASSWORD, localhost));\n        assertTrue(subject.isAuthenticated());\n        assertTrue(subject.hasRole(ROLE));\n        assertTrue( (subject.getPrincipal() instanceof CustomUsernamePrincipal) );\n        assertEquals( USERNAME, ((CustomUsernamePrincipal) subject.getPrincipal()).getUsername() );\n\n\n    }\n\n    public class AllowAllRealm extends AuthorizingRealm {\n\n        CredentialsMatcher credentialsMatcher;\n\n        public AllowAllRealm() {\n            super();\n            setCredentialsMatcher( new AllowAllCredentialsMatcher() );\n        }\n\n        protected Account doGetAccount(AuthenticationToken token) throws AuthenticationException {\n            return doGetAccount( token.getPrincipal() );\n        }\n\n        protected AuthorizingAccount doGetAccount(Object principal) {\n            Set<String> roles = new HashSet<String>();\n            roles.add(ROLE);\n            return new SimpleAuthorizingAccount(principal, null, roles, new HashSet<Permission>());\n        }\n\n        protected Account createAccount(Object principal, Object credentials) {\n            List<Object> principals = new ArrayList<Object>();\n            principals.add(new UserIdPrincipal(USER_ID));\n            principals.add(new UsernamePrincipal(USERNAME));\n            principals.add(USER_ID + USERNAME);\n            return new SimpleAccount(principals,null);\n        }\n    }\n\n    public class CustomUsernamePrincipal {\n        private String username;\n\n        public CustomUsernamePrincipal(String username) {\n            this.username = username;\n        }\n\n        public String getUsername() {\n            return username;\n        }\n    }\n\n}\n","lineNo":118}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Jeremy Haile\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.samples.spring;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\n\n/**\n * Default implementation of the {@link SampleManager} interface that stores\n * and retrieves a value from the user's session.\n *\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DefaultSampleManager implements SampleManager {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * Key used to store the value in the user's session.\n     */\n    private static final String VALUE_KEY = \"sample_value\";\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logger.\n     */\n    protected transient final Log log = LogFactory.getLog(getClass());\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    public String getValue() {\n        String value = null;\n\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n\n\n            value = (String) session.getAttribute(VALUE_KEY);\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"retrieving session key [\" + VALUE_KEY + \"] with value [\" + value + \"] on session with id [\" + session.getId() + \"]\");\n            }\n\n        }\n\n        return value;\n    }\n\n    public void setValue(String newValue) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"saving session key [\" + VALUE_KEY + \"] with value [\" + newValue + \"] on session with id [\" + session.getId() + \"]\");\n        }\n\n        session.setAttribute(VALUE_KEY, newValue);\n    }\n\n    public void secureMethod1() {\n        if (log.isInfoEnabled()) {\n            log.info(\"Secure method 1 called...\");\n        }\n    }\n\n    public void secureMethod2() {\n        if (log.isInfoEnabled()) {\n            log.info(\"Secure method 2 called...\");\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Jeremy Haile\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.samples.spring;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\n\n/**\n * Default implementation of the {@link SampleManager} interface that stores\n * and retrieves a value from the user's session.\n *\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DefaultSampleManager implements SampleManager {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * Key used to store the value in the user's session.\n     */\n    private static final String VALUE_KEY = \"sample_value\";\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logger.\n     */\n    protected transient final Log log = LogFactory.getLog(getClass());\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    public String getValue() {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            return (String) session.getAttribute(VALUE_KEY);\n        } else {\n            return null;\n        }\n    }\n\n    public void setValue(String newValue) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        session.setAttribute(VALUE_KEY, newValue);\n    }\n\n    public void secureMethod1() {\n        if (log.isInfoEnabled()) {\n            log.info(\"Secure method 1 called...\");\n        }\n    }\n\n    public void secureMethod2() {\n        if (log.isInfoEnabled()) {\n            log.info(\"Secure method 2 called...\");\n        }\n    }\n\n}\n","lineNo":62}
{"Refactored Sample":"/*\n * Copyright 2005-2008 Les Hazlewood, Peter Ledbrook\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web.attr;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.beans.PropertyEditor;\n\n/**\n * A <tt>CookieAttribute<\/tt> stores an object as a {@link Cookie} for access on later requests.\n *\n * @author Les Hazlewood\n * @author Peter Ledbrook\n * @since 0.2\n */\npublic class CookieAttribute<T> extends AbstractWebAttribute<T> {\n\n    protected static final int ONE_YEAR = 60 * 60 * 24 * 365;\n    protected static final int INDEFINITE = Integer.MAX_VALUE;\n\n    private String path = null; //null means set it on the request context root\n    private int maxAge = -1; //expire on browser close\n    private boolean secure = false;\n\n    public CookieAttribute() {\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified {@link Cookie#getName() name}\n     * using the request context's path and with a {@link Cookie#setMaxAge(int) maxAge} of <tt>-1<\/tt>, indicating the\n     * Cookie will persist until browser shutdown.\n     *\n     * @param name the Cookie {@link Cookie#getName() name}\n     */\n    public CookieAttribute( String name ) {\n        super( name );\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name} and {@link Cookie#getPath() path}.\n     *\n     * <p>A <tt>null<\/tt> <tt>path<\/tt> value means the request context's path will be used by default.\n     *\n     * <p>The Cookie's {@link Cookie#getMaxAge() maxAge} will be <tt>-1<\/tt>, indicating the Cookie will persist until\n     * browser shutdown.\n     *\n     * @param name the Cookie {@link Cookie#getName() name}\n     * @param path the Cookie {@link Cookie#setPath(String) path}.\n     */\n    public CookieAttribute( String name, String path ) {\n        super( name );\n        setPath( path );\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name} and {@link Cookie#getMaxAge() maxAge}.\n     *\n     * <p>The Cookie's {@link javax.servlet.http.Cookie#getPath() path} will be the <tt>Request<\/tt>'s\n     * {@link javax.servlet.http.HttpServletRequest#getContextPath() context path}.\n     *\n     * @param name   the Cookie {@link javax.servlet.http.Cookie#getName() name};\n     * @param maxAge the Cookie {@link Cookie#getMaxAge() maxAge}\n     */\n    public CookieAttribute( String name, int maxAge ) {\n        super( name );\n        setMaxAge( maxAge );\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name}, {@link javax.servlet.http.Cookie#getPath() path}, and\n     * {@link Cookie#getMaxAge() maxAge}.\n     *\n     * @param name   the Cookie {@link Cookie#getName() name}\n     * @param path   the Cookie {@link Cookie#setPath(String) path}.\n     * @param maxAge the Cookie {@link Cookie#getMaxAge() maxAge}\n     */\n    public CookieAttribute( String name, String path, int maxAge ) {\n        this( name, path );\n        setMaxAge( maxAge );\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name}, {@link javax.servlet.http.Cookie#getPath() path}, and\n     * {@link Cookie#getMaxAge() maxAge}, utilizing the specified <tt>PropertyEditor<\/tt> to perform value/string\n     * conversion on the object stored as a cookie.\n     *\n     * @param name        the Cookie {@link Cookie#getName() name}\n     * @param path        the Cookie {@link Cookie#setPath(String) path}.\n     * @param maxAge      the Cookie {@link Cookie#getMaxAge() maxAge}\n     * @param editorClass the <tt>PropertyEditor<\/tt> to perform value/string conversion on the object stored as a\n     *                    Cookie.\n     */\n    public CookieAttribute( String name, String path, int maxAge, Class<? extends PropertyEditor> editorClass ) {\n        super( name, editorClass );\n        setPath( path );\n        setMaxAge( maxAge );\n    }\n\n    /**\n     * Returns the Cookie's {@link Cookie#getPath() path} setting.  If <tt>null<\/tt>, the <tt>request<\/tt>'s\n     * {@link javax.servlet.http.HttpServletRequest#getContextPath() context path} will be used.\n     * @return the Cookie's path, or <tt>null<\/tt> if the request's context path should be used as the path when the\n     * cookie is created.\n     */\n    public String getPath() {\n        return path;\n    }\n\n    /**\n     * Sets the Cookie's {@link Cookie#getPath() path} setting.  If the argument is <tt>null<\/tt>, the <tt>request<\/tt>'s\n     * {@link javax.servlet.http.HttpServletRequest#getContextPath() context path} will be used.\n     * @param path the Cookie's path, or <tt>null<\/tt> if the request's context path should be used as the path when the\n     * cookie is created.\n     */\n    public void setPath( String path ) {\n        this.path = path;\n    }\n\n    /**\n     * Returns the Cookie's {@link Cookie#setMaxAge(int) maxAge} setting.  Please see that JavaDoc for the semantics on\n     * the repercussions of negative, zero, and positive values for the maxAge.\n     * @return the Cookie's {@link Cookie#setMaxAge(int) maxAge}\n     */\n    public int getMaxAge() {\n        return maxAge;\n    }\n\n    /**\n     * Sets the Cookie's {@link Cookie#setMaxAge(int) maxAge} setting.  Please see that JavaDoc for the semantics on\n     * the repercussions of negative, zero, and positive values for the maxAge.\n     * @param maxAge the Cookie's {@link Cookie#setMaxAge(int) maxAge}\n     */\n    public void setMaxAge( int maxAge ) {\n        this.maxAge = maxAge;\n    }\n\n    public boolean isSecure() {\n        return secure;\n    }\n\n    public void setSecure( boolean secure ) {\n        this.secure = secure;\n    }\n\n    /**\n     * Returns the cookie with the given name from the request or <tt>null<\/tt> if no cookie\n     * with that name could be found.\n     *\n     * @param request    the current executing http request.\n     * @param cookieName the name of the cookie to find and return.\n     * @return the cookie with the given name from the request or <tt>null<\/tt> if no cookie\n     *         with that name could be found.\n     */\n    private static Cookie getCookie( HttpServletRequest request, String cookieName ) {\n        Cookie cookies[] = request.getCookies();\n        if ( cookies != null ) {\n            for ( Cookie cookie : cookies ) {\n                if ( cookie.getName().equals( cookieName ) ) {\n                    return cookie;\n                }\n            }\n        }\n        return null;\n    }\n\n    public T onRetrieveValue( ServletRequest request, ServletResponse response ) {\n        T value = null;\n\n        String stringValue = null;\n        Cookie cookie = getCookie( toHttp(request), getName() );\n        if ( cookie != null ) {\n            stringValue = cookie.getValue();\n            if ( log.isInfoEnabled() ) {\n                log.info( \"Found string value [\" + stringValue + \"] from HttpServletRequest Cookie [\" + getName() + \"]\" );\n            }\n            value = fromStringValue( stringValue );\n        } else {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No value found in request Cookies under cookie name [\" + getName() + \"]\" );\n            }\n        }\n\n        return value;\n    }\n\n    public void onStoreValue( T value, ServletRequest servletRequest, ServletResponse servletResponse ) {\n\n        HttpServletRequest request = toHttp( servletRequest );\n        HttpServletResponse response = toHttp( servletResponse );\n\n        String name = getName();\n        int maxAge = getMaxAge();\n        String path = getPath() != null ? getPath() : request.getContextPath();\n\n        String stringValue = toStringValue( value );\n        Cookie cookie = new Cookie( name, stringValue );\n        cookie.setMaxAge( maxAge );\n        cookie.setPath( path );\n        if ( isSecure() ) {\n            cookie.setSecure( true );\n        }\n\n        response.addCookie( cookie );\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Added Cookie [\" + name + \"] to path [\" + path + \"] with value [\" +\n                stringValue + \"] to the HttpServletResponse.\" );\n        }\n    }\n\n    public void removeValue(ServletRequest servletRequest, ServletResponse response) {\n        HttpServletRequest request = toHttp(servletRequest);\n        Cookie cookie = getCookie( request, getName() );\n        if ( cookie != null ) {\n            cookie.setMaxAge( 0 );\n            //JSEC-94: Must set the path on the outgoing cookie (some browsers don't retain it from the\n            //retrieved cookie?)\n            cookie.setPath( getPath() == null ? request.getContextPath() : getPath() );\n            cookie.setSecure( isSecure() );\n            toHttp(response).addCookie( cookie );\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright 2005-2008 Les Hazlewood\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jsecurity.web.attr;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.beans.PropertyEditor;\n\n/**\n * A <tt>CookieAttribute<\/tt> stores an object as a {@link Cookie} for access on later requests.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class CookieAttribute<T> extends AbstractWebAttribute<T> {\n\n    protected static final int ONE_YEAR = 60 * 60 * 24 * 365;\n    protected static final int INDEFINITE = Integer.MAX_VALUE;\n\n    private String path = null; //null means set it on the request context root\n    private int maxAge = -1; //expire on browser close\n    private boolean secure = false;\n\n    public CookieAttribute() {\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified {@link Cookie#getName() name}\n     * using the request context's path and with a {@link Cookie#setMaxAge(int) maxAge} of <tt>-1<\/tt>, indicating the\n     * Cookie will persist until browser shutdown.\n     *\n     * @param name the Cookie {@link Cookie#getName() name}\n     */\n    public CookieAttribute( String name ) {\n        super( name );\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name} and {@link Cookie#getPath() path}.\n     *\n     * <p>A <tt>null<\/tt> <tt>path<\/tt> value means the request context's path will be used by default.\n     *\n     * <p>The Cookie's {@link Cookie#getMaxAge() maxAge} will be <tt>-1<\/tt>, indicating the Cookie will persist until\n     * browser shutdown.\n     *\n     * @param name the Cookie {@link Cookie#getName() name}\n     * @param path the Cookie {@link Cookie#setPath(String) path}.\n     */\n    public CookieAttribute( String name, String path ) {\n        super( name );\n        setPath( path );\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name} and {@link Cookie#getMaxAge() maxAge}.\n     *\n     * <p>The Cookie's {@link javax.servlet.http.Cookie#getPath() path} will be the <tt>Request<\/tt>'s\n     * {@link javax.servlet.http.HttpServletRequest#getContextPath() context path}.\n     *\n     * @param name   the Cookie {@link javax.servlet.http.Cookie#getName() name};\n     * @param maxAge the Cookie {@link Cookie#getMaxAge() maxAge}\n     */\n    public CookieAttribute( String name, int maxAge ) {\n        super( name );\n        setMaxAge( maxAge );\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name}, {@link javax.servlet.http.Cookie#getPath() path}, and\n     * {@link Cookie#getMaxAge() maxAge}.\n     *\n     * @param name   the Cookie {@link Cookie#getName() name}\n     * @param path   the Cookie {@link Cookie#setPath(String) path}.\n     * @param maxAge the Cookie {@link Cookie#getMaxAge() maxAge}\n     */\n    public CookieAttribute( String name, String path, int maxAge ) {\n        this( name, path );\n        setMaxAge( maxAge );\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute<\/tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name}, {@link javax.servlet.http.Cookie#getPath() path}, and\n     * {@link Cookie#getMaxAge() maxAge}, utilizing the specified <tt>PropertyEditor<\/tt> to perform value/string\n     * conversion on the object stored as a cookie.\n     *\n     * @param name        the Cookie {@link Cookie#getName() name}\n     * @param path        the Cookie {@link Cookie#setPath(String) path}.\n     * @param maxAge      the Cookie {@link Cookie#getMaxAge() maxAge}\n     * @param editorClass the <tt>PropertyEditor<\/tt> to perform value/string conversion on the object stored as a\n     *                    Cookie.\n     */\n    public CookieAttribute( String name, String path, int maxAge, Class<? extends PropertyEditor> editorClass ) {\n        super( name, editorClass );\n        setPath( path );\n        setMaxAge( maxAge );\n    }\n\n    /**\n     * Returns the Cookie's {@link Cookie#getPath() path} setting.  If <tt>null<\/tt>, the <tt>request<\/tt>'s\n     * {@link javax.servlet.http.HttpServletRequest#getContextPath() context path} will be used.\n     * @return the Cookie's path, or <tt>null<\/tt> if the request's context path should be used as the path when the\n     * cookie is created.\n     */\n    public String getPath() {\n        return path;\n    }\n\n    /**\n     * Sets the Cookie's {@link Cookie#getPath() path} setting.  If the argument is <tt>null<\/tt>, the <tt>request<\/tt>'s\n     * {@link javax.servlet.http.HttpServletRequest#getContextPath() context path} will be used.\n     * @param path the Cookie's path, or <tt>null<\/tt> if the request's context path should be used as the path when the\n     * cookie is created.\n     */\n    public void setPath( String path ) {\n        this.path = path;\n    }\n\n    /**\n     * Returns the Cookie's {@link Cookie#setMaxAge(int) maxAge} setting.  Please see that JavaDoc for the semantics on\n     * the repercussions of negative, zero, and positive values for the maxAge.\n     * @return the Cookie's {@link Cookie#setMaxAge(int) maxAge}\n     */\n    public int getMaxAge() {\n        return maxAge;\n    }\n\n    /**\n     * Sets the Cookie's {@link Cookie#setMaxAge(int) maxAge} setting.  Please see that JavaDoc for the semantics on\n     * the repercussions of negative, zero, and positive values for the maxAge.\n     * @param maxAge the Cookie's {@link Cookie#setMaxAge(int) maxAge}\n     */\n    public void setMaxAge( int maxAge ) {\n        this.maxAge = maxAge;\n    }\n\n    public boolean isSecure() {\n        return secure;\n    }\n\n    public void setSecure( boolean secure ) {\n        this.secure = secure;\n    }\n\n    /**\n     * Returns the cookie with the given name from the request or <tt>null<\/tt> if no cookie\n     * with that name could be found.\n     *\n     * @param request    the current executing http request.\n     * @param cookieName the name of the cookie to find and return.\n     * @return the cookie with the given name from the request or <tt>null<\/tt> if no cookie\n     *         with that name could be found.\n     */\n    private static Cookie getCookie( HttpServletRequest request, String cookieName ) {\n        Cookie cookies[] = request.getCookies();\n        if ( cookies != null ) {\n            for ( Cookie cookie : cookies ) {\n                if ( cookie.getName().equals( cookieName ) ) {\n                    return cookie;\n                }\n            }\n        }\n        return null;\n    }\n\n    public T onRetrieveValue( ServletRequest request, ServletResponse response ) {\n        T value = null;\n\n        String stringValue = null;\n        Cookie cookie = getCookie( toHttp(request), getName() );\n        if ( cookie != null ) {\n            stringValue = cookie.getValue();\n            if ( log.isInfoEnabled() ) {\n                log.info( \"Found string value [\" + stringValue + \"] from HttpServletRequest Cookie [\" + getName() + \"]\" );\n            }\n            value = fromStringValue( stringValue );\n        } else {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No value found in request Cookies under cookie name [\" + getName() + \"]\" );\n            }\n        }\n\n        return value;\n    }\n\n    public void onStoreValue( T value, ServletRequest servletRequest, ServletResponse servletResponse ) {\n\n        HttpServletRequest request = toHttp( servletRequest );\n        HttpServletResponse response = toHttp( servletResponse );\n\n        String name = getName();\n        String path = getPath();\n        int maxAge = getMaxAge();\n\n        if ( path == null ) {\n            path = request.getContextPath();\n        }\n\n        String stringValue = toStringValue( value );\n        Cookie idCookie = new Cookie( name, stringValue );\n        idCookie.setMaxAge( maxAge );\n        idCookie.setPath( path );\n        if ( isSecure() ) {\n            idCookie.setSecure( true );\n        }\n\n        response.addCookie( idCookie );\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Added Cookie [\" + name + \"] to path [\" + path + \"] with value [\" +\n                stringValue + \"] to the HttpServletResponse.\" );\n        }\n    }\n\n    public void removeValue(ServletRequest request, ServletResponse response) {\n        Cookie cookie = getCookie( toHttp(request), getName() );\n        if ( cookie != null ) {\n            cookie.setMaxAge( 0 );\n            toHttp( response ).addCookie( cookie );\n        }\n    }\n}\n","lineNo":231}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.authc;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.HashSet;\n\n/**\n * Simple implementation of the {@link org.jsecurity.authc.Account} interface that\n * contains principal and credential information as instance variables and exposes them\n * via getters and setters using standard JavaBean notation.\n *\n * <p>Realm implementations can use this for simple principal/credential accounts, but note:\n *\n * <p>This class cannot perform its own authorization checks for roles and permissions.  It is therefore not sufficient\n * to use to back a Realm's {@link org.jsecurity.authz.Authorizer Authorizer} method implementations.  If you need\n * an Account object to perform role and permission checks itself, you might want to use instaces of\n * {@link org.jsecurity.authz.SimpleAuthorizingAccount SimpleAuthorizingAccount} instead of this class.\n *\n * <p>But note that a <tt>SimpleAuthorizingAccount<\/tt> object caches its roles and permission definitions and will not\n * persist any changes to these definitions back to the source Realm.  If you need dynamic runtime modification of Roles\n * and/or Permissions for any given account, your Realm implementation will need to perform the authorization checks\n * directly since instances of this class are primarily used for caching and could represent stale data.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @see org.jsecurity.authz.SimpleAuthorizingAccount\n * @since 0.1\n */\npublic class SimpleAccount implements Account, Serializable {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    protected transient final Log logger = LogFactory.getLog(getClass());\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The principal that apply to the authenticated Subject/user.\n     */\n    private Object principal = null;\n\n    /**\n     * Credentials that were used to authenticate the user.\n     */\n    private Object credentials = null;\n\n    /**\n     * True if the account is locked, false otherwise.\n     */\n    private boolean locked = false;\n\n    /**\n     * True if the user's credentials are expired, false otherwise.\n     */\n    private boolean credentialsExpired = false;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public SimpleAccount() {\n    }\n\n    public SimpleAccount(Object principal, Object credentials) {\n        this(principal, credentials, false, false);\n    }\n\n    public SimpleAccount(Object principal, Object credentials, boolean locked, boolean credentialsExpired) {\n        this.principal = principal;\n        this.credentials = credentials;\n        this.locked = locked;\n        this.credentialsExpired = credentialsExpired;\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    public Object getPrincipal() {\n        return this.principal;\n    }\n\n    public void setPrincipal(Object principal) {\n        this.principal = principal;\n    }\n\n    public Object getCredentials() {\n        return credentials;\n    }\n\n    public void setCredentials(Object credentials) {\n        this.credentials = credentials;\n    }\n\n    public boolean isLocked() {\n        return locked;\n    }\n\n    public void setLocked(boolean locked) {\n        this.locked = locked;\n    }\n\n    public boolean isCredentialsExpired() {\n        return credentialsExpired;\n    }\n\n    public void setCredentialsExpired(boolean credentialsExpired) {\n        this.credentialsExpired = credentialsExpired;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Merges (adds) the specified Account data into this instance.\n     *\n     * This allows an instance of this class to be an <em>aggregation<\/em>, or <em>composition<\/em> of account data\n     * from across multiple <code>Realm<\/code>s <tt>Realm<\/tt>s, not just one realm.\n     *\n     * <p>This is useful in a multi-realm authentication configuration - the individual <tt>Account<\/tt>\n     * objects obtained from each realm can be {@link #merge merged} into this object.  This single object can then be\n     * returned at the end of the authentication process, giving the impression of a single underlying\n     * realm/data source.\n     *\n     * @param otherAccount the account whos data will be merged (added) into this instance.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public void merge(Account otherAccount) {\n        if (otherAccount == null) {\n            return;\n        }\n\n        Object otherPrincipal = otherAccount.getPrincipal();\n        if (otherPrincipal == null) {\n            return;\n        }\n\n        Object thisPrincipal = getPrincipal();\n        if (thisPrincipal == null) {\n            this.principal = otherPrincipal;\n        } else {\n            HashSet set = new HashSet();\n            if (thisPrincipal instanceof Collection) {\n                set.addAll((Collection) thisPrincipal);\n            } else {\n                set.add(thisPrincipal);\n            }\n            if (otherPrincipal instanceof Collection) {\n                set.addAll((Collection) otherPrincipal);\n            } else {\n                set.add(otherPrincipal);\n            }\n            this.principal = set;\n        }\n\n        Object otherCredentials = otherAccount.getCredentials();\n        Object thisCredentials = getCredentials();\n        if ( thisCredentials == null ) {\n            this.credentials = otherCredentials;\n        } else {\n            HashSet set = new HashSet();\n            if (thisCredentials instanceof Collection) {\n                set.addAll((Collection) thisCredentials);\n            } else {\n                set.add(thisCredentials);\n            }\n            if (otherCredentials instanceof Collection) {\n                set.addAll((Collection) otherCredentials);\n            } else {\n                set.add(otherCredentials);\n            }\n            this.credentials = set;\n        }\n\n        if (otherAccount.isLocked()) {\n            setLocked(true);\n        }\n\n        if (otherAccount.isCredentialsExpired()) {\n            setCredentialsExpired(true);\n        }\n    }\n\n    public int hashCode() {\n        return (getPrincipal() != null ? getPrincipal().hashCode() : 0);\n    }\n\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimpleAccount) {\n            SimpleAccount sa = (SimpleAccount) o;\n            //principal should be unique across the application, so only check this for equality:\n            return (getPrincipal() != null ? getPrincipal().equals(sa.getPrincipal()) : sa.getPrincipal() == null);\n        }\n        return false;\n    }\n\n    public String toString() {\n        return getPrincipal() != null ? getPrincipal().toString() : \"empty\";\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.authc;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.pam.AggregateAccount;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.HashSet;\n\n/**\n * Simple implementation of the {@link org.jsecurity.authc.Account} interface that\n * contains principal and credential information as instance variables and exposes them\n * via getters and setters using standard JavaBean notation.\n *\n * <p>Realm implementations can use this for simple principal/credential accounts, but note:  \n *\n * <p>This class cannot perform its own authorization checks for roles and permissions.  It is therefore not sufficient\n * to use to back a Realm's {@link org.jsecurity.authz.Authorizer Authorizer} method implementations.  If you need\n * an Account object to perform role and permission checks itself, you might want to use instaces of\n * {@link org.jsecurity.authz.SimpleAuthorizingAccount SimpleAuthorizingAccount} instead of this class.\n *\n * <p>But note that a <tt>SimpleAuthorizingAccount<\/tt> object caches its roles and permission definitions and will not\n * persist any changes to these definitions back to the source Realm.  If you need dynamic runtime modification of Roles\n * and/or Permissions for any given account, your Realm implementation will need to perform the authorization checks\n * directly since instances of this class are primarily used for caching and could represent stale data.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @see org.jsecurity.authz.SimpleAuthorizingAccount\n * @since 0.1\n */\npublic class SimpleAccount implements AggregateAccount, Serializable {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    protected transient final Log logger = LogFactory.getLog( getClass() );\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /** The principal that apply to the authenticated Subject/user. */\n    private Object principal = null;\n\n    /** Credentials that were used to authenticate the user. */\n    private Object credentials = null;\n\n    /** True if the account is locked, false otherwise. */\n    private boolean locked = false;\n\n    /** True if the user's credentials are expired, false otherwise. */\n    private boolean credentialsExpired = false;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public SimpleAccount() {\n    }\n\n    public SimpleAccount(Object principal, Object credentials) {\n        this(principal, credentials, false, false);\n    }\n\n    public SimpleAccount(Object principal, Object credentials, boolean locked, boolean credentialsExpired) {\n        this.principal = principal;\n        this.credentials = credentials;\n        this.locked = locked;\n        this.credentialsExpired = credentialsExpired;\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    public Object getPrincipal() {\n        return this.principal;\n    }\n\n    public void setPrincipal(Object principal) {\n        this.principal = principal;\n    }\n\n    public Object getCredentials() {\n        return credentials;\n    }\n\n    public void setCredentials(Object credentials) {\n        this.credentials = credentials;\n    }\n\n    public boolean isLocked() {\n        return locked;\n    }\n\n    public void setLocked(boolean locked) {\n        this.locked = locked;\n    }\n\n    public boolean isCredentialsExpired() {\n        return credentialsExpired;\n    }\n\n    public void setCredentialsExpired(boolean credentialsExpired) {\n        this.credentialsExpired = credentialsExpired;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Merges the specified argument into this instance.\n     *\n     * @param otherAccount the otherAccount to merge into this instance.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public void merge(Account otherAccount) {\n        if (otherAccount == null) {\n            return;\n        }\n\n        Object otherPrincipal = otherAccount.getPrincipal();\n        if (otherPrincipal == null) {\n            return;\n        }\n\n        Object thisPrincipal = getPrincipal();\n        if (thisPrincipal == null) {\n            this.principal = otherPrincipal;\n        } else {\n            HashSet set = new HashSet();\n            if (thisPrincipal instanceof Collection) {\n                set.addAll((Collection)thisPrincipal);\n            } else {\n                set.add( thisPrincipal );\n            }\n            if (otherPrincipal instanceof Collection) {\n                set.addAll((Collection)otherPrincipal);\n            } else {\n                set.add(otherPrincipal);\n            }\n            this.principal = set;\n        }\n\n\n        if (this.credentials == null) {\n            setCredentials(otherAccount.getCredentials());\n        }\n\n        if (otherAccount.isLocked()) {\n            setLocked(true);\n        }\n\n        if (otherAccount.isCredentialsExpired()) {\n            setCredentialsExpired(true);\n        }\n    }\n\n    public int hashCode() {\n        return ( getPrincipal() != null ? getPrincipal().hashCode() : 0 );\n    }\n\n    public boolean equals( Object o ) {\n        if ( o == this ) {\n            return true;\n        }\n        if ( o instanceof SimpleAccount ) {\n            SimpleAccount sa = (SimpleAccount)o;\n            //principal should be unique across the application, so only check this for equality:\n            return ( getPrincipal() != null ? getPrincipal().equals( sa.getPrincipal() ) : sa.getPrincipal() == null );\n        }\n        return false;\n    }\n\n    public String toString() {\n        return getPrincipal() != null ? getPrincipal().toString() : \"empty\";\n    }\n}\n","lineNo":184}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.authc;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.HashSet;\n\n/**\n * Simple implementation of the {@link org.jsecurity.authc.Account} interface that\n * contains principal and credential information as instance variables and exposes them\n * via getters and setters using standard JavaBean notation.\n *\n * <p>Realm implementations can use this for simple principal/credential accounts, but note:\n *\n * <p>This class cannot perform its own authorization checks for roles and permissions.  It is therefore not sufficient\n * to use to back a Realm's {@link org.jsecurity.authz.Authorizer Authorizer} method implementations.  If you need\n * an Account object to perform role and permission checks itself, you might want to use instaces of\n * {@link org.jsecurity.authz.SimpleAuthorizingAccount SimpleAuthorizingAccount} instead of this class.\n *\n * <p>But note that a <tt>SimpleAuthorizingAccount<\/tt> object caches its roles and permission definitions and will not\n * persist any changes to these definitions back to the source Realm.  If you need dynamic runtime modification of Roles\n * and/or Permissions for any given account, your Realm implementation will need to perform the authorization checks\n * directly since instances of this class are primarily used for caching and could represent stale data.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @see org.jsecurity.authz.SimpleAuthorizingAccount\n * @since 0.1\n */\npublic class SimpleAccount implements Account, Serializable {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    protected transient final Log logger = LogFactory.getLog(getClass());\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The principal that apply to the authenticated Subject/user.\n     */\n    private Object principal = null;\n\n    /**\n     * Credentials that were used to authenticate the user.\n     */\n    private Object credentials = null;\n\n    /**\n     * True if the account is locked, false otherwise.\n     */\n    private boolean locked = false;\n\n    /**\n     * True if the user's credentials are expired, false otherwise.\n     */\n    private boolean credentialsExpired = false;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public SimpleAccount() {\n    }\n\n    public SimpleAccount(Object principal, Object credentials) {\n        this(principal, credentials, false, false);\n    }\n\n    public SimpleAccount(Object principal, Object credentials, boolean locked, boolean credentialsExpired) {\n        this.principal = principal;\n        this.credentials = credentials;\n        this.locked = locked;\n        this.credentialsExpired = credentialsExpired;\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    public Object getPrincipal() {\n        return this.principal;\n    }\n\n    public void setPrincipal(Object principal) {\n        this.principal = principal;\n    }\n\n    public Object getCredentials() {\n        return credentials;\n    }\n\n    public void setCredentials(Object credentials) {\n        this.credentials = credentials;\n    }\n\n    public boolean isLocked() {\n        return locked;\n    }\n\n    public void setLocked(boolean locked) {\n        this.locked = locked;\n    }\n\n    public boolean isCredentialsExpired() {\n        return credentialsExpired;\n    }\n\n    public void setCredentialsExpired(boolean credentialsExpired) {\n        this.credentialsExpired = credentialsExpired;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Merges (adds) the specified Account data into this instance.\n     *\n     * This allows an instance of this class to be an <em>aggregation<\/em>, or <em>composition<\/em> of account data\n     * from across multiple <code>Realm<\/code>s <tt>Realm<\/tt>s, not just one realm.\n     *\n     * <p>This is useful in a multi-realm authentication configuration - the individual <tt>Account<\/tt>\n     * objects obtained from each realm can be {@link #merge merged} into this object.  This single object can then be\n     * returned at the end of the authentication process, giving the impression of a single underlying\n     * realm/data source.\n     *\n     * @param otherAccount the account whos data will be merged (added) into this instance.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public void merge(Account otherAccount) {\n        if (otherAccount == null) {\n            return;\n        }\n\n        Object otherPrincipal = otherAccount.getPrincipal();\n        if (otherPrincipal == null) {\n            return;\n        }\n\n        Object thisPrincipal = getPrincipal();\n        if (thisPrincipal == null) {\n            this.principal = otherPrincipal;\n        } else {\n            HashSet set = new HashSet();\n            if (thisPrincipal instanceof Collection) {\n                set.addAll((Collection) thisPrincipal);\n            } else {\n                set.add(thisPrincipal);\n            }\n            if (otherPrincipal instanceof Collection) {\n                set.addAll((Collection) otherPrincipal);\n            } else {\n                set.add(otherPrincipal);\n            }\n            this.principal = set;\n        }\n\n        Object otherCredentials = otherAccount.getCredentials();\n        Object thisCredentials = getCredentials();\n        if ( thisCredentials == null ) {\n            this.credentials = otherCredentials;\n        } else {\n            HashSet set = new HashSet();\n            if (thisCredentials instanceof Collection) {\n                set.addAll((Collection) thisCredentials);\n            } else {\n                set.add(thisCredentials);\n            }\n            if (otherCredentials instanceof Collection) {\n                set.addAll((Collection) otherCredentials);\n            } else {\n                set.add(otherCredentials);\n            }\n            this.credentials = set;\n        }\n\n        if (otherAccount.isLocked()) {\n            setLocked(true);\n        }\n\n        if (otherAccount.isCredentialsExpired()) {\n            setCredentialsExpired(true);\n        }\n    }\n\n    public int hashCode() {\n        return (getPrincipal() != null ? getPrincipal().hashCode() : 0);\n    }\n\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimpleAccount) {\n            SimpleAccount sa = (SimpleAccount) o;\n            //principal should be unique across the application, so only check this for equality:\n            return (getPrincipal() != null ? getPrincipal().equals(sa.getPrincipal()) : sa.getPrincipal() == null);\n        }\n        return false;\n    }\n\n    public String toString() {\n        return getPrincipal() != null ? getPrincipal().toString() : \"empty\";\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.authc;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.pam.AggregateAccount;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.HashSet;\n\n/**\n * Simple implementation of the {@link org.jsecurity.authc.Account} interface that\n * contains principal and credential information as instance variables and exposes them\n * via getters and setters using standard JavaBean notation.\n *\n * <p>Realm implementations can use this for simple principal/credential accounts, but note:  \n *\n * <p>This class cannot perform its own authorization checks for roles and permissions.  It is therefore not sufficient\n * to use to back a Realm's {@link org.jsecurity.authz.Authorizer Authorizer} method implementations.  If you need\n * an Account object to perform role and permission checks itself, you might want to use instaces of\n * {@link org.jsecurity.authz.SimpleAuthorizingAccount SimpleAuthorizingAccount} instead of this class.\n *\n * <p>But note that a <tt>SimpleAuthorizingAccount<\/tt> object caches its roles and permission definitions and will not\n * persist any changes to these definitions back to the source Realm.  If you need dynamic runtime modification of Roles\n * and/or Permissions for any given account, your Realm implementation will need to perform the authorization checks\n * directly since instances of this class are primarily used for caching and could represent stale data.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @see org.jsecurity.authz.SimpleAuthorizingAccount\n * @since 0.1\n */\npublic class SimpleAccount implements AggregateAccount, Serializable {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    protected transient final Log logger = LogFactory.getLog( getClass() );\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /** The principal that apply to the authenticated Subject/user. */\n    private Object principal = null;\n\n    /** Credentials that were used to authenticate the user. */\n    private Object credentials = null;\n\n    /** True if the account is locked, false otherwise. */\n    private boolean locked = false;\n\n    /** True if the user's credentials are expired, false otherwise. */\n    private boolean credentialsExpired = false;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public SimpleAccount() {\n    }\n\n    public SimpleAccount(Object principal, Object credentials) {\n        this(principal, credentials, false, false);\n    }\n\n    public SimpleAccount(Object principal, Object credentials, boolean locked, boolean credentialsExpired) {\n        this.principal = principal;\n        this.credentials = credentials;\n        this.locked = locked;\n        this.credentialsExpired = credentialsExpired;\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    public Object getPrincipal() {\n        return this.principal;\n    }\n\n    public void setPrincipal(Object principal) {\n        this.principal = principal;\n    }\n\n    public Object getCredentials() {\n        return credentials;\n    }\n\n    public void setCredentials(Object credentials) {\n        this.credentials = credentials;\n    }\n\n    public boolean isLocked() {\n        return locked;\n    }\n\n    public void setLocked(boolean locked) {\n        this.locked = locked;\n    }\n\n    public boolean isCredentialsExpired() {\n        return credentialsExpired;\n    }\n\n    public void setCredentialsExpired(boolean credentialsExpired) {\n        this.credentialsExpired = credentialsExpired;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Merges the specified argument into this instance.\n     *\n     * @param otherAccount the otherAccount to merge into this instance.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public void merge(Account otherAccount) {\n        if (otherAccount == null) {\n            return;\n        }\n\n        Object otherPrincipal = otherAccount.getPrincipal();\n        if (otherPrincipal == null) {\n            return;\n        }\n\n        Object thisPrincipal = getPrincipal();\n        if (thisPrincipal == null) {\n            this.principal = otherPrincipal;\n        } else {\n            HashSet set = new HashSet();\n            if (thisPrincipal instanceof Collection) {\n                set.addAll((Collection)thisPrincipal);\n            } else {\n                set.add( thisPrincipal );\n            }\n            if (otherPrincipal instanceof Collection) {\n                set.addAll((Collection)otherPrincipal);\n            } else {\n                set.add(otherPrincipal);\n            }\n            this.principal = set;\n        }\n\n\n        if (this.credentials == null) {\n            setCredentials(otherAccount.getCredentials());\n        }\n\n        if (otherAccount.isLocked()) {\n            setLocked(true);\n        }\n\n        if (otherAccount.isCredentialsExpired()) {\n            setCredentialsExpired(true);\n        }\n    }\n\n    public int hashCode() {\n        return ( getPrincipal() != null ? getPrincipal().hashCode() : 0 );\n    }\n\n    public boolean equals( Object o ) {\n        if ( o == this ) {\n            return true;\n        }\n        if ( o instanceof SimpleAccount ) {\n            SimpleAccount sa = (SimpleAccount)o;\n            //principal should be unique across the application, so only check this for equality:\n            return ( getPrincipal() != null ? getPrincipal().equals( sa.getPrincipal() ) : sa.getPrincipal() == null );\n        }\n        return false;\n    }\n\n    public String toString() {\n        return getPrincipal() != null ? getPrincipal().toString() : \"empty\";\n    }\n}\n","lineNo":185}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2008 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.util.LifecycleUtils;\n\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * JSecurity support of a {@link SecurityManager} class hierarchy that delegates all\n * authorization (access control) operations to a wrapped {@link Authorizer Authorizer} instance.  That is,\n * this class implements all the <tt>Authorizer<\/tt> methods in the {@link SecurityManager SecurityManager}\n * interface, but in reality, those methods are merely passthrough calls to the underlying 'real'\n * <tt>Authorizer<\/tt> instance.\n *\n * <p>All remaining <tt>SecurityManager<\/tt> methods not covered by this class or its parents (mostly Session support)\n * are left to be implemented by subclasses.\n *\n * <p>In keeping with the other classes in this hierarchy and JSecurity's desire to minimize configuration whenever\n * possible, suitable default instances for all dependencies will be created upon {@link #init() initialization} if\n * they have not been provided.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AuthorizingSecurityManager extends AuthenticatingSecurityManager implements PermissionResolverAware {\n\n    /**\n     * The wrapped instance to which all of this <tt>SecurityManager<\/tt> authorization calls are delegated.\n     */\n    protected Authorizer authorizer = null;\n\n    /**\n     * The <tt>PermissionResolver<\/tt> instance to pass to the wrapped <tt>Authorizer<\/tt> instance during init.\n     */\n    protected PermissionResolver permissionResolver = null;\n\n    /**\n     * Default no-arg constructor - used in IoC environments or when the programmer wishes to explicitly call\n     * {@link #init()} after the necessary properties have been set.\n     */\n    public AuthorizingSecurityManager() {\n    }\n\n    /**\n     * Supporting constructor for a single-realm application (automatically calls {@link #init()} before returning).\n     *\n     * @param singleRealm the single realm used by this SecurityManager.\n     */\n    public AuthorizingSecurityManager(Realm singleRealm) {\n        super(singleRealm);\n    }\n\n    /**\n     * Supporting constructor that sets the {@link #setRealms realms} property and then automatically calls {@link #init()}.\n     *\n     * @param realms the realm instances backing this SecurityManager.\n     */\n    public AuthorizingSecurityManager(Collection<Realm> realms) {\n        super(realms);\n    }\n\n    /**\n     * Returns the underlying wrapped <tt>Authorizer<\/tt> instance to which this <tt>SecurityManager<\/tt>\n     * implementation delegates all of its authorization calls.\n     *\n     * @return the wrapped <tt>Authorizer<\/tt> used by this <tt>SecurityManager<\/tt> implementation.\n     */\n    public Authorizer getAuthorizer() {\n        return authorizer;\n    }\n\n    /**\n     * Sets the underlying <tt>Authorizer<\/tt> instance to which this <tt>SecurityManager<\/tt> implementation will\n     * delegate all of its authorization calls.\n     *\n     * <p>If you don't set this attribute, a suitable default instance will be created for you during\n     * {@link #init initialization}.\n     *\n     * @param authorizer the <tt>Authorizer<\/tt> this <tt>SecurityManager<\/tt> should wrap and delegate all of its\n     *                   authorization calls to.\n     */\n    public void setAuthorizer(Authorizer authorizer) {\n        this.authorizer = authorizer;\n    }\n\n    /**\n     * Returns the <tt>PermissionResolver<\/tt> instance that will be passed on to the underlying wrapped\n     * {@link Authorizer Authorizer} instance during {@link #init() initialization}.\n     *\n     * <p>See the {@link #setPermissionResolver setPermissionResolver} method for more detail.\n     *\n     * @return the <tt>PermissionResolver<\/tt> instance that will be passed on to the underlying wrapped\n     *         {@link Authorizer Authorizer} instance during {@link #init() initialization}.\n     * @see #setPermissionResolver setPermissionResolver\n     */\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    /**\n     * Sets the <tt>PermissionResolver<\/tt> instance that will be passed on to the underlying default wrapped\n     * {@link Authorizer Authorizer} instance during {@link #init() initialization}.\n     *\n     * <p>This is a convenience method:  it allows you to configure an application-wide\n     * <tt>PermissionResolver<\/tt> on the <tt>SecurityManager<\/tt> instance, and it will trickle its way down to the\n     * 'real' authorizer and/or underlying Realms.  This is easier to configure at the <tt>SecurityManager<\/tt> level\n     * than constructing your own object graph just to configure a <tt>PermissionResolver<\/tt> instance on objects\n     * deep in the graph.\n     *\n     * @param permissionResolver the <tt>PermissionResolver<\/tt> instance to set on the wrapped <tt>Authorizer<\/tt> if\n     *                           and only if that Authorizer instance also implements the <tt>PermissionResolverAware<\/tt> interface.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n\n    /**\n     * Creates a new <tt>Authorizer<\/tt> to use as the wrapped instance for this <tt>SecurityManager<\/tt>\n     * implementation.\n     *\n     * @return the new <tt>Authorizer<\/tt> to use as the wrapped instance for this <tt>SecurityManager<\/tt> implementation.\n     */\n    protected Authorizer createAuthorizer() {\n        ModularRealmAuthorizer mra = new ModularRealmAuthorizer();\n        mra.setRealms(getRealms());\n        if ( getPermissionResolver() != null ) {\n            mra.setPermissionResolver( getPermissionResolver() );\n        }\n        mra.init();\n        return mra;\n    }\n\n    /**\n     * Called during the init process, this method ensures that an underlying wrapped <tt>Authorizer<\/tt> instance will\n     * exist to support all of this <tt>SecurityManager<\/tt>'s delegate authorization calls.  If one does not exist,\n     * a default will be created via the {@link #createAuthorizer createAuthorizer()} method which will then be set as\n     * an attribute of this class.\n     */\n    protected void ensureAuthorizer() {\n        Authorizer authorizer = getAuthorizer();\n        if ( authorizer == null) {\n            authorizer = createAuthorizer();\n            setAuthorizer(authorizer);\n        }\n    }\n\n    /**\n     * Implementation of parent class's template hook for initialization logic.  This implementation\n     * {@link #ensureAuthorizer ensures} an <tt>Authorizer<\/tt> exists and is fully initialized and then calls\n     * {@link #afterAuthorizerSet() afterAuthorizerSet()} for further subclass initialization logic.\n     */\n    protected void afterAuthenticatorSet() {\n        ensureAuthorizer();\n        afterAuthorizerSet();\n    }\n\n    /**\n     * Template hook for subclasses to implement initialization logic.  This will be called after an\n     * <tt>Authorizer<\/tt> instance is guaranteed to have been set and initialized on this <tt>SecurityManager<\/tt>\n     * instance.\n     */\n    protected void afterAuthorizerSet() {\n    }\n\n    /**\n     * Template hook for subclasses to implement destruction/cleanup logic.  This will be called before this\n     * instance's <tt>Authorizer<\/tt> instance will be cleaned up.\n     */\n    protected void beforeAuthorizerDestroyed() {\n    }\n\n    /**\n     * Cleanup method that destroys/cleans up the wrapped {@link #getAuthorizer Authorizer} instance.\n     */\n    protected void destroyAuthorizer() {\n        LifecycleUtils.destroy(getAuthorizer());\n        this.authorizer = null;\n    }\n\n    /**\n     * Implementation of parent class's template hook for destruction/cleanup logic.\n     *\n     * <p>This implementation ensures subclasses are cleaned up first by calling\n     * {@link #beforeAuthorizerDestroyed() beforeAuthorizerDestroyed()} and then actually cleans up the\n     * wrapped <tt>Authorizer<\/tt> via the {@link #destroyAuthorizer() desroyAuthorizer()} method.\n     */\n    protected void beforeAuthenticatorDestroyed() {\n        beforeAuthorizerDestroyed();\n        destroyAuthorizer();\n    }\n\n    /**\n     * Utility method that ensures a delegate {@link #getAuthorizer() Authorizer} instance exists as an attribute of\n     * this class.  If it does not, an IllegalStateException will be thrown because that indicates this\n     * <tt>SecurityManager<\/tt> instance was not properly {@link #init() initialized}.\n     *\n     * @return the delegate <tt>Authorizer<\/tt> instance used by this <tt>SecurityManager<\/tt>\n     * @throws IllegalStateException if for some reason the <tt>Authorizer<\/tt> instance is <tt>null<\/tt>, indicating\n     *                               this <tt>SecurityManager<\/tt> instance was not properly {@link #init() initialized}.\n     */\n    protected Authorizer getRequiredAuthorizer() throws IllegalStateException {\n        Authorizer authz = getAuthorizer();\n        if (authz == null) {\n            String msg = \"No authorizer attribute configured for this SecurityManager instance.  Please ensure \" +\n                    \"the init() method is called prior to using this instance and a default one will be created.\";\n            throw new IllegalStateException(msg);\n        }\n        return authz;\n    }\n\n\n    public boolean isPermitted(Object subjectIdentifier, String permissionString) {\n        return getRequiredAuthorizer().isPermitted(subjectIdentifier, permissionString);\n    }\n\n    public boolean isPermitted(Object subjectIdentifier, Permission permission) {\n        return getRequiredAuthorizer().isPermitted(subjectIdentifier, permission);\n    }\n\n    public boolean[] isPermitted(Object subjectIdentifier, String... permissions) {\n        return getRequiredAuthorizer().isPermitted(subjectIdentifier, permissions);\n    }\n\n    public boolean[] isPermitted(Object subjectIdentifier, List<Permission> permissions) {\n        return getRequiredAuthorizer().isPermitted(subjectIdentifier, permissions);\n    }\n\n    public boolean isPermittedAll(Object subjectIdentifier, String... permissions) {\n        return getRequiredAuthorizer().isPermittedAll(subjectIdentifier, permissions);\n    }\n\n    public boolean isPermittedAll(Object subjectIdentifier, Collection<Permission> permissions) {\n        return getRequiredAuthorizer().isPermittedAll(subjectIdentifier, permissions);\n    }\n\n    public void checkPermission(Object subjectIdentifier, String permission) throws AuthorizationException {\n        getRequiredAuthorizer().checkPermission(subjectIdentifier, permission);\n    }\n\n    public void checkPermission(Object subjectIdentifier, Permission permission) throws AuthorizationException {\n        getRequiredAuthorizer().checkPermission(subjectIdentifier, permission);\n    }\n\n    public void checkPermissions(Object subjectIdentifier, String... permissions) throws AuthorizationException {\n        getRequiredAuthorizer().checkPermissions(subjectIdentifier, permissions);\n    }\n\n    public void checkPermissions(Object subjectIdentifier, Collection<Permission> permissions) throws AuthorizationException {\n        getRequiredAuthorizer().checkPermissions(subjectIdentifier, permissions);\n    }\n\n    public boolean hasRole(Object subjectIdentifier, String roleIdentifier) {\n        return getRequiredAuthorizer().hasRole(subjectIdentifier, roleIdentifier);\n    }\n\n    public boolean[] hasRoles(Object subjectIdentifier, List<String> roleIdentifiers) {\n        return getRequiredAuthorizer().hasRoles(subjectIdentifier, roleIdentifiers);\n    }\n\n    public boolean hasAllRoles(Object subjectIdentifier, Collection<String> roleIdentifiers) {\n        return getRequiredAuthorizer().hasAllRoles(subjectIdentifier, roleIdentifiers);\n    }\n\n    public void checkRole(Object subjectIdentifier, String role) throws AuthorizationException {\n        getRequiredAuthorizer().checkRole(subjectIdentifier, role);\n    }\n\n    public void checkRoles(Object subjectIdentifier, Collection<String> roles) throws AuthorizationException {\n        getRequiredAuthorizer().checkRoles(subjectIdentifier, roles);\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2008 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.util.LifecycleUtils;\n\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * JSecurity support of a {@link SecurityManager} class hierarchy that delegates all\n * authorization (access control) operations to a wrapped {@link Authorizer Authorizer} instance.  That is,\n * this class implements all the <tt>Authorizer<\/tt> methods in the {@link SecurityManager SecurityManager}\n * interface, but in reality, those methods are merely passthrough calls to the underlying 'real'\n * <tt>Authorizer<\/tt> instance.\n *\n * <p>All remaining <tt>SecurityManager<\/tt> methods not covered by this class or its parents (mostly Session support)\n * are left to be implemented by subclasses.\n *\n * <p>In keeping with the other classes in this hierarchy and JSecurity's desire to minimize configuration whenever\n * possible, suitable default instances for all dependencies will be created upon {@link #init() initialization} if\n * they have not been provided.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AuthorizingSecurityManager extends AuthenticatingSecurityManager implements PermissionResolverAware {\n\n    /**\n     * The wrapped instance to which all of this <tt>SecurityManager<\/tt> authorization calls are delegated.\n     */\n    protected Authorizer authorizer = null;\n\n    /**\n     * The <tt>PermissionResolver<\/tt> instance to pass to the wrapped <tt>Authorizer<\/tt> instance during init.\n     */\n    protected PermissionResolver permissionResolver = null;\n\n    /**\n     * Default no-arg constructor - used in IoC environments or when the programmer wishes to explicitly call\n     * {@link #init()} after the necessary properties have been set.\n     */\n    public AuthorizingSecurityManager() {\n    }\n\n    /**\n     * Supporting constructor for a single-realm application (automatically calls {@link #init()} before returning).\n     *\n     * @param singleRealm the single realm used by this SecurityManager.\n     */\n    public AuthorizingSecurityManager(Realm singleRealm) {\n        super(singleRealm);\n    }\n\n    /**\n     * Supporting constructor that sets the {@link #setRealms realms} property and then automatically calls {@link #init()}.\n     *\n     * @param realms the realm instances backing this SecurityManager.\n     */\n    public AuthorizingSecurityManager(Collection<Realm> realms) {\n        super(realms);\n    }\n\n    /**\n     * Returns the underlying wrapped <tt>Authorizer<\/tt> instance to which this <tt>SecurityManager<\/tt>\n     * implementation delegates all of its authorization calls.\n     *\n     * @return the wrapped <tt>Authorizer<\/tt> used by this <tt>SecurityManager<\/tt> implementation.\n     */\n    public Authorizer getAuthorizer() {\n        return authorizer;\n    }\n\n    /**\n     * Sets the underlying <tt>Authorizer<\/tt> instance to which this <tt>SecurityManager<\/tt> implementation will\n     * delegate all of its authorization calls.\n     *\n     * <p>If you don't set this attribute, a suitable default instance will be created for you during\n     * {@link #init initialization}.\n     *\n     * @param authorizer the <tt>Authorizer<\/tt> this <tt>SecurityManager<\/tt> should wrap and delegate all of its\n     *                   authorization calls to.\n     */\n    public void setAuthorizer(Authorizer authorizer) {\n        this.authorizer = authorizer;\n    }\n\n    /**\n     * Returns the <tt>PermissionResolver<\/tt> instance that will be passed on to the underlying wrapped\n     * {@link Authorizer Authorizer} instance during {@link #init() initialization}.\n     *\n     * <p>See the {@link #setPermissionResolver setPermissionResolver} method for more detail.\n     *\n     * @return the <tt>PermissionResolver<\/tt> instance that will be passed on to the underlying wrapped\n     *         {@link Authorizer Authorizer} instance during {@link #init() initialization}.\n     * @see #setPermissionResolver setPermissionResolver\n     */\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    /**\n     * Sets the <tt>PermissionResolver<\/tt> instance that will be passed on to the underlying default wrapped\n     * {@link Authorizer Authorizer} instance during {@link #init() initialization}.\n     *\n     * <p>This is a convenience method:  it allows you to configure an application-wide\n     * <tt>PermissionResolver<\/tt> on the <tt>SecurityManager<\/tt> instance, and it will trickle its way down to the\n     * 'real' authorizer and/or underlying Realms.  This is easier to configure at the <tt>SecurityManager<\/tt> level\n     * than constructing your own object graph just to configure a <tt>PermissionResolver<\/tt> instance on objects\n     * deep in the graph.\n     *\n     * @param permissionResolver the <tt>PermissionResolver<\/tt> instance to set on the wrapped <tt>Authorizer<\/tt> if\n     *                           and only if that Authorizer instance also implements the <tt>PermissionResolverAware<\/tt> interface.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n\n    /**\n     * Creates a new <tt>Authorizer<\/tt> to use as the wrapped instance for this <tt>SecurityManager<\/tt>\n     * implementation.\n     *\n     * @return the new <tt>Authorizer<\/tt> to use as the wrapped instance for this <tt>SecurityManager<\/tt> implementation.\n     */\n    protected Authorizer createAuthorizer() {\n        ModularRealmAuthorizer mra = new ModularRealmAuthorizer();\n        mra.setRealms(getRealms());\n        if ( getPermissionResolver() != null ) {\n            mra.setPermissionResolver( getPermissionResolver() );\n        }\n        mra.init();\n        return mra;\n    }\n\n    /**\n     * Called during the init process, this method ensures that an underlying wrapped <tt>Authorizer<\/tt> instance will\n     * exist to support all of this <tt>SecurityManager<\/tt>'s delegate authorization calls.  If one does not exist,\n     * a default will be created via the {@link #createAuthorizer createAuthorizer()} method which will then be set as\n     * an attribute of this class.\n     */\n    protected void ensureAuthorizer() {\n        if (getAuthorizer() == null) {\n            Authorizer authz = createAuthorizer();\n            setAuthorizer(authz);\n        }\n    }\n\n    /**\n     * Implementation of parent class's template hook for initialization logic.  This implementation\n     * {@link #ensureAuthorizer ensures} an <tt>Authorizer<\/tt> exists and is fully initialized and then calls\n     * {@link #afterAuthorizerSet() afterAuthorizerSet()} for further subclass initialization logic.\n     */\n    protected void afterAuthenticatorSet() {\n        ensureAuthorizer();\n        afterAuthorizerSet();\n    }\n\n    /**\n     * Template hook for subclasses to implement initialization logic.  This will be called after an\n     * <tt>Authorizer<\/tt> instance is guaranteed to have been set and initialized on this <tt>SecurityManager<\/tt>\n     * instance.\n     */\n    protected void afterAuthorizerSet() {\n    }\n\n    /**\n     * Template hook for subclasses to implement destruction/cleanup logic.  This will be called before this\n     * instance's <tt>Authorizer<\/tt> instance will be cleaned up.\n     */\n    protected void beforeAuthorizerDestroyed() {\n    }\n\n    /**\n     * Cleanup method that destroys/cleans up the wrapped {@link #getAuthorizer Authorizer} instance.\n     */\n    protected void destroyAuthorizer() {\n        LifecycleUtils.destroy(getAuthorizer());\n        this.authorizer = null;\n    }\n\n    /**\n     * Implementation of parent class's template hook for destruction/cleanup logic.\n     *\n     * <p>This implementation ensures subclasses are cleaned up first by calling\n     * {@link #beforeAuthorizerDestroyed() beforeAuthorizerDestroyed()} and then actually cleans up the\n     * wrapped <tt>Authorizer<\/tt> via the {@link #destroyAuthorizer() desroyAuthorizer()} method.\n     */\n    protected void beforeAuthenticatorDestroyed() {\n        beforeAuthorizerDestroyed();\n        destroyAuthorizer();\n    }\n\n    /**\n     * Utility method that ensures a delegate {@link #getAuthorizer() Authorizer} instance exists as an attribute of\n     * this class.  If it does not, an IllegalStateException will be thrown because that indicates this\n     * <tt>SecurityManager<\/tt> instance was not properly {@link #init() initialized}.\n     *\n     * @return the delegate <tt>Authorizer<\/tt> instance used by this <tt>SecurityManager<\/tt>\n     * @throws IllegalStateException if for some reason the <tt>Authorizer<\/tt> instance is <tt>null<\/tt>, indicating\n     *                               this <tt>SecurityManager<\/tt> instance was not properly {@link #init() initialized}.\n     */\n    protected Authorizer getRequiredAuthorizer() throws IllegalStateException {\n        Authorizer authz = getAuthorizer();\n        if (authz == null) {\n            String msg = \"No authorizer attribute configured for this SecurityManager instance.  Please ensure \" +\n                    \"the init() method is called prior to using this instance and a default one will be created.\";\n            throw new IllegalStateException(msg);\n        }\n        return authz;\n    }\n\n\n    public boolean isPermitted(Object subjectIdentifier, String permissionString) {\n        return getRequiredAuthorizer().isPermitted(subjectIdentifier, permissionString);\n    }\n\n    public boolean isPermitted(Object subjectIdentifier, Permission permission) {\n        return getRequiredAuthorizer().isPermitted(subjectIdentifier, permission);\n    }\n\n    public boolean[] isPermitted(Object subjectIdentifier, String... permissions) {\n        return getRequiredAuthorizer().isPermitted(subjectIdentifier, permissions);\n    }\n\n    public boolean[] isPermitted(Object subjectIdentifier, List<Permission> permissions) {\n        return getRequiredAuthorizer().isPermitted(subjectIdentifier, permissions);\n    }\n\n    public boolean isPermittedAll(Object subjectIdentifier, String... permissions) {\n        return getRequiredAuthorizer().isPermittedAll(subjectIdentifier, permissions);\n    }\n\n    public boolean isPermittedAll(Object subjectIdentifier, Collection<Permission> permissions) {\n        return getRequiredAuthorizer().isPermittedAll(subjectIdentifier, permissions);\n    }\n\n    public void checkPermission(Object subjectIdentifier, String permission) throws AuthorizationException {\n        getRequiredAuthorizer().checkPermission(subjectIdentifier, permission);\n    }\n\n    public void checkPermission(Object subjectIdentifier, Permission permission) throws AuthorizationException {\n        getRequiredAuthorizer().checkPermission(subjectIdentifier, permission);\n    }\n\n    public void checkPermissions(Object subjectIdentifier, String... permissions) throws AuthorizationException {\n        getRequiredAuthorizer().checkPermissions(subjectIdentifier, permissions);\n    }\n\n    public void checkPermissions(Object subjectIdentifier, Collection<Permission> permissions) throws AuthorizationException {\n        getRequiredAuthorizer().checkPermissions(subjectIdentifier, permissions);\n    }\n\n    public boolean hasRole(Object subjectIdentifier, String roleIdentifier) {\n        return getRequiredAuthorizer().hasRole(subjectIdentifier, roleIdentifier);\n    }\n\n    public boolean[] hasRoles(Object subjectIdentifier, List<String> roleIdentifiers) {\n        return getRequiredAuthorizer().hasRoles(subjectIdentifier, roleIdentifiers);\n    }\n\n    public boolean hasAllRoles(Object subjectIdentifier, Collection<String> roleIdentifiers) {\n        return getRequiredAuthorizer().hasAllRoles(subjectIdentifier, roleIdentifiers);\n    }\n\n    public void checkRole(Object subjectIdentifier, String role) throws AuthorizationException {\n        getRequiredAuthorizer().checkRole(subjectIdentifier, role);\n    }\n\n    public void checkRoles(Object subjectIdentifier, Collection<String> roles) throws AuthorizationException {\n        getRequiredAuthorizer().checkRoles(subjectIdentifier, roles);\n    }\n}\n","lineNo":171}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2008 Allan Ditzel, Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.web.filter;\n\nimport org.jsecurity.JSecurityException;\nimport org.jsecurity.util.AntPathMatcher;\nimport static org.jsecurity.util.StringUtils.split;\nimport org.jsecurity.web.RedirectView;\nimport org.jsecurity.web.SecurityWebSupport;\nimport org.jsecurity.web.WebUtils;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * <p>Base class for all web interceptors. This class is an adapter for the WebInterceptor interface.<\/p>\n *\n * @author Allan Ditzel\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AbstractWebInterceptor extends SecurityWebSupport implements MatchingWebInterceptor {\n\n    protected AntPathMatcher pathMatcher = new AntPathMatcher();\n    /**\n     * A collection of path-to-config entries where the key is the path and the value is the\n     * interceptor-specific configuration element.\n     */\n    protected Map<String,Object> appliedPaths = new LinkedHashMap<String,Object>(); //path to interceptor-specific-config mapping.\n\n    private String url;\n    private boolean contextRelative = true;\n\tprivate boolean http10Compatible = true;\n\tprivate String encodingScheme = RedirectView.DEFAULT_ENCODING_SCHEME;\n    private Map queryParams = new HashMap();\n\n    public AbstractWebInterceptor(){}\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public boolean isContextRelative() {\n        return contextRelative;\n    }\n\n    public void setContextRelative(boolean contextRelative) {\n        this.contextRelative = contextRelative;\n    }\n\n    public boolean isHttp10Compatible() {\n        return http10Compatible;\n    }\n\n    public void setHttp10Compatible(boolean http10Compatible) {\n        this.http10Compatible = http10Compatible;\n    }\n\n    public String getEncodingScheme() {\n        return encodingScheme;\n    }\n\n    public void setEncodingScheme(String encodingScheme) {\n        this.encodingScheme = encodingScheme;\n    }\n\n    public Map getQueryParams() {\n        return queryParams;\n    }\n\n    public void setQueryParams(Map queryParams) {\n        this.queryParams = queryParams;\n    }\n\n    /**\n     * Default implementation\n     *\n     * @throws JSecurityException\n     */\n    public void init() throws JSecurityException {\n    }\n\n    protected void issueRedirect(ServletRequest request, ServletResponse response ) throws IOException {\n        RedirectView view = new RedirectView( getUrl(), isContextRelative(), isHttp10Compatible() );\n        view.renderMergedOutputModel(getQueryParams(), toHttp(request), toHttp(response) );\n    }\n\n    public void processPathConfig(String path, String config) {\n        String[] values = null;\n        if ( config != null ) {\n            values = split(config);\n        }\n\n        this.appliedPaths.put(path,values);\n    }\n\n    /**\n     * Default implemenation of this method. Always returns true. Sub-classes should override this method.\n     *\n     * @param request\n     * @param response\n     * @return true - allow the request chain to continue in this default implementation\n     * @throws Exception\n     */\n    public boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {\n\n        if (this.appliedPaths != null && !this.appliedPaths.isEmpty()) {\n\n            String requestURI = WebUtils.getPathWithinApplication(toHttp(request));\n\n            // If URL path isn't matched, we allow the request to go through so default to true\n            boolean continueChain = true;\n            for (String path : this.appliedPaths.keySet()) {\n\n                // If the path does match, then pass on to the subclass implementation for specific checks:\n                if (pathMatcher.match(path, requestURI)) {\n                    if ( log.isTraceEnabled() ) {\n                        log.trace( \"matched path [\" + path + \"] for requestURI [\" + requestURI + \"].  \" +\n                                \"Performing onPreHandle check...\" );\n                    }\n                    Object config = this.appliedPaths.get(path);\n                    continueChain = onPreHandle( request, response, config );\n                }\n\n                if ( !continueChain ) {\n                    //it is expected the subclass renders the response directly, so just return false\n                    return false;\n                }\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"appliedPaths property is null or empty.  This interceptor will passthrough immediately.\" );\n            }\n        }\n\n        return true;\n    }\n\n    protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue ) throws Exception {\n        return true;\n    }\n\n    /**\n     * Default implementation of this method. Sub-classes should override this method.\n     *\n     * @param request\n     * @param response\n     * @throws Exception\n     */\n    public void postHandle(ServletRequest request, ServletResponse response) throws Exception {\n    }\n\n    /**\n     * Default implementation of this method. Sub-classes should override this method.\n     *\n     * @param request\n     * @param response\n     * @param exception\n     * @throws Exception\n     */\n    public void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception {\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2008 Allan Ditzel, Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.web.filter;\n\nimport org.jsecurity.JSecurityException;\nimport org.jsecurity.util.AntPathMatcher;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.web.RedirectView;\nimport org.jsecurity.web.SecurityWebSupport;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.IOException;\nimport java.util.*;\n\n/**\n * <p>Base class for all web interceptors. This class is an adapter for the WebInterceptor interface.<\/p>\n *\n * @author Allan Ditzel\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AbstractWebInterceptor extends SecurityWebSupport implements WebInterceptor {\n\n    protected AntPathMatcher pathMatcher = new AntPathMatcher();\n\n    private String url;\n    private boolean contextRelative = true;\n\tprivate boolean http10Compatible = true;\n\tprivate String encodingScheme = RedirectView.DEFAULT_ENCODING_SCHEME;\n    private Map queryParams = new HashMap();\n\n    public AbstractWebInterceptor(){}\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public boolean isContextRelative() {\n        return contextRelative;\n    }\n\n    public void setContextRelative(boolean contextRelative) {\n        this.contextRelative = contextRelative;\n    }\n\n    public boolean isHttp10Compatible() {\n        return http10Compatible;\n    }\n\n    public void setHttp10Compatible(boolean http10Compatible) {\n        this.http10Compatible = http10Compatible;\n    }\n\n    public String getEncodingScheme() {\n        return encodingScheme;\n    }\n\n    public void setEncodingScheme(String encodingScheme) {\n        this.encodingScheme = encodingScheme;\n    }\n\n    public Map getQueryParams() {\n        return queryParams;\n    }\n\n    public void setQueryParams(Map queryParams) {\n        this.queryParams = queryParams;\n    }\n\n    /**\n     * Sets the URLs that this interceptor should filter.\n     *\n     * <p>The map is a url (key) to interceptor-specific config string (value) entries.  Subclasses are expected to\n     * process the config strings (map values) for the corresponding urls (keys).\n     *\n     * <p>It is expected that the implementation will ignore all requests to urls <em>not<\/em> matched by those in\n     * this map.\n     *\n     * @param urlToConfigMap\n     */\n    public void setAppliedUrls(Map<String, String> urlToConfigMap) {\n        this.appliedUrls = urlToConfigMap;\n    }\n\n    /**\n     * Default implementation\n     *\n     * @throws JSecurityException\n     */\n    public void init() throws JSecurityException {\n    }\n\n    protected void issueRedirect(ServletRequest request, ServletResponse response ) throws IOException {\n        RedirectView view = new RedirectView( getUrl(), isContextRelative(), isHttp10Compatible() );\n        view.renderMergedOutputModel(getQueryParams(), toHttp(request), toHttp(response) );\n    }\n\n    /**\n     * A collection of url-to-config entries where the key is the url and the value is the\n     * interceptor-specific configuration elements.  The subclass is expected to\n     */\n    protected Map<String, ?> appliedUrls = null; //url to interceptor-specific-config mapping.\n\n\n    protected Map<String, Set<String>> tokenizeValues(Map<String,String> urlValueMap) {\n\n        Map<String,Set<String>> converted = new LinkedHashMap<String,Set<String>>(this.appliedUrls.size());\n\n        for( Map.Entry<String,String> entry : urlValueMap.entrySet() ) {\n            String url = entry.getKey();\n            String interceptorConfig = entry.getValue();\n            if ( interceptorConfig != null ) {\n                String[] configTokens = StringUtils.split(interceptorConfig);\n                Set<String> configTokensSet = new LinkedHashSet<String>( Arrays.asList(configTokens) );\n                converted.put(url,configTokensSet);\n            }\n        }\n\n        if (!converted.isEmpty()) {\n            return converted;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Default implemenation of this method. Always returns true. Sub-classes should override this method.\n     *\n     * @param request\n     * @param response\n     * @return true - allow the request chain to continue in this default implementation\n     * @throws Exception\n     */\n    public boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {\n\n        if (this.appliedUrls != null && !this.appliedUrls.isEmpty()) {\n\n            String requestURI = toHttp(request).getRequestURI();\n            \n            //TODO Need to strip off context path here.  See Spring's UrlPathHelper.getPathWithinApplication()\n\n            // If URL path isn't matched, we allow the request to go through so default to true\n            boolean continueChain = true;\n            for (String url : this.appliedUrls.keySet()) {\n\n                // If the path does match, then pass on to the subclass implementation for specific checks:\n                if (pathMatcher.match(url, requestURI)) {\n                    continueChain = onPreHandle( request, response, this.appliedUrls.get(url) );\n                }\n\n                if ( !continueChain ) {\n                    //it is expected the subclass renders the response directly, so just return false\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue ) throws Exception {\n        return true;\n    }\n\n    /**\n     * Default implementation of this method. Sub-classes should override this method.\n     *\n     * @param request\n     * @param response\n     * @throws Exception\n     */\n    public void postHandle(ServletRequest request, ServletResponse response) throws Exception {\n    }\n\n    /**\n     * Default implementation of this method. Sub-classes should override this method.\n     *\n     * @param request\n     * @param response\n     * @param exception\n     * @throws Exception\n     */\n    public void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception {\n    }\n}\n","lineNo":152}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2008 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.cache.CacheProvider;\nimport org.jsecurity.cache.CacheProviderAware;\nimport org.jsecurity.cache.HashtableCacheProvider;\nimport org.jsecurity.cache.ehcache.EhCacheProvider;\nimport org.jsecurity.util.Destroyable;\nimport org.jsecurity.util.Initializable;\nimport org.jsecurity.util.JavaEnvironment;\nimport org.jsecurity.util.LifecycleUtils;\n\n/**\n * A very basic extension point for the SecurityManager interface that merely provides logging and caching\n * support.  All <tt>SecurityManager<\/tt> method implementations are left to subclasses.\n *\n * <p>Upon {@link #init() initialization}, a sensible default <tt>CacheProvider<\/tt> will be created automatically\n * if one has not been provided.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class CachingSecurityManager implements SecurityManager, Initializable, Destroyable, CacheProviderAware {\n\n    protected transient final Log log = LogFactory.getLog(getClass());\n\n    protected CacheProvider cacheProvider;\n\n    /**\n     * Default no-arg constructor - used in IoC environments or when the programmer wishes to explicitly call\n     * {@link #init()} after first setting necessary attributes.\n     */\n    public CachingSecurityManager() {\n    }\n\n    /**\n     * Returns the default CacheProvider used by this SecurityManager.\n     *\n     * @return the cacheProvider used by this SecurityManager\n     */\n    public CacheProvider getCacheProvider() {\n        return cacheProvider;\n    }\n\n    public void setCacheProvider(CacheProvider cacheProvider) {\n        this.cacheProvider = cacheProvider;\n    }\n\n    public void init() {\n        ensureCacheProvider();\n        afterCacheProviderSet();\n    }\n\n    protected void ensureCacheProvider() {\n        CacheProvider cacheProvider = getCacheProvider();\n        if (cacheProvider == null) {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No CacheProvider has been configured.  Attempting to create a default one...\" );\n            }\n            CacheProvider provider = createCacheProvider();\n            setCacheProvider(provider);\n        } else {\n            if ( log.isInfoEnabled() ) {\n                log.info( \"Using configured CacheProvider [\" + cacheProvider + \"]\" );\n            }\n        }\n    }\n\n    protected CacheProvider createCacheProvider() {\n        CacheProvider provider;\n\n        if (JavaEnvironment.isEhcacheAvailable()) {\n            if (log.isDebugEnabled()) {\n                String msg = \"Initializing default CacheProvider using EhCache.\";\n                log.debug(msg);\n            }\n            EhCacheProvider ehCacheProvider = new EhCacheProvider();\n            ehCacheProvider.init();\n            provider = ehCacheProvider;\n        } else {\n            if (log.isWarnEnabled()) {\n                String msg = \"Ehcache was not found in the classpath.  Reverting to failsafe CacheProvider which will \" +\n                        \"create in-memory HashTable caches.  This is NOT RECOMMENDED for production environments.  \" +\n                        \"Please ensure ehcache.jar is in the classpath and JSecurity will automatically use a \" +\n                        \"production-quality CacheProvider implementation, or you may alternatively provide your \" +\n                        \"own via the \" + getClass().getName() + \"#setCacheProvider method.\";\n                log.warn(msg);\n            }\n            provider = new HashtableCacheProvider();\n        }\n\n        return provider;\n    }\n\n    protected void afterCacheProviderSet(){}\n\n    public void destroy() {\n        beforeCacheProviderDestroyed();\n        destroyCacheProvider();\n    }\n\n    protected void beforeCacheProviderDestroyed(){}    \n\n    protected void destroyCacheProvider() {\n        LifecycleUtils.destroy( getCacheProvider() );\n        this.cacheProvider = null;\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2008 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.cache.CacheProvider;\nimport org.jsecurity.cache.CacheProviderAware;\nimport org.jsecurity.cache.HashtableCacheProvider;\nimport org.jsecurity.cache.ehcache.EhCacheProvider;\nimport org.jsecurity.util.Destroyable;\nimport org.jsecurity.util.Initializable;\nimport org.jsecurity.util.JavaEnvironment;\nimport org.jsecurity.util.LifecycleUtils;\n\n/**\n *\n * A very basic extension point for the SecurityManager interface that merely provides logging and caching \n * support.  All <tt>SecurityManager<\/tt> method implementations are left to subclasses.\n *\n * <p>Upon {@link #init() initialization}, a sensible default <tt>CacheProvider<\/tt> will be created automatically\n * if one has not been provided.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class CachingSecurityManager implements SecurityManager, Initializable, Destroyable, CacheProviderAware {\n\n    protected transient final Log log = LogFactory.getLog(getClass());\n\n    protected CacheProvider cacheProvider;\n\n    /**\n     * Default no-arg constructor - used in IoC environments or when the programmer wishes to explicitly call\n     * {@link #init()} after the necessary properties have been set.\n     */\n    public CachingSecurityManager() {\n    }\n\n    /**\n     * Returns the default CacheProvider used by this SecurityManager.\n     *\n     * @return the cacheProvider used by this SecurityManager\n     */\n    public CacheProvider getCacheProvider() {\n        return cacheProvider;\n    }\n\n    public void setCacheProvider(CacheProvider cacheProvider) {\n        this.cacheProvider = cacheProvider;\n    }\n\n    public void init() {\n        ensureCacheProvider();\n        afterCacheProviderSet();\n    }\n\n    protected void ensureCacheProvider() {\n        if (getCacheProvider() == null) {\n            CacheProvider provider = createCacheProvider();\n            setCacheProvider(provider);\n        }\n    }\n\n    protected CacheProvider createCacheProvider() {\n        CacheProvider provider;\n\n        if (JavaEnvironment.isEhcacheAvailable()) {\n            if (log.isDebugEnabled()) {\n                String msg = \"Initializing default CacheProvider using EhCache.\";\n                log.debug(msg);\n            }\n            EhCacheProvider ehCacheProvider = new EhCacheProvider();\n            ehCacheProvider.init();\n            provider = ehCacheProvider;\n        } else {\n            if (log.isWarnEnabled()) {\n                String msg = \"Instantiating default CacheProvider which will create in-memory HashTable caches.  \" +\n                    \"This is NOT RECOMMENDED for production environments.  Please ensure ehcache.jar is in the \" +\n                    \"classpath and JSecurity will automatically use a production-quality CacheProvider \" +\n                    \"implementation, or you may alternatively provide your own via the #setCacheProvider method.\";\n                log.warn(msg);\n            }\n            provider = new HashtableCacheProvider();\n        }\n\n        return provider;\n    }\n\n    protected void afterCacheProviderSet(){}\n\n    public void destroy() {\n        beforeCacheProviderDestroyed();\n        destroyCacheProvider();\n    }\n\n    protected void beforeCacheProviderDestroyed(){}    \n\n    protected void destroyCacheProvider() {\n        LifecycleUtils.destroy( getCacheProvider() );\n        this.cacheProvider = null;\n    }\n}\n","lineNo":80}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2008 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.authc.credential;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.jsecurity.crypto.hash.AbstractHash;\nimport org.jsecurity.crypto.hash.Hash;\n\n/**\n * A <tt>HashedCredentialMatcher<\/tt> provides support for hashing of supplied <tt>AuthenticationToken<\/tt> credentials\n * before being compared to those in the <tt>Account<\/tt> from the data store.\n *\n * <p>Credential hashing is one of the most common security techniques when safeguarding a user's private credentials\n * (passwords, keys, etc).  Most developers never want to store their users' credentials in plain form, viewable by\n * anyone, so they often hash the users' credentials before they are saved in the data store.<\/p>\n *\n * <p>This class (and its subclasses) function as follows:<\/p>\n *\n * <p>It first hashes the <tt>AuthenticationToken<\/tt> credentials supplied by the user during their login.  It then\n * compares this hashed value directly with the <tt>Account<\/tt> credentials stored in the system.  The stored account\n * credentials are expected to already be in hashed form.  If these two values are equal, the submitted credentials\n * match.<\/p>\n *\n * <h3>Salting and Multiple Hash Iterations<\/h3>\n *\n * <p>Because simple hashing is sometimes not good enough for many applications, this class also supports 'salting'\n * and multiple hash iterations.  Please read this excellent\n * <a href=\"http://www.owasp.org/index.php/Hashing_Java\" _target=\"blank\">Hashing Java article<\/a> to learn about\n * salting and multiple iterations and why you might want to use them. (Note of sections 5\n * &quot;Why add salt?&quot; and 6 \"Hardening against the attacker's attack\").\n *\n * <p>We should also note here that all of JSecurity's Hash implementations (for example,\n * {@link org.jsecurity.crypto.hash.Md5Hash Md5Hash}, {@link org.jsecurity.crypto.hash.Sha1Hash Sha1Hash}, etc)\n * support salting and multiple hash iterations via overloaded constructors.<\/p>\n *\n * <h4>Salting<\/h4>\n *\n * <p>Salting of the authentication token's credentials hash is disabled by default, but you may enable it by setting\n * {@link #setHashSalted hashSalted} to\n * <tt>true<\/tt>.  If you do enable it, the value used to salt the hash will be\n * obtained from {@link #getSalt(AuthenticationToken) getSalt(authenticationToken)}.\n *\n * <p>The default <tt>getSalt<\/tt> implementation merely returns\n * <code>token.getPrincipal()<\/code>, effectively using the user's identity as the salt, a most common\n * technique.  If you wish to provide the authentication token's salt another way, you may override this\n * <tt>getSalt<\/tt> method.\n *\n * <h4>Multiple Hash Iterations<\/h4>\n *\n * <p>If you hash your users' credentials multiple times before persisting to the data store, you will also need to\n * set this class's {@link #setHashIterations(int) hashIterations} property.<\/p>\n *\n * @see org.jsecurity.crypto.hash.Md5Hash\n * @see org.jsecurity.crypto.hash.Sha1Hash\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class HashedCredentialsMatcher extends SimpleCredentialsMatcher {\n\n    private boolean storedCredentialsHexEncoded = true; //false means base64 encoded\n    private boolean hashSalted = false;\n    private int hashIterations = 1;\n\n    /**\n     * Returns <tt>true<\/tt> if the system's stored credential hash is Hex encoded, <tt>false<\/tt> if it\n     * is Base64 encoded.\n     *\n     * <p>Default value is <tt>true<\/tt> for convenience - all of JSecurity's {@link Hash Hash#toString()}\n     * implementations return Hex encoded values by default, making this class's use with those implementations \n     * easier.<\/p>\n     *\n     * @return <tt>true<\/tt> if the system's stored credential hash is Hex encoded, <tt>false<\/tt> if it\n     *         is Base64 encoded.  Default is <tt>true<\/tt>\n     */\n    public boolean isStoredCredentialsHexEncoded() {\n        return storedCredentialsHexEncoded;\n    }\n\n    /**\n     * Sets the indicator if this system's stored credential hash is Hex encoded or not.\n     *\n     * <p>A value of <tt>true<\/tt> will cause this class to decode the system credential from Hex, a\n     * value of <tt>false<\/tt> will cause this class to decode the system credential from Base64.<\/p>\n     *\n     * <p>Unless overridden via this method, the default value is <tt>true<\/tt> for convenience - all of JSecurity's\n     * {@link Hash Hash#toString()} implementations return Hex encoded values by default, making this class's use with\n     * those implementations easier.<\/p>.\n     *\n     * @param storedCredentialsHexEncoded the indicator if this system's stored credential hash is Hex\n     *                                    encoded or not ('not' automatically implying it is Base64 encoded).\n     */\n    public void setStoredCredentialsHexEncoded(boolean storedCredentialsHexEncoded) {\n        this.storedCredentialsHexEncoded = storedCredentialsHexEncoded;\n    }\n\n    /**\n     * Returns <tt>true<\/tt> if a submitted <tt>AuthenticationToken<\/tt>'s credentials should be salted when hashing,\n     * <tt>false<\/tt> if it should not be salted.\n     *\n     * <p>If enabled, the salt used will be obtained via the {@link #getSalt(AuthenticationToken) getSalt} method.\n     *\n     * <p>The default value is <tt>false<\/tt>.\n     *\n     * @return <tt>true<\/tt> if a submitted <tt>AuthenticationToken<\/tt>'s credentials should be salted when hashing,\n     * <tt>false<\/tt> if it should not be salted.\n     */\n    public boolean isHashSalted() {\n        return hashSalted;\n    }\n\n    /**\n     * Sets whether or not to salt a submitted <tt>AuthenticationToken<\/tt>'s credentials when hashing.\n     *\n     * <p>If enabled, the salt used will be obtained via the {@link #getSalt(AuthenticationToken) getSalt} method.\n     *\n     * <p>The default value is <tt>false<\/tt>.\n     *\n     * @param hashSalted whether or not to salt a submitted <tt>AuthenticationToken<\/tt>'s credentials when hashing.\n     */\n    public void setHashSalted(boolean hashSalted) {\n        this.hashSalted = hashSalted;\n    }\n\n    /**\n     * Returns the number of times a submitted <tt>AuthenticationToken<\/tt>'s credentials will be hashed before\n     * comparing to the credentials stored in the system.\n     *\n     * <p>Unless overridden, the default value is <tt>1<\/tt>, meaning a normal hash execution will occur.\n     *\n     * @return the number of times a submitted <tt>AuthenticationToken<\/tt>'s credentials will be hashed before\n     * comparing to the credentials stored in the system.\n     */\n    public int getHashIterations() {\n        return hashIterations;\n    }\n\n    /**\n     * Sets the number of times a submitted <tt>AuthenticationToken<\/tt>'s credentials will be hashed before comparing\n     * to the credentials stored in the system.\n     *\n     * <p>Unless overridden, the default value is <tt>1<\/tt>, meaning a normal single hash execution will occur.\n     *\n     * <p>If this argument is less than 1 (i.e. 0 or negative), the default value of 1 is applied.  There must always be\n     * at least 1 hash iteration (otherwise there would be no hash).\n     *\n     * @param hashIterations the number of times to hash a submitted <tt>AuthenticationToken<\/tt>'s credentials.\n     */\n    public void setHashIterations(int hashIterations) {\n        if ( hashIterations < 1 ) {\n            this.hashIterations = 1;\n        } else {\n            this.hashIterations = hashIterations;\n        }\n    }\n\n    /**\n     * Returns a salt value used to hash the token's credentials.\n     *\n     * <p>This default implementation merely returns <code>token.getPrincipal()<\/code>, effectively using the user's\n     * identity (username, user id, etc) as the salt, a most common technique.  If you wish to provide the\n     * authentication token's salt another way, you may override this method.\n     * @param token the AuthenticationToken submitted during the authentication attempt.\n     * @return a salt value to use to hash the authentication token's credentials.\n     */\n    protected Object getSalt( AuthenticationToken token ) {\n        return token.getPrincipal();\n    }\n\n    /**\n     * As this is a HashedCredentialMatcher, this method overrides the parent method by returning a hashed value\n     * of the submitted token's credentials.\n     *\n     * <p>Based on this class's configuration, the return value may be salted and/or\n     * hashed multiple times (see the class-level JavaDoc for more information on salting and\n     * multiple hash iterations).\n     *\n     * @param token the authentication token submitted during the authentication attempt.\n     * @return the hashed value of the authentication token's credentials.\n     */\n    protected Object getCredentials(AuthenticationToken token) {\n        Object credentials = token.getCredentials();\n        Object salt = isHashSalted() ? getSalt( token ) : null;\n        return hashProvidedCredentials(credentials, salt, getHashIterations() );\n    }\n\n    /**\n     * Returns a {@link Hash Hash} instance representing the already-hashed Account credentials stored in the system.\n     *\n     * <p>This method reconstructs a {@link Hash Hash} instance based on a <code>account.getCredentials<\/code> call,\n     * but it does <em>not<\/em> hash that value - it is expected that method call will return an already-hashed value.\n     *\n     * <p>This implementation's reconstruction effort functions as follows:\n     *\n     * <ul>\n     * <li>If <code>account.getCredentials()<\/code> is a byte array, just set that byte array directly on\n     * the <tt>Hash<\/tt> implementation and return it.<\/li>\n     * <li>If <code>account.getCredentials()<\/code> is a String or char[], convert it to a byte array via the\n     * {@link #toBytes toBytes} method, and then check for encoding:\n     * <ol><li>If {@link #storedCredentialsHexEncoded storedCredentialsHexEncoded}, Hex decode that byte array, otherwise\n     *         Base64 decode the byte array<\/li>\n     *     <li>Set the decoded bytes directly on the <tt>Hash<\/tt> implementation and return it.<\/li><\/ol>\n     * <\/li>\n     * <\/ul>\n     *\n     * @param account the Account from which to retrive the credentials which assumed to be in already-hashed form.\n     * @return a {@link Hash Hash} instance representing the given Account's stored credentials.\n     */\n    protected Object getCredentials(Account account) {\n        Object credentials = account.getCredentials();\n\n        byte[] storedBytes = toBytes(credentials);\n\n        if ( credentials instanceof String || credentials instanceof char[] ) {\n            //account.credentials were a char[] or String, so\n            //we need to do text decoding first:\n            if (isStoredCredentialsHexEncoded()) {\n                storedBytes = Hex.decode( storedBytes );\n            } else {\n                storedBytes = Base64.decodeBase64( storedBytes );\n            }\n        }\n        AbstractHash hash = newHashInstance();\n        hash.setBytes( storedBytes );\n        return hash;\n    }\n\n    /**\n     * Hashes the provided credentials a total of <tt>hashIterations<\/tt> times, using the given salt.  The hash\n     * implementation/algorithm used is left to subclasses.\n     *\n     * @param credentials the submitted authentication token's credentials to hash\n     * @param salt the value to salt the hash, or <tt>null<\/tt> if a salt will not be used.\n     * @param hashIterations the number of times to hash the credentials.  At least one hash will always occur though,\n     * even if this argument is 0 or negative.\n     * @return the hashed value of the provided credentials, according to the specified salt and hash iterations.\n     */\n    protected abstract Hash hashProvidedCredentials(Object credentials, Object salt, int hashIterations );\n\n    /**\n     * Returns a new, <em>uninitialized<\/em> instance, without its byte array set.  Used as a utility method in the\n     * {@link #getCredentials(Account) getCredentials(Account)} implementation.\n     *\n     * @return a new, <em>uninitialized<\/em> instance, without its byte array set.\n     */\n    protected abstract AbstractHash newHashInstance();\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2008 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.authc.credential;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.jsecurity.crypto.hash.AbstractHash;\nimport org.jsecurity.crypto.hash.Hash;\n\n/**\n * A <tt>HashedCredentialMatcher<\/tt> provides support for hashing of supplied <tt>AuthenticationToken<\/tt> credentials\n * before being compared to those in the <tt>Account<\/tt> from the data store.\n *\n * <p>Credential hashing is one of the most common security techniques when safeguarding a user's private credentials\n * (passwords, keys, etc).  Most developers never want to store their users' credentials in plain form, viewable by\n * anyone, so they often hash the users' credentials before they are saved in the data store.<\/p>\n *\n * <p>This class (and its subclasses) function as follows:<\/p>\n *\n * <p>It first hashes the <tt>AuthenticationToken<\/tt> credentials supplied by the user during their login.  It then\n * compares this hashed value directly with the <tt>Account<\/tt> credentials stored in the system.  The stored account\n * credentials are expected to already be in hashed form.  If these two values are equal, the submitted credentials\n * match.<\/p>\n *\n * <h3>Salting and Multiple Hash Iterations<\/h3>\n *\n * <p>Because simple hashing is sometimes not good enough for many applications, this class also supports 'salting'\n * and multiple hash iterations.  Please read this excellent\n * <a href=\"http://www.owasp.org/index.php/Hashing_Java\" _target=\"blank\">Hashing Java article<\/a> to learn about\n * salting and multiple iterations and why you might want to use them. (Note of sections 5\n * &quot;Why add salt?&quot; and 6 \"Hardening against the attacker's attack\").\n *\n * <p>We should also note here that all of JSecurity's Hash implementations (for example,\n * {@link org.jsecurity.crypto.hash.Md5Hash Md5Hash}, {@link org.jsecurity.crypto.hash.ShaHash ShaHash}, etc)\n * support salting and multiple hash iterations via overloaded constructors.<\/p>\n *\n * <h4>Salting<\/h4>\n *\n * <p>Salting of the authentication token's credentials hash is disabled by default, but you may enable it by setting\n * {@link #setHashSalted hashSalted} to\n * <tt>true<\/tt>.  If you do enable it, the value used to salt the hash will be\n * obtained from {@link #getSalt(AuthenticationToken) getSalt(authenticationToken}.\n *\n * <p>The default <tt>getSalt<\/tt> implementation merely returns\n * <code>token.getPrincipal()<\/code>, effectively using the user's identity as the salt, a most common technique.  If\n * you wish to provide the authentication token's salt another way, you may override this <tt>getSalt<\/tt> method.\n *\n * <h4>Multiple Hash Iterations<\/h4>\n *\n * <p>If you hash your users' credentials multiple times before persisting to the data store, you will also need to\n * set this class's {@link #setHashIterations(int) hashIterations} property.<\/p>\n *\n * @see org.jsecurity.crypto.hash.Md5Hash\n * @see org.jsecurity.crypto.hash.ShaHash\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class HashedCredentialsMatcher extends SimpleCredentialsMatcher {\n\n    private boolean storedCredentialsHexEncoded = true; //false means base64 encoded\n    private boolean hashSalted = false;\n    private int hashIterations = 1;\n\n    /**\n     * Returns <tt>true<\/tt> if the system's stored credential hash is Hex encoded, <tt>false<\/tt> if it\n     * is Base64 encoded.\n     *\n     * <p>Default value is <tt>true<\/tt> for convenience - all of JSecurity's {@link Hash Hash#toString()}\n     * implementations return Hex encoded values by default, making this class's use with those implementations \n     * easier.<\/p>\n     *\n     * @return <tt>true<\/tt> if the system's stored credential hash is Hex encoded, <tt>false<\/tt> if it\n     *         is Base64 encoded.  Default is <tt>true<\/tt>\n     */\n    public boolean isStoredCredentialsHexEncoded() {\n        return storedCredentialsHexEncoded;\n    }\n\n    /**\n     * Sets the indicator if this system's stored credential hash is Hex encoded or not.\n     *\n     * <p>A value of <tt>true<\/tt> will cause this class to decode the system credential from Hex, a\n     * value of <tt>false<\/tt> will cause this class to decode the system credential from Base64.<\/p>\n     *\n     * <p>Unless overridden via this method, the default value is <tt>true<\/tt> for convenience - all of JSecurity's\n     * {@link Hash Hash#toString()} implementations return Hex encoded values by default, making this class's use with\n     * those implementations easier.<\/p>.\n     *\n     * @param storedCredentialsHexEncoded the indicator if this system's stored credential hash is Hex\n     *                                    encoded or not ('not' automatically implying it is Base64 encoded).\n     */\n    public void setStoredCredentialsHexEncoded(boolean storedCredentialsHexEncoded) {\n        this.storedCredentialsHexEncoded = storedCredentialsHexEncoded;\n    }\n\n    /**\n     * Returns <tt>true<\/tt> if a submitted <tt>AuthenticationToken<\/tt>'s credentials should be salted when hashing,\n     * <tt>false<\/tt> if it should not be salted.\n     *\n     * <p>If enabled, the salt used will be obtained via the {@link #getSalt(AuthenticationToken) getSalt} method.\n     *\n     * @return <tt>true<\/tt> if a submitted <tt>AuthenticationToken<\/tt>'s credentials should be salted when hashing,\n     * <tt>false<\/tt> if it should not be salted.\n     */\n    public boolean isHashSalted() {\n        return hashSalted;\n    }\n\n    /**\n     * Sets whether or not to salt a submitted <tt>AuthenticationToken<\/tt>'s credentials when hashing.\n     * \n     * <p>If enabled, the salt used will be obtained via the {@link #getSalt(AuthenticationToken) getSalt} method.\n     *\n     * @param hashSalted whether or not to salt a submitted <tt>AuthenticationToken<\/tt>'s credentials when hashing.\n     */\n    public void setHashSalted(boolean hashSalted) {\n        this.hashSalted = hashSalted;\n    }\n\n    /**\n     * Returns the number of times a submitted <tt>AuthenticationToken<\/tt>'s credentials will be hashed before\n     * comparing to the credentials stored in the system.\n     *\n     * <p>Unless overridden, the default value is <tt>1<\/tt>, meaning a normal hash execution will occur.\n     *\n     * @return the number of times a submitted <tt>AuthenticationToken<\/tt>'s credentials will be hashed before\n     * comparing to the credentials stored in the system.\n     */\n    public int getHashIterations() {\n        return hashIterations;\n    }\n\n    /**\n     * Sets the number of times a submitted <tt>AuthenticationToken<\/tt>'s credentials will be hashed before comparing\n     * to the credentials stored in the system.\n     *\n     * <p>Unless overridden, the default value is <tt>1<\/tt>, meaning a normal single hash execution will occur.\n     *\n     * <p>If this argument is less than 1 (i.e. 0 or negative), the default value of 1 is applied.  There must always be\n     * at least 1 hash iteration (otherwise there would be no hash).\n     *\n     * @param hashIterations the number of times to hash a submitted <tt>AuthenticationToken<\/tt>'s credentials.\n     */\n    public void setHashIterations(int hashIterations) {\n        if ( hashIterations < 1 ) {\n            this.hashIterations = 1;\n        } else {\n            this.hashIterations = hashIterations;\n        }\n    }\n\n    /**\n     * Returns a salt value used to hash the token's credentials.\n     *\n     * <p>This default implementation merely returns <code>token.getPrincipal()<\/code>, effectively using the user's\n     * identity (username, user id, etc) as the salt, a most common technique.  If you wish to provide the\n     * authentication token's salt another way, you may override this method.\n     * @param token the AuthenticationToken submitted during the authentication attempt.\n     * @return a salt value to use to hash the authentication token's credentials.\n     */\n    protected Object getSalt( AuthenticationToken token ) {\n        return token.getPrincipal();\n    }\n\n    /**\n     * As this is a HashedCredentialMatcher, this method overrides the parent by returning a hashed value\n     * of the submitted token's credentials.  Based on this class's configuration, the return value may be salted and/or\n     * hashed multiple times (see the class-level JavaDoc for more information on salting and\n     * multiple hash iterations).\n     *\n     * @param token the authentication token submitted during the authentication attempt.\n     * @return the hashed value of the authentication token's credentials.\n     */\n    protected Object getCredentials(AuthenticationToken token) {\n        Object salt = isHashSalted() ? getSalt( token ) : null;\n        return getProvidedCredentialsHash(token.getCredentials(), salt, getHashIterations() );\n    }\n\n    /**\n     * Returns a {@link Hash Hash} instance representing the already-hashed Account credentials stored in the system.\n     *\n     * <p>This method reconstructs a {@link Hash Hash} instance based on a <code>account.getCredentials<\/code> call,\n     * but it does <em>not<\/em> hash that value - it is expected that method call will return an already-hashed value.\n     *\n     * <p>This implementation's reconstruction effort functions as follows:\n     *\n     * <ul>\n     * <li>If <code>account.getCredentials()<\/code> is a byte array, just set that byte array directly on\n     * the <tt>Hash<\/tt> implementation and return it.<\/li>\n     * <li>If <code>account.getCredentials()<\/code> is <em>not<\/em> a byte array, convert it to a byte array via the\n     * {@link #toBytes toBytes} method, and then check for encoding:\n     * <ol><li>If {@link #storedCredentialsHexEncoded storedCredentialsHexEncoded}, Hex decode that byte array, otherwise\n     *         Base64 decode the byte array<\/li>\n     *     <li>Set the decoded bytes directly on the <tt>Hash<\/tt> implementation and return it.<\/li><\/ol>\n     * <\/li>\n     * <\/ul>\n     *\n     * @param account the Account from which to retrive the credentials which assumed to be in already-hashed form.\n     * @return a {@link Hash Hash} instance representing the given Account's stored credentials.\n     */\n    protected Object getCredentials(Account account) {\n        Object credentials = account.getCredentials();\n\n        //assume stored credential is already hashed:\n        AbstractHash hash = newHashInstance();\n\n        //apply stored credentials to this Hash instance\n        byte[] storedBytes = toBytes(credentials);\n\n        if (!(credentials instanceof byte[])) {\n            //method argument came in as a char[] or String, so\n            //we need to do text decoding first:\n            if (isStoredCredentialsHexEncoded()) {\n                storedBytes = Hex.decode( storedBytes );\n            } else {\n                storedBytes = Base64.decodeBase64( storedBytes );\n            }\n        }\n        hash.setBytes( storedBytes );\n        return hash;\n    }\n\n    /**\n     * Hashes the provided credentials a total of <tt>hashIterations<\/tt> times, using the given salt.  The hash\n     * implementation/algorithm used is left to subclasses.\n     *\n     * @param credential the submitted authentication token's credentials to hash\n     * @param salt the value to salt the hash, or <tt>null<\/tt> if a salt will not be used.\n     * @param hashIterations the number of times to hash the credentials.  At least one hash will always occur though,\n     * even if this argument is 0 or negative.\n     * @return the hashed value of the provided credentials, according to the specified salt and hash iterations.\n     */\n    protected abstract Hash getProvidedCredentialsHash(Object credential, Object salt, int hashIterations );\n\n    /**\n     * Returns a new, <em>uninitialized<\/em> instance, without its byte array set.  Used as a utility method in the\n     * {@link #getCredentials(Account) getCredentials(Account)} implementation.\n     *\n     * @return a new, <em>uninitialized<\/em> instance, without its byte array set.\n     */\n    protected abstract AbstractHash newHashInstance();\n\n}\n","lineNo":207}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2008 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.web.WebInterceptor;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.IOException;\n\n/**\n * A <tt>WebInterceptorFilter<\/tt> is a Servlet Filter that merely delegates all filter operations to a single internally\n * wrapped {@link org.jsecurity.web.WebInterceptor} instance.  It is a simple utility class to cleanly use a\n * <tt>WebInterceptor<\/tt> as a servlet filter if so desired - the benefit is that you only have to code one\n * WebInterceptor class, and you can re-use it in multiple environments such as in a servlet container,\n * in Spring or Pico, JBoss, etc.  This Filter represents the mechanism to use that one WebInterceptor directly in a\n * Servlet environment.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class WebInterceptorFilter extends SecurityManagerFilter {\n\n    protected WebInterceptor webInterceptor;\n\n    public WebInterceptor getWebInterceptor() {\n        return this.webInterceptor;\n    }\n\n    public void setWebInterceptor(WebInterceptor webInterceptor) {\n        this.webInterceptor = webInterceptor;\n    }\n\n    public void afterSecurityManagerSet() {\n        WebInterceptor interceptor = getWebInterceptor();\n        if (interceptor == null) {\n            throw new IllegalStateException(\"WebInterceptor property must be set.\");\n        }\n        afterWebInterceptorSet();\n    }\n\n    protected void afterWebInterceptorSet() {\n    }\n\n    protected void continueChain(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        chain.doFilter(request, response);\n        if (log.isTraceEnabled()) {\n            log.trace(\"Completed chain execution.\");\n        }\n    }\n\n    protected void doFilterInternal(\n            ServletRequest request, ServletResponse response, FilterChain chain)\n            throws ServletException, IOException {\n\n        Exception exception = null;\n\n        WebInterceptor interceptor = getWebInterceptor();\n\n        try {\n\n            boolean continueChain = interceptor.preHandle(request, response);\n            if (log.isTraceEnabled()) {\n                log.trace(\"Invked interceptor.preHandle method.  Continuing chain?: [\" + continueChain + \"]\");\n            }\n\n            if (continueChain) {\n                continueChain(request, response, chain);\n            }\n\n            interceptor.postHandle(request, response);\n            if (log.isTraceEnabled()) {\n                log.trace(\"Successfully invoked interceptor.postHandle method\");\n            }\n\n        } catch (Exception e) {\n            exception = e;\n        } finally {\n            try {\n                interceptor.afterCompletion(request, response, exception);\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Successfully invoked interceptor.afterCompletion method.\");\n                }\n            } catch (Exception e) {\n                if (exception == null) {\n                    exception = e;\n                }\n            }\n            if (exception != null) {\n                if (exception instanceof ServletException) {\n                    throw (ServletException) exception;\n                } else if (exception instanceof IOException) {\n                    throw (IOException) exception;\n                } else {\n                    String msg = \"Filter execution resulted in a Exception \" +\n                            \"(not IOException or ServletException as the Filter api recommends).  \" +\n                            \"Wrapping in ServletException and propagating.\";\n                    throw new ServletException(msg, exception);\n                }\n            }\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2008 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.web.WebInterceptor;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.IOException;\n\n/**\n * A <tt>WebInterceptorFilter<\/tt> is a Servlet Filter that merely delegates all filter operations to a single internally\n * wrapped {@link org.jsecurity.web.WebInterceptor} instance.  It is a simple utility class to cleanly use a\n * <tt>WebInterceptor<\/tt> as a servlet filter if so desired - the benefit is that you only have to code one\n * WebInterceptor class, and you can re-use it in multiple environments such as in a servlet container,\n * in Spring or Pico, JBoss, etc.  This Filter represents the mechanism to use that one WebInterceptor directly in a\n * Servlet environment.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class WebInterceptorFilter extends SecurityManagerFilter {\n\n    protected WebInterceptor webInterceptor;\n\n    public WebInterceptor getWebInterceptor() {\n        return this.webInterceptor;\n    }\n\n    public void setWebInterceptor(WebInterceptor webInterceptor) {\n        this.webInterceptor = webInterceptor;\n    }\n\n    public void afterSecurityManagerSet() {\n        WebInterceptor interceptor = getWebInterceptor();\n        if (interceptor == null) {\n            throw new IllegalStateException(\"WebInterceptor property must be set.\");\n        }\n        afterWebInterceptorSet();\n    }\n\n    protected void afterWebInterceptorSet() {\n    }\n\n    protected void continueChain(ServletRequest request, ServletResponse response, FilterChain chain)\n        throws IOException, ServletException {\n        chain.doFilter(request, response);\n        if (log.isTraceEnabled()) {\n            log.trace(\"Completed chain execution.\");\n        }\n    }\n\n    protected void doFilterInternal(\n        ServletRequest request, ServletResponse response, FilterChain chain)\n        throws ServletException, IOException {\n\n        Exception exception = null;\n\n        WebInterceptor interceptor = getWebInterceptor();\n\n        try {\n\n            boolean continueChain = interceptor.preHandle(request, response);\n            if (log.isTraceEnabled()) {\n                log.trace(\"Invked interceptor.preHandle method.  Continuing chain?: [\" + continueChain + \"]\");\n            }\n\n            if (continueChain) {\n                continueChain( request, response, chain );\n            }\n\n            interceptor.postHandle(request, response);\n            if (log.isTraceEnabled()) {\n                log.trace(\"Successfully invoked interceptor.postHandle method\");\n            }\n\n        } catch (Exception e) {\n            exception = e;\n            if ( e instanceof ServletException ) {\n                throw (ServletException)e;\n            } else if ( e instanceof IOException ) {\n                throw (IOException)e;\n            } else {\n                String msg = \"Filter execution resulted in a Exception (not IOException or ServletException).  \" +\n                        \"Wrapping in ServletException and propagating.\";\n                throw new ServletException( msg, e );\n            }\n        } finally {\n            try {\n                interceptor.afterCompletion(request, response, exception);\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Successfully invoked interceptor.afterCompletion method.\");\n                }\n            } catch (Exception e) {\n                if (log.isErrorEnabled()) {\n                    log.error(\"WebInterceptor [\" + interceptor + \"] afterCompletion method threw an exception: \", e);\n                }\n            }\n        }\n    }\n}\n","lineNo":81}
{"Refactored Sample":"/*\n* Copyright (C) 2005-2007 Jeremy Haile\n*\n* This library is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as published\n* by the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n* Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the\n*\n* Free Software Foundation, Inc.\n* 59 Temple Place, Suite 330\n* Boston, MA 02111-1307\n* USA\n*\n* Or, you may view it online at\n* http://www.opensource.org/licenses/lgpl-license.php\n*/\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authc.support.SimpleAccount;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * <p>A simple implementation of the {@link AuthorizingAccount} interface that is useful\n * for many realms.  This implementation uses an internal collection of roles and permissions\n * in order to perform authorization checks for a particular user.<\/p>\n *\n * @since 0.2\n * @author Jeremy Haile\n */\npublic class SimpleAuthorizingAccount extends SimpleAccount implements AuthorizingAccount {\n\n    protected Collection<SimpleRole> roles = null;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public SimpleAuthorizingAccount(){}\n\n    public SimpleAuthorizingAccount( Object principal, Object credentials ) {\n        super( principal, credentials );\n    }\n\n    public SimpleAuthorizingAccount( Object principal, Object credentials, Collection<String> roleNames ) {\n        this( principal, credentials );\n        this.roles = toRoles( roleNames );\n    }\n\n    public SimpleAuthorizingAccount( Object principal, Object credentials,\n                                     Collection<String> roleNames, Collection<Permission> permissions ) {\n        super( principal, credentials );\n        this.roles = toRoles( roleNames );\n        SimpleRole privatePermRole = toPrivateRole( principal, permissions );\n        if ( privatePermRole != null ) {\n            if ( this.roles == null ) {\n                this.roles = new HashSet<SimpleRole>(1);\n            }\n            this.roles.add(privatePermRole);\n        }\n    }\n\n    protected SimpleRole toPrivateRole( Object principal, Collection<Permission> perms ) {\n        if ( perms != null && !perms.isEmpty() ) {\n            //create a 'private' role to encapsulate these permissions:\n            String privateRoleName = getClass().getName() + \"_PRIVATE_ROLE_\" + principal;\n            return new SimpleRole(privateRoleName, perms);\n        }\n        return null;\n    }\n\n    protected Collection<SimpleRole> toRoles( Collection<String> roleNames ) {\n        Collection<SimpleRole> roles = null;\n        if ( roleNames != null && !roleNames.isEmpty() ) {\n            roles = new HashSet<SimpleRole>(roleNames.size());\n            for( String roleName : roleNames ) {\n                roles.add( new SimpleRole( roleName ) );\n            }\n        }\n        return roles;\n    }\n\n    public Collection<SimpleRole> getRoles() {\n        return roles;\n    }\n\n    public void setRoles( Collection<SimpleRole> roles ) {\n        this.roles = roles;\n    }\n\n    public Set<Permission> getPermissions() {\n        Set<Permission> permissions = new HashSet<Permission>();\n        for( SimpleRole role : roles ) {\n            permissions.addAll( role.getPermissions() );\n        }\n        return permissions;\n    }\n\n    public Set<String> getRolenames() {\n        Set<String> rolenames = new HashSet<String>();\n        for( SimpleRole role : roles ) {\n            rolenames.add( role.getName() );\n        }\n        return rolenames;\n    }\n\n    public void add( SimpleRole role ) {\n        Collection<SimpleRole> roles = getRoles();\n        if ( roles == null ) {\n            roles = new HashSet<SimpleRole>();\n            setRoles( roles );\n        }\n        roles.add( role );\n    }\n\n    public boolean hasRole( String rolename ) {\n        Collection<SimpleRole> roles = getRoles();\n        if ( roles != null && !roles.isEmpty() ) {\n            for( SimpleRole role : roles ) {\n                if ( role.getName().equals( rolename ) ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean isPermitted( Permission permission ) {\n        Collection<SimpleRole> roles = getRoles();\n        if ( roles != null && !roles.isEmpty() ) {\n            for( SimpleRole role : roles ) {\n                if ( role.isPermitted( permission ) ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        boolean[] result;\n        if ( roleIdentifiers != null && !roleIdentifiers.isEmpty() ) {\n            int size = roleIdentifiers.size();\n            result = new boolean[ size ];\n            int i = 0;\n            for( String roleName : roleIdentifiers ) {\n                result[i++] = hasRole( roleName );\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        if ( roleIdentifiers != null && !roleIdentifiers.isEmpty() ) {\n            for( String roleName : roleIdentifiers ) {\n                if ( !hasRole(roleName ) ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        boolean[] result;\n        if ( permissions != null && !permissions.isEmpty() ) {\n            int size = permissions.size();\n            result = new boolean[ size ];\n            int i = 0;\n            for( Permission p : permissions ) {\n                result[i++] = isPermitted(p);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n        if ( permissions != null && !permissions.isEmpty() ) {\n            for( Permission p : permissions ) {\n                if ( !isPermitted(p) ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        if ( !isPermitted(permission) ) {\n            String msg = \"User is not permitted [\" + permission + \"]\";\n            throw new UnauthorizedException(msg);\n        }\n    }\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        if ( permissions != null && !permissions.isEmpty() ) {\n            for( Permission p : permissions ) {\n                checkPermission(p);\n            }\n        }\n    }\n\n    public void checkRole(String role) {\n        if ( !hasRole( role ) ) {\n            String msg = \"User does not have role [\" + role + \"]\";\n            throw new UnauthorizedException( msg );\n        }\n    }\n\n    public void checkRoles(Collection<String> roles) {\n        if ( roles != null && !roles.isEmpty() ) {\n            for( String roleName : roles ) {\n                checkRole( roleName );\n            }\n        }\n    }\n}\n","Smelly Sample":"/*\n* Copyright (C) 2005-2007 Jeremy Haile\n*\n* This library is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as published\n* by the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n* Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the\n*\n* Free Software Foundation, Inc.\n* 59 Temple Place, Suite 330\n* Boston, MA 02111-1307\n* USA\n*\n* Or, you may view it online at\n* http://www.opensource.org/licenses/lgpl-license.php\n*/\npackage org.jsecurity.authz;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.support.SimpleAccount;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * <p>A simple implementation of the {@link AuthorizingAccount} interface that is useful\n * for many realms.  This implementation uses an internal collection of roles and permissions\n * in order to perform authorizatino checks for a particular user.<\/p>\n *\n * @since 0.2\n * @author Jeremy Haile\n */\npublic class SimpleAuthorizingAccount extends SimpleAccount implements AuthorizingAccount {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logger.\n     */\n    protected transient final Log logger = LogFactory.getLog( getClass() );\n\n    /**\n     * The roles that apply to this info object.\n     */\n    protected Collection<String> roles;\n\n    /**\n     * The permissions that apply to this info object.\n     */\n    protected Collection<Permission> permissions;\n\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    /**\n     * Constructs a new instance with assigned roles and permissions.\n     * \n     * @param roles the roles assigned to this Account.\n     * @param permissions the permissions assigned to this Account.\n     */\n    @SuppressWarnings( \"unchecked\" )\n    public SimpleAuthorizingAccount(Collection<String> roles, Collection<Permission> permissions) {\n        if( roles != null ) {\n            this.roles = roles;\n        } else {\n            this.roles = Collections.EMPTY_LIST;\n        }\n\n        if( permissions != null ) {\n            this.permissions = permissions;\n        } else {\n            this.permissions = Collections.EMPTY_LIST;\n        }\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n\n    public boolean hasRole(String roleIdentifier) {\n        return roles != null && roles.contains(roleIdentifier);\n    }\n\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        boolean[] hasRoles = new boolean[roleIdentifiers.size()];\n\n        for( int i = 0; i < roleIdentifiers.size(); i++ ) {\n            hasRoles[i] = hasRole( roleIdentifiers.get(i) );\n        }\n\n        return hasRoles;\n    }\n\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        for( String roleIdentifier : roleIdentifiers ) {\n            if( !hasRole( roleIdentifier ) ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n\n    public boolean isPermitted(Permission permission) {\n\n        if( permissions != null ) {\n            for( Permission perm : permissions ) {\n                if( perm.implies( permission ) ) {\n                    return true;\n                }\n            }\n        }\n\n        if( logger.isDebugEnabled() ) {\n            logger.debug( \"Context does not imply permission [\" + permission + \"]\" );\n\n            if( permissions == null ) {\n                logger.debug( \"No permissions are associated with this context.  Permissions are null.\" );\n            } else {\n                logger.debug( \"Implies permissions:\" );\n                for( Permission perm : permissions ) {\n                    logger.debug( \"\\t\" + perm );\n                }\n            }\n        }\n\n        return false;\n    }\n\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        boolean[] implies = new boolean[permissions.size()];\n\n        for( int i = 0; i < permissions.size(); i++ ) {\n            implies[i] = isPermitted( permissions.get(i) );\n        }\n        return implies;\n    }\n\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n\n        if( permissions != null ) {\n            for( Permission perm : permissions ) {\n                if( !isPermitted(perm) ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        if( !isPermitted( permission ) ) {\n            throw new AuthorizationException( \"User does not have permission [\" + permission.toString() + \"]\" );\n        }\n    }\n\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        if( permissions != null ) {\n            for( Permission permission : permissions ) {\n                if( !isPermitted( permission ) ) {\n                   throw new AuthorizationException( \"User does not have permission [\" + permission.toString() + \"]\" );\n                }\n            }\n        }\n    }\n\n    public void checkRole(String role) {\n        if( !hasRole( role ) ) {\n            throw new AuthorizationException( \"User does not have role [\" + role + \"]\" );\n        }\n    }\n\n    public void checkRoles(Collection<String> roles) {\n       if( roles != null ) {\n            for( String role : roles ) {\n                checkRole( role );\n            }\n        }\n    }\n\n    public String toString() {\n        StringBuffer sb = new StringBuffer();\n\n        sb.append( \"Roles [\" );\n        if( roles != null ) {\n            for( String role : roles ) {\n                sb.append( role ).append( \" \" );\n            }\n        }\n        sb.append( \"] \" );\n\n        sb.append( \"Permissions [\" );\n        if( permissions != null ) {\n            for( Permission permission : permissions ) {\n                sb.append( permission ).append( \" \" );\n            }\n        }\n        sb.append( \"] \" );\n\n        return sb.toString();\n    }\n\n}\n","lineNo":153}
{"Refactored Sample":"/*\n* Copyright (C) 2005-2007 Jeremy Haile\n*\n* This library is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as published\n* by the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n* Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the\n*\n* Free Software Foundation, Inc.\n* 59 Temple Place, Suite 330\n* Boston, MA 02111-1307\n* USA\n*\n* Or, you may view it online at\n* http://www.opensource.org/licenses/lgpl-license.php\n*/\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authc.support.SimpleAccount;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * <p>A simple implementation of the {@link AuthorizingAccount} interface that is useful\n * for many realms.  This implementation uses an internal collection of roles and permissions\n * in order to perform authorization checks for a particular user.<\/p>\n *\n * @since 0.2\n * @author Jeremy Haile\n */\npublic class SimpleAuthorizingAccount extends SimpleAccount implements AuthorizingAccount {\n\n    protected Collection<SimpleRole> roles = null;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public SimpleAuthorizingAccount(){}\n\n    public SimpleAuthorizingAccount( Object principal, Object credentials ) {\n        super( principal, credentials );\n    }\n\n    public SimpleAuthorizingAccount( Object principal, Object credentials, Collection<String> roleNames ) {\n        this( principal, credentials );\n        this.roles = toRoles( roleNames );\n    }\n\n    public SimpleAuthorizingAccount( Object principal, Object credentials,\n                                     Collection<String> roleNames, Collection<Permission> permissions ) {\n        super( principal, credentials );\n        this.roles = toRoles( roleNames );\n        SimpleRole privatePermRole = toPrivateRole( principal, permissions );\n        if ( privatePermRole != null ) {\n            if ( this.roles == null ) {\n                this.roles = new HashSet<SimpleRole>(1);\n            }\n            this.roles.add(privatePermRole);\n        }\n    }\n\n    protected SimpleRole toPrivateRole( Object principal, Collection<Permission> perms ) {\n        if ( perms != null && !perms.isEmpty() ) {\n            //create a 'private' role to encapsulate these permissions:\n            String privateRoleName = getClass().getName() + \"_PRIVATE_ROLE_\" + principal;\n            return new SimpleRole(privateRoleName, perms);\n        }\n        return null;\n    }\n\n    protected Collection<SimpleRole> toRoles( Collection<String> roleNames ) {\n        Collection<SimpleRole> roles = null;\n        if ( roleNames != null && !roleNames.isEmpty() ) {\n            roles = new HashSet<SimpleRole>(roleNames.size());\n            for( String roleName : roleNames ) {\n                roles.add( new SimpleRole( roleName ) );\n            }\n        }\n        return roles;\n    }\n\n    public Collection<SimpleRole> getRoles() {\n        return roles;\n    }\n\n    public void setRoles( Collection<SimpleRole> roles ) {\n        this.roles = roles;\n    }\n\n    public Set<Permission> getPermissions() {\n        Set<Permission> permissions = new HashSet<Permission>();\n        for( SimpleRole role : roles ) {\n            permissions.addAll( role.getPermissions() );\n        }\n        return permissions;\n    }\n\n    public Set<String> getRolenames() {\n        Set<String> rolenames = new HashSet<String>();\n        for( SimpleRole role : roles ) {\n            rolenames.add( role.getName() );\n        }\n        return rolenames;\n    }\n\n    public void add( SimpleRole role ) {\n        Collection<SimpleRole> roles = getRoles();\n        if ( roles == null ) {\n            roles = new HashSet<SimpleRole>();\n            setRoles( roles );\n        }\n        roles.add( role );\n    }\n\n    public boolean hasRole( String rolename ) {\n        Collection<SimpleRole> roles = getRoles();\n        if ( roles != null && !roles.isEmpty() ) {\n            for( SimpleRole role : roles ) {\n                if ( role.getName().equals( rolename ) ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean isPermitted( Permission permission ) {\n        Collection<SimpleRole> roles = getRoles();\n        if ( roles != null && !roles.isEmpty() ) {\n            for( SimpleRole role : roles ) {\n                if ( role.isPermitted( permission ) ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        boolean[] result;\n        if ( roleIdentifiers != null && !roleIdentifiers.isEmpty() ) {\n            int size = roleIdentifiers.size();\n            result = new boolean[ size ];\n            int i = 0;\n            for( String roleName : roleIdentifiers ) {\n                result[i++] = hasRole( roleName );\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        if ( roleIdentifiers != null && !roleIdentifiers.isEmpty() ) {\n            for( String roleName : roleIdentifiers ) {\n                if ( !hasRole(roleName ) ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        boolean[] result;\n        if ( permissions != null && !permissions.isEmpty() ) {\n            int size = permissions.size();\n            result = new boolean[ size ];\n            int i = 0;\n            for( Permission p : permissions ) {\n                result[i++] = isPermitted(p);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n        if ( permissions != null && !permissions.isEmpty() ) {\n            for( Permission p : permissions ) {\n                if ( !isPermitted(p) ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        if ( !isPermitted(permission) ) {\n            String msg = \"User is not permitted [\" + permission + \"]\";\n            throw new UnauthorizedException(msg);\n        }\n    }\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        if ( permissions != null && !permissions.isEmpty() ) {\n            for( Permission p : permissions ) {\n                checkPermission(p);\n            }\n        }\n    }\n\n    public void checkRole(String role) {\n        if ( !hasRole( role ) ) {\n            String msg = \"User does not have role [\" + role + \"]\";\n            throw new UnauthorizedException( msg );\n        }\n    }\n\n    public void checkRoles(Collection<String> roles) {\n        if ( roles != null && !roles.isEmpty() ) {\n            for( String roleName : roles ) {\n                checkRole( roleName );\n            }\n        }\n    }\n}\n","Smelly Sample":"/*\n* Copyright (C) 2005-2007 Jeremy Haile\n*\n* This library is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as published\n* by the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n* Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the\n*\n* Free Software Foundation, Inc.\n* 59 Temple Place, Suite 330\n* Boston, MA 02111-1307\n* USA\n*\n* Or, you may view it online at\n* http://www.opensource.org/licenses/lgpl-license.php\n*/\npackage org.jsecurity.authz;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.support.SimpleAccount;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * <p>A simple implementation of the {@link AuthorizingAccount} interface that is useful\n * for many realms.  This implementation uses an internal collection of roles and permissions\n * in order to perform authorizatino checks for a particular user.<\/p>\n *\n * @since 0.2\n * @author Jeremy Haile\n */\npublic class SimpleAuthorizingAccount extends SimpleAccount implements AuthorizingAccount {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logger.\n     */\n    protected transient final Log logger = LogFactory.getLog( getClass() );\n\n    /**\n     * The roles that apply to this info object.\n     */\n    protected Collection<String> roles;\n\n    /**\n     * The permissions that apply to this info object.\n     */\n    protected Collection<Permission> permissions;\n\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    /**\n     * Constructs a new instance with assigned roles and permissions.\n     * \n     * @param roles the roles assigned to this Account.\n     * @param permissions the permissions assigned to this Account.\n     */\n    @SuppressWarnings( \"unchecked\" )\n    public SimpleAuthorizingAccount(Collection<String> roles, Collection<Permission> permissions) {\n        if( roles != null ) {\n            this.roles = roles;\n        } else {\n            this.roles = Collections.EMPTY_LIST;\n        }\n\n        if( permissions != null ) {\n            this.permissions = permissions;\n        } else {\n            this.permissions = Collections.EMPTY_LIST;\n        }\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n\n    public boolean hasRole(String roleIdentifier) {\n        return roles != null && roles.contains(roleIdentifier);\n    }\n\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        boolean[] hasRoles = new boolean[roleIdentifiers.size()];\n\n        for( int i = 0; i < roleIdentifiers.size(); i++ ) {\n            hasRoles[i] = hasRole( roleIdentifiers.get(i) );\n        }\n\n        return hasRoles;\n    }\n\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        for( String roleIdentifier : roleIdentifiers ) {\n            if( !hasRole( roleIdentifier ) ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n\n    public boolean isPermitted(Permission permission) {\n\n        if( permissions != null ) {\n            for( Permission perm : permissions ) {\n                if( perm.implies( permission ) ) {\n                    return true;\n                }\n            }\n        }\n\n        if( logger.isDebugEnabled() ) {\n            logger.debug( \"Context does not imply permission [\" + permission + \"]\" );\n\n            if( permissions == null ) {\n                logger.debug( \"No permissions are associated with this context.  Permissions are null.\" );\n            } else {\n                logger.debug( \"Implies permissions:\" );\n                for( Permission perm : permissions ) {\n                    logger.debug( \"\\t\" + perm );\n                }\n            }\n        }\n\n        return false;\n    }\n\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        boolean[] implies = new boolean[permissions.size()];\n\n        for( int i = 0; i < permissions.size(); i++ ) {\n            implies[i] = isPermitted( permissions.get(i) );\n        }\n        return implies;\n    }\n\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n\n        if( permissions != null ) {\n            for( Permission perm : permissions ) {\n                if( !isPermitted(perm) ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        if( !isPermitted( permission ) ) {\n            throw new AuthorizationException( \"User does not have permission [\" + permission.toString() + \"]\" );\n        }\n    }\n\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        if( permissions != null ) {\n            for( Permission permission : permissions ) {\n                if( !isPermitted( permission ) ) {\n                   throw new AuthorizationException( \"User does not have permission [\" + permission.toString() + \"]\" );\n                }\n            }\n        }\n    }\n\n    public void checkRole(String role) {\n        if( !hasRole( role ) ) {\n            throw new AuthorizationException( \"User does not have role [\" + role + \"]\" );\n        }\n    }\n\n    public void checkRoles(Collection<String> roles) {\n       if( roles != null ) {\n            for( String role : roles ) {\n                checkRole( role );\n            }\n        }\n    }\n\n    public String toString() {\n        StringBuffer sb = new StringBuffer();\n\n        sb.append( \"Roles [\" );\n        if( roles != null ) {\n            for( String role : roles ) {\n                sb.append( role ).append( \" \" );\n            }\n        }\n        sb.append( \"] \" );\n\n        sb.append( \"Permissions [\" );\n        if( permissions != null ) {\n            for( Permission permission : permissions ) {\n                sb.append( permission ).append( \" \" );\n            }\n        }\n        sb.append( \"] \" );\n\n        return sb.toString();\n    }\n\n}\n","lineNo":179}
{"Refactored Sample":"/*\n* Copyright (C) 2005-2007 Jeremy Haile\n*\n* This library is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as published\n* by the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n* Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the\n*\n* Free Software Foundation, Inc.\n* 59 Temple Place, Suite 330\n* Boston, MA 02111-1307\n* USA\n*\n* Or, you may view it online at\n* http://www.opensource.org/licenses/lgpl-license.php\n*/\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authc.support.SimpleAccount;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * <p>A simple implementation of the {@link AuthorizingAccount} interface that is useful\n * for many realms.  This implementation uses an internal collection of roles and permissions\n * in order to perform authorization checks for a particular user.<\/p>\n *\n * @since 0.2\n * @author Jeremy Haile\n */\npublic class SimpleAuthorizingAccount extends SimpleAccount implements AuthorizingAccount {\n\n    protected Collection<SimpleRole> roles = null;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public SimpleAuthorizingAccount(){}\n\n    public SimpleAuthorizingAccount( Object principal, Object credentials ) {\n        super( principal, credentials );\n    }\n\n    public SimpleAuthorizingAccount( Object principal, Object credentials, Collection<String> roleNames ) {\n        this( principal, credentials );\n        this.roles = toRoles( roleNames );\n    }\n\n    public SimpleAuthorizingAccount( Object principal, Object credentials,\n                                     Collection<String> roleNames, Collection<Permission> permissions ) {\n        super( principal, credentials );\n        this.roles = toRoles( roleNames );\n        SimpleRole privatePermRole = toPrivateRole( principal, permissions );\n        if ( privatePermRole != null ) {\n            if ( this.roles == null ) {\n                this.roles = new HashSet<SimpleRole>(1);\n            }\n            this.roles.add(privatePermRole);\n        }\n    }\n\n    protected SimpleRole toPrivateRole( Object principal, Collection<Permission> perms ) {\n        if ( perms != null && !perms.isEmpty() ) {\n            //create a 'private' role to encapsulate these permissions:\n            String privateRoleName = getClass().getName() + \"_PRIVATE_ROLE_\" + principal;\n            return new SimpleRole(privateRoleName, perms);\n        }\n        return null;\n    }\n\n    protected Collection<SimpleRole> toRoles( Collection<String> roleNames ) {\n        Collection<SimpleRole> roles = null;\n        if ( roleNames != null && !roleNames.isEmpty() ) {\n            roles = new HashSet<SimpleRole>(roleNames.size());\n            for( String roleName : roleNames ) {\n                roles.add( new SimpleRole( roleName ) );\n            }\n        }\n        return roles;\n    }\n\n    public Collection<SimpleRole> getRoles() {\n        return roles;\n    }\n\n    public void setRoles( Collection<SimpleRole> roles ) {\n        this.roles = roles;\n    }\n\n    public Set<Permission> getPermissions() {\n        Set<Permission> permissions = new HashSet<Permission>();\n        for( SimpleRole role : roles ) {\n            permissions.addAll( role.getPermissions() );\n        }\n        return permissions;\n    }\n\n    public Set<String> getRolenames() {\n        Set<String> rolenames = new HashSet<String>();\n        for( SimpleRole role : roles ) {\n            rolenames.add( role.getName() );\n        }\n        return rolenames;\n    }\n\n    public void add( SimpleRole role ) {\n        Collection<SimpleRole> roles = getRoles();\n        if ( roles == null ) {\n            roles = new HashSet<SimpleRole>();\n            setRoles( roles );\n        }\n        roles.add( role );\n    }\n\n    public boolean hasRole( String rolename ) {\n        Collection<SimpleRole> roles = getRoles();\n        if ( roles != null && !roles.isEmpty() ) {\n            for( SimpleRole role : roles ) {\n                if ( role.getName().equals( rolename ) ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean isPermitted( Permission permission ) {\n        Collection<SimpleRole> roles = getRoles();\n        if ( roles != null && !roles.isEmpty() ) {\n            for( SimpleRole role : roles ) {\n                if ( role.isPermitted( permission ) ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        boolean[] result;\n        if ( roleIdentifiers != null && !roleIdentifiers.isEmpty() ) {\n            int size = roleIdentifiers.size();\n            result = new boolean[ size ];\n            int i = 0;\n            for( String roleName : roleIdentifiers ) {\n                result[i++] = hasRole( roleName );\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        if ( roleIdentifiers != null && !roleIdentifiers.isEmpty() ) {\n            for( String roleName : roleIdentifiers ) {\n                if ( !hasRole(roleName ) ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        boolean[] result;\n        if ( permissions != null && !permissions.isEmpty() ) {\n            int size = permissions.size();\n            result = new boolean[ size ];\n            int i = 0;\n            for( Permission p : permissions ) {\n                result[i++] = isPermitted(p);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n        if ( permissions != null && !permissions.isEmpty() ) {\n            for( Permission p : permissions ) {\n                if ( !isPermitted(p) ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        if ( !isPermitted(permission) ) {\n            String msg = \"User is not permitted [\" + permission + \"]\";\n            throw new UnauthorizedException(msg);\n        }\n    }\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        if ( permissions != null && !permissions.isEmpty() ) {\n            for( Permission p : permissions ) {\n                checkPermission(p);\n            }\n        }\n    }\n\n    public void checkRole(String role) {\n        if ( !hasRole( role ) ) {\n            String msg = \"User does not have role [\" + role + \"]\";\n            throw new UnauthorizedException( msg );\n        }\n    }\n\n    public void checkRoles(Collection<String> roles) {\n        if ( roles != null && !roles.isEmpty() ) {\n            for( String roleName : roles ) {\n                checkRole( roleName );\n            }\n        }\n    }\n}\n","Smelly Sample":"/*\n* Copyright (C) 2005-2007 Jeremy Haile\n*\n* This library is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as published\n* by the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n* Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the\n*\n* Free Software Foundation, Inc.\n* 59 Temple Place, Suite 330\n* Boston, MA 02111-1307\n* USA\n*\n* Or, you may view it online at\n* http://www.opensource.org/licenses/lgpl-license.php\n*/\npackage org.jsecurity.authz;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.support.SimpleAccount;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * <p>A simple implementation of the {@link AuthorizingAccount} interface that is useful\n * for many realms.  This implementation uses an internal collection of roles and permissions\n * in order to perform authorizatino checks for a particular user.<\/p>\n *\n * @since 0.2\n * @author Jeremy Haile\n */\npublic class SimpleAuthorizingAccount extends SimpleAccount implements AuthorizingAccount {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logger.\n     */\n    protected transient final Log logger = LogFactory.getLog( getClass() );\n\n    /**\n     * The roles that apply to this info object.\n     */\n    protected Collection<String> roles;\n\n    /**\n     * The permissions that apply to this info object.\n     */\n    protected Collection<Permission> permissions;\n\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    /**\n     * Constructs a new instance with assigned roles and permissions.\n     * \n     * @param roles the roles assigned to this Account.\n     * @param permissions the permissions assigned to this Account.\n     */\n    @SuppressWarnings( \"unchecked\" )\n    public SimpleAuthorizingAccount(Collection<String> roles, Collection<Permission> permissions) {\n        if( roles != null ) {\n            this.roles = roles;\n        } else {\n            this.roles = Collections.EMPTY_LIST;\n        }\n\n        if( permissions != null ) {\n            this.permissions = permissions;\n        } else {\n            this.permissions = Collections.EMPTY_LIST;\n        }\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n\n    public boolean hasRole(String roleIdentifier) {\n        return roles != null && roles.contains(roleIdentifier);\n    }\n\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        boolean[] hasRoles = new boolean[roleIdentifiers.size()];\n\n        for( int i = 0; i < roleIdentifiers.size(); i++ ) {\n            hasRoles[i] = hasRole( roleIdentifiers.get(i) );\n        }\n\n        return hasRoles;\n    }\n\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        for( String roleIdentifier : roleIdentifiers ) {\n            if( !hasRole( roleIdentifier ) ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n\n    public boolean isPermitted(Permission permission) {\n\n        if( permissions != null ) {\n            for( Permission perm : permissions ) {\n                if( perm.implies( permission ) ) {\n                    return true;\n                }\n            }\n        }\n\n        if( logger.isDebugEnabled() ) {\n            logger.debug( \"Context does not imply permission [\" + permission + \"]\" );\n\n            if( permissions == null ) {\n                logger.debug( \"No permissions are associated with this context.  Permissions are null.\" );\n            } else {\n                logger.debug( \"Implies permissions:\" );\n                for( Permission perm : permissions ) {\n                    logger.debug( \"\\t\" + perm );\n                }\n            }\n        }\n\n        return false;\n    }\n\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        boolean[] implies = new boolean[permissions.size()];\n\n        for( int i = 0; i < permissions.size(); i++ ) {\n            implies[i] = isPermitted( permissions.get(i) );\n        }\n        return implies;\n    }\n\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n\n        if( permissions != null ) {\n            for( Permission perm : permissions ) {\n                if( !isPermitted(perm) ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        if( !isPermitted( permission ) ) {\n            throw new AuthorizationException( \"User does not have permission [\" + permission.toString() + \"]\" );\n        }\n    }\n\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        if( permissions != null ) {\n            for( Permission permission : permissions ) {\n                if( !isPermitted( permission ) ) {\n                   throw new AuthorizationException( \"User does not have permission [\" + permission.toString() + \"]\" );\n                }\n            }\n        }\n    }\n\n    public void checkRole(String role) {\n        if( !hasRole( role ) ) {\n            throw new AuthorizationException( \"User does not have role [\" + role + \"]\" );\n        }\n    }\n\n    public void checkRoles(Collection<String> roles) {\n       if( roles != null ) {\n            for( String role : roles ) {\n                checkRole( role );\n            }\n        }\n    }\n\n    public String toString() {\n        StringBuffer sb = new StringBuffer();\n\n        sb.append( \"Roles [\" );\n        if( roles != null ) {\n            for( String role : roles ) {\n                sb.append( role ).append( \" \" );\n            }\n        }\n        sb.append( \"] \" );\n\n        sb.append( \"Permissions [\" );\n        if( permissions != null ) {\n            for( Permission permission : permissions ) {\n                sb.append( permission ).append( \" \" );\n            }\n        }\n        sb.append( \"] \" );\n\n        return sb.toString();\n    }\n\n}\n","lineNo":219}
{"Refactored Sample":"/*\n* Copyright (C) 2005-2007 Jeremy Haile\n*\n* This library is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as published\n* by the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n* Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the\n*\n* Free Software Foundation, Inc.\n* 59 Temple Place, Suite 330\n* Boston, MA 02111-1307\n* USA\n*\n* Or, you may view it online at\n* http://www.opensource.org/licenses/lgpl-license.php\n*/\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authc.support.SimpleAccount;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * <p>A simple implementation of the {@link AuthorizingAccount} interface that is useful\n * for many realms.  This implementation uses an internal collection of roles and permissions\n * in order to perform authorization checks for a particular user.<\/p>\n *\n * @since 0.2\n * @author Jeremy Haile\n */\npublic class SimpleAuthorizingAccount extends SimpleAccount implements AuthorizingAccount {\n\n    protected Collection<SimpleRole> roles = null;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public SimpleAuthorizingAccount(){}\n\n    public SimpleAuthorizingAccount( Object principal, Object credentials ) {\n        super( principal, credentials );\n    }\n\n    public SimpleAuthorizingAccount( Object principal, Object credentials, Collection<String> roleNames ) {\n        this( principal, credentials );\n        this.roles = toRoles( roleNames );\n    }\n\n    public SimpleAuthorizingAccount( Object principal, Object credentials,\n                                     Collection<String> roleNames, Collection<Permission> permissions ) {\n        super( principal, credentials );\n        this.roles = toRoles( roleNames );\n        SimpleRole privatePermRole = toPrivateRole( principal, permissions );\n        if ( privatePermRole != null ) {\n            if ( this.roles == null ) {\n                this.roles = new HashSet<SimpleRole>(1);\n            }\n            this.roles.add(privatePermRole);\n        }\n    }\n\n    protected SimpleRole toPrivateRole( Object principal, Collection<Permission> perms ) {\n        if ( perms != null && !perms.isEmpty() ) {\n            //create a 'private' role to encapsulate these permissions:\n            String privateRoleName = getClass().getName() + \"_PRIVATE_ROLE_\" + principal;\n            return new SimpleRole(privateRoleName, perms);\n        }\n        return null;\n    }\n\n    protected Collection<SimpleRole> toRoles( Collection<String> roleNames ) {\n        Collection<SimpleRole> roles = null;\n        if ( roleNames != null && !roleNames.isEmpty() ) {\n            roles = new HashSet<SimpleRole>(roleNames.size());\n            for( String roleName : roleNames ) {\n                roles.add( new SimpleRole( roleName ) );\n            }\n        }\n        return roles;\n    }\n\n    public Collection<SimpleRole> getRoles() {\n        return roles;\n    }\n\n    public void setRoles( Collection<SimpleRole> roles ) {\n        this.roles = roles;\n    }\n\n    public Set<Permission> getPermissions() {\n        Set<Permission> permissions = new HashSet<Permission>();\n        for( SimpleRole role : roles ) {\n            permissions.addAll( role.getPermissions() );\n        }\n        return permissions;\n    }\n\n    public Set<String> getRolenames() {\n        Set<String> rolenames = new HashSet<String>();\n        for( SimpleRole role : roles ) {\n            rolenames.add( role.getName() );\n        }\n        return rolenames;\n    }\n\n    public void add( SimpleRole role ) {\n        Collection<SimpleRole> roles = getRoles();\n        if ( roles == null ) {\n            roles = new HashSet<SimpleRole>();\n            setRoles( roles );\n        }\n        roles.add( role );\n    }\n\n    public boolean hasRole( String rolename ) {\n        Collection<SimpleRole> roles = getRoles();\n        if ( roles != null && !roles.isEmpty() ) {\n            for( SimpleRole role : roles ) {\n                if ( role.getName().equals( rolename ) ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean isPermitted( Permission permission ) {\n        Collection<SimpleRole> roles = getRoles();\n        if ( roles != null && !roles.isEmpty() ) {\n            for( SimpleRole role : roles ) {\n                if ( role.isPermitted( permission ) ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        boolean[] result;\n        if ( roleIdentifiers != null && !roleIdentifiers.isEmpty() ) {\n            int size = roleIdentifiers.size();\n            result = new boolean[ size ];\n            int i = 0;\n            for( String roleName : roleIdentifiers ) {\n                result[i++] = hasRole( roleName );\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        if ( roleIdentifiers != null && !roleIdentifiers.isEmpty() ) {\n            for( String roleName : roleIdentifiers ) {\n                if ( !hasRole(roleName ) ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        boolean[] result;\n        if ( permissions != null && !permissions.isEmpty() ) {\n            int size = permissions.size();\n            result = new boolean[ size ];\n            int i = 0;\n            for( Permission p : permissions ) {\n                result[i++] = isPermitted(p);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n        if ( permissions != null && !permissions.isEmpty() ) {\n            for( Permission p : permissions ) {\n                if ( !isPermitted(p) ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        if ( !isPermitted(permission) ) {\n            String msg = \"User is not permitted [\" + permission + \"]\";\n            throw new UnauthorizedException(msg);\n        }\n    }\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        if ( permissions != null && !permissions.isEmpty() ) {\n            for( Permission p : permissions ) {\n                checkPermission(p);\n            }\n        }\n    }\n\n    public void checkRole(String role) {\n        if ( !hasRole( role ) ) {\n            String msg = \"User does not have role [\" + role + \"]\";\n            throw new UnauthorizedException( msg );\n        }\n    }\n\n    public void checkRoles(Collection<String> roles) {\n        if ( roles != null && !roles.isEmpty() ) {\n            for( String roleName : roles ) {\n                checkRole( roleName );\n            }\n        }\n    }\n}\n","Smelly Sample":"/*\n* Copyright (C) 2005-2007 Jeremy Haile\n*\n* This library is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as published\n* by the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n* Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the\n*\n* Free Software Foundation, Inc.\n* 59 Temple Place, Suite 330\n* Boston, MA 02111-1307\n* USA\n*\n* Or, you may view it online at\n* http://www.opensource.org/licenses/lgpl-license.php\n*/\npackage org.jsecurity.authz;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.support.SimpleAccount;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * <p>A simple implementation of the {@link AuthorizingAccount} interface that is useful\n * for many realms.  This implementation uses an internal collection of roles and permissions\n * in order to perform authorizatino checks for a particular user.<\/p>\n *\n * @since 0.2\n * @author Jeremy Haile\n */\npublic class SimpleAuthorizingAccount extends SimpleAccount implements AuthorizingAccount {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logger.\n     */\n    protected transient final Log logger = LogFactory.getLog( getClass() );\n\n    /**\n     * The roles that apply to this info object.\n     */\n    protected Collection<String> roles;\n\n    /**\n     * The permissions that apply to this info object.\n     */\n    protected Collection<Permission> permissions;\n\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    /**\n     * Constructs a new instance with assigned roles and permissions.\n     * \n     * @param roles the roles assigned to this Account.\n     * @param permissions the permissions assigned to this Account.\n     */\n    @SuppressWarnings( \"unchecked\" )\n    public SimpleAuthorizingAccount(Collection<String> roles, Collection<Permission> permissions) {\n        if( roles != null ) {\n            this.roles = roles;\n        } else {\n            this.roles = Collections.EMPTY_LIST;\n        }\n\n        if( permissions != null ) {\n            this.permissions = permissions;\n        } else {\n            this.permissions = Collections.EMPTY_LIST;\n        }\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n\n    public boolean hasRole(String roleIdentifier) {\n        return roles != null && roles.contains(roleIdentifier);\n    }\n\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        boolean[] hasRoles = new boolean[roleIdentifiers.size()];\n\n        for( int i = 0; i < roleIdentifiers.size(); i++ ) {\n            hasRoles[i] = hasRole( roleIdentifiers.get(i) );\n        }\n\n        return hasRoles;\n    }\n\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        for( String roleIdentifier : roleIdentifiers ) {\n            if( !hasRole( roleIdentifier ) ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n\n    public boolean isPermitted(Permission permission) {\n\n        if( permissions != null ) {\n            for( Permission perm : permissions ) {\n                if( perm.implies( permission ) ) {\n                    return true;\n                }\n            }\n        }\n\n        if( logger.isDebugEnabled() ) {\n            logger.debug( \"Context does not imply permission [\" + permission + \"]\" );\n\n            if( permissions == null ) {\n                logger.debug( \"No permissions are associated with this context.  Permissions are null.\" );\n            } else {\n                logger.debug( \"Implies permissions:\" );\n                for( Permission perm : permissions ) {\n                    logger.debug( \"\\t\" + perm );\n                }\n            }\n        }\n\n        return false;\n    }\n\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        boolean[] implies = new boolean[permissions.size()];\n\n        for( int i = 0; i < permissions.size(); i++ ) {\n            implies[i] = isPermitted( permissions.get(i) );\n        }\n        return implies;\n    }\n\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n\n        if( permissions != null ) {\n            for( Permission perm : permissions ) {\n                if( !isPermitted(perm) ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        if( !isPermitted( permission ) ) {\n            throw new AuthorizationException( \"User does not have permission [\" + permission.toString() + \"]\" );\n        }\n    }\n\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        if( permissions != null ) {\n            for( Permission permission : permissions ) {\n                if( !isPermitted( permission ) ) {\n                   throw new AuthorizationException( \"User does not have permission [\" + permission.toString() + \"]\" );\n                }\n            }\n        }\n    }\n\n    public void checkRole(String role) {\n        if( !hasRole( role ) ) {\n            throw new AuthorizationException( \"User does not have role [\" + role + \"]\" );\n        }\n    }\n\n    public void checkRoles(Collection<String> roles) {\n       if( roles != null ) {\n            for( String role : roles ) {\n                checkRole( role );\n            }\n        }\n    }\n\n    public String toString() {\n        StringBuffer sb = new StringBuffer();\n\n        sb.append( \"Roles [\" );\n        if( roles != null ) {\n            for( String role : roles ) {\n                sb.append( role ).append( \" \" );\n            }\n        }\n        sb.append( \"] \" );\n\n        sb.append( \"Permissions [\" );\n        if( permissions != null ) {\n            for( Permission permission : permissions ) {\n                sb.append( permission ).append( \" \" );\n            }\n        }\n        sb.append( \"] \" );\n\n        return sb.toString();\n    }\n\n}\n","lineNo":64}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2008 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.crypto.support;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.CodecSupport;\nimport org.jsecurity.crypto.Cipher;\nimport org.jsecurity.crypto.Key;\n\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.InvalidKeyException;\nimport java.util.Arrays;\n\n/**\n * @author Les Hazlewood\n * @since 1.0\n */\npublic class SimpleBlowfishCipher implements Cipher {\n\n    private static final String ALGORITHM = \"Blowfish\";\n\n    private static final String TRANSFORMATION_STRING = ALGORITHM + \"/ECB/PKCS5Padding\";\n\n    //created by running the test program below\n    private static final byte[] KEY_BYTES = Base64.decodeBase64(\"jJ9Kg1BAevbvhSg3vBfwfQ==\");\n    private static final JdkKey DEFAULT_CIPHER_KEY = new JdkKey( new SecretKeySpec( KEY_BYTES, ALGORITHM ) );\n\n    private JdkKey key = DEFAULT_CIPHER_KEY;\n\n    public SimpleBlowfishCipher() {\n    }\n\n    public JdkKey getKey() {\n        return key;\n    }\n\n    public void setKey(JdkKey key) {\n        this.key = key;\n    }\n\n    public byte[] encrypt(byte[] raw, Key key) {\n        return crypt(raw, javax.crypto.Cipher.ENCRYPT_MODE, key);\n    }\n\n    public byte[] decrypt(byte[] encrypted, Key key) {\n        return crypt(encrypted, javax.crypto.Cipher.DECRYPT_MODE, key);\n    }\n\n    protected javax.crypto.Cipher newCipherInstance() {\n        try {\n            return javax.crypto.Cipher.getInstance(TRANSFORMATION_STRING);\n        } catch (Exception e) {\n            String msg = \"Unable to acquire a Java JCE Cipher instance using \" +\n                javax.crypto.Cipher.class.getName() + \".getInstance( \\\"\" + TRANSFORMATION_STRING + \"\\\" ). \" +\n                \"Blowfish under this configuration is required for the \" +\n                getClass().getName() + \" instance to function.\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    protected void init(javax.crypto.Cipher cipher, int mode, java.security.Key key) {\n        try {\n            cipher.init(mode, key);\n        } catch (InvalidKeyException e) {\n            String msg = \"Unable to init cipher.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    protected byte[] crypt(javax.crypto.Cipher cipher, byte[] bytes) {\n        try {\n            return cipher.doFinal(bytes);\n        } catch (Exception e) {\n            String msg = \"Unable to crypt bytes with cipher [\" + cipher + \"].\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    protected byte[] crypt(byte[] bytes, int mode, Key key) {\n        javax.crypto.Cipher cipher = newCipherInstance();\n        java.security.Key jdkKey = getKey();\n        if ( key != null ) {\n            if ( key instanceof java.security.Key ) {\n                jdkKey = (java.security.Key)key;\n            } else {\n                String msg = \"The \" + getClass().getName() + \" implementation only accepts \" + Key.class.getName() +\n                        \" instances that also implement the \" + java.security.Key.class.getName() +\n                        \" interface.  The argument used is of type [\" + key.getClass().getName() + \"].\";\n                throw new IllegalArgumentException( msg );\n            }\n        }\n        init(cipher, mode, jdkKey);\n        return crypt(cipher, bytes);\n    }\n\n    public static void main(String[] unused) throws Exception {\n\n        /* Commented out - only used to generate a a new permanent KEY_BYTES constant\n        // Generate a secret key\n        KeyGenerator kg = KeyGenerator.getInstance( ALGORITHM );\n        kg.init(128); //using a 128 bit key size\n        SecretKey key = kg.generateKey();\n\n        String algorithm = key.getAlgorithm();\n        byte[] keyData = key.getEncoded();\n        //the following output in between the brackets is copied-and-pasted into this class's KEY_BYTES line of code.\n        //This constant is the embedded key used to symmetrically encode/decode data.\n        System.out.println(\"Base64 encoded keyData: [\" + Base64.encodeBytes(keyData) + \"]\");\n        */\n\n        Cipher cipher = new SimpleBlowfishCipher();\n\n        String[] cleartext = new String[]{\n            \"Hello, this is a test.\",\n            \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\",\n            \"\u2014?\u2014\u2026????\u2022??\u201e?\u201a\u201a?\u2014???\"\n        };\n\n        for (String clear : cleartext) {\n            byte[] cleartextBytes = CodecSupport.toBytes(clear);\n            System.out.println(\"Clear text: [\" + clear + \"]\");\n            System.out.println(\"Clear text base64: [\" + Base64.encodeBase64ToString(cleartextBytes) + \"]\");\n\n            byte[] encrypted = cipher.encrypt(cleartextBytes, null);\n            String encryptedBase64 = Base64.encodeBase64ToString( encrypted );\n            System.out.println(\"Encrypted base64: [\" + encryptedBase64 + \"]\");\n\n            byte[] decrypted = cipher.decrypt(Base64.decodeBase64(encryptedBase64), null);\n            String decryptedString = CodecSupport.toString(decrypted);\n\n            System.out.println(\"Arrays equal? \" + Arrays.equals(cleartextBytes, decrypted));\n\n            System.out.println(\"Decrypted text: [\" + decryptedString + \"]\");\n            System.out.println(\"Decrypted text base64: [\" + Base64.encodeBase64ToString(decrypted) + \"]\");\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2008 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.crypto.support;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.support.CodecSupport;\nimport org.jsecurity.crypto.Cipher;\nimport org.jsecurity.crypto.Key;\n\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.InvalidKeyException;\nimport java.util.Arrays;\n\n/**\n * @author Les Hazlewood\n * @since 1.0\n */\npublic class SimpleBlowfishCipher implements Cipher {\n\n    private static final String ALGORITHM = \"Blowfish\";\n\n    private static final String TRANSFORMATION_STRING = ALGORITHM + \"/ECB/PKCS5Padding\";\n\n    //created by running the test program below\n    private static final byte[] KEY_BYTES = Base64.decodeBase64(\"jJ9Kg1BAevbvhSg3vBfwfQ==\");\n    private static final javax.crypto.SecretKey DEFAULT_CIPHER_KEY = new SecretKeySpec(KEY_BYTES, ALGORITHM);\n\n    private javax.crypto.SecretKey key = DEFAULT_CIPHER_KEY; //default unless overridden\n\n    public SimpleBlowfishCipher() {\n    }\n\n    public SecretKey getKey() {\n        return key;\n    }\n\n    public void setKey(SecretKey key) {\n        this.key = key;\n    }\n\n    public byte[] encrypt(byte[] raw, Key key) {\n        return crypt(raw, javax.crypto.Cipher.ENCRYPT_MODE, key);\n    }\n\n    public byte[] decrypt(byte[] encrypted, Key key) {\n        return crypt(encrypted, javax.crypto.Cipher.DECRYPT_MODE, key);\n    }\n\n    protected javax.crypto.Cipher newCipherInstance() {\n        try {\n            return javax.crypto.Cipher.getInstance(TRANSFORMATION_STRING);\n        } catch (Exception e) {\n            String msg = \"Unable to acquire a Java JCE Cipher instance using \" +\n                javax.crypto.Cipher.class.getName() + \".getInstance( \\\"\" + TRANSFORMATION_STRING + \"\\\" ). \" +\n                \"Blowfish under this configuration is required for the \" +\n                getClass().getName() + \" instance to function.\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    protected void init(javax.crypto.Cipher cipher, int mode, java.security.Key key) {\n        try {\n            cipher.init(mode, key);\n        } catch (InvalidKeyException e) {\n            String msg = \"Unable to init cipher.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    protected byte[] crypt(javax.crypto.Cipher cipher, byte[] bytes) {\n        try {\n            return cipher.doFinal(bytes);\n        } catch (Exception e) {\n            String msg = \"Unable to crypt bytes with cipher [\" + cipher + \"].\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    protected byte[] crypt(byte[] bytes, int mode, Key key) {\n        javax.crypto.Cipher cipher = newCipherInstance();\n        init(cipher, mode, getKey());\n        return crypt(cipher, bytes);\n    }\n\n    public static void main(String[] unused) throws Exception {\n\n        /* Commented out - only used to generate a a new permanent KEY_BYTES constant\n        // Generate a secret key\n        KeyGenerator kg = KeyGenerator.getInstance( ALGORITHM );\n        kg.init(128); //using a 128 bit key size\n        SecretKey key = kg.generateKey();\n\n        String algorithm = key.getAlgorithm();\n        byte[] keyData = key.getEncoded();\n        //the following output in between the brackets is copied-and-pasted into this class's KEY_BYTES line of code.\n        //This constant is the embedded key used to symmetrically encode/decode data.\n        System.out.println(\"Base64 encoded keyData: [\" + Base64.encodeBytes(keyData) + \"]\");\n        */\n\n        Cipher cipher = new SimpleBlowfishCipher();\n\n        String[] cleartext = new String[]{\n            \"Hello, this is a test.\",\n            \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\",\n            \"\u2014?\u2014\u2026????\u2022??\u201e?\u201a\u201a?\u2014???\"\n        };\n\n        for (String clear : cleartext) {\n            byte[] cleartextBytes = CodecSupport.toBytes(clear);\n            System.out.println(\"Clear text: [\" + clear + \"]\");\n            System.out.println(\"Clear text base64: [\" + Base64.encodeBase64ToString(cleartextBytes) + \"]\");\n\n            byte[] encrypted = cipher.encrypt(cleartextBytes, null);\n            String encryptedBase64 = Base64.encodeBase64ToString( encrypted );\n            System.out.println(\"Encrypted base64: [\" + encryptedBase64 + \"]\");\n\n            byte[] decrypted = cipher.decrypt(Base64.decodeBase64(encryptedBase64), null);\n            String decryptedString = CodecSupport.toString(decrypted);\n\n            System.out.println(\"Arrays equal? \" + Arrays.equals(cleartextBytes, decrypted));\n\n            System.out.println(\"Decrypted text: [\" + decryptedString + \"]\");\n            System.out.println(\"Decrypted text base64: [\" + Base64.encodeBase64ToString(decrypted) + \"]\");\n        }\n    }\n}\n","lineNo":103}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2008 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.jsecurity.codec.support.CodecSupport;\n\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\n/**\n * Read <a href=\"http://www.owasp.org/index.php/Hashing_Java\">http://www.owasp.org/index.php/Hashing_Java<\/a> for a\n * good article on the benefits of hashing, including what a 'salt' is as well as why multiple hash iterations can\n * be useful.\n * \n * @author Les Hazlewood\n * @since 1.0\n */\npublic abstract class AbstractHash extends CodecSupport implements Hash {\n\n    private byte[] bytes = null;\n\n    //cache string ops to ensure multiple calls won't incur repeated overhead:\n    private String hexEncoded = null;\n    private String base64Encoded = null;\n\n    public AbstractHash() {\n    }\n\n    public AbstractHash(Object source) {\n        this( source, null, 1 );\n    }\n\n    public AbstractHash(Object source, Object salt ) {\n        this( source, salt, 1 );\n    }\n\n    public AbstractHash(Object source, Object salt, int hashIterations ) {\n        byte[] sourceBytes = toBytes( source );\n        byte[] saltBytes = null;\n        if ( salt != null ) {\n            saltBytes = toBytes( salt );\n        }\n        byte[] hashedBytes = hash( sourceBytes, saltBytes, hashIterations );\n        setBytes(hashedBytes);\n    }\n\n    public abstract String getAlgorithmName();\n\n    public byte[] getBytes() {\n        return this.bytes;\n    }\n\n    public void setBytes(byte[] alreadyHashedBytes) {\n        this.bytes = alreadyHashedBytes;\n        this.hexEncoded = null;\n        this.base64Encoded = null;\n    }\n\n    protected MessageDigest getDigest(String algorithmName) {\n        try {\n            return MessageDigest.getInstance(algorithmName);\n        } catch (NoSuchAlgorithmException e) {\n            String msg = \"No native '\" + algorithmName + \"' MessageDigest instance available on the current JVM.\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    protected byte[] hash(byte[] bytes) {\n        return hash( bytes, null, 1 );\n    }\n\n    protected byte[] hash(byte[] bytes, byte[] salt ) {\n        return hash( bytes, salt, 1 );\n    }\n\n    protected byte[] hash(byte[] bytes, byte[] salt, int hashIterations) {\n        MessageDigest md = getDigest(getAlgorithmName());\n        if ( salt != null ) {\n            md.reset();\n            md.update( salt );\n        }\n        byte[] hashed = md.digest(bytes);\n        int iterations = hashIterations - 1; //already hashed once above\n        //iterate remaining number:\n        for (int i = 0; i < iterations; i++) {\n            md.reset();\n            hashed = md.digest(hashed);\n        }\n        return hashed;\n    }\n\n    /**\n     * Simple implementation that merely returns the {@link #toHex() toHex()} value.\n     *\n     * @return the {@link #toHex() toHex()} value.\n     */\n    public String toString() {\n        return toHex();\n    }\n\n    public String toHex() {\n        if (this.hexEncoded == null) {\n            this.hexEncoded = Hex.encodeToString(getBytes());\n        }\n        return this.hexEncoded;\n    }\n\n    public String toBase64() {\n        if (this.base64Encoded == null) {\n            //cache result in case this method is called multiple times.\n            this.base64Encoded = Base64.encodeBase64ToString(getBytes());\n        }\n        return this.base64Encoded;\n    }\n\n    public boolean equals(Object o) {\n        if (o instanceof Hash) {\n            Hash other = (Hash) o;\n            return Arrays.equals(getBytes(), other.getBytes());\n        }\n        return false;\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2008 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.jsecurity.codec.support.CodecSupport;\n\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\n/**\n * @author Les Hazlewood\n * @since 1.0\n */\npublic abstract class AbstractHash extends CodecSupport implements Hash {\n\n    private byte[] bytes = null;\n\n    //cache string ops to ensure multiple calls won't incur repeated overhead:\n    private String hexEncoded = null;\n    private String base64Encoded = null;\n\n    public AbstractHash(){\n    }\n    \n    public AbstractHash( Object source ) {\n        byte[] sourceBytes = toBytes( source );\n        byte[] hashedBytes = hash( sourceBytes );\n        setBytes( hashedBytes );\n    }\n\n    public abstract String getAlgorithmName();\n\n    public byte[] getBytes() {\n        return this.bytes;\n    }\n\n    public void setBytes( byte[] alreadyHashedBytes ) {\n        this.bytes = alreadyHashedBytes;\n        this.hexEncoded = null;\n        this.base64Encoded = null;\n    }\n\n    protected MessageDigest getDigest( String algorithmName ) {\n        try {\n            return MessageDigest.getInstance(algorithmName);\n        } catch (NoSuchAlgorithmException e) {\n            String msg = \"No native '\" + algorithmName + \"' MessageDigest instance available on the current JVM.\";\n            throw new IllegalStateException( msg, e );\n        }\n    }\n\n    protected byte[] hash( byte[] bytes ) {\n        MessageDigest md = getDigest( getAlgorithmName() );\n        return md.digest( bytes );\n    }\n\n    /**\n     * Simple implementation that merely returns the {@link #toHex() toHex()} value.\n     * @return the {@link #toHex() toHex()} value.\n     */\n    public String toString() {\n        return toHex();\n    }\n\n    public String toHex() {\n        if ( this.hexEncoded == null ) {\n            this.hexEncoded = Hex.encodeToString( getBytes() );\n        }\n        return this.hexEncoded;\n    }\n\n    public String toBase64() {\n        if (this.base64Encoded == null) {\n            //cache result in case this method is called multiple times.\n            this.base64Encoded = Base64.encodeBase64ToString( getBytes() );\n        }\n        return this.base64Encoded;\n    }\n\n    public boolean equals( Object o ) {\n        if ( o instanceof Hash ) {\n            Hash other = (Hash)o;\n            return Arrays.equals( getBytes(), other.getBytes() );\n        }\n        return false;\n    }\n}\n","lineNo":107}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2008 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.jsecurity.codec.support.CodecSupport;\n\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\n/**\n * @author Les Hazlewood\n * @since 1.0\n */\npublic abstract class AbstractHash extends CodecSupport implements Hash {\n\n    private byte[] bytes = null;\n\n    //cache string ops to ensure multiple calls won't incur repeated overhead:\n    private String hexEncoded = null;\n    private String base64Encoded = null;\n\n    public AbstractHash(){\n    }\n    \n    public AbstractHash( Object source ) {\n        byte[] sourceBytes = toBytes( source );\n        byte[] hashedBytes = hash( sourceBytes );\n        setBytes( hashedBytes );\n    }\n\n    public abstract String getAlgorithmName();\n\n    public byte[] getBytes() {\n        return this.bytes;\n    }\n\n    public void setBytes( byte[] alreadyHashedBytes ) {\n        this.bytes = alreadyHashedBytes;\n        this.hexEncoded = null;\n        this.base64Encoded = null;\n    }\n\n    protected MessageDigest getDigest( String algorithmName ) {\n        try {\n            return MessageDigest.getInstance(algorithmName);\n        } catch (NoSuchAlgorithmException e) {\n            String msg = \"No native '\" + algorithmName + \"' MessageDigest instance available on the current JVM.\";\n            throw new IllegalStateException( msg, e );\n        }\n    }\n\n    protected byte[] hash( byte[] bytes ) {\n        MessageDigest md = getDigest( getAlgorithmName() );\n        return md.digest( bytes );\n    }\n\n    /**\n     * Simple implementation that merely returns the {@link #toHex() toHex()} value.\n     * @return the {@link #toHex() toHex()} value.\n     */\n    public String toString() {\n        return toHex();\n    }\n\n    public String toHex() {\n        if ( this.hexEncoded == null ) {\n            this.hexEncoded = Hex.encodeToString( getBytes() );\n        }\n        return this.hexEncoded;\n    }\n\n    public String toBase64() {\n        if (this.base64Encoded == null) {\n            //cache result in case this method is called multiple times.\n            this.base64Encoded = Base64.encodeBase64ToString( getBytes() );\n        }\n        return this.base64Encoded;\n    }\n\n    public boolean equals( Object o ) {\n        if ( o instanceof Hash ) {\n            Hash other = (Hash)o;\n            return Arrays.equals( getBytes(), other.getBytes() );\n        }\n        return false;\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2008 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.jsecurity.codec.support.CodecSupport;\n\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\n/**\n * @author Les Hazlewood\n * @since 1.0\n */\npublic abstract class AbstractHash extends CodecSupport implements Hash {\n\n    private byte[] bytes = null;\n\n    //cache string ops to ensure multiple calls won't incur repeated overhead:\n    private String hexEncoded = null;\n    private String base64Encoded = null;\n\n    public AbstractHash(){\n    }\n\n    public AbstractHash( byte[] bytes ) {\n        setBytes( hash( bytes ) );\n    }\n\n    public AbstractHash( char[] chars ) {\n        this( toBytes( chars ) );\n    }\n\n    public AbstractHash( String source ) {\n        this( toBytes( source) );\n    }\n\n    public abstract String getAlgorithmName();\n\n    public byte[] getBytes() {\n        return this.bytes;\n    }\n\n    public void setBytes( byte[] alreadyHashedBytes ) {\n        this.bytes = alreadyHashedBytes;\n        this.hexEncoded = null;\n        this.base64Encoded = null;\n    }\n\n    protected MessageDigest getDigest( String algorithmName ) {\n        try {\n            return MessageDigest.getInstance(algorithmName);\n        } catch (NoSuchAlgorithmException e) {\n            String msg = \"No native '\" + algorithmName + \"' MessageDigest instance available on the current JVM.\";\n            throw new IllegalStateException( msg, e );\n        }\n    }\n\n    protected byte[] hash( byte[] bytes ) {\n        MessageDigest md = getDigest( getAlgorithmName() );\n        return md.digest( bytes );\n    }\n\n    /**\n     * Simple implementation that merely returns the {@link #toHex() toHex()} value.\n     * @return the {@link #toHex() toHex()} value.\n     */\n    public String toString() {\n        return toHex();\n    }\n\n    public String toHex() {\n        if ( this.hexEncoded == null ) {\n            this.hexEncoded = Hex.encodeToString( getBytes() );\n        }\n        return this.hexEncoded;\n    }\n\n    public String toBase64() {\n        if (this.base64Encoded == null) {\n            //cache result in case this method is called multiple times.\n            this.base64Encoded = Base64.encodeBase64ToString( getBytes() );\n        }\n        return this.base64Encoded;\n    }\n\n    public boolean equals( Object o ) {\n        if ( o instanceof Hash ) {\n            Hash other = (Hash)o;\n            return Arrays.equals( getBytes(), other.getBytes() );\n        }\n        return false;\n    }\n}\n","lineNo":52}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.spring.servlet;\n\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.web.WebSecurityManager;\nimport org.jsecurity.web.servlet.SecurityContextFilter;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.web.context.support.WebApplicationContextUtils;\n\nimport javax.servlet.ServletContext;\n\n/**\n * <p>Extension of the {@link SecurityContextFilter} that retrieves the {@link SecurityManager} for the current request\n * from a Spring application context and ensures that the {@link SecurityManager} is available throughout the\n * request.<\/p>\n *\n * <p>In Spring MVC environments, the {@link org.jsecurity.spring.servlet.security.SecurityContextInterceptor} may\n * be used instead of this filter.  This class offers a Servlet filter based alternative to using Spring interceptors.\n * It is useful in Spring enviroments that do not use Spring MVC.<\/p>\n *\n * @deprecated in Spring environments, configure the {@link SpringSecurityManagerListener} instead, and then define the\n * standard {@link SecurityContextFilter SecurityContextFilter}.  This class will be removed before the next final\n * release.\n *\n *\n * @since 0.2\n * @author Les Hazlewood\n */\npublic class SpringSecurityContextFilter extends SecurityContextFilter {\n\n    public static final String SECURITY_MANAGER_BEAN_NAME_PARAM_NAME = \"securityManagerBeanName\";\n    public static final String DEFAULT_SECURITY_MANAGER_BEAN_NAME = \"securityManager\";\n\n    protected String securityManagerBeanName = DEFAULT_SECURITY_MANAGER_BEAN_NAME;\n\n    public String getSecurityManagerBeanName() {\n        return securityManagerBeanName;\n    }\n\n    public void setSecurityManagerBeanName( String securityManagerBeanName ) {\n        this.securityManagerBeanName = securityManagerBeanName;\n    }\n\n    public void onFilterConfigSet() throws Exception {\n        String beanName = getFilterConfig().getInitParameter( SECURITY_MANAGER_BEAN_NAME_PARAM_NAME );\n        if ( beanName != null ) {\n            setSecurityManagerBeanName( beanName );\n        }\n        super.onFilterConfigSet();\n    }\n\n    private void assertWebSecurityManager( Object secMgrBean ) {\n        if ( secMgrBean == null ) {\n            String msg = \"There is no \" + WebSecurityManager.class.getName() + \" instance bound in in the \" +\n                    \"Spring WebApplicationContext under the name of '\" + getSecurityManagerBeanName() + \"'.\"  +\n                    \"  Please ensure that such a bean exists, or you can change which bean is accessed by \" +\n                    \"setting the \" + getClass().getName() + \"#SecurityManagerBeanName attribute.\";\n            throw new IllegalStateException( msg );\n        }\n        if ( !(secMgrBean instanceof WebSecurityManager)) {\n            String msg = \"The \" + getClass().getName() + \" class requires the web application's \" +\n                    \"SecurityManager instance to be of type [\" + WebSecurityManager.class.getName() + \" ].\";\n            throw new IllegalStateException( msg );\n        }\n    }\n\n    protected WebSecurityManager getSecurityManager() {\n        ServletContext sc = getFilterConfig().getServletContext();\n        ApplicationContext appCtx = WebApplicationContextUtils.getRequiredWebApplicationContext( sc );\n        Object secMgrBean = appCtx.getBean( getSecurityManagerBeanName() );\n        assertWebSecurityManager( secMgrBean );\n        return (WebSecurityManager)secMgrBean;\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.spring.servlet;\n\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.web.WebSecurityManager;\nimport org.jsecurity.web.servlet.SecurityContextFilter;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.web.context.support.WebApplicationContextUtils;\n\nimport javax.servlet.ServletContext;\n\n/**\n * <p>Extension of the {@link SecurityContextFilter} that retrieves the {@link SecurityManager} for the current request\n * from a Spring application context and ensures that the {@link SecurityManager} is available throughout the\n * request.<\/p>\n *\n * <p>In Spring MVC environments, the {@link org.jsecurity.spring.servlet.security.SecurityContextInterceptor} may\n * be used instead of this filter.  This class offers a Servlet filter based alternative to using Spring interceptors.\n * It is useful in Spring enviroments that do not use Spring MVC.<\/p>\n *\n * @deprecated in Spring environments, configure the {@link SpringSecurityManagerListener} instead, and then define the\n * standard {@link SecurityContextFilter SecurityContextFilter}.  This class will be removed before the next final\n * release.\n *\n *\n * @since 0.2\n * @author Les Hazlewood\n */\npublic class SpringSecurityContextFilter extends SecurityContextFilter {\n\n    public static final String SECURITY_MANAGER_BEAN_NAME_PARAM_NAME = \"securityManagerBeanName\";\n    public static final String DEFAULT_SECURITY_MANAGER_BEAN_NAME = \"securityManager\";\n\n    protected String securityManagerBeanName = DEFAULT_SECURITY_MANAGER_BEAN_NAME;\n\n    public String getSecurityManagerBeanName() {\n        return securityManagerBeanName;\n    }\n\n    public void setSecurityManagerBeanName( String securityManagerBeanName ) {\n        this.securityManagerBeanName = securityManagerBeanName;\n    }\n\n    public void onFilterConfigSet() throws Exception {\n        String beanName = getFilterConfig().getInitParameter( SECURITY_MANAGER_BEAN_NAME_PARAM_NAME );\n        if ( beanName != null ) {\n            setSecurityManagerBeanName( beanName );\n        }\n        super.onFilterConfigSet();\n    }\n\n    protected WebSecurityManager getSecurityManager() {\n        ServletContext sc = getFilterConfig().getServletContext();\n        ApplicationContext appCtx = WebApplicationContextUtils.getRequiredWebApplicationContext( sc );\n        return (WebSecurityManager)appCtx.getBean( getSecurityManagerBeanName() );\n    }\n}\n","lineNo":93}
{"Refactored Sample":"package org.jsecurity.spring.servlet;\n\nimport org.jsecurity.web.WebSecurityManager;\nimport org.jsecurity.web.servlet.SecurityManagerListener;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.web.context.support.WebApplicationContextUtils;\n\n/**\n * TODO class JavaDoc\n *\n * @author Les Hazlewood\n */\npublic class SpringSecurityManagerListener extends SecurityManagerListener {\n\n    public static final String SECURITY_MANAGER_BEAN_NAME_PARAM_NAME = \"securityManagerBeanName\";\n    public static final String DEFAULT_SECURITY_MANAGER_BEAN_NAME = \"securityManager\";\n\n    protected String securityManagerBeanName = DEFAULT_SECURITY_MANAGER_BEAN_NAME;\n\n    public String getSecurityManagerBeanName() {\n        return securityManagerBeanName;\n    }\n\n    public void setSecurityManagerBeanName( String securityManagerBeanName ) {\n        this.securityManagerBeanName = securityManagerBeanName;\n    }\n\n    public void init() {\n        String beanName = getServletContext().getInitParameter( SECURITY_MANAGER_BEAN_NAME_PARAM_NAME );\n        if ( beanName != null ) {\n            setSecurityManagerBeanName( beanName );\n        }\n        super.init();\n    }\n\n    private void assertWebSecurityManager( Object secMgrBean ) {\n        if ( secMgrBean == null ) {\n            String msg = \"There is no \" + WebSecurityManager.class.getName() + \" instance bound in in the \" +\n                    \"Spring WebApplicationContext under the name of '\" + getSecurityManagerBeanName() + \"'.\"  +\n                    \"  Please ensure that such a bean exists, or you can change which bean is accessed by \" +\n                    \"setting the \" + getClass().getName() + \"#SecurityManagerBeanName attribute.\";\n            throw new IllegalStateException( msg );\n        }\n        if ( !(secMgrBean instanceof WebSecurityManager)) {\n            String msg = \"The \" + getClass().getName() + \" class requires the web application's \" +\n                    \"SecurityManager instance to be of type [\" + WebSecurityManager.class.getName() + \" ].\";\n            throw new IllegalStateException( msg );\n        }\n    }\n\n    public WebSecurityManager getSecurityManager() {\n        ApplicationContext appCtx = WebApplicationContextUtils.getRequiredWebApplicationContext( getServletContext() );\n        Object secMgrBean = appCtx.getBean( getSecurityManagerBeanName() );\n        assertWebSecurityManager( secMgrBean );\n        return (WebSecurityManager)secMgrBean;\n    }\n}\n","Smelly Sample":"package org.jsecurity.spring.servlet;\n\nimport org.jsecurity.web.WebSecurityManager;\nimport org.jsecurity.web.servlet.SecurityManagerListener;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.web.context.support.WebApplicationContextUtils;\n\n/**\n * TODO class JavaDoc\n *\n * @author Les Hazlewood\n */\npublic class SpringSecurityManagerListener extends SecurityManagerListener {\n\n    public static final String SECURITY_MANAGER_BEAN_NAME_PARAM_NAME = \"securityManagerBeanName\";\n    public static final String DEFAULT_SECURITY_MANAGER_BEAN_NAME = \"securityManager\";\n\n    protected String securityManagerBeanName = DEFAULT_SECURITY_MANAGER_BEAN_NAME;\n\n    public String getSecurityManagerBeanName() {\n        return securityManagerBeanName;\n    }\n\n    public void setSecurityManagerBeanName( String securityManagerBeanName ) {\n        this.securityManagerBeanName = securityManagerBeanName;\n    }\n\n    public void init() {\n        String beanName = getServletContext().getInitParameter( SECURITY_MANAGER_BEAN_NAME_PARAM_NAME );\n        if ( beanName != null ) {\n            setSecurityManagerBeanName( beanName );\n        }\n        super.init();\n    }\n\n    public WebSecurityManager getSecurityManager() {\n        ApplicationContext appCtx = WebApplicationContextUtils.getRequiredWebApplicationContext( getServletContext() );\n        return (WebSecurityManager)appCtx.getBean( getSecurityManagerBeanName() );\n    }\n}\n","lineNo":53}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.DefaultSecurityManager;\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.session.SessionFactory;\nimport org.jsecurity.session.SessionFactoryAware;\nimport org.jsecurity.util.Destroyable;\nimport org.jsecurity.util.Initializable;\nimport org.jsecurity.web.WebSessionFactory;\nimport org.jsecurity.web.support.DefaultWebSessionFactory;\nimport org.jsecurity.web.support.HttpContainerWebSessionFactory;\n\nimport java.util.List;\n\n/**\n * Utility superclass for a web application that consolidates SecurityManager acquisition and/or creation logic during\n * application startup.  Subclasses are expected to utilize startup mechanisms/APIs supported by the Servlet Container\n * (for example, <tt>ServletContextListener<\/tt>, <tt>Servlet<\/tt>, etc), and call the methods in this class to\n * reduce the amount of code required.\n *\n * <p><b>Clean Architecture Note:<\/b> A JSecurity <tt>SecurityManager<\/tt> is really considered a business-tier\n * component and should be created in the application's business-tier configuration (e.g. Spring, Pico, Guice, JBoss,\n * etc) if such a configuration exists.  If this business-tier does exist, subclasses of this one should acquire and\n * return that instance by overriding the {@link #getSecurityManager() getSecurityManager()} method.<\/p>\n *\n * <p>If there is no business-tier, i.e. this is a 'pure' web application, then a <tt>SecurityManager<\/tt> instance\n * needs to be created (instantiated) explicitly.  This implementation will do that automatically by default, but if\n * you wish to change the default logic, you'll need to override the\n * {@link #createSecurityManager() createSecurityManager()} method.  Subclasses with a proper business tier as\n * described above do not need to worry about doing this.\n *\n * @author Les Hazlewood\n * @see #getSecurityManager\n * @see #createSecurityManager\n * @since 0.2\n */\npublic class SecurityManagerLoader extends ServletContextSupport {\n\n    public static final String SECURITY_MANAGER_CONTEXT_KEY = SecurityManagerLoader.class.getName() + \"_SECURITY_MANAGER\";\n    public static final String WEB_SESSION_FACTORY_CONTEXT_KEY = WebSessionFactory.class.getName() + \"_WEB_SESSION_FACTORY\";\n\n    private WebSessionFactory webSessionFactory = null;\n    private boolean webSessionFactoryImplicitlyCreated = false;\n    private SecurityManager securityManager = null;\n    private boolean securityManagerImplicitlyCreated = false;\n\n    public void init() {\n        if (getServletContext() == null) {\n            throw new IllegalStateException(\"servletContext property must be set.\");\n        }\n        applySessionMode();\n        ensureSecurityManager();\n    }\n\n    public WebSessionFactory getWebSessionFactory() {\n        return this.webSessionFactory;\n    }\n\n    public SecurityManager getSecurityManager() {\n        return this.securityManager;\n    }\n\n    protected List<Realm> getRealms() {\n        return null;\n    }\n\n    protected Realm getRealm() {\n        return null;\n    }\n\n    protected void assertSessionFactoryAware(SecurityManager securityManager) {\n        if (!(securityManager instanceof SessionFactoryAware)) {\n            String msg = \"The \" + getClass().getName() + \" class requires that the SecurityManager instance must \" +\n                \"implement the \" + SessionFactoryAware.class.getName() + \" interface.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    protected void bind( String name, String key, Object value ) {\n        if ( value == null ) {\n            throw new IllegalArgumentException( name + \" argument cannot be null.\" );\n        }\n        if ( getAttribute( key ) != null ) {\n            String msg = name + \" already bound to ServletContext.  Please check your configuration to ensure \" +\n                \"you don't have mutliple SecurityManager Loaders configured (listener, servlet, etc).\";\n            throw new IllegalStateException(msg);    \n        }\n        setAttribute( key, value );\n    }\n\n    protected void bind( WebSessionFactory webSessionFactory ) {\n        bind( \"webSessionFactory\", WEB_SESSION_FACTORY_CONTEXT_KEY, webSessionFactory );\n    }\n\n    protected void bind( SecurityManager securityManager ) {\n        bind( \"securityManager\", SECURITY_MANAGER_CONTEXT_KEY, securityManager );\n    }\n\n    private WebSessionFactory createWebSessionFactory() {\n        if ( isWebSessions() ) {\n            return new HttpContainerWebSessionFactory();\n        } else {\n            return new DefaultWebSessionFactory();\n        }\n    }\n\n    protected SecurityManager createSecurityManager() {\n        WebSessionFactory webSessionFactory = getWebSessionFactory();\n        if ( !(webSessionFactory instanceof SessionFactory ) ) {\n            String msg = \"If you do not configure a SecurityManager, the \" + getClass().getName() + \" implementation \" +\n                \"expects the WebSessionFactory instance to also implement the \" +\n                SessionFactory.class.getName() + \" interface as well.\";\n            throw new IllegalStateException( msg );\n        }\n        DefaultSecurityManager defaultSecMgr = new DefaultSecurityManager();\n        defaultSecMgr.setSessionFactory( (SessionFactory)webSessionFactory );\n\n        if ( !isWebSessions() ) {\n            // not using web-only sessions - need JSecurity's more robust Session support,\n            // so make sure the SessionManagement infrastructure is eagerly initialized w/ the\n            // SecurityManager to catch errors early:\n            defaultSecMgr.setLazySessions(false);\n        }\n\n        List<Realm> realms = getRealms();\n\n        if (realms != null && !realms.isEmpty()) {\n            defaultSecMgr.setRealms(realms);\n        } else {\n            Realm realm = getRealm();\n            if (realm != null) {\n                defaultSecMgr.setRealm(realm);\n            }\n        }\n\n        defaultSecMgr.init();\n\n        return defaultSecMgr;\n    }\n\n    public void ensureWebSessionFactory() {\n        WebSessionFactory webSessionFactory = getWebSessionFactory();\n\n        if (webSessionFactory == null) {\n            SecurityManager securityManager = getSecurityManager();\n            if (securityManager != null) {\n                assertSessionFactoryAware(securityManager);\n                SessionFactory sf = ((SessionFactoryAware) securityManager).getSessionFactory();\n                if (!(sf instanceof WebSessionFactory)) {\n                    String msg = \"The \" + getClass().getName() + \" requires that the configured \" +\n                        \"SecurityManager's getSessionFactory() method return an instance of \" +\n                        WebSessionFactory.class.getName() + \" in addition to the regular SessionFactory interface\";\n                    throw new IllegalStateException(msg);\n                }\n                this.webSessionFactory = (WebSessionFactory) sf;\n            } else {\n                //create a web session factory from scratch and make it available for injection into the\n                //the SecurityManager that will be created after this method call.\n                webSessionFactory = createWebSessionFactory();\n                if (webSessionFactory == null) {\n                    String msg = \"webSessionFactory instance returned from createWebSessionFactory() call cannot \" +\n                        \"be null.\";\n                    throw new IllegalStateException(msg);\n                }\n                if (!(webSessionFactory instanceof SessionFactory)) {\n                    String msg = \"The \" + getClass().getName() + \" implementation requires the WebSessionFactory \" +\n                        \"instance returned from createWebSessionFactory() to implement the \" +\n                        SessionFactory.class.getName() + \" interface if you do not configure a SecurityManager\";\n                    throw new IllegalStateException(msg);\n                }\n                if ( webSessionFactory instanceof Initializable ) {\n                    try {\n                        ((Initializable)webSessionFactory).init();\n                    } catch (Exception e) {\n                        String msg = \"Unable to cleanly initialize the implicitly created WebSessionFactory \" +\n                            \"instance.  Please verify your implementation's init() method.\";\n                        throw new IllegalStateException( msg, e );\n                    }\n                }\n\n                this.webSessionFactory = webSessionFactory;\n                this.webSessionFactoryImplicitlyCreated = true;\n            }\n        }\n\n        bind(webSessionFactory);\n    }\n\n    public void ensureSecurityManager() {\n        ensureWebSessionFactory();\n        SecurityManager securityManager = getSecurityManager();\n        if (securityManager == null) {\n            securityManager = createSecurityManager();\n            if (securityManager == null) {\n                String msg = \"securityManager instance returned from createSecurityManager() call cannot \" +\n                    \"be null.\";\n                throw new IllegalStateException(msg);\n            }\n            this.securityManager = securityManager;\n            this.securityManagerImplicitlyCreated = true;\n        }\n\n        bind(securityManager);\n    }\n\n    protected void destroyWebSessionFactory() {\n        if (this.webSessionFactoryImplicitlyCreated && this.webSessionFactory != null) {\n            if (this.webSessionFactory instanceof Destroyable) {\n                try {\n                    ((Destroyable) this.webSessionFactory).destroy();\n                } catch (Exception e) {\n                    if (log.isWarnEnabled()) {\n                        log.warn(\"Unable to cleanly destroy implicitly created WebSessionFactory instance.  \" +\n                            \"Ignoring and continuing shut-down.\", e);\n                    }\n                }\n            }\n        }\n        removeAttribute(WEB_SESSION_FACTORY_CONTEXT_KEY);\n    }\n\n    protected void destroySecurityManager() {\n        if (this.securityManagerImplicitlyCreated && this.securityManager != null) {\n            if (this.securityManager instanceof Destroyable) {\n                try {\n                    ((Destroyable) this.securityManager).destroy();\n                } catch (Exception e) {\n                    if (log.isWarnEnabled()) {\n                        log.warn(\"Unable to cleanly destroy implicitly created SecurityManager instance.  \" +\n                            \"Ignoring and continuing shut-down.\", e);\n                    }\n                }\n            }\n        }\n        removeAttribute(SECURITY_MANAGER_CONTEXT_KEY);\n    }\n\n    public void destroy() {\n        destroySecurityManager();\n        destroyWebSessionFactory();\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.web.servlet;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.DefaultSecurityManager;\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.util.Destroyable;\n\nimport javax.servlet.ServletContext;\nimport java.util.List;\n\n/**\n * Utility superclass for a web application that consolidates SecurityManager acquisition and/or creation logic during\n * application startup.  Subclasses are expected to utilize startup mechanisms/APIs supported by the Servlet Container\n * (for example, <tt>ServletContextListener<\/tt>, <tt>Servlet<\/tt>, etc), and call the methods in this class to\n * reduce the amount of code required.\n *\n * <p><b>Clean Architecture Note:<\/b> A JSecurity <tt>SecurityManager<\/tt> is really considered a business-tier\n * component and should be created in the application's business-tier configuration (e.g. Spring, Pico, Guice, JBoss, \n * etc) if such a configuration exists.  If this business-tier does exist, subclasses of this one should acquire and\n * return that instance by overriding the {@link #getSecurityManager() getSecurityManager()} method.<\/P>\n *\n * <p>If there is no business-tier, i.e. this is a 'pure' web application, then a <tt>SecurityManager<\/tt> instance\n * needs to be created (instantiated) explicitly.  This implementation will do that automatically by default, but if\n * you wish to change the default logic, you'll need to override the\n * {@link #createSecurityManager() createSecurityManager()} method.  Subclasses with a proper business tier as\n * described above do not need to worry about doing this.\n *\n * @see #getSecurityManager\n * @see #createSecurityManager\n *\n * @since 0.2\n * @author Les Hazlewood\n */\npublic class SecurityManagerLoader extends ServletContextSupport {\n\n    public static final String SECURITY_MANAGER_CONTEXT_KEY = SecurityManagerLoader.class.getName() + \"_SECURITY_MANAGER\";\n\n    protected final transient Log log = LogFactory.getLog( getClass() );\n\n    private SecurityManager securityManager = null;\n    private boolean securityManagerImplicitlyCreated = false;\n\n    public void init() {\n        if ( getServletContext() == null ) {\n            throw new IllegalStateException( \"servletContext property must be set.\" );\n        }\n        applySessionMode();\n        ensureSecurityManager();\n    }\n\n    public void ensureSecurityManager() {\n        SecurityManager securityManager = getSecurityManager();\n        if ( securityManager == null ) {\n            this.securityManager = createSecurityManager();\n            this.securityManagerImplicitlyCreated = true;\n        }\n        bindToServletContext( securityManager );\n    }\n\n    protected void bindToServletContext( SecurityManager securityManager ) {\n        if ( securityManager == null ) {\n            throw new IllegalArgumentException( \"securityManager argument cannot be null.\" );\n        }\n        ServletContext servletContext = getServletContext();\n        if ( servletContext == null ) {\n            String msg = \"ServletContext property must be set via the setServletContext method.\";\n            throw new IllegalStateException( msg );\n        }\n        if ( servletContext.getAttribute( SECURITY_MANAGER_CONTEXT_KEY ) != null ) {\n            String msg = \"SecurityManager already bound to ServletContext.  Please check your configuration to ensure \" +\n                \"you don't have mutliple SecurityManager Loaders configured (listener, servlet, etc).\";\n            throw new IllegalStateException( msg );\n        }\n        servletContext.setAttribute( SECURITY_MANAGER_CONTEXT_KEY, securityManager );\n    }\n\n    protected SecurityManager createSecurityManager() {\n        DefaultSecurityManager defaultSecMgr = new DefaultSecurityManager();\n        this.securityManagerImplicitlyCreated = true;\n\n        if ( !getSessionMode().equals(WEB_SESSION_MODE) ) {\n            // not using web-only sessions - need JSecurity's more robust Session support,\n            // so make sure the SessionManagement infrastructure is eagerly initialized w/ the \n            // SecurityManager to catch errors early:\n            defaultSecMgr.setLazySessions( false );\n        }\n\n        List<Realm> realms = getRealms();\n\n        if ( realms != null && !realms.isEmpty() ) {\n            defaultSecMgr.setRealms( realms );\n        } else {\n            Realm realm = getRealm();\n            if ( realm != null ) {\n                defaultSecMgr.setRealm( realm );\n            }\n        }\n\n        defaultSecMgr.init();\n\n        return defaultSecMgr;\n    }\n\n    public SecurityManager getSecurityManager() {\n        return this.securityManager;\n    }\n\n    protected List<Realm> getRealms() {\n        return null;\n    }\n\n    protected Realm getRealm() {\n        return null;\n    }\n\n    protected void destroySecurityManager() {\n        ServletContext servletContext = getServletContext();\n        \n        if ( this.securityManagerImplicitlyCreated && this.securityManager != null )  {\n            if ( this.securityManager instanceof Destroyable ) {\n                try {\n                    ((Destroyable)this.securityManager).destroy();\n                } catch ( Exception e ) {\n                    if ( log.isWarnEnabled() ) {\n                        log.warn( \"Unable to cleanly destroy implicitly created SecurityManager instance.  \" +\n                            \"Ignoring and continuing shut-down.\", e );\n                    }\n                }\n            }\n        }\n        servletContext.removeAttribute( SECURITY_MANAGER_CONTEXT_KEY );\n    }\n}\n","lineNo":216}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.web.support;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.SessionManager;\nimport org.jsecurity.session.support.DefaultSessionFactory;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.WebSessionFactory;\nimport org.jsecurity.web.WebStore;\nimport org.jsecurity.web.servlet.JSecurityHttpServletRequest;\nimport org.jsecurity.web.servlet.JSecurityHttpSession;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\nimport java.net.InetAddress;\n\n/**\n * Default JSecurity implementation of the {@link WebSessionFactory} interface.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class DefaultWebSessionFactory extends DefaultSessionFactory implements WebSessionFactory {\n\n    private boolean enforceSessionOnGet = false;\n\n    /**\n     * Property specifying if, after a session object is acquired from the request, if that session should be\n     * validated to ensure the starting origin of the session is the same as the incoming request.\n     */\n    private boolean validateRequestOrigin = false; //default\n\n    protected CookieStore<Serializable> cookieSessionIdStore = null;\n    protected RequestParamStore<Serializable> reqParamSessionIdStore = null;\n\n    public DefaultWebSessionFactory() {\n    }\n\n    public DefaultWebSessionFactory( SessionManager sessionManager ) {\n        super( sessionManager );\n    }\n\n    /**\n     * Returns the current session enforcement policy for the\n     * {@link #getSession(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}\n     * method - please see that method's JavaDoc for usage information.\n     *\n     * <p>The default value is <tt>false<\/tt>.\n     *\n     * @return the current session enforcement policy for the {@link #getSession(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} method.\n     *\n     */\n    public boolean isEnforceSessionOnGet() {\n        return enforceSessionOnGet;\n    }\n\n    /**\n     * Specifies session enforcemnt policy for the {@link #getSession(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}\n     * method - please see that method's JavaDoc for usage information.\n     *\n     * <p>The default value is <tt>false<\/tt>.\n     *\n     * @param enforceSessionOnGet the session enforcement policy for the {@link #getSession(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} method.\n     */\n    public void setEnforceSessionOnGet( boolean enforceSessionOnGet ) {\n        this.enforceSessionOnGet = enforceSessionOnGet;\n    }\n\n    public CookieStore<Serializable> getCookieSessionIdStore() {\n        return cookieSessionIdStore;\n    }\n\n    public void setCookieSessionIdStore( CookieStore<Serializable> cookieSessionIdStore ) {\n        this.cookieSessionIdStore = cookieSessionIdStore;\n    }\n\n    public RequestParamStore<Serializable> getReqParamSessionIdStore() {\n        return reqParamSessionIdStore;\n    }\n\n    public void setReqParamSessionIdStore( RequestParamStore<Serializable> reqParamSessionIdStore ) {\n        this.reqParamSessionIdStore = reqParamSessionIdStore;\n    }\n\n    /**\n     * If set to <tt>true<\/tt>, this <tt>WebSessionFactory<\/tt> will ensure that any\n     * <tt>HttpRequest<\/tt> attempting\n     * to join a session (i.e. via {@link #getSession getSession} must have the same\n     * IP Address of the <tt>HttpRequest<\/tt> that started the session.\n     * <p/>\n     * <p> If set to <tt>false<\/tt>, any <tt>HttpRequest<\/tt> with a reference to a valid\n     * session id may acquire that <tt>Session<\/tt>.\n     * <p/>\n     * <p>Although convenient, this should only be enabled in environments where the\n     * system can <em>guarantee<\/em> that each IP address represents one and only one\n     * machine accessing the system.\n     * <p/>\n     * <p>Public websites are not good candidates for enabling this\n     * feature since many browser clients often sit behind NAT routers (in\n     * which case many machines are viewed to come from the same IP, thereby making this\n     * validation check useless).  Also, some internet service providers (e.g. AOL) may change a\n     * client's IP in mid-session, making subsequent requests appear to come from a different\n     * location.  Again, this feature should only be enabled where IP Addresses can be guaranteed a\n     * 1-to-1 relationship with a user's session.\n     * <p/>\n     * <p>For the reasons specified above, this property is <tt>false<\/tt> by default.\n     *\n     * @return true if this factory will verify each HttpRequest joining a session\n     */\n    public boolean isValidateRequestOrigin() {\n        return validateRequestOrigin;\n    }\n\n    /**\n     * Sets whether or not a request's origin will be validated when accessing a session.  See\n     * the {@link #isValidateRequestOrigin} JavaDoc for an in-depth explanation of this property.\n     *\n     * @param validateRequestOrigin whether or not to validate the request's origin when accessing\n     *                              a session.\n     * @see #isValidateRequestOrigin\n     */\n    public void setValidateRequestOrigin( boolean validateRequestOrigin ) {\n        this.validateRequestOrigin = validateRequestOrigin;\n    }\n\n    public void init() {\n        super.init();\n        ensureCookieSessionIdStore();\n        ensureRequestParamSessionIdStore();\n    }\n\n    protected void ensureCookieSessionIdStore() {\n        CookieStore<Serializable> cookieStore = getCookieSessionIdStore();\n        if ( cookieStore == null ) {\n            cookieStore = new CookieStore<Serializable>( JSecurityHttpSession.DEFAULT_SESSION_ID_NAME );\n            cookieStore.setCheckRequestParams( false );\n            setCookieSessionIdStore( cookieStore );\n        }\n    }\n\n    protected void ensureRequestParamSessionIdStore() {\n        RequestParamStore<Serializable> reqParamStore = getReqParamSessionIdStore();\n        if ( reqParamStore == null ) {\n            reqParamStore = new RequestParamStore<Serializable>( JSecurityHttpSession.DEFAULT_SESSION_ID_NAME );\n            setReqParamSessionIdStore( reqParamStore );\n        }\n    }\n\n    protected void validateSessionOrigin( ServletRequest request, Session session )\n        throws HostUnauthorizedException {\n        InetAddress requestIp = SecurityWebSupport.getInetAddress( request );\n        InetAddress originIp = session.getHostAddress();\n        Serializable sessionId = session.getSessionId();\n\n        if ( originIp == null ) {\n            if ( requestIp != null ) {\n                String msg = \"No IP Address was specified when creating session with id [\" +\n                    sessionId + \"].  Attempting to access session from \" +\n                    \"IP [\" + requestIp + \"].  Origin IP and request IP must match.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        } else {\n            if ( requestIp != null ) {\n                if ( !requestIp.equals( originIp ) ) {\n                    String msg = \"Session with id [\" + sessionId + \"] originated from [\" +\n                        originIp + \"], but the current HttpServletRequest originated \" +\n                        \"from [\" + requestIp + \"].  Disallowing session access: \" +\n                        \"session origin and request origin must match to allow access.\";\n                    throw new HostUnauthorizedException( msg );\n                }\n\n            } else {\n                String msg = \"No IP Address associated with the current HttpServletRequest.  \" +\n                    \"Session with id [\" + sessionId + \"] originated from \" +\n                    \"[\" + originIp + \"].  Request IP must match the session's origin \" +\n                    \"IP in order to gain access to that session.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        }\n    }\n\n    protected void storeSessionId( Serializable currentId, ServletRequest request, ServletResponse response ) {\n        if ( currentId == null ) {\n            String msg = \"sessionId cannot be null when persisting for subsequent requests.\";\n            throw new IllegalArgumentException( msg );\n        }\n        //ensure that the id has been set in the idStore, or if it already has, that it is not different than the\n        //'real' session value:\n        Serializable existingId = retrieveSessionId( request, response );\n        if ( existingId == null || !currentId.equals( existingId ) ) {\n            getCookieSessionIdStore().storeValue( currentId, request, response );\n        }\n    }\n\n    protected Serializable retrieveSessionId( ServletRequest request, ServletResponse response ) {\n        WebStore<Serializable> cookieSessionIdStore = getCookieSessionIdStore();\n        Serializable id = cookieSessionIdStore.retrieveValue( request, response );\n        if ( id != null ) {\n            request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                JSecurityHttpServletRequest.COOKIE_SESSION_ID_SOURCE );\n        } else {\n            id = getReqParamSessionIdStore().retrieveValue( request, response );\n            if ( id != null ) {\n                request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                    JSecurityHttpServletRequest.URL_SESSION_ID_SOURCE );\n            }\n        }\n        return id;\n    }\n\n    protected Session doGetSession( ServletRequest request, ServletResponse response ) {\n\n        Session session = null;\n        Serializable sessionId = retrieveSessionId( request, response );\n\n        if ( sessionId != null ) {\n            request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID, sessionId );\n            session = getSession( sessionId );\n            if ( isValidateRequestOrigin() ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"Validating request origin against session origin\" );\n                }\n                validateSessionOrigin( request, session );\n            }\n            if ( session != null ) {\n                request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE );\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No JSecurity session id associated with the given \" +\n                    \"HttpServletRequest.  A Session will not be returned.\" );\n            }\n        }\n        return session;\n\n\n    }\n\n    public Session start(InetAddress hostAddress) throws HostUnauthorizedException, IllegalArgumentException {\n        ServletRequest request = ThreadContext.getServletRequest();\n        ServletResponse response = ThreadContext.getServletResponse();\n        return start( request, response, hostAddress );\n    }\n\n    /**\n     * Starts a brand new Session, associates it with the specified request, and makes that session available for\n     * future requests via a Cookie or URL rewriting as specified by the Servlet Specification.\n     *\n     * @param request incoming ServletRequest\n     * @param response outgoing ServletResponse\n     * @return a new Session for the specified request/response pair.\n     */\n    public Session start( ServletRequest request, ServletResponse response ) {\n        InetAddress clientAddress = SecurityWebSupport.getInetAddress( request );\n        Session s = start( request, response, clientAddress );\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Started new Session with id [\" + s.getSessionId() );\n        }\n        return s;\n    }\n\n    protected Session start( ServletRequest request, ServletResponse response, InetAddress inetAddress ) {\n        Session s = super.start( inetAddress );\n        storeSessionId( s.getSessionId(), request, response );\n        request.removeAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE );\n        request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_IS_NEW, Boolean.TRUE );\n        return s;\n    }\n\n    /**\n     * Returns the Session associated with the specified request, <tt>null<\/tt>, or a new Session, depending on the\n     * enforcement policy in effect as specified by the {@link #setEnforceSessionOnGet(boolean) enforceSessionOnGet}\n     * property.\n     *\n     * <p>This method implementation functions as follows:<\/p>\n     *\n     * <ol>\n     *   <li>If the the incoming <tt>request<\/tt> references a valid, non-expired session, it will be returned\n     *       immediately<\/li>\n     *   <li>If the incoming <tt>request<\/tt> references an invalid, expired, or non-existent Session, and the\n     *       <tt>enforceSessionOnGet<\/tt> property is <tt>true<\/tt>, then a new Session will be created via the\n     *       {@link #start(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} method and returned.<\/li>\n     *   <li>If the incoming <tt>request<\/tt> references an invalid, expired or non-existent Session, and the\n     *       <tt>enforceSessionOnGet<\/tt> property is <tt>false<\/tt>, then <tt>null<\/tt> is returned.<\/li>\n     * <\/ol>\n     *\n     * <p>The default value of <tt>enforceSessionOnGet<\/tt> is <tt>true<\/tt> to guarantee a Session for an\n     * HttpRequest if one is desired.\n     *\n     * @param request  incoming servlet request\n     * @param response outgoing servlet response\n     * @return the Session associated with the incoming request, <tt>null<\/tt> or a new Session, depending on the\n     * {@link #setEnforceSessionOnGet(boolean) enforceSessionOnGet} policy in effect.\n     * @throws org.jsecurity.session.InvalidSessionException if the associated Session has expired prior to invoking this method.\n     * @throws org.jsecurity.authz.AuthorizationException  if the caller is not authorized to access the session associated with the request.\n     */\n    public final Session getSession( ServletRequest request, ServletResponse response )\n        throws InvalidSessionException, AuthorizationException {\n\n        Session session;\n        try {\n            session = doGetSession( request, response );\n            if ( session == null && isEnforceSessionOnGet() ) {\n                session = start( request, response );\n            }\n        } catch ( InvalidSessionException ise ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Request Session is invalid, message: [\" + ise.getMessage() + \"].\" );\n            }\n            session = handleInvalidSession( request, response, ise );\n        }\n\n        return session;\n    }\n\n    protected Session handleInvalidSession( ServletRequest request,\n                                            ServletResponse response,\n                                            InvalidSessionException ise ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Handling invalid session associated with the request.\" );\n        }\n\n        Session session = null;\n\n        if ( isEnforceSessionOnGet() ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Configured to create a new session on invalid session - attempting to start a new session...\" );\n            }\n            session = start( request, response );\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Configured to _not_ start a new session after an invalid session - returning null.\" );\n            }\n        }\n\n        return session;\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.web.support;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.SessionManager;\nimport org.jsecurity.session.support.DefaultSessionFactory;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.WebSessionFactory;\nimport org.jsecurity.web.WebStore;\nimport org.jsecurity.web.servlet.JSecurityHttpServletRequest;\nimport org.jsecurity.web.servlet.JSecurityHttpSession;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\nimport java.net.InetAddress;\n\n/**\n * Default JSecurity implementation of the {@link WebSessionFactory} interface.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class DefaultWebSessionFactory extends DefaultSessionFactory implements WebSessionFactory {\n\n    private boolean enforceSessionOnGet = false;\n\n    /**\n     * Property specifying if, after a session object is acquired from the request, if that session should be\n     * validated to ensure the starting origin of the session is the same as the incoming request.\n     */\n    private boolean validateRequestOrigin = false; //default\n\n    protected CookieStore<Serializable> cookieSessionIdStore = null;\n    protected RequestParamStore<Serializable> reqParamSessionIdStore = null;\n\n    public DefaultWebSessionFactory() {\n    }\n\n    public DefaultWebSessionFactory( SessionManager sessionManager ) {\n        super( sessionManager );\n    }\n\n    /**\n     * Returns the current session enforcement policy for the\n     * {@link #getSession(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}\n     * method - please see that method's JavaDoc for usage information.\n     *\n     * <p>The default value is <tt>false<\/tt>.\n     *\n     * @return the current session enforcement policy for the {@link #getSession(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} method.\n     *\n     */\n    public boolean isEnforceSessionOnGet() {\n        return enforceSessionOnGet;\n    }\n\n    /**\n     * Specifies session enforcemnt policy for the {@link #getSession(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}\n     * method - please see that method's JavaDoc for usage information.\n     *\n     * <p>The default value is <tt>false<\/tt>.\n     *\n     * @param enforceSessionOnGet the session enforcement policy for the {@link #getSession(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} method.\n     */\n    public void setEnforceSessionOnGet( boolean enforceSessionOnGet ) {\n        this.enforceSessionOnGet = enforceSessionOnGet;\n    }\n\n    public CookieStore<Serializable> getCookieSessionIdStore() {\n        return cookieSessionIdStore;\n    }\n\n    public void setCookieSessionIdStore( CookieStore<Serializable> cookieSessionIdStore ) {\n        this.cookieSessionIdStore = cookieSessionIdStore;\n    }\n\n    public RequestParamStore<Serializable> getReqParamSessionIdStore() {\n        return reqParamSessionIdStore;\n    }\n\n    public void setReqParamSessionIdStore( RequestParamStore<Serializable> reqParamSessionIdStore ) {\n        this.reqParamSessionIdStore = reqParamSessionIdStore;\n    }\n\n    /**\n     * If set to <tt>true<\/tt>, this <tt>WebSessionFactory<\/tt> will ensure that any\n     * <tt>HttpRequest<\/tt> attempting\n     * to join a session (i.e. via {@link #getSession getSession} must have the same\n     * IP Address of the <tt>HttpRequest<\/tt> that started the session.\n     * <p/>\n     * <p> If set to <tt>false<\/tt>, any <tt>HttpRequest<\/tt> with a reference to a valid\n     * session id may acquire that <tt>Session<\/tt>.\n     * <p/>\n     * <p>Although convenient, this should only be enabled in environments where the\n     * system can <em>guarantee<\/em> that each IP address represents one and only one\n     * machine accessing the system.\n     * <p/>\n     * <p>Public websites are not good candidates for enabling this\n     * feature since many browser clients often sit behind NAT routers (in\n     * which case many machines are viewed to come from the same IP, thereby making this\n     * validation check useless).  Also, some internet service providers (e.g. AOL) may change a\n     * client's IP in mid-session, making subsequent requests appear to come from a different\n     * location.  Again, this feature should only be enabled where IP Addresses can be guaranteed a\n     * 1-to-1 relationship with a user's session.\n     * <p/>\n     * <p>For the reasons specified above, this property is <tt>false<\/tt> by default.\n     *\n     * @return true if this factory will verify each HttpRequest joining a session\n     */\n    public boolean isValidateRequestOrigin() {\n        return validateRequestOrigin;\n    }\n\n    /**\n     * Sets whether or not a request's origin will be validated when accessing a session.  See\n     * the {@link #isValidateRequestOrigin} JavaDoc for an in-depth explanation of this property.\n     *\n     * @param validateRequestOrigin whether or not to validate the request's origin when accessing\n     *                              a session.\n     * @see #isValidateRequestOrigin\n     */\n    public void setValidateRequestOrigin( boolean validateRequestOrigin ) {\n        this.validateRequestOrigin = validateRequestOrigin;\n    }\n\n    public void init() {\n        super.init();\n        ensureCookieSessionIdStore();\n        ensureRequestParamSessionIdStore();\n    }\n\n    protected void ensureCookieSessionIdStore() {\n        CookieStore<Serializable> cookieStore = getCookieSessionIdStore();\n        if ( cookieStore == null ) {\n            cookieStore = new CookieStore<Serializable>( JSecurityHttpSession.DEFAULT_SESSION_ID_NAME );\n            cookieStore.setCheckRequestParams( false );\n            setCookieSessionIdStore( cookieStore );\n        }\n    }\n\n    protected void ensureRequestParamSessionIdStore() {\n        RequestParamStore<Serializable> reqParamStore = getReqParamSessionIdStore();\n        if ( reqParamStore == null ) {\n            reqParamStore = new RequestParamStore<Serializable>( JSecurityHttpSession.DEFAULT_SESSION_ID_NAME );\n            setReqParamSessionIdStore( reqParamStore );\n        }\n    }\n\n    protected void validateSessionOrigin( ServletRequest request, Session session )\n        throws HostUnauthorizedException {\n        InetAddress requestIp = SecurityWebSupport.getInetAddress( request );\n        InetAddress originIp = session.getHostAddress();\n        Serializable sessionId = session.getSessionId();\n\n        if ( originIp == null ) {\n            if ( requestIp != null ) {\n                String msg = \"No IP Address was specified when creating session with id [\" +\n                    sessionId + \"].  Attempting to access session from \" +\n                    \"IP [\" + requestIp + \"].  Origin IP and request IP must match.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        } else {\n            if ( requestIp != null ) {\n                if ( !requestIp.equals( originIp ) ) {\n                    String msg = \"Session with id [\" + sessionId + \"] originated from [\" +\n                        originIp + \"], but the current HttpServletRequest originated \" +\n                        \"from [\" + requestIp + \"].  Disallowing session access: \" +\n                        \"session origin and request origin must match to allow access.\";\n                    throw new HostUnauthorizedException( msg );\n                }\n\n            } else {\n                String msg = \"No IP Address associated with the current HttpServletRequest.  \" +\n                    \"Session with id [\" + sessionId + \"] originated from \" +\n                    \"[\" + originIp + \"].  Request IP must match the session's origin \" +\n                    \"IP in order to gain access to that session.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        }\n    }\n\n    protected void storeSessionId( Serializable currentId, ServletRequest request, ServletResponse response ) {\n        if ( currentId == null ) {\n            String msg = \"sessionId cannot be null when persisting for subsequent requests.\";\n            throw new IllegalArgumentException( msg );\n        }\n        //ensure that the id has been set in the idStore, or if it already has, that it is not different than the\n        //'real' session value:\n        Serializable existingId = retrieveSessionId( request, response );\n        if ( existingId == null || !currentId.equals( existingId ) ) {\n            getCookieSessionIdStore().storeValue( currentId, request, response );\n        }\n    }\n\n    protected Serializable retrieveSessionId( ServletRequest request, ServletResponse response ) {\n        WebStore<Serializable> cookieSessionIdStore = getCookieSessionIdStore();\n        Serializable id = cookieSessionIdStore.retrieveValue( request, response );\n        if ( id != null ) {\n            request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                JSecurityHttpServletRequest.COOKIE_SESSION_ID_SOURCE );\n        } else {\n            id = getReqParamSessionIdStore().retrieveValue( request, response );\n            if ( id != null ) {\n                request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                    JSecurityHttpServletRequest.URL_SESSION_ID_SOURCE );\n            }\n        }\n        return id;\n    }\n\n    protected Session doGetSession( ServletRequest request, ServletResponse response ) {\n\n        Session session = null;\n        Serializable sessionId = retrieveSessionId( request, response );\n\n        if ( sessionId != null ) {\n            request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID, sessionId );\n            session = getSession( sessionId );\n            if ( isValidateRequestOrigin() ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"Validating request origin against session origin\" );\n                }\n                validateSessionOrigin( request, session );\n            }\n            if ( session != null ) {\n                request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE );\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No JSecurity session id associated with the given \" +\n                    \"HttpServletRequest.  A Session will not be returned.\" );\n            }\n        }\n        return session;\n\n\n    }\n\n    public Session start(InetAddress hostAddress) throws HostUnauthorizedException, IllegalArgumentException {\n        return start( ThreadContext.getServletRequest(), ThreadContext.getServletResponse(), hostAddress );\n    }\n\n    /**\n     * Starts a brand new Session, associates it with the specified request, and makes that session available for\n     * future requests via a Cookie or URL rewriting as specified by the Servlet Specification.\n     *\n     * @param request incoming ServletRequest\n     * @param response outgoing ServletResponse\n     * @return a new Session for the specified request/response pair.\n     */\n    public Session start( ServletRequest request, ServletResponse response ) {\n        InetAddress clientAddress = SecurityWebSupport.getInetAddress( request );\n        Session s = start( request, response, clientAddress );\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Started new Session with id [\" + s.getSessionId() );\n        }\n        return s;\n    }\n\n    protected Session start( ServletRequest request, ServletResponse response, InetAddress inetAddress ) {\n        Session s = super.start( inetAddress );\n        storeSessionId( s.getSessionId(), request, response );\n        request.removeAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE );\n        request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_IS_NEW, Boolean.TRUE );\n        return s;\n    }\n\n    /**\n     * Returns the Session associated with the specified request, <tt>null<\/tt>, or a new Session, depending on the\n     * enforcement policy in effect as specified by the {@link #setEnforceSessionOnGet(boolean) enforceSessionOnGet}\n     * property.\n     *\n     * <p>This method implementation functions as follows:<\/p>\n     *\n     * <ol>\n     *   <li>If the the incoming <tt>request<\/tt> references a valid, non-expired session, it will be returned\n     *       immediately<\/li>\n     *   <li>If the incoming <tt>request<\/tt> references an invalid, expired, or non-existent Session, and the\n     *       <tt>enforceSessionOnGet<\/tt> property is <tt>true<\/tt>, then a new Session will be created via the\n     *       {@link #start(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} method and returned.<\/li>\n     *   <li>If the incoming <tt>request<\/tt> references an invalid, expired or non-existent Session, and the\n     *       <tt>enforceSessionOnGet<\/tt> property is <tt>false<\/tt>, then <tt>null<\/tt> is returned.<\/li>\n     * <\/ol>\n     *\n     * <p>The default value of <tt>enforceSessionOnGet<\/tt> is <tt>true<\/tt> to guarantee a Session for an\n     * HttpRequest if one is desired.\n     *\n     * @param request  incoming servlet request\n     * @param response outgoing servlet response\n     * @return the Session associated with the incoming request, <tt>null<\/tt> or a new Session, depending on the\n     * {@link #setEnforceSessionOnGet(boolean) enforceSessionOnGet} policy in effect.\n     * @throws org.jsecurity.session.InvalidSessionException if the associated Session has expired prior to invoking this method.\n     * @throws org.jsecurity.authz.AuthorizationException  if the caller is not authorized to access the session associated with the request.\n     */\n    public final Session getSession( ServletRequest request, ServletResponse response )\n        throws InvalidSessionException, AuthorizationException {\n\n        Session session = null;\n        try {\n            session = doGetSession( request, response );\n            if ( session == null && isEnforceSessionOnGet() ) {\n                session = start( request, response );\n            }\n        } catch ( InvalidSessionException ise ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Request Session is invalid, message: [\" + ise.getMessage() + \"].\" );\n            }\n            session = handleInvalidSession( request, response, ise );\n        }\n\n        return session;\n    }\n\n    protected Session handleInvalidSession( ServletRequest request,\n                                            ServletResponse response,\n                                            InvalidSessionException ise ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Handling invalid session associated with the request.\" );\n        }\n\n        Session session = null;\n\n        if ( isEnforceSessionOnGet() ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Configured to create a new session on invalid session - attempting to start a new session...\" );\n            }\n            session = start( request, response );\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Configured to _not_ start a new session after an invalid session - returning null.\" );\n            }\n        }\n\n        return session;\n    }\n}\n","lineNo":267}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.web.support;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.SessionManager;\nimport org.jsecurity.session.support.DefaultSessionFactory;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.WebSessionFactory;\nimport org.jsecurity.web.WebStore;\nimport org.jsecurity.web.servlet.JSecurityHttpServletRequest;\nimport org.jsecurity.web.servlet.JSecurityHttpSession;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\nimport java.net.InetAddress;\n\n/**\n * Default JSecurity implementation of the {@link WebSessionFactory} interface.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class DefaultWebSessionFactory extends DefaultSessionFactory implements WebSessionFactory {\n\n    private boolean enforceSessionOnGet = false;\n\n    /**\n     * Property specifying if, after a session object is acquired from the request, if that session should be\n     * validated to ensure the starting origin of the session is the same as the incoming request.\n     */\n    private boolean validateRequestOrigin = false; //default\n\n    protected CookieStore<Serializable> cookieSessionIdStore = null;\n    protected RequestParamStore<Serializable> reqParamSessionIdStore = null;\n\n    public DefaultWebSessionFactory() {\n    }\n\n    public DefaultWebSessionFactory( SessionManager sessionManager ) {\n        super( sessionManager );\n    }\n\n    /**\n     * Returns the current session enforcement policy for the\n     * {@link #getSession(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}\n     * method - please see that method's JavaDoc for usage information.\n     *\n     * <p>The default value is <tt>false<\/tt>.\n     *\n     * @return the current session enforcement policy for the {@link #getSession(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} method.\n     *\n     */\n    public boolean isEnforceSessionOnGet() {\n        return enforceSessionOnGet;\n    }\n\n    /**\n     * Specifies session enforcemnt policy for the {@link #getSession(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}\n     * method - please see that method's JavaDoc for usage information.\n     *\n     * <p>The default value is <tt>false<\/tt>.\n     *\n     * @param enforceSessionOnGet the session enforcement policy for the {@link #getSession(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} method.\n     */\n    public void setEnforceSessionOnGet( boolean enforceSessionOnGet ) {\n        this.enforceSessionOnGet = enforceSessionOnGet;\n    }\n\n    public CookieStore<Serializable> getCookieSessionIdStore() {\n        return cookieSessionIdStore;\n    }\n\n    public void setCookieSessionIdStore( CookieStore<Serializable> cookieSessionIdStore ) {\n        this.cookieSessionIdStore = cookieSessionIdStore;\n    }\n\n    public RequestParamStore<Serializable> getReqParamSessionIdStore() {\n        return reqParamSessionIdStore;\n    }\n\n    public void setReqParamSessionIdStore( RequestParamStore<Serializable> reqParamSessionIdStore ) {\n        this.reqParamSessionIdStore = reqParamSessionIdStore;\n    }\n\n    /**\n     * If set to <tt>true<\/tt>, this <tt>WebSessionFactory<\/tt> will ensure that any\n     * <tt>HttpRequest<\/tt> attempting\n     * to join a session (i.e. via {@link #getSession getSession} must have the same\n     * IP Address of the <tt>HttpRequest<\/tt> that started the session.\n     * <p/>\n     * <p> If set to <tt>false<\/tt>, any <tt>HttpRequest<\/tt> with a reference to a valid\n     * session id may acquire that <tt>Session<\/tt>.\n     * <p/>\n     * <p>Although convenient, this should only be enabled in environments where the\n     * system can <em>guarantee<\/em> that each IP address represents one and only one\n     * machine accessing the system.\n     * <p/>\n     * <p>Public websites are not good candidates for enabling this\n     * feature since many browser clients often sit behind NAT routers (in\n     * which case many machines are viewed to come from the same IP, thereby making this\n     * validation check useless).  Also, some internet service providers (e.g. AOL) may change a\n     * client's IP in mid-session, making subsequent requests appear to come from a different\n     * location.  Again, this feature should only be enabled where IP Addresses can be guaranteed a\n     * 1-to-1 relationship with a user's session.\n     * <p/>\n     * <p>For the reasons specified above, this property is <tt>false<\/tt> by default.\n     *\n     * @return true if this factory will verify each HttpRequest joining a session\n     */\n    public boolean isValidateRequestOrigin() {\n        return validateRequestOrigin;\n    }\n\n    /**\n     * Sets whether or not a request's origin will be validated when accessing a session.  See\n     * the {@link #isValidateRequestOrigin} JavaDoc for an in-depth explanation of this property.\n     *\n     * @param validateRequestOrigin whether or not to validate the request's origin when accessing\n     *                              a session.\n     * @see #isValidateRequestOrigin\n     */\n    public void setValidateRequestOrigin( boolean validateRequestOrigin ) {\n        this.validateRequestOrigin = validateRequestOrigin;\n    }\n\n    public void init() {\n        super.init();\n        ensureCookieSessionIdStore();\n        ensureRequestParamSessionIdStore();\n    }\n\n    protected void ensureCookieSessionIdStore() {\n        CookieStore<Serializable> cookieStore = getCookieSessionIdStore();\n        if ( cookieStore == null ) {\n            cookieStore = new CookieStore<Serializable>( JSecurityHttpSession.DEFAULT_SESSION_ID_NAME );\n            cookieStore.setCheckRequestParams( false );\n            setCookieSessionIdStore( cookieStore );\n        }\n    }\n\n    protected void ensureRequestParamSessionIdStore() {\n        RequestParamStore<Serializable> reqParamStore = getReqParamSessionIdStore();\n        if ( reqParamStore == null ) {\n            reqParamStore = new RequestParamStore<Serializable>( JSecurityHttpSession.DEFAULT_SESSION_ID_NAME );\n            setReqParamSessionIdStore( reqParamStore );\n        }\n    }\n\n    protected void validateSessionOrigin( ServletRequest request, Session session )\n        throws HostUnauthorizedException {\n        InetAddress requestIp = SecurityWebSupport.getInetAddress( request );\n        InetAddress originIp = session.getHostAddress();\n        Serializable sessionId = session.getSessionId();\n\n        if ( originIp == null ) {\n            if ( requestIp != null ) {\n                String msg = \"No IP Address was specified when creating session with id [\" +\n                    sessionId + \"].  Attempting to access session from \" +\n                    \"IP [\" + requestIp + \"].  Origin IP and request IP must match.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        } else {\n            if ( requestIp != null ) {\n                if ( !requestIp.equals( originIp ) ) {\n                    String msg = \"Session with id [\" + sessionId + \"] originated from [\" +\n                        originIp + \"], but the current HttpServletRequest originated \" +\n                        \"from [\" + requestIp + \"].  Disallowing session access: \" +\n                        \"session origin and request origin must match to allow access.\";\n                    throw new HostUnauthorizedException( msg );\n                }\n\n            } else {\n                String msg = \"No IP Address associated with the current HttpServletRequest.  \" +\n                    \"Session with id [\" + sessionId + \"] originated from \" +\n                    \"[\" + originIp + \"].  Request IP must match the session's origin \" +\n                    \"IP in order to gain access to that session.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        }\n    }\n\n    protected void storeSessionId( Serializable currentId, ServletRequest request, ServletResponse response ) {\n        if ( currentId == null ) {\n            String msg = \"sessionId cannot be null when persisting for subsequent requests.\";\n            throw new IllegalArgumentException( msg );\n        }\n        //ensure that the id has been set in the idStore, or if it already has, that it is not different than the\n        //'real' session value:\n        Serializable existingId = retrieveSessionId( request, response );\n        if ( existingId == null || !currentId.equals( existingId ) ) {\n            getCookieSessionIdStore().storeValue( currentId, request, response );\n        }\n    }\n\n    protected Serializable retrieveSessionId( ServletRequest request, ServletResponse response ) {\n        WebStore<Serializable> cookieSessionIdStore = getCookieSessionIdStore();\n        Serializable id = cookieSessionIdStore.retrieveValue( request, response );\n        if ( id != null ) {\n            request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                JSecurityHttpServletRequest.COOKIE_SESSION_ID_SOURCE );\n        } else {\n            id = getReqParamSessionIdStore().retrieveValue( request, response );\n            if ( id != null ) {\n                request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                    JSecurityHttpServletRequest.URL_SESSION_ID_SOURCE );\n            }\n        }\n        return id;\n    }\n\n    protected Session doGetSession( ServletRequest request, ServletResponse response ) {\n\n        Session session = null;\n        Serializable sessionId = retrieveSessionId( request, response );\n\n        if ( sessionId != null ) {\n            request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID, sessionId );\n            session = getSession( sessionId );\n            if ( isValidateRequestOrigin() ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"Validating request origin against session origin\" );\n                }\n                validateSessionOrigin( request, session );\n            }\n            if ( session != null ) {\n                request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE );\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No JSecurity session id associated with the given \" +\n                    \"HttpServletRequest.  A Session will not be returned.\" );\n            }\n        }\n        return session;\n\n\n    }\n\n    public Session start(InetAddress hostAddress) throws HostUnauthorizedException, IllegalArgumentException {\n        ServletRequest request = ThreadContext.getServletRequest();\n        ServletResponse response = ThreadContext.getServletResponse();\n        return start( request, response, hostAddress );\n    }\n\n    /**\n     * Starts a brand new Session, associates it with the specified request, and makes that session available for\n     * future requests via a Cookie or URL rewriting as specified by the Servlet Specification.\n     *\n     * @param request incoming ServletRequest\n     * @param response outgoing ServletResponse\n     * @return a new Session for the specified request/response pair.\n     */\n    public Session start( ServletRequest request, ServletResponse response ) {\n        InetAddress clientAddress = SecurityWebSupport.getInetAddress( request );\n        Session s = start( request, response, clientAddress );\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Started new Session with id [\" + s.getSessionId() );\n        }\n        return s;\n    }\n\n    protected Session start( ServletRequest request, ServletResponse response, InetAddress inetAddress ) {\n        Session s = super.start( inetAddress );\n        storeSessionId( s.getSessionId(), request, response );\n        request.removeAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE );\n        request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_IS_NEW, Boolean.TRUE );\n        return s;\n    }\n\n    /**\n     * Returns the Session associated with the specified request, <tt>null<\/tt>, or a new Session, depending on the\n     * enforcement policy in effect as specified by the {@link #setEnforceSessionOnGet(boolean) enforceSessionOnGet}\n     * property.\n     *\n     * <p>This method implementation functions as follows:<\/p>\n     *\n     * <ol>\n     *   <li>If the the incoming <tt>request<\/tt> references a valid, non-expired session, it will be returned\n     *       immediately<\/li>\n     *   <li>If the incoming <tt>request<\/tt> references an invalid, expired, or non-existent Session, and the\n     *       <tt>enforceSessionOnGet<\/tt> property is <tt>true<\/tt>, then a new Session will be created via the\n     *       {@link #start(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} method and returned.<\/li>\n     *   <li>If the incoming <tt>request<\/tt> references an invalid, expired or non-existent Session, and the\n     *       <tt>enforceSessionOnGet<\/tt> property is <tt>false<\/tt>, then <tt>null<\/tt> is returned.<\/li>\n     * <\/ol>\n     *\n     * <p>The default value of <tt>enforceSessionOnGet<\/tt> is <tt>true<\/tt> to guarantee a Session for an\n     * HttpRequest if one is desired.\n     *\n     * @param request  incoming servlet request\n     * @param response outgoing servlet response\n     * @return the Session associated with the incoming request, <tt>null<\/tt> or a new Session, depending on the\n     * {@link #setEnforceSessionOnGet(boolean) enforceSessionOnGet} policy in effect.\n     * @throws org.jsecurity.session.InvalidSessionException if the associated Session has expired prior to invoking this method.\n     * @throws org.jsecurity.authz.AuthorizationException  if the caller is not authorized to access the session associated with the request.\n     */\n    public final Session getSession( ServletRequest request, ServletResponse response )\n        throws InvalidSessionException, AuthorizationException {\n\n        Session session;\n        try {\n            session = doGetSession( request, response );\n            if ( session == null && isEnforceSessionOnGet() ) {\n                session = start( request, response );\n            }\n        } catch ( InvalidSessionException ise ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Request Session is invalid, message: [\" + ise.getMessage() + \"].\" );\n            }\n            session = handleInvalidSession( request, response, ise );\n        }\n\n        return session;\n    }\n\n    protected Session handleInvalidSession( ServletRequest request,\n                                            ServletResponse response,\n                                            InvalidSessionException ise ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Handling invalid session associated with the request.\" );\n        }\n\n        Session session = null;\n\n        if ( isEnforceSessionOnGet() ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Configured to create a new session on invalid session - attempting to start a new session...\" );\n            }\n            session = start( request, response );\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Configured to _not_ start a new session after an invalid session - returning null.\" );\n            }\n        }\n\n        return session;\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.web.support;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.SessionManager;\nimport org.jsecurity.session.support.DefaultSessionFactory;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.WebSessionFactory;\nimport org.jsecurity.web.WebStore;\nimport org.jsecurity.web.servlet.JSecurityHttpServletRequest;\nimport org.jsecurity.web.servlet.JSecurityHttpSession;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\nimport java.net.InetAddress;\n\n/**\n * Default JSecurity implementation of the {@link WebSessionFactory} interface.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class DefaultWebSessionFactory extends DefaultSessionFactory implements WebSessionFactory {\n\n    private boolean enforceSessionOnGet = false;\n\n    /**\n     * Property specifying if, after a session object is acquired from the request, if that session should be\n     * validated to ensure the starting origin of the session is the same as the incoming request.\n     */\n    private boolean validateRequestOrigin = false; //default\n\n    protected CookieStore<Serializable> cookieSessionIdStore = null;\n    protected RequestParamStore<Serializable> reqParamSessionIdStore = null;\n\n    public DefaultWebSessionFactory() {\n    }\n\n    public DefaultWebSessionFactory( SessionManager sessionManager ) {\n        super( sessionManager );\n    }\n\n    /**\n     * Returns the current session enforcement policy for the\n     * {@link #getSession(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}\n     * method - please see that method's JavaDoc for usage information.\n     *\n     * <p>The default value is <tt>false<\/tt>.\n     *\n     * @return the current session enforcement policy for the {@link #getSession(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} method.\n     *\n     */\n    public boolean isEnforceSessionOnGet() {\n        return enforceSessionOnGet;\n    }\n\n    /**\n     * Specifies session enforcemnt policy for the {@link #getSession(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}\n     * method - please see that method's JavaDoc for usage information.\n     *\n     * <p>The default value is <tt>false<\/tt>.\n     *\n     * @param enforceSessionOnGet the session enforcement policy for the {@link #getSession(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} method.\n     */\n    public void setEnforceSessionOnGet( boolean enforceSessionOnGet ) {\n        this.enforceSessionOnGet = enforceSessionOnGet;\n    }\n\n    public CookieStore<Serializable> getCookieSessionIdStore() {\n        return cookieSessionIdStore;\n    }\n\n    public void setCookieSessionIdStore( CookieStore<Serializable> cookieSessionIdStore ) {\n        this.cookieSessionIdStore = cookieSessionIdStore;\n    }\n\n    public RequestParamStore<Serializable> getReqParamSessionIdStore() {\n        return reqParamSessionIdStore;\n    }\n\n    public void setReqParamSessionIdStore( RequestParamStore<Serializable> reqParamSessionIdStore ) {\n        this.reqParamSessionIdStore = reqParamSessionIdStore;\n    }\n\n    /**\n     * If set to <tt>true<\/tt>, this <tt>WebSessionFactory<\/tt> will ensure that any\n     * <tt>HttpRequest<\/tt> attempting\n     * to join a session (i.e. via {@link #getSession getSession} must have the same\n     * IP Address of the <tt>HttpRequest<\/tt> that started the session.\n     * <p/>\n     * <p> If set to <tt>false<\/tt>, any <tt>HttpRequest<\/tt> with a reference to a valid\n     * session id may acquire that <tt>Session<\/tt>.\n     * <p/>\n     * <p>Although convenient, this should only be enabled in environments where the\n     * system can <em>guarantee<\/em> that each IP address represents one and only one\n     * machine accessing the system.\n     * <p/>\n     * <p>Public websites are not good candidates for enabling this\n     * feature since many browser clients often sit behind NAT routers (in\n     * which case many machines are viewed to come from the same IP, thereby making this\n     * validation check useless).  Also, some internet service providers (e.g. AOL) may change a\n     * client's IP in mid-session, making subsequent requests appear to come from a different\n     * location.  Again, this feature should only be enabled where IP Addresses can be guaranteed a\n     * 1-to-1 relationship with a user's session.\n     * <p/>\n     * <p>For the reasons specified above, this property is <tt>false<\/tt> by default.\n     *\n     * @return true if this factory will verify each HttpRequest joining a session\n     */\n    public boolean isValidateRequestOrigin() {\n        return validateRequestOrigin;\n    }\n\n    /**\n     * Sets whether or not a request's origin will be validated when accessing a session.  See\n     * the {@link #isValidateRequestOrigin} JavaDoc for an in-depth explanation of this property.\n     *\n     * @param validateRequestOrigin whether or not to validate the request's origin when accessing\n     *                              a session.\n     * @see #isValidateRequestOrigin\n     */\n    public void setValidateRequestOrigin( boolean validateRequestOrigin ) {\n        this.validateRequestOrigin = validateRequestOrigin;\n    }\n\n    public void init() {\n        super.init();\n        ensureCookieSessionIdStore();\n        ensureRequestParamSessionIdStore();\n    }\n\n    protected void ensureCookieSessionIdStore() {\n        CookieStore<Serializable> cookieStore = getCookieSessionIdStore();\n        if ( cookieStore == null ) {\n            cookieStore = new CookieStore<Serializable>( JSecurityHttpSession.DEFAULT_SESSION_ID_NAME );\n            cookieStore.setCheckRequestParams( false );\n            setCookieSessionIdStore( cookieStore );\n        }\n    }\n\n    protected void ensureRequestParamSessionIdStore() {\n        RequestParamStore<Serializable> reqParamStore = getReqParamSessionIdStore();\n        if ( reqParamStore == null ) {\n            reqParamStore = new RequestParamStore<Serializable>( JSecurityHttpSession.DEFAULT_SESSION_ID_NAME );\n            setReqParamSessionIdStore( reqParamStore );\n        }\n    }\n\n    protected void validateSessionOrigin( ServletRequest request, Session session )\n        throws HostUnauthorizedException {\n        InetAddress requestIp = SecurityWebSupport.getInetAddress( request );\n        InetAddress originIp = session.getHostAddress();\n        Serializable sessionId = session.getSessionId();\n\n        if ( originIp == null ) {\n            if ( requestIp != null ) {\n                String msg = \"No IP Address was specified when creating session with id [\" +\n                    sessionId + \"].  Attempting to access session from \" +\n                    \"IP [\" + requestIp + \"].  Origin IP and request IP must match.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        } else {\n            if ( requestIp != null ) {\n                if ( !requestIp.equals( originIp ) ) {\n                    String msg = \"Session with id [\" + sessionId + \"] originated from [\" +\n                        originIp + \"], but the current HttpServletRequest originated \" +\n                        \"from [\" + requestIp + \"].  Disallowing session access: \" +\n                        \"session origin and request origin must match to allow access.\";\n                    throw new HostUnauthorizedException( msg );\n                }\n\n            } else {\n                String msg = \"No IP Address associated with the current HttpServletRequest.  \" +\n                    \"Session with id [\" + sessionId + \"] originated from \" +\n                    \"[\" + originIp + \"].  Request IP must match the session's origin \" +\n                    \"IP in order to gain access to that session.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        }\n    }\n\n    protected void storeSessionId( Serializable currentId, ServletRequest request, ServletResponse response ) {\n        if ( currentId == null ) {\n            String msg = \"sessionId cannot be null when persisting for subsequent requests.\";\n            throw new IllegalArgumentException( msg );\n        }\n        //ensure that the id has been set in the idStore, or if it already has, that it is not different than the\n        //'real' session value:\n        Serializable existingId = retrieveSessionId( request, response );\n        if ( existingId == null || !currentId.equals( existingId ) ) {\n            getCookieSessionIdStore().storeValue( currentId, request, response );\n        }\n    }\n\n    protected Serializable retrieveSessionId( ServletRequest request, ServletResponse response ) {\n        WebStore<Serializable> cookieSessionIdStore = getCookieSessionIdStore();\n        Serializable id = cookieSessionIdStore.retrieveValue( request, response );\n        if ( id != null ) {\n            request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                JSecurityHttpServletRequest.COOKIE_SESSION_ID_SOURCE );\n        } else {\n            id = getReqParamSessionIdStore().retrieveValue( request, response );\n            if ( id != null ) {\n                request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,\n                    JSecurityHttpServletRequest.URL_SESSION_ID_SOURCE );\n            }\n        }\n        return id;\n    }\n\n    protected Session doGetSession( ServletRequest request, ServletResponse response ) {\n\n        Session session = null;\n        Serializable sessionId = retrieveSessionId( request, response );\n\n        if ( sessionId != null ) {\n            request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID, sessionId );\n            session = getSession( sessionId );\n            if ( isValidateRequestOrigin() ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"Validating request origin against session origin\" );\n                }\n                validateSessionOrigin( request, session );\n            }\n            if ( session != null ) {\n                request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE );\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No JSecurity session id associated with the given \" +\n                    \"HttpServletRequest.  A Session will not be returned.\" );\n            }\n        }\n        return session;\n\n\n    }\n\n    public Session start(InetAddress hostAddress) throws HostUnauthorizedException, IllegalArgumentException {\n        return start( ThreadContext.getServletRequest(), ThreadContext.getServletResponse(), hostAddress );\n    }\n\n    /**\n     * Starts a brand new Session, associates it with the specified request, and makes that session available for\n     * future requests via a Cookie or URL rewriting as specified by the Servlet Specification.\n     *\n     * @param request incoming ServletRequest\n     * @param response outgoing ServletResponse\n     * @return a new Session for the specified request/response pair.\n     */\n    public Session start( ServletRequest request, ServletResponse response ) {\n        InetAddress clientAddress = SecurityWebSupport.getInetAddress( request );\n        Session s = start( request, response, clientAddress );\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Started new Session with id [\" + s.getSessionId() );\n        }\n        return s;\n    }\n\n    protected Session start( ServletRequest request, ServletResponse response, InetAddress inetAddress ) {\n        Session s = super.start( inetAddress );\n        storeSessionId( s.getSessionId(), request, response );\n        request.removeAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE );\n        request.setAttribute( JSecurityHttpServletRequest.REFERENCED_SESSION_IS_NEW, Boolean.TRUE );\n        return s;\n    }\n\n    /**\n     * Returns the Session associated with the specified request, <tt>null<\/tt>, or a new Session, depending on the\n     * enforcement policy in effect as specified by the {@link #setEnforceSessionOnGet(boolean) enforceSessionOnGet}\n     * property.\n     *\n     * <p>This method implementation functions as follows:<\/p>\n     *\n     * <ol>\n     *   <li>If the the incoming <tt>request<\/tt> references a valid, non-expired session, it will be returned\n     *       immediately<\/li>\n     *   <li>If the incoming <tt>request<\/tt> references an invalid, expired, or non-existent Session, and the\n     *       <tt>enforceSessionOnGet<\/tt> property is <tt>true<\/tt>, then a new Session will be created via the\n     *       {@link #start(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} method and returned.<\/li>\n     *   <li>If the incoming <tt>request<\/tt> references an invalid, expired or non-existent Session, and the\n     *       <tt>enforceSessionOnGet<\/tt> property is <tt>false<\/tt>, then <tt>null<\/tt> is returned.<\/li>\n     * <\/ol>\n     *\n     * <p>The default value of <tt>enforceSessionOnGet<\/tt> is <tt>true<\/tt> to guarantee a Session for an\n     * HttpRequest if one is desired.\n     *\n     * @param request  incoming servlet request\n     * @param response outgoing servlet response\n     * @return the Session associated with the incoming request, <tt>null<\/tt> or a new Session, depending on the\n     * {@link #setEnforceSessionOnGet(boolean) enforceSessionOnGet} policy in effect.\n     * @throws org.jsecurity.session.InvalidSessionException if the associated Session has expired prior to invoking this method.\n     * @throws org.jsecurity.authz.AuthorizationException  if the caller is not authorized to access the session associated with the request.\n     */\n    public final Session getSession( ServletRequest request, ServletResponse response )\n        throws InvalidSessionException, AuthorizationException {\n\n        Session session = null;\n        try {\n            session = doGetSession( request, response );\n            if ( session == null && isEnforceSessionOnGet() ) {\n                session = start( request, response );\n            }\n        } catch ( InvalidSessionException ise ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Request Session is invalid, message: [\" + ise.getMessage() + \"].\" );\n            }\n            session = handleInvalidSession( request, response, ise );\n        }\n\n        return session;\n    }\n\n    protected Session handleInvalidSession( ServletRequest request,\n                                            ServletResponse response,\n                                            InvalidSessionException ise ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Handling invalid session associated with the request.\" );\n        }\n\n        Session session = null;\n\n        if ( isEnforceSessionOnGet() ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Configured to create a new session on invalid session - attempting to start a new session...\" );\n            }\n            session = start( request, response );\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Configured to _not_ start a new session after an invalid session - returning null.\" );\n            }\n        }\n\n        return session;\n    }\n}\n","lineNo":268}
{"Refactored Sample":"package org.jsecurity.web.servlet;\n\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.security.Principal;\n\n/**\n * TODO class JavaDoc\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class JSecurityHttpServletRequest extends HttpServletRequestWrapper {\n\n    //The following 7 constants support the JSecurity's implementation of the Servlet Specification\n    public static final String COOKIE_SESSION_ID_SOURCE = \"cookie\";\n    public static final String URL_SESSION_ID_SOURCE = \"url\";\n    public static final String REFERENCED_SESSION_ID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID\";\n    public static final String REFERENCED_SESSION_ID_IS_VALID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID_VALID\";\n    public static final String REFERENCED_SESSION_IS_NEW = JSecurityHttpServletRequest.class.getName() + \"_REFERENCED_SESSION_IS_NEW\";\n    public static final String REFERENCED_SESSION_ID_SOURCE = JSecurityHttpServletRequest.class.getName() + \"REFERENCED_SESSION_ID_SOURCE\";\n    public static final String SESSION_ID_NAME = JSecurityHttpSession.DEFAULT_SESSION_ID_NAME;\n    /**\n     * Key that may be used to alert that the request's  referenced JSecurity Session has expired prior to\n     * request processing.\n     */\n    public static final String EXPIRED_SESSION_KEY = JSecurityHttpServletRequest.class.getName() + \"_EXPIRED_SESSION_KEY\";\n\n    protected ServletContext servletContext = null;\n\n    protected HttpSession session = null;\n\n    protected boolean useJSecuritySessions = true;\n\n    public JSecurityHttpServletRequest( HttpServletRequest wrapped, ServletContext servletContext,\n                                        boolean useJSecuritySessions ) {\n        super( wrapped );\n        this.servletContext = servletContext;\n        this.useJSecuritySessions = useJSecuritySessions;\n    }\n\n    public boolean isUseJSecuritySessions() {\n        return useJSecuritySessions;\n    }\n\n    public String getRemoteUser() {\n        String remoteUser = null;\n        Object scPrincipal = getSecurityContextPrincipal();\n        if ( scPrincipal != null ) {\n            if ( scPrincipal instanceof Principal ) {\n                remoteUser = ( (Principal)scPrincipal ).getName();\n            } else {\n                remoteUser = scPrincipal.toString();\n            }\n        } else {\n            remoteUser = super.getRemoteUser();\n        }\n        return remoteUser;\n    }\n\n    protected SecurityContext getSecurityContext() {\n        return ThreadContext.getSecurityContext();\n    }\n\n    protected Object getSecurityContextPrincipal() {\n        Object userPrincipal = null;\n        SecurityContext sc = getSecurityContext();\n        if ( sc != null ) {\n            userPrincipal = sc.getPrincipal();\n        }\n        return userPrincipal;\n    }\n\n    public boolean isUserInRole( String s ) {\n        SecurityContext sc = getSecurityContext();\n        boolean inRole = ( sc != null && sc.hasRole( s ) );\n        if ( !inRole ) {\n            inRole = super.isUserInRole( s );\n        }\n        return inRole;\n    }\n\n    public Principal getUserPrincipal() {\n        Principal userPrincipal = null;\n        Object scPrincipal = getSecurityContextPrincipal();\n        if ( scPrincipal != null ) {\n            if ( scPrincipal instanceof Principal ) {\n                userPrincipal = (Principal)scPrincipal;\n            } else {\n                userPrincipal = new ObjectPrincipal( scPrincipal );\n            }\n        } else {\n            userPrincipal = super.getUserPrincipal();\n        }\n        return userPrincipal;\n    }\n\n    public String getRequestedSessionId() {\n        String requestedSessionId = null;\n\n        if ( isUseJSecuritySessions() ) {\n            Object sessionId = getAttribute( REFERENCED_SESSION_ID );\n            if ( sessionId != null ) {\n                requestedSessionId = sessionId.toString();\n            }\n        } else {\n            requestedSessionId = super.getRequestedSessionId();\n        }\n\n        return requestedSessionId;\n    }\n\n    public HttpSession getSession( boolean create ) {\n\n        HttpSession httpSession = null;\n\n        if ( isUseJSecuritySessions() ) {\n\n            if ( this.session == null ) {\n\n                boolean existing = getSecurityContext().getSession( false ) != null;\n\n                Session jsecSession = getSecurityContext().getSession( create );\n                if ( jsecSession != null ) {\n                    this.session = new JSecurityHttpSession( jsecSession, this, this.servletContext );\n                    if ( !existing ) {\n                        setAttribute( REFERENCED_SESSION_IS_NEW, Boolean.TRUE );\n                    }\n                }\n            }\n            httpSession = this.session;\n        } else {\n            httpSession = super.getSession( create );\n        }\n\n        return httpSession;\n    }\n\n\n    public HttpSession getSession() {\n        return getSession( true );\n    }\n\n    public boolean isRequestedSessionIdValid() {\n        if ( isUseJSecuritySessions() ) {\n            Boolean value = (Boolean)getAttribute( REFERENCED_SESSION_ID_IS_VALID );\n            return ( value != null && value.equals( Boolean.TRUE ) );\n        } else {\n            return super.isRequestedSessionIdValid();\n        }\n    }\n\n    public boolean isRequestedSessionIdFromCookie() {\n        if ( isUseJSecuritySessions() ) {\n            String value = (String)getAttribute( REFERENCED_SESSION_ID_SOURCE );\n            return value != null && value.equals( COOKIE_SESSION_ID_SOURCE );\n        } else {\n            return super.isRequestedSessionIdFromCookie();\n        }\n    }\n\n    public boolean isRequestedSessionIdFromURL() {\n        if ( isUseJSecuritySessions() ) {\n            String value = (String)getAttribute( REFERENCED_SESSION_ID_SOURCE );\n            return value != null && value.equals( URL_SESSION_ID_SOURCE );\n        } else {\n            return super.isRequestedSessionIdFromURL();\n        }\n    }\n\n    public boolean isRequestedSessionIdFromUrl() {\n        return isRequestedSessionIdFromURL();\n    }\n\n    private class ObjectPrincipal implements java.security.Principal {\n        private Object object = null;\n\n        public ObjectPrincipal( Object object ) {\n            this.object = object;\n        }\n\n        public Object getObject() {\n            return object;\n        }\n\n        public String getName() {\n            return getObject().toString();\n        }\n\n        public int hashCode() {\n            return object.hashCode();\n        }\n\n        public boolean equals( Object o ) {\n            if ( o instanceof ObjectPrincipal ) {\n                ObjectPrincipal op = (ObjectPrincipal)o;\n                return getObject().equals( op.getObject() );\n            }\n            return false;\n        }\n\n        public String toString() {\n            return object.toString();\n        }\n    }\n}\n","Smelly Sample":"package org.jsecurity.web.servlet;\n\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.security.Principal;\n\n/**\n * TODO class JavaDoc\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class JSecurityHttpServletRequest extends HttpServletRequestWrapper {\n\n    //The following 7 constants support the JSecurity's implementation of the Servlet Specification\n    public static final String COOKIE_SESSION_ID_SOURCE = \"cookie\";\n    public static final String URL_SESSION_ID_SOURCE = \"url\";\n    public static final String REFERENCED_SESSION_ID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID\";\n    public static final String REFERENCED_SESSION_ID_IS_VALID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID_VALID\";\n    public static final String REFERENCED_SESSION_IS_NEW = JSecurityHttpServletRequest.class.getName() + \"_REFERENCED_SESSION_IS_NEW\";\n    public static final String REFERENCED_SESSION_ID_SOURCE = JSecurityHttpServletRequest.class.getName() + \"REFERENCED_SESSION_ID_SOURCE\";\n    public static final String SESSION_ID_NAME = JSecurityHttpSession.DEFAULT_SESSION_ID_NAME;\n    /**\n     * Key that may be used to alert that the request's  referenced JSecurity Session has expired prior to\n     * request processing.\n     */\n    public static final String EXPIRED_SESSION_KEY = JSecurityHttpServletRequest.class.getName() + \"_EXPIRED_SESSION_KEY\";\n    \n    protected ServletContext servletContext = null;\n\n    protected HttpSession session = null;\n\n    public JSecurityHttpServletRequest( HttpServletRequest wrapped, ServletContext servletContext ) {\n        super( wrapped );\n        this.servletContext = servletContext;\n    }\n\n    public String getRemoteUser() {\n        String remoteUser = null;\n        Object scPrincipal = getSecurityContextPrincipal();\n        if ( scPrincipal != null ) {\n            if ( scPrincipal instanceof Principal ) {\n                remoteUser = ((Principal)scPrincipal).getName();\n            } else {\n                remoteUser = scPrincipal.toString();\n            }\n        }\n        return remoteUser;\n    }\n\n    protected SecurityContext getSecurityContext() {\n        return ThreadContext.getSecurityContext();\n    }\n\n    protected Object getSecurityContextPrincipal() {\n        Object userPrincipal = null;\n        SecurityContext sc = getSecurityContext();\n        if ( sc != null ) {\n            userPrincipal = sc.getPrincipal();\n        }\n        return userPrincipal;\n    }\n\n    public boolean isUserInRole( String s ) {\n        SecurityContext sc = getSecurityContext();\n        return ( sc != null && sc.hasRole( s ) );\n    }\n\n    public Principal getUserPrincipal() {\n        Principal userPrincipal = null;\n        Object scPrincipal = getSecurityContextPrincipal();\n        if ( scPrincipal != null ) {\n            if ( scPrincipal instanceof Principal ) {\n                userPrincipal = (Principal)scPrincipal;\n            } else {\n                userPrincipal = new ObjectPrincipal( scPrincipal );\n            }\n        }\n        return userPrincipal;\n    }\n\n    public String getRequestedSessionId() {\n        Object sessionId = getAttribute( REFERENCED_SESSION_ID );\n        if ( sessionId != null ) {\n            return sessionId.toString();\n        } else {\n            return null;\n        }\n    }\n\n    public HttpSession getSession( boolean create ) {\n        if ( this.session == null ) {\n\n            boolean existing = getSecurityContext().getSession( false ) != null;\n\n            Session jsecSession = getSecurityContext().getSession( create );\n            if ( jsecSession != null ) {\n                this.session = new JSecurityHttpSession( jsecSession, this, this.servletContext );\n                if ( !existing ) {\n                    setAttribute( REFERENCED_SESSION_IS_NEW, Boolean.TRUE );\n                }\n            }\n        }\n        return this.session;\n    }\n\n    public HttpSession getSession() {\n        return getSession( true );\n    }\n\n    public boolean isRequestedSessionIdValid() {\n        Boolean value = (Boolean)getAttribute( REFERENCED_SESSION_ID_IS_VALID );\n        return ( value != null && value.equals( Boolean.TRUE ) );\n    }\n\n    public boolean isRequestedSessionIdFromCookie() {\n        String value = (String)getAttribute( REFERENCED_SESSION_ID_SOURCE );\n        return value != null && value.equals( COOKIE_SESSION_ID_SOURCE );\n    }\n\n    public boolean isRequestedSessionIdFromURL() {\n        String value = (String)getAttribute( REFERENCED_SESSION_ID_SOURCE );\n        return value != null && value.equals( URL_SESSION_ID_SOURCE );\n    }\n\n    public boolean isRequestedSessionIdFromUrl() {\n        return isRequestedSessionIdFromURL();\n    }\n\n    private class ObjectPrincipal implements java.security.Principal {\n        private Object object = null;\n\n        public ObjectPrincipal( Object object ) {\n            this.object = object;\n        }\n\n        public Object getObject() {\n            return object;\n        }\n\n        public String getName() {\n            return getObject().toString();\n        }\n\n        public int hashCode() {\n            return object.hashCode();\n        }\n\n        public boolean equals( Object o ) {\n            if ( o instanceof ObjectPrincipal ) {\n                ObjectPrincipal op = (ObjectPrincipal)o;\n                return getObject().equals( op.getObject() );\n            }\n            return false;\n        }\n\n        public String toString() {\n            return object.toString();\n        }\n    }\n}\n","lineNo":82}
{"Refactored Sample":"package org.jsecurity.web.servlet;\n\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.security.Principal;\n\n/**\n * TODO class JavaDoc\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class JSecurityHttpServletRequest extends HttpServletRequestWrapper {\n\n    //The following 7 constants support the JSecurity's implementation of the Servlet Specification\n    public static final String COOKIE_SESSION_ID_SOURCE = \"cookie\";\n    public static final String URL_SESSION_ID_SOURCE = \"url\";\n    public static final String REFERENCED_SESSION_ID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID\";\n    public static final String REFERENCED_SESSION_ID_IS_VALID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID_VALID\";\n    public static final String REFERENCED_SESSION_IS_NEW = JSecurityHttpServletRequest.class.getName() + \"_REFERENCED_SESSION_IS_NEW\";\n    public static final String REFERENCED_SESSION_ID_SOURCE = JSecurityHttpServletRequest.class.getName() + \"REFERENCED_SESSION_ID_SOURCE\";\n    public static final String SESSION_ID_NAME = JSecurityHttpSession.DEFAULT_SESSION_ID_NAME;\n    /**\n     * Key that may be used to alert that the request's  referenced JSecurity Session has expired prior to\n     * request processing.\n     */\n    public static final String EXPIRED_SESSION_KEY = JSecurityHttpServletRequest.class.getName() + \"_EXPIRED_SESSION_KEY\";\n\n    protected ServletContext servletContext = null;\n\n    protected HttpSession session = null;\n\n    protected boolean useJSecuritySessions = true;\n\n    public JSecurityHttpServletRequest( HttpServletRequest wrapped, ServletContext servletContext,\n                                        boolean useJSecuritySessions ) {\n        super( wrapped );\n        this.servletContext = servletContext;\n        this.useJSecuritySessions = useJSecuritySessions;\n    }\n\n    public boolean isUseJSecuritySessions() {\n        return useJSecuritySessions;\n    }\n\n    public String getRemoteUser() {\n        String remoteUser = null;\n        Object scPrincipal = getSecurityContextPrincipal();\n        if ( scPrincipal != null ) {\n            if ( scPrincipal instanceof Principal ) {\n                remoteUser = ( (Principal)scPrincipal ).getName();\n            } else {\n                remoteUser = scPrincipal.toString();\n            }\n        } else {\n            remoteUser = super.getRemoteUser();\n        }\n        return remoteUser;\n    }\n\n    protected SecurityContext getSecurityContext() {\n        return ThreadContext.getSecurityContext();\n    }\n\n    protected Object getSecurityContextPrincipal() {\n        Object userPrincipal = null;\n        SecurityContext sc = getSecurityContext();\n        if ( sc != null ) {\n            userPrincipal = sc.getPrincipal();\n        }\n        return userPrincipal;\n    }\n\n    public boolean isUserInRole( String s ) {\n        SecurityContext sc = getSecurityContext();\n        boolean inRole = ( sc != null && sc.hasRole( s ) );\n        if ( !inRole ) {\n            inRole = super.isUserInRole( s );\n        }\n        return inRole;\n    }\n\n    public Principal getUserPrincipal() {\n        Principal userPrincipal = null;\n        Object scPrincipal = getSecurityContextPrincipal();\n        if ( scPrincipal != null ) {\n            if ( scPrincipal instanceof Principal ) {\n                userPrincipal = (Principal)scPrincipal;\n            } else {\n                userPrincipal = new ObjectPrincipal( scPrincipal );\n            }\n        } else {\n            userPrincipal = super.getUserPrincipal();\n        }\n        return userPrincipal;\n    }\n\n    public String getRequestedSessionId() {\n        String requestedSessionId = null;\n\n        if ( isUseJSecuritySessions() ) {\n            Object sessionId = getAttribute( REFERENCED_SESSION_ID );\n            if ( sessionId != null ) {\n                requestedSessionId = sessionId.toString();\n            }\n        } else {\n            requestedSessionId = super.getRequestedSessionId();\n        }\n\n        return requestedSessionId;\n    }\n\n    public HttpSession getSession( boolean create ) {\n\n        HttpSession httpSession = null;\n\n        if ( isUseJSecuritySessions() ) {\n\n            if ( this.session == null ) {\n\n                boolean existing = getSecurityContext().getSession( false ) != null;\n\n                Session jsecSession = getSecurityContext().getSession( create );\n                if ( jsecSession != null ) {\n                    this.session = new JSecurityHttpSession( jsecSession, this, this.servletContext );\n                    if ( !existing ) {\n                        setAttribute( REFERENCED_SESSION_IS_NEW, Boolean.TRUE );\n                    }\n                }\n            }\n            httpSession = this.session;\n        } else {\n            httpSession = super.getSession( create );\n        }\n\n        return httpSession;\n    }\n\n\n    public HttpSession getSession() {\n        return getSession( true );\n    }\n\n    public boolean isRequestedSessionIdValid() {\n        if ( isUseJSecuritySessions() ) {\n            Boolean value = (Boolean)getAttribute( REFERENCED_SESSION_ID_IS_VALID );\n            return ( value != null && value.equals( Boolean.TRUE ) );\n        } else {\n            return super.isRequestedSessionIdValid();\n        }\n    }\n\n    public boolean isRequestedSessionIdFromCookie() {\n        if ( isUseJSecuritySessions() ) {\n            String value = (String)getAttribute( REFERENCED_SESSION_ID_SOURCE );\n            return value != null && value.equals( COOKIE_SESSION_ID_SOURCE );\n        } else {\n            return super.isRequestedSessionIdFromCookie();\n        }\n    }\n\n    public boolean isRequestedSessionIdFromURL() {\n        if ( isUseJSecuritySessions() ) {\n            String value = (String)getAttribute( REFERENCED_SESSION_ID_SOURCE );\n            return value != null && value.equals( URL_SESSION_ID_SOURCE );\n        } else {\n            return super.isRequestedSessionIdFromURL();\n        }\n    }\n\n    public boolean isRequestedSessionIdFromUrl() {\n        return isRequestedSessionIdFromURL();\n    }\n\n    private class ObjectPrincipal implements java.security.Principal {\n        private Object object = null;\n\n        public ObjectPrincipal( Object object ) {\n            this.object = object;\n        }\n\n        public Object getObject() {\n            return object;\n        }\n\n        public String getName() {\n            return getObject().toString();\n        }\n\n        public int hashCode() {\n            return object.hashCode();\n        }\n\n        public boolean equals( Object o ) {\n            if ( o instanceof ObjectPrincipal ) {\n                ObjectPrincipal op = (ObjectPrincipal)o;\n                return getObject().equals( op.getObject() );\n            }\n            return false;\n        }\n\n        public String toString() {\n            return object.toString();\n        }\n    }\n}\n","Smelly Sample":"package org.jsecurity.web.servlet;\n\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.security.Principal;\n\n/**\n * TODO class JavaDoc\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class JSecurityHttpServletRequest extends HttpServletRequestWrapper {\n\n    //The following 7 constants support the JSecurity's implementation of the Servlet Specification\n    public static final String COOKIE_SESSION_ID_SOURCE = \"cookie\";\n    public static final String URL_SESSION_ID_SOURCE = \"url\";\n    public static final String REFERENCED_SESSION_ID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID\";\n    public static final String REFERENCED_SESSION_ID_IS_VALID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID_VALID\";\n    public static final String REFERENCED_SESSION_IS_NEW = JSecurityHttpServletRequest.class.getName() + \"_REFERENCED_SESSION_IS_NEW\";\n    public static final String REFERENCED_SESSION_ID_SOURCE = JSecurityHttpServletRequest.class.getName() + \"REFERENCED_SESSION_ID_SOURCE\";\n    public static final String SESSION_ID_NAME = JSecurityHttpSession.DEFAULT_SESSION_ID_NAME;\n    /**\n     * Key that may be used to alert that the request's  referenced JSecurity Session has expired prior to\n     * request processing.\n     */\n    public static final String EXPIRED_SESSION_KEY = JSecurityHttpServletRequest.class.getName() + \"_EXPIRED_SESSION_KEY\";\n    \n    protected ServletContext servletContext = null;\n\n    protected HttpSession session = null;\n\n    public JSecurityHttpServletRequest( HttpServletRequest wrapped, ServletContext servletContext ) {\n        super( wrapped );\n        this.servletContext = servletContext;\n    }\n\n    public String getRemoteUser() {\n        String remoteUser = null;\n        Object scPrincipal = getSecurityContextPrincipal();\n        if ( scPrincipal != null ) {\n            if ( scPrincipal instanceof Principal ) {\n                remoteUser = ((Principal)scPrincipal).getName();\n            } else {\n                remoteUser = scPrincipal.toString();\n            }\n        }\n        return remoteUser;\n    }\n\n    protected SecurityContext getSecurityContext() {\n        return ThreadContext.getSecurityContext();\n    }\n\n    protected Object getSecurityContextPrincipal() {\n        Object userPrincipal = null;\n        SecurityContext sc = getSecurityContext();\n        if ( sc != null ) {\n            userPrincipal = sc.getPrincipal();\n        }\n        return userPrincipal;\n    }\n\n    public boolean isUserInRole( String s ) {\n        SecurityContext sc = getSecurityContext();\n        return ( sc != null && sc.hasRole( s ) );\n    }\n\n    public Principal getUserPrincipal() {\n        Principal userPrincipal = null;\n        Object scPrincipal = getSecurityContextPrincipal();\n        if ( scPrincipal != null ) {\n            if ( scPrincipal instanceof Principal ) {\n                userPrincipal = (Principal)scPrincipal;\n            } else {\n                userPrincipal = new ObjectPrincipal( scPrincipal );\n            }\n        }\n        return userPrincipal;\n    }\n\n    public String getRequestedSessionId() {\n        Object sessionId = getAttribute( REFERENCED_SESSION_ID );\n        if ( sessionId != null ) {\n            return sessionId.toString();\n        } else {\n            return null;\n        }\n    }\n\n    public HttpSession getSession( boolean create ) {\n        if ( this.session == null ) {\n\n            boolean existing = getSecurityContext().getSession( false ) != null;\n\n            Session jsecSession = getSecurityContext().getSession( create );\n            if ( jsecSession != null ) {\n                this.session = new JSecurityHttpSession( jsecSession, this, this.servletContext );\n                if ( !existing ) {\n                    setAttribute( REFERENCED_SESSION_IS_NEW, Boolean.TRUE );\n                }\n            }\n        }\n        return this.session;\n    }\n\n    public HttpSession getSession() {\n        return getSession( true );\n    }\n\n    public boolean isRequestedSessionIdValid() {\n        Boolean value = (Boolean)getAttribute( REFERENCED_SESSION_ID_IS_VALID );\n        return ( value != null && value.equals( Boolean.TRUE ) );\n    }\n\n    public boolean isRequestedSessionIdFromCookie() {\n        String value = (String)getAttribute( REFERENCED_SESSION_ID_SOURCE );\n        return value != null && value.equals( COOKIE_SESSION_ID_SOURCE );\n    }\n\n    public boolean isRequestedSessionIdFromURL() {\n        String value = (String)getAttribute( REFERENCED_SESSION_ID_SOURCE );\n        return value != null && value.equals( URL_SESSION_ID_SOURCE );\n    }\n\n    public boolean isRequestedSessionIdFromUrl() {\n        return isRequestedSessionIdFromURL();\n    }\n\n    private class ObjectPrincipal implements java.security.Principal {\n        private Object object = null;\n\n        public ObjectPrincipal( Object object ) {\n            this.object = object;\n        }\n\n        public Object getObject() {\n            return object;\n        }\n\n        public String getName() {\n            return getObject().toString();\n        }\n\n        public int hashCode() {\n            return object.hashCode();\n        }\n\n        public boolean equals( Object o ) {\n            if ( o instanceof ObjectPrincipal ) {\n                ObjectPrincipal op = (ObjectPrincipal)o;\n                return getObject().equals( op.getObject() );\n            }\n            return false;\n        }\n\n        public String toString() {\n            return object.toString();\n        }\n    }\n}\n","lineNo":105}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile, Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.WebInterceptor;\nimport org.jsecurity.web.support.SecurityContextWebInterceptor;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * Filter that is used to ensure a {@link org.jsecurity.context.SecurityContext} is made available to the application\n * on every request.  It must be subclassed to retrieve a <tt>SecurityManager<\/tt> instance in an\n * application-dependent manner (e.g. from Spring, from the subclass directly, etc).\n *\n * @since 0.1\n * @author Les Hazlewood\n * @author Jeremy Haile\n */\npublic class SecurityContextFilter extends WebInterceptorFilter {\n\n    public static final String USE_JSECURITY_SESSIONS_PARAM_NAME = \"useJSecuritySessions\";\n\n    protected boolean useJSecuritySessions = false;\n\n    protected boolean getBoolean( String paramName, boolean defaultValue ) {\n        boolean value = defaultValue;\n\n        String stringValue = getFilterConfig().getInitParameter( paramName );\n        if ( stringValue != null ) {\n            stringValue = stringValue.trim();\n            if ( \"\".equals( stringValue ) ) {\n                if (log.isWarnEnabled() ) {\n                    log.warn( \"Filter init param [\" + paramName + \"] does not have a \" +\n                        \"valid value (empty).  Defaulting to \" + defaultValue + \".\" );\n                }\n            }\n            stringValue = stringValue.trim();\n\n            try {\n                value = Boolean.valueOf( stringValue );\n            } catch ( Exception e ) {\n                if ( log.isWarnEnabled() ) {\n                    log.warn( \"Filter init param [\" + paramName + \"] with value [\" + stringValue + \"] is not a valid \" +\n                        \"boolean value (true|false).  Defaulting to \" + defaultValue + \".\" );\n                }\n            }\n        }\n\n        return value;\n    }\n\n    protected boolean isUseJSecuritySessions() {\n        return useJSecuritySessions;\n    }\n\n    protected void onInit() throws Exception {\n        this.useJSecuritySessions = getBoolean( USE_JSECURITY_SESSIONS_PARAM_NAME, false );\n    }\n\n    public void doFilterInternal( ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain )\n        throws IOException, ServletException {\n        HttpServletRequest request = toHttp(servletRequest);\n        HttpServletResponse response = toHttp(servletResponse);\n\n        ServletContext servletContext = getFilterConfig().getServletContext();\n\n        boolean useJSecuritySessions = isUseJSecuritySessions();\n        request = new JSecurityHttpServletRequest( request, servletContext, useJSecuritySessions );\n        //the JSecurityHttpServletResponse exists to support URL rewriting for session ids.  If not using\n        //JSecurity sessions, there is no need for this to be wrapped:\n        if ( useJSecuritySessions ) {\n            response = new JSecurityHttpServletResponse( response, servletContext, (JSecurityHttpServletRequest)request );\n        }\n\n        ThreadContext.bind( request );\n        ThreadContext.bind( response );\n\n        try {\n            super.doFilterInternal( request, response, chain );    //To change body of overridden methods use File | Settings | File Templates.\n        } finally {\n            ThreadContext.unbindServletRequest();\n            ThreadContext.unbindServletResponse();\n        }\n    }\n\n    /**\n     * Default implementation pulls the SecurityContext instance from the ServletContext.  Subclasses can override to\n     * retrieve from a different location.\n     *\n     * @return the application's SecurityManager.\n     */\n    protected SecurityManager getSecurityManager() {\n        ServletContext servletContext = getFilterConfig().getServletContext();\n        SecurityManager securityManager = (SecurityManager)servletContext.getAttribute( SecurityManagerLoader.SECURITY_MANAGER_CONTEXT_KEY );\n        if ( securityManager == null ) {\n            String msg = \"no SecurityManager instance bound to the ServletContext under key [\" +\n            SecurityManagerLoader.SECURITY_MANAGER_CONTEXT_KEY + \"].  Please ensure that either the \" +\n                SecurityManagerListener.class.getName() + \" listener or the \" +\n                SecurityManagerServlet.class.getName() + \" servlet are configured in web.xml (easiest), or override the \" +\n                getClass().getName() + \".getSecurityManager() method to retrieve it from a custom location.\";\n            throw new IllegalStateException( msg );\n        }\n        return securityManager;\n    }\n\n    protected WebInterceptor createWebInterceptor() throws Exception {\n        SecurityContextWebInterceptor interceptor = new SecurityContextWebInterceptor();\n        SecurityManager securityManager = getSecurityManager();\n        interceptor.setSecurityManager( securityManager );\n        interceptor.setUseJSecuritySessions( isUseJSecuritySessions() );\n        interceptor.init();\n        return interceptor;\n    }\n\n\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile, Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.WebInterceptor;\nimport org.jsecurity.web.support.SecurityContextWebInterceptor;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * Filter that is used to ensure a {@link org.jsecurity.context.SecurityContext} is made available to the application\n * on every request.  It must be subclassed to retrieve a <tt>SecurityManager<\/tt> instance in an\n * application-dependent manner (e.g. from Spring, from the subclass directly, etc).\n *\n * @since 0.1\n * @author Les Hazlewood\n * @author Jeremy Haile\n */\npublic class SecurityContextFilter extends WebInterceptorFilter {\n\n    public static final String USE_JSECURITY_SESSIONS_PARAM_NAME = \"useJSecuritySessions\"; //default is true\n\n    protected boolean useJSecuritySessions = true;\n\n    protected boolean getBoolean( String paramName, boolean defaultValue ) {\n        boolean value = defaultValue;\n\n        String stringValue = getFilterConfig().getInitParameter( paramName );\n        if ( stringValue != null ) {\n            stringValue = stringValue.trim();\n            if ( \"\".equals( stringValue ) ) {\n                if (log.isWarnEnabled() ) {\n                    log.warn( \"Filter init param [\" + paramName + \"] does not have a \" +\n                        \"valid value (empty).  Defaulting to \" + defaultValue + \".\" );\n                }\n            }\n            stringValue = stringValue.trim();\n\n            try {\n                value = Boolean.valueOf( stringValue );\n            } catch ( Exception e ) {\n                if ( log.isWarnEnabled() ) {\n                    log.warn( \"Filter init param [\" + paramName + \"] with value [\" + stringValue + \"] is not a valid \" +\n                        \"boolean value (true|false).  Defaulting to \" + defaultValue + \".\" );\n                }\n            }\n        }\n\n        return value;\n    }\n\n    protected boolean isUseJSecuritySessions() {\n        return useJSecuritySessions;\n    }\n\n    protected void onInit() throws Exception {\n        this.useJSecuritySessions = getBoolean( USE_JSECURITY_SESSIONS_PARAM_NAME, false );\n    }\n\n    public void doFilterInternal( ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain )\n        throws IOException, ServletException {\n        HttpServletRequest request = toHttp(servletRequest);\n        HttpServletResponse response = toHttp(servletResponse);\n        if ( isUseJSecuritySessions() ) {\n            ServletContext servletContext = getFilterConfig().getServletContext();\n            request = new JSecurityHttpServletRequest( request, servletContext );\n            response = new JSecurityHttpServletResponse( response, servletContext, (JSecurityHttpServletRequest)request );\n        }\n        ThreadContext.bind( request );\n        ThreadContext.bind( response );\n\n        try {\n            super.doFilterInternal( request, response, chain );    //To change body of overridden methods use File | Settings | File Templates.\n        } finally {\n            ThreadContext.unbindServletRequest();\n            ThreadContext.unbindServletResponse();\n        }\n    }\n\n    /**\n     * Default implementation pulls the SecurityContext instance from the ServletContext.  Subclasses can override to\n     * retrieve from a different location.\n     *\n     * @return the application's SecurityManager.\n     */\n    protected SecurityManager getSecurityManager() {\n        ServletContext servletContext = getFilterConfig().getServletContext();\n        SecurityManager securityManager = (SecurityManager)servletContext.getAttribute( SecurityManagerLoader.SECURITY_MANAGER_CONTEXT_KEY );\n        if ( securityManager == null ) {\n            String msg = \"no SecurityManager instance bound to the ServletContext under key [\" +\n            SecurityManagerLoader.SECURITY_MANAGER_CONTEXT_KEY + \"].  Please ensure that either the \" +\n                SecurityManagerListener.class.getName() + \" listener or the \" +\n                SecurityManagerServlet.class.getName() + \" servlet are configured in web.xml (easiest), or override the \" +\n                getClass().getName() + \".getSecurityManager() method to retrieve it from a custom location.\";\n            throw new IllegalStateException( msg );\n        }\n        return securityManager;\n    }\n\n    protected WebInterceptor createWebInterceptor() throws Exception {\n        SecurityContextWebInterceptor interceptor = new SecurityContextWebInterceptor();\n        SecurityManager securityManager = getSecurityManager();\n        interceptor.setSecurityManager( securityManager );\n        interceptor.setUseJSecuritySessions( isUseJSecuritySessions() );\n        interceptor.init();\n        return interceptor;\n    }\n\n\n\n}\n","lineNo":94}
{"Refactored Sample":"package org.jsecurity.web.support;\n\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.web.WebSecurityContextFactory;\nimport org.jsecurity.web.WebSessionFactory;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.net.InetAddress;\nimport java.util.List;\n\n/**\n * TODO class JavaDoc\n *\n * @author Les Hazlewood\n */\npublic class DefaultWebSecurityContextFactory extends SecurityWebSupport implements WebSecurityContextFactory {\n\n    /**\n     * The key that is used to store subject principals in the session.\n     */\n    public static final String PRINCIPALS_SESSION_KEY =\n        DefaultWebSecurityContextFactory.class.getName() + \"_PRINCIPALS_SESSION_KEY\";\n\n    /**\n     * The key that is used to store whether or not the user is authenticated in the session.\n     */\n    public static final String AUTHENTICATED_SESSION_KEY =\n        DefaultWebSecurityContextFactory.class.getName() + \"_AUTHENTICATED_SESSION_KEY\";\n\n    protected SecurityManager securityManager = null;\n\n    protected WebSessionFactory webSessionFactory = null;\n\n    private boolean useJSecuritySessions = false;\n\n    public DefaultWebSecurityContextFactory() {\n    }\n\n    public SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    public void setSecurityManager( SecurityManager securityManager ) {\n        this.securityManager = securityManager;\n    }\n\n    public WebSessionFactory getWebSessionFactory() {\n        return webSessionFactory;\n    }\n\n    public void setWebSessionFactory( WebSessionFactory webSessionFactory ) {\n        this.webSessionFactory = webSessionFactory;\n    }\n\n    public boolean isUseJSecuritySessions() {\n        return useJSecuritySessions;\n    }\n\n    public void setUseJSecuritySessions( boolean useJSecuritySessions ) {\n        this.useJSecuritySessions = useJSecuritySessions;\n    }\n\n    void assertSecurityManager() {\n        SecurityManager securityManager = getSecurityManager();\n        if ( securityManager == null ) {\n            String msg = \"SecurityManager property must be set.\";\n            throw new IllegalStateException( msg );\n        }\n    }\n\n    void ensureWebSessionFactory() {\n\n        WebSessionFactory factory = getWebSessionFactory();\n\n        if ( factory == null ) {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No WebSessionFactory configured.  Initializing default WebSessionFactory instance...\" );\n            }\n\n            if ( isUseJSecuritySessions() ) {\n                SecurityManager securityManager = getSecurityManager();\n                if ( securityManager == null ) {\n                    String msg = \"The SessionManager property must be set when using JSecurity Sessions.\";\n                    throw new IllegalStateException( msg );\n                }\n                factory = new DefaultWebSessionFactory( securityManager );\n            } else {\n                factory = new HttpContainerWebSessionFactory();\n            }\n            setWebSessionFactory( factory );\n        }\n    }\n\n    public void init() {\n        assertSecurityManager();\n        ensureWebSessionFactory();\n    }\n\n    protected List getPrincipals( Session session ) {\n        List principals = null;\n\n        if ( session != null ) {\n            principals = (List)session.getAttribute( PRINCIPALS_SESSION_KEY );\n        }\n\n        return principals;\n    }\n\n    protected List getPrincipals( ServletRequest servletRequest, ServletResponse servletResponse, Session existing ) {\n        return getPrincipals( existing );\n    }\n\n    protected boolean isAuthenticated( Session session ) {\n        Boolean value = null;\n\n        if ( session != null ) {\n            value = (Boolean)session.getAttribute( AUTHENTICATED_SESSION_KEY );\n        }\n\n        return value != null && value;\n    }\n\n    protected boolean isAuthenticated( ServletRequest servletRequest, ServletResponse servletResponse, Session existing ) {\n        return isAuthenticated( existing );\n    }\n    \n    protected SecurityContext createSecurityContext( ServletRequest request,\n                                                     ServletResponse response,\n                                                     List principals,\n                                                     boolean authenticated,\n                                                     Session existing ) {\n        SecurityManager securityManager = getSecurityManager();\n\n        if ( securityManager == null ) {\n            final String message = \"the SecurityManager attribute must be configured.  This could be \" +\n                \"done by calling setSecurityManager() on the \" + getClass().getName() + \" instance, or by subclassing \" +\n                \"to retrieve the SecurityManager from an application framework.\";\n            throw new IllegalStateException( message );\n        }\n\n\n        InetAddress inetAddress = getInetAddress( request );\n\n        WebSecurityContext sc = new WebSecurityContext( principals, authenticated, inetAddress,\n                                                        existing, securityManager, request );\n        sc.setUseJSecuritySessions( isUseJSecuritySessions() );\n        return sc;\n    }\n\n    public SecurityContext createSecurityContext( ServletRequest request, ServletResponse response, Session existing ) {\n        List principals = getPrincipals( request, response, existing );\n        boolean authenticated = isAuthenticated( request, response, existing );\n        return createSecurityContext( request, response, principals, authenticated, existing );\n    }\n\n    /**\n     * Returns the raw {@link Session session} associated with the request, or <tt>null<\/tt> if there isn't one.\n     *\n     * <p>Implementation note: this implementation merely delegates to an internal <tt>WebSessionFactory<\/tt> to perform\n     * the lookup.\n     *\n     * @param request  incoming ServletRequest\n     * @param response outgoing ServletResponse\n     * @return the raw {@link Session session} associated with the request, or <tt>null<\/tt> if there isn't one.\n     */\n    protected Session getSession( ServletRequest request, ServletResponse response ) {\n        WebSessionFactory webSessionFactory = getWebSessionFactory();\n        if ( webSessionFactory == null ) {\n            String msg = \"The webSessionFactory property must be set.  This is done by \" +\n                       \"default during the init() method.  Please ensure init() is called before using this instance.\";\n            throw new IllegalStateException( msg );\n        }\n        return webSessionFactory.getSession( request, response );\n    }\n\n    public SecurityContext createSecurityContext( ServletRequest request, ServletResponse response ) {\n        Session session = getSession( request, response );\n        return createSecurityContext( request, response, session );\n    }\n\n    protected void bindForSubsequentRequests( ServletRequest request, ServletResponse response, SecurityContext securityContext ) {\n        List allPrincipals = securityContext.getAllPrincipals();\n        if ( allPrincipals != null && !allPrincipals.isEmpty() ) {\n            Session session = securityContext.getSession();\n            session.setAttribute( PRINCIPALS_SESSION_KEY, allPrincipals );\n            if ( securityContext.isAuthenticated() ) {\n                session.setAttribute( AUTHENTICATED_SESSION_KEY, securityContext.isAuthenticated() );\n            } else {\n                session.removeAttribute( AUTHENTICATED_SESSION_KEY );\n            }\n        }\n    }\n\n}\n","Smelly Sample":"package org.jsecurity.web.support;\n\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.support.DelegatingSecurityContext;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.WebSecurityContextFactory;\nimport org.jsecurity.web.WebSessionFactory;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.net.InetAddress;\nimport java.util.List;\n\n/**\n * TODO class JavaDoc\n *\n * @author Les Hazlewood\n */\npublic class DefaultWebSecurityContextFactory extends SecurityWebSupport implements WebSecurityContextFactory {\n\n    /**\n     * The key that is used to store subject principals in the session.\n     */\n    public static final String PRINCIPALS_SESSION_KEY =\n        DefaultWebSecurityContextFactory.class.getName() + \"_PRINCIPALS_SESSION_KEY\";\n\n    /**\n     * The key that is used to store whether or not the user is authenticated in the session.\n     */\n    public static final String AUTHENTICATED_SESSION_KEY =\n        DefaultWebSecurityContextFactory.class.getName() + \"_AUTHENTICATED_SESSION_KEY\";\n\n    protected SecurityManager securityManager = null;\n\n    protected WebSessionFactory webSessionFactory = null;\n\n    private boolean useJSecuritySessions = true;\n\n    public DefaultWebSecurityContextFactory() {\n    }\n\n    public SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    public void setSecurityManager( SecurityManager securityManager ) {\n        this.securityManager = securityManager;\n    }\n\n    public WebSessionFactory getWebSessionFactory() {\n        return webSessionFactory;\n    }\n\n    public void setWebSessionFactory( WebSessionFactory webSessionFactory ) {\n        this.webSessionFactory = webSessionFactory;\n    }\n\n    public boolean isUseJSecuritySessions() {\n        return useJSecuritySessions;\n    }\n\n    public void setUseJSecuritySessions( boolean useJSecuritySessions ) {\n        this.useJSecuritySessions = useJSecuritySessions;\n    }\n\n    void assertSecurityManager() {\n        SecurityManager securityManager = getSecurityManager();\n        if ( securityManager == null ) {\n            String msg = \"SecurityManager property must be set.\";\n            throw new IllegalStateException( msg );\n        }\n    }\n\n    void ensureWebSessionFactory() {\n        if ( getWebSessionFactory() == null ) {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"Initializing default WebSessionFactory instance...\" );\n            }\n\n            SecurityManager securityManager = getSecurityManager();\n            DefaultWebSessionFactory dwsf = new DefaultWebSessionFactory( securityManager );\n            setWebSessionFactory( dwsf );\n        }\n    }\n\n    public void init() {\n        assertSecurityManager();\n        if ( isUseJSecuritySessions() ) {\n            ensureWebSessionFactory();\n        }\n    }\n\n    protected List getPrincipals( ServletRequest servletRequest ) {\n        List principals = null;\n\n        HttpSession httpSession = toHttp( servletRequest ).getSession( false );\n        if ( httpSession != null ) {\n            principals = (List)httpSession.getAttribute( PRINCIPALS_SESSION_KEY );\n        }\n\n        return principals;\n    }\n\n    protected List getPrincipals( ServletRequest servletRequest, ServletResponse servletResponse ) {\n        return getPrincipals( servletRequest );\n    }\n\n    protected boolean isAuthenticated( ServletRequest servletRequest ) {\n        Boolean value = null;\n\n        HttpSession httpSession = toHttp( servletRequest ).getSession( false );\n        if ( httpSession != null ) {\n            value = (Boolean)httpSession.getAttribute( AUTHENTICATED_SESSION_KEY );\n        }\n\n        return value != null && value;\n    }\n\n    protected boolean isAuthenticated( ServletRequest servletRequest, ServletResponse servletResponse ) {\n        return isAuthenticated( servletRequest );\n    }\n\n    protected SecurityContext createSecurityContext( List principals, boolean authenticated,\n                                                     InetAddress inetAddress, Session session,\n                                                     SecurityManager securityManager ) {\n        return new DelegatingSecurityContext( principals, authenticated, inetAddress, session, securityManager );\n    }\n\n    protected SecurityContext createSecurityContext( ServletRequest request,\n                                                     ServletResponse response,\n                                                     List principals,\n                                                     boolean authenticated,\n                                                     Session existing ) {\n        SecurityContext securityContext;\n\n        SecurityManager securityManager = getSecurityManager();\n\n        if ( securityManager == null ) {\n            final String message = \"the SecurityManager attribute must be configured.  This could be \" +\n                \"done by calling setSecurityManager() on the \" + getClass().getName() + \" instance, or by subclassing \" +\n                \"to retrieve the SecurityManager from an application framework.\";\n            throw new IllegalStateException( message );\n        }\n\n\n        InetAddress inetAddress = getInetAddress( request );\n\n        securityContext = createSecurityContext( principals, authenticated, inetAddress, existing, securityManager );\n\n        return securityContext;\n    }\n\n    public SecurityContext createSecurityContext( ServletRequest request, ServletResponse response, Session existing ) {\n        List principals = getPrincipals( request, response );\n        boolean authenticated = isAuthenticated( request, response );\n        return createSecurityContext( request, response, principals, authenticated, existing );\n    }\n\n    /**\n     * Returns the raw {@link Session session} associated with the request, or <tt>null<\/tt> if there isn't one.\n     *\n     * <p>Implementation note: this implementation merely delegates to an internal <tt>WebSessionFactory<\/tt> to perform\n     * the lookup.\n     *\n     * @param request  incoming ServletRequest\n     * @param response outgoing ServletResponse\n     * @return the raw {@link Session session} associated with the request, or <tt>null<\/tt> if there isn't one.\n     */\n    protected Session getSession( ServletRequest request, ServletResponse response ) {\n\n        WebSessionFactory webSessionFactory = getWebSessionFactory();\n\n        if ( webSessionFactory == null ) {\n            String msg = \"webSessionFactory property must be set when using JSecurity sessions.  This is done by \" +\n                \"default during the init() method.  Please ensure init() is called before using this instance.\";\n            throw new IllegalStateException( msg );\n        }\n\n        return webSessionFactory.getSession( request, response );\n\n    }\n\n    public SecurityContext createSecurityContext( ServletRequest request, ServletResponse response ) {\n\n        //if there is a raw JSecurity Session already associated with the request, ensure it is passed along to the \n        //underlying SecurityContext so it can be used (instead of the SecurityContext implementation creating a brand\n        //new one the first time it is requested):\n\n        Session session = null;\n\n        if ( isUseJSecuritySessions() ) {\n            session = getSession( request, response );\n        }\n\n        SecurityContext sc = null;\n\n        try {\n            //Create a dummy context with any acquired session and bind it to the thread.  The next method call uses\n            //code that expects an SC to be bound to the thread.\n            sc = createSecurityContext( request, response, null, false, session );\n            ThreadContext.bind( sc );\n\n            //this is the call the requires a thread-bound SC:\n            sc = createSecurityContext( request, response, session );\n        } finally {\n            //remove the dummy in any case:\n            ThreadContext.unbindSecurityContext();\n        }\n\n        return sc;\n    }\n\n    protected void bindForSubsequentRequests( ServletRequest request, ServletResponse response, SecurityContext securityContext ) {\n        List allPrincipals = securityContext.getAllPrincipals();\n        if ( allPrincipals != null && !allPrincipals.isEmpty() ) {\n            HttpSession httpSession = toHttp(request).getSession();\n            httpSession.setAttribute( PRINCIPALS_SESSION_KEY, allPrincipals );\n            if ( securityContext.isAuthenticated() ) {\n                httpSession.setAttribute( AUTHENTICATED_SESSION_KEY, securityContext.isAuthenticated() );\n            } else {\n                httpSession.removeAttribute( AUTHENTICATED_SESSION_KEY );\n            }\n        }\n    }\n\n}\n","lineNo":76}
{"Refactored Sample":"/*\n* Copyright (C) 2005-2007 Les Hazlewood\n*\n* This library is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as published\n* by the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n* Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the\n*\n* Free Software Foundation, Inc.\n* 59 Temple Place, Suite 330\n* Boston, MA 02111-1307\n* USA\n*\n* Or, you may view it online at\n* http://www.opensource.org/licenses/lgpl-license.php\n*/\npackage org.jsecurity.context.factory.support;\n\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.support.DelegatingSecurityContext;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\n\nimport java.net.InetAddress;\n\n/**\n * SecurityContextFactory implementation that creates\n * {@link org.jsecurity.context.support.DelegatingSecurityContext} instances.\n *\n * @since 0.1\n * @author Les Hazlewood\n * @author Jeremy Haile\n */\npublic class DelegatingSecurityContextFactory extends AbstractSecurityContextFactory {\n\n    private SecurityManager securityManager;\n\n    public DelegatingSecurityContextFactory( SecurityManager securityManager ){\n        this.securityManager = securityManager;\n    }\n\n    protected SecurityContext onCreateSecurityContext( AuthenticationToken token, AuthenticationInfo info ) {\n\n        //get any existing session that may exist - we don't want to lose it:\n        SecurityContext securityContext = ThreadContext.getSecurityContext();\n        Session session = null;\n        if ( securityContext != null ) {\n            session = securityContext.getSession( false );\n        }\n\n        InetAddress authcSourceIP = null;\n        if( token instanceof InetAuthenticationToken ) {\n            authcSourceIP = ((InetAuthenticationToken)token).getInetAddress();\n        }\n        if ( authcSourceIP == null ) {\n            //try the thread local:\n            authcSourceIP = ThreadContext.getInetAddress();\n        }\n\n        return new DelegatingSecurityContext( info.getPrincipals(), true, authcSourceIP, session, securityManager );\n    }\n}\n","Smelly Sample":"/*\n* Copyright (C) 2005-2007 Les Hazlewood\n*\n* This library is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as published\n* by the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n* Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the\n*\n* Free Software Foundation, Inc.\n* 59 Temple Place, Suite 330\n* Boston, MA 02111-1307\n* USA\n*\n* Or, you may view it online at\n* http://www.opensource.org/licenses/lgpl-license.php\n*/\npackage org.jsecurity.context.factory.support;\n\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.support.DelegatingSecurityContext;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\n\n/**\n * SecurityContextFactory implementation that creates\n * {@link org.jsecurity.context.support.DelegatingSecurityContext} instances.\n *\n * @since 0.1\n * @author Les Hazlewood\n * @author Jeremy Haile\n */\npublic class DelegatingSecurityContextFactory extends AbstractSecurityContextFactory {\n\n    private SecurityManager securityManager;\n\n    public DelegatingSecurityContextFactory( SecurityManager securityManager ){\n        this.securityManager = securityManager;\n    }\n\n    protected SecurityContext onCreateSecurityContext( AuthenticationInfo info ) {\n\n        //get any existing session that may exist - we don't want to lose it:\n        SecurityContext securityContext = ThreadContext.getSecurityContext();\n        Session session = null;\n        if ( securityContext != null ) {\n            session = securityContext.getSession( false );\n        }\n\n        return new DelegatingSecurityContext( info.getPrincipals(), true, ThreadContext.getInetAddress(), session, securityManager );\n    }\n}\n","lineNo":63}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.web.support;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.SessionFactory;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.WebSessionFactory;\nimport org.jsecurity.web.WebStore;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.Serializable;\nimport java.net.InetAddress;\n\n/**\n * Default JSecurity implementation of the {@link WebSessionFactory} interface.\n * <p/>\n * <p>This SessionFactory implementation handles web-specific APIs and delegates session creation/acquisition\n * behavior to an underlying wrapped {@link SessionFactory SessionFactory} instance.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class DefaultWebSessionFactory extends SecurityWebSupport implements WebSessionFactory {\n\n    public static final String COOKIE_ID_SOURCE = \"cookie\";\n    public static final String URL_ID_SOURCE = \"url\";\n\n    public static final String REQUEST_REFERENCED_SESSION_ID_THREAD_CONTEXT_KEY = DefaultWebSessionFactory.class.getName() + \"_REQUESTED_SESSION_ID\";\n    public static final String REQUEST_REFERENCED_SESSION_ID_VALID_THREAD_CONTEXT_KEY = DefaultWebSessionFactory.class.getName() + \"_REQUESTED_SESSION_ID_VALID\";\n    public static final String REQUEST_REFERENCED_SESSION_IS_NEW_THREAD_CONTEXT_KEY = DefaultWebSessionFactory.class.getName() + \"_REFERENCED_SESSION_IS_NEW\";\n    public static final String REQUEST_REFERENCED_SESSION_ID_SOURCE_THREAD_CONTEXT_KEY = DefaultWebSessionFactory.class.getName() + \"REFERENCED_SESSION_ID_SOURCE\";\n\n    public static final String DEFAULT_SESSION_ID_KEY_NAME = \"jsecSessionId\";\n\n    protected transient final Log log = LogFactory.getLog( getClass() );\n\n    /**\n     * Key that may be used for a http request or session attribute to alert that a referencing JSecurity Session\n     * has expired.\n     */\n    public static final String EXPIRED_SESSION_KEY = SessionWebInterceptor.class.getName() + \"_EXPIRED_SESSION_KEY\";\n\n    private boolean validateRequestOrigin = false; //default\n\n    protected SessionFactory sessionFactory = null;\n\n    //An HttpSessionStore is required if JSecurity sessions can be lazily created (e.g. SecurityContext.getSession())\n    //after the response has started rendering - i.e. inside of a web controller or business-tier component accessed\n    //after the web request comes in.\n    //\n    // Cookies can only be sent out before the response has started rendering, so saving a cookie\n    //_after_ a response is done (as would happen in a web interceptor implementation's postHandle method) is\n    // worthless, since the cookie would never be sent.\n    //\n    // As such, the only time a CookieStore can be used to store the JSecurity sessionId is if the\n    // requireSessionOnRequest property is true, because a session would be created before the interceptor chain is\n    // continued, where it is still 'legal' to modify the HTTP headers (i.e. set a Cookie).  If this property is set\n    // to true in configuration (it is false by default), this implementation will automatically re-assign the\n    // idStore attribute to be a CookieStore in the init() method.  If this property is false, the init method\n    // will automatically create the HttpSessionStore.\n    protected WebStore<Serializable> idStore = null;\n\n    protected boolean requireSessionOnRequest = false;\n    protected boolean createNewSessionWhenInvalid = true;\n    protected boolean touchSessionOnRequest = false; //proactively touch the session on each request to ensure it is valid and timestamp has been updated.\n\n    public DefaultWebSessionFactory(){}\n\n    public DefaultWebSessionFactory( SessionFactory sessionFactory ) {\n        setSessionFactory( sessionFactory );\n    }\n\n    public void setSessionFactory( SessionFactory sessionFactory ) {\n        this.sessionFactory = sessionFactory;\n    }\n\n    public SessionFactory getSessionFactory() {\n        return sessionFactory;\n    }\n\n    public WebStore<Serializable> getIdStore() {\n        return idStore;\n    }\n\n    public void setIdStore( WebStore<Serializable> idStore ) {\n        this.idStore = idStore;\n    }\n\n    /**\n     * If set to <tt>true<\/tt>, this <tt>SessionWebInterceptor<\/tt> will ensure that any\n     * <tt>HttpRequest<\/tt> attempting\n     * to join a session (i.e. via {@link #getSession getSession} must have the same\n     * IP Address of the <tt>HttpRequest<\/tt> that started the session.\n     * <p/>\n     * <p> If set to <tt>false<\/tt>, any <tt>HttpRequest<\/tt> with a reference to a valid\n     * session id may acquire that <tt>Session<\/tt>.\n     * <p/>\n     * <p>Although convenient, this should only be enabled in environments where the\n     * system can <em>guarantee<\/em> that each IP address represents one and only one\n     * machine accessing the system.\n     * <p/>\n     * <p>Public websites are not good candidates for enabling this\n     * feature since many browser clients often sit behind NAT routers (in\n     * which case many machines are viewed to come from the same IP, thereby making this\n     * validation check useless).  Also, some internet service providers (e.g. AOL) may change a\n     * client's IP in mid-session, making subsequent requests appear to come from a different\n     * location.  Again, this feature should only be enabled where IP Addresses can be guaranteed a\n     * 1-to-1 relationship with a user's session.\n     * <p/>\n     * <p>For the reasons specified above, this property is <tt>false<\/tt> by default.\n     *\n     * @return true if this factory will verify each HttpRequest joining a session\n     */\n    public boolean isValidateRequestOrigin() {\n        return validateRequestOrigin;\n    }\n\n    /**\n     * Sets whether or not a request's origin will be validated when accessing a session.  See\n     * the {@link #isValidateRequestOrigin} JavaDoc for an in-depth explanation of this property.\n     *\n     * @param validateRequestOrigin whether or not to validate the request's origin when accessing\n     *                              a session.\n     * @see #isValidateRequestOrigin\n     */\n    public void setValidateRequestOrigin( boolean validateRequestOrigin ) {\n        this.validateRequestOrigin = validateRequestOrigin;\n    }\n\n    public boolean isRequireSessionOnRequest() {\n        return requireSessionOnRequest;\n    }\n\n    public void setRequireSessionOnRequest( boolean requireSessionOnRequest ) {\n        this.requireSessionOnRequest = requireSessionOnRequest;\n    }\n\n    public boolean isCreateNewSessionWhenInvalid() {\n        return createNewSessionWhenInvalid;\n    }\n\n    public void setCreateNewSessionWhenInvalid( boolean createNewSessionWhenInvalid ) {\n        this.createNewSessionWhenInvalid = createNewSessionWhenInvalid;\n    }\n\n    /**\n     * Returns if this WebSessionFactory will proactively {@link Session#touch() touch} a session on every\n     * request to ensure it is valid and its access timestamp has been updated.\n     * <p/>\n     * <p>The default value is <tt>false<\/tt>, since most appliacations actively update their session objects enough\n     * such that the session does not time out.\n     * <p/>\n     * <p>However, if you want to ensure that a session is valid on every request\n     * such that the Session's last access timestamp shows the last time they interacted with the web application,\n     * you will probably want to set this attribute to <tt>true<\/tt>.\n     *\n     * @return if this WebSessionFactory will proactively {@link Session#touch() touch} a session on every\n     *         request to ensure it is valid and its access timestamp has been updated.\n     */\n    public boolean isTouchSessionOnRequest() {\n        return touchSessionOnRequest;\n    }\n\n    public void setTouchSessionOnRequest( boolean touchSessionOnRequest ) {\n        this.touchSessionOnRequest = touchSessionOnRequest;\n    }\n\n    protected void assertSessionFactory() {\n        if ( getSessionFactory() == null ) {\n            String msg = \"sessionFactory property must be set.\";\n            throw new IllegalStateException( msg );\n        }\n    }\n\n    public void init() {\n        assertSessionFactory();\n        WebStore<Serializable> store = getIdStore();\n        if ( store == null ) {\n            if ( isRequireSessionOnRequest() ) {\n                store = new CookieStore<Serializable>( DEFAULT_SESSION_ID_KEY_NAME, CookieStore.INDEFINITE );\n            } else {\n                store = new HttpSessionStore<Serializable>( DEFAULT_SESSION_ID_KEY_NAME );\n            }\n            setIdStore( store );\n        }\n    }\n\n    protected void validateSessionOrigin( HttpServletRequest request, Session session )\n        throws HostUnauthorizedException {\n        InetAddress requestIp = SecurityWebSupport.getInetAddress( request );\n        InetAddress originIp = session.getHostAddress();\n        Serializable sessionId = session.getSessionId();\n\n        if ( originIp == null ) {\n            if ( requestIp != null ) {\n                String msg = \"No IP Address was specified when creating session with id [\" +\n                    sessionId + \"].  Attempting to access session from \" +\n                    \"IP [\" + requestIp + \"].  Origin IP and request IP must match.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        } else {\n            if ( requestIp != null ) {\n                if ( !requestIp.equals( originIp ) ) {\n                    String msg = \"Session with id [\" + sessionId + \"] originated from [\" +\n                        originIp + \"], but the current HttpServletRequest originated \" +\n                        \"from [\" + requestIp + \"].  Disallowing session access: \" +\n                        \"session origin and request origin must match to allow access.\";\n                    throw new HostUnauthorizedException( msg );\n                }\n\n            } else {\n                String msg = \"No IP Address associated with the current HttpServletRequest.  \" +\n                    \"Session with id [\" + sessionId + \"] originated from \" +\n                    \"[\" + originIp + \"].  Request IP must match the session's origin \" +\n                    \"IP in order to gain access to that session.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        }\n    }\n\n    protected void storeSessionId( Session session, HttpServletRequest request, HttpServletResponse response ) {\n        Serializable currentId = session.getSessionId();\n        if ( currentId == null ) {\n            String msg = \"Session#getSessionId() cannot return null when storing sessions for subsequent requests.\";\n            throw new IllegalStateException( msg );\n        }\n        //ensure that the id has been set in the idStore, or if it already has, that it is not different than the\n        //'real' session value:\n        Serializable existingId = retrieveSessionId( request, response );\n        if ( existingId == null || !currentId.equals( existingId ) ) {\n            getIdStore().storeValue( currentId, request, response );\n        }\n    }\n\n    protected Serializable retrieveSessionId( HttpServletRequest request, HttpServletResponse response ) {\n        WebStore<Serializable> idStore = getIdStore();\n        Serializable id = idStore.retrieveValue( request, response );\n        if ( id != null ) {\n            if ( idStore instanceof CookieStore ) {\n                ThreadContext.put( REQUEST_REFERENCED_SESSION_ID_SOURCE_THREAD_CONTEXT_KEY, COOKIE_ID_SOURCE );\n            }\n        }\n        return id;\n    }\n\n    public Session getSession( Serializable sessionId ) throws InvalidSessionException, AuthorizationException {\n        assertSessionFactory();\n        return sessionFactory.getSession( sessionId );\n    }\n\n    protected Session handleInvalidSession( HttpServletRequest request,\n                                            HttpServletResponse response,\n                                            InvalidSessionException ise ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Handling invalid session associated with the request.\" );\n        }\n\n        Session session = null;\n\n        if ( isRequireSessionOnRequest() || isCreateNewSessionWhenInvalid() ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Configured to create a new session on invalid session - attempting to start a new session...\" );\n            }\n            session = start( request, response );\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"New session started successfully.\" );\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Configured to _not_ start a new session after an invalid session - returning a null session.\" );\n            }\n        }\n\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Adding EXPIRED_SESSION_KEY as a request attribute to alert that the request's incoming \" +\n                \"referenced session had expired.\" );\n        }\n        request.setAttribute( EXPIRED_SESSION_KEY, Boolean.TRUE );\n\n        return session;\n    }\n\n\n    protected Session doGetSession( HttpServletRequest request, HttpServletResponse response ) {\n\n        Session session = null;\n        Serializable sessionId = retrieveSessionId( request, response );\n\n        if ( sessionId != null ) {\n            ThreadContext.put( REQUEST_REFERENCED_SESSION_ID_THREAD_CONTEXT_KEY, sessionId.toString() );\n            assertSessionFactory();\n            session = sessionFactory.getSession( sessionId );\n            if ( isValidateRequestOrigin() ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"Validating request origin against session origin\" );\n                }\n                validateSessionOrigin( request, session );\n            }\n        } else {\n            if ( log.isWarnEnabled() ) {\n                log.warn( \"No JSecurity session id associated with the given \" +\n                    \"HttpServletRequest.  A Session will not be returned.\" );\n            }\n        }\n        return session;\n\n\n    }\n\n    /**\n     * Acquires a session for the given request, and if there isn't one, automatically creates one and makes it\n     * accessible for future requests.\n     * \n     * @param request incoming servlet request\n     * @param response outgoing servlet response\n     * @return the Session associated with the incoming request, if any.\n     */\n    public final Session getSession( HttpServletRequest request, HttpServletResponse response )\n        throws InvalidSessionException, AuthorizationException {\n\n        Session session;\n\n        try {\n            session = doGetSession( request, response );\n            if ( session == null ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"No JSecurity Session associated with the HttpServletRequest.\" );\n                }\n                if ( isRequireSessionOnRequest() ) {\n                    if ( log.isDebugEnabled() ) {\n                        log.debug( \"JSecurity Sessions are required for each request (per the \" +\n                            \"isRequireSessionOnRequest() attribute) - Attempting to start a new session...\" );\n                    }\n                    session = start( request, response );\n                    if ( log.isDebugEnabled() ) {\n                        log.debug( \"Created new JSecurity Session with id [\" + session.getSessionId() + \"]\" );\n                    }\n                }\n            } else {\n                ThreadContext.put( REQUEST_REFERENCED_SESSION_ID_VALID_THREAD_CONTEXT_KEY, Boolean.TRUE );\n                if ( isTouchSessionOnRequest() ) {\n                    session.touch();\n                }\n            }\n        } catch ( InvalidSessionException ise ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Request JSecurity Session is invalid, message: [\" + ise.getMessage() + \"].\" );\n            }\n            session = handleInvalidSession( request, response, ise );\n        }\n\n        return session;\n    }\n\n    public Session start( HttpServletRequest request, HttpServletResponse response ) {\n        InetAddress clientAddress = SecurityWebSupport.getInetAddress( request );\n        Session session = getSessionFactory().start( clientAddress );\n        //ensure it is available for future requests:\n        storeSessionId( session, request, response );\n        ThreadContext.put( REQUEST_REFERENCED_SESSION_IS_NEW_THREAD_CONTEXT_KEY, Boolean.TRUE );\n        return session;\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.web.support;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.SessionFactory;\nimport org.jsecurity.web.WebSessionFactory;\nimport org.jsecurity.web.WebStore;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.Serializable;\nimport java.net.InetAddress;\n\n/**\n * Default JSecurity implementation of the {@link WebSessionFactory} interface.\n * <p/>\n * <p>This SessionFactory implementation handles web-specific APIs and delegates session creation/acquisition\n * behavior to an underlying wrapped {@link SessionFactory SessionFactory} instance.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class DefaultWebSessionFactory extends SecurityWebSupport implements WebSessionFactory {\n\n    public static final String DEFAULT_SESSION_ID_KEY_NAME = \"jsecSessionId\";\n\n    protected transient final Log log = LogFactory.getLog( getClass() );\n\n    /**\n     * Key that may be used for a http request or session attribute to alert that a referencing JSecurity Session\n     * has expired.\n     */\n    public static final String EXPIRED_SESSION_KEY = SessionWebInterceptor.class.getName() + \"_EXPIRED_SESSION_KEY\";\n\n    private boolean validateRequestOrigin = false; //default\n\n    protected SessionFactory sessionFactory = null;\n\n    //An HttpSessionStore is required if JSecurity sessions can be lazily created (e.g. SecurityContext.getSession())\n    //after the response has started rendering - i.e. inside of a web controller or business-tier component accessed\n    //after the web request comes in.\n    //\n    // Cookies can only be sent out before the response has started rendering, so saving a cookie\n    //_after_ a response is done (as would happen in a web interceptor implementation's postHandle method) is\n    // worthless, since the cookie would never be sent.\n    //\n    // As such, the only time a CookieStore can be used to store the JSecurity sessionId is if the\n    // requireSessionOnRequest property is true, because a session would be created before the interceptor chain is\n    // continued, where it is still 'legal' to modify the HTTP headers (i.e. set a Cookie).  If this property is set\n    // to true in configuration (it is false by default), this implementation will automatically re-assign the\n    // idStore attribute to be a CookieStore in the init() method.  If this property is false, the init method\n    // will automatically create the HttpSessionStore.\n    protected WebStore<Serializable> idStore = null;\n\n    protected boolean requireSessionOnRequest = false;\n    protected boolean createNewSessionWhenInvalid = true;\n    protected boolean touchSessionOnRequest = false; //proactively touch the session on each request to ensure it is valid and timestamp has been updated.\n\n    public DefaultWebSessionFactory(){}\n\n    public DefaultWebSessionFactory( SessionFactory sessionFactory ) {\n        setSessionFactory( sessionFactory );\n    }\n\n    public void setSessionFactory( SessionFactory sessionFactory ) {\n        this.sessionFactory = sessionFactory;\n    }\n\n    public SessionFactory getSessionFactory() {\n        return sessionFactory;\n    }\n\n    public WebStore<Serializable> getIdStore() {\n        return idStore;\n    }\n\n    public void setIdStore( WebStore<Serializable> idStore ) {\n        this.idStore = idStore;\n    }\n\n    /**\n     * If set to <tt>true<\/tt>, this <tt>SessionWebInterceptor<\/tt> will ensure that any\n     * <tt>HttpRequest<\/tt> attempting\n     * to join a session (i.e. via {@link #getSession getSession} must have the same\n     * IP Address of the <tt>HttpRequest<\/tt> that started the session.\n     * <p/>\n     * <p> If set to <tt>false<\/tt>, any <tt>HttpRequest<\/tt> with a reference to a valid\n     * session id may acquire that <tt>Session<\/tt>.\n     * <p/>\n     * <p>Although convenient, this should only be enabled in environments where the\n     * system can <em>guarantee<\/em> that each IP address represents one and only one\n     * machine accessing the system.\n     * <p/>\n     * <p>Public websites are not good candidates for enabling this\n     * feature since many browser clients often sit behind NAT routers (in\n     * which case many machines are viewed to come from the same IP, thereby making this\n     * validation check useless).  Also, some internet service providers (e.g. AOL) may change a\n     * client's IP in mid-session, making subsequent requests appear to come from a different\n     * location.  Again, this feature should only be enabled where IP Addresses can be guaranteed a\n     * 1-to-1 relationship with a user's session.\n     * <p/>\n     * <p>For the reasons specified above, this property is <tt>false<\/tt> by default.\n     *\n     * @return true if this factory will verify each HttpRequest joining a session\n     */\n    public boolean isValidateRequestOrigin() {\n        return validateRequestOrigin;\n    }\n\n    /**\n     * Sets whether or not a request's origin will be validated when accessing a session.  See\n     * the {@link #isValidateRequestOrigin} JavaDoc for an in-depth explanation of this property.\n     *\n     * @param validateRequestOrigin whether or not to validate the request's origin when accessing\n     *                              a session.\n     * @see #isValidateRequestOrigin\n     */\n    public void setValidateRequestOrigin( boolean validateRequestOrigin ) {\n        this.validateRequestOrigin = validateRequestOrigin;\n    }\n\n    public boolean isRequireSessionOnRequest() {\n        return requireSessionOnRequest;\n    }\n\n    public void setRequireSessionOnRequest( boolean requireSessionOnRequest ) {\n        this.requireSessionOnRequest = requireSessionOnRequest;\n    }\n\n    public boolean isCreateNewSessionWhenInvalid() {\n        return createNewSessionWhenInvalid;\n    }\n\n    public void setCreateNewSessionWhenInvalid( boolean createNewSessionWhenInvalid ) {\n        this.createNewSessionWhenInvalid = createNewSessionWhenInvalid;\n    }\n\n    /**\n     * Returns if this WebSessionFactory will proactively {@link Session#touch() touch} a session on every\n     * request to ensure it is valid and its access timestamp has been updated.\n     * <p/>\n     * <p>The default value is <tt>false<\/tt>, since most appliacations actively update their session objects enough\n     * such that the session does not time out.\n     * <p/>\n     * <p>However, if you want to ensure that a session is valid on every request\n     * such that the Session's last access timestamp shows the last time they interacted with the web application,\n     * you will probably want to set this attribute to <tt>true<\/tt>.\n     *\n     * @return if this WebSessionFactory will proactively {@link Session#touch() touch} a session on every\n     *         request to ensure it is valid and its access timestamp has been updated.\n     */\n    public boolean isTouchSessionOnRequest() {\n        return touchSessionOnRequest;\n    }\n\n    public void setTouchSessionOnRequest( boolean touchSessionOnRequest ) {\n        this.touchSessionOnRequest = touchSessionOnRequest;\n    }\n\n    protected void assertSessionFactory() {\n        if ( getSessionFactory() == null ) {\n            String msg = \"sessionFactory property must be set.\";\n            throw new IllegalStateException( msg );\n        }\n    }\n\n    public void init() {\n        assertSessionFactory();\n        WebStore<Serializable> store = getIdStore();\n        if ( store == null ) {\n            if ( isRequireSessionOnRequest() ) {\n                store = new CookieStore<Serializable>( DEFAULT_SESSION_ID_KEY_NAME, CookieStore.INDEFINITE );\n            } else {\n                store = new HttpSessionStore<Serializable>( DEFAULT_SESSION_ID_KEY_NAME );\n            }\n            setIdStore( store );\n        }\n    }\n\n    protected void validateSessionOrigin( HttpServletRequest request, Session session )\n        throws HostUnauthorizedException {\n        InetAddress requestIp = SecurityWebSupport.getInetAddress( request );\n        InetAddress originIp = session.getHostAddress();\n        Serializable sessionId = session.getSessionId();\n\n        if ( originIp == null ) {\n            if ( requestIp != null ) {\n                String msg = \"No IP Address was specified when creating session with id [\" +\n                    sessionId + \"].  Attempting to access session from \" +\n                    \"IP [\" + requestIp + \"].  Origin IP and request IP must match.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        } else {\n            if ( requestIp != null ) {\n                if ( !requestIp.equals( originIp ) ) {\n                    String msg = \"Session with id [\" + sessionId + \"] originated from [\" +\n                        originIp + \"], but the current HttpServletRequest originated \" +\n                        \"from [\" + requestIp + \"].  Disallowing session access: \" +\n                        \"session origin and request origin must match to allow access.\";\n                    throw new HostUnauthorizedException( msg );\n                }\n\n            } else {\n                String msg = \"No IP Address associated with the current HttpServletRequest.  \" +\n                    \"Session with id [\" + sessionId + \"] originated from \" +\n                    \"[\" + originIp + \"].  Request IP must match the session's origin \" +\n                    \"IP in order to gain access to that session.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        }\n    }\n\n    protected void storeSessionId( Session session, HttpServletRequest request, HttpServletResponse response ) {\n        Serializable currentId = session.getSessionId();\n        if ( currentId == null ) {\n            String msg = \"Session#getSessionId() cannot return null when storing sessions for subsequent requests.\";\n            throw new IllegalStateException( msg );\n        }\n        //ensure that the id has been set in the idStore, or if it already has, that it is not different than the\n        //'real' session value:\n        Serializable existingId = retrieveSessionId( request, response );\n        if ( existingId == null || !currentId.equals( existingId ) ) {\n            getIdStore().storeValue( currentId, request, response );\n        }\n    }\n\n    protected Serializable retrieveSessionId( HttpServletRequest request, HttpServletResponse response ) {\n        return getIdStore().retrieveValue( request, response );\n    }\n\n    public Session getSession( Serializable sessionId ) throws InvalidSessionException, AuthorizationException {\n        assertSessionFactory();\n        return sessionFactory.getSession( sessionId );\n    }\n\n    protected Session handleInvalidSession( HttpServletRequest request,\n                                            HttpServletResponse response,\n                                            InvalidSessionException ise ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Handling invalid session associated with the request.\" );\n        }\n        Session session = null;\n\n        if ( isRequireSessionOnRequest() || isCreateNewSessionWhenInvalid() ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Configured to create a new session on invalid session - attempting to start a new session...\" );\n            }\n            session = start( request, response );\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"New session started successfully.\" );\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Configured to _not_ start a new session after an invalid session - returning a null session.\" );\n            }\n        }\n\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Adding EXPIRED_SESSION_KEY as a request attribute to alert that the request's incoming \" +\n                \"referenced session had expired.\" );\n        }\n        request.setAttribute( EXPIRED_SESSION_KEY, Boolean.TRUE );\n\n        return session;\n    }\n\n\n    protected Session doGetSession( HttpServletRequest request, HttpServletResponse response ) {\n\n        Session session = null;\n        Serializable sessionId = retrieveSessionId( request, response );\n\n        if ( sessionId != null ) {\n            assertSessionFactory();\n            session = sessionFactory.getSession( sessionId );\n            if ( isValidateRequestOrigin() ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"Validating request origin against session origin\" );\n                }\n                validateSessionOrigin( request, session );\n            }\n        } else {\n            if ( log.isWarnEnabled() ) {\n                log.warn( \"No JSecurity session id associated with the given \" +\n                    \"HttpServletRequest.  A Session will not be returned.\" );\n            }\n        }\n        return session;\n\n\n    }\n\n    /**\n     * Acquires a session for the given request, and if there isn't one, automatically creates one and makes it\n     * accessible for future requests.\n     * \n     * @param request incoming servlet request\n     * @param response outgoing servlet response\n     * @return the Session associated with the incoming request, if any.\n     */\n    public final Session getSession( HttpServletRequest request, HttpServletResponse response )\n        throws InvalidSessionException, AuthorizationException {\n\n        Session session;\n\n        try {\n            session = doGetSession( request, response );\n            if ( session == null ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"No JSecurity Session associated with the HttpServletRequest.\" );\n                }\n                if ( isRequireSessionOnRequest() ) {\n                    if ( log.isDebugEnabled() ) {\n                        log.debug( \"JSecurity Sessions are required for each request (per the \" +\n                            \"isRequireSessionOnRequest() attribute) - Attempting to start a new session...\" );\n                    }\n                    session = start( request, response );\n                    if ( log.isDebugEnabled() ) {\n                        log.debug( \"Created new JSecurity Session with id [\" + session.getSessionId() + \"]\" );\n                    }\n                }\n            } else {\n                if ( isTouchSessionOnRequest() ) {\n                    session.touch();\n                }\n            }\n        } catch ( InvalidSessionException ise ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Request JSecurity Session is invalid, message: [\" + ise.getMessage() + \"].\" );\n            }\n            session = handleInvalidSession( request, response, ise );\n        }\n\n        return session;\n    }\n\n    public Session start( HttpServletRequest request, HttpServletResponse response ) {\n        InetAddress clientAddress = SecurityWebSupport.getInetAddress( request );\n        Session session = getSessionFactory().start( clientAddress );\n        //ensure it is available for future requests:\n        storeSessionId( session, request, response );\n        return session;\n    }\n}\n","lineNo":265}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.authc.support;\n\nimport static org.easymock.EasyMock.*;\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authc.event.*;\nimport org.jsecurity.authc.event.support.SimpleAuthenticationEventSender;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.bind.SecurityContextBinder;\nimport org.jsecurity.context.factory.SecurityContextFactory;\nimport org.jsecurity.context.support.DelegatingSecurityContext;\nimport static org.junit.Assert.*;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class AbstractAuthenticatorTest {\n\n    AbstractAuthenticator abstractAuthenticator;\n    SecurityManager mockSecurityManager;\n\n    private final SimpleAuthenticationInfo authInfo = new SimpleAuthenticationInfo( \"user1\", \"secret\" );\n\n    private AbstractAuthenticator createAuthcReturnNull() {\n        return new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate( AuthenticationToken token ) throws AuthenticationException {\n                return null;\n            }\n        };\n    }\n\n    private AbstractAuthenticator createAuthcReturnValidAuthcInfo() {\n        return new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate( AuthenticationToken token ) throws AuthenticationException {\n                return authInfo;\n            }\n        };\n    }\n\n    private AuthenticationToken newToken() {\n        return new UsernamePasswordToken( \"user1\", \"secret\".toCharArray() );\n    }\n\n    protected void initAuthc() {\n        abstractAuthenticator.init();\n    }\n\n    @Before\n    public void setUp() {\n        abstractAuthenticator = createAuthcReturnValidAuthcInfo();\n        mockSecurityManager = createMock( SecurityManager.class );\n    }\n\n    @Test\n    public void newAbstractAuthenticatorSecurityManagerConstructor() {\n        mockSecurityManager = createMock( SecurityManager.class );\n        abstractAuthenticator = new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException {\n                return authInfo;\n            }\n        };\n        initAuthc();\n    }\n\n    /**\n     * Asserts that when the init() method is called without a SecurityContextFactory being set as a class attribute,\n     * a SecurityContextFactory is lazily created (based on a previously injected SecurityManager) and non-null.\n     */\n    @Test\n    public void initWithoutSessionFactory() {\n        abstractAuthenticator.init();\n        assertNotNull( abstractAuthenticator.getSecurityContextBinder() ); //default impl set when instance created\n        assertNotNull( abstractAuthenticator.getAuthenticationEventFactory() ); //default impl set when instance created\n        assertNotNull( \"After setting a SecurityManager and calling init() on AbstractAuthenticator, a \" +\n                \"SecurityContextFactory instance should be implicitly created.\",\n                abstractAuthenticator.getSecurityContextFactory() );\n    }\n\n    /**\n     * Asserts that if neither a SecurityContextFactory or a SessionManager have been set and init() is called, that\n     * an exception is thrown due to the instance not being in an intializable state.\n     */\n    @Test(expected=IllegalStateException.class)\n    public void initWithoutSessionFactoryOrSecurityManager() {\n        assertNotNull( abstractAuthenticator.getSecurityContextBinder() ); //default impl set when instance created\n        assertNotNull( abstractAuthenticator.getAuthenticationEventFactory() ); //default impl set when instance created\n        abstractAuthenticator.init();\n    }\n\n    /**\n     * Tests that the authenticate() method fails if the instance's init() method wasn't called.\n     */\n    @Test(expected=IllegalStateException.class)\n    public void authenticateWithoutFirstCallingInit() {\n        abstractAuthenticator.authenticate( newToken() );\n    }\n\n    /**\n     * Ensures that the authenticate() method proactively fails if a <tt>null<\/tt> AuthenticationToken is passed as an\n     * argument.\n     */\n    @Test(expected=IllegalArgumentException.class)\n    public void authenticateWithNullArgument() {\n        initAuthc();\n        abstractAuthenticator.authenticate( null );\n    }\n\n    /**\n     * Ensures that the authenticate() method throws an AuthenticationException if the subclass returns <tt>null<\/tt>\n     * as the return value to the doAuthenticate() method.\n     */\n    @Test(expected=AuthenticationException.class)\n    public void throwAuthenticationExceptionIfDoAuthenticateReturnsNull() {\n        abstractAuthenticator = createAuthcReturnNull();\n        initAuthc();\n        abstractAuthenticator.authenticate( newToken() );\n    }\n\n    /**\n     * Ensures a non-null <tt>SecurityContext<\/tt> instance is returned from the authenticate() method after a valid\n     * authentication attempt (i.e. the subclass's doAuthenticate implementation returns a valid, non-null\n     * AuthenticationInfo object).\n     */\n    @Test\n    public void nonNullSecurityContextAfterAuthenticate() {\n        initAuthc();\n        SecurityContext securityContext = abstractAuthenticator.authenticate( newToken() );\n        assertNotNull( securityContext );\n    }\n\n    /**\n     * Asserts that the internal <tt>SecurityContextFactory<\/tt> (either the default or\n     * explicitly injected) does not return a null SecurityContext during the authentication phase.\n     */\n    @Test(expected=IllegalStateException.class)\n    public void securityContextFactoryReturnsNullAfterSuccessfulAuthentication() {\n        SecurityContextFactory mockSCF = createMock( SecurityContextFactory.class );\n        abstractAuthenticator.setSecurityContextFactory( mockSCF );\n        AuthenticationToken token = newToken();\n        expect( mockSCF.createSecurityContext( token, authInfo ) ).andReturn( null );\n        replay( mockSCF );\n        initAuthc();\n        abstractAuthenticator.authenticate( token );\n\n        verify( mockSCF );\n    }\n\n    /**\n     * Asserts that the AbstractAuthenticator properly calls the <tt>SecurityContextBinder<\/tt> during a successful\n     * authentication attempt.\n     */\n    @Test\n    public void bindSecurityContextAfterDoAuthenticate() {\n        SecurityContextBinder mockBinder = createMock( SecurityContextBinder.class );\n        SecurityContextFactory mockFactory = createMock( SecurityContextFactory.class );\n\n        abstractAuthenticator.setSecurityContextBinder( mockBinder );\n        abstractAuthenticator.setSecurityContextFactory( mockFactory );\n\n        initAuthc();\n\n        SecurityContext sc = new DelegatingSecurityContext( \"user1\", true, null, null, mockSecurityManager );\n\n        AuthenticationToken token = newToken();\n\n        expect( mockFactory.createSecurityContext( token, authInfo ) ).andReturn( sc );\n\n        //this is the test method's purpose: to ensure the following call on the binder is made by the authenticator:\n        mockBinder.bindSecurityContext( sc );\n\n        replay( mockFactory );\n        replay( mockBinder );\n\n        abstractAuthenticator.authenticate( token );\n\n        verify( mockFactory );\n        verify( mockBinder );\n    }\n\n    @Test(expected=AuthenticationException.class)\n    public void createFailureEventReturnsNull() {\n        abstractAuthenticator = new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException {\n                throw new AuthenticationException();\n            }\n            protected AuthenticationEvent createFailureEvent(AuthenticationToken token, AuthenticationException ae) {\n                return null;\n            }\n        };\n        abstractAuthenticator.setAuthenticationEventSender( new SimpleAuthenticationEventSender() );\n        initAuthc();\n        abstractAuthenticator.authenticate( newToken() );\n    }\n\n    @Test\n    public void createSuccessEventReturnsNull() {\n        abstractAuthenticator = new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException {\n                return authInfo;\n            }\n            protected AuthenticationEvent createSuccessEvent(AuthenticationToken token, AuthenticationInfo info ) {\n                return null;\n            }\n        };\n        abstractAuthenticator.setAuthenticationEventSender( new SimpleAuthenticationEventSender() );\n        initAuthc();\n        abstractAuthenticator.authenticate( newToken() );\n    }\n\n    @Test(expected=IllegalArgumentException.class)\n    public void sendWithNullArgument() {\n        initAuthc();\n        abstractAuthenticator.send( null );\n    }\n\n    @Test\n    public void sendWithNonNullSender() {\n        AuthenticationEventSender mockSender = createMock( AuthenticationEventSender.class );\n        abstractAuthenticator.setAuthenticationEventSender( mockSender );\n        initAuthc();\n        AuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n        mockSender.send( successEvent );\n        replay( mockSender );\n        abstractAuthenticator.send( successEvent );\n        verify( mockSender );\n    }\n\n    @Test\n    public void sendWithNullSender() {\n        initAuthc();\n        AuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n        abstractAuthenticator.send( successEvent );\n    }\n\n    @Test\n    public void sendWithSenderThrowingException() {\n        AuthenticationEventSender mockSender = createMock( AuthenticationEventSender.class );\n        AuthenticationEventFactory mockFactory = createMock( AuthenticationEventFactory.class );\n        abstractAuthenticator.setAuthenticationEventFactory( mockFactory );\n        abstractAuthenticator.setAuthenticationEventSender( mockSender );\n        initAuthc();\n        AuthenticationToken token = newToken();\n        SuccessfulAuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n        expect( mockFactory.createSuccessEvent( token, authInfo ) ).andReturn( successEvent );\n        mockSender.send( successEvent );\n        expectLastCall().andThrow( new RuntimeException() );\n        replay( mockFactory );\n        replay( mockSender );\n        abstractAuthenticator.sendSuccessEvent( token, authInfo );\n        verify( mockFactory );\n        verify( mockSender );\n    }\n\n    @Test(expected=AuthenticationException.class)\n    public void sendWithSenderThrowingExceptionFailingAuthentication() {\n        AuthenticationEventSender mockSender = createMock( AuthenticationEventSender.class );\n        AuthenticationEventFactory mockFactory = createMock( AuthenticationEventFactory.class );\n        abstractAuthenticator.setAuthenticationEventFactory( mockFactory );\n        abstractAuthenticator.setAuthenticationEventSender( mockSender );\n        abstractAuthenticator.setEventSendErrorFailsAuthentication( true );\n        initAuthc();\n        AuthenticationToken token = newToken();\n        SuccessfulAuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n        expect( mockFactory.createSuccessEvent( token, authInfo ) ).andReturn( successEvent );\n        mockSender.send( successEvent );\n        expectLastCall().andThrow( new RuntimeException() );\n        replay( mockFactory );\n        replay( mockSender );\n        abstractAuthenticator.sendSuccessEvent( token, authInfo );\n        verify( mockFactory );\n        verify( mockSender );\n    }\n\n    @Test\n    public void sendSuccessEventAfterDoAuthenticate() {\n        AuthenticationEventSender mockAuthcEvtSender = createMock( AuthenticationEventSender.class );\n        AuthenticationEventFactory mockEvtFactory = createMock( AuthenticationEventFactory.class );\n\n        abstractAuthenticator.setAuthenticationEventSender( mockAuthcEvtSender );\n        abstractAuthenticator.setAuthenticationEventFactory( mockEvtFactory  );\n\n        initAuthc();\n\n        AuthenticationToken token = newToken();\n\n        AuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n\n        expect( mockEvtFactory.createSuccessEvent( token, authInfo ) ).andReturn( successEvent );\n        mockAuthcEvtSender.send( successEvent );\n\n        replay( mockEvtFactory );\n        replay( mockAuthcEvtSender );\n\n        abstractAuthenticator.authenticate( token );\n\n        verify( mockEvtFactory );\n        verify( mockAuthcEvtSender );\n    }\n\n    @Test\n    public void sendFailedEventAfterDoAuthenticateThrowsAuthenticationException() {\n        AuthenticationEventSender mockAuthcEvtSender = createMock( AuthenticationEventSender.class );\n        AuthenticationEventFactory mockEvtFactory = createMock( AuthenticationEventFactory.class );\n\n        final AuthenticationException ae = new AuthenticationException( \"dummy exception to test event sending\" );\n        final AuthenticationEvent failedEvent = new FailedAuthenticationEvent( authInfo.getPrincipal(), ae );\n\n\n        abstractAuthenticator = new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate( AuthenticationToken token ) throws AuthenticationException {\n                throw ae;\n            }\n        };\n\n        abstractAuthenticator.setAuthenticationEventSender( mockAuthcEvtSender );\n        abstractAuthenticator.setAuthenticationEventFactory( mockEvtFactory  );\n\n        initAuthc();\n\n        AuthenticationToken token = newToken();\n\n        expect( mockEvtFactory.createFailureEvent( token, ae ) ).andReturn( failedEvent );\n\n        mockAuthcEvtSender.send( failedEvent );\n\n        replay( mockEvtFactory );\n        replay( mockAuthcEvtSender );\n\n        boolean exceptionThrown = false;\n        try {\n            abstractAuthenticator.authenticate( token );\n        } catch (AuthenticationException e) {\n            exceptionThrown = true;\n            assertEquals( e, ae );\n        }\n        verify( mockAuthcEvtSender );\n        verify( mockEvtFactory );\n\n        if ( !exceptionThrown ) {\n            fail( \"An AuthenticationException should have been thrown during the sendFailedEvent test case.\" );\n        }\n    }\n\n    @Test(expected=AuthenticationException.class)\n    public void sendFailedEventAfterDoAuthenticateThrowsNonAuthenticationException() {\n\n        AuthenticationEventSender dummyAuthcEvtSender = new SimpleAuthenticationEventSender();\n\n        abstractAuthenticator = new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate( AuthenticationToken token ) throws AuthenticationException {\n                throw new IllegalArgumentException( \"not an AuthenticationException subclass\" );\n            }\n        };\n\n        abstractAuthenticator.setAuthenticationEventSender( dummyAuthcEvtSender );\n\n        initAuthc();\n\n        AuthenticationToken token = newToken();\n\n        abstractAuthenticator.authenticate( token );\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.authc.support;\n\nimport static org.easymock.EasyMock.*;\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authc.event.*;\nimport org.jsecurity.authc.event.support.SimpleAuthenticationEventSender;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.bind.SecurityContextBinder;\nimport org.jsecurity.context.factory.SecurityContextFactory;\nimport org.jsecurity.context.support.DelegatingSecurityContext;\nimport org.jsecurity.session.Session;\nimport static org.junit.Assert.*;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class AbstractAuthenticatorTest {\n\n    AbstractAuthenticator abstractAuthenticator;\n    SecurityManager mockSecurityManager;\n\n    private final SimpleAuthenticationInfo authInfo =\n            new SimpleAuthenticationInfo( \"user1\", \"secret\" );\n\n    private AbstractAuthenticator createAuthcReturnNull() {\n        return new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate( AuthenticationToken token ) throws AuthenticationException {\n                return null;\n            }\n        };\n    }\n\n    private AbstractAuthenticator createAuthcReturnValidAuthcInfo() {\n        return new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate( AuthenticationToken token ) throws AuthenticationException {\n                return authInfo;\n            }\n        };\n    }\n\n    private AuthenticationToken newToken() {\n        return new UsernamePasswordToken( \"user1\", \"secret\".toCharArray() );\n    }\n\n    protected void initAuthc() {\n        abstractAuthenticator.setSecurityManager( mockSecurityManager );\n        abstractAuthenticator.init();\n    }\n\n    @Before\n    public void setUp() {\n        abstractAuthenticator = createAuthcReturnValidAuthcInfo();\n        mockSecurityManager = createMock( SecurityManager.class );\n    }\n\n    @Test\n    public void newAbstractAuthenticatorSecurityManagerConstructor() {\n        mockSecurityManager = createMock( SecurityManager.class );\n        abstractAuthenticator = new AbstractAuthenticator( mockSecurityManager ) {\n            protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException {\n                return authInfo;\n            }\n        };\n        initAuthc();\n    }\n\n    /**\n     * Asserts that when the init() method is called without a SecurityContextFactory being set as a class attribute,\n     * a SecurityContextFactory is lazily created (based on a previously injected SecurityManager) and non-null.\n     */\n    @Test\n    public void initWithoutSessionFactory() {\n        abstractAuthenticator.setSecurityManager( mockSecurityManager );\n        abstractAuthenticator.init();\n        assertNotNull( abstractAuthenticator.getSecurityContextBinder() ); //default impl set when instance created\n        assertNotNull( abstractAuthenticator.getAuthenticationEventFactory() ); //default impl set when instance created\n        assertNotNull( \"After setting a SecurityManager and calling init() on AbstractAuthenticator, a \" +\n                \"SecurityContextFactory instance should be implicitly created.\",\n                abstractAuthenticator.getSecurityContextFactory() );\n    }\n\n    /**\n     * Asserts that if neither a SecurityContextFactory or a SessionManager have been set and init() is called, that\n     * an exception is thrown due to the instance not being in an intializable state.\n     */\n    @Test(expected=IllegalStateException.class)\n    public void initWithoutSessionFactoryOrSecurityManager() {\n        assertNotNull( abstractAuthenticator.getSecurityContextBinder() ); //default impl set when instance created\n        assertNotNull( abstractAuthenticator.getAuthenticationEventFactory() ); //default impl set when instance created\n        abstractAuthenticator.init();\n    }\n\n    /**\n     * Tests that the authenticate() method fails if the instance's init() method wasn't called.\n     */\n    @Test(expected=IllegalStateException.class)\n    public void authenticateWithoutFirstCallingInit() {\n        abstractAuthenticator.authenticate( newToken() );\n    }\n\n    /**\n     * Ensures that the authenticate() method proactively fails if a <tt>null<\/tt> AuthenticationToken is passed as an\n     * argument.\n     */\n    @Test(expected=IllegalArgumentException.class)\n    public void authenticateWithNullArgument() {\n        initAuthc();\n        abstractAuthenticator.authenticate( null );\n    }\n\n    /**\n     * Ensures that the authenticate() method throws an AuthenticationException if the subclass returns <tt>null<\/tt>\n     * as the return value to the doAuthenticate() method.\n     */\n    @Test(expected=AuthenticationException.class)\n    public void throwAuthenticationExceptionIfDoAuthenticateReturnsNull() {\n        abstractAuthenticator = createAuthcReturnNull();\n        initAuthc();\n        abstractAuthenticator.authenticate( newToken() );\n    }\n\n    /**\n     * Ensures a non-null <tt>SecurityContext<\/tt> instance is returned from the authenticate() method after a valid\n     * authentication attempt (i.e. the subclass's doAuthenticate implementation returns a valid, non-null\n     * AuthenticationInfo object).\n     */\n    @Test\n    public void nonNullSecurityContextAfterAuthenticate() {\n        initAuthc();\n        SecurityContext securityContext = abstractAuthenticator.authenticate( newToken() );\n        assertNotNull( securityContext );\n    }\n\n    /**\n     * Asserts that the internal <tt>SecurityContextFactory<\/tt> (either the default or\n     * explicitly injected) does not return a null SecurityContext during the authentication phase.\n     */\n    @Test(expected=IllegalStateException.class)\n    public void securityContextFactoryReturnsNullAfterSuccessfulAuthentication() {\n        SecurityContextFactory mockSCF = createMock( SecurityContextFactory.class );\n        abstractAuthenticator.setSecurityContextFactory( mockSCF );\n        expect( mockSCF.createSecurityContext( authInfo ) ).andReturn( null );\n        replay( mockSCF );\n        initAuthc();\n        abstractAuthenticator.authenticate( newToken() );\n\n        verify( mockSCF );\n    }\n\n    /**\n     * Asserts that the AbstractAuthenticator properly calls the <tt>SecurityContextBinder<\/tt> during a successful\n     * authentication attempt.\n     */\n    @Test\n    public void bindSecurityContextAfterDoAuthenticate() {\n        SecurityContextBinder mockBinder = createMock( SecurityContextBinder.class );\n        SecurityContextFactory mockFactory = createMock( SecurityContextFactory.class );\n\n        abstractAuthenticator.setSecurityContextBinder( mockBinder );\n        abstractAuthenticator.setSecurityContextFactory( mockFactory );\n\n        initAuthc();\n\n        SecurityContext sc = new DelegatingSecurityContext( new UsernamePrincipal( \"user1\" ), true, null, (Session)null, mockSecurityManager );\n\n        expect( mockFactory.createSecurityContext( authInfo ) ).andReturn( sc );\n\n        //this is the test method's purpose: to ensure the following call on the binder is made by the authenticator:\n        mockBinder.bindSecurityContext( sc );\n\n        replay( mockFactory );\n        replay( mockBinder );\n\n        abstractAuthenticator.authenticate( newToken() );\n\n        verify( mockFactory );\n        verify( mockBinder );\n    }\n\n    @Test(expected=AuthenticationException.class)\n    public void createFailureEventReturnsNull() {\n        abstractAuthenticator = new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException {\n                throw new AuthenticationException();\n            }\n            protected AuthenticationEvent createFailureEvent(AuthenticationToken token, AuthenticationException ae) {\n                return null;\n            }\n        };\n        abstractAuthenticator.setSecurityManager( mockSecurityManager );\n        abstractAuthenticator.setAuthenticationEventSender( new SimpleAuthenticationEventSender() );\n        initAuthc();\n        abstractAuthenticator.authenticate( newToken() );\n    }\n\n    @Test\n    public void createSuccessEventReturnsNull() {\n        abstractAuthenticator = new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException {\n                return authInfo;\n            }\n            protected AuthenticationEvent createSuccessEvent(AuthenticationToken token, AuthenticationInfo info ) {\n                return null;\n            }\n        };\n        abstractAuthenticator.setSecurityManager( mockSecurityManager );\n        abstractAuthenticator.setAuthenticationEventSender( new SimpleAuthenticationEventSender() );\n        initAuthc();\n        abstractAuthenticator.authenticate( newToken() );\n    }\n\n    @Test(expected=IllegalArgumentException.class)\n    public void sendWithNullArgument() {\n        initAuthc();\n        abstractAuthenticator.send( null );\n    }\n\n    @Test\n    public void sendWithNonNullSender() {\n        AuthenticationEventSender mockSender = createMock( AuthenticationEventSender.class );\n        abstractAuthenticator.setAuthenticationEventSender( mockSender );\n        initAuthc();\n        AuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n        mockSender.send( successEvent );\n        replay( mockSender );\n        abstractAuthenticator.send( successEvent );\n        verify( mockSender );\n    }\n\n    @Test\n    public void sendWithNullSender() {\n        initAuthc();\n        AuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n        abstractAuthenticator.send( successEvent );\n    }\n\n    @Test\n    public void sendWithSenderThrowingException() {\n        AuthenticationEventSender mockSender = createMock( AuthenticationEventSender.class );\n        AuthenticationEventFactory mockFactory = createMock( AuthenticationEventFactory.class );\n        abstractAuthenticator.setAuthenticationEventFactory( mockFactory );\n        abstractAuthenticator.setAuthenticationEventSender( mockSender );\n        initAuthc();\n        AuthenticationToken token = newToken();\n        SuccessfulAuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n        expect( mockFactory.createSuccessEvent( token, authInfo ) ).andReturn( successEvent );\n        mockSender.send( successEvent );\n        expectLastCall().andThrow( new RuntimeException() );\n        replay( mockFactory );\n        replay( mockSender );\n        abstractAuthenticator.sendSuccessEvent( token, authInfo );\n        verify( mockFactory );\n        verify( mockSender );\n    }\n\n    @Test(expected=AuthenticationException.class)\n    public void sendWithSenderThrowingExceptionFailingAuthentication() {\n        AuthenticationEventSender mockSender = createMock( AuthenticationEventSender.class );\n        AuthenticationEventFactory mockFactory = createMock( AuthenticationEventFactory.class );\n        abstractAuthenticator.setAuthenticationEventFactory( mockFactory );\n        abstractAuthenticator.setAuthenticationEventSender( mockSender );\n        abstractAuthenticator.setEventSendErrorFailsAuthentication( true );\n        initAuthc();\n        AuthenticationToken token = newToken();\n        SuccessfulAuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n        expect( mockFactory.createSuccessEvent( token, authInfo ) ).andReturn( successEvent );\n        mockSender.send( successEvent );\n        expectLastCall().andThrow( new RuntimeException() );\n        replay( mockFactory );\n        replay( mockSender );\n        abstractAuthenticator.sendSuccessEvent( token, authInfo );\n        verify( mockFactory );\n        verify( mockSender );\n    }\n\n    @Test\n    public void sendSuccessEventAfterDoAuthenticate() {\n        AuthenticationEventSender mockAuthcEvtSender = createMock( AuthenticationEventSender.class );\n        AuthenticationEventFactory mockEvtFactory = createMock( AuthenticationEventFactory.class );\n\n        abstractAuthenticator.setAuthenticationEventSender( mockAuthcEvtSender );\n        abstractAuthenticator.setAuthenticationEventFactory( mockEvtFactory  );\n\n        initAuthc();\n\n        AuthenticationToken token = newToken();\n\n        AuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n\n        expect( mockEvtFactory.createSuccessEvent( token, authInfo ) ).andReturn( successEvent );\n        mockAuthcEvtSender.send( successEvent );\n\n        replay( mockEvtFactory );\n        replay( mockAuthcEvtSender );\n\n        abstractAuthenticator.authenticate( token );\n\n        verify( mockEvtFactory );\n        verify( mockAuthcEvtSender );\n    }\n\n    @Test\n    public void sendFailedEventAfterDoAuthenticateThrowsAuthenticationException() {\n        AuthenticationEventSender mockAuthcEvtSender = createMock( AuthenticationEventSender.class );\n        AuthenticationEventFactory mockEvtFactory = createMock( AuthenticationEventFactory.class );\n\n        final AuthenticationException ae = new AuthenticationException( \"dummy exception to test event sending\" );\n        final AuthenticationEvent failedEvent = new FailedAuthenticationEvent( authInfo.getPrincipal(), ae );\n\n\n        abstractAuthenticator = new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate( AuthenticationToken token ) throws AuthenticationException {\n                throw ae;\n            }\n        };\n\n        abstractAuthenticator.setAuthenticationEventSender( mockAuthcEvtSender );\n        abstractAuthenticator.setAuthenticationEventFactory( mockEvtFactory  );\n\n        initAuthc();\n\n        AuthenticationToken token = newToken();\n\n        expect( mockEvtFactory.createFailureEvent( token, ae ) ).andReturn( failedEvent );\n\n        mockAuthcEvtSender.send( failedEvent );\n\n        replay( mockEvtFactory );\n        replay( mockAuthcEvtSender );\n\n        boolean exceptionThrown = false;\n        try {\n            abstractAuthenticator.authenticate( token );\n        } catch (AuthenticationException e) {\n            exceptionThrown = true;\n            assertEquals( e, ae );\n        }\n        verify( mockAuthcEvtSender );\n        verify( mockEvtFactory );\n\n        if ( !exceptionThrown ) {\n            fail( \"An AuthenticationException should have been thrown during the sendFailedEvent test case.\" );\n        }\n    }\n\n    @Test(expected=AuthenticationException.class)\n    public void sendFailedEventAfterDoAuthenticateThrowsNonAuthenticationException() {\n\n        AuthenticationEventSender dummyAuthcEvtSender = new SimpleAuthenticationEventSender();\n\n        abstractAuthenticator = new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate( AuthenticationToken token ) throws AuthenticationException {\n                throw new IllegalArgumentException( \"not an AuthenticationException subclass\" );\n            }\n        };\n\n        abstractAuthenticator.setAuthenticationEventSender( dummyAuthcEvtSender );\n\n        initAuthc();\n\n        AuthenticationToken token = newToken();\n\n        abstractAuthenticator.authenticate( token );\n    }\n\n}\n","lineNo":165}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.authc.support;\n\nimport static org.easymock.EasyMock.*;\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authc.event.*;\nimport org.jsecurity.authc.event.support.SimpleAuthenticationEventSender;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.bind.SecurityContextBinder;\nimport org.jsecurity.context.factory.SecurityContextFactory;\nimport org.jsecurity.context.support.DelegatingSecurityContext;\nimport static org.junit.Assert.*;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class AbstractAuthenticatorTest {\n\n    AbstractAuthenticator abstractAuthenticator;\n    SecurityManager mockSecurityManager;\n\n    private final SimpleAuthenticationInfo authInfo = new SimpleAuthenticationInfo( \"user1\", \"secret\" );\n\n    private AbstractAuthenticator createAuthcReturnNull() {\n        return new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate( AuthenticationToken token ) throws AuthenticationException {\n                return null;\n            }\n        };\n    }\n\n    private AbstractAuthenticator createAuthcReturnValidAuthcInfo() {\n        return new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate( AuthenticationToken token ) throws AuthenticationException {\n                return authInfo;\n            }\n        };\n    }\n\n    private AuthenticationToken newToken() {\n        return new UsernamePasswordToken( \"user1\", \"secret\".toCharArray() );\n    }\n\n    protected void initAuthc() {\n        abstractAuthenticator.init();\n    }\n\n    @Before\n    public void setUp() {\n        abstractAuthenticator = createAuthcReturnValidAuthcInfo();\n        mockSecurityManager = createMock( SecurityManager.class );\n    }\n\n    @Test\n    public void newAbstractAuthenticatorSecurityManagerConstructor() {\n        mockSecurityManager = createMock( SecurityManager.class );\n        abstractAuthenticator = new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException {\n                return authInfo;\n            }\n        };\n        initAuthc();\n    }\n\n    /**\n     * Asserts that when the init() method is called without a SecurityContextFactory being set as a class attribute,\n     * a SecurityContextFactory is lazily created (based on a previously injected SecurityManager) and non-null.\n     */\n    @Test\n    public void initWithoutSessionFactory() {\n        abstractAuthenticator.init();\n        assertNotNull( abstractAuthenticator.getSecurityContextBinder() ); //default impl set when instance created\n        assertNotNull( abstractAuthenticator.getAuthenticationEventFactory() ); //default impl set when instance created\n        assertNotNull( \"After setting a SecurityManager and calling init() on AbstractAuthenticator, a \" +\n                \"SecurityContextFactory instance should be implicitly created.\",\n                abstractAuthenticator.getSecurityContextFactory() );\n    }\n\n    /**\n     * Asserts that if neither a SecurityContextFactory or a SessionManager have been set and init() is called, that\n     * an exception is thrown due to the instance not being in an intializable state.\n     */\n    @Test(expected=IllegalStateException.class)\n    public void initWithoutSessionFactoryOrSecurityManager() {\n        assertNotNull( abstractAuthenticator.getSecurityContextBinder() ); //default impl set when instance created\n        assertNotNull( abstractAuthenticator.getAuthenticationEventFactory() ); //default impl set when instance created\n        abstractAuthenticator.init();\n    }\n\n    /**\n     * Tests that the authenticate() method fails if the instance's init() method wasn't called.\n     */\n    @Test(expected=IllegalStateException.class)\n    public void authenticateWithoutFirstCallingInit() {\n        abstractAuthenticator.authenticate( newToken() );\n    }\n\n    /**\n     * Ensures that the authenticate() method proactively fails if a <tt>null<\/tt> AuthenticationToken is passed as an\n     * argument.\n     */\n    @Test(expected=IllegalArgumentException.class)\n    public void authenticateWithNullArgument() {\n        initAuthc();\n        abstractAuthenticator.authenticate( null );\n    }\n\n    /**\n     * Ensures that the authenticate() method throws an AuthenticationException if the subclass returns <tt>null<\/tt>\n     * as the return value to the doAuthenticate() method.\n     */\n    @Test(expected=AuthenticationException.class)\n    public void throwAuthenticationExceptionIfDoAuthenticateReturnsNull() {\n        abstractAuthenticator = createAuthcReturnNull();\n        initAuthc();\n        abstractAuthenticator.authenticate( newToken() );\n    }\n\n    /**\n     * Ensures a non-null <tt>SecurityContext<\/tt> instance is returned from the authenticate() method after a valid\n     * authentication attempt (i.e. the subclass's doAuthenticate implementation returns a valid, non-null\n     * AuthenticationInfo object).\n     */\n    @Test\n    public void nonNullSecurityContextAfterAuthenticate() {\n        initAuthc();\n        SecurityContext securityContext = abstractAuthenticator.authenticate( newToken() );\n        assertNotNull( securityContext );\n    }\n\n    /**\n     * Asserts that the internal <tt>SecurityContextFactory<\/tt> (either the default or\n     * explicitly injected) does not return a null SecurityContext during the authentication phase.\n     */\n    @Test(expected=IllegalStateException.class)\n    public void securityContextFactoryReturnsNullAfterSuccessfulAuthentication() {\n        SecurityContextFactory mockSCF = createMock( SecurityContextFactory.class );\n        abstractAuthenticator.setSecurityContextFactory( mockSCF );\n        AuthenticationToken token = newToken();\n        expect( mockSCF.createSecurityContext( token, authInfo ) ).andReturn( null );\n        replay( mockSCF );\n        initAuthc();\n        abstractAuthenticator.authenticate( token );\n\n        verify( mockSCF );\n    }\n\n    /**\n     * Asserts that the AbstractAuthenticator properly calls the <tt>SecurityContextBinder<\/tt> during a successful\n     * authentication attempt.\n     */\n    @Test\n    public void bindSecurityContextAfterDoAuthenticate() {\n        SecurityContextBinder mockBinder = createMock( SecurityContextBinder.class );\n        SecurityContextFactory mockFactory = createMock( SecurityContextFactory.class );\n\n        abstractAuthenticator.setSecurityContextBinder( mockBinder );\n        abstractAuthenticator.setSecurityContextFactory( mockFactory );\n\n        initAuthc();\n\n        SecurityContext sc = new DelegatingSecurityContext( \"user1\", true, null, null, mockSecurityManager );\n\n        AuthenticationToken token = newToken();\n\n        expect( mockFactory.createSecurityContext( token, authInfo ) ).andReturn( sc );\n\n        //this is the test method's purpose: to ensure the following call on the binder is made by the authenticator:\n        mockBinder.bindSecurityContext( sc );\n\n        replay( mockFactory );\n        replay( mockBinder );\n\n        abstractAuthenticator.authenticate( token );\n\n        verify( mockFactory );\n        verify( mockBinder );\n    }\n\n    @Test(expected=AuthenticationException.class)\n    public void createFailureEventReturnsNull() {\n        abstractAuthenticator = new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException {\n                throw new AuthenticationException();\n            }\n            protected AuthenticationEvent createFailureEvent(AuthenticationToken token, AuthenticationException ae) {\n                return null;\n            }\n        };\n        abstractAuthenticator.setAuthenticationEventSender( new SimpleAuthenticationEventSender() );\n        initAuthc();\n        abstractAuthenticator.authenticate( newToken() );\n    }\n\n    @Test\n    public void createSuccessEventReturnsNull() {\n        abstractAuthenticator = new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException {\n                return authInfo;\n            }\n            protected AuthenticationEvent createSuccessEvent(AuthenticationToken token, AuthenticationInfo info ) {\n                return null;\n            }\n        };\n        abstractAuthenticator.setAuthenticationEventSender( new SimpleAuthenticationEventSender() );\n        initAuthc();\n        abstractAuthenticator.authenticate( newToken() );\n    }\n\n    @Test(expected=IllegalArgumentException.class)\n    public void sendWithNullArgument() {\n        initAuthc();\n        abstractAuthenticator.send( null );\n    }\n\n    @Test\n    public void sendWithNonNullSender() {\n        AuthenticationEventSender mockSender = createMock( AuthenticationEventSender.class );\n        abstractAuthenticator.setAuthenticationEventSender( mockSender );\n        initAuthc();\n        AuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n        mockSender.send( successEvent );\n        replay( mockSender );\n        abstractAuthenticator.send( successEvent );\n        verify( mockSender );\n    }\n\n    @Test\n    public void sendWithNullSender() {\n        initAuthc();\n        AuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n        abstractAuthenticator.send( successEvent );\n    }\n\n    @Test\n    public void sendWithSenderThrowingException() {\n        AuthenticationEventSender mockSender = createMock( AuthenticationEventSender.class );\n        AuthenticationEventFactory mockFactory = createMock( AuthenticationEventFactory.class );\n        abstractAuthenticator.setAuthenticationEventFactory( mockFactory );\n        abstractAuthenticator.setAuthenticationEventSender( mockSender );\n        initAuthc();\n        AuthenticationToken token = newToken();\n        SuccessfulAuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n        expect( mockFactory.createSuccessEvent( token, authInfo ) ).andReturn( successEvent );\n        mockSender.send( successEvent );\n        expectLastCall().andThrow( new RuntimeException() );\n        replay( mockFactory );\n        replay( mockSender );\n        abstractAuthenticator.sendSuccessEvent( token, authInfo );\n        verify( mockFactory );\n        verify( mockSender );\n    }\n\n    @Test(expected=AuthenticationException.class)\n    public void sendWithSenderThrowingExceptionFailingAuthentication() {\n        AuthenticationEventSender mockSender = createMock( AuthenticationEventSender.class );\n        AuthenticationEventFactory mockFactory = createMock( AuthenticationEventFactory.class );\n        abstractAuthenticator.setAuthenticationEventFactory( mockFactory );\n        abstractAuthenticator.setAuthenticationEventSender( mockSender );\n        abstractAuthenticator.setEventSendErrorFailsAuthentication( true );\n        initAuthc();\n        AuthenticationToken token = newToken();\n        SuccessfulAuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n        expect( mockFactory.createSuccessEvent( token, authInfo ) ).andReturn( successEvent );\n        mockSender.send( successEvent );\n        expectLastCall().andThrow( new RuntimeException() );\n        replay( mockFactory );\n        replay( mockSender );\n        abstractAuthenticator.sendSuccessEvent( token, authInfo );\n        verify( mockFactory );\n        verify( mockSender );\n    }\n\n    @Test\n    public void sendSuccessEventAfterDoAuthenticate() {\n        AuthenticationEventSender mockAuthcEvtSender = createMock( AuthenticationEventSender.class );\n        AuthenticationEventFactory mockEvtFactory = createMock( AuthenticationEventFactory.class );\n\n        abstractAuthenticator.setAuthenticationEventSender( mockAuthcEvtSender );\n        abstractAuthenticator.setAuthenticationEventFactory( mockEvtFactory  );\n\n        initAuthc();\n\n        AuthenticationToken token = newToken();\n\n        AuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n\n        expect( mockEvtFactory.createSuccessEvent( token, authInfo ) ).andReturn( successEvent );\n        mockAuthcEvtSender.send( successEvent );\n\n        replay( mockEvtFactory );\n        replay( mockAuthcEvtSender );\n\n        abstractAuthenticator.authenticate( token );\n\n        verify( mockEvtFactory );\n        verify( mockAuthcEvtSender );\n    }\n\n    @Test\n    public void sendFailedEventAfterDoAuthenticateThrowsAuthenticationException() {\n        AuthenticationEventSender mockAuthcEvtSender = createMock( AuthenticationEventSender.class );\n        AuthenticationEventFactory mockEvtFactory = createMock( AuthenticationEventFactory.class );\n\n        final AuthenticationException ae = new AuthenticationException( \"dummy exception to test event sending\" );\n        final AuthenticationEvent failedEvent = new FailedAuthenticationEvent( authInfo.getPrincipal(), ae );\n\n\n        abstractAuthenticator = new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate( AuthenticationToken token ) throws AuthenticationException {\n                throw ae;\n            }\n        };\n\n        abstractAuthenticator.setAuthenticationEventSender( mockAuthcEvtSender );\n        abstractAuthenticator.setAuthenticationEventFactory( mockEvtFactory  );\n\n        initAuthc();\n\n        AuthenticationToken token = newToken();\n\n        expect( mockEvtFactory.createFailureEvent( token, ae ) ).andReturn( failedEvent );\n\n        mockAuthcEvtSender.send( failedEvent );\n\n        replay( mockEvtFactory );\n        replay( mockAuthcEvtSender );\n\n        boolean exceptionThrown = false;\n        try {\n            abstractAuthenticator.authenticate( token );\n        } catch (AuthenticationException e) {\n            exceptionThrown = true;\n            assertEquals( e, ae );\n        }\n        verify( mockAuthcEvtSender );\n        verify( mockEvtFactory );\n\n        if ( !exceptionThrown ) {\n            fail( \"An AuthenticationException should have been thrown during the sendFailedEvent test case.\" );\n        }\n    }\n\n    @Test(expected=AuthenticationException.class)\n    public void sendFailedEventAfterDoAuthenticateThrowsNonAuthenticationException() {\n\n        AuthenticationEventSender dummyAuthcEvtSender = new SimpleAuthenticationEventSender();\n\n        abstractAuthenticator = new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate( AuthenticationToken token ) throws AuthenticationException {\n                throw new IllegalArgumentException( \"not an AuthenticationException subclass\" );\n            }\n        };\n\n        abstractAuthenticator.setAuthenticationEventSender( dummyAuthcEvtSender );\n\n        initAuthc();\n\n        AuthenticationToken token = newToken();\n\n        abstractAuthenticator.authenticate( token );\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.authc.support;\n\nimport static org.easymock.EasyMock.*;\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authc.event.*;\nimport org.jsecurity.authc.event.support.SimpleAuthenticationEventSender;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.bind.SecurityContextBinder;\nimport org.jsecurity.context.factory.SecurityContextFactory;\nimport org.jsecurity.context.support.DelegatingSecurityContext;\nimport org.jsecurity.session.Session;\nimport static org.junit.Assert.*;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class AbstractAuthenticatorTest {\n\n    AbstractAuthenticator abstractAuthenticator;\n    SecurityManager mockSecurityManager;\n\n    private final SimpleAuthenticationInfo authInfo =\n            new SimpleAuthenticationInfo( \"user1\", \"secret\" );\n\n    private AbstractAuthenticator createAuthcReturnNull() {\n        return new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate( AuthenticationToken token ) throws AuthenticationException {\n                return null;\n            }\n        };\n    }\n\n    private AbstractAuthenticator createAuthcReturnValidAuthcInfo() {\n        return new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate( AuthenticationToken token ) throws AuthenticationException {\n                return authInfo;\n            }\n        };\n    }\n\n    private AuthenticationToken newToken() {\n        return new UsernamePasswordToken( \"user1\", \"secret\".toCharArray() );\n    }\n\n    protected void initAuthc() {\n        abstractAuthenticator.setSecurityManager( mockSecurityManager );\n        abstractAuthenticator.init();\n    }\n\n    @Before\n    public void setUp() {\n        abstractAuthenticator = createAuthcReturnValidAuthcInfo();\n        mockSecurityManager = createMock( SecurityManager.class );\n    }\n\n    @Test\n    public void newAbstractAuthenticatorSecurityManagerConstructor() {\n        mockSecurityManager = createMock( SecurityManager.class );\n        abstractAuthenticator = new AbstractAuthenticator( mockSecurityManager ) {\n            protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException {\n                return authInfo;\n            }\n        };\n        initAuthc();\n    }\n\n    /**\n     * Asserts that when the init() method is called without a SecurityContextFactory being set as a class attribute,\n     * a SecurityContextFactory is lazily created (based on a previously injected SecurityManager) and non-null.\n     */\n    @Test\n    public void initWithoutSessionFactory() {\n        abstractAuthenticator.setSecurityManager( mockSecurityManager );\n        abstractAuthenticator.init();\n        assertNotNull( abstractAuthenticator.getSecurityContextBinder() ); //default impl set when instance created\n        assertNotNull( abstractAuthenticator.getAuthenticationEventFactory() ); //default impl set when instance created\n        assertNotNull( \"After setting a SecurityManager and calling init() on AbstractAuthenticator, a \" +\n                \"SecurityContextFactory instance should be implicitly created.\",\n                abstractAuthenticator.getSecurityContextFactory() );\n    }\n\n    /**\n     * Asserts that if neither a SecurityContextFactory or a SessionManager have been set and init() is called, that\n     * an exception is thrown due to the instance not being in an intializable state.\n     */\n    @Test(expected=IllegalStateException.class)\n    public void initWithoutSessionFactoryOrSecurityManager() {\n        assertNotNull( abstractAuthenticator.getSecurityContextBinder() ); //default impl set when instance created\n        assertNotNull( abstractAuthenticator.getAuthenticationEventFactory() ); //default impl set when instance created\n        abstractAuthenticator.init();\n    }\n\n    /**\n     * Tests that the authenticate() method fails if the instance's init() method wasn't called.\n     */\n    @Test(expected=IllegalStateException.class)\n    public void authenticateWithoutFirstCallingInit() {\n        abstractAuthenticator.authenticate( newToken() );\n    }\n\n    /**\n     * Ensures that the authenticate() method proactively fails if a <tt>null<\/tt> AuthenticationToken is passed as an\n     * argument.\n     */\n    @Test(expected=IllegalArgumentException.class)\n    public void authenticateWithNullArgument() {\n        initAuthc();\n        abstractAuthenticator.authenticate( null );\n    }\n\n    /**\n     * Ensures that the authenticate() method throws an AuthenticationException if the subclass returns <tt>null<\/tt>\n     * as the return value to the doAuthenticate() method.\n     */\n    @Test(expected=AuthenticationException.class)\n    public void throwAuthenticationExceptionIfDoAuthenticateReturnsNull() {\n        abstractAuthenticator = createAuthcReturnNull();\n        initAuthc();\n        abstractAuthenticator.authenticate( newToken() );\n    }\n\n    /**\n     * Ensures a non-null <tt>SecurityContext<\/tt> instance is returned from the authenticate() method after a valid\n     * authentication attempt (i.e. the subclass's doAuthenticate implementation returns a valid, non-null\n     * AuthenticationInfo object).\n     */\n    @Test\n    public void nonNullSecurityContextAfterAuthenticate() {\n        initAuthc();\n        SecurityContext securityContext = abstractAuthenticator.authenticate( newToken() );\n        assertNotNull( securityContext );\n    }\n\n    /**\n     * Asserts that the internal <tt>SecurityContextFactory<\/tt> (either the default or\n     * explicitly injected) does not return a null SecurityContext during the authentication phase.\n     */\n    @Test(expected=IllegalStateException.class)\n    public void securityContextFactoryReturnsNullAfterSuccessfulAuthentication() {\n        SecurityContextFactory mockSCF = createMock( SecurityContextFactory.class );\n        abstractAuthenticator.setSecurityContextFactory( mockSCF );\n        expect( mockSCF.createSecurityContext( authInfo ) ).andReturn( null );\n        replay( mockSCF );\n        initAuthc();\n        abstractAuthenticator.authenticate( newToken() );\n\n        verify( mockSCF );\n    }\n\n    /**\n     * Asserts that the AbstractAuthenticator properly calls the <tt>SecurityContextBinder<\/tt> during a successful\n     * authentication attempt.\n     */\n    @Test\n    public void bindSecurityContextAfterDoAuthenticate() {\n        SecurityContextBinder mockBinder = createMock( SecurityContextBinder.class );\n        SecurityContextFactory mockFactory = createMock( SecurityContextFactory.class );\n\n        abstractAuthenticator.setSecurityContextBinder( mockBinder );\n        abstractAuthenticator.setSecurityContextFactory( mockFactory );\n\n        initAuthc();\n\n        SecurityContext sc = new DelegatingSecurityContext( new UsernamePrincipal( \"user1\" ), true, null, (Session)null, mockSecurityManager );\n\n        expect( mockFactory.createSecurityContext( authInfo ) ).andReturn( sc );\n\n        //this is the test method's purpose: to ensure the following call on the binder is made by the authenticator:\n        mockBinder.bindSecurityContext( sc );\n\n        replay( mockFactory );\n        replay( mockBinder );\n\n        abstractAuthenticator.authenticate( newToken() );\n\n        verify( mockFactory );\n        verify( mockBinder );\n    }\n\n    @Test(expected=AuthenticationException.class)\n    public void createFailureEventReturnsNull() {\n        abstractAuthenticator = new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException {\n                throw new AuthenticationException();\n            }\n            protected AuthenticationEvent createFailureEvent(AuthenticationToken token, AuthenticationException ae) {\n                return null;\n            }\n        };\n        abstractAuthenticator.setSecurityManager( mockSecurityManager );\n        abstractAuthenticator.setAuthenticationEventSender( new SimpleAuthenticationEventSender() );\n        initAuthc();\n        abstractAuthenticator.authenticate( newToken() );\n    }\n\n    @Test\n    public void createSuccessEventReturnsNull() {\n        abstractAuthenticator = new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException {\n                return authInfo;\n            }\n            protected AuthenticationEvent createSuccessEvent(AuthenticationToken token, AuthenticationInfo info ) {\n                return null;\n            }\n        };\n        abstractAuthenticator.setSecurityManager( mockSecurityManager );\n        abstractAuthenticator.setAuthenticationEventSender( new SimpleAuthenticationEventSender() );\n        initAuthc();\n        abstractAuthenticator.authenticate( newToken() );\n    }\n\n    @Test(expected=IllegalArgumentException.class)\n    public void sendWithNullArgument() {\n        initAuthc();\n        abstractAuthenticator.send( null );\n    }\n\n    @Test\n    public void sendWithNonNullSender() {\n        AuthenticationEventSender mockSender = createMock( AuthenticationEventSender.class );\n        abstractAuthenticator.setAuthenticationEventSender( mockSender );\n        initAuthc();\n        AuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n        mockSender.send( successEvent );\n        replay( mockSender );\n        abstractAuthenticator.send( successEvent );\n        verify( mockSender );\n    }\n\n    @Test\n    public void sendWithNullSender() {\n        initAuthc();\n        AuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n        abstractAuthenticator.send( successEvent );\n    }\n\n    @Test\n    public void sendWithSenderThrowingException() {\n        AuthenticationEventSender mockSender = createMock( AuthenticationEventSender.class );\n        AuthenticationEventFactory mockFactory = createMock( AuthenticationEventFactory.class );\n        abstractAuthenticator.setAuthenticationEventFactory( mockFactory );\n        abstractAuthenticator.setAuthenticationEventSender( mockSender );\n        initAuthc();\n        AuthenticationToken token = newToken();\n        SuccessfulAuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n        expect( mockFactory.createSuccessEvent( token, authInfo ) ).andReturn( successEvent );\n        mockSender.send( successEvent );\n        expectLastCall().andThrow( new RuntimeException() );\n        replay( mockFactory );\n        replay( mockSender );\n        abstractAuthenticator.sendSuccessEvent( token, authInfo );\n        verify( mockFactory );\n        verify( mockSender );\n    }\n\n    @Test(expected=AuthenticationException.class)\n    public void sendWithSenderThrowingExceptionFailingAuthentication() {\n        AuthenticationEventSender mockSender = createMock( AuthenticationEventSender.class );\n        AuthenticationEventFactory mockFactory = createMock( AuthenticationEventFactory.class );\n        abstractAuthenticator.setAuthenticationEventFactory( mockFactory );\n        abstractAuthenticator.setAuthenticationEventSender( mockSender );\n        abstractAuthenticator.setEventSendErrorFailsAuthentication( true );\n        initAuthc();\n        AuthenticationToken token = newToken();\n        SuccessfulAuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n        expect( mockFactory.createSuccessEvent( token, authInfo ) ).andReturn( successEvent );\n        mockSender.send( successEvent );\n        expectLastCall().andThrow( new RuntimeException() );\n        replay( mockFactory );\n        replay( mockSender );\n        abstractAuthenticator.sendSuccessEvent( token, authInfo );\n        verify( mockFactory );\n        verify( mockSender );\n    }\n\n    @Test\n    public void sendSuccessEventAfterDoAuthenticate() {\n        AuthenticationEventSender mockAuthcEvtSender = createMock( AuthenticationEventSender.class );\n        AuthenticationEventFactory mockEvtFactory = createMock( AuthenticationEventFactory.class );\n\n        abstractAuthenticator.setAuthenticationEventSender( mockAuthcEvtSender );\n        abstractAuthenticator.setAuthenticationEventFactory( mockEvtFactory  );\n\n        initAuthc();\n\n        AuthenticationToken token = newToken();\n\n        AuthenticationEvent successEvent = new SuccessfulAuthenticationEvent( authInfo.getPrincipal() );\n\n        expect( mockEvtFactory.createSuccessEvent( token, authInfo ) ).andReturn( successEvent );\n        mockAuthcEvtSender.send( successEvent );\n\n        replay( mockEvtFactory );\n        replay( mockAuthcEvtSender );\n\n        abstractAuthenticator.authenticate( token );\n\n        verify( mockEvtFactory );\n        verify( mockAuthcEvtSender );\n    }\n\n    @Test\n    public void sendFailedEventAfterDoAuthenticateThrowsAuthenticationException() {\n        AuthenticationEventSender mockAuthcEvtSender = createMock( AuthenticationEventSender.class );\n        AuthenticationEventFactory mockEvtFactory = createMock( AuthenticationEventFactory.class );\n\n        final AuthenticationException ae = new AuthenticationException( \"dummy exception to test event sending\" );\n        final AuthenticationEvent failedEvent = new FailedAuthenticationEvent( authInfo.getPrincipal(), ae );\n\n\n        abstractAuthenticator = new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate( AuthenticationToken token ) throws AuthenticationException {\n                throw ae;\n            }\n        };\n\n        abstractAuthenticator.setAuthenticationEventSender( mockAuthcEvtSender );\n        abstractAuthenticator.setAuthenticationEventFactory( mockEvtFactory  );\n\n        initAuthc();\n\n        AuthenticationToken token = newToken();\n\n        expect( mockEvtFactory.createFailureEvent( token, ae ) ).andReturn( failedEvent );\n\n        mockAuthcEvtSender.send( failedEvent );\n\n        replay( mockEvtFactory );\n        replay( mockAuthcEvtSender );\n\n        boolean exceptionThrown = false;\n        try {\n            abstractAuthenticator.authenticate( token );\n        } catch (AuthenticationException e) {\n            exceptionThrown = true;\n            assertEquals( e, ae );\n        }\n        verify( mockAuthcEvtSender );\n        verify( mockEvtFactory );\n\n        if ( !exceptionThrown ) {\n            fail( \"An AuthenticationException should have been thrown during the sendFailedEvent test case.\" );\n        }\n    }\n\n    @Test(expected=AuthenticationException.class)\n    public void sendFailedEventAfterDoAuthenticateThrowsNonAuthenticationException() {\n\n        AuthenticationEventSender dummyAuthcEvtSender = new SimpleAuthenticationEventSender();\n\n        abstractAuthenticator = new AbstractAuthenticator() {\n            protected AuthenticationInfo doAuthenticate( AuthenticationToken token ) throws AuthenticationException {\n                throw new IllegalArgumentException( \"not an AuthenticationException subclass\" );\n            }\n        };\n\n        abstractAuthenticator.setAuthenticationEventSender( dummyAuthcEvtSender );\n\n        initAuthc();\n\n        AuthenticationToken token = newToken();\n\n        abstractAuthenticator.authenticate( token );\n    }\n\n}\n","lineNo":190}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.Permission;\n\nimport java.lang.reflect.Constructor;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\n/**\n * @since 0.1\n * @author Les Hazlewood\n */\npublic class PermissionUtils {\n\n    private static final String PERMISSIONS_DELIMITER = \";\";\n    private static final String PERMISSION_PART_DELIMITER = \",\";\n\n    protected static transient final Log log = LogFactory.getLog( PermissionUtils.class );\n\n    private static String strip( String in ) {\n        String out = null;\n        if ( in != null ) {\n            out = in.trim();\n            if ( out.equals( \"\" ) ) {\n                out = null;\n            }\n        }\n        return out;\n    }\n\n    private static Class[] getTypes( Object[] args ) {\n        if ( args == null || args.length == 0 ) {\n            return null;\n        } else {\n            Class[] types = new Class[args.length];\n            for( int i = 0; i < args.length; i++ ) {\n                Object arg = args[i];\n                types[i] = ( arg != null ? arg.getClass() : null );\n            }\n            return types;\n        }\n    }\n\n    private static Object[] toArray( String arg1, String arg2 ) {\n        Object[] array = null;\n        if ( arg2 != null ) {\n            array = new Object[]{ arg1, arg2 };\n        } else {\n            if ( arg1 != null ) {\n                array = new Object[]{ arg1 };\n            } else {\n                array = null;\n            }\n        }\n        return array;\n    }\n\n    public static Permission createPermissino( String permissionFullyQualifiedClassName ) {\n        return createPermission( permissionFullyQualifiedClassName, null, null );\n    }\n    \n    public static Permission createPermission( String permissionClassName, String nameOrTarget ) {\n        return createPermission( permissionClassName, nameOrTarget, null );\n    }\n\n    public static Permission createPermission( String permissionClassName,\n                                               String nameOrTarget,\n                                               String actions ) {\n        //noinspection unchecked\n        Class<? extends Permission> clazz = ClassUtils.forName( permissionClassName );\n        return createPermission( clazz, nameOrTarget, actions );\n    }\n\n    /**\n     * Creates a <tt>Permission<\/tt> instance using the default no-argument constructor.\n     * @param clazz the <tt>Permission<\/tt> class.\n     * @return the newly instantiated <tt>Permission<\/tt> instance.\n     */\n    public static Permission createPermission( Class<? extends Permission> clazz ) {\n        return createPermission( clazz, null, null );\n    }\n\n    public static Permission createPermission( Class<? extends Permission> clazz, String nameOrTarget )\n        throws UnavailableConstructorException {\n        return createPermission( clazz, nameOrTarget, null );\n    }\n\n    public static Permission createPermission( Class<? extends Permission> clazz,\n                                               String nameOrTarget,\n                                               String commaDelimitedActions ) throws UnavailableConstructorException {\n\n        Permission instance = null;\n\n        String value = strip( nameOrTarget );\n        String actions = strip( commaDelimitedActions );\n\n        Object[] ctorArgs = toArray( value, actions );\n\n        if ( ctorArgs == null ) {\n            instance = (Permission)ClassUtils.newInstance( clazz );\n        } else {\n            Constructor<? extends Permission> constructor;\n            Class[] argTypes = getTypes( ctorArgs );\n            try {\n                constructor = clazz.getDeclaredConstructor( argTypes );\n            } catch ( NoSuchMethodException nsme ) {\n                String msg = \"Unable to find \" + ( argTypes.length == 2 ? \"double\" : \"single\" ) + \n                    \" String argument constructor on class [\" + clazz.getName() + \"].\";\n                throw new UnavailableConstructorException( msg );\n            }\n\n            instance = (Permission)ClassUtils.instantiate( constructor, ctorArgs );\n        }\n\n        return instance;\n    }\n\n    protected static Set<String> toSet( String delimited, String delimiter ) {\n        if ( delimited == null || delimited.trim().equals( \"\" ) ) {\n            return null;\n        }\n\n        Set<String> values = new LinkedHashSet<String>();\n        String[] rolenamesArray = delimited.split( delimiter );\n        for( String s : rolenamesArray ) {\n            String trimmed = s.trim();\n            if ( !trimmed.equals( \"\" ) ) {\n                values.add( trimmed );\n            }\n       }\n\n       return values;\n    }\n\n    public static Permission fromDefinition( String permDef ) {\n\n        String def = strip( permDef );\n        if ( def == null ) {\n            return null;\n        }\n\n        //split into respective components:\n        String classname = null;\n        String target = null;\n        String actions = null;\n\n        String[] parts =  def.split( PERMISSION_PART_DELIMITER, 3 );\n        if ( parts.length >= 3 ) {\n            actions = strip( parts[2] );\n        }\n        if ( parts.length >= 2 ) {\n            target = strip( parts[1] );\n        }\n        if ( parts.length >= 1 ) {\n            classname = strip( parts[0] );\n        }\n\n        return createPermission( classname, target, actions );\n    }\n\n    public static Set<Permission> fromDefinitions( String permissionDefinitions ) {\n\n        String defs = strip( permissionDefinitions );\n\n        if ( defs == null ) {\n            return null;\n        }\n\n        Set<String> defnSet = toSet( permissionDefinitions, PERMISSIONS_DELIMITER );\n        Set<Permission> perms = new LinkedHashSet<Permission>( defnSet.size() );\n\n        for( String permDef : defnSet ) {\n            perms.add( fromDefinition( permDef ) );\n        }\n\n        return perms;\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.Permission;\n\nimport java.lang.reflect.Constructor;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\n/**\n * @since 0.1\n * @author Les Hazlewood\n */\npublic class PermissionUtils {\n\n    private static final String PERMISSIONS_DELIMITER = \";\";\n    private static final String PERMISSION_PART_DELIMITER = \",\";\n\n    protected static transient final Log log = LogFactory.getLog( PermissionUtils.class );\n\n    private static void assertTarget( String nameOrTarget ) {\n        if ( nameOrTarget == null ) {\n            String msg = \"name (a.k.a. target) String argument cannot be null\";\n            throw new IllegalArgumentException( msg );\n        }\n    }\n\n    private static Permission instantiate( Constructor<? extends Permission> c, Object[] args ) {\n        Permission p;\n        try {\n            p = c.newInstance( args );\n        } catch ( Exception e ) {\n            String msg = \"Unable to instantiate Permission instance with constructor [\" + c + \"]\";\n            throw new PermissionInstantiationException( msg, e );\n        }\n        return p;\n    }\n\n    public static Permission createPermission( Class<? extends Permission> clazz, String nameOrTarget ) {\n\n        assertTarget( nameOrTarget );\n\n        Class[] argTypes = new Class[]{ String.class };\n        Constructor<? extends Permission> constructor;\n        try {\n            constructor = clazz.getDeclaredConstructor( argTypes );\n        } catch ( NoSuchMethodException nsme ) {\n            String msg = \"Unable to find single argument String constructor for class [\" + clazz.getName() + \"].\";\n            throw new ConstructorAcquisitionException( msg, nsme );\n        }\n\n        Object[] args = new Object[]{ nameOrTarget };\n        return instantiate( constructor, args );\n    }\n\n    public static Permission createPermission( Class<? extends Permission> clazz,\n                                               String nameOrTarget,\n                                               String actions ) throws ConstructorAcquisitionException {\n        if ( actions != null ) {\n            Class[] argTypes = new Class[]{ String.class, String.class };\n            Constructor<? extends Permission> constructor;\n\n            try {\n                constructor = clazz.getDeclaredConstructor( argTypes );\n            } catch ( NoSuchMethodException nsme ) {\n                String msg = \"Unable to find double String argument constructor on class [\" + clazz.getName() + \"].\";\n                throw new ConstructorAcquisitionException( msg );\n            }\n\n            // Instantiate permission with name and actions specified as attributes\n            Object[] args = new Object[]{ nameOrTarget, actions };\n            return instantiate( constructor, args );\n        } else {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"actions method parameter was null.  Trying single String argument constructor...\" );\n            }\n            return createPermission( clazz, nameOrTarget );\n        }\n    }\n\n    public static Permission createPermission( String permissionClassName, String nameOrTarget ) {\n        //noinspection unchecked\n        Class<? extends Permission> clazz = ClassUtils.forName( permissionClassName );\n        return createPermission( clazz, nameOrTarget );\n    }\n\n    public static Permission createPermission( String permissionClassName,\n                                               String nameOrTarget,\n                                               String actions ) {\n        //noinspection unchecked\n        Class<? extends Permission> clazz = ClassUtils.forName( permissionClassName );\n        return createPermission( clazz, nameOrTarget, actions );\n    }\n\n    protected static Set<String> toSet( String delimited, String delimiter ) {\n        if ( delimited == null || delimited.trim().equals( \"\" ) ) {\n            return null;\n        }\n\n        Set<String> values = new LinkedHashSet<String>();\n        String[] rolenamesArray = delimited.split( delimiter );\n        for( String s : rolenamesArray ) {\n            String trimmed = s.trim();\n            if ( !trimmed.equals( \"\" ) ) {\n                values.add( trimmed );\n            }\n       }\n\n       return values;\n    }\n\n    public static Permission createPermission( String permDef ) {\n        if ( permDef == null || permDef.trim().equals( \"\" ) ) {\n            return null;\n        }\n\n        //split into respective components:\n        String classname = null;\n        String target = null;\n        String actions = null;\n\n        String[] parts =  permDef.split( PERMISSION_PART_DELIMITER, 3 );\n        classname = parts[0];\n        if ( parts.length >= 2 ) {\n            target = parts[1];\n        }\n        if ( parts.length >= 3 ) {\n            actions = parts[2];\n        }\n        \n        Permission perm = null;\n\n        if ( actions == null ) {\n            if ( target == null ) {\n                perm = (Permission)ClassUtils.newInstance( classname );\n            } else {\n                perm = createPermission( classname, target );\n            }\n        } else {\n            perm = createPermission( classname, target, actions );\n        }\n\n        return perm;\n    }\n\n    public static Set<Permission> createPermissions( String permissionDefinitions ) {\n\n        if ( permissionDefinitions == null || permissionDefinitions.trim().equals( \"\" ) ) {\n            return null;\n        }\n\n        Set<String> defnSet = toSet( permissionDefinitions, PERMISSIONS_DELIMITER );\n        Set<Permission> perms = new LinkedHashSet<Permission>( defnSet.size() );\n\n        for( String permDef : defnSet ) {\n            perms.add( createPermission( permDef ) );\n        }\n\n        return perms;\n    }\n}\n","lineNo":163}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.authc.support;\n\nimport org.jsecurity.authc.AuthenticationInfo;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Simple implementation of the {@link org.jsecurity.authc.AuthenticationInfo} interface that\n * contains all necessary information as instance variables and exposes them\n * via getters and setters using standard JavaBean notation.\n *\n * @see org.jsecurity.authc.AuthenticationInfo\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class SimpleAuthenticationInfo implements AuthenticationInfo, Serializable {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The principals that apply to the subject/user who has been authenticated.\n     */\n    private List<Object> principals = null;\n\n    /**\n     * Credentials that were used to authenticate the user.\n     */\n    private Object credentials = null;\n\n    /**\n     * True if the user's account is locked, false otherwise.\n     */\n    private boolean accountLocked = false;\n\n    /**\n     * True if the user's credentials are expired, false otherwise.\n     */\n    private boolean credentialsExpired = false;\n\n    /**\n     * True if the user is allowed to log in concurrently from two\n     * separate locations, false otherwise.\n     */\n    private boolean concurrentLoginsAllowed = true;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public SimpleAuthenticationInfo() {\n    }\n\n    public SimpleAuthenticationInfo( Object principal, Object credentials) {\n        addPrincipal( principal );\n        this.credentials = credentials;\n    }\n\n    public SimpleAuthenticationInfo(List<Object> principals, Object credentials) {\n        this.principals = principals;\n        this.credentials = credentials;\n    }\n\n    public SimpleAuthenticationInfo(List<Object> principals, Object credentials, boolean accountLocked, boolean credentialsExpired) {\n        this.principals = principals;\n        this.credentials = credentials;\n        this.accountLocked = accountLocked;\n        this.credentialsExpired = credentialsExpired;\n    }\n\n    public SimpleAuthenticationInfo(List<Object> principals, Object credentials, boolean accountLocked, boolean credentialsExpired, boolean concurrentLoginsAllowed) {\n        this.principals = principals;\n        this.credentials = credentials;\n        this.accountLocked = accountLocked;\n        this.credentialsExpired = credentialsExpired;\n        this.concurrentLoginsAllowed = concurrentLoginsAllowed;\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    public Object getPrincipal() {\n        if( this.principals == null || this.principals.isEmpty()) {\n            return null;\n        } else {\n            return this.principals.get(0);\n        }\n    }\n\n    public List getPrincipals() {\n        return principals;\n    }\n\n    public void setPrincipals(List<Object> principals) {\n        this.principals = principals;\n    }\n\n    public void addPrincipal( Object principal ) {\n        if ( this.principals == null ) {\n            this.principals = new ArrayList<Object>();\n        }\n        this.principals.add( principal );\n    }\n\n    public Object getCredentials() {\n        return credentials;\n    }\n\n    public void setCredentials( Object credentials ) {\n        this.credentials = credentials;\n    }\n\n    public boolean isAccountLocked() {\n        return accountLocked;\n    }\n\n    public void setAccountLocked(boolean accountLocked) {\n        this.accountLocked = accountLocked;\n    }\n\n    public boolean isCredentialsExpired() {\n        return credentialsExpired;\n    }\n\n    public void setCredentialsExpired(boolean credentialsExpired) {\n        this.credentialsExpired = credentialsExpired;\n    }\n\n    public boolean isConcurrentLoginsAllowed() {\n        return concurrentLoginsAllowed;\n    }\n\n    public void setConcurrentLoginsAllowed(boolean concurrentLoginsAllowed) {\n        this.concurrentLoginsAllowed = concurrentLoginsAllowed;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    public String toString() {\n        return \"Authentication information for user [\" + getPrincipals() + \"]\";\n    }\n\n    /**\n     * Merges the specified argument into this instance.\n     * @param info the info to merge into this instance.\n     */\n    public void merge(AuthenticationInfo info) {\n        if ( info == null ) {\n            return;\n        }\n\n        //noinspection unchecked\n        List<Object> infoPrincipals = info.getPrincipals();\n\n        if ( infoPrincipals != null && !infoPrincipals.isEmpty() ) {\n            if ( this.principals == null ) {\n                this.principals = new ArrayList<Object>( infoPrincipals.size() );\n            }\n            this.principals.addAll( infoPrincipals );\n        }\n\n        if( this.credentials == null ) {\n            setCredentials( info );\n        }\n\n        if( info.isAccountLocked() ) {\n            setAccountLocked( true );\n        }\n\n        if( info.isCredentialsExpired() ) {\n            setCredentialsExpired( true );\n        }\n\n        if( !info.isConcurrentLoginsAllowed() ) {\n            setConcurrentLoginsAllowed( false );\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.authc.support;\n\nimport org.jsecurity.authc.AuthenticationInfo;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Simple implementation of the {@link org.jsecurity.authc.AuthenticationInfo} interface that\n * contains all necessary information as instance variables and exposes them\n * via getters and setters using standard JavaBean notation.\n *\n * @see org.jsecurity.authc.AuthenticationInfo\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class SimpleAuthenticationInfo implements AuthenticationInfo, Serializable {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The principals that apply to the subject/user who has been authenticated.\n     */\n    private List principals;\n\n    /**\n     * Credentials that were used to authenticate the user.\n     */\n    private Object credentials;\n\n    /**\n     * True if the user's account is locked, false otherwise.\n     */\n    private boolean accountLocked = false;\n\n    /**\n     * True if the user's credentials are expired, false otherwise.\n     */\n    private boolean credentialsExpired = false;\n\n    /**\n     * True if the user is allowed to log in concurrently from two\n     * separate locations, false otherwise.\n     */\n    private boolean concurrentLoginsAllowed = true;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public SimpleAuthenticationInfo() {\n        this.principals = new ArrayList<Object>();\n    }\n\n    public SimpleAuthenticationInfo( Object principal, Object credentials) {\n        this();\n        //noinspection unchecked\n        this.principals.add( principal );\n        this.credentials = credentials;\n    }\n\n    public SimpleAuthenticationInfo(List<Object> principals, Object credentials) {\n        this.principals = principals;\n        this.credentials = credentials;\n    }\n\n    public SimpleAuthenticationInfo(List<Object> principals, Object credentials, boolean accountLocked, boolean credentialsExpired) {\n        this.principals = principals;\n        this.credentials = credentials;\n        this.accountLocked = accountLocked;\n        this.credentialsExpired = credentialsExpired;\n    }\n\n    public SimpleAuthenticationInfo(List<Object> principals, Object credentials, boolean accountLocked, boolean credentialsExpired, boolean concurrentLoginsAllowed) {\n        this.principals = principals;\n        this.credentials = credentials;\n        this.accountLocked = accountLocked;\n        this.credentialsExpired = credentialsExpired;\n        this.concurrentLoginsAllowed = concurrentLoginsAllowed;\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    public Object getPrincipal() {\n        if( this.principals == null ) {\n            return null;\n        } else {\n            return this.principals.get(0);\n        }\n    }\n\n    public List getPrincipals() {\n        return principals;\n    }\n\n    public void setPrincipals(List<Object> principals) {\n        this.principals = principals;\n    }\n\n    public void addPrincipal( Object principal ) {\n        //noinspection unchecked\n        this.principals.add( principal );\n    }\n\n    public Object getCredentials() {\n        return credentials;\n    }\n\n    public void setCredentials( Object credentials ) {\n        this.credentials = credentials;\n    }\n\n\n    public boolean isAccountLocked() {\n        return accountLocked;\n    }\n\n\n    public void setAccountLocked(boolean accountLocked) {\n        this.accountLocked = accountLocked;\n    }\n\n\n    public boolean isCredentialsExpired() {\n        return credentialsExpired;\n    }\n\n\n    public void setCredentialsExpired(boolean credentialsExpired) {\n        this.credentialsExpired = credentialsExpired;\n    }\n\n\n    public boolean isConcurrentLoginsAllowed() {\n        return concurrentLoginsAllowed;\n    }\n\n\n    public void setConcurrentLoginsAllowed(boolean concurrentLoginsAllowed) {\n        this.concurrentLoginsAllowed = concurrentLoginsAllowed;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    public String toString() {\n        return \"Authentication information for user [\" + getPrincipals() + \"]\";\n    }\n\n    /**\n     * Merges the specified argument into this instance.\n     * @param info the info to merge into this instance.\n     */\n    public void merge(AuthenticationInfo info) {\n        if( this.principals == null ) {\n            this.principals = new ArrayList<Object>();\n        }\n        //noinspection unchecked\n        this.principals.addAll( info.getPrincipals() );\n\n        if( this.credentials == null ) {\n            setCredentials( info );\n        }\n\n        if( info.isAccountLocked() ) {\n            setAccountLocked( true );\n        }\n\n        if( info.isCredentialsExpired() ) {\n            setCredentialsExpired( true );\n        }\n\n        if( !info.isConcurrentLoginsAllowed() ) {\n            setConcurrentLoginsAllowed( false );\n        }\n    }\n}\n","lineNo":186}
{"Refactored Sample":"/*\n * Copyright (C) 2005 Tim Veil, Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.realm.support.activedirectory;\n\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authc.support.SimpleAuthenticationInfo;\nimport org.jsecurity.authz.AuthorizationInfo;\nimport org.jsecurity.authz.support.SimpleAuthorizationInfo;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.realm.support.ldap.AbstractLdapRealm;\nimport org.jsecurity.realm.support.ldap.LdapContextFactory;\nimport org.jsecurity.realm.support.ldap.LdapUtils;\nimport org.jsecurity.util.UsernamePrincipal;\n\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.naming.ldap.LdapContext;\nimport java.security.Principal;\nimport java.util.*;\n\n/**\n * <p>An {@link Realm} that authenticates with an active directory LDAP\n * server to determine the roles for a particular user.  This implementation\n * queries for the user's groups and then maps the group names to roles using the\n * {@link #groupRolesMap}.<\/p>\n *\n *\n * @since 0.1\n * @author Tim Veil\n * @author Jeremy Haile\n */\npublic class ActiveDirectoryRealm extends AbstractLdapRealm {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    \n    private static final String ROLE_NAMES_DELIMETER = \",\";\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n\n    /**\n     * Mapping from fully qualified active directory\n     * group names (e.g. CN=Group,OU=Company,DC=MyDomain,DC=local)\n     * as returned by the active directory LDAP server to role names.\n     */\n    private Map<String, String> groupRolesMap;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    public void setGroupRolesMap(Map<String, String> groupRolesMap) {\n        this.groupRolesMap = groupRolesMap;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n\n    /**\n     * <p>Builds an {@link AuthenticationInfo} object by querying the active directory LDAP context for the\n     * specified username.  This method binds to the LDAP server using the provided username and password -\n     * which if successful, indicates that the password is correct.<\/p>\n     *\n     * <p>This method can be overridden by subclasses to query the LDAP server in a more complex way.<\/p>\n     *\n     * @param token the authentication token provided by the user.\n     * @param ldapContextFactory the factory used to build connections to the LDAP server.\n     * @return an {@link AuthenticationInfo} instance containing information retrieved from LDAP\n     * that can be used to build an {@link org.jsecurity.authc.AuthenticationInfo} instance to return.\n     *\n     * @throws NamingException if any LDAP errors occur during the search.\n     */\n    protected AuthenticationInfo queryForLdapAuthenticationInfo(AuthenticationToken token, LdapContextFactory ldapContextFactory) throws NamingException {\n\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n\n        // Binds using the username and password provided by the user.\n        LdapContext ctx = null;\n        try {\n\n            ctx = ldapContextFactory.getLdapContext( upToken.getUsername(), String.valueOf( upToken.getPassword() ) );\n\n        } finally {\n            LdapUtils.closeContext( ctx );\n        }\n\n        UsernamePrincipal principal = new UsernamePrincipal( upToken.getUsername() );\n\n        return new SimpleAuthenticationInfo( principal, upToken.getPassword() );\n    }\n\n\n    /**\n     * <p>Builds an {@link AuthorizationInfo} object by querying the active directory LDAP context for the\n     * groups that a user is a member of.  The groups are then translated to role names by using the\n     * configured {@link #groupRolesMap}.<\/p>\n     *\n     * <p>Subclasses can override this method to determine authorization information in a more complex way.  Note that\n     * this default implementation does not support permissions, only roles.<\/p>\n     *\n     * @param principal the principal of the user whose authorization information is being retrieved.\n     * @param ldapContextFactory the factory used to create LDAP connections.\n     * @return authorization information for the given principal.\n     * @throws NamingException if an error occurs when searching the LDAP server.\n     */\n    protected AuthorizationInfo queryForLdapAuthorizationInfo(Principal principal, LdapContextFactory ldapContextFactory) throws NamingException {\n\n        UsernamePrincipal usernamePrincipal = (UsernamePrincipal) principal;\n\n        // Perform context search\n        LdapContext ldapContext = ldapContextFactory.getSystemLdapContext();\n\n        List<String> roleNames;\n\n        try {\n\n            roleNames = getRoleNamesForUser(usernamePrincipal, ldapContext);\n\n        } finally {\n\n            LdapUtils.closeContext( ldapContext );\n        }\n\n        return new SimpleAuthorizationInfo( roleNames, null );\n    }\n\n    private List<String> getRoleNamesForUser(UsernamePrincipal usernamePrincipal, LdapContext ldapContext) throws NamingException {\n        List<String> roleNames;\n        roleNames = new ArrayList<String>();\n\n        SearchControls searchCtls = new SearchControls();\n        searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        String searchFilter = \"(&(objectClass=*)(userPrincipalName=\" + usernamePrincipal.getUsername() + \"))\";\n\n        NamingEnumeration answer = ldapContext.search(searchBase, searchFilter, searchCtls);\n\n        while (answer.hasMoreElements()) {\n            SearchResult sr = (SearchResult) answer.next();\n\n            if( log.isDebugEnabled() ) {\n                log.debug(\"Retrieving group names for user [\" + sr.getName() + \"]\");\n            }\n\n            Attributes attrs = sr.getAttributes();\n\n            if (attrs != null) {\n                NamingEnumeration ae = attrs.getAll();\n                while( ae.hasMore() ) {\n                    Attribute attr = (Attribute) ae.next();\n\n                    if( attr.getID().equals( \"memberOf\" ) ) {\n\n                        Collection<String> groupNames = LdapUtils.getAllAttributeValues( attr );\n\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Groups found for user [\" + usernamePrincipal.getUsername() + \"]: \" + groupNames );\n                        }\n\n                        Collection<String> rolesForGroups = getRoleNamesForGroups(groupNames);\n                        roleNames.addAll(rolesForGroups);\n                    }\n                }\n            }\n        }\n        return roleNames;\n    }\n\n    /**\n     * This method is called by the default implementation to translate Active Directory group names\n     * to role names.  This implementation uses the {@link #groupRolesMap} to map group names to role names.\n     * @param groupNames the group names that apply to the current user.\n     * @return a collection of roles that are implied by the given role names.\n     */\n    protected Collection<String> getRoleNamesForGroups(Collection<String> groupNames) {\n        Set<String> roleNames = new HashSet<String>( groupNames.size() );\n\n        if( groupRolesMap != null ) {\n            for( String groupName : groupNames ) {\n                String strRoleNames = groupRolesMap.get( groupName );\n                if( strRoleNames != null ) {\n                    for( String roleName : strRoleNames.split( ROLE_NAMES_DELIMETER ) ) {\n\n                        if( log.isDebugEnabled() ) {\n                            log.debug( \"User is member of group [\" + groupName + \"] so adding role [\" + roleName + \"]\" );\n                        }\n\n                        roleNames.add( roleName );\n\n                    }\n                }\n            }\n        }\n        return roleNames;\n    }\n\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005 Tim Veil, Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.realm.support.activedirectory;\n\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authc.support.SimpleAuthenticationInfo;\nimport org.jsecurity.authz.AuthorizationInfo;\nimport org.jsecurity.authz.support.SimpleAuthorizationInfo;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.realm.support.ldap.AbstractLdapRealm;\nimport org.jsecurity.realm.support.ldap.LdapContextFactory;\nimport org.jsecurity.realm.support.ldap.LdapUtils;\nimport org.jsecurity.util.UsernamePrincipal;\n\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.naming.ldap.LdapContext;\nimport java.security.Principal;\nimport java.util.*;\n\n/**\n * <p>An {@link Realm} that authenticates with an active directory LDAP\n * server to determine the roles for a particular user.  This implementation\n * queries for the user's groups and then maps the group names to roles using the\n * {@link #groupRolesMap}.<\/p>\n *\n *\n * @since 0.1\n * @author Tim Veil\n * @author Jeremy Haile\n */\npublic class ActiveDirectoryRealm extends AbstractLdapRealm {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    \n    private static final String ROLE_NAMES_DELIMETER = \",\";\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n\n    /**\n     * Mapping from fully qualified active directory\n     * group names (e.g. CN=Group,OU=Company,DC=MyDomain,DC=local)\n     * as returned by the active directory LDAP server to role names.\n     */\n    private Map<String, String> groupRolesMap;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    public void setGroupRolesMap(Map<String, String> groupRolesMap) {\n        this.groupRolesMap = groupRolesMap;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n\n    /**\n     * <p>Builds an {@link AuthenticationInfo} object by querying the active directory LDAP context for the\n     * specified username.  This method binds to the LDAP server using the provided username and password -\n     * which if successful, indicates that the password is correct.<\/p>\n     *\n     * <p>This method can be overridden by subclasses to query the LDAP server in a more complex way.<\/p>\n     *\n     * @param token the authentication token provided by the user.\n     * @param ldapContextFactory the factory used to build connections to the LDAP server.\n     * @return an {@link AuthenticationInfo} instance containing information retrieved from LDAP\n     * that can be used to build an {@link org.jsecurity.authc.AuthenticationInfo} instance to return.\n     *\n     * @throws NamingException if any LDAP errors occur during the search.\n     */\n    protected AuthenticationInfo queryForLdapAuthenticationInfo(AuthenticationToken token, LdapContextFactory ldapContextFactory) throws NamingException {\n\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n\n        // Binds using the username and password provided by the user.\n        ldapContextFactory.getLdapContext( upToken.getUsername(), String.valueOf( upToken.getPassword() ) );\n\n        UsernamePrincipal principal = new UsernamePrincipal( upToken.getUsername() );\n\n        return new SimpleAuthenticationInfo( principal, upToken.getPassword() );\n    }\n\n\n    /**\n     * <p>Builds an {@link AuthorizationInfo} object by querying the active directory LDAP context for the\n     * groups that a user is a member of.  The groups are then translated to role names by using the\n     * configured {@link #groupRolesMap}.<\/p>\n     *\n     * <p>Subclasses can override this method to determine authorization information in a more complex way.  Note that\n     * this default implementation does not support permissions, only roles.<\/p>\n     *\n     * @param principal the principal of the user whose authorization information is being retrieved.\n     * @param ldapContextFactory the factory used to create LDAP connections.\n     * @return authorization information for the given principal.\n     * @throws NamingException if an error occurs when searching the LDAP server.\n     */\n    protected AuthorizationInfo queryForLdapAuthorizationInfo(Principal principal, LdapContextFactory ldapContextFactory) throws NamingException {\n\n        UsernamePrincipal usernamePrincipal = (UsernamePrincipal) principal;\n\n        SearchControls searchCtls = new SearchControls();\n        searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        String searchFilter = \"(&(objectClass=*)(userPrincipalName=\" + usernamePrincipal.getUsername() + \"))\";\n\n        // Perform context search\n        LdapContext ldapContext = ldapContextFactory.getSystemLdapContext();\n        NamingEnumeration answer = ldapContext.search(searchBase, searchFilter, searchCtls);\n\n        List<String> roleNames = new ArrayList<String>();\n        while (answer.hasMoreElements()) {\n            SearchResult sr = (SearchResult) answer.next();\n\n            log.debug(\"Retrieving group names for user [\" + sr.getName() + \"]\");\n\n            Attributes attrs = sr.getAttributes();\n\n            if (attrs != null) {\n                NamingEnumeration ae = attrs.getAll();\n                while( ae.hasMore() ) {\n                    Attribute attr = (Attribute) ae.next();\n\n                    if( attr.getID().equals( \"memberOf\" ) ) {\n\n                        Collection<String> groupNames = LdapUtils.getAllAttributeValues( attr );\n\n                        roleNames.addAll( getRoleNamesForGroups( groupNames ) );\n                    }\n                }\n            }\n        }\n\n        return new SimpleAuthorizationInfo( roleNames, null );\n    }\n\n    /**\n     * This method is called by the default implementation to translate Active Directory group names\n     * to role names.  This implementation uses the {@link #groupRolesMap} to map group names to role names.\n     * @param groupNames the group names that apply to the current user.\n     * @return a collection of roles that are implied by the given role names.\n     */\n    protected Collection<String> getRoleNamesForGroups(Collection<String> groupNames) {\n        Set<String> roleNames = new HashSet<String>( groupNames.size() );\n\n        if( groupRolesMap != null ) {\n            for( String groupName : groupNames ) {\n                String strRoleNames = groupRolesMap.get( groupName );\n                if( strRoleNames != null ) {\n                    for( String roleName : strRoleNames.split( ROLE_NAMES_DELIMETER ) ) {\n\n                        if( log.isDebugEnabled() ) {\n                            log.debug( \"User is member of group [\" + groupName + \"] so adding role [\" + roleName + \"]\" );\n                        }\n\n                        roleNames.add( roleName );\n\n                    }\n                }\n            }\n        }\n        return roleNames;\n    }\n\n\n}\n","lineNo":193}
{"Refactored Sample":"/*\n* Copyright (C) 2005-2007 Jeremy Haile, Les Hazlewood\n*\n* This library is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as published\n* by the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n* Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the\n*\n* Free Software Foundation, Inc.\n* 59 Temple Place, Suite 330\n* Boston, MA 02111-1307\n* USA\n*\n* Or, you may view it online at\n* http://www.opensource.org/licenses/lgpl-license.php\n*/\npackage org.jsecurity.realm.support.memory;\n\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authc.support.SimpleAuthenticationInfo;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.AuthorizedAction;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthorizedException;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheException;\nimport org.jsecurity.cache.CacheProvider;\nimport org.jsecurity.cache.support.HashtableCacheProvider;\nimport org.jsecurity.realm.support.AuthenticatingRealm;\nimport org.jsecurity.util.Destroyable;\nimport org.jsecurity.util.Initializable;\nimport org.jsecurity.util.UsernamePrincipal;\n\nimport java.security.Principal;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * <p>A simple implementation of the {@link org.jsecurity.realm.Realm} interface that\n * uses a set of configured user accounts to authenticate the user.  Each account entry\n * specifies the username, password, and roles for a user.  Roles can also be mapped\n * to permissions and will be associated with users.<\/p>\n *\n * <p>See the <tt>applicationContext.xml<\/tt> in the Spring sample application for an example\n * of configuring a <tt>MemoryRealm<\/tt><\/p>\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class MemoryRealm extends AuthenticatingRealm implements Initializable, Destroyable {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    protected Cache userCache = null;\n    protected Cache roleCache = null;\n\n    private boolean cacheProviderImplicitlyCreated = true;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    /**\n     * Sets the account entries that are used to authenticate users and associate them\n     * with roles for this realm.\n     *\n     * @param accounts the accounts for this realm.\n     */\n    public void setAccounts( Set<AccountEntry> accounts ) {\n        //this.accounts = accounts;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    public void init() {\n        CacheProvider provider = getCacheProvider();\n\n        if ( provider == null ) {\n            provider = new HashtableCacheProvider();\n            setCacheProvider( provider );\n            this.cacheProviderImplicitlyCreated = true;\n        }\n        //if ( accounts != null && !accounts.isEmpty() ) {\n            //todo - translate into SimpleUser and SimpleRole objects\n        //}\n\n    }\n\n    protected void destroy( Cache cache ) {\n        if ( cache != null ) {\n            try {\n                cache.clear();\n            } catch ( Throwable t ) {\n                if ( log.isInfoEnabled() ) {\n                    log.info( \"Unable to cleanly clear cache [\" + cache + \"].  Ingoring (shutting down).\" );\n                }\n            }\n            try {\n                cache.destroy();\n            } catch ( CacheException e ) {\n                if ( log.isInfoEnabled() ) {\n                    log.info( \"Unable to cleanly destroy cache [\" + cache + \"].  Ignoring (shutting down).\" );\n                }\n            }\n\n        }\n    }\n\n    public void destroy() throws Exception {\n        destroy( userCache );\n        destroy( roleCache );\n        if ( this.cacheProviderImplicitlyCreated ) {\n            if ( getCacheProvider() instanceof Destroyable ) {\n                try {\n                    ((Destroyable)getCacheProvider()).destroy();\n                } catch ( Exception e ) {\n                    if ( log.isInfoEnabled() ) {\n                        log.info( \"Unable to cleanly destroy implicitly created CacheProvider.  Ignoring (shutting down)\" );\n                    }\n                }\n            }\n        }\n    }\n\n    protected AuthenticationInfo doGetAuthenticationInfo( AuthenticationToken token ) throws AuthenticationException {\n        UsernamePasswordToken upToken = (UsernamePasswordToken)token;\n\n        SimpleUser user = (SimpleUser)userCache.get( upToken.getUsername() );\n        if ( user == null ) {\n            return null;\n        }\n\n        Principal principal = new UsernamePrincipal( user.getUsername() );\n\n        return new SimpleAuthenticationInfo( principal, user.getPassword() );\n\n    }\n\n    protected String getUsername( Principal principal ) {\n        if ( principal instanceof UsernamePrincipal ) {\n            return ( (UsernamePrincipal)principal ).getUsername();\n        } else {\n            String msg = \"The \" + getClass().getName() + \" implementation expects all Principal arguments to be \" +\n                \"instances of the [\" + UsernamePrincipal.class.getName() + \"] class\";\n            throw new IllegalArgumentException( msg );\n        }\n    }\n\n    protected SimpleUser getUser( Principal principal ) {\n        return (SimpleUser)userCache.get( getUsername( principal ) );\n    }\n\n    public boolean hasRole( Principal principal, String roleIdentifier ) {\n        SimpleUser user = getUser( principal );\n        return ( user != null && user.hasRole( roleIdentifier ) );\n    }\n\n\n    public boolean[] hasRoles( Principal principal, List<String> roleIdentifiers ) {\n        boolean[] hasRoles = new boolean[roleIdentifiers.size()];\n        for ( int i = 0; i < roleIdentifiers.size(); i++ ) {\n            hasRoles[i] = hasRole( principal, roleIdentifiers.get( i ) );\n        }\n        return hasRoles;\n    }\n\n    public boolean hasAllRoles( Principal principal, Collection<String> roleIdentifiers ) {\n        for ( String rolename : roleIdentifiers ) {\n            if ( !hasRole( principal, rolename ) ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean isPermitted( Principal principal, Permission permission ) {\n        SimpleUser user = getUser( principal );\n        return user != null && user.isPermitted( permission );\n    }\n\n    public boolean[] isPermitted( Principal principal, List<Permission> permissions ) {\n        boolean[] permitted = new boolean[permissions.size()];\n        for ( int i = 0; i < permissions.size(); i++ ) {\n            permitted[i] = isPermitted( principal, permissions.get( i ) );\n        }\n        return permitted;\n    }\n\n    public boolean isPermittedAll( Principal principal, Collection<Permission> permissions ) {\n        for ( Permission perm : permissions ) {\n            if ( !isPermitted( principal, perm ) ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public void checkPermission( Principal principal, Permission permission ) throws AuthorizationException {\n        if ( !isPermitted( principal, permission ) ) {\n            throw new UnauthorizedException( \"User does not have permission [\" + permission + \"]\" );\n        }\n    }\n\n    public void checkPermissions( Principal principal, Collection<Permission> permissions ) throws AuthorizationException {\n        if ( permissions != null ) {\n            for ( Permission permission : permissions ) {\n                if ( !isPermitted( principal, permission ) ) {\n                    throw new UnauthorizedException( \"User does not have permission [\" + permission + \"]\" );\n                }\n            }\n        }\n    }\n\n    public void checkRole( Principal principal, String role ) throws AuthorizationException {\n        if ( !hasRole( principal, role ) ) {\n            throw new UnauthorizedException( \"User does not have role [\" + role + \"]\" );\n        }\n    }\n\n    public void checkRoles( Principal principal, Collection<String> roles ) throws AuthorizationException {\n        if ( roles != null ) {\n            for ( String role : roles ) {\n                if ( !hasRole( principal, role ) ) {\n                    throw new UnauthorizedException( \"User does not have role [\" + role + \"]\" );\n                }\n            }\n        }\n    }\n\n    /**\n     * Default implementation that always returns false (relies on JSecurity 1.5 annotations instead).\n     *\n     * @param action the action to check for authorized execution\n     * @return whether or not the realm supports AuthorizedActions of the given type.\n     */\n    public boolean supports( AuthorizedAction action ) {\n        return false;\n    }\n\n    public boolean isAuthorized( Principal subjectIdentifier, AuthorizedAction action ) {\n        return true;\n    }\n\n    public void checkAuthorization( Principal subjectIdentifier, AuthorizedAction action ) throws AuthorizationException {\n        //does nothing\n    }\n\n}\n","Smelly Sample":"/*\n* Copyright (C) 2005-2007 Jeremy Haile, Les Hazlewood\n*\n* This library is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as published\n* by the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n* Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the\n*\n* Free Software Foundation, Inc.\n* 59 Temple Place, Suite 330\n* Boston, MA 02111-1307\n* USA\n*\n* Or, you may view it online at\n* http://www.opensource.org/licenses/lgpl-license.php\n*/\npackage org.jsecurity.realm.support.memory;\n\nimport org.jsecurity.JSecurityException;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.support.SimpleAuthenticationInfo;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.realm.support.AbstractRealm;\nimport org.jsecurity.realm.support.AuthorizationInfo;\nimport org.jsecurity.util.Initializable;\nimport org.jsecurity.util.UsernamePrincipal;\n\nimport java.lang.reflect.Constructor;\nimport java.security.Principal;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * <p>A simple implementation of the {@link org.jsecurity.realm.Realm} interface that\n * uses a set of configured user accounts to authenticate the user.  Each account entry\n * specifies the username, password, and roles for a user.  Roles can also be mapped\n * to permissions and will be associated with users.<\/p>\n *\n * <p>See the <tt>applicationContext.xml<\/tt> in the Spring sample application for an example\n * of configuring a <tt>MemoryRealm<\/tt><\/p>\n *\n * @since 0.1\n * @author Jeremy Haile\n * @author Les Hazlewood\n */\npublic class MemoryRealm extends AbstractRealm implements Initializable {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    private Set<AccountEntry> accounts;\n    private Map<String,String> rolesPermissionsMap = new HashMap<String,String>();\n\n    protected Map<String,SimpleUser> userMap = new HashMap<String, SimpleUser>();\n    protected Map<String,SimpleRole> roleMap = new HashMap<String,SimpleRole>();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    /**\n     * Sets the account entries that are used to authenticate users and associate them\n     * with roles for this realm.\n     * @param accounts the accounts for this realm.\n     */\n    public void setAccounts(Set<AccountEntry> accounts) {\n        this.accounts = accounts;\n    }\n\n\n    /**\n     * <p>A mapping of role names to permissions that can be authenticated using this realm.\n     * It is not necessary to define any role entries if you are simply using\n     * role-based authorization.  However if you want to use permission-based\n     * authorization, you must define the permissions that apply to a particular\n     * role.<\/p>\n     *\n     * <p>The key of the map is the role name.<\/p>\n     *\n     * <p>The value of the map is a delimited list of all permissions that apply to\n     * this role.  Each permission entry is separated by semicolons.  Each\n     * permission consists of a fully-qualified permission class-name, a\n     * name name, and a list of actions that apply to the permission.  Each\n     * of theses entries is comma-separated.<\/p>\n     *\n     * <p>For example,<br>\n     * <tt>\"com.mycompany.PermissionClass,myTarget,myAction1,myAction2,myAction3;<br>\n     *     java.io.FilePermission,/myDir/myFile,read,write\"<\/tt>\n     * <\/p>\n     *\n     * @param rolesPermissionsMap the mapping between role names and permissions.\n     */\n    public void setRolesPermissionsMap(Map<String, String> rolesPermissionsMap) {\n        this.rolesPermissionsMap = rolesPermissionsMap;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    public void init()  {\n        if( accounts != null && !accounts.isEmpty() ) {\n            //todo - translate into SimpleUser and SimpleRole objects\n        }\n\n    }\n\n    /**\n     * Builds a <tt>UserAuthenticationInfo<\/tt> object for the given username\n     * by examining the set of configured accounts and roles held in the\n     * memory realm.\n     * @param token The authentication token that is being used to authenticate the current user.\n     * @return an <tt>AuthenticationInfo<\/tt> object that represents the\n     * authentication information for the given username, or null if an\n     * account cannot be found with the given username.\n     *\n     */\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n\n        Principal principal = token.getPrincipal();\n\n        try {\n\n            for( AccountEntry entry : accounts ) {\n                if( entry.getUsername().equals( principal.getName() ) ) {\n                    return new SimpleAuthenticationInfo( new UsernamePrincipal( principal.getName() ),\n                                                  entry.getPassword().toCharArray() );\n\n                }\n            }\n\n        } catch (Exception e) {\n            throw new AuthenticationException( \"Unexpected exception while authenticating user.\", e );\n        }\n\n        // User could not be found, so return null\n        return null;\n    }\n\n\n    private Set<Permission> getPermissionsForRoles(Set<String> roleNames) {\n\n        Set<Permission> permissions = new HashSet<Permission>();\n\n        for( String roleName : roleNames ) {\n            String permissionsString = rolesPermissionsMap.get( roleName );\n\n            // If the permissions String is not null or empty, parse the individual\n            // permissions from it\n            if( permissionsString != null && permissionsString.length() > 0 ) {\n                Set<Permission> rolePermissions = parsePermissions( permissionsString );\n                permissions.addAll( rolePermissions );\n            }\n        }\n\n        return permissions;\n    }\n\n\n    private Set<Permission> parsePermissions(String permissionsString) {\n        Set<Permission> rolePermissions = new HashSet<Permission>();\n\n        // For each semicolon-delimited permission in the string, build\n        // a permission object.\n        String[] permissionsArray = permissionsString.split( \";\" );\n        for( String permissionString : permissionsArray ) {\n\n            String[] permissionParts = permissionString.split( \",\" );\n            if( permissionParts.length < 3 ) {\n                throw new IllegalArgumentException(\n                    \"Permission token [\" + permissionString + \"] is not a valid permission \" +\n                    \"definition.  Please see the JavaDoc for the \" + getClass() + \" class.\" );\n            }\n\n            // Parse permission string into class, name, and actions\n            String clazz = permissionParts[0];\n            String target = permissionParts[1];\n            StringBuffer actions = new StringBuffer();\n            for( int i = 2; i < permissionParts.length; i++ ) {\n                actions.append( permissionParts[i] );\n                if( permissionParts.length > (i+1) ) {\n                    actions.append( \",\" );\n                }\n            }\n\n            Permission permission = createPermission( clazz, target, actions.toString() );\n            rolePermissions.add( permission );\n\n        }\n\n        return rolePermissions;\n    }\n\n\n    /**\n     * Builds a permission object with the given class, name, and actions using reflection.\n     * The permission class is expected to have a constructor that takes in two String\n     * parameters.  The first parameter is the name of the permission.  The second parameter\n     * is a comma-delimeted list of actions that apply to the permission.\n     *\n     * @param className the permission class.\n     * @param target the permission name (or name).\n     * @param actions the permission actions.\n     * @return a new Permission object with the given properties.\n     */\n    private Permission createPermission(String className, String target, String actions) {\n\n        try {\n            Class clazz = Class.forName( className );\n            Constructor constructor = clazz.getConstructor( String.class, String.class );\n            return (Permission) constructor.newInstance( target, actions );\n        } catch (Exception e) {\n            throw new JSecurityException( \"Error instantiating permission specified for realm [\" + getName() + \"]\", e );\n        }\n\n    }\n\n\n    protected AuthorizationInfo getAuthorizationInfo(Principal principal) {\n        //return authorizationInfoMap.get( principal );\n        return null;\n    }\n\n}\n","lineNo":157}
{"Refactored Sample":"/*\n* Copyright (C) 2005-2007 Les Hazlewood\n*\n* This library is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as published\n* by the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n* Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the\n*\n* Free Software Foundation, Inc.\n* 59 Temple Place, Suite 330\n* Boston, MA 02111-1307\n* USA\n*\n* Or, you may view it online at\n* http://www.opensource.org/licenses/lgpl-license.php\n*/\npackage org.jsecurity.context.factory.support;\n\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.support.DelegatingSecurityContext;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\n\n/**\n * SecurityContextFactory implementation that creates\n * {@link org.jsecurity.context.support.DelegatingSecurityContext} instances.\n *\n * @since 0.1\n * @author Les Hazlewood\n * @author Jeremy Haile\n */\npublic class DelegatingSecurityContextFactory extends AbstractSecurityContextFactory {\n\n    private SecurityManager securityManager;\n\n    public DelegatingSecurityContextFactory( SecurityManager securityManager ){\n        this.securityManager = securityManager;\n    }\n\n    protected SecurityContext onCreateSecurityContext( AuthenticationInfo info ) {\n\n        //get any existing session that may exist - we don't want to lose it:\n        SecurityContext securityContext = ThreadContext.getSecurityContext();\n        Session session = null;\n        if ( securityContext != null ) {\n            session = securityContext.getSession( false );\n        }\n\n        return new DelegatingSecurityContext( info.getPrincipals(), true, ThreadContext.getInetAddress(), session, securityManager );\n    }\n}\n","Smelly Sample":"/*\n* Copyright (C) 2005-2007 Les Hazlewood\n*\n* This library is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as published\n* by the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n* Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the\n*\n* Free Software Foundation, Inc.\n* 59 Temple Place, Suite 330\n* Boston, MA 02111-1307\n* USA\n*\n* Or, you may view it online at\n* http://www.opensource.org/licenses/lgpl-license.php\n*/\npackage org.jsecurity.context.factory.support;\n\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.support.DelegatingSecurityContext;\nimport org.jsecurity.util.ThreadContext;\n\n/**\n * SecurityContextFactory implementation that creates\n * {@link org.jsecurity.context.support.DelegatingSecurityContext} instances.\n *\n * @since 0.1\n * @author Les Hazlewood\n * @author Jeremy Haile\n */\npublic class DelegatingSecurityContextFactory extends AbstractSecurityContextFactory {\n\n    private SecurityManager securityManager;\n\n    public DelegatingSecurityContextFactory( SecurityManager securityManager ){\n        this.securityManager = securityManager;\n    }\n\n    protected SecurityContext onCreateSecurityContext( AuthenticationInfo info ) {\n        return new DelegatingSecurityContext( info.getPrincipals(), true, ThreadContext.getInetAddress(), null, securityManager );\n    }\n}\n","lineNo":54}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood, Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.context.support;\n\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.AuthorizedAction;\nimport org.jsecurity.authz.NoSuchPrincipalException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.session.Session;\n\nimport java.net.InetAddress;\nimport java.security.Principal;\nimport java.util.*;\n\n/**\n * Simple implementation of the <tt>SecurityContext<\/tt> interface that delegates\n * method calls to an underlying {@link org.jsecurity.SecurityManager SecurityManager} instance for security checks.\n * It is essentially a <tt>SecurityManager<\/tt> proxy.\n *\n * <p>This implementation does not maintain state such as roles and permissions (only a subject\n * identifier, such as a user primary key or username) for better performance in a stateless\n * architecture.  It instead asks the underlying <tt>SecurityManager<\/tt> every time to perform\n * the authorization check.\n *\n * <p>A common misconception in using this implementation is that an EIS resource (RDBMS, etc) would\n * be &quot;hit&quot; every time a method is called.  This is not necessarily the case and is\n * up to the implementation of the underlying <tt>SecurityManager<\/tt> instance.  If caching of authorization\n * context data is desired (to eliminate EIS round trips and therefore improve database performance), it is considered\n * much more elegant to let the underlying <tt>SecurityManager<\/tt> implementation manage caching, not this class.  A\n * <tt>SecurityManager<\/tt> is considered a business-tier component, where caching strategies are better suited.\n *\n * <p>Applications from large and clustered to simple and vm local all benefit from\n * stateless architectures.  This implementation plays a part in the stateless programming\n * paradigm and should be used whenever possible.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DelegatingSecurityContext implements SecurityContext {\n\n    protected List<Principal> principals;\n    protected boolean authenticated;\n    protected InetAddress inetAddress = null;\n    protected Session session = null;\n    protected SecurityManager securityManager;\n    protected boolean invalidated = false;\n\n    private static List<Principal> toList( Principal p ) {\n        List<Principal> principals = new ArrayList<Principal>(1);\n        if ( p != null ) {\n            principals.add( p );\n        }\n        return principals;\n    }\n\n    private static List<Principal> toList( List<Principal> ps ) {\n        List<Principal> principals = new ArrayList<Principal>( ps != null ? ps.size() : 1 );\n        principals.addAll( ps );\n        return principals;\n    }\n\n    public DelegatingSecurityContext( Principal principal, boolean authenticated, InetAddress inetAddress,\n                                      Session session, SecurityManager securityManager ) {\n        this( toList( principal ), authenticated, inetAddress, session, securityManager );\n    }\n\n    public DelegatingSecurityContext( List<Principal> principals, boolean authenticated, InetAddress inetAddress,\n                                      Session session, SecurityManager securityManager ) {\n        if ( securityManager == null ) {\n            throw new IllegalArgumentException( \"SecurityManager cannot be null.\" );\n        }\n        this.principals = toList( principals );\n        this.authenticated = authenticated;\n        this.inetAddress = inetAddress;\n        this.session = session;\n        this.securityManager = securityManager;\n    }\n\n    protected boolean isInvalidated() {\n        return invalidated;\n    }\n\n    protected void setInvalidated( boolean invalidated ) {\n        this.invalidated = invalidated;\n    }\n\n    protected void assertValid() throws InvalidSecurityContextException {\n        if ( isInvalidated() ) {\n            String msg = \"The SecurityContext has been invalidated.  It can no longer be used.\";\n            throw new InvalidSecurityContextException( msg );\n        }\n    }\n\n    /**\n     * Returns the InetAddress associated with the client who created/is interacting with this SecurityContext.\n     * <p/>\n     * <p>The default implementation attempts to get the InetAddress from a thread local for use in server-side\n     * environments.  Subclasses can override this method to retrieve the InetAddress from somewhere else (for\n     * example, as a system property in a standalone application, or an applet parameter for an applet).\n     *\n     * @return the InetAddress associated with the client who created/is interacting with this SecurityContext.\n     */\n    protected InetAddress getInetAddress() {\n        assertValid();\n        return this.inetAddress;\n    }\n\n    /**\n     * If multiple principals are defined, this method will return the first\n     * principal in the list of principals.\n     *\n     * @see org.jsecurity.context.SecurityContext#getPrincipal()\n     */\n    public Principal getPrincipal() {\n        assertValid();\n        if ( this.principals.isEmpty() ) {\n            return null;\n        } else {\n            return this.principals.get( 0 );\n        }\n    }\n\n    /**\n     * @see org.jsecurity.context.SecurityContext#getAllPrincipals()\n     */\n    public List<Principal> getAllPrincipals() {\n        assertValid();\n        return principals;\n    }\n\n    /**\n     * @see org.jsecurity.context.SecurityContext#getPrincipalByType(Class) ()\n     */\n    public Principal getPrincipalByType( Class<Principal> principalType ) throws NoSuchPrincipalException {\n        assertValid();\n        for ( Principal principal : principals ) {\n            if ( principalType.isAssignableFrom( principal.getClass() ) ) {\n                return principal;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @see org.jsecurity.context.SecurityContext#getAllPrincipalsByType(Class)()\n     */\n    public Collection<Principal> getAllPrincipalsByType( Class<Principal> principalType ) {\n        assertValid();\n        Set<Principal> principalsOfType = new HashSet<Principal>();\n\n        for ( Principal principal : principals ) {\n            if ( principalType.isAssignableFrom( principal.getClass() ) ) {\n                principalsOfType.add( principal );\n            }\n        }\n        return principalsOfType;\n    }\n\n    public boolean hasRole( String roleIdentifier ) {\n        assertValid();\n        return getPrincipal() != null && securityManager.hasRole( getPrincipal(), roleIdentifier );\n    }\n\n    public boolean[] hasRoles( List<String> roleIdentifiers ) {\n        assertValid();\n        if ( getPrincipal() != null ) {\n            return securityManager.hasRoles( getPrincipal(), roleIdentifiers );\n        } else {\n            return new boolean[roleIdentifiers.size()];\n        }\n    }\n\n    public boolean hasAllRoles( Collection<String> roleIdentifiers ) {\n        assertValid();\n        return getPrincipal() != null && securityManager.hasAllRoles( getPrincipal(), roleIdentifiers );\n    }\n\n    public boolean implies( Permission permission ) {\n        assertValid();\n        return getPrincipal() != null && securityManager.isPermitted( getPrincipal(), permission );\n    }\n\n    public boolean[] implies( List<Permission> permissions ) {\n        assertValid();\n        if ( getPrincipal() != null ) {\n            return securityManager.isPermitted( getPrincipal(), permissions );\n        } else {\n            return new boolean[permissions.size()];\n        }\n    }\n\n    public boolean impliesAll( Collection<Permission> permissions ) {\n        assertValid();\n        return getPrincipal() != null && securityManager.isPermittedAll( getPrincipal(), permissions );\n    }\n\n    public void checkPermission( Permission permission ) throws AuthorizationException {\n        assertValid();\n        securityManager.checkPermission( getPrincipal(), permission );\n    }\n\n    public void checkPermissions( Collection<Permission> permissions )\n        throws AuthorizationException {\n        assertValid();\n        securityManager.checkPermissions( getPrincipal(), permissions );\n    }\n\n    public void checkRole( String role ) throws AuthorizationException {\n        assertValid();\n        securityManager.checkRole( getPrincipal(), role );\n    }\n\n    public void checkRoles( Collection<String> roles ) throws AuthorizationException {\n        assertValid();\n        securityManager.checkRoles( getPrincipal(), roles );\n    }\n\n    public boolean isAuthorized( AuthorizedAction action ) {\n        assertValid();\n        return securityManager.isAuthorized( getPrincipal(), action );\n    }\n\n    public void checkAuthorization( AuthorizedAction action ) throws AuthorizationException {\n        assertValid();\n        securityManager.checkAuthorization( getPrincipal(), action );\n    }\n\n    public boolean isAuthenticated() {\n        assertValid();\n        return authenticated;\n    }\n\n    public Session getSession() {\n        return getSession( true );\n    }\n\n    public Session getSession( boolean create ) {\n        assertValid();\n        if ( this.session == null && create ) {\n            this.session = securityManager.start( getInetAddress() );\n        }\n        return this.session;\n    }\n\n    public void invalidate() {\n        if ( isInvalidated() ) {\n            return;\n        }\n        Session s = getSession( false );\n        if ( s != null ) {\n            s.stop();\n        }\n        this.session = null;\n        this.principals.clear();\n        this.authenticated = false;\n        this.inetAddress = null;\n        this.securityManager = null;\n        setInvalidated( true );\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood, Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.context.support;\n\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.AuthorizedAction;\nimport org.jsecurity.authz.NoSuchPrincipalException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\n\nimport java.net.InetAddress;\nimport java.security.Principal;\nimport java.util.*;\n\n/**\n * Simple implementation of the <tt>SecurityContext<\/tt> interface that delegates all\n * method calls to an underlying {@link org.jsecurity.SecurityManager SecurityManager} instance for security checks.\n * It is essentially a <tt>SecurityManager<\/tt> proxy.\n *\n * <p>This implementation does not maintain state such as roles and permissions (only a subject\n * identifier, such as a user primary key or username) for better performance in a stateless\n * architecture.  It instead asks the underlying <tt>SecurityManager<\/tt> every time to perform\n * the authorization check.\n *\n * <p>A common misconception in using this implementation is that an EIS resource (RDBMS, etc) would\n * be &quot;hit&quot; every time a method is called.  This is not necessarily the case and is\n * up to the implementation of the underlying <tt>SecurityManager<\/tt> instance.  If caching of authorization\n * context data is desired (to eliminate EIS round trips and therefore improve database performance), it is considered\n * much more elegant to let the underlying <tt>SecurityManager<\/tt> implementation manage caching, not this class.  A\n * <tt>SecurityManager<\/tt> is considered a business-tier component, where caching strategies are better suited.\n *\n * <p>Applications from large and clustered to simple and vm local all benefit from\n * stateless architectures.  This implementation plays a part in the stateless programming\n * paradigm and should be used whenever possible.\n *\n * @since 0.1\n * @author Les Hazlewood\n * @author Jeremy Haile\n */\npublic class DelegatingSecurityContext implements SecurityContext {\n\n    protected List<Principal> principals;\n\n    protected boolean authenticated;\n\n    protected SecurityManager securityManager;\n\n    protected boolean invalidated = false;\n\n    public DelegatingSecurityContext() {\n        principals = new ArrayList<Principal>();\n    }\n\n    public DelegatingSecurityContext(Principal principal, boolean authenticated, SecurityManager securityManager) {\n        if( securityManager == null) {\n            throw new IllegalArgumentException( \"SecurityManager cannot be null.\" );\n        }\n\n        this.principals = new ArrayList<Principal>(1);\n        if( principal != null ) {\n            this.principals.add( principal );\n        }\n        this.authenticated = authenticated;\n        this.securityManager = securityManager;\n    }\n\n    public DelegatingSecurityContext(List<Principal> principals, boolean authenticated, SecurityManager securityManager) {\n        if( securityManager == null) {\n            throw new IllegalArgumentException( \"SecurityManager cannot be null.\" );\n        }\n\n        this.principals = new ArrayList<Principal>(1);\n        if( principals != null ) {\n            this.principals.addAll( principals );\n        }\n        this.authenticated = authenticated;        \n        this.securityManager = securityManager;\n    }\n\n    protected boolean isInvalidated() {\n        return invalidated;\n    }\n\n    protected void setInvalidated( boolean invalidated ) {\n        this.invalidated = invalidated;\n    }\n\n    protected void assertValid() throws InvalidSecurityContextException {\n        if ( isInvalidated() ) {\n            String msg = \"The SecurityContext has been invalidated.  It can no longer be used.\";\n            throw new InvalidSecurityContextException( msg );\n        }\n    }\n\n    /**\n     * Returns the InetAddress associated with the client who created/is interacting with this SecurityContext.\n     *\n     * <p>The default implementation attempts to get the InetAddress from a thread local for use in server-side\n     * environments.  Subclasses can override this method to retrieve the InetAddress from somewhere else (for\n     * example, as a system property in a standalone application, or an applet parameter for an applet).\n     * @return the InetAddress associated with the client who created/is interacting with this SecurityContext.\n     */\n    protected InetAddress getInetAddress() {\n        assertValid();\n        return ThreadContext.getInetAddress();\n    }\n\n    /**\n     * If multiple principals are defined, this method will return the first\n     * principal in the list of principals.\n     * @see org.jsecurity.context.SecurityContext#getPrincipal()\n     */\n    public Principal getPrincipal() {\n        assertValid();\n        if( this.principals.isEmpty() ) {\n            return null;\n        } else {\n            return this.principals.get(0);\n        }\n    }\n\n    /**\n     * @see org.jsecurity.context.SecurityContext#getAllPrincipals()\n     */\n    public List<Principal> getAllPrincipals() {\n        assertValid();\n        return principals;\n    }\n\n    /**\n     * @see org.jsecurity.context.SecurityContext#getPrincipalByType(Class) ()\n     */\n    public Principal getPrincipalByType( Class<Principal> principalType ) throws NoSuchPrincipalException {\n        assertValid();\n        for( Principal principal : principals ) {\n            if( principalType.isAssignableFrom( principal.getClass() ) ) {\n                return principal;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @see org.jsecurity.context.SecurityContext#getAllPrincipalsByType(Class)()\n     */\n    public Collection<Principal> getAllPrincipalsByType(Class<Principal> principalType) {\n        assertValid();\n        Set<Principal> principalsOfType = new HashSet<Principal>();\n\n        for( Principal principal : principals ) {\n            if( principalType.isAssignableFrom( principal.getClass() ) ) {\n                principalsOfType.add( principal );\n            }\n        }\n        return principalsOfType;\n    }\n\n    public boolean hasRole( String roleIdentifier ) {\n        assertValid();\n        return getPrincipal() != null && securityManager.hasRole( getPrincipal(), roleIdentifier );\n    }\n\n    public boolean[] hasRoles( List<String> roleIdentifiers ) {\n        assertValid();\n        if( getPrincipal() != null ) {\n            return securityManager.hasRoles( getPrincipal(), roleIdentifiers );\n        } else {\n            return new boolean[roleIdentifiers.size()];\n        }\n    }\n\n    public boolean hasAllRoles( Collection<String> roleIdentifiers ) {\n        assertValid();\n        return getPrincipal() != null && securityManager.hasAllRoles( getPrincipal(), roleIdentifiers );\n    }\n\n    public boolean implies( Permission permission ) {\n        assertValid();\n        return getPrincipal() != null && securityManager.isPermitted( getPrincipal(), permission );\n    }\n\n    public boolean[] implies( List<Permission> permissions ) {\n        assertValid();\n        if( getPrincipal() != null ) {\n            return securityManager.isPermitted( getPrincipal(), permissions );\n        } else{\n            return new boolean[permissions.size()];\n        }\n    }\n\n    public boolean impliesAll( Collection<Permission> permissions ) {\n        assertValid();\n        return getPrincipal() != null && securityManager.isPermittedAll( getPrincipal(), permissions );\n    }\n\n    public void checkPermission( Permission permission ) throws AuthorizationException {\n        assertValid();\n        securityManager.checkPermission( getPrincipal(), permission );\n    }\n\n    public void checkPermissions( Collection<Permission> permissions )\n        throws AuthorizationException {\n        assertValid();\n        securityManager.checkPermissions( getPrincipal(), permissions );\n    }\n\n    public void checkRole(String role) throws AuthorizationException {\n        assertValid();\n        securityManager.checkRole( getPrincipal(), role );\n    }\n\n    public void checkRoles(Collection<String> roles) throws AuthorizationException {\n        assertValid();\n        securityManager.checkRoles( getPrincipal(), roles );\n    }\n\n    public boolean isAuthorized( AuthorizedAction action ) {\n        assertValid();\n        return securityManager.isAuthorized( getPrincipal(), action );\n    }\n\n    public void checkAuthorization( AuthorizedAction action ) throws AuthorizationException {\n        assertValid();\n        securityManager.checkAuthorization( getPrincipal(), action );\n    }\n\n    public boolean isAuthenticated() {\n        assertValid();\n        return authenticated;\n    }\n\n    public Session getSession() {\n        return getSession( true );\n    }\n\n    public Session getSession( boolean create ) {\n        assertValid();\n        Session s = ThreadContext.getSession();\n        if ( s == null && create ) {\n            s = securityManager.start( getInetAddress() );\n            ThreadContext.bind( s );\n        }\n        return s;\n    }\n\n    public void invalidate() {\n        if ( isInvalidated() ) {\n            return;\n        }\n\n        this.authenticated = false;\n        this.principals.clear();\n\n        Session s = getSession( false );\n        if ( s != null ) {\n            s.stop();\n        }\n    }\n\n}\n","lineNo":82}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.web.support;\n\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.support.DelegatingSecurityContext;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.WebInterceptor;\nimport org.jsecurity.web.WebSessionFactory;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.net.InetAddress;\nimport java.security.Principal;\nimport java.util.List;\n\n/**\n * Builds a previously initialized {@link org.jsecurity.context.SecurityContext SecurityContext} based on a web request.\n * <p/>\n * <p>Primarily a parent class to consolidate common behaviors in obtaining a SecurityContext in different\n * web environments (e.g. Servlet Filters, framework specific interceptors, etc).\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class SecurityContextWebInterceptor extends SecurityWebSupport implements WebInterceptor {\n\n    /**\n     * The key that is used to store subject principals in the session.\n     */\n    public static final String PRINCIPALS_SESSION_KEY =\n        SecurityContextWebInterceptor.class.getName() + \"_PRINCIPALS_SESSION_KEY\";\n\n    /**\n     * The key that is used to store whether or not the user is authenticated in the session.\n     */\n    public static final String AUTHENTICATED_SESSION_KEY =\n        SecurityContextWebInterceptor.class.getName() + \"_AUTHENTICATED_SESSION_KEY\";\n\n    protected SecurityManager securityManager = null;\n\n    protected WebSessionFactory webSessionFactory = null;\n\n    /**\n     * Determines whether or not to use the HttpSession as the storage mechanism for principals or the JSecurity\n     * Session.  The default is <tt>false<\/tt>, since JSecurity sessions can be accessed across multiple client\n     * mediums (more flexible) and HttpSessions cannot.\n     */\n    protected boolean preferHttpSessionStorage = false;\n\n    public SecurityContextWebInterceptor() {\n    }\n\n    public SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    public void setSecurityManager( SecurityManager securityManager ) {\n        this.securityManager = securityManager;\n    }\n\n    public WebSessionFactory getWebSessionFactory() {\n        return webSessionFactory;\n    }\n\n    public void setWebSessionFactory( WebSessionFactory webSessionFactory ) {\n        this.webSessionFactory = webSessionFactory;\n    }\n\n    public boolean isPreferHttpSessionStorage() {\n        return preferHttpSessionStorage;\n    }\n\n    public void setPreferHttpSessionStorage( boolean preferHttpSessionStorage ) {\n        this.preferHttpSessionStorage = preferHttpSessionStorage;\n    }\n\n    public void init() {\n        SecurityManager securityManager = getSecurityManager();\n        if ( securityManager == null ) {\n            String msg = \"SecurityManager property must be set.\";\n            throw new IllegalStateException( msg );\n        }\n        if ( getWebSessionFactory() == null ) {\n            DefaultWebSessionFactory factory = new DefaultWebSessionFactory();\n            factory.setSessionFactory( securityManager );\n            factory.init();\n            setWebSessionFactory( factory );\n        }\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    protected List<Principal> getPrincipalsFromJSecuritySession( HttpServletRequest request, HttpServletResponse response ) {\n        List<Principal> principals = null;\n        Session session = getWebSessionFactory().getSession( request, response );\n        if ( session != null ) {\n            principals = (List<Principal>)session.getAttribute( PRINCIPALS_SESSION_KEY );\n            if ( principals == null ) {\n                if ( log.isTraceEnabled() ) {\n                    log.trace( \"JSecurity Session exists, but does not contain any principals from which a \" +\n                        \"SecurityContext may be built.  Returning null and moving on...\" );\n                }\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No JSecurity Session associated with the request.  Ignoring as a resource to \" +\n                    \"construct a SecurityContext instance.\" );\n            }\n        }\n        return principals;\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    protected List<Principal> getPrincipalsFromHttpSession( HttpServletRequest request ) {\n        List<Principal> principals = null;\n        HttpSession httpSession = request.getSession( false );\n        if ( httpSession != null ) {\n            principals = (List<Principal>)httpSession.getAttribute( PRINCIPALS_SESSION_KEY );\n            if ( principals == null ) {\n                if ( log.isTraceEnabled() ) {\n                    log.trace( \"HttpSession exists, but does not contain any principals from which a \" +\n                        \"SecurityContext may be built.  Returning null and moving on...\" );\n                }\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"HttpSession does not exist.  Ignoring as a resource to attempt to construct a \" +\n                    \"SecurityContext instance.\" );\n            }\n        }\n        return principals;\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    protected List<Principal> getPrincipals( ServletRequest servletRequest, ServletResponse servletResponse ) {\n\n        HttpServletRequest request = (HttpServletRequest)servletRequest;\n        HttpServletResponse response = (HttpServletResponse)servletResponse;\n\n        List<Principal> principals = null;\n\n        if ( !isPreferHttpSessionStorage() ) {\n            principals = getPrincipalsFromJSecuritySession( request, response );\n        }\n\n        if ( principals == null || principals.isEmpty() ) {\n            //fall back to HttpSession:\n            principals = getPrincipalsFromHttpSession( request );\n        }\n\n        return principals;\n    }\n\n    protected boolean isAuthenticatedFromJSecuritySession( HttpServletRequest request, HttpServletResponse response ) {\n\n        // Defaults to false unless found in the session\n        boolean authenticated = false;\n        Session session = getWebSessionFactory().getSession( request, response );\n        if ( session != null ) {\n            Boolean boolAuthenticated = (Boolean)session.getAttribute( AUTHENTICATED_SESSION_KEY );\n            if ( boolAuthenticated != null ) {\n                authenticated = boolAuthenticated;\n            }\n        }\n        return authenticated;\n    }\n\n    protected boolean isAuthenticatedFromHttpSession( HttpServletRequest request ) {\n\n        // Defaults to false unless found in the session\n        boolean authenticated = false;\n        HttpSession httpSession = request.getSession( false );\n        if ( httpSession != null ) {\n            Boolean boolAuthenticated = (Boolean)httpSession.getAttribute( AUTHENTICATED_SESSION_KEY );\n            if ( boolAuthenticated != null ) {\n                authenticated = boolAuthenticated;\n            }\n        }\n        return authenticated;\n    }\n\n    protected boolean isAuthenticated( ServletRequest servletRequest, ServletResponse servletResponse ) {\n\n        HttpServletRequest request = (HttpServletRequest)servletRequest;\n        HttpServletResponse response = (HttpServletResponse)servletResponse;\n\n        boolean authenticated;\n\n        if ( !isPreferHttpSessionStorage() ) {\n            authenticated = isAuthenticatedFromJSecuritySession( request, response );\n        } else {\n            //fall back to HttpSession:\n            authenticated = isAuthenticatedFromHttpSession( request );\n        }\n\n        return authenticated;\n    }\n\n    protected SecurityContext buildSecurityContext( List<Principal> principals, boolean authenticated,\n                                                    InetAddress inetAddress, Session session,\n                                                    SecurityManager securityManager ) {\n        return new DelegatingSecurityContext( principals, authenticated, inetAddress, session, securityManager );\n    }\n\n    protected SecurityContext buildSecurityContext( ServletRequest request,\n                                                    ServletResponse response,\n                                                    List<Principal> principals,\n                                                    boolean authenticated ) {\n\n        SecurityContext securityContext;\n\n        SecurityManager securityManager = getSecurityManager();\n\n        if ( securityManager == null ) {\n            final String message = \"the SecurityManager attribute must be configured.  This could be \" +\n                \"done by calling setSecurityManager() on the \" + getClass().getName() + \" instance, or by subclassing \" +\n                \"to retrieve the SecurityManager from an application framework.\";\n            throw new IllegalStateException( message );\n        }\n\n        Session session = getWebSessionFactory().getSession( (HttpServletRequest)request, (HttpServletResponse)response );\n\n        securityContext = buildSecurityContext( principals, authenticated,\n                          getInetAddress( request ), session, securityManager );\n\n        return securityContext;\n    }\n\n\n    public SecurityContext buildSecurityContext( ServletRequest request, ServletResponse response ) {\n        List<Principal> principals = getPrincipals( request, response );\n        boolean authenticated = isAuthenticated( request, response );\n        return buildSecurityContext( request, response, principals, authenticated );\n    }\n\n    protected boolean bindInJSecuritySessionForSubsequentRequests( HttpServletRequest request,\n                                                                   HttpServletResponse response,\n                                                                   SecurityContext securityContext ) {\n        boolean saved = false;\n\n        try {\n            Session session = securityContext.getSession();\n\n            if ( session != null ) {\n                // Don't overwrite any previous credentials - i.e. SecurityContext swapping for a previously\n                // initialized session is not allowed.\n                // Only store principals if they exist in the security context\n                Object currentPrincipal = session.getAttribute( PRINCIPALS_SESSION_KEY );\n                List<Principal> allPrincipals = securityContext.getAllPrincipals();\n                if ( currentPrincipal == null && allPrincipals != null && !allPrincipals.isEmpty() ) {\n                    session.setAttribute( PRINCIPALS_SESSION_KEY, allPrincipals );\n                }\n\n                // Only bind if the current value in the session is null or it doesn't equal the security context value\n                Boolean currentAuthenticated = (Boolean)session.getAttribute( AUTHENTICATED_SESSION_KEY );\n                if ( currentAuthenticated == null || !currentAuthenticated.equals( securityContext.isAuthenticated() ) ) {\n                    session.setAttribute( AUTHENTICATED_SESSION_KEY, securityContext.isAuthenticated() );\n                }\n                saved = true;\n            }\n        } catch ( Throwable t ) {\n            if ( log.isWarnEnabled() ) {\n                String msg = \"Unable to store SecurityContext Principal(s) collection in JSecurity Session for \" +\n                    \"reconstruction on subsequent requests: \";\n                log.warn( msg, t );\n            }\n        }\n\n        return saved;\n    }\n\n    protected boolean bindInHttpSessionForSubsequentRequests( HttpServletRequest request, HttpServletResponse response,\n                                                              SecurityContext securityContext ) {\n        HttpSession httpSession = request.getSession();\n\n        // Don't overwrite any previous credentials - i.e. SecurityContext swapping for a previously\n        // initialized session is not allowed.\n        // Only store principals if they exist in the security context\n        Object currentPrincipal = httpSession.getAttribute( PRINCIPALS_SESSION_KEY );\n        if ( currentPrincipal == null && !securityContext.getAllPrincipals().isEmpty() ) {\n            httpSession.setAttribute( PRINCIPALS_SESSION_KEY, securityContext.getAllPrincipals() );\n        }\n\n        // Only bind if the current value in the session is null or it doesn't equal the security context value\n        Boolean currentAuthenticated = (Boolean)httpSession.getAttribute( AUTHENTICATED_SESSION_KEY );\n        if ( currentAuthenticated == null || !currentAuthenticated.equals( securityContext.isAuthenticated() ) ) {\n            httpSession.setAttribute( AUTHENTICATED_SESSION_KEY, securityContext.isAuthenticated() );\n        }\n        return true;\n    }\n\n    protected void bindForSubsequentRequests( HttpServletRequest request, HttpServletResponse response, SecurityContext securityContext ) {\n        boolean saved = false;\n        if ( !isPreferHttpSessionStorage() ) {\n            saved = bindInJSecuritySessionForSubsequentRequests( request, response, securityContext );\n        }\n\n        if ( !saved ) {\n            //always fall back to HttpSession\n            bindInHttpSessionForSubsequentRequests( request, response, securityContext );\n        }\n    }\n\n    public boolean preHandle( HttpServletRequest request, HttpServletResponse response )\n        throws Exception {\n        SecurityContext securityContext = buildSecurityContext( request, response );\n        if ( securityContext != null ) {\n            ThreadContext.bind( securityContext );\n        }\n        //useful for a number of JSecurity components - do it in case this interceptor is the only one configured:\n        bindInetAddressToThread( request );\n        return true;\n    }\n\n    public void postHandle( HttpServletRequest request, HttpServletResponse response )\n        throws Exception {\n        SecurityContext securityContext = ThreadContext.getSecurityContext();\n        if ( securityContext != null ) {\n            bindForSubsequentRequests( request, response, securityContext );\n        }\n    }\n\n    public void afterCompletion( HttpServletRequest request, HttpServletResponse response, Exception exception )\n        throws Exception {\n        ThreadContext.unbindSecurityContext();\n        ThreadContext.unbindSession();\n        unbindInetAddressFromThread();\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.web.support;\n\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.support.DelegatingSecurityContext;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.security.Principal;\nimport java.util.List;\n\n/**\n * Builds a previously initialized {@link org.jsecurity.context.SecurityContext SecurityContext} based on a web request.\n *\n * <p>Primarily a parent class to consolidate common behaviors in obtaining a SecurityContext in different\n * web environments (e.g. Servlet Filters, framework specific interceptors, etc).\n *\n * @since 0.2\n * @author Les Hazlewood\n */\npublic class SecurityContextWebInterceptor extends SecurityWebInterceptor {\n\n    protected enum SecurityContextStorageOrder {\n        Cookie_HttpSession_JSecuritySession,\n        Cookie_JSecuritySession_HttpSession\n    }\n\n    /**\n     * The key that is used to store subject principals in the session.\n     */\n    public static final String PRINCIPALS_SESSION_KEY =\n        SecurityContextWebInterceptor.class.getName() + \"_PRINCIPALS_SESSION_KEY\";\n\n    /**\n     * The key that is used to store whether or not the user is authenticated in the session.\n     */\n    public static final String AUTHENTICATED_SESSION_KEY =\n        SecurityContextWebInterceptor.class.getName() + \"_AUTHENTICATED_SESSION_KEY\";\n\n    protected SecurityManager securityManager = null;\n\n    /**\n     * If a cookie is not used to store the Principal object(s) that will be used to re-construct a SecurityContext\n     * on every request, a <tt>false<\/tt> value here (default) will attempt to use the JSecurity Session to\n     * store the Principal(s) between requests, if it exists.  If it does not exist, then the storage mechanism will\n     * always fall back to the HttpSession.\n     *\n     * <p>If a cookie is not used to store the Principal(s), and this value is <tt>true<\/tt>, the JSecurity Session\n     * is not utilized at all - instead the HttpSession will be used immediately to store the Principal(s).\n     */\n    protected boolean preferHttpSessionStorage = false;\n\n    public SecurityContextWebInterceptor() {\n    }\n\n    public SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    public void setSecurityManager( SecurityManager securityManager ) {\n        this.securityManager = securityManager;\n    }\n\n    public boolean isPreferHttpSessionStorage() {\n        return preferHttpSessionStorage;\n    }\n\n    public void setPreferHttpSessionStorage( boolean preferHttpSessionStorage ) {\n        this.preferHttpSessionStorage = preferHttpSessionStorage;\n    }\n\n    public void init() {\n        SecurityManager securityManager = getSecurityManager();\n        if ( securityManager == null ) {\n            String msg = \"SecurityManager property must be set.\";\n            throw new IllegalStateException( msg );\n        }\n    }\n\n    protected List<Principal> getPrincipalsFromCookie( HttpServletRequest request ) {\n        return null;//no cookie storage by default - application Principals are application dependent and require the \n        //app to do string-to-principal conversion & vice versa for cookies to work;\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    protected List<Principal> getPrincipalsFromJSecuritySession( HttpServletRequest request ) {\n\n        //request object is ignored, JSecurity default is to get the JSecurity Session from the thread.  This means\n        //a JSecurity Session interception mechanism of some sort (filter, interceptor, etc) must be configured before \n        //this object.\n\n        List<Principal> principals = null;\n        Session session = ThreadContext.getSession();\n        if ( session != null ) {\n            principals = (List<Principal>)session.getAttribute( PRINCIPALS_SESSION_KEY );\n            if ( principals == null ) {\n                if ( log.isTraceEnabled() ) {\n                    log.trace( \"JSecurity Session exists, but does not contain any principals from which a \" +\n                        \"SecurityContext may be built.  Returning null and moving on...\" );\n                }\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"JSecurity Session does not exist.  Ignoring as a resource to attempt to construct a \" +\n                    \"SecurityContext instance.\" );\n            }\n        }\n        return principals;\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    protected List<Principal> getPrincipalsFromHttpSession( HttpServletRequest request ) {\n        List<Principal> principals = null;\n        HttpSession httpSession = request.getSession( false );\n        if ( httpSession != null ) {\n            principals = (List<Principal>)httpSession.getAttribute( PRINCIPALS_SESSION_KEY );\n            if ( principals == null ) {\n                if ( log.isTraceEnabled() ) {\n                    log.trace( \"HttpSession exists, but does not contain any principals from which a \" +\n                        \"SecurityContext may be built.  Returning null and moving on...\" );\n                }\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"HttpSession does not exist.  Ignoring as a resource to attempt to construct a \" +\n                    \"SecurityContext instance.\" );\n            }\n        }\n        return principals;\n    }\n\n    protected boolean isAuthenticatedFromJSecuritySession( HttpServletRequest request ) {\n\n        // Defaults to false unless found in the session\n        boolean authenticated = false;\n        Session session = ThreadContext.getSession();\n        if ( session != null ) {\n            Boolean boolAuthenticated = (Boolean)session.getAttribute( AUTHENTICATED_SESSION_KEY );\n            if( boolAuthenticated != null ) {\n                authenticated = boolAuthenticated;\n            }\n        }\n        return authenticated;\n    }\n\n    protected boolean isAuthenticatedFromHttpSession( HttpServletRequest request ) {\n\n        // Defaults to false unless found in the session\n        boolean authenticated = false;\n        HttpSession httpSession = request.getSession( false );\n        if ( httpSession != null ) {\n            Boolean boolAuthenticated = (Boolean)httpSession.getAttribute( AUTHENTICATED_SESSION_KEY );\n            if( boolAuthenticated != null ) {\n                authenticated = boolAuthenticated;\n            }\n        }\n        return authenticated;\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    protected List<Principal> getPrincipals( ServletRequest servletRequest ) {\n\n        HttpServletRequest request = (HttpServletRequest)servletRequest;\n\n        List<Principal> principals = getPrincipalsFromCookie( request );\n\n        if ( principals == null || principals.isEmpty() ) {\n\n            if ( !isPreferHttpSessionStorage() ) {\n                principals = getPrincipalsFromJSecuritySession( request );\n            }\n\n            if ( principals == null || principals.isEmpty() ) {\n                //fall back to HttpSession:\n                principals = getPrincipalsFromHttpSession( request );\n            }\n        }\n\n        return principals;\n    }\n\n    protected boolean isAuthenticated( ServletRequest servletRequest ) {\n\n        HttpServletRequest request = (HttpServletRequest)servletRequest;\n\n        boolean authenticated;\n\n        if( !isPreferHttpSessionStorage() ) {\n            authenticated = isAuthenticatedFromJSecuritySession( request );\n        } else {\n            //fall back to HttpSession:\n            authenticated = isAuthenticatedFromHttpSession( request );\n        }\n\n        return authenticated;\n    }\n\n    protected SecurityContext buildSecurityContext( List<Principal> principals, boolean authenticated, SecurityManager securityManager ) {\n        return new DelegatingSecurityContext( principals, authenticated, securityManager);\n    }\n\n    protected SecurityContext buildSecurityContext( ServletRequest request,\n                                                    ServletResponse response,\n                                                    List<Principal> principals,\n                                                    boolean authenticated ) {\n\n        SecurityContext securityContext;\n\n        if ( securityManager == null ) {\n            final String message = \"the SecurityManager attribute must be configured.  This could be \" +\n                \"done by calling setSecurityManager() on the \" + getClass() + \" instance, or by subclassing this \" +\n                \"class to retrieve the SecurityManager from an application framework.\";\n            if ( log.isErrorEnabled() ) {\n                log.error( message );\n            }\n            throw new IllegalStateException( message );\n        }\n        securityContext = buildSecurityContext( principals, authenticated, securityManager );\n\n        return securityContext;\n    }\n\n\n    public SecurityContext buildSecurityContext( ServletRequest request, ServletResponse response ) {\n        List<Principal> principals = getPrincipals( request );\n        boolean authenticated = isAuthenticated( request );\n        return buildSecurityContext( request, response, principals, authenticated );\n    }\n\n    protected void bindToThread( SecurityContext securityContext ) {\n        ThreadContext.bind( securityContext );\n    }\n\n    protected void unbindSecurityContextFromThread() {\n        ThreadContext.unbindSecurityContext();\n    }\n\n    protected boolean bindInCookieForSubsequentRequests( HttpServletRequest request, HttpServletResponse response,\n                                                         SecurityContext securityContxt ) {\n        //todo This looks wrong.  Does it need to be fixed before 0.2?  If not, comment this method as to why it is empty\n        return false;\n    }\n\n    protected boolean bindInJSecuritySessionForSubsequentRequests( HttpServletRequest request, HttpServletResponse response,\n                                                                   SecurityContext securityContext ) {\n        boolean saved = false;\n\n        Session session;\n\n        try {\n            session = securityContext.getSession();\n        } catch ( Exception t ) {\n            if ( log.isWarnEnabled() ) {\n                String msg = \"Unable to acquire a JSecurity Session from the SecurityContext.  SecurityContext \" +\n                    \"Principal(s) cannot be stored here for access on subsequent requests: \";\n                log.warn( msg, t );\n            }\n            return false;\n        }\n\n        try {\n            if ( session != null ) {\n                // Don't overwrite any previous credentials - i.e. SecurityContext swapping for a previously\n                // initialized session is not allowed.\n                // Only store principals if they exist in the security context\n                Object currentPrincipal = session.getAttribute(PRINCIPALS_SESSION_KEY);\n                if ( currentPrincipal == null && !securityContext.getAllPrincipals().isEmpty()  ) {\n                    session.setAttribute( PRINCIPALS_SESSION_KEY, securityContext.getAllPrincipals() );\n                }\n\n                // Only bind if the current value in the session is null or it doesn't equal the security context value\n                Boolean currentAuthenticated = (Boolean) session.getAttribute( AUTHENTICATED_SESSION_KEY );\n                if ( currentAuthenticated == null || !currentAuthenticated.equals( securityContext.isAuthenticated() ) ) {\n                    session.setAttribute( AUTHENTICATED_SESSION_KEY, securityContext.isAuthenticated() );\n                }\n                saved = true;\n            }\n        } catch ( Throwable t ) {\n            if ( log.isWarnEnabled() ) {\n                String msg = \"Unable to store SecurityContext Principal(s) collection in JSecurity Session for \" +\n                    \"reconstruction on subsequent requests: \";\n                log.warn( msg, t );\n            }\n        }\n\n        return saved;\n    }\n\n    protected boolean bindInHttpSessionForSubsequentRequests( HttpServletRequest request, HttpServletResponse response,\n                                                              SecurityContext securityContext ) {\n        HttpSession httpSession = request.getSession();\n\n        // Don't overwrite any previous credentials - i.e. SecurityContext swapping for a previously\n        // initialized session is not allowed.\n        // Only store principals if they exist in the security context\n        Object currentPrincipal = httpSession.getAttribute(PRINCIPALS_SESSION_KEY);\n        if ( currentPrincipal == null && !securityContext.getAllPrincipals().isEmpty()  ) {\n            httpSession.setAttribute( PRINCIPALS_SESSION_KEY, securityContext.getAllPrincipals() );\n        }\n\n        // Only bind if the current value in the session is null or it doesn't equal the security context value\n        Boolean currentAuthenticated = (Boolean) httpSession.getAttribute( AUTHENTICATED_SESSION_KEY );\n        if ( currentAuthenticated == null || !currentAuthenticated.equals( securityContext.isAuthenticated() ) ) {\n            httpSession.setAttribute( AUTHENTICATED_SESSION_KEY, securityContext.isAuthenticated() );\n        }\n        return true;\n    }\n\n    protected void bindForSubsequentRequests( HttpServletRequest request, HttpServletResponse response, SecurityContext securityContext ) {\n        if ( securityContext != null ) {\n            boolean saved = bindInCookieForSubsequentRequests( request, response, securityContext );\n            if ( !saved ) {\n                if ( !isPreferHttpSessionStorage() ) {\n                    saved = bindInJSecuritySessionForSubsequentRequests( request, response, securityContext );\n                }\n            }\n            if ( !saved ) {\n                //fall back to HttpSession:\n                saved = bindInHttpSessionForSubsequentRequests( request, response, securityContext );\n            }\n        }\n    }\n\n    public boolean preHandle( HttpServletRequest request, HttpServletResponse response )\n        throws Exception {\n        SecurityContext securityContext = buildSecurityContext( request, response );\n        if ( securityContext != null ) {\n            bindToThread( securityContext );\n        }\n        //useful for a number of JSecurity components - do it in case this interceptor is the only one configured:\n        bindInetAddressToThread( request );\n        return true;\n    }\n\n    public void postHandle( HttpServletRequest request, HttpServletResponse response )\n        throws Exception {\n        SecurityContext securityContext = ThreadContext.getSecurityContext();\n        if ( securityContext != null ) {\n            bindForSubsequentRequests( request, response, securityContext );\n        }\n    }\n\n    public void afterCompletion( HttpServletRequest request, HttpServletResponse response, Exception exception )\n        throws Exception {\n        unbindSecurityContextFromThread();\n        unbindInetAddressFromThread();\n    }\n\n}\n","lineNo":276}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood, Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.spring.remoting;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.support.DelegatingSecurityContext;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.support.SecurityContextWebInterceptor;\nimport org.springframework.remoting.support.DefaultRemoteInvocationExecutor;\nimport org.springframework.remoting.support.RemoteInvocation;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.security.Principal;\nimport java.util.List;\n\n/**\n * An implementation of the Spring {@link org.springframework.remoting.support.RemoteInvocationExecutor}\n * that binds the correct {@link Session} and {@link org.jsecurity.context.SecurityContext} to the\n * remote invocation thread during a remote execution.\n *\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class SecureRemoteInvocationExecutor extends DefaultRemoteInvocationExecutor {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logger.\n     */\n    protected transient final Log log = LogFactory.getLog( getClass() );\n\n    /**\n     * The realm manager used to retrieve realms that should be associated with the\n     * created authorization contexts upon remote invocation.\n     */\n    private SecurityManager securityManager;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    public void setSecurityManager( SecurityManager securityManager ) {\n        this.securityManager = securityManager;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    protected InetAddress getInetAddress( RemoteInvocation invocation, Object targetObject ) {\n        try {\n            return InetAddress.getLocalHost();\n        } catch ( UnknownHostException e ) {\n            return null;\n        }\n    }\n\n    @SuppressWarnings( { \"unchecked\" } )\n    public Object invoke( RemoteInvocation invocation, Object targetObject ) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n\n        try {\n            List<Principal> principals = null;\n            boolean authenticated = false;\n            InetAddress inetAddress = getInetAddress( invocation, targetObject );\n            Session session = null;\n\n            if ( invocation instanceof SecureRemoteInvocation ) {\n                SecureRemoteInvocation secureInvocation = (SecureRemoteInvocation)invocation;\n\n                Serializable sessionId = secureInvocation.getSessionId();\n\n                if ( sessionId == null ) {\n                    //try remote invocation attributes:\n                    sessionId = (Serializable)secureInvocation.getAttributes().get( \"sessionId\" );\n                }\n\n                if ( sessionId != null ) {\n                    session = securityManager.getSession( sessionId );\n                    ThreadContext.bind( session );\n\n                    // Get the principals and realm name from the session\n                    principals = (List<Principal>)session.getAttribute( SecurityContextWebInterceptor.PRINCIPALS_SESSION_KEY );\n\n                    // If principals and realm were found in the session, assume authenticated.\n                    if ( principals != null && !principals.isEmpty() ) {\n                        authenticated = true;\n                    }\n                }\n\n            } else {\n                if ( log.isWarnEnabled() ) {\n                    log.warn( \"Secure remote invocation executor used, but did not receive a \" +\n                        \"SecureRemoteInvocation from remote call.  Session will not be propogated to the remote invocation.  \" +\n                        \"Ensure that clients are using a SecureRemoteInvocationFactory to prevent this problem.\" );\n                }\n            }\n\n            SecurityContext securityContext =\n                new DelegatingSecurityContext( principals, authenticated, inetAddress, session, securityManager );\n\n            ThreadContext.bind( securityContext );\n\n            return super.invoke( invocation, targetObject );\n        } finally {\n            ThreadContext.clear();\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood, Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.spring.remoting;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.support.DelegatingSecurityContext;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.support.SecurityContextWebInterceptor;\nimport org.springframework.remoting.support.DefaultRemoteInvocationExecutor;\nimport org.springframework.remoting.support.RemoteInvocation;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.security.Principal;\nimport java.util.List;\n\n/**\n * An implementation of the Spring {@link org.springframework.remoting.support.RemoteInvocationExecutor}\n * that binds the correct {@link Session} and {@link org.jsecurity.context.SecurityContext} to the\n * remote invocation thread during a remote execution.\n *\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class SecureRemoteInvocationExecutor extends DefaultRemoteInvocationExecutor {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logger.\n     */\n    protected transient final Log log = LogFactory.getLog( getClass() );\n\n    /**\n     * The realm manager used to retrieve realms that should be associated with the\n     * created authorization contexts upon remote invocation.\n     */\n    private SecurityManager securityManager;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    public void setSecurityManager( SecurityManager securityManager ) {\n        this.securityManager = securityManager;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    @SuppressWarnings( { \"unchecked\" } )\n    public Object invoke( RemoteInvocation invocation, Object targetObject ) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n\n        try {\n\n            if ( invocation instanceof SecureRemoteInvocation ) {\n                SecureRemoteInvocation secureInvocation = (SecureRemoteInvocation)invocation;\n\n                Serializable sessionId = secureInvocation.getSessionId();\n\n                if ( sessionId == null ) {\n                    //try remote invocation attributes:\n                    sessionId = (Serializable)secureInvocation.getAttributes().get( \"sessionId\" );\n                }\n\n                if ( sessionId != null ) {\n                    Session session = securityManager.getSession( sessionId );\n                    ThreadContext.bind( session );\n\n                    // Get the principals and realm name from the session\n                    List<Principal> principals = (List<Principal>)session.getAttribute( SecurityContextWebInterceptor.PRINCIPALS_SESSION_KEY );\n\n                    // If principals and realm were found in the session, create a delegating authorization context\n                    // and bind it to the thread.\n                    if ( principals != null && !principals.isEmpty() ) {\n                        SecurityContext securityContext = new DelegatingSecurityContext( principals, true, securityManager );\n                        ThreadContext.bind( securityContext );\n                    }\n                }\n            } else {\n                if ( log.isWarnEnabled() ) {\n                    log.warn( \"Secure remote invocation executor used, but did not receive a \" +\n                        \"SecureRemoteInvocation from remote call.  Session will not be propogated to the remote invocation.  \" +\n                        \"Ensure that clients are using a SecureRemoteInvocationFactory to prevent this problem.\" );\n                }\n            }\n\n            return super.invoke( invocation, targetObject );\n        } finally {\n            ThreadContext.clear();\n        }\n    }\n}\n","lineNo":102}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile, Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.authc.support;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.Authenticator;\nimport org.jsecurity.authc.event.AuthenticationEvent;\nimport org.jsecurity.authc.event.AuthenticationEventFactory;\nimport org.jsecurity.authc.event.AuthenticationEventSender;\nimport org.jsecurity.authc.event.support.SimpleAuthenticationEventFactory;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.bind.SecurityContextBinder;\nimport org.jsecurity.context.bind.support.ThreadLocalSecurityContextBinder;\nimport org.jsecurity.context.factory.SecurityContextFactory;\nimport org.jsecurity.context.factory.support.DelegatingSecurityContextFactory;\nimport org.jsecurity.util.Initializable;\n\n/**\n * Superclass for almost all {@link Authenticator} implementations that performs the common work around authentication\n * attempts.\n *\n * <p>This class delegates the actual authentication attempt to subclasses but will send events based on a\n * successful or failed attempt, create a {@link SecurityContext SecurityContext} in the event of a successful attmept,\n * and bind this <tt>SecurityContext<\/tt> to the application for further use.\n *\n * <p>In most cases, the only thing a subclass needs to do (via its {@link #doAuthenticate} implementation)\n * is perform the actual principal/credential verification process for the submitted <tt>AuthenticationToken<\/tt>.\n *\n * <p>This implementation employs an event-based architecture so other components may react to both failed and\n * successful authentication attempts.  Failure or success events are triggered based on the\n * subclass's {@link #doAuthenticate} implementation throwing an exception or not, respectively (i.e. a failure event\n * will be created and sent if the authentication attempt fails, and a success event will be created and sent if the\n * authentication event is successful.  The actual events\n * themselves are constructed via an {@link AuthenticationEventFactory} and sent to interested components via a\n * {@link AuthenticationEventSender}.\n * \n * <p>Both the event factory and the event sender may be set as properties of this class\n * (instead of overriding this class for event creation and sending).  A simple default event factory is already\n * provided, but a sender <b>must<\/b> be set, either by injection or by subclass implementation, if you wish to send \n * AuthenticationEvents.  By omitting an event sender, you are implicitly directing this implementation to ignore\n * event logic.\n *\n * <p>During a subject's (a.k.a. user's) successful login attempt, a <tt>SecurityContext<\/tt> is created for that user\n * by a {@link SecurityContextFactory}.  This factory must be set as a property of this class.  Most users will\n * want to use a {@link DelegatingSecurityContextFactory} or roll their own..\n *\n * <p>Once a <tt>SecurityContext<\/tt> is created for a successfully authenticated subject (a.k.a. 'user'), it is\n * first <em>bound<\/em> to the application for convenient access before being returned to the {@link #authenticate}\n * caller.  Because binding is dependent upon runtime environment, the binding logic is delegated to an internal\n * {@link SecurityContextBinder} implementation.  The <tt>AbstractAuthenticator<\/tt> already provides a default that\n * binds the context to the local thread to cater to the majority of server-side deployments.  If operating outside of\n * a server-side environment (e.g. in an applet or standalone application), you might wish to bind the\n * <tt>SecurityContext<\/tt> in another way by setting a different implementation with the\n * {@link #setSecurityContextBinder} method.\n *\n * <p>After all class attributes have been set (event factory, security context binder, etc.), the {@link #init()}\n * method must be called, either by a framework or explicitly in code, before the Authenticator can be used.\n *\n * @since 0.1\n * @author Jeremy Haile\n * @author Les Hazlewood\n */\npublic abstract class AbstractAuthenticator implements Authenticator, Initializable {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logging logger\n     */\n    protected final transient Log log = LogFactory.getLog(getClass());\n\n    /**\n     * The factory used to create a SecurityContext after a successful authentication.\n     */\n    private SecurityContextFactory securityContextFactory = null;\n\n    /**\n     * The binder used to bind the SecurityContext so that it is accessible on subsequent\n     * requests.\n     */\n    private SecurityContextBinder securityContextBinder = new ThreadLocalSecurityContextBinder();\n\n    /**\n     * Factory used to create authentication events for publishing.\n     */\n    private AuthenticationEventFactory authcEventFactory = new SimpleAuthenticationEventFactory();\n\n    /**\n     * Sender used to publish authentication events.  The default is null, which means the events\n     * are not published.\n     */\n    private AuthenticationEventSender authcEventSender = null;\n\n    /**\n     * Whether or not to fail the authentication process when sending an event (via the sender) and the sender\n     * can't send the event (i.e. it throws an exception );  Default is <tt>false<\/tt> for system-resiliency so that\n     * a user can still login even if the event subsystem fails.\n     */\n    private boolean eventSendErrorFailsAuthentication = false;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AbstractAuthenticator(){}\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    /**\n     * Returns the <tt>SecurityContextFactory<\/tt> that this Authenticator will use to create a <tt>SecurityContext<\/tt>\n     * upon a successful authentication attempt.\n     * @return the <tt>SecurityContextFactory<\/tt> that this Authenticator will use to create a <tt>SecurityContext<\/tt>\n     * upon a successful authentication attempt.\n     *\n     * @see #setSecurityContextFactory #setSecurityContextFactory for more explanation.\n     */\n    protected SecurityContextFactory getSecurityContextFactory() {\n        return securityContextFactory;\n    }\n\n    /**\n     * Sets the <tt>SecurityContextFactory<\/tt> that this Authenticator will use to create a <tt>SecurityContext<\/tt>\n     * upon a successful authentication attempt.\n     *\n     * @param securityContextFactory the <tt>SecurityContextFactory<\/tt> that this Authenticator will use to create a\n     * <tt>SecurityContext<\/tt> upon a successful authentication attempt.\n     */\n    public void setSecurityContextFactory( SecurityContextFactory securityContextFactory ) {\n        this.securityContextFactory = securityContextFactory;\n    }\n\n    /**\n     * Returns the <tt>SecurityContextBinder<\/tt> this <tt>Authenticator<\/tt> will use to <em>bind<\/em> a subject's\n     * <tt>SecurityContext<\/tt> to the application for later use.\n     * @return the <tt>SecurityContextBinder<\/tt> this <tt>Authenticator<\/tt> will use to <em>bind<\/em> a subject's\n     * <tt>SecurityContext<\/tt> to the application for later use.\n     *\n     * @see #setSecurityContextBinder #setSecurityContextBinder for more explanation.\n     */\n    public SecurityContextBinder getSecurityContextBinder() {\n        return securityContextBinder;\n    }\n\n    /**\n     * Sets the <tt>SecurityContextBinder<\/tt> this <tt>Authenticator<\/tt> will use to <em>bind<\/em> a subject's\n     * <tt>SecurityContext<\/tt> to the application for later use.\n     *\n     * <p>The default implementation used by this class is a\n     * {@link ThreadLocalSecurityContextBinder ThreadLocalSecurityContextBinder} and probably shouldn't be overridden\n     * in server-side applications such as Web or EJB apps unless you know what you are doing.\n     *\n     * <p>This property however will probably need to be changed if in a standalone\n     * client environment, such as in an Applet or standalone application, where the <tt>SecurityContext<\/tt> might\n     * need to be accessible in a well-known location such as in a static memory variable (less desireable), or in\n     * a better managed application context (e.g. Spring or Pico - more desireable).\n     *\n     * @param securityContextBinder the <tt>SecurityContextBinder<\/tt> this <tt>Authenticator<\/tt> will use to\n     * <em>bind<\/em> a subject's <tt>SecurityContext<\/tt> to the application for later use.\n     */\n    public void setSecurityContextBinder( SecurityContextBinder securityContextBinder ) {\n        this.securityContextBinder = securityContextBinder;\n    }\n\n    /**\n     * Returns the <tt>AuthenticationEventFactory<\/tt> this <tt>Authenticator<\/tt> will use to create\n     * <tt>AuthenticationEvents<\/tt> during successful or failed authentication attempts.\n     * @return the <tt>AuthenticationEventFactory<\/tt> this <tt>Authenticator<\/tt> will use to create\n     * <tt>AuthenticationEvents<\/tt> during successful or failed authentication attempts.\n     */\n    public AuthenticationEventFactory getAuthenticationEventFactory() {\n        return authcEventFactory;\n    }\n\n    /**\n     * Sets the <tt>AuthenticationEventFactory<\/tt> this <tt>Authenticator<\/tt> will use to create\n     * <tt>AuthenticationEvents<\/tt> during successful or failed authentication attempts.\n     * @param factory the <tt>AuthenticationEventFactory<\/tt> this <tt>Authenticator<\/tt> will use to create\n     * <tt>AuthenticationEvents<\/tt> during successful or failed authentication attempts.\n     */\n    public void setAuthenticationEventFactory( AuthenticationEventFactory factory ) {\n        this.authcEventFactory = factory;\n    }\n\n    /**\n     * Returns the <tt>AuthenticationEventSender<\/tt> this Authenticator will use to send <tt>AuthenticationEvent<\/tt>s\n     * to interested parties once an event is created.\n     * @return the <tt>AuthenticationEventSender<\/tt> this Authenticator will use to send <tt>AuthenticationEvent<\/tt>s\n     * to interested parties once an event is created.\n     */\n    public AuthenticationEventSender getAuthenticationEventSender() {\n        return authcEventSender;\n    }\n\n    /**\n     * Sets the <tt>AuthenticationEventSender<\/tt> this Authenticator will use to send <tt>AuthenticationEvent<\/tt>s\n     * to interested parties once an event is created.\n     * @param authcEventSender the <tt>AuthenticationEventSender<\/tt> this Authenticator will use to send\n     * <tt>AuthenticationEvent<\/tt>s to interested parties once an event is created.\n     */\n    public void setAuthenticationEventSender( AuthenticationEventSender authcEventSender ) {\n        this.authcEventSender = authcEventSender;\n    }\n\n\n    /**\n     * Returns whether or not a problem sending an authentication event causes authentication to fail\n     * for the attempting subject.\n     *\n     * <p>JSecurity employs an event-based architecture to allow components to react when interesting things happen.\n     * When a subject's authentication attempt is successful or fails, this Authenticator implementation will use an\n     * underlying {@link #setAuthenticationEventSender AuthenticationEventSender} to send the event in either case.\n     *\n     * <p>If for some reason the event sender throws an exception during the send operation, this property determines\n     * whether or not the entire authentication attempt will fail.\n     *\n     * <p>The default is <b>false<\/b> for resiliency's sake: an event sending problem does not fail the authentication.\n     *\n     * @return whether or not a problem sending an authentication event causes the entire authentication process to fail\n     * for the attempting subject (user).\n     */\n    public boolean isEventSendErrorFailsAuthentication() {\n        return eventSendErrorFailsAuthentication;\n    }\n\n    public void setEventSendErrorFailsAuthentication(boolean eventSendErrorFailsAuthentication) {\n        this.eventSendErrorFailsAuthentication = eventSendErrorFailsAuthentication;\n    }\n\n    /*-------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Public initializer that should be called after all class properties have been set, but before the instance\n     * is used to process authentications.\n     */\n    public void init() {\n        if( getSecurityContextFactory() == null ) {\n            String msg = \"SecurityContextFactory property must be set.\";\n            throw new IllegalStateException( msg );\n        }\n        onInit();\n    }\n        \n    /**\n     * Subclass template hook to allow subclasses additional initialization behavior without having to override the\n     * {@link #init init()} method.\n     */\n    protected void onInit(){}\n\n    /**\n     * Creates an <tt>AuthenticationEvent<\/tt> in the event of a failed authentication attempt, based on the given\n     * authentication token and exception that occurred during the attempt.\n     *\n     * <p>The default implementation merely delegates creation to the internal {@link AuthenticationEventFactory}\n     * property.\n     *\n     * @param token the authentication token reprenting the subject (user)'s authentication attempt.\n     * @param ae the <tt>AuthenticationException<\/tt> that occurred as a result of the attempt.\n     * @return an event that represents the failed attempt.\n     */\n    protected AuthenticationEvent createFailureEvent( AuthenticationToken token, AuthenticationException ae ) {\n        AuthenticationEventFactory factory = getAuthenticationEventFactory();\n        return factory.createFailureEvent( token, ae );\n    }\n\n    /**\n     * Creates an <tt>AuthenticationEvent<\/tt> in the event of a successful authentication attempt, based on the given\n     * authentication token and <tt>AuthenticationInfo<\/tt> that was created as a result of the successful attempt.\n     *\n     * <p>The default implementation merely delegates creation to the internal {@link AuthenticationEventFactory}\n     * property.\n     *\n     * @param token the authentication token reprenting the subject (user)'s authentication attempt.\n     * @param info the <tt>AuthenticationInfo<\/tt> returned by {@link #doAuthenticate} after the successful attempt.\n     * @return an event that represents the successful attempt.\n     */\n    protected AuthenticationEvent createSuccessEvent( AuthenticationToken token, AuthenticationInfo info ) {\n        AuthenticationEventFactory factory = getAuthenticationEventFactory();\n        return factory.createSuccessEvent( token, info );\n    }\n\n    /**\n     * Utility method that first creates a failure event based on the given token and exception and then actually sends\n     * the event.\n     *\n     * <p>The default implementation does not attempt to create an event if the {@link #setAuthenticationEventSender}\n     * property has not been set - the logic is that event creation overhead will not be incurred if it would never\n     * be sent.\n     *\n     * @param token the authentication token reprenting the subject (user)'s authentication attempt.\n     * @param ae the <tt>AuthenticationException<\/tt> that occurred as a result of the attempt.\n     */\n    protected void sendFailureEvent( AuthenticationToken token, AuthenticationException ae ) {\n        AuthenticationEventSender sender = getAuthenticationEventSender();\n        //only incur event creation overhead if the event can actually be sent:\n        if ( sender != null ) {\n            AuthenticationEvent event = createFailureEvent( token, ae );\n            if ( event != null ) {\n                send( event );\n            } else {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"No AuthenticationEvent instance returned from \" +\n                               \"'createFailureEvent' method call.  No failed authentication \" +\n                               \"event will be sent.\" );\n                }\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No AuthenticationEventSender configured.  No failure event will \" +\n                           \"be sent\" );\n            }\n        }\n\n    }\n\n    /**\n     * Utility method that first creates a success event based on the given token and info and then actually sends\n     * the event.\n     *\n     * <p>The default implementation does not attempt to create an event if the {@link #setAuthenticationEventSender}\n     * property has not been set - the logic is that event creation overhead will not be incurred if it would never be\n     * sent.\n     *\n     * @param token the authentication token reprenting the subject (user)'s authentication attempt.\n     * @param info the <tt>AuthenticationInfo<\/tt> returned by {@link #doAuthenticate} after the successful attempt.\n     */\n    protected void sendSuccessEvent( AuthenticationToken token, AuthenticationInfo info ) {\n        AuthenticationEventSender sender = getAuthenticationEventSender();\n        //only incur event creation overhead if the event can actually be sent:\n        if ( sender != null ) {\n            AuthenticationEvent event = createSuccessEvent( token, info );\n            if ( event != null ) {\n                try {\n                    send( event );\n                } catch (Throwable t) {\n                    if ( isEventSendErrorFailsAuthentication() ) {\n                        String msg = \"Unable to send event [\" + event + \"].  This authenticator is configured to \" +\n                            \"interpret an event sending error as a failure during the authentication process \" +\n                            \"via the setEventSendErrorFailsAuthentication property.  Authentication failed.\";\n                        throw new AuthenticationException( msg, t );\n                    } else {\n                        if ( log.isWarnEnabled() ) {\n                            String msg = \"Unable to send AuthenticationEvent [\" + event + \"].  Ignoring send error \" +\n                                \"(for system resiliency) and continuing with the authentication process.  Please \" +\n                                \"check your sender configuration and/or implementation.\";\n                            log.warn( msg, t );\n                        }\n                    }\n                }\n            } else {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"No AuthenticationEvent instance returned from \" +\n                            \"'createSuccessEvent' method call.  No successful authentication \" +\n                            \"event will be sent.\" );\n                }\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No AuthenticationEventSender configured.  No success event will \" +\n                           \"be sent\" );\n            }\n        }\n    }\n\n    /**\n     * Utility method that will send any type of <tt>AuthenticationEvent<\/tt> instance.\n     *\n     * <p>The default implementation merely delegates to the internal {@link AuthenticationEventSender} property if\n     * it exists.\n     *\n     * @param event the <tt>AuthenticationEvent<\/tt> to send to interested parties.\n     * \n     * @throws IllegalArgumentException if the method argument is null\n     */\n    protected void send( AuthenticationEvent event ) throws IllegalArgumentException {\n        if ( event == null ) {\n            throw new IllegalArgumentException( \"AuthenticationEvent argument cannot be null\" );\n        }\n        AuthenticationEventSender sender = getAuthenticationEventSender();\n        if ( sender != null ) {\n            sender.send( event );\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No AuthenticationEventSender configured.  Event [\" + event + \"] will not be sent.\" );\n            }\n        }\n    }\n\n    /**\n     * Creates a <tt>SecurityContext<\/tt> instance for the user represented by the given method argument.\n     *\n     * <p>The default implementation delegates to the internal {@link SecurityContextFactory} property.\n     *\n     * @param info the <tt>AuthenticationInfo<\/tt> of a newly authenticated subject/user.\n     * @return the <tt>SecurityContext<\/tt> that represents the authorization and session data for the newly\n     * authenticated subject/user.\n     */\n    protected SecurityContext createSecurityContext( AuthenticationInfo info ) {\n        SecurityContextFactory factory = getSecurityContextFactory();\n        if( factory == null ) {\n            throw new IllegalStateException(\n                    \"No SecurityContextFactory class attribute has been set, so authentication cannot \" +\n                    \"be completed.  Make sure the init() method is being called on this \" +\n                    \"Authenticator before it is used.\" );\n        }\n\n        return factory.createSecurityContext( info );\n    }\n\n    /**\n     * Binds a <tt>SecurityContext<\/tt> instance created after authentication to the application for later use.\n     *\n     * <p>The default implementation merely delegates to the internal {@link SecurityContextBinder} property.\n     *\n     * @param secCtx the <tt>SecurityContext<\/tt> instance created after authentication to be bound to the application\n     * for later use.\n     */\n    protected void bind( SecurityContext secCtx ) {\n        getSecurityContextBinder().bindSecurityContext( secCtx );\n    }\n\n    private void assertCreation( SecurityContext secCtx ) throws IllegalStateException {\n        if ( secCtx == null ) {\n            String msg = \"Programming or configuration error - No SecurityContext was created after successful \" +\n                    \"authentication.  Verify that you have either configured the \" + getClass().getName() +\n                    \" instance with a proper SecurityContextFactory or SecurityManager (easier) or \" +\n                    \"that you have overridden the \" + AbstractAuthenticator.class.getName() +\n                    \".createSecurityContext( AuthenticationInfo info ) method.\";\n            throw new IllegalStateException( msg );\n        }\n    }\n\n    /**\n     * Implementation of the {@link Authenticator} interface that functions in the following manner:\n     *\n     * <ol>\n     * <li>Calls template {@link #doAuthenticate doAuthenticate} method for subclass execution of the actual\n     * authentication behavior.<\/li>\n     * <li>If an <tt>AuthenticationException<\/tt> is thrown during <tt>doAuthenticate<\/tt>, create and send a\n     * failure <tt>AuthenticationEvent<\/tt> that represents this failure, and then propogate this exception\n     * for the caller to handle.<\/li>\n     * <li>If no exception is thrown (indicating a successful login), perform the following:\n     *     <ol>\n     *         <li>{@link #createSecurityContext Create a <tt>SecurityContext<\/tt>} instance that represents the\n     *             <tt>AuthenticationInfo<\/tt> returned by <tt>doAuthenticate<\/tt><\/li>\n     *         <li>{@link #bind Bind this newly created SecurityContext} to the application such that it can be\n     *             referenced by the application later.<\/li>\n     *         <li>Create and send a success <tt>AuthenticationEvent<\/tt> noting the successful authentication.<\/li>\n     *         <li>Return the newly created <tt>SecurityContext<\/tt> to the caller should they wish to use it\n     *             immediately.<\/li>\n     *     <\/ol>\n     * <\/li>\n     * <\/ol>\n     * @param token the submitted token representing the subject's (user's) login principals and credentials.\n     * @return the SecurityContext referencing the authenticated user's access rights.\n     *\n     * @throws AuthenticationException if there is any problem during the authentication process - see the\n     * interface's JavaDoc for a more detailed explanation.\n     */\n    public final SecurityContext authenticate( AuthenticationToken token )\n            throws AuthenticationException {\n\n        if ( token == null ) {\n            throw new IllegalArgumentException( \"Method argumet (authentication token) cannot be null.\" );\n        }\n\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Authentication attempt received for token [\" + token + \"]\" );\n        }\n\n        AuthenticationInfo info;\n        try {\n            info = doAuthenticate( token );\n            if ( info == null ) {\n                String msg = \"Authentication token [\" + token + \"] could not be processed for authentication by this \" +\n                        \"Authenticator instance.  Please check that it is configured correctly.\";\n                throw new AuthenticationException( msg );\n            }\n        } catch ( Throwable t ) {\n            AuthenticationException ae = null;\n            if ( t instanceof AuthenticationException ) {\n                ae = (AuthenticationException)t;\n            }\n            if ( ae == null ) {\n                //Exception thrown was not an expected AuthenticationException.  Therefore it is probably a little more\n                //severe or unexpected.  So, wrap in an AuthenticationException, log to warn, and propagate:\n                String msg = \"Authentication failed for token submission [\" + token + \"].  Possible unexpected \" +\n                        \"error? (Typical or expected login exceptions should extend from AuthenticationException).\";\n                ae = new AuthenticationException( msg, t );\n                if ( log.isWarnEnabled() ) {\n                    log.warn( msg, t );\n                }\n            }\n            try {\n                sendFailureEvent( token, ae );\n            } catch (Throwable t2) {\n                String msg = \"Unable to send event for failed authentication attempt.  Please check the \" +\n                        \"authenticationEventSender implementation.  Logging sending exception and propagating \" +\n                        \"original AuthenticationException instead...\";\n                if ( log.isWarnEnabled() ) {\n                    log.warn( msg, t2 );\n                }\n            }\n\n            throw ae;\n        }\n\n        if ( log.isInfoEnabled() ) {\n            log.info( \"Authentication successful for token [\" + token + \"].  \" +\n                      \"Returned authentication info: [\" + info + \"]\" );\n        }\n\n        SecurityContext secCtx = createSecurityContext( info );\n\n        assertCreation( secCtx );\n\n        bind( secCtx );\n\n        sendSuccessEvent( token, info );\n\n        return secCtx;\n    }\n\n    /**\n     * Template design pattern hook for subclasses to implement specific authentication behavior.\n     *\n     * <p>Common behavior for most all common authentication attempts is encapsulated in the \n     * {@link #authenticate} method and that method invokes this one for custom behavior.\n     *\n     * <p><b>N.B.<\/b> Subclasses <em>should<\/em> throw some kind of\n     * <tt>AuthenticationException<\/tt> if there is a problem during\n     * authentication instead of returning <tt>null<\/tt>.  A <tt>null<\/tt> return value indicates\n     * a configuration or programming error, since <tt>AuthenticationException<\/tt>s should\n     * indicate any expected problem (such as an unknown account or username, or invalid password, etc).\n     *\n     * @param token the authentication token encapsulating the user's login information.\n     * @return an <tt>AuthenticationInfo<\/tt> object encapsulating the user's account information\n     * important to JSecurity.  <tt>null<\/tt> should <em>not<\/em> be returned - throw a proper AuthenticationException\n     * instead (like {@link org.jsecurity.authc.UnknownAccountException} if the account can't be found, etc).\n     * @throws AuthenticationException if there is a problem logging in the user.\n     */\n    protected abstract AuthenticationInfo doAuthenticate( AuthenticationToken token )\n            throws AuthenticationException;\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile, Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.authc.support;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.Authenticator;\nimport org.jsecurity.authc.event.AuthenticationEvent;\nimport org.jsecurity.authc.event.AuthenticationEventFactory;\nimport org.jsecurity.authc.event.AuthenticationEventSender;\nimport org.jsecurity.authc.event.support.SimpleAuthenticationEventFactory;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.bind.SecurityContextBinder;\nimport org.jsecurity.context.bind.support.ThreadLocalSecurityContextBinder;\nimport org.jsecurity.context.factory.SecurityContextFactory;\nimport org.jsecurity.context.factory.support.DelegatingSecurityContextFactory;\nimport org.jsecurity.util.Initializable;\n\n/**\n * Superclass for almost all {@link Authenticator} implementations that performs the common work around authentication\n * attempts.\n *\n * <p>This class delegates the actual authentication attempt to subclasses but will send events based on a\n * successful or failed attempt, create a {@link SecurityContext SecurityContext} in the event of a successful attmept,\n * and bind this <tt>SecurityContext<\/tt> to the application for further use.\n *\n * <p>In most cases, the only thing a subclass needs to do (via its {@link #doAuthenticate} implementation)\n * is perform the actual principal/credential verification process for the submitted <tt>AuthenticationToken<\/tt>.\n *\n * <p>This implementation employs an event-based architecture so other components may react to both failed and\n * successful authentication attempts.  Failure or success events are triggered based on the\n * subclass's {@link #doAuthenticate} implementation throwing an exception or not, respectively (i.e. a failure event\n * will be created and sent if the authentication attempt fails, and a success event will be created and sent if the\n * authentication event is successful.  The actual events\n * themselves are constructed via an {@link AuthenticationEventFactory} and sent to interested components via a\n * {@link AuthenticationEventSender}.\n * \n * <p>Both the event factory and the event sender may be set as properties of this class\n * (instead of overriding this class for event creation and sending).  A simple default event factory is already\n * provided, but a sender <b>must<\/b> be set, either by injection or by subclass implementation, if you wish to send \n * AuthenticationEvents.  By omitting an event sender, you are implicitly directing this implementation to ignore\n * event logic.\n *\n * <p>During a subject's (a.k.a. user's) successful login attempt, a <tt>SecurityContext<\/tt> is created for that user\n * by a {@link SecurityContextFactory}.  This factory may also be set as a property of this class if desired, but it \n * is generally recommended that a SecurityManager is set instead, and the factory be created automatically\n * based on the manager - see the {@link #setSecurityManager} javadoc for more details).\n *\n * <p>Once a <tt>SecurityContext<\/tt> is created for a successfully authenticated subject (a.k.a. 'user'), it is\n * first <em>bound<\/em> to the application for convenient access before being returned to the {@link #authenticate}\n * caller.  Because binding is dependent upon runtime environment, the binding logic is delegated to an internal\n * {@link SecurityContextBinder} implementation.  The <tt>AbstractAuthenticator<\/tt> already provides a default that\n * binds the context to the local thread to cater to the majority of server-side deployments.  If operating outside of\n * a server-side environment (e.g. in an applet or standalone application), you might wish to bind the\n * <tt>SecurityContext<\/tt> in another way by setting a different implementation with the\n * {@link #setSecurityContextBinder} method.\n *\n * <p>After all class attributes have been set (event factory, security context binder, etc.), the {@link #init()}\n * method must be called, either by a framework or explicitly in code, before the Authenticator can be used.\n *\n * @since 0.1\n * @author Jeremy Haile\n * @author Les Hazlewood\n */\npublic abstract class AbstractAuthenticator implements Authenticator, Initializable {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logging logger\n     */\n    protected final transient Log log = LogFactory.getLog(getClass());\n\n    /**\n     * The factory used to create a SecurityContext after a successful authentication.\n     */\n    private SecurityContextFactory securityContextFactory = null;\n\n    /**\n     * The binder used to bind the SecurityContext so that it is accessible on subsequent\n     * requests.\n     */\n    private SecurityContextBinder securityContextBinder = new ThreadLocalSecurityContextBinder();\n\n    /**\n     * Factory used to create authentication events for publishing.\n     */\n    private AuthenticationEventFactory authcEventFactory = new SimpleAuthenticationEventFactory();\n\n    /**\n     * Sender used to publish authentication events.  The default is null, which means the events\n     * are not published.\n     */\n    private AuthenticationEventSender authcEventSender = null;\n\n    /**\n     * Used to initialize the default SecurityContextFactory.\n     */\n    private SecurityManager securityManager = null;\n\n    /**\n     * Whether or not to fail the authentication process when sending an event (via the sender) and the sender\n     * can't send the event (i.e. it throws an exception );  Default is false for system-resiliency so that a user\n     * can still login even if the event subsystem fails.\n     */\n    private boolean eventSendErrorFailsAuthentication = false;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AbstractAuthenticator(){}\n\n    public AbstractAuthenticator( SecurityManager securityManager ) {\n        this.securityManager = securityManager;\n        init();\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    /**\n     * Returns the <tt>SecurityContextFactory<\/tt> that this Authenticator will use to create a <tt>SecurityContext<\/tt>\n     * upon a successful authentication attempt.\n     * @return the <tt>SecurityContextFactory<\/tt> that this Authenticator will use to create a <tt>SecurityContext<\/tt>\n     * upon a successful authentication attempt.\n     *\n     * @see #setSecurityContextFactory #setSecurityContextFactory for more explanation.\n     */\n    protected SecurityContextFactory getSecurityContextFactory() {\n        return securityContextFactory;\n    }\n\n\n    /**\n     * Sets the <tt>SecurityContextFactory<\/tt> that this Authenticator will use to create a <tt>SecurityContext<\/tt>\n     * upon a successful authentication attempt.\n     *\n     * <p>It is not usually recommended to override this property, but instead set the\n     * {@link #setSecurityManager securityManager} property.  When a <tt>securityManager<\/tt> property is set, this\n     * class will use it to construct an internal\n     * {@link DelegatingSecurityContextFactory DelegatingSecurityContextFactory}, which uses the securityManager in a \n     * more efficient manner.\n     *\n     * @param securityContextFactory the <tt>SecurityContextFactory<\/tt> that this Authenticator will use to create a\n     * <tt>SecurityContext<\/tt> upon a successful authentication attempt.\n     */\n    public void setSecurityContextFactory( SecurityContextFactory securityContextFactory ) {\n        this.securityContextFactory = securityContextFactory;\n    }\n\n\n    /**\n     * Returns the <tt>SecurityContextBinder<\/tt> this <tt>Authenticator<\/tt> will use to <em>bind<\/em> a subject's\n     * <tt>SecurityContext<\/tt> to the application for later use.\n     * @return the <tt>SecurityContextBinder<\/tt> this <tt>Authenticator<\/tt> will use to <em>bind<\/em> a subject's\n     * <tt>SecurityContext<\/tt> to the application for later use.\n     *\n     * @see #setSecurityContextBinder #setSecurityContextBinder for more explanation.\n     */\n    public SecurityContextBinder getSecurityContextBinder() {\n        return securityContextBinder;\n    }\n\n    /**\n     * Sets the <tt>SecurityContextBinder<\/tt> this <tt>Authenticator<\/tt> will use to <em>bind<\/em> a subject's\n     * <tt>SecurityContext<\/tt> to the application for later use.\n     *\n     * <p>The default implementation used by this class is a\n     * {@link ThreadLocalSecurityContextBinder ThreadLocalSecurityContextBinder} and probably shouldn't be overridden\n     * in server-side applications such as Web or EJB apps unless you know what you are doing.\n     *\n     * <p>This property probably <b><em>will<\/em><\/b> however probably need to be changed if in a standalone\n     * client environment, such as in an Applet or standalone application, where the <tt>SecurityContext<\/tt> will\n     * need to be accessible in a well-known location such as in a static memory variable (less desireable), or in\n     * a better managed application context (e.g. Spring or Pico - more desireable).\n     *\n     * @param securityContextBinder the <tt>SecurityContextBinder<\/tt> this <tt>Authenticator<\/tt> will use to\n     * <em>bind<\/em> a subject's <tt>SecurityContext<\/tt> to the application for later use.\n     */\n    public void setSecurityContextBinder( SecurityContextBinder securityContextBinder ) {\n        this.securityContextBinder = securityContextBinder;\n    }\n\n    /**\n     * Returns the <tt>AuthenticationEventFactory<\/tt> this <tt>Authenticator<\/tt> will use to create\n     * <tt>AuthenticationEvents<\/tt> during successful or failed authentication attempts.\n     * @return the <tt>AuthenticationEventFactory<\/tt> this <tt>Authenticator<\/tt> will use to create\n     * <tt>AuthenticationEvents<\/tt> during successful or failed authentication attempts.\n     */\n    public AuthenticationEventFactory getAuthenticationEventFactory() {\n        return authcEventFactory;\n    }\n\n    /**\n     * Sets the <tt>AuthenticationEventFactory<\/tt> this <tt>Authenticator<\/tt> will use to create\n     * <tt>AuthenticationEvents<\/tt> during successful or failed authentication attempts.\n     * @param factory the <tt>AuthenticationEventFactory<\/tt> this <tt>Authenticator<\/tt> will use to create\n     * <tt>AuthenticationEvents<\/tt> during successful or failed authentication attempts.\n     */\n    public void setAuthenticationEventFactory( AuthenticationEventFactory factory ) {\n        this.authcEventFactory = factory;\n    }\n\n    /**\n     * Returns the <tt>AuthenticationEventSender<\/tt> this Authenticator will use to send <tt>AuthenticationEvent<\/tt>s\n     * to interested parties once an event is created.\n     * @return the <tt>AuthenticationEventSender<\/tt> this Authenticator will use to send <tt>AuthenticationEvent<\/tt>s\n     * to interested parties once an event is created.\n     */\n    public AuthenticationEventSender getAuthenticationEventSender() {\n        return authcEventSender;\n    }\n\n    /**\n     * Sets the <tt>AuthenticationEventSender<\/tt> this Authenticator will use to send <tt>AuthenticationEvent<\/tt>s\n     * to interested parties once an event is created.\n     * @param authcEventSender the <tt>AuthenticationEventSender<\/tt> this Authenticator will use to send\n     * <tt>AuthenticationEvent<\/tt>s to interested parties once an event is created.\n     */\n    public void setAuthenticationEventSender( AuthenticationEventSender authcEventSender ) {\n        this.authcEventSender = authcEventSender;\n    }\n\n    /**\n     * Sets the securityManager that will be used to construct and set this class's default\n     * <tt>SecurityContextFactory<\/tt> property if one is not explicitly set via the\n     * {@link #setSecurityContextFactory} method.\n     *\n     * <p>It <b>IS<\/b> recommended that most configurations set this <tt>securityManager<\/tt> property and\n     * <b><em>NOT<\/em><\/b> explicitly set the <tt>SecurityContextFactory<\/tt> property unless you know what you're\n     * doing and/or need special behavior.\n     * \n     * @param securityManager the <tt>SecurityManager<\/tt> that will be used to construct a <tt>SecurityContextFactory<\/tt>\n     * upon initialization.\n     */\n    public void setSecurityManager(SecurityManager securityManager) {\n        this.securityManager = securityManager;\n    }\n\n\n    /**\n     * Returns whether or not a problem sending an authentication event causes authentication to fail\n     * for the attempting subject.\n     *\n     * <p>JSecurity employs an event-based architecture to allow components to react when interesting things happen.\n     * When a subject's authentication attempt is successful or fails, this Authenticator implementation will use an\n     * underlying {@link #setAuthenticationEventSender AuthenticationEventSender} to send the event in either case.\n     *\n     * <p>If for some reason the event sender throws an exception during the send operation, this property determines\n     * whether or not the entire authentication attempt will fail.\n     *\n     * <p>The default is <b>false<\/b> for resiliency's sake: an event sending problem does not fail the authentication.\n     *\n     * @return whether or not a problem sending an authentication event causes the entire authentication process to fail\n     * for the attempting subject (user).\n     */\n    public boolean isEventSendErrorFailsAuthentication() {\n        return eventSendErrorFailsAuthentication;\n    }\n\n    public void setEventSendErrorFailsAuthentication(boolean eventSendErrorFailsAuthentication) {\n        this.eventSendErrorFailsAuthentication = eventSendErrorFailsAuthentication;\n    }\n\n    /*-------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Public initializer that should be called after all class properties have been set, but before the instance\n     * is used to process authentications.\n     */\n    public void init() {\n        if( getSecurityContextFactory() == null ) {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No securityContextFactory set.  Attempting to create the default SecurityContextFactory \" +\n                        \"based on the SecurityManager attribute...\" );\n            }\n            if( securityManager == null ) {\n                throw new IllegalStateException( \"If the SecurityContextFactory class attribute is not set, a \" +\n                        \"SecurityManager must be provided so that the default factory can be created.\" );\n            }\n            setSecurityContextFactory( new DelegatingSecurityContextFactory( securityManager ) );\n            if ( log.isInfoEnabled() ) {\n                log.info( \"Created SecurityContextFactory based on provided SecurityManager class attribute.\" );\n            }\n        }\n        onInit();\n    }\n        \n    /**\n     * Subclass template hook to allow subclasses additional initialization behavior without having to override the\n     * {@link #init init()} method.\n     */\n    protected void onInit(){}\n\n    /**\n     * Creates an <tt>AuthenticationEvent<\/tt> in the event of a failed authentication attempt, based on the given\n     * authentication token and exception that occurred during the attempt.\n     *\n     * <p>The default implementation merely delegates creation to the internal {@link AuthenticationEventFactory}\n     * property.\n     *\n     * @param token the authentication token reprenting the subject (user)'s authentication attempt.\n     * @param ae the <tt>AuthenticationException<\/tt> that occurred as a result of the attempt.\n     * @return an event that represents the failed attempt.\n     */\n    protected AuthenticationEvent createFailureEvent( AuthenticationToken token, AuthenticationException ae ) {\n        AuthenticationEventFactory factory = getAuthenticationEventFactory();\n        return factory.createFailureEvent( token, ae );\n    }\n\n    /**\n     * Creates an <tt>AuthenticationEvent<\/tt> in the event of a successful authentication attempt, based on the given\n     * authentication token and <tt>AuthenticationInfo<\/tt> that was created as a result of the successful attempt.\n     *\n     * <p>The default implementation merely delegates creation to the internal {@link AuthenticationEventFactory}\n     * property.\n     *\n     * @param token the authentication token reprenting the subject (user)'s authentication attempt.\n     * @param info the <tt>AuthenticationInfo<\/tt> returned by {@link #doAuthenticate} after the successful attempt.\n     * @return an event that represents the successful attempt.\n     */\n    protected AuthenticationEvent createSuccessEvent( AuthenticationToken token, AuthenticationInfo info ) {\n        AuthenticationEventFactory factory = getAuthenticationEventFactory();\n        return factory.createSuccessEvent( token, info );\n    }\n\n    /**\n     * Utility method that first creates a failure event based on the given token and exception and then actually sends\n     * the event.\n     *\n     * <p>The default implementation does not attempt to create an event if the {@link #setAuthenticationEventSender}\n     * property has not been set - the logic is that event creation overhead will not be incurred if it would never\n     * be sent.\n     *\n     * @param token the authentication token reprenting the subject (user)'s authentication attempt.\n     * @param ae the <tt>AuthenticationException<\/tt> that occurred as a result of the attempt.\n     */\n    protected void sendFailureEvent( AuthenticationToken token, AuthenticationException ae ) {\n        AuthenticationEventSender sender = getAuthenticationEventSender();\n        //only incur event creation overhead if the event can actually be sent:\n        if ( sender != null ) {\n            AuthenticationEvent event = createFailureEvent( token, ae );\n            if ( event != null ) {\n                send( event );\n            } else {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"No AuthenticationEvent instance returned from \" +\n                               \"'createFailureEvent' method call.  No failed authentication \" +\n                               \"event will be sent.\" );\n                }\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No AuthenticationEventSender configured.  No failure event will \" +\n                           \"be sent\" );\n            }\n        }\n\n    }\n\n    /**\n     * Utility method that first creates a success event based on the given token and info and then actually sends\n     * the event.\n     *\n     * <p>The default implementation does not attempt to create an event if the {@link #setAuthenticationEventSender}\n     * property has not been set - the logic is that event creation overhead will not be incurred if it would never be\n     * sent.\n     *\n     * @param token the authentication token reprenting the subject (user)'s authentication attempt.\n     * @param info the <tt>AuthenticationInfo<\/tt> returned by {@link #doAuthenticate} after the successful attempt.\n     */\n    protected void sendSuccessEvent( AuthenticationToken token, AuthenticationInfo info ) {\n        AuthenticationEventSender sender = getAuthenticationEventSender();\n        //only incur event creation overhead if the event can actually be sent:\n        if ( sender != null ) {\n            AuthenticationEvent event = createSuccessEvent( token, info );\n            if ( event != null ) {\n                try {\n                    send( event );\n                } catch (Throwable t) {\n                    if ( isEventSendErrorFailsAuthentication() ) {\n                        String msg = \"Unable to send event [\" + event + \"].  This authenticator is configured to \" +\n                            \"interpret an event sending error as a failure during the authentication process \" +\n                            \"via the setEventSendErrorFailsAuthentication property.  Authentication failed.\";\n                        throw new AuthenticationException( msg, t );\n                    } else {\n                        if ( log.isWarnEnabled() ) {\n                            String msg = \"Unable to send AuthenticationEvent [\" + event + \"].  Ignoring send error \" +\n                                \"(for system resiliency) and continuing with the authentication process.  Please \" +\n                                \"check your sender configuration and/or implementation.\";\n                            log.warn( msg, t );\n                        }\n                    }\n                }\n            } else {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"No AuthenticationEvent instance returned from \" +\n                            \"'createSuccessEvent' method call.  No successful authentication \" +\n                            \"event will be sent.\" );\n                }\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No AuthenticationEventSender configured.  No success event will \" +\n                           \"be sent\" );\n            }\n        }\n    }\n\n    /**\n     * Utility method that will send any type of <tt>AuthenticationEvent<\/tt> instance.\n     *\n     * <p>The default implementation merely delegates to the internal {@link AuthenticationEventSender} property if\n     * it exists.\n     *\n     * @param event the <tt>AuthenticationEvent<\/tt> to send to interested parties.\n     * \n     * @throws IllegalArgumentException if the method argument is null\n     */\n    protected void send( AuthenticationEvent event ) throws IllegalArgumentException {\n        if ( event == null ) {\n            throw new IllegalArgumentException( \"AuthenticationEvent argument cannot be null\" );\n        }\n        AuthenticationEventSender sender = getAuthenticationEventSender();\n        if ( sender != null ) {\n            sender.send( event );\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No AuthenticationEventSender configured.  Event [\" + event + \"] will not be sent.\" );\n            }\n        }\n    }\n\n    /**\n     * Creates a <tt>SecurityContext<\/tt> instance for the user represented by the given method argument.\n     *\n     * <p>The default implementation delegates to the internal {@link SecurityContextFactory} property.\n     *\n     * @param info the <tt>AuthenticationInfo<\/tt> of a newly authenticated subject/user.\n     * @return the <tt>SecurityContext<\/tt> that represents the authorization and session data for the newly\n     * authenticated subject/user.\n     */\n    protected SecurityContext createSecurityContext( AuthenticationInfo info ) {\n        SecurityContextFactory factory = getSecurityContextFactory();\n        if( factory == null ) {\n            throw new IllegalStateException(\n                    \"No SecurityContextFactory class attribute has been set, so authentication cannot \" +\n                    \"be completed.  Make sure the init() method is being called on this \" +\n                    \"Authenticator before it is used.\" );\n        }\n\n        return factory.createSecurityContext( info );\n    }\n\n    /**\n     * Binds a <tt>SecurityContext<\/tt> instance created after authentication to the application for later use.\n     *\n     * <p>The default implementation merely delegates to the internal {@link SecurityContextBinder} property.\n     *\n     * @param secCtx the <tt>SecurityContext<\/tt> instance created after authentication to be bound to the application\n     * for later use.\n     */\n    protected void bind( SecurityContext secCtx ) {\n        getSecurityContextBinder().bindSecurityContext( secCtx );\n    }\n\n    private void assertCreation( SecurityContext secCtx ) throws IllegalStateException {\n        if ( secCtx == null ) {\n            String msg = \"Programming or configuration error - No SecurityContext was created after successful \" +\n                    \"authentication.  Verify that you have either configured the \" + getClass().getName() +\n                    \" instance with a proper SecurityContextFactory or SecurityManager (easier) or \" +\n                    \"that you have overridden the \" + AbstractAuthenticator.class.getName() +\n                    \".createSecurityContext( AuthenticationInfo info ) method.\";\n            throw new IllegalStateException( msg );\n        }\n    }\n\n    /**\n     * Implementation of the {@link Authenticator} interface that functions in the following manner:\n     *\n     * <ol>\n     * <li>Calls template {@link #doAuthenticate doAuthenticate} method for subclass execution of the actual\n     * authentication behavior.<\/li>\n     * <li>If an <tt>AuthenticationException<\/tt> is thrown during <tt>doAuthenticate<\/tt>, create and send a\n     * failure <tt>AuthenticationEvent<\/tt> that represents this failure, and then propogate this exception\n     * for the caller to handle.<\/li>\n     * <li>If no exception is thrown (indicating a successful login), perform the following:\n     *     <ol>\n     *         <li>{@link #createSecurityContext Create a <tt>SecurityContext<\/tt>} instance that represents the\n     *             <tt>AuthenticationInfo<\/tt> returned by <tt>doAuthenticate<\/tt><\/li>\n     *         <li>{@link #bind Bind this newly created SecurityContext} to the application such that it can be\n     *             referenced by the application later.<\/li>\n     *         <li>Create and send a success <tt>AuthenticationEvent<\/tt> noting the successful authentication.<\/li>\n     *         <li>Return the newly created <tt>SecurityContext<\/tt> to the caller should they wish to use it\n     *             immediately.<\/li>\n     *     <\/ol>\n     * <\/li>\n     * <\/ol>\n     * @param token the submitted token representing the subject's (user's) login principals and credentials.\n     * @return the SecurityContext referencing the authenticated user's access rights.\n     *\n     * @throws AuthenticationException if there is any problem during the authentication process - see the\n     * interface's JavaDoc for a more detailed explanation.\n     */\n    public final SecurityContext authenticate( AuthenticationToken token )\n            throws AuthenticationException {\n\n        if ( token == null ) {\n            throw new IllegalArgumentException( \"Method argumet (authentication token) cannot be null.\" );\n        }\n\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Authentication attempt received for token [\" + token + \"]\" );\n        }\n\n        AuthenticationInfo info;\n        try {\n            info = doAuthenticate( token );\n            if ( info == null ) {\n                String msg = \"Authentication token [\" + token + \"] could not be processed for authentication by this \" +\n                        \"Authenticator instance.  Please check that it is configured correctly.\";\n                throw new AuthenticationException( msg );\n            }\n        } catch ( Throwable t ) {\n            AuthenticationException ae = null;\n            if ( t instanceof AuthenticationException ) {\n                ae = (AuthenticationException)t;\n            }\n            if ( ae == null ) {\n                //Exception thrown was not an expected AuthenticationException.  Therefore it is probably a little more\n                //severe or unexpected.  So, wrap in an AuthenticationException, log to warn, and propagate:\n                String msg = \"Authentication failed for token submission [\" + token + \"].  Possible unexpected \" +\n                        \"error? (Typical or expected login exceptions should extend from AuthenticationException).\";\n                ae = new AuthenticationException( msg, t );\n                if ( log.isWarnEnabled() ) {\n                    log.warn( msg, t );\n                }\n            }\n            try {\n                sendFailureEvent( token, ae );\n            } catch (Throwable t2) {\n                String msg = \"Unable to send event for failed authentication attempt.  Please check the \" +\n                        \"authenticationEventSender implementation.  Logging sending exception and propagating \" +\n                        \"original AuthenticationException instead...\";\n                if ( log.isWarnEnabled() ) {\n                    log.warn( msg, t2 );\n                }\n            }\n\n            throw ae;\n        }\n\n        if ( log.isInfoEnabled() ) {\n            log.info( \"Authentication successful for token [\" + token + \"].  \" +\n                      \"Returned authentication info: [\" + info + \"]\" );\n        }\n\n        SecurityContext secCtx = createSecurityContext( info );\n\n        assertCreation( secCtx );\n\n        bind( secCtx );\n\n        sendSuccessEvent( token, info );\n\n        return secCtx;\n    }\n\n    /**\n     * Template design pattern hook for subclasses to implement specific authentication behavior.\n     *\n     * <p>Common behavior for most all common authentication attempts is encapsulated in the \n     * {@link #authenticate} method and that method invokes this one for custom behavior.\n     *\n     * <p><b>N.B.<\/b> Subclasses <em>should<\/em> throw some kind of\n     * <tt>AuthenticationException<\/tt> if there is a problem during\n     * authentication instead of returning <tt>null<\/tt>.  A <tt>null<\/tt> return value indicates\n     * a configuration or programming error, since <tt>AuthenticationException<\/tt>s should\n     * indicate any expected problem (such as an unknown account or username, or invalid password, etc).\n     *\n     * @param token the authentication token encapsulating the user's login information.\n     * @return an <tt>AuthenticationInfo<\/tt> object encapsulating the user's account information\n     * important to JSecurity.  <tt>null<\/tt> should <em>not<\/em> be returned - throw a proper AuthenticationException\n     * instead (like {@link org.jsecurity.authc.UnknownAccountException} if the account can't be found, etc).\n     * @throws AuthenticationException if there is a problem logging in the user.\n     */\n    protected abstract AuthenticationInfo doAuthenticate( AuthenticationToken token )\n            throws AuthenticationException;\n}\n","lineNo":270}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.context.support;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.NoSuchPrincipalException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthorizedException;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\n\nimport java.security.Principal;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Retrieves all security context data from the currently executing thread (via the {@link ThreadContext}).  This\n * implementation is most widely used in multi-threaded server environments such as EJB and Servlet containers.\n *\n * @since 0.1\n * @author Les Hazlewood\n */\n@SuppressWarnings( {\"unchecked\"} )\npublic class ThreadLocalSecurityContext implements SecurityContext {\n\n    public ThreadLocalSecurityContext(){}\n\n    public boolean isAuthenticated() {\n        SecurityContext sc = getSecurityContext();\n        return sc != null && sc.isAuthenticated();\n    }\n\n    public Principal getPrincipal() throws NoSuchPrincipalException {\n        SecurityContext secCtx = getSecurityContext();\n        return ( secCtx != null ? secCtx.getPrincipal() : null );\n    }\n\n    public List<Principal> getAllPrincipals() {\n        SecurityContext secCtx = getSecurityContext();\n        return ( secCtx != null ? secCtx.getAllPrincipals() : Collections.EMPTY_LIST );\n    }\n\n    public Principal getPrincipalByType( Class principalType ) throws NoSuchPrincipalException {\n        SecurityContext secCtx = getSecurityContext();\n        return ( secCtx != null ? secCtx.getPrincipalByType( principalType ) : null );\n    }\n\n    public Collection<Principal> getAllPrincipalsByType( Class principalType ) {\n        SecurityContext secCtx = getSecurityContext();\n        if ( secCtx != null ) {\n            return secCtx.getAllPrincipalsByType( principalType );\n        }\n        return Collections.EMPTY_LIST;\n    }\n\n    public boolean hasRole( String roleIdentifier ) {\n        SecurityContext secCtx = getSecurityContext();\n        return secCtx != null && secCtx.hasRole( roleIdentifier );\n    }\n\n    public boolean[] hasRoles( List<String> roleIdentifiers ) {\n        SecurityContext secCtx = getSecurityContext();\n        boolean[] hasRoles;\n\n        if ( secCtx != null ) {\n            hasRoles = secCtx.hasRoles( roleIdentifiers );\n        } else {\n            if ( roleIdentifiers != null ) {\n                hasRoles = new boolean[roleIdentifiers.size()];\n            } else {\n                hasRoles = new boolean[0];\n            }\n        }\n\n        return hasRoles;\n    }\n\n    public boolean hasAllRoles( Collection<String> roleIdentifiers ) {\n        SecurityContext secCtx = getSecurityContext();\n        return secCtx != null && secCtx.hasAllRoles( roleIdentifiers );\n    }\n\n    public boolean implies( Permission permission ) {\n        SecurityContext secCtx = getSecurityContext();\n        return secCtx != null && secCtx.implies( permission );\n    }\n\n    public boolean[] implies( List<Permission> permissions ) {\n        SecurityContext secCtx = getSecurityContext();\n        boolean[] implies;\n\n        if ( secCtx != null ) {\n            implies = secCtx.implies( permissions );\n        } else {\n            if ( permissions != null ) {\n                implies = new boolean[permissions.size()];\n            } else {\n                implies = new boolean[0];\n            }\n        }\n\n        return implies;\n    }\n\n    public boolean impliesAll( Collection<Permission> permissions ) {\n        SecurityContext secCtx = getSecurityContext();\n        return secCtx != null && secCtx.impliesAll( permissions );\n    }\n\n    public void checkPermission( Permission permission ) throws AuthorizationException {\n        SecurityContext secCtx = getSecurityContext();\n        if ( secCtx != null ) {\n            secCtx.checkPermission( permission );\n        } else {\n            handleNoSecurityContextCheck();\n        }\n    }\n\n    public void checkPermissions( Collection<Permission> permissions ) throws AuthorizationException {\n        SecurityContext secCtx = getSecurityContext();\n        if ( secCtx != null ) {\n            secCtx.checkPermissions( permissions );\n        } else {\n            handleNoSecurityContextCheck();\n        }\n    }\n\n    public void checkRole(String role) throws AuthorizationException {\n        SecurityContext secCtx = getSecurityContext();\n        if ( secCtx != null ) {\n            secCtx.checkRole( role );\n        } else {\n            handleNoSecurityContextCheck();\n        }\n    }\n\n    public void checkRoles(Collection<String> roles) throws AuthorizationException {\n        SecurityContext secCtx = getSecurityContext();\n        if ( secCtx != null ) {\n            secCtx.checkRoles( roles );\n        } else {\n            handleNoSecurityContextCheck();\n        }\n    }\n\n    protected void handleNoSecurityContextCheck() {\n        String msg = \"No SecurityContext bound to the current thread: unable to perform authorization check. \" +\n                \"Defaulting to a more secure disallow policy - authorization check failed.\";\n        throw new UnauthorizedException( msg );\n    }\n\n    protected SecurityContext getSecurityContext() {\n        return ThreadContext.getSecurityContext();\n    }\n\n    public Session getSession() {\n        return getSecurityContext().getSession();\n    }\n\n    public Session getSession( boolean create ) {\n        return getSecurityContext().getSession( create );\n    }\n\n    public void invalidate() {\n        try {\n            getSecurityContext().invalidate();\n        } finally {\n            ThreadContext.unbindSession();\n            ThreadContext.unbindSecurityContext();\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.context.support;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.NoSuchPrincipalException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthorizedException;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\n\nimport java.security.Principal;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Retrieves all security context data from the currently executing thread (via the {@link ThreadContext}).  This\n * implementation is most widely used in multi-threaded server environments such as EJB and Servlet containers.\n *\n * @since 0.1\n * @author Les Hazlewood\n */\n@SuppressWarnings( {\"unchecked\"} )\npublic class ThreadLocalSecurityContext implements SecurityContext {\n\n    public ThreadLocalSecurityContext(){}\n\n    public static SecurityContext current() {\n        return ThreadContext.getSecurityContext();\n    }\n\n    public boolean isAuthenticated() {\n        return getSecurityContext() != null;\n    }\n\n    public Principal getPrincipal() throws NoSuchPrincipalException {\n        SecurityContext secCtx = getSecurityContext();\n        return ( secCtx != null ? secCtx.getPrincipal() : null );\n    }\n\n    public List<Principal> getAllPrincipals() {\n        SecurityContext secCtx = getSecurityContext();\n        return ( secCtx != null ? secCtx.getAllPrincipals() : Collections.EMPTY_LIST );\n    }\n\n    public Principal getPrincipalByType( Class principalType ) throws NoSuchPrincipalException {\n        SecurityContext secCtx = getSecurityContext();\n        return ( secCtx != null ? secCtx.getPrincipalByType( principalType ) : null );\n    }\n\n    public Collection<Principal> getAllPrincipalsByType( Class principalType ) {\n        SecurityContext secCtx = getSecurityContext();\n        if ( secCtx != null ) {\n            return secCtx.getAllPrincipalsByType( principalType );\n        }\n        return Collections.EMPTY_LIST;\n    }\n\n    public boolean hasRole( String roleIdentifier ) {\n        SecurityContext secCtx = getSecurityContext();\n        return secCtx != null && secCtx.hasRole( roleIdentifier );\n    }\n\n    public boolean[] hasRoles( List<String> roleIdentifiers ) {\n        SecurityContext secCtx = getSecurityContext();\n        boolean[] hasRoles;\n\n        if ( secCtx != null ) {\n            hasRoles = secCtx.hasRoles( roleIdentifiers );\n        } else {\n            if ( roleIdentifiers != null ) {\n                hasRoles = new boolean[roleIdentifiers.size()];\n            } else {\n                hasRoles = new boolean[0];\n            }\n        }\n\n        return hasRoles;\n    }\n\n    public boolean hasAllRoles( Collection<String> roleIdentifiers ) {\n        SecurityContext secCtx = getSecurityContext();\n        return secCtx != null && secCtx.hasAllRoles( roleIdentifiers );\n    }\n\n    public boolean implies( Permission permission ) {\n        SecurityContext secCtx = getSecurityContext();\n        return secCtx != null && secCtx.implies( permission );\n    }\n\n    public boolean[] implies( List<Permission> permissions ) {\n        SecurityContext secCtx = getSecurityContext();\n        boolean[] implies;\n\n        if ( secCtx != null ) {\n            implies = secCtx.implies( permissions );\n        } else {\n            if ( permissions != null ) {\n                implies = new boolean[permissions.size()];\n            } else {\n                implies = new boolean[0];\n            }\n        }\n\n        return implies;\n    }\n\n    public boolean impliesAll( Collection<Permission> permissions ) {\n        SecurityContext secCtx = getSecurityContext();\n        return secCtx != null && secCtx.impliesAll( permissions );\n    }\n\n    public void checkPermission( Permission permission ) throws AuthorizationException {\n        SecurityContext secCtx = getSecurityContext();\n        if ( secCtx != null ) {\n            secCtx.checkPermission( permission );\n        } else {\n            handleNoSecurityContextCheck();\n        }\n    }\n\n    public void checkPermissions( Collection<Permission> permissions ) throws AuthorizationException {\n        SecurityContext secCtx = getSecurityContext();\n        if ( secCtx != null ) {\n            secCtx.checkPermissions( permissions );\n        } else {\n            handleNoSecurityContextCheck();\n        }\n    }\n\n    public void checkRole(String role) throws AuthorizationException {\n        SecurityContext secCtx = getSecurityContext();\n        if ( secCtx != null ) {\n            secCtx.checkRole( role );\n        } else {\n            handleNoSecurityContextCheck();\n        }\n    }\n\n    public void checkRoles(Collection<String> roles) throws AuthorizationException {\n        SecurityContext secCtx = getSecurityContext();\n        if ( secCtx != null ) {\n            secCtx.checkRoles( roles );\n        } else {\n            handleNoSecurityContextCheck();\n        }\n    }\n\n    protected void handleNoSecurityContextCheck() {\n        String msg = \"No SecurityContext bound to the current thread: unable to perform authorization check. \" +\n                \"Defaulting to a more secure disallow policy - authorization check failed.\";\n        throw new UnauthorizedException( msg );\n    }\n\n    protected SecurityContext getSecurityContext() {\n        return ThreadContext.getSecurityContext();\n    }\n\n    public Session getSession() {\n        return getSecurityContext().getSession();\n    }\n\n    public Session getSession( boolean create ) {\n        return getSecurityContext().getSession( create );\n    }\n\n    public void invalidate() {\n        getSecurityContext().invalidate();\n    }\n\n}\n","lineNo":53}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.session.support;\n\nimport org.jsecurity.session.ExpiredSessionException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.support.eis.SessionDAO;\nimport org.jsecurity.session.support.eis.ehcache.EhcacheSessionDAO;\nimport org.jsecurity.session.support.eis.support.MemorySessionDAO;\nimport org.jsecurity.session.support.quartz.QuartzSessionValidationScheduler;\nimport org.jsecurity.util.ClassUtils;\nimport org.jsecurity.util.Destroyable;\nimport org.jsecurity.util.Initializable;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport java.util.Date;\n\n/**\n * Default business-tier implementation of the {@link ValidatingSessionManager} interface.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DefaultSessionManager extends AbstractSessionManager\n    implements ValidatingSessionManager, Destroyable {\n\n    private static final String EHCACHE_VALID_CLASS_NAME = \"net.sf.ehcache.CacheManager\";\n\n    /**\n     * Validator used to validate sessions on a regular basis.\n     * By default, the session manager will use Quartz to schedule session validation, but this\n     * can be overridden by calling {@link #setSessionValidationScheduler(SessionValidationScheduler)}\n     */\n    protected SessionValidationScheduler sessionValidationScheduler = null;\n\n    private boolean sessionDAOImplicitlyCreated = false;\n    private boolean sessionValidationSchedulerImplicitlyCreated = false;\n\n    public DefaultSessionManager() {\n        setSessionClass( SimpleSession.class );\n    }\n\n    public void setSessionValidationScheduler( SessionValidationScheduler sessionValidationScheduler ) {\n        this.sessionValidationScheduler = sessionValidationScheduler;\n    }\n\n    public SessionValidationScheduler getSessionValidationScheduler() {\n        return sessionValidationScheduler;\n    }\n\n    private boolean isEhcacheAvailable() {\n        return ClassUtils.isAvailable( EHCACHE_VALID_CLASS_NAME );\n    }\n\n    /**\n     * Creates a default <tt>SessionDAO<\/tt> during {@link #init initialization} as a fail-safe mechanism if one has\n     * not already been explicitly set via {@link #setSessionDAO}.\n     * <p/>\n     * <p>This default implementation tries to use an {@link EhcacheSessionDAO EhcacheSessionDAO} instance by default if\n     * <a href=\"\">Ehcache<\/a> is in the classpath.  If ehcache is not in the classpath, a\n     * {@link org.jsecurity.session.support.eis.support.MemorySessionDAO} will be used instead.\n     * <p/>\n     * <p><b>N.B.<\/b> The MemorySessionDAO implementation is not production capable, as it maintains all sessions in\n     * memory (never removed, eating up memory over time) and loses session after server restarts.  It is really only\n     * suitable during testing.  For production environments, please ensure\n     * that you either have the <tt>ehcache<\/tt> jar in the classpath, or explicitly set a SessionDAO via the\n     * {@link #setSessionDAO} method so a sensible default will be used.\n     *\n     * @return a lazily created SessionDAO instance.\n     */\n    protected SessionDAO createSessionDAO() {\n        SessionDAO dao = null;\n\n        if ( log.isDebugEnabled() ) {\n            log.debug( \"No sessionDAO set.  Attempting to create default instance.\" );\n        }\n        if ( isEhcacheAvailable() ) {\n            if ( log.isDebugEnabled() ) {\n                String msg = \"Ehcache found in the classpath.  Using default EhcacheSessionDAO implementation.\";\n                log.debug( msg );\n            }\n            dao = new EhcacheSessionDAO();\n        } else {\n            if ( log.isWarnEnabled() ) {\n                String msg = \"Ehcache is not in the classpath.  JSecurity's default production-quality session \" +\n                    \"DAO is implemented w/ Ehcache.  Defaulting to a simple memory-based DAO, but this should \" +\n                    \"NOT be used in a production environment.  Please either put ehcache.jar in the classpath \" +\n                    \"or set a production-quality implementation explicitly via the \" + getClass().getName() +\n                    \"#setSessionDAO method.\";\n                log.warn( msg );\n            }\n            dao = new MemorySessionDAO();\n        }\n        this.sessionDAOImplicitlyCreated = true;\n\n        init( dao );\n\n        return dao;\n    }\n\n    protected SessionValidationScheduler createSessionValidationScheduler() {\n        SessionValidationScheduler scheduler = null;\n\n        if ( log.isDebugEnabled() ) {\n            log.debug( \"No sessionValidationScheduler set.  Attempting to create default instance.\" );\n        }\n        scheduler = new QuartzSessionValidationScheduler( this );\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Created default SessionValidationScheduler instance of type [\" + scheduler.getClass().getName() + \"].\" );\n        }\n        this.sessionValidationSchedulerImplicitlyCreated = true;\n        return scheduler;\n    }\n\n    protected void startSessionValidation() {\n        SessionValidationScheduler scheduler = getSessionValidationScheduler();\n        if ( scheduler == null ) {\n            scheduler = createSessionValidationScheduler();\n            setSessionValidationScheduler( scheduler );\n        }\n        if ( log.isInfoEnabled() ) {\n            log.info( \"Starting session validation scheduler...\" );\n        }\n        scheduler.startSessionValidation();\n    }\n\n    protected void stopSessionValidation() {\n        SessionValidationScheduler scheduler = getSessionValidationScheduler();\n        if ( scheduler != null ) {\n            try {\n                scheduler.stopSessionValidation();\n            } catch ( Exception e ) {\n                if ( log.isDebugEnabled() ) {\n                    String msg = \"Unable to stop SessionValidationScheduler.  Ignoring (shutting down)...\";\n                    log.debug( msg, e );\n                }\n            }\n            if ( sessionValidationSchedulerImplicitlyCreated ) {\n                destroy( scheduler );\n            }\n        }\n    }\n\n    protected void ensureSessionDAO() {\n        SessionDAO sessionDAO = getSessionDAO();\n        if ( sessionDAO == null ) {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No sessionDAO set.  Attempting to create default instance.\" );\n            }\n            sessionDAO = createSessionDAO();\n            setSessionDAO( sessionDAO );\n        }\n    }\n\n    protected void initSessionDAO() {\n        if ( sessionDAOImplicitlyCreated ) {\n            init( getSessionDAO() );\n        }\n    }\n\n    protected void initSessionValidationScheduler() {\n        if ( sessionValidationSchedulerImplicitlyCreated ) {\n            init( getSessionValidationScheduler() );\n        }\n    }\n\n    public void init() {\n        ensureSessionDAO();\n        super.init();\n        startSessionValidation();\n    }\n\n    protected void destroySessionDAO() {\n        if ( sessionDAOImplicitlyCreated ) {\n            destroy( getSessionDAO() );\n        }\n    }\n\n    protected void init( Object o ) {\n        if ( o instanceof Initializable ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Initializing object instance of type [\" + o.getClass().getName() + \"]...\" );\n            }\n            try {\n                ((Initializable)o).init();\n            } catch ( Exception e ) {\n                String msg = \"Unable to intialize object [\" + o + \"].\";\n                throw new IllegalStateException( msg, e );\n            }\n        }\n    }\n\n    protected void destroy( Object o ) {\n        if ( o instanceof Destroyable ) {\n            try {\n                ((Destroyable)o).destroy();\n            } catch ( Exception e ) {\n                if ( log.isDebugEnabled() ) {\n                    String msg = \"Unable to cleanly destroy Destroyable object of type [\" + o.getClass().getName() +\n                        \"].  Ignoring (shutting down).\";\n                    log.debug( msg, e );\n                }\n            }\n        }\n    }\n\n    public void destroy() {\n        stopSessionValidation();\n        destroySessionDAO();\n    }\n\n    protected void onStop( Session session ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Updating last access and destroy time of session with id [\" + session.getSessionId() + \"]\" );\n        }\n        // when properly stopping a session, it makes sense (for most systems) that the stop time and last access time\n        // are the same:\n        Date timestamp = new Date();\n        SimpleSession simpleSession = (SimpleSession)session;\n        simpleSession.setLastAccessTime( timestamp );\n        simpleSession.setStopTimestamp( timestamp );\n    }\n\n    protected void onExpire( Session session ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Updating destroy time and expiration status of session with id \" +\n                session.getSessionId() + \"]\" );\n        }\n        SimpleSession ss = (SimpleSession)session;\n        ss.setStopTimestamp( new Date() );\n        ss.setExpired( true );\n    }\n\n    protected void onTouch( Session session ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Updating last access time of session with id [\" +\n                session.getSessionId() + \"]\" );\n        }\n        ( (SimpleSession)session ).setLastAccessTime( new Date() );\n    }\n\n    protected void init( Session newInstance, InetAddress hostAddr ) {\n        if ( newInstance instanceof SimpleSession ) {\n            SimpleSession ss = (SimpleSession)newInstance;\n            ss.setHostAddress( hostAddr );\n        }\n    }\n\n    /**\n     * @see org.jsecurity.session.support.ValidatingSessionManager#validateSessions()\n     */\n    public void validateSessions() {\n        if ( log.isInfoEnabled() ) {\n            log.info( \"Validating all active sessions...\" );\n        }\n\n        int invalidCount = 0;\n\n        Collection<Session> activeSessions = getSessionDAO().getActiveSessions();\n\n        if ( activeSessions != null && !activeSessions.isEmpty() ) {\n            for ( Session s : activeSessions ) {\n                try {\n                    validate( s );\n                } catch ( InvalidSessionException e ) {\n                    if ( log.isDebugEnabled() ) {\n                        boolean expired = ( e instanceof ExpiredSessionException );\n                        String msg = \"Invalidated session with id [\" + s.getSessionId() + \"]\" +\n                            ( expired ? \" (expired)\" : \" (stopped)\" );\n                        log.debug( msg );\n                    }\n                    invalidCount++;\n                }\n            }\n        }\n\n        if ( log.isInfoEnabled() ) {\n            String msg = \"Finished session validation.\";\n            if ( invalidCount > 0 ) {\n                msg += \"  [\" + invalidCount + \"] sessions were stopped.\";\n            } else {\n                msg += \"  No sessions were stopped.\";\n            }\n            log.info( msg );\n        }\n    }\n\n    public void validateSession( Serializable sessionId ) {\n        retrieveAndValidateSession( sessionId );\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.session.support;\n\nimport org.jsecurity.session.ExpiredSessionException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.support.eis.SessionDAO;\nimport org.jsecurity.session.support.eis.ehcache.EhcacheSessionDAO;\nimport org.jsecurity.session.support.eis.support.MemorySessionDAO;\nimport org.jsecurity.session.support.quartz.QuartzSessionValidationScheduler;\nimport org.jsecurity.util.ClassUtils;\nimport org.jsecurity.util.Destroyable;\nimport org.jsecurity.util.Initializable;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport java.util.Date;\n\n/**\n * Default business-tier implementation of the {@link ValidatingSessionManager} interface.\n *\n * @since 0.1\n * @author Les Hazlewood\n * @author Jeremy Haile\n */\npublic class DefaultSessionManager extends AbstractSessionManager\n        implements ValidatingSessionManager, Destroyable {\n\n    private static final String EHCACHE_VALID_CLASS_NAME = \"net.sf.ehcache.CacheManager\";\n\n    /**\n     * Validator used to validate sessions on a regular basis.\n     * By default, the session manager will use Quartz to schedule session validation, but this\n     * can be overridden by calling {@link #setSessionValidationScheduler(SessionValidationScheduler)}\n     */\n    protected SessionValidationScheduler sessionValidationScheduler = new QuartzSessionValidationScheduler( this );\n\n    private boolean sessionDAOImplicitlyCreated = false;\n\n\n    public DefaultSessionManager(){\n        setSessionClass( SimpleSession.class );\n    }\n\n    private boolean isEhcacheAvailable() {\n        return ClassUtils.isAvailable( EHCACHE_VALID_CLASS_NAME );\n    }\n\n    /**\n     * Creates a default <tt>SessionDAO<\/tt> during {@link #init initialization} as a fail-safe mechanism if one has\n     * not already been explicitly set via {@link #setSessionDAO}.\n     *\n     * <p>This default implementation tries to use an {@link EhcacheSessionDAO EhcacheSessionDAO} instance by default if\n     * <a href=\"\">Ehcache<\/a> is in the classpath.  If ehcache is not in the classpath, a\n     * {@link org.jsecurity.session.support.eis.support.MemorySessionDAO} will be used instead.\n     *\n     * <p><b>N.B.<\/b> The MemorySessionDAO implementation is not production capable, as it maintains all sessions in\n     * memory (never removed, eating up memory over time) and loses session after server restarts.  It is really only\n     * suitable during testing.  For production environments, please ensure\n     * that you either have the <tt>ehcache<\/tt> jar in the classpath, or explicitly set a SessionDAO via the\n     * {@link #setSessionDAO} method so a sensible default will be used.\n     *\n     * @return a lazily created SessionDAO instance.\n     */\n    protected SessionDAO createSessionDAO() {\n        SessionDAO dao = null;\n\n        if ( log.isDebugEnabled() ) {\n            log.debug( \"No sessionDAO set.  Attempting to create default instance.\" );\n        }\n        if ( isEhcacheAvailable() ) {\n            if ( log.isDebugEnabled() ) {\n                String msg = \"Ehcache found in the classpath.  Using default EhcacheSessionDAO implementation.\";\n                log.debug( msg );\n            }\n            dao = new EhcacheSessionDAO();\n        } else {\n            if ( log.isWarnEnabled() ) {\n                String msg = \"Ehcache is not in the classpath.  JSecurity's default production-quality session \" +\n                        \"DAO is implemented w/ Ehcache.  Defaulting to a simple memory-based DAO, but this should \" +\n                        \"NOT be used in a production environment.  Please either put ehcache.jar in the classpath \" +\n                        \"or set a production-quality implementation explicitly via the \" + getClass().getName() +\n                        \"#setSessionDAO method.\";\n                log.warn( msg );\n            }\n            dao = new MemorySessionDAO();\n        }\n        this.sessionDAOImplicitlyCreated = true;\n        return dao;\n    }\n\n    public void init() {\n\n        SessionDAO sessionDAO = getSessionDAO();\n        if ( sessionDAO == null ) {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No sessionDAO set.  Attempting to create default instance.\" );\n            }\n            sessionDAO = createSessionDAO();\n            setSessionDAO( sessionDAO );\n            if ( sessionDAOImplicitlyCreated && (sessionDAO instanceof Initializable ) ) {\n                if ( log.isTraceEnabled() ) {\n                    log.trace( \"Initializing implicitly created instance...\" );\n                }\n                try {\n                    ((Initializable)sessionDAO).init();\n                } catch (Exception e) {\n                    String msg = \"Unable to initialize sessionDAO [\" + sessionDAO + \"]\";\n                    throw new IllegalStateException( msg, e );\n                }\n            }\n        }\n\n        super.init();\n\n        // Start session validation\n        if ( sessionValidationScheduler != null ) {\n\n            if( log.isInfoEnabled() ) {\n                log.info( \"Starting session validation scheduler...\" );\n            }\n\n            sessionValidationScheduler.startSessionValidation();\n        } else {\n            if (log.isWarnEnabled()) {\n                log.warn(\"No session validation scheduler is configured, so sessions may not be validated.\");\n            }\n        }\n    }\n\n    public void destroy() {\n        try {\n            if ( sessionValidationScheduler != null ) {\n                sessionValidationScheduler.stopSessionValidation();\n            }\n        } catch (Exception e) {\n            if ( log.isWarnEnabled() ) {\n                String msg = \"Unable to cleanly destroy sessionValidationScheduler [\" + sessionValidationScheduler + \"].\";\n                log.warn( msg, e );\n            }\n        }\n\n        if ( sessionDAOImplicitlyCreated ) {\n            if ( sessionDAO instanceof Destroyable ) {\n                try {\n                    ((Destroyable)sessionDAO).destroy();\n                } catch ( Exception e ) {\n                    if ( log.isDebugEnabled() ) {\n                        log.debug( \"Unable to cleanly destroy implicitly created sessionDAO [\" + sessionDAO + \"].\" );\n                    }\n                }\n            }\n        }\n    }\n\n    public void setSessionValidationScheduler(SessionValidationScheduler sessionValidationScheduler) {\n        this.sessionValidationScheduler = sessionValidationScheduler;\n    }\n\n\n    protected void onStop( Session session ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Updating last access and destroy time of session with id [\" + session.getSessionId() + \"]\" );\n        }\n        // when properly stopping a session, it makes sense (for most systems) that the stop time and last access time\n        // are the same:\n        Date timestamp = new Date();\n        SimpleSession simpleSession = (SimpleSession)session;\n        simpleSession.setLastAccessTime( timestamp );\n        simpleSession.setStopTimestamp( timestamp );\n    }\n\n    protected void onExpire( Session session ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Updating destroy time and expiration status of session with id \" +\n                       session.getSessionId() + \"]\");\n        }\n        SimpleSession ss = (SimpleSession)session;\n        ss.setStopTimestamp( new Date() );\n        ss.setExpired( true );\n    }\n\n    protected void onTouch( Session session ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Updating last access time of session with id [\" +\n                       session.getSessionId() + \"]\");\n        }\n        ((SimpleSession)session).setLastAccessTime( new Date() );\n    }\n\n    protected void init( Session newInstance, InetAddress hostAddr ) {\n        if ( newInstance instanceof SimpleSession ) {\n            SimpleSession ss = (SimpleSession)newInstance;\n            ss.setHostAddress( hostAddr );\n        }\n    }\n\n    /**\n     * @see org.jsecurity.session.support.ValidatingSessionManager#validateSessions()\n     */\n    public void validateSessions() {\n        if ( log.isInfoEnabled() ) {\n            log.info( \"Validating all active sessions...\" );\n        }\n\n        int invalidCount = 0;\n\n        Collection<Session> activeSessions = getSessionDAO().getActiveSessions();\n\n        if ( activeSessions != null && !activeSessions.isEmpty() ) {\n            for( Session s : activeSessions ) {\n                try {\n                    validate( s );\n                } catch ( InvalidSessionException e ) {\n                    if ( log.isDebugEnabled() ) {\n                        boolean expired = (e instanceof ExpiredSessionException );\n                        String msg = \"Invalidated session with id [\" + s.getSessionId() + \"]\" +\n                            ( expired ? \" (expired)\" : \" (stopped)\" );\n                        log.debug( msg );\n                    }\n                    invalidCount++;\n                }\n            }\n        }\n\n        if ( log.isInfoEnabled() ) {\n            String msg = \"Finished session validation.\";\n            if ( invalidCount > 0 ) {\n                msg += \"  [\" + invalidCount + \"] sessions were stopped.\";\n            } else {\n                msg += \"  No sessions were stopped.\";\n            }\n            log.info( msg );\n        }\n    }\n\n    public void validateSession( Serializable sessionId ) {\n        retrieveAndValidateSession( sessionId );\n    }\n\n}\n","lineNo":225}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.session.support;\n\nimport org.jsecurity.session.ExpiredSessionException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.support.eis.SessionDAO;\nimport org.jsecurity.session.support.eis.ehcache.EhcacheSessionDAO;\nimport org.jsecurity.session.support.eis.support.MemorySessionDAO;\nimport org.jsecurity.session.support.quartz.QuartzSessionValidationScheduler;\nimport org.jsecurity.util.ClassUtils;\nimport org.jsecurity.util.Destroyable;\nimport org.jsecurity.util.Initializable;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport java.util.Date;\n\n/**\n * Default business-tier implementation of the {@link ValidatingSessionManager} interface.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DefaultSessionManager extends AbstractSessionManager\n    implements ValidatingSessionManager, Destroyable {\n\n    private static final String EHCACHE_VALID_CLASS_NAME = \"net.sf.ehcache.CacheManager\";\n\n    /**\n     * Validator used to validate sessions on a regular basis.\n     * By default, the session manager will use Quartz to schedule session validation, but this\n     * can be overridden by calling {@link #setSessionValidationScheduler(SessionValidationScheduler)}\n     */\n    protected SessionValidationScheduler sessionValidationScheduler = null;\n\n    private boolean sessionDAOImplicitlyCreated = false;\n    private boolean sessionValidationSchedulerImplicitlyCreated = false;\n\n    public DefaultSessionManager() {\n        setSessionClass( SimpleSession.class );\n    }\n\n    public void setSessionValidationScheduler( SessionValidationScheduler sessionValidationScheduler ) {\n        this.sessionValidationScheduler = sessionValidationScheduler;\n    }\n\n    public SessionValidationScheduler getSessionValidationScheduler() {\n        return sessionValidationScheduler;\n    }\n\n    private boolean isEhcacheAvailable() {\n        return ClassUtils.isAvailable( EHCACHE_VALID_CLASS_NAME );\n    }\n\n    /**\n     * Creates a default <tt>SessionDAO<\/tt> during {@link #init initialization} as a fail-safe mechanism if one has\n     * not already been explicitly set via {@link #setSessionDAO}.\n     * <p/>\n     * <p>This default implementation tries to use an {@link EhcacheSessionDAO EhcacheSessionDAO} instance by default if\n     * <a href=\"\">Ehcache<\/a> is in the classpath.  If ehcache is not in the classpath, a\n     * {@link org.jsecurity.session.support.eis.support.MemorySessionDAO} will be used instead.\n     * <p/>\n     * <p><b>N.B.<\/b> The MemorySessionDAO implementation is not production capable, as it maintains all sessions in\n     * memory (never removed, eating up memory over time) and loses session after server restarts.  It is really only\n     * suitable during testing.  For production environments, please ensure\n     * that you either have the <tt>ehcache<\/tt> jar in the classpath, or explicitly set a SessionDAO via the\n     * {@link #setSessionDAO} method so a sensible default will be used.\n     *\n     * @return a lazily created SessionDAO instance.\n     */\n    protected SessionDAO createSessionDAO() {\n        SessionDAO dao = null;\n\n        if ( log.isDebugEnabled() ) {\n            log.debug( \"No sessionDAO set.  Attempting to create default instance.\" );\n        }\n        if ( isEhcacheAvailable() ) {\n            if ( log.isDebugEnabled() ) {\n                String msg = \"Ehcache found in the classpath.  Using default EhcacheSessionDAO implementation.\";\n                log.debug( msg );\n            }\n            dao = new EhcacheSessionDAO();\n        } else {\n            if ( log.isWarnEnabled() ) {\n                String msg = \"Ehcache is not in the classpath.  JSecurity's default production-quality session \" +\n                    \"DAO is implemented w/ Ehcache.  Defaulting to a simple memory-based DAO, but this should \" +\n                    \"NOT be used in a production environment.  Please either put ehcache.jar in the classpath \" +\n                    \"or set a production-quality implementation explicitly via the \" + getClass().getName() +\n                    \"#setSessionDAO method.\";\n                log.warn( msg );\n            }\n            dao = new MemorySessionDAO();\n        }\n        this.sessionDAOImplicitlyCreated = true;\n\n        init( dao );\n\n        return dao;\n    }\n\n    protected SessionValidationScheduler createSessionValidationScheduler() {\n        SessionValidationScheduler scheduler = null;\n\n        if ( log.isDebugEnabled() ) {\n            log.debug( \"No sessionValidationScheduler set.  Attempting to create default instance.\" );\n        }\n        scheduler = new QuartzSessionValidationScheduler( this );\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Created default SessionValidationScheduler instance of type [\" + scheduler.getClass().getName() + \"].\" );\n        }\n        this.sessionValidationSchedulerImplicitlyCreated = true;\n        return scheduler;\n    }\n\n    protected void startSessionValidation() {\n        SessionValidationScheduler scheduler = getSessionValidationScheduler();\n        if ( scheduler == null ) {\n            scheduler = createSessionValidationScheduler();\n            setSessionValidationScheduler( scheduler );\n        }\n        if ( log.isInfoEnabled() ) {\n            log.info( \"Starting session validation scheduler...\" );\n        }\n        scheduler.startSessionValidation();\n    }\n\n    protected void stopSessionValidation() {\n        SessionValidationScheduler scheduler = getSessionValidationScheduler();\n        if ( scheduler != null ) {\n            try {\n                scheduler.stopSessionValidation();\n            } catch ( Exception e ) {\n                if ( log.isDebugEnabled() ) {\n                    String msg = \"Unable to stop SessionValidationScheduler.  Ignoring (shutting down)...\";\n                    log.debug( msg, e );\n                }\n            }\n            if ( sessionValidationSchedulerImplicitlyCreated ) {\n                destroy( scheduler );\n            }\n        }\n    }\n\n    protected void ensureSessionDAO() {\n        SessionDAO sessionDAO = getSessionDAO();\n        if ( sessionDAO == null ) {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No sessionDAO set.  Attempting to create default instance.\" );\n            }\n            sessionDAO = createSessionDAO();\n            setSessionDAO( sessionDAO );\n        }\n    }\n\n    protected void initSessionDAO() {\n        if ( sessionDAOImplicitlyCreated ) {\n            init( getSessionDAO() );\n        }\n    }\n\n    protected void initSessionValidationScheduler() {\n        if ( sessionValidationSchedulerImplicitlyCreated ) {\n            init( getSessionValidationScheduler() );\n        }\n    }\n\n    public void init() {\n        ensureSessionDAO();\n        super.init();\n        startSessionValidation();\n    }\n\n    protected void destroySessionDAO() {\n        if ( sessionDAOImplicitlyCreated ) {\n            destroy( getSessionDAO() );\n        }\n    }\n\n    protected void init( Object o ) {\n        if ( o instanceof Initializable ) {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"Initializing object instance of type [\" + o.getClass().getName() + \"]...\" );\n            }\n            try {\n                ((Initializable)o).init();\n            } catch ( Exception e ) {\n                String msg = \"Unable to intialize object [\" + o + \"].\";\n                throw new IllegalStateException( msg, e );\n            }\n        }\n    }\n\n    protected void destroy( Object o ) {\n        if ( o instanceof Destroyable ) {\n            try {\n                ((Destroyable)o).destroy();\n            } catch ( Exception e ) {\n                if ( log.isDebugEnabled() ) {\n                    String msg = \"Unable to cleanly destroy Destroyable object of type [\" + o.getClass().getName() +\n                        \"].  Ignoring (shutting down).\";\n                    log.debug( msg, e );\n                }\n            }\n        }\n    }\n\n    public void destroy() {\n        stopSessionValidation();\n        destroySessionDAO();\n    }\n\n    protected void onStop( Session session ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Updating last access and destroy time of session with id [\" + session.getSessionId() + \"]\" );\n        }\n        // when properly stopping a session, it makes sense (for most systems) that the stop time and last access time\n        // are the same:\n        Date timestamp = new Date();\n        SimpleSession simpleSession = (SimpleSession)session;\n        simpleSession.setLastAccessTime( timestamp );\n        simpleSession.setStopTimestamp( timestamp );\n    }\n\n    protected void onExpire( Session session ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Updating destroy time and expiration status of session with id \" +\n                session.getSessionId() + \"]\" );\n        }\n        SimpleSession ss = (SimpleSession)session;\n        ss.setStopTimestamp( new Date() );\n        ss.setExpired( true );\n    }\n\n    protected void onTouch( Session session ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Updating last access time of session with id [\" +\n                session.getSessionId() + \"]\" );\n        }\n        ( (SimpleSession)session ).setLastAccessTime( new Date() );\n    }\n\n    protected void init( Session newInstance, InetAddress hostAddr ) {\n        if ( newInstance instanceof SimpleSession ) {\n            SimpleSession ss = (SimpleSession)newInstance;\n            ss.setHostAddress( hostAddr );\n        }\n    }\n\n    /**\n     * @see org.jsecurity.session.support.ValidatingSessionManager#validateSessions()\n     */\n    public void validateSessions() {\n        if ( log.isInfoEnabled() ) {\n            log.info( \"Validating all active sessions...\" );\n        }\n\n        int invalidCount = 0;\n\n        Collection<Session> activeSessions = getSessionDAO().getActiveSessions();\n\n        if ( activeSessions != null && !activeSessions.isEmpty() ) {\n            for ( Session s : activeSessions ) {\n                try {\n                    validate( s );\n                } catch ( InvalidSessionException e ) {\n                    if ( log.isDebugEnabled() ) {\n                        boolean expired = ( e instanceof ExpiredSessionException );\n                        String msg = \"Invalidated session with id [\" + s.getSessionId() + \"]\" +\n                            ( expired ? \" (expired)\" : \" (stopped)\" );\n                        log.debug( msg );\n                    }\n                    invalidCount++;\n                }\n            }\n        }\n\n        if ( log.isInfoEnabled() ) {\n            String msg = \"Finished session validation.\";\n            if ( invalidCount > 0 ) {\n                msg += \"  [\" + invalidCount + \"] sessions were stopped.\";\n            } else {\n                msg += \"  No sessions were stopped.\";\n            }\n            log.info( msg );\n        }\n    }\n\n    public void validateSession( Serializable sessionId ) {\n        retrieveAndValidateSession( sessionId );\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.session.support;\n\nimport org.jsecurity.session.ExpiredSessionException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.support.eis.SessionDAO;\nimport org.jsecurity.session.support.eis.ehcache.EhcacheSessionDAO;\nimport org.jsecurity.session.support.eis.support.MemorySessionDAO;\nimport org.jsecurity.session.support.quartz.QuartzSessionValidationScheduler;\nimport org.jsecurity.util.ClassUtils;\nimport org.jsecurity.util.Destroyable;\nimport org.jsecurity.util.Initializable;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport java.util.Date;\n\n/**\n * Default business-tier implementation of the {@link ValidatingSessionManager} interface.\n *\n * @since 0.1\n * @author Les Hazlewood\n * @author Jeremy Haile\n */\npublic class DefaultSessionManager extends AbstractSessionManager\n        implements ValidatingSessionManager, Destroyable {\n\n    private static final String EHCACHE_VALID_CLASS_NAME = \"net.sf.ehcache.CacheManager\";\n\n    /**\n     * Validator used to validate sessions on a regular basis.\n     * By default, the session manager will use Quartz to schedule session validation, but this\n     * can be overridden by calling {@link #setSessionValidationScheduler(SessionValidationScheduler)}\n     */\n    protected SessionValidationScheduler sessionValidationScheduler = new QuartzSessionValidationScheduler( this );\n\n    private boolean sessionDAOImplicitlyCreated = false;\n\n\n    public DefaultSessionManager(){\n        setSessionClass( SimpleSession.class );\n    }\n\n    private boolean isEhcacheAvailable() {\n        return ClassUtils.isAvailable( EHCACHE_VALID_CLASS_NAME );\n    }\n\n    /**\n     * Creates a default <tt>SessionDAO<\/tt> during {@link #init initialization} as a fail-safe mechanism if one has\n     * not already been explicitly set via {@link #setSessionDAO}.\n     *\n     * <p>This default implementation tries to use an {@link EhcacheSessionDAO EhcacheSessionDAO} instance by default if\n     * <a href=\"\">Ehcache<\/a> is in the classpath.  If ehcache is not in the classpath, a\n     * {@link org.jsecurity.session.support.eis.support.MemorySessionDAO} will be used instead.\n     *\n     * <p><b>N.B.<\/b> The MemorySessionDAO implementation is not production capable, as it maintains all sessions in\n     * memory (never removed, eating up memory over time) and loses session after server restarts.  It is really only\n     * suitable during testing.  For production environments, please ensure\n     * that you either have the <tt>ehcache<\/tt> jar in the classpath, or explicitly set a SessionDAO via the\n     * {@link #setSessionDAO} method so a sensible default will be used.\n     *\n     * @return a lazily created SessionDAO instance.\n     */\n    protected SessionDAO createSessionDAO() {\n        SessionDAO dao = null;\n\n        if ( log.isDebugEnabled() ) {\n            log.debug( \"No sessionDAO set.  Attempting to create default instance.\" );\n        }\n        if ( isEhcacheAvailable() ) {\n            if ( log.isDebugEnabled() ) {\n                String msg = \"Ehcache found in the classpath.  Using default EhcacheSessionDAO implementation.\";\n                log.debug( msg );\n            }\n            dao = new EhcacheSessionDAO();\n        } else {\n            if ( log.isWarnEnabled() ) {\n                String msg = \"Ehcache is not in the classpath.  JSecurity's default production-quality session \" +\n                        \"DAO is implemented w/ Ehcache.  Defaulting to a simple memory-based DAO, but this should \" +\n                        \"NOT be used in a production environment.  Please either put ehcache.jar in the classpath \" +\n                        \"or set a production-quality implementation explicitly via the \" + getClass().getName() +\n                        \"#setSessionDAO method.\";\n                log.warn( msg );\n            }\n            dao = new MemorySessionDAO();\n        }\n        this.sessionDAOImplicitlyCreated = true;\n        return dao;\n    }\n\n    public void init() {\n\n        SessionDAO sessionDAO = getSessionDAO();\n        if ( sessionDAO == null ) {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No sessionDAO set.  Attempting to create default instance.\" );\n            }\n            sessionDAO = createSessionDAO();\n            setSessionDAO( sessionDAO );\n            if ( sessionDAOImplicitlyCreated && (sessionDAO instanceof Initializable ) ) {\n                if ( log.isTraceEnabled() ) {\n                    log.trace( \"Initializing implicitly created instance...\" );\n                }\n                try {\n                    ((Initializable)sessionDAO).init();\n                } catch (Exception e) {\n                    String msg = \"Unable to initialize sessionDAO [\" + sessionDAO + \"]\";\n                    throw new IllegalStateException( msg, e );\n                }\n            }\n        }\n\n        super.init();\n\n        // Start session validation\n        if ( sessionValidationScheduler != null ) {\n\n            if( log.isInfoEnabled() ) {\n                log.info( \"Starting session validation scheduler...\" );\n            }\n\n            sessionValidationScheduler.startSessionValidation();\n        } else {\n            if (log.isWarnEnabled()) {\n                log.warn(\"No session validation scheduler is configured, so sessions may not be validated.\");\n            }\n        }\n    }\n\n    public void destroy() {\n        try {\n            if ( sessionValidationScheduler != null ) {\n                sessionValidationScheduler.stopSessionValidation();\n            }\n        } catch (Exception e) {\n            if ( log.isWarnEnabled() ) {\n                String msg = \"Unable to cleanly destroy sessionValidationScheduler [\" + sessionValidationScheduler + \"].\";\n                log.warn( msg, e );\n            }\n        }\n\n        if ( sessionDAOImplicitlyCreated ) {\n            if ( sessionDAO instanceof Destroyable ) {\n                try {\n                    ((Destroyable)sessionDAO).destroy();\n                } catch ( Exception e ) {\n                    if ( log.isDebugEnabled() ) {\n                        log.debug( \"Unable to cleanly destroy implicitly created sessionDAO [\" + sessionDAO + \"].\" );\n                    }\n                }\n            }\n        }\n    }\n\n    public void setSessionValidationScheduler(SessionValidationScheduler sessionValidationScheduler) {\n        this.sessionValidationScheduler = sessionValidationScheduler;\n    }\n\n\n    protected void onStop( Session session ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Updating last access and destroy time of session with id [\" + session.getSessionId() + \"]\" );\n        }\n        // when properly stopping a session, it makes sense (for most systems) that the stop time and last access time\n        // are the same:\n        Date timestamp = new Date();\n        SimpleSession simpleSession = (SimpleSession)session;\n        simpleSession.setLastAccessTime( timestamp );\n        simpleSession.setStopTimestamp( timestamp );\n    }\n\n    protected void onExpire( Session session ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Updating destroy time and expiration status of session with id \" +\n                       session.getSessionId() + \"]\");\n        }\n        SimpleSession ss = (SimpleSession)session;\n        ss.setStopTimestamp( new Date() );\n        ss.setExpired( true );\n    }\n\n    protected void onTouch( Session session ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Updating last access time of session with id [\" +\n                       session.getSessionId() + \"]\");\n        }\n        ((SimpleSession)session).setLastAccessTime( new Date() );\n    }\n\n    protected void init( Session newInstance, InetAddress hostAddr ) {\n        if ( newInstance instanceof SimpleSession ) {\n            SimpleSession ss = (SimpleSession)newInstance;\n            ss.setHostAddress( hostAddr );\n        }\n    }\n\n    /**\n     * @see org.jsecurity.session.support.ValidatingSessionManager#validateSessions()\n     */\n    public void validateSessions() {\n        if ( log.isInfoEnabled() ) {\n            log.info( \"Validating all active sessions...\" );\n        }\n\n        int invalidCount = 0;\n\n        Collection<Session> activeSessions = getSessionDAO().getActiveSessions();\n\n        if ( activeSessions != null && !activeSessions.isEmpty() ) {\n            for( Session s : activeSessions ) {\n                try {\n                    validate( s );\n                } catch ( InvalidSessionException e ) {\n                    if ( log.isDebugEnabled() ) {\n                        boolean expired = (e instanceof ExpiredSessionException );\n                        String msg = \"Invalidated session with id [\" + s.getSessionId() + \"]\" +\n                            ( expired ? \" (expired)\" : \" (stopped)\" );\n                        log.debug( msg );\n                    }\n                    invalidCount++;\n                }\n            }\n        }\n\n        if ( log.isInfoEnabled() ) {\n            String msg = \"Finished session validation.\";\n            if ( invalidCount > 0 ) {\n                msg += \"  [\" + invalidCount + \"] sessions were stopped.\";\n            } else {\n                msg += \"  No sessions were stopped.\";\n            }\n            log.info( msg );\n        }\n    }\n\n    public void validateSession( Serializable sessionId ) {\n        retrieveAndValidateSession( sessionId );\n    }\n\n}\n","lineNo":160}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood, Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.session.support.quartz;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.session.support.SessionValidationScheduler;\nimport org.jsecurity.session.support.ValidatingSessionManager;\nimport org.quartz.JobDetail;\nimport org.quartz.Scheduler;\nimport org.quartz.SchedulerException;\nimport org.quartz.SimpleTrigger;\nimport org.quartz.impl.StdSchedulerFactory;\n\n/**\n * An implementation of the {@link SessionValidationScheduler SessionValidationScheduler} that uses Quartz to schedule a\n * job to call {@link org.jsecurity.session.support.ValidatingSessionManager#validateSessions()} on\n * a regular basis.\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class QuartzSessionValidationScheduler implements SessionValidationScheduler {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * The default interval at which sessions will be validated.(5 minutes)\n     * This can be overridden by calling {@link #setSessionValidationInterval(long)}\n     */\n    private static final long DEFAULT_SESSION_VALIDATION_INTERVAL = 300000;\n\n    /**\n     * The name assigned to the quartz job.\n     */\n    private static final String JOB_NAME = \"SessionValidationJob\";\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logging logger\n     */\n    protected final transient Log log = LogFactory.getLog(getClass());\n\n    /**\n     * The configured Quartz scheduler to use to schedule the Quartz job.  If no scheduler is\n     * configured, the schedular will be retrieved by calling {@link StdSchedulerFactory#getDefaultScheduler()}\n     */\n    private Scheduler scheduler;\n\n    private boolean schedulerImplicitlyCreated = false;\n\n    /**\n     * The session manager used to validate sessions.\n     */\n    private ValidatingSessionManager sessionManager;\n\n    /**\n     * The session validation interval in milliseconds.\n     */\n    private long sessionValidationInterval = DEFAULT_SESSION_VALIDATION_INTERVAL;\n\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /**\n     * Default constructor.\n     */\n    public QuartzSessionValidationScheduler() {\n    }\n\n    /**\n     * Constructor that specifies the session manager that should be used for validating sessions.\n     * @param sessionManager the <tt>SessionManager<\/tt> that should be used to validate sessions.\n     */\n    public QuartzSessionValidationScheduler(ValidatingSessionManager sessionManager) {\n        this.sessionManager = sessionManager;\n    }\n\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    protected Scheduler getScheduler() throws SchedulerException {\n        if( scheduler == null ) {\n            scheduler = StdSchedulerFactory.getDefaultScheduler();\n            schedulerImplicitlyCreated = true;\n        }\n        return scheduler;\n    }\n\n    public void setScheduler(Scheduler scheduler) {\n        this.scheduler = scheduler;\n    }\n\n    public void setSessionManager(ValidatingSessionManager sessionManager) {\n        this.sessionManager = sessionManager;\n    }\n\n\n    public void setSessionValidationInterval(long sessionValidationInterval) {\n        this.sessionValidationInterval = sessionValidationInterval;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    /**\n     * Starts session validation by creating a Quartz simple trigger, linking it to\n     * the {@link QuartzSessionValidationJob}, and scheduling it with the Quartz scheduler.\n     */\n    public void startSessionValidation() {\n\n        if( log.isDebugEnabled() ) {\n            log.debug( \"Scheduling session validation job using Quartz with \" +\n                    \"session validation interval of [\" + sessionValidationInterval + \"]ms...\" );\n        }\n\n        try {\n            SimpleTrigger trigger = new SimpleTrigger( getClass().getName(),\n                                                       Scheduler.DEFAULT_GROUP,\n                                                       SimpleTrigger.REPEAT_INDEFINITELY,\n                                                       sessionValidationInterval );\n\n            JobDetail detail = new JobDetail( JOB_NAME, Scheduler.DEFAULT_GROUP, QuartzSessionValidationJob.class );\n            detail.getJobDataMap().put( QuartzSessionValidationJob.SESSION_MANAGER_KEY, sessionManager );\n\n            Scheduler scheduler = getScheduler();\n\n            scheduler.scheduleJob( detail, trigger );\n            if ( schedulerImplicitlyCreated ) {\n                scheduler.start();\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"Successfully started implicitly created Quartz Scheduler instance.\" );\n                }\n            }\n\n            if( log.isDebugEnabled() ) {\n                log.debug( \"Session validation job successfully scheduled with Quartz.\" );\n            }\n\n        } catch (SchedulerException e) {\n            if (log.isErrorEnabled()) {\n                log.error(\"Error starting the Quartz session validation job.  Session validation may not occur.\", e);\n            }\n        }\n    }\n\n    public void stopSessionValidation() {\n        if( log.isDebugEnabled() ) {\n            log.debug( \"Stopping Quartz session validation job...\" );\n        }\n\n        Scheduler scheduler = null;\n\n        try {\n\n            scheduler = getScheduler();\n\n            scheduler.unscheduleJob( JOB_NAME, Scheduler.DEFAULT_GROUP );\n\n            if( log.isDebugEnabled() ) {\n                log.debug( \"Quartz session validation job stopped successfully.\" );\n            }\n\n        } catch (SchedulerException e) {\n            if( log.isErrorEnabled() ) {\n                log.error( \"Error stopping the Quartz session validation job.\", e );\n            }\n        }\n\n        if ( schedulerImplicitlyCreated && scheduler != null) {\n            try {\n                scheduler.shutdown();\n            } catch ( SchedulerException e ) {\n                if ( log.isErrorEnabled() ) {\n                    log.error( \"Unable to cleanly shutdown implicitly created Quartz Scheduler instance.\", e );\n                }\n            } finally {\n                setScheduler( null );\n                schedulerImplicitlyCreated = false;\n            }\n        }\n\n\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood, Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.session.support.quartz;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.session.support.SessionValidationScheduler;\nimport org.jsecurity.session.support.ValidatingSessionManager;\nimport org.quartz.JobDetail;\nimport org.quartz.Scheduler;\nimport org.quartz.SchedulerException;\nimport org.quartz.SimpleTrigger;\nimport org.quartz.impl.StdSchedulerFactory;\n\n/**\n * An implementation of the {@link SessionValidationScheduler SessionValidationScheduler} that uses Quartz to schedule a\n * job to call {@link org.jsecurity.session.support.ValidatingSessionManager#validateSessions()} on\n * a regular basis.\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class QuartzSessionValidationScheduler implements SessionValidationScheduler {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * The default interval at which sessions will be validated.(5 minutes)\n     * This can be overridden by calling {@link #setSessionValidationInterval(long)}\n     */\n    private static final long DEFAULT_SESSION_VALIDATION_INTERVAL = 300000;\n\n    /**\n     * The name assigned to the quartz job.\n     */\n    private static final String JOB_NAME = \"SessionValidationJob\";\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logging logger\n     */\n    protected final transient Log log = LogFactory.getLog(getClass());\n\n    /**\n     * The configured Quartz scheduler to use to schedule the Quartz job.  If no scheduler is\n     * configured, the schedular will be retrieved by calling {@link StdSchedulerFactory#getDefaultScheduler()}\n     */\n    private Scheduler scheduler;\n\n    /**\n     * The session manager used to validate sessions.\n     */\n    private ValidatingSessionManager sessionManager;\n\n    /**\n     * The session validation interval in milliseconds.\n     */\n    private long sessionValidationInterval = DEFAULT_SESSION_VALIDATION_INTERVAL;\n\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /**\n     * Default constructor.\n     */\n    public QuartzSessionValidationScheduler() {\n    }\n\n    /**\n     * Constructor that specifies the session manager that should be used for validating sessions.\n     * @param sessionManager the <tt>SessionManager<\/tt> that should be used to validate sessions.\n     */\n    public QuartzSessionValidationScheduler(ValidatingSessionManager sessionManager) {\n        this.sessionManager = sessionManager;\n    }\n\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    protected Scheduler getScheduler() throws SchedulerException {\n        if( scheduler == null ) {\n            return StdSchedulerFactory.getDefaultScheduler();\n        } else {\n            return scheduler;\n        }\n    }\n\n    public void setScheduler(Scheduler scheduler) {\n        this.scheduler = scheduler;\n    }\n\n    public void setSessionManager(ValidatingSessionManager sessionManager) {\n        this.sessionManager = sessionManager;\n    }\n\n\n    public void setSessionValidationInterval(long sessionValidationInterval) {\n        this.sessionValidationInterval = sessionValidationInterval;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    /**\n     * Starts session validation by creating a Quartz simple trigger, linking it to\n     * the {@link QuartzSessionValidationJob}, and scheduling it with the Quartz scheduler.\n     */\n    public void startSessionValidation() {\n\n        if( log.isDebugEnabled() ) {\n            log.debug( \"Scheduling session validation job using Quartz with \" +\n                    \"session validation interval of [\" + sessionValidationInterval + \"]ms...\" );\n        }\n\n        try {\n            SimpleTrigger trigger = new SimpleTrigger( getClass().getName(),\n                                                       Scheduler.DEFAULT_GROUP,\n                                                       SimpleTrigger.REPEAT_INDEFINITELY,\n                                                       sessionValidationInterval );\n\n            JobDetail detail = new JobDetail( JOB_NAME, Scheduler.DEFAULT_GROUP, QuartzSessionValidationJob.class );\n            detail.getJobDataMap().put( QuartzSessionValidationJob.SESSION_MANAGER_KEY, sessionManager );\n\n            getScheduler().scheduleJob( detail, trigger );\n            getScheduler().start();\n            \n            if( log.isDebugEnabled() ) {\n                log.debug( \"Session validation job successfully scheduled with Quartz.\" );\n            }\n\n        } catch (SchedulerException e) {\n            if (log.isErrorEnabled()) {\n                log.error(\"Error starting the Quartz session validation job.  Session validation may not occur.\", e);\n            }\n        }\n    }\n\n    public void stopSessionValidation() {\n        if( log.isDebugEnabled() ) {\n            log.debug( \"Stopping Quartz session validation job...\" );\n        }\n\n        try {\n\n            getScheduler().unscheduleJob( JOB_NAME, Scheduler.DEFAULT_GROUP );\n\n            if( log.isDebugEnabled() ) {\n                log.debug( \"Quartz session validation job stopped successfully.\" );\n            }\n\n        } catch (SchedulerException e) {\n            if( log.isErrorEnabled() ) {\n                log.error( \"Error stopping the Quartz session validation job.\", e );\n            }\n        }\n\n\n    }\n}\n","lineNo":157}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood, Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.session.support.quartz;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.session.support.SessionValidationScheduler;\nimport org.jsecurity.session.support.ValidatingSessionManager;\nimport org.quartz.JobDetail;\nimport org.quartz.Scheduler;\nimport org.quartz.SchedulerException;\nimport org.quartz.SimpleTrigger;\nimport org.quartz.impl.StdSchedulerFactory;\n\n/**\n * An implementation of the {@link SessionValidationScheduler SessionValidationScheduler} that uses Quartz to schedule a\n * job to call {@link org.jsecurity.session.support.ValidatingSessionManager#validateSessions()} on\n * a regular basis.\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class QuartzSessionValidationScheduler implements SessionValidationScheduler {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * The default interval at which sessions will be validated.(5 minutes)\n     * This can be overridden by calling {@link #setSessionValidationInterval(long)}\n     */\n    private static final long DEFAULT_SESSION_VALIDATION_INTERVAL = 300000;\n\n    /**\n     * The name assigned to the quartz job.\n     */\n    private static final String JOB_NAME = \"SessionValidationJob\";\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logging logger\n     */\n    protected final transient Log log = LogFactory.getLog(getClass());\n\n    /**\n     * The configured Quartz scheduler to use to schedule the Quartz job.  If no scheduler is\n     * configured, the schedular will be retrieved by calling {@link StdSchedulerFactory#getDefaultScheduler()}\n     */\n    private Scheduler scheduler;\n\n    private boolean schedulerImplicitlyCreated = false;\n\n    /**\n     * The session manager used to validate sessions.\n     */\n    private ValidatingSessionManager sessionManager;\n\n    /**\n     * The session validation interval in milliseconds.\n     */\n    private long sessionValidationInterval = DEFAULT_SESSION_VALIDATION_INTERVAL;\n\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /**\n     * Default constructor.\n     */\n    public QuartzSessionValidationScheduler() {\n    }\n\n    /**\n     * Constructor that specifies the session manager that should be used for validating sessions.\n     * @param sessionManager the <tt>SessionManager<\/tt> that should be used to validate sessions.\n     */\n    public QuartzSessionValidationScheduler(ValidatingSessionManager sessionManager) {\n        this.sessionManager = sessionManager;\n    }\n\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    protected Scheduler getScheduler() throws SchedulerException {\n        if( scheduler == null ) {\n            scheduler = StdSchedulerFactory.getDefaultScheduler();\n            schedulerImplicitlyCreated = true;\n        }\n        return scheduler;\n    }\n\n    public void setScheduler(Scheduler scheduler) {\n        this.scheduler = scheduler;\n    }\n\n    public void setSessionManager(ValidatingSessionManager sessionManager) {\n        this.sessionManager = sessionManager;\n    }\n\n\n    public void setSessionValidationInterval(long sessionValidationInterval) {\n        this.sessionValidationInterval = sessionValidationInterval;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    /**\n     * Starts session validation by creating a Quartz simple trigger, linking it to\n     * the {@link QuartzSessionValidationJob}, and scheduling it with the Quartz scheduler.\n     */\n    public void startSessionValidation() {\n\n        if( log.isDebugEnabled() ) {\n            log.debug( \"Scheduling session validation job using Quartz with \" +\n                    \"session validation interval of [\" + sessionValidationInterval + \"]ms...\" );\n        }\n\n        try {\n            SimpleTrigger trigger = new SimpleTrigger( getClass().getName(),\n                                                       Scheduler.DEFAULT_GROUP,\n                                                       SimpleTrigger.REPEAT_INDEFINITELY,\n                                                       sessionValidationInterval );\n\n            JobDetail detail = new JobDetail( JOB_NAME, Scheduler.DEFAULT_GROUP, QuartzSessionValidationJob.class );\n            detail.getJobDataMap().put( QuartzSessionValidationJob.SESSION_MANAGER_KEY, sessionManager );\n\n            Scheduler scheduler = getScheduler();\n\n            scheduler.scheduleJob( detail, trigger );\n            if ( schedulerImplicitlyCreated ) {\n                scheduler.start();\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"Successfully started implicitly created Quartz Scheduler instance.\" );\n                }\n            }\n\n            if( log.isDebugEnabled() ) {\n                log.debug( \"Session validation job successfully scheduled with Quartz.\" );\n            }\n\n        } catch (SchedulerException e) {\n            if (log.isErrorEnabled()) {\n                log.error(\"Error starting the Quartz session validation job.  Session validation may not occur.\", e);\n            }\n        }\n    }\n\n    public void stopSessionValidation() {\n        if( log.isDebugEnabled() ) {\n            log.debug( \"Stopping Quartz session validation job...\" );\n        }\n\n        Scheduler scheduler = null;\n\n        try {\n\n            scheduler = getScheduler();\n\n            scheduler.unscheduleJob( JOB_NAME, Scheduler.DEFAULT_GROUP );\n\n            if( log.isDebugEnabled() ) {\n                log.debug( \"Quartz session validation job stopped successfully.\" );\n            }\n\n        } catch (SchedulerException e) {\n            if( log.isErrorEnabled() ) {\n                log.error( \"Error stopping the Quartz session validation job.\", e );\n            }\n        }\n\n        if ( schedulerImplicitlyCreated && scheduler != null) {\n            try {\n                scheduler.shutdown();\n            } catch ( SchedulerException e ) {\n                if ( log.isErrorEnabled() ) {\n                    log.error( \"Unable to cleanly shutdown implicitly created Quartz Scheduler instance.\", e );\n                }\n            } finally {\n                setScheduler( null );\n                schedulerImplicitlyCreated = false;\n            }\n        }\n\n\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood, Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.session.support.quartz;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.session.support.SessionValidationScheduler;\nimport org.jsecurity.session.support.ValidatingSessionManager;\nimport org.quartz.JobDetail;\nimport org.quartz.Scheduler;\nimport org.quartz.SchedulerException;\nimport org.quartz.SimpleTrigger;\nimport org.quartz.impl.StdSchedulerFactory;\n\n/**\n * An implementation of the {@link SessionValidationScheduler SessionValidationScheduler} that uses Quartz to schedule a\n * job to call {@link org.jsecurity.session.support.ValidatingSessionManager#validateSessions()} on\n * a regular basis.\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class QuartzSessionValidationScheduler implements SessionValidationScheduler {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * The default interval at which sessions will be validated.(5 minutes)\n     * This can be overridden by calling {@link #setSessionValidationInterval(long)}\n     */\n    private static final long DEFAULT_SESSION_VALIDATION_INTERVAL = 300000;\n\n    /**\n     * The name assigned to the quartz job.\n     */\n    private static final String JOB_NAME = \"SessionValidationJob\";\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logging logger\n     */\n    protected final transient Log log = LogFactory.getLog(getClass());\n\n    /**\n     * The configured Quartz scheduler to use to schedule the Quartz job.  If no scheduler is\n     * configured, the schedular will be retrieved by calling {@link StdSchedulerFactory#getDefaultScheduler()}\n     */\n    private Scheduler scheduler;\n\n    /**\n     * The session manager used to validate sessions.\n     */\n    private ValidatingSessionManager sessionManager;\n\n    /**\n     * The session validation interval in milliseconds.\n     */\n    private long sessionValidationInterval = DEFAULT_SESSION_VALIDATION_INTERVAL;\n\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /**\n     * Default constructor.\n     */\n    public QuartzSessionValidationScheduler() {\n    }\n\n    /**\n     * Constructor that specifies the session manager that should be used for validating sessions.\n     * @param sessionManager the <tt>SessionManager<\/tt> that should be used to validate sessions.\n     */\n    public QuartzSessionValidationScheduler(ValidatingSessionManager sessionManager) {\n        this.sessionManager = sessionManager;\n    }\n\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    protected Scheduler getScheduler() throws SchedulerException {\n        if( scheduler == null ) {\n            return StdSchedulerFactory.getDefaultScheduler();\n        } else {\n            return scheduler;\n        }\n    }\n\n    public void setScheduler(Scheduler scheduler) {\n        this.scheduler = scheduler;\n    }\n\n    public void setSessionManager(ValidatingSessionManager sessionManager) {\n        this.sessionManager = sessionManager;\n    }\n\n\n    public void setSessionValidationInterval(long sessionValidationInterval) {\n        this.sessionValidationInterval = sessionValidationInterval;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    /**\n     * Starts session validation by creating a Quartz simple trigger, linking it to\n     * the {@link QuartzSessionValidationJob}, and scheduling it with the Quartz scheduler.\n     */\n    public void startSessionValidation() {\n\n        if( log.isDebugEnabled() ) {\n            log.debug( \"Scheduling session validation job using Quartz with \" +\n                    \"session validation interval of [\" + sessionValidationInterval + \"]ms...\" );\n        }\n\n        try {\n            SimpleTrigger trigger = new SimpleTrigger( getClass().getName(),\n                                                       Scheduler.DEFAULT_GROUP,\n                                                       SimpleTrigger.REPEAT_INDEFINITELY,\n                                                       sessionValidationInterval );\n\n            JobDetail detail = new JobDetail( JOB_NAME, Scheduler.DEFAULT_GROUP, QuartzSessionValidationJob.class );\n            detail.getJobDataMap().put( QuartzSessionValidationJob.SESSION_MANAGER_KEY, sessionManager );\n\n            getScheduler().scheduleJob( detail, trigger );\n            getScheduler().start();\n            \n            if( log.isDebugEnabled() ) {\n                log.debug( \"Session validation job successfully scheduled with Quartz.\" );\n            }\n\n        } catch (SchedulerException e) {\n            if (log.isErrorEnabled()) {\n                log.error(\"Error starting the Quartz session validation job.  Session validation may not occur.\", e);\n            }\n        }\n    }\n\n    public void stopSessionValidation() {\n        if( log.isDebugEnabled() ) {\n            log.debug( \"Stopping Quartz session validation job...\" );\n        }\n\n        try {\n\n            getScheduler().unscheduleJob( JOB_NAME, Scheduler.DEFAULT_GROUP );\n\n            if( log.isDebugEnabled() ) {\n                log.debug( \"Quartz session validation job stopped successfully.\" );\n            }\n\n        } catch (SchedulerException e) {\n            if( log.isErrorEnabled() ) {\n                log.error( \"Error stopping the Quartz session validation job.\", e );\n            }\n        }\n\n\n    }\n}\n","lineNo":183}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.spring.servlet.security;\n\nimport org.jsecurity.session.Session;\nimport org.jsecurity.web.support.DefaultSessionWebInterceptor;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * Ensures a JSecurity {@link Session Session} exists for an incoming {@link HttpServletRequest}.\n * <p/>\n * <p>If an existing <tt>Session<\/tt> can be found that is already associated with the client\n * executing the <tt>HttpServletRequest<\/tt>, it will be retrieved and made accessible.\n * <p/>\n * <p>If no existing <tt>Session<\/tt> could be associated with the <tt>HttpServletRequest<\/tt>,\n * this interceptor will create a new one, associate it with the <tt>request<\/tt>'s corresponding\n * client, and be made accessible to the JSecurity framework for the duration of the\n * request (i.e. via a {@link ThreadLocal ThreadLocal}).\n *\n * @since 0.1\n * @author Les Hazlewood\n */\npublic class SessionInterceptor extends DefaultSessionWebInterceptor implements HandlerInterceptor, InitializingBean {\n\n    public void afterPropertiesSet() throws Exception {\n        super.init();\n    }\n\n    public boolean preHandle( HttpServletRequest request, HttpServletResponse response,\n                              Object handler ) throws Exception {\n        preHandle( request, response );\n        return true;\n    }\n\n    public void postHandle( HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView ) throws Exception {\n        postHandle( request, response, null );\n    }\n\n    public void afterCompletion( HttpServletRequest request, HttpServletResponse response,\n                                 Object handler, Exception ex ) throws Exception {\n        Session session = null; //set to null explicitly + use type safety so the apropriate method is called at runtime\n        afterCompletion( request, response, session, ex );\n    }\n    \n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.spring.servlet.security;\n\nimport org.jsecurity.session.Session;\nimport org.jsecurity.web.support.DefaultSessionWebInterceptor;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * Ensures a JSecurity {@link Session Session} exists for an incoming {@link HttpServletRequest}.\n * <p/>\n * <p>If an existing <tt>Session<\/tt> can be found that is already associated with the client\n * executing the <tt>HttpServletRequest<\/tt>, it will be retrieved and made accessible.\n * <p/>\n * <p>If no existing <tt>Session<\/tt> could be associated with the <tt>HttpServletRequest<\/tt>,\n * this interceptor will create a new one, associate it with the <tt>request<\/tt>'s corresponding\n * client, and be made accessible to the JSecurity framework for the duration of the\n * request (i.e. via a {@link ThreadLocal ThreadLocal}).\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SessionInterceptor extends DefaultSessionWebInterceptor implements HandlerInterceptor, InitializingBean {\n\n    public void afterPropertiesSet() throws Exception {\n        super.init();\n    }\n\n    public boolean preHandle( HttpServletRequest request, HttpServletResponse response,\n                              Object handler ) throws Exception {\n        super.preHandle( request, response );\n        return true;\n    }\n\n    public void postHandle( HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView ) throws Exception {\n        super.postHandle( request, response, null );\n    }\n\n    public void afterCompletion( HttpServletRequest request, HttpServletResponse response,\n                                 Object handler, Exception ex ) throws Exception {\n        super.afterCompletion( request, response, null, ex );\n    }\n}\n","lineNo":68}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood, Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.spring.remoting;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.support.DelegatingSecurityContext;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.support.SecurityContextWebSupport;\nimport org.springframework.remoting.support.DefaultRemoteInvocationExecutor;\nimport org.springframework.remoting.support.RemoteInvocation;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.security.Principal;\nimport java.util.List;\n\n/**\n * An implementation of the Spring {@link org.springframework.remoting.support.RemoteInvocationExecutor}\n * that binds the correct {@link Session} and {@link org.jsecurity.context.SecurityContext} to the\n * remote invocation thread during a remote execution.\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class SecureRemoteInvocationExecutor extends DefaultRemoteInvocationExecutor {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logger.\n     */\n    protected transient final Log log = LogFactory.getLog( getClass() );\n\n    /**\n     * The realm manager used to retrieve realms that should be associated with the\n     * created authorization contexts upon remote invocation.\n     */\n    private SecurityManager securityManager;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setSecurityManager(SecurityManager securityManager) {\n        this.securityManager = securityManager;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    @SuppressWarnings({\"unchecked\"})\n    public Object invoke(RemoteInvocation invocation, Object targetObject) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n\n        try {\n\n            if( invocation instanceof SecureRemoteInvocation ) {\n                SecureRemoteInvocation secureInvocation = (SecureRemoteInvocation) invocation;\n\n                Serializable sessionId = secureInvocation.getSessionId();\n                Session session = securityManager.getSession( sessionId );\n                ThreadContext.bind( session );\n\n                // Get the principals and realm name from the session\n                List<Principal>principals = (List<Principal>) session.getAttribute( SecurityContextWebSupport.PRINCIPALS_SESSION_KEY );\n\n                // If principals and realm were found in the session, create a delegating authorization context\n                // and bind it to the thread.\n                if( principals != null && !principals.isEmpty() ) {\n                    SecurityContext securityContext = new DelegatingSecurityContext( principals, securityManager );\n                    ThreadContext.bind( securityContext );\n                }\n\n            } else {\n                if( log.isWarnEnabled() ) {\n                    log.warn( \"Secure remote invocation executor used, but did not receive a \" +\n                            \"SecureRemoteInvocation from remote call.  Session will not be propogated to the remote invocation.  \" +\n                            \"Ensure that clients are using a SecureRemoteInvocationFactory to prevent this problem.\" );\n                }\n            }\n\n            return super.invoke(invocation, targetObject);\n        } finally {\n            ThreadContext.unbindSession();\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood, Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.spring.remoting;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.context.support.DelegatingSecurityContext;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadUtils;\nimport org.jsecurity.web.WebUtils;\nimport org.springframework.remoting.support.DefaultRemoteInvocationExecutor;\nimport org.springframework.remoting.support.RemoteInvocation;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.security.Principal;\nimport java.util.List;\n\n/**\n * An implementation of the Spring {@link org.springframework.remoting.support.RemoteInvocationExecutor}\n * that binds the correct {@link Session} and {@link org.jsecurity.context.SecurityContext} to the\n * remote invocation thread during a remote execution.\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class SecureRemoteInvocationExecutor extends DefaultRemoteInvocationExecutor {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logger.\n     */\n    protected transient final Log log = LogFactory.getLog( getClass() );\n\n    /**\n     * The realm manager used to retrieve realms that should be associated with the\n     * created authorization contexts upon remote invocation.\n     */\n    private SecurityManager securityManager;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setSecurityManager(SecurityManager securityManager) {\n        this.securityManager = securityManager;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    @SuppressWarnings({\"unchecked\"})\n    public Object invoke(RemoteInvocation invocation, Object targetObject) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n\n        try {\n\n            if( invocation instanceof SecureRemoteInvocation ) {\n                SecureRemoteInvocation secureInvocation = (SecureRemoteInvocation) invocation;\n\n                Serializable sessionId = secureInvocation.getSessionId();\n                Session session = securityManager.getSession( sessionId );\n                ThreadUtils.bindToThread( session );\n\n                // Get the principals and realm name from the session\n                List<Principal>principals = (List<Principal>) session.getAttribute( WebUtils.PRINCIPALS_SESSION_KEY );\n\n                // If principals and realm were found in the session, create a delegating authorization context\n                // and bind it to the thread.\n                if( principals != null && !principals.isEmpty() ) {\n                    ThreadUtils.bindToThread( new DelegatingSecurityContext( principals, securityManager) );\n                }\n\n            } else {\n                if( log.isWarnEnabled() ) {\n                    log.warn( \"Secure remote invocation executor used, but did not receive a \" +\n                            \"SecureRemoteInvocation from remote call.  Session will not be propogated to the remote invocation.  \" +\n                            \"Ensure that clients are using a SecureRemoteInvocationFactory to prevent this problem.\" );\n                }\n            }\n\n            return super.invoke(invocation, targetObject);\n        } finally {\n            ThreadUtils.unbindSessionFromThread();\n        }\n    }\n}\n","lineNo":105}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile, Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.authc.support;\n\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UnknownAccountException;\nimport org.jsecurity.realm.Realm;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * A <tt>ModularRealmAuthenticator<\/tt> is an {@link org.jsecurity.authc.Authenticator Authenticator}\n * that delgates authentication information lookups to a pluggable (modular) collection of\n * {@link Realm}s.  This enables PAM (Pluggable Authentication Module) behavior in JSecurity\n * for authentication.  For all intents and purposes, a JSecurity Realm can be thought of a PAM 'module'.\n *\n * <p>Using this Authenticator allows you to &quot;plug-in&quot; your own\n * <tt>Realm<\/tt>s as you see fit.  Common realms are those based on accessing\n * LDAP, relational databases, file systems, etc.\n *\n * <p>If only one realm is configured (this is the case for most applications), authentication success is naturally\n * only dependent upon invoking this one Realm's\n * {@link Realm#getAuthenticationInfo(org.jsecurity.authc.AuthenticationToken) getAuthenticationInfo} method (i.e.\n * a null return value means no account could be found, or an AuthenticationException could be thrown, which would be\n * propagated to the caller, etc - see the JavaDoc for more details).\n *\n * <p>But if two or more realms are configured, PAM behavior is implemented by iterating over the collection of realms\n * and interacting with each over the course of the authentication attempt.  As this is more complicated, this\n * authenticator allows customized behavior for interpreting what happens when interacting with multiple realms - for\n * example, you might require all realms to be successful during the attempt, or perhaps only at least one must be\n * successful, or some other interpretation.  This customized behavior can be performed via the use of a\n * {@link #setModularAuthenticationStrategy(ModularAuthenticationStrategy) ModularAuthenticationStrategy}, which\n * you can inject as a property of this class.\n *\n * <p>The strategy object provides callback methods that allow you to\n * determine what constitutes a success or failure in a multi-realm (PAM) scenario.  And because this only makes sense\n * in a mult-realm scenario, the strategy object is only utilized when more than one Realm is configured.\n *\n * <p>For greater security in a multi-realm configuration, unless overridden, the default implementation is the\n * {@link org.jsecurity.authc.support.AllSuccessfulModularAuthenticationStrategy AllSuccessfulModularAuthenticationStrategy}\n *\n * @see #setRealms\n * @see AllSuccessfulModularAuthenticationStrategy\n * @see AtLeastOneSuccessfulModularAuthenticationStrategy\n *\n * @since 0.1\n * @author Jeremy Haile\n * @author Les Hazlewood\n */\npublic class ModularRealmAuthenticator extends AbstractAuthenticator {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * List of realms that will be iterated through when a user authenticates.\n     */\n    private List<? extends Realm> realms;\n\n    protected ModularAuthenticationStrategy modularAuthenticationStrategy =\n        new AllSuccessfulModularAuthenticationStrategy(); //default\n\n\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public ModularRealmAuthenticator() {\n    }\n\n\n    public ModularRealmAuthenticator(SecurityManager securityManager, List<? extends Realm> realms ) {\n        setSecurityManager( securityManager );\n        this.realms = realms;\n    }\n\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    /**\n     * Convenience setter for single-realm environments (fairly common).  This method just wraps the realm in a\n     * collection and then calls {@link #setRealms}.\n     * @param realm the realm to consult during authentication attempts.\n     */\n    public void setRealm( Realm realm ) {\n        List<Realm> realms = new ArrayList<Realm>(1);\n        realms.add( realm );\n        setRealms( realms );\n    }\n\n    /**\n     * Sets all realms used by this Authenticator, providing PAM (Pluggable Authentication Module) configuration.\n     * @param realms the realms to consult during authentication attempts.\n     */\n    public void setRealms( List<Realm> realms ) {\n        this.realms = realms;\n    }\n\n    /**\n     * Returns the <tt>ModularAuthenticationStrategy<\/tt> utilized by this modular authenticator during a multi-realm\n     * log-in attempt.  This object is only used when two or more Realms are configured.\n     *\n     * <p>Unless overridden by\n     * the {@link #setModularAuthenticationStrategy(ModularAuthenticationStrategy)} method, the default implementation\n     * is the {@link org.jsecurity.authc.support.AllSuccessfulModularAuthenticationStrategy}.\n     *\n     * @return the <tt>ModularAuthenticationStrategy<\/tt> utilized by this modular authenticator during a log-in attempt.\n     * @since 0.2\n     */\n    public ModularAuthenticationStrategy getModularAuthenticationStrategy() {\n        return modularAuthenticationStrategy;\n    }\n\n    /**\n     * Allows overriding the default <tt>ModularAuthenticationStrategy<\/tt> utilized during multi-realm log-in attempts.\n     * This object is only used when two or more Realms are configured.\n     *\n     * @param modularAuthenticationStrategy the strategy implementation to use during log-in attempts.\n     * @since 0.2\n     */\n    public void setModularAuthenticationStrategy( ModularAuthenticationStrategy modularAuthenticationStrategy ) {\n        this.modularAuthenticationStrategy = modularAuthenticationStrategy;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Creates an <tt>AuthenticationInfo<\/tt> instance that will be used to aggregate authentication info across\n     * all successfully consulted Realms during a multi-realm log-in attempt.\n     *\n     * <p>It is primarily provided for subclass overriding behavior if necessary - the default implementation only\n     * returns <tt>new SimpleAuthenticationInfo();<\/tt>, which supports merging info objects.\n     *\n     * <p>If this method is overridden to return something <em>other<\/em> than an instance of\n     * <tt>SimpleAuthenticationInfo<\/tt>, then the {@link #merge} method will need to be overridden as well.\n     * Please see that method's JavaDoc for more info.\n     *\n     * @param token the authentication token submitted during the authentication process which may be useful\n     * to subclasses in constructing the returned <tt>AuthenticationInfo<\/tt> instance.\n     * @return an <tt>AuthenticationInfo<\/tt> instance that will be used to aggregate all\n     * <tt>AuthenticationInfo<\/tt> objects returned by all configured <tt>Realm<\/tt>s.\n     */\n    protected AuthenticationInfo createAggregatedAuthenticationInfo( AuthenticationToken token ) {\n        return new SimpleAuthenticationInfo();\n    }\n\n    /**\n     * Merges the <tt>AuthenticationInfo<\/tt> returned from a single realm into the aggregated\n     * <tt>AuthenticationInfo<\/tt> that summarizes all realms in a multi-realm configuration.\n     *\n     * <p>This method is primarily provided as a template method if subclasses wish to override it for custom\n     * merging behavior.\n     *\n     * <p>The default implementation\n     * only checks to see if the <tt>aggregatedInfo<\/tt> parameter is an <tt>instanceof<\/tt>\n     * {@link SimpleAuthenticationInfo}, and if so, calls\n     * <tt>aggregatedInfo.{@link SimpleAuthenticationInfo#merge merge( singleRealmInfo )}<\/tt>, otherwise\n     * nothing occurs.\n     *\n     * @param aggregatedInfo the aggregated info from all realms\n     * @param singleRealmInfo the info provided by a single realm, to be joined with the aggregated info\n     */\n    protected void merge(AuthenticationInfo aggregatedInfo, AuthenticationInfo singleRealmInfo ) {\n        if ( aggregatedInfo instanceof SimpleAuthenticationInfo ) {\n            ((SimpleAuthenticationInfo)aggregatedInfo).merge( singleRealmInfo );\n        }\n    }\n\n    /**\n     * Used by the internal {@link #doAuthenticate} implementation to ensure that the <tt>realms<\/tt> property\n     * has been set.  The default implementation ensures the property is not null and not empty.\n     * @throws IllegalStateException if the <tt>realms<\/tt> property is configured incorrectly.\n     */\n    protected void assertRealmsConfigured() throws IllegalStateException {\n        if ( realms == null || realms.size() <= 0 ) {\n            String msg = \"No realms configured for this ModularRealmAuthenticator.  Configuration error.\";\n            throw new IllegalStateException( msg );\n        }\n    }\n\n    /**\n     * Performs the authentication attempt by interacting with the single configured realm, which is significantly\n     * simpler than performing multi-realm logic.\n     *\n     * @param realm the realm to consult for AuthenticationInfo.\n     * @param token the submitted AuthenticationToken representing the subject's (user's) log-in principals and credentials.\n     * @return the AuthenticationInfo associated with the user account corresponding to the specified <tt>token<\/tt>\n     */\n    protected AuthenticationInfo doSingleRealmAuthentication( Realm realm, AuthenticationToken token ) {\n        if ( !realm.supports( token.getClass() ) ) {\n            String msg = \"Single configured realm [\" + realm + \"] does not support authentication tokens of type [\" +\n                token.getClass().getName() + \"].  Please ensure that the appropriate Realm implementation is \" +\n                \"configured correctly or that the realm accepts AuthenticationTokens of this type.\";\n            throw new UnsupportedTokenException( msg );\n        }\n        AuthenticationInfo info = realm.getAuthenticationInfo( token );\n        if ( info == null ) {\n            String msg = \"Single configured realm [\" + realm + \"] was unable to find account information for the \" +\n                \"submitted AuthenticationToken [\" + token + \"].\";\n            throw new UnknownAccountException( msg );\n        }\n        return info;\n    }\n\n    /**\n     * Performs the multi-realm authentication attempt by calling back to a {@link ModularAuthenticationStrategy} object\n     * as each realm is consulted for <tt>AuthenticationInfo<\/tt> for the specified <tt>token<\/tt>.\n     *\n     * @param realms the multiple realms configured on this Authenticator instance.\n     * @param token the submitted AuthenticationToken representing the subject's (user's) log-in principals and credentials.\n     * @return an aggregated AuthenticationInfo instance representing authentication info across all the successfully\n     * consulted realms.\n     */\n    protected AuthenticationInfo doMultiRealmAuthentication( List<? extends Realm> realms, AuthenticationToken token ) {\n        \n        AuthenticationInfo aggregatedInfo = createAggregatedAuthenticationInfo( token );\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Iterating through [\" + realms.size() + \"] realms for PAM authentication\");\n        }\n\n        for( Realm realm : realms) {\n\n            modularAuthenticationStrategy.beforeAttempt( realm, token );\n\n            if( realm.supports( token.getClass() ) ) {\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Attempting to authenticate token [\" + token + \"] \" +\n                        \"using realm of type [\" + realm.getClass() + \"]\");\n                }\n\n                AuthenticationInfo realmInfo = null;\n                Throwable t = null;\n                try {\n                    realmInfo = realm.getAuthenticationInfo( token );\n                } catch ( Throwable throwable ) {\n                    t = throwable;\n                    if ( log.isTraceEnabled() ) {\n                        String msg = \"Realm [\" + realm + \"] threw an exception during a multi-realm authentication attempt:\";\n                        log.trace( msg, t );\n                    }\n                }\n\n                modularAuthenticationStrategy.afterAttempt( realm, token, realmInfo, t );\n\n                // If non-null info is returned, then the realm was able to authenticate the\n                // user - so merge the info with any accumulated before:\n                if( realmInfo != null ) {\n\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Account successfully authenticated using realm of type [\" +\n                            realm.getClass().getName() + \"]\");\n                    }\n\n                    // Merge the module-returned data with the aggregate data\n                    merge( aggregatedInfo, realmInfo );\n\n                }\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Realm of type [\" + realm.getClass().getName() + \"] does not support token \" +\n                            \"of type [\" + token.getClass().getName() + \"].  Skipping realm.\" );\n                }\n            }\n        }\n\n        modularAuthenticationStrategy.afterAllAttempts( token, aggregatedInfo );\n\n        return aggregatedInfo;\n    }\n\n\n    /**\n     * <p>Attempts to authenticate the given token by iterating over the internal collection of\n     * {@link Realm}s.  For each realm, first the {@link Realm#supports(Class)}\n     * method will be called to determine if the realm supports the <tt>authenticationToken<\/tt> method argument.\n     *\n     * If a realm does support\n     * the token, its {@link Realm#getAuthenticationInfo(org.jsecurity.authc.AuthenticationToken)}\n     * method will be called.  If the realm returns non-null authentication information, the token will be\n     * considered authenticated and the authentication info recorded.  If the realm returns <tt>null<\/tt>, the next\n     * realm will be consulted.  If no realms support the token or all supported realms return null,\n     * an {@link AuthenticationException} will be thrown to indicate that the user could not be authenticated.\n     *\n     * <p>After all realms have been consulted, the information from each realm is aggregated into a single\n     * {@link AuthenticationInfo} object and returned.\n     *\n     * @param authenticationToken the token containing the authentication principal and credentials for the\n     * user being authenticated.\n     * @return account information attributed to the authenticated user.\n     * @throws AuthenticationException if the user could not be authenticated or the user is denied authentication\n     * for the given principal and credentials.\n     */\n    protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException {\n\n        assertRealmsConfigured();\n\n        if ( realms.size() == 1 ) {\n            return doSingleRealmAuthentication( realms.get( 0 ), authenticationToken );\n        } else {\n            return doMultiRealmAuthentication( realms, authenticationToken );\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile, Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.authc.support;\n\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.realm.Realm;\n\nimport java.util.List;\n\n/**\n * A <tt>ModularRealmAuthenticator<\/tt> is an {@link org.jsecurity.authc.Authenticator Authenticator}\n * that delgates authentication duties to a pluggable (modular) collection of\n * {@link Realm}s.  This enables PAM (Pluggable Authentication Module) behavior in JSecurity\n * for authentication.  For all intents and purposes, a JSecurity Realm can be thought of a PAM 'module'.\n *\n * <p>Using this Authenticator allows you to &quot;plug-in&quot; your own\n * <tt>Realm<\/tt>s as you see fit.  Common realms are those based on accessing\n * LDAP, relational databases, file systems, etc.\n *\n * @see #setRealms\n *\n * @since 0.1\n * @author Jeremy Haile\n * @author Les Hazlewood\n */\npublic class ModularRealmAuthenticator extends AbstractAuthenticator {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * List of realms that will be iterated through when a user authenticates.\n     */\n    private List<? extends Realm> realms;\n\n\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public ModularRealmAuthenticator() {\n    }\n\n\n    public ModularRealmAuthenticator(SecurityManager securityManager, List<? extends Realm> realms ) {\n        setSecurityManager( securityManager );\n        this.realms = realms;\n    }\n\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setRealms( List<Realm> realms ) {\n        this.realms = realms;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Provided for subclass overriding behavior if necessary.\n     * \n     * <p>Default implementation only returns <tt>new SimpleAuthenticationInfo();<\/tt>.\n     *\n     * <p>If this method is overridden to _not_ return an instance of <tt>SimpleAuthenticationInfo<\/tt>,\n     * then the {@link #merge} method will need to be overridden as well.  Please see that method's JavaDoc\n     * for more info.\n     *\n     * @param token the authentication token submitted during the authentication process which may be useful\n     * to subclasses in constructing the returned <tt>AuthenticationInfo<\/tt> instance.\n     * @return an <tt>AuthenticationInfo<\/tt> instance that will be used to aggregate all\n     * <tt>AuthenticationInfo<\/tt> objects returned by all configured <tt>Realm<\/tt>s.\n     */\n    protected AuthenticationInfo createAggregatedAuthenticationInfo( AuthenticationToken token ) {\n        return new SimpleAuthenticationInfo();\n    }\n\n    /**\n     * Merges the <tt>AuthenticationInfo<\/tt> returned from a single realm into the aggregated\n     * <tt>AuthenticationInfo<\/tt> that summarizes all realms.\n     *\n     * <p>This method is primarily provided as a template method if subclasses wish to override it for custom\n     * merging behavior.\n     *\n     * <p>The default implementation\n     * only checks to see if the <tt>aggregatedInfo<\/tt> parameter is an <tt>instanceof<\/tt>\n     * {@link SimpleAuthenticationInfo}, and if so, calls\n     * <tt>aggregatedInfo.{@link SimpleAuthenticationInfo#merge merge( singleRealmInfo )}<\/tt>, otherwise\n     * nothing occurs.\n     *\n     * @param aggregatedInfo the aggregated info from all realms\n     * @param singleRealmInfo the info provided by a single realm, to be joined with the aggregated info\n     */\n    protected void merge(AuthenticationInfo aggregatedInfo, AuthenticationInfo singleRealmInfo ) {\n        if ( aggregatedInfo instanceof SimpleAuthenticationInfo ) {\n            ((SimpleAuthenticationInfo)aggregatedInfo).merge( singleRealmInfo );\n        }\n    }\n\n    /**\n     * Used by the internal {@link #doAuthenticate} implementation to ensure that the <tt>realms<\/tt> property\n     * has been set.  The default implementation ensures the property is not null and not empty.\n     * @throws IllegalStateException if the <tt>realms<\/tt> property is configured incorrectly.\n     */\n    protected void assertRealmsConfigured() throws IllegalStateException {\n        if ( realms == null || realms.size() <= 0 ) {\n            String msg = \"No realms configured for this ModularRealmAuthenticator.  Configuration error.\";\n            throw new IllegalStateException( msg );\n        }\n    }\n\n    /**\n     * This is a final 'housekeeping' method that is called after all realms have been consulted during the\n     * authentication attempt for the specified token.\n     *\n     * <p>The default implementation only verifies that one or more realms successfully retrieved AuthenticationInfo\n     * for the specified <tt>AuthenticationToken<\/tt> (i.e. <tt>oneOrMoreSuccessful == true<\/tt>).  If so, it just\n     * returns the <tt>aggregated<\/tt> argument.  If not, it throws an AuthenticationException stating that no realms\n     * could authenticate the token.  Subclasses may override this method for more custom behavior, but a\n     * non-null value must be returned (otherwise the authentication attempt is considered to be failed and an\n     * exception will be thrown).\n     *\n     * @param oneOrMoreSuccessful specifies if one or more <tt>Realm<\/tt>s were able to obtain\n     * <tt>AuthenticationInfo<\/tt> for the specified token\n     * @param authenticationToken the token submitted during the login process that encapsulates the user's\n     * principals and credentials.\n     * @param aggregated the aggregated <tt>AuthenticationInfo<\/tt> data from all realms that processed the token\n     * during the authentication attempt.\n     * @return the realms' <tt>AuthenticationInfo<\/tt> for the given token\n     * @throws AuthenticationException if no realms could associate any <tt>AuthenticationInfo<\/tt> with the token\n     */\n    protected AuthenticationInfo realmsComplete( boolean oneOrMoreSuccessful, AuthenticationToken authenticationToken,\n                                                  AuthenticationInfo aggregated ) throws AuthenticationException {\n        // If no realm authenticated the user, throw an exception\n        if( !oneOrMoreSuccessful ) {\n            throw new AuthenticationException( \"Authentication token of type [\" + authenticationToken.getClass() + \"] \" +\n                \"could not be authenticated by any configured realms.  Check that this authenticator is configured \" +\n                \"with appropriate realms.\" );\n        } else {\n            return aggregated;\n        }\n    }\n\n\n    /**\n     * <p>Attempts to authenticate the given token by iterating over the internal collection of\n     * {@link Realm}s.  For each realm, first the {@link Realm#supports(Class)}\n     * method will be called to determine if the realm supports the <tt>authenticationToken<\/tt> method argument.\n     *\n     * If a realm does support\n     * the token, its {@link Realm#getAuthenticationInfo(org.jsecurity.authc.AuthenticationToken)}\n     * method will be called.  If the realm returns non-null authentication information, the token will be\n     * considered authenticated and the authentication info recorded.  If the realm returns <tt>null<\/tt>, the next\n     * realm will be consulted.  If no realms support the token or all supported realms return null,\n     * an {@link AuthenticationException} will be thrown to indicate that the user could not be authenticated.\n     *\n     * <p>After all realms have been consulted, the information from each realm is aggregated into a single\n     * {@link AuthenticationInfo} object and returned.\n     *\n     * @param authenticationToken the token containing the authentication principal and credentials for the\n     * user being authenticated.\n     * @return account information attributed to the authenticated user.\n     * @throws AuthenticationException if the user could not be authenticated or the user is denied authentication\n     * for the given principal and credentials.\n     */\n    protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException {\n\n        assertRealmsConfigured();\n\n        AuthenticationInfo aggregatedInfo = createAggregatedAuthenticationInfo( authenticationToken );\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Iterating through [\" + realms.size() + \"] realms\");\n        }\n\n        boolean authenticated = false;\n        for( Realm realm : realms) {\n\n            if( realm.supports( authenticationToken.getClass() ) ) {\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Attempting to authenticate token [\" + authenticationToken + \"] \" +\n                        \"using realm of type [\" + realm.getClass() + \"]\");\n                }\n\n                AuthenticationInfo realmInfo = realm.getAuthenticationInfo( authenticationToken );\n\n                // If non-null info is returned, then the realm was able to authenticate the\n                // user - so return the context.\n                if( realmInfo != null ) {\n\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Account authenticated using realm of type [\" + realm.getClass().getName() + \"]\");\n                    }\n\n                    // Merge the module-returned data with the aggregate data\n                    merge( aggregatedInfo, realmInfo );\n                    authenticated = true;\n\n                }\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Realm of type [\" + realm.getClass().getName() + \"] does not support token \" +\n                            \"of type [\" + authenticationToken.getClass().getName() + \"].  Skipping realm.\" );\n                }\n            }\n        }\n\n        AuthenticationInfo info = realmsComplete( authenticated, authenticationToken, aggregatedInfo );\n        if ( info == null ) {\n            throw new AuthenticationException( \"Authentication token of type [\" + authenticationToken.getClass() + \"] \" +\n                \"could not be authenticated by any configured realms.  Check that this authenticator is configured \" +\n                \"with appropriate realms.\" );\n        }\n\n        return info;\n    }\n}\n","lineNo":224}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile, Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.authc.support;\n\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UnknownAccountException;\nimport org.jsecurity.realm.Realm;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * A <tt>ModularRealmAuthenticator<\/tt> is an {@link org.jsecurity.authc.Authenticator Authenticator}\n * that delgates authentication information lookups to a pluggable (modular) collection of\n * {@link Realm}s.  This enables PAM (Pluggable Authentication Module) behavior in JSecurity\n * for authentication.  For all intents and purposes, a JSecurity Realm can be thought of a PAM 'module'.\n *\n * <p>Using this Authenticator allows you to &quot;plug-in&quot; your own\n * <tt>Realm<\/tt>s as you see fit.  Common realms are those based on accessing\n * LDAP, relational databases, file systems, etc.\n *\n * <p>If only one realm is configured (this is the case for most applications), authentication success is naturally\n * only dependent upon invoking this one Realm's\n * {@link Realm#getAuthenticationInfo(org.jsecurity.authc.AuthenticationToken) getAuthenticationInfo} method (i.e.\n * a null return value means no account could be found, or an AuthenticationException could be thrown, which would be\n * propagated to the caller, etc - see the JavaDoc for more details).\n *\n * <p>But if two or more realms are configured, PAM behavior is implemented by iterating over the collection of realms\n * and interacting with each over the course of the authentication attempt.  As this is more complicated, this\n * authenticator allows customized behavior for interpreting what happens when interacting with multiple realms - for\n * example, you might require all realms to be successful during the attempt, or perhaps only at least one must be\n * successful, or some other interpretation.  This customized behavior can be performed via the use of a\n * {@link #setModularAuthenticationStrategy(ModularAuthenticationStrategy) ModularAuthenticationStrategy}, which\n * you can inject as a property of this class.\n *\n * <p>The strategy object provides callback methods that allow you to\n * determine what constitutes a success or failure in a multi-realm (PAM) scenario.  And because this only makes sense\n * in a mult-realm scenario, the strategy object is only utilized when more than one Realm is configured.\n *\n * <p>For greater security in a multi-realm configuration, unless overridden, the default implementation is the\n * {@link org.jsecurity.authc.support.AllSuccessfulModularAuthenticationStrategy AllSuccessfulModularAuthenticationStrategy}\n *\n * @see #setRealms\n * @see AllSuccessfulModularAuthenticationStrategy\n * @see AtLeastOneSuccessfulModularAuthenticationStrategy\n *\n * @since 0.1\n * @author Jeremy Haile\n * @author Les Hazlewood\n */\npublic class ModularRealmAuthenticator extends AbstractAuthenticator {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * List of realms that will be iterated through when a user authenticates.\n     */\n    private List<? extends Realm> realms;\n\n    protected ModularAuthenticationStrategy modularAuthenticationStrategy =\n        new AllSuccessfulModularAuthenticationStrategy(); //default\n\n\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public ModularRealmAuthenticator() {\n    }\n\n\n    public ModularRealmAuthenticator(SecurityManager securityManager, List<? extends Realm> realms ) {\n        setSecurityManager( securityManager );\n        this.realms = realms;\n    }\n\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    /**\n     * Convenience setter for single-realm environments (fairly common).  This method just wraps the realm in a\n     * collection and then calls {@link #setRealms}.\n     * @param realm the realm to consult during authentication attempts.\n     */\n    public void setRealm( Realm realm ) {\n        List<Realm> realms = new ArrayList<Realm>(1);\n        realms.add( realm );\n        setRealms( realms );\n    }\n\n    /**\n     * Sets all realms used by this Authenticator, providing PAM (Pluggable Authentication Module) configuration.\n     * @param realms the realms to consult during authentication attempts.\n     */\n    public void setRealms( List<Realm> realms ) {\n        this.realms = realms;\n    }\n\n    /**\n     * Returns the <tt>ModularAuthenticationStrategy<\/tt> utilized by this modular authenticator during a multi-realm\n     * log-in attempt.  This object is only used when two or more Realms are configured.\n     *\n     * <p>Unless overridden by\n     * the {@link #setModularAuthenticationStrategy(ModularAuthenticationStrategy)} method, the default implementation\n     * is the {@link org.jsecurity.authc.support.AllSuccessfulModularAuthenticationStrategy}.\n     *\n     * @return the <tt>ModularAuthenticationStrategy<\/tt> utilized by this modular authenticator during a log-in attempt.\n     * @since 0.2\n     */\n    public ModularAuthenticationStrategy getModularAuthenticationStrategy() {\n        return modularAuthenticationStrategy;\n    }\n\n    /**\n     * Allows overriding the default <tt>ModularAuthenticationStrategy<\/tt> utilized during multi-realm log-in attempts.\n     * This object is only used when two or more Realms are configured.\n     *\n     * @param modularAuthenticationStrategy the strategy implementation to use during log-in attempts.\n     * @since 0.2\n     */\n    public void setModularAuthenticationStrategy( ModularAuthenticationStrategy modularAuthenticationStrategy ) {\n        this.modularAuthenticationStrategy = modularAuthenticationStrategy;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Creates an <tt>AuthenticationInfo<\/tt> instance that will be used to aggregate authentication info across\n     * all successfully consulted Realms during a multi-realm log-in attempt.\n     *\n     * <p>It is primarily provided for subclass overriding behavior if necessary - the default implementation only\n     * returns <tt>new SimpleAuthenticationInfo();<\/tt>, which supports merging info objects.\n     *\n     * <p>If this method is overridden to return something <em>other<\/em> than an instance of\n     * <tt>SimpleAuthenticationInfo<\/tt>, then the {@link #merge} method will need to be overridden as well.\n     * Please see that method's JavaDoc for more info.\n     *\n     * @param token the authentication token submitted during the authentication process which may be useful\n     * to subclasses in constructing the returned <tt>AuthenticationInfo<\/tt> instance.\n     * @return an <tt>AuthenticationInfo<\/tt> instance that will be used to aggregate all\n     * <tt>AuthenticationInfo<\/tt> objects returned by all configured <tt>Realm<\/tt>s.\n     */\n    protected AuthenticationInfo createAggregatedAuthenticationInfo( AuthenticationToken token ) {\n        return new SimpleAuthenticationInfo();\n    }\n\n    /**\n     * Merges the <tt>AuthenticationInfo<\/tt> returned from a single realm into the aggregated\n     * <tt>AuthenticationInfo<\/tt> that summarizes all realms in a multi-realm configuration.\n     *\n     * <p>This method is primarily provided as a template method if subclasses wish to override it for custom\n     * merging behavior.\n     *\n     * <p>The default implementation\n     * only checks to see if the <tt>aggregatedInfo<\/tt> parameter is an <tt>instanceof<\/tt>\n     * {@link SimpleAuthenticationInfo}, and if so, calls\n     * <tt>aggregatedInfo.{@link SimpleAuthenticationInfo#merge merge( singleRealmInfo )}<\/tt>, otherwise\n     * nothing occurs.\n     *\n     * @param aggregatedInfo the aggregated info from all realms\n     * @param singleRealmInfo the info provided by a single realm, to be joined with the aggregated info\n     */\n    protected void merge(AuthenticationInfo aggregatedInfo, AuthenticationInfo singleRealmInfo ) {\n        if ( aggregatedInfo instanceof SimpleAuthenticationInfo ) {\n            ((SimpleAuthenticationInfo)aggregatedInfo).merge( singleRealmInfo );\n        }\n    }\n\n    /**\n     * Used by the internal {@link #doAuthenticate} implementation to ensure that the <tt>realms<\/tt> property\n     * has been set.  The default implementation ensures the property is not null and not empty.\n     * @throws IllegalStateException if the <tt>realms<\/tt> property is configured incorrectly.\n     */\n    protected void assertRealmsConfigured() throws IllegalStateException {\n        if ( realms == null || realms.size() <= 0 ) {\n            String msg = \"No realms configured for this ModularRealmAuthenticator.  Configuration error.\";\n            throw new IllegalStateException( msg );\n        }\n    }\n\n    /**\n     * Performs the authentication attempt by interacting with the single configured realm, which is significantly\n     * simpler than performing multi-realm logic.\n     *\n     * @param realm the realm to consult for AuthenticationInfo.\n     * @param token the submitted AuthenticationToken representing the subject's (user's) log-in principals and credentials.\n     * @return the AuthenticationInfo associated with the user account corresponding to the specified <tt>token<\/tt>\n     */\n    protected AuthenticationInfo doSingleRealmAuthentication( Realm realm, AuthenticationToken token ) {\n        if ( !realm.supports( token.getClass() ) ) {\n            String msg = \"Single configured realm [\" + realm + \"] does not support authentication tokens of type [\" +\n                token.getClass().getName() + \"].  Please ensure that the appropriate Realm implementation is \" +\n                \"configured correctly or that the realm accepts AuthenticationTokens of this type.\";\n            throw new UnsupportedTokenException( msg );\n        }\n        AuthenticationInfo info = realm.getAuthenticationInfo( token );\n        if ( info == null ) {\n            String msg = \"Single configured realm [\" + realm + \"] was unable to find account information for the \" +\n                \"submitted AuthenticationToken [\" + token + \"].\";\n            throw new UnknownAccountException( msg );\n        }\n        return info;\n    }\n\n    /**\n     * Performs the multi-realm authentication attempt by calling back to a {@link ModularAuthenticationStrategy} object\n     * as each realm is consulted for <tt>AuthenticationInfo<\/tt> for the specified <tt>token<\/tt>.\n     *\n     * @param realms the multiple realms configured on this Authenticator instance.\n     * @param token the submitted AuthenticationToken representing the subject's (user's) log-in principals and credentials.\n     * @return an aggregated AuthenticationInfo instance representing authentication info across all the successfully\n     * consulted realms.\n     */\n    protected AuthenticationInfo doMultiRealmAuthentication( List<? extends Realm> realms, AuthenticationToken token ) {\n        \n        AuthenticationInfo aggregatedInfo = createAggregatedAuthenticationInfo( token );\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Iterating through [\" + realms.size() + \"] realms for PAM authentication\");\n        }\n\n        for( Realm realm : realms) {\n\n            modularAuthenticationStrategy.beforeAttempt( realm, token );\n\n            if( realm.supports( token.getClass() ) ) {\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Attempting to authenticate token [\" + token + \"] \" +\n                        \"using realm of type [\" + realm.getClass() + \"]\");\n                }\n\n                AuthenticationInfo realmInfo = null;\n                Throwable t = null;\n                try {\n                    realmInfo = realm.getAuthenticationInfo( token );\n                } catch ( Throwable throwable ) {\n                    t = throwable;\n                    if ( log.isTraceEnabled() ) {\n                        String msg = \"Realm [\" + realm + \"] threw an exception during a multi-realm authentication attempt:\";\n                        log.trace( msg, t );\n                    }\n                }\n\n                modularAuthenticationStrategy.afterAttempt( realm, token, realmInfo, t );\n\n                // If non-null info is returned, then the realm was able to authenticate the\n                // user - so merge the info with any accumulated before:\n                if( realmInfo != null ) {\n\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Account successfully authenticated using realm of type [\" +\n                            realm.getClass().getName() + \"]\");\n                    }\n\n                    // Merge the module-returned data with the aggregate data\n                    merge( aggregatedInfo, realmInfo );\n\n                }\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Realm of type [\" + realm.getClass().getName() + \"] does not support token \" +\n                            \"of type [\" + token.getClass().getName() + \"].  Skipping realm.\" );\n                }\n            }\n        }\n\n        modularAuthenticationStrategy.afterAllAttempts( token, aggregatedInfo );\n\n        return aggregatedInfo;\n    }\n\n\n    /**\n     * <p>Attempts to authenticate the given token by iterating over the internal collection of\n     * {@link Realm}s.  For each realm, first the {@link Realm#supports(Class)}\n     * method will be called to determine if the realm supports the <tt>authenticationToken<\/tt> method argument.\n     *\n     * If a realm does support\n     * the token, its {@link Realm#getAuthenticationInfo(org.jsecurity.authc.AuthenticationToken)}\n     * method will be called.  If the realm returns non-null authentication information, the token will be\n     * considered authenticated and the authentication info recorded.  If the realm returns <tt>null<\/tt>, the next\n     * realm will be consulted.  If no realms support the token or all supported realms return null,\n     * an {@link AuthenticationException} will be thrown to indicate that the user could not be authenticated.\n     *\n     * <p>After all realms have been consulted, the information from each realm is aggregated into a single\n     * {@link AuthenticationInfo} object and returned.\n     *\n     * @param authenticationToken the token containing the authentication principal and credentials for the\n     * user being authenticated.\n     * @return account information attributed to the authenticated user.\n     * @throws AuthenticationException if the user could not be authenticated or the user is denied authentication\n     * for the given principal and credentials.\n     */\n    protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException {\n\n        assertRealmsConfigured();\n\n        if ( realms.size() == 1 ) {\n            return doSingleRealmAuthentication( realms.get( 0 ), authenticationToken );\n        } else {\n            return doMultiRealmAuthentication( realms, authenticationToken );\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile, Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.authc.support;\n\nimport org.jsecurity.SecurityManager;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.realm.Realm;\n\nimport java.util.List;\n\n/**\n * A <tt>ModularRealmAuthenticator<\/tt> is an {@link org.jsecurity.authc.Authenticator Authenticator}\n * that delgates authentication duties to a pluggable (modular) collection of\n * {@link Realm}s.  This enables PAM (Pluggable Authentication Module) behavior in JSecurity\n * for authentication.  For all intents and purposes, a JSecurity Realm can be thought of a PAM 'module'.\n *\n * <p>Using this Authenticator allows you to &quot;plug-in&quot; your own\n * <tt>Realm<\/tt>s as you see fit.  Common realms are those based on accessing\n * LDAP, relational databases, file systems, etc.\n *\n * @see #setRealms\n *\n * @since 0.1\n * @author Jeremy Haile\n * @author Les Hazlewood\n */\npublic class ModularRealmAuthenticator extends AbstractAuthenticator {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * List of realms that will be iterated through when a user authenticates.\n     */\n    private List<? extends Realm> realms;\n\n\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public ModularRealmAuthenticator() {\n    }\n\n\n    public ModularRealmAuthenticator(SecurityManager securityManager, List<? extends Realm> realms ) {\n        setSecurityManager( securityManager );\n        this.realms = realms;\n    }\n\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setRealms( List<Realm> realms ) {\n        this.realms = realms;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Provided for subclass overriding behavior if necessary.\n     * \n     * <p>Default implementation only returns <tt>new SimpleAuthenticationInfo();<\/tt>.\n     *\n     * <p>If this method is overridden to _not_ return an instance of <tt>SimpleAuthenticationInfo<\/tt>,\n     * then the {@link #merge} method will need to be overridden as well.  Please see that method's JavaDoc\n     * for more info.\n     *\n     * @param token the authentication token submitted during the authentication process which may be useful\n     * to subclasses in constructing the returned <tt>AuthenticationInfo<\/tt> instance.\n     * @return an <tt>AuthenticationInfo<\/tt> instance that will be used to aggregate all\n     * <tt>AuthenticationInfo<\/tt> objects returned by all configured <tt>Realm<\/tt>s.\n     */\n    protected AuthenticationInfo createAggregatedAuthenticationInfo( AuthenticationToken token ) {\n        return new SimpleAuthenticationInfo();\n    }\n\n    /**\n     * Merges the <tt>AuthenticationInfo<\/tt> returned from a single realm into the aggregated\n     * <tt>AuthenticationInfo<\/tt> that summarizes all realms.\n     *\n     * <p>This method is primarily provided as a template method if subclasses wish to override it for custom\n     * merging behavior.\n     *\n     * <p>The default implementation\n     * only checks to see if the <tt>aggregatedInfo<\/tt> parameter is an <tt>instanceof<\/tt>\n     * {@link SimpleAuthenticationInfo}, and if so, calls\n     * <tt>aggregatedInfo.{@link SimpleAuthenticationInfo#merge merge( singleRealmInfo )}<\/tt>, otherwise\n     * nothing occurs.\n     *\n     * @param aggregatedInfo the aggregated info from all realms\n     * @param singleRealmInfo the info provided by a single realm, to be joined with the aggregated info\n     */\n    protected void merge(AuthenticationInfo aggregatedInfo, AuthenticationInfo singleRealmInfo ) {\n        if ( aggregatedInfo instanceof SimpleAuthenticationInfo ) {\n            ((SimpleAuthenticationInfo)aggregatedInfo).merge( singleRealmInfo );\n        }\n    }\n\n    /**\n     * Used by the internal {@link #doAuthenticate} implementation to ensure that the <tt>realms<\/tt> property\n     * has been set.  The default implementation ensures the property is not null and not empty.\n     * @throws IllegalStateException if the <tt>realms<\/tt> property is configured incorrectly.\n     */\n    protected void assertRealmsConfigured() throws IllegalStateException {\n        if ( realms == null || realms.size() <= 0 ) {\n            String msg = \"No realms configured for this ModularRealmAuthenticator.  Configuration error.\";\n            throw new IllegalStateException( msg );\n        }\n    }\n\n    /**\n     * This is a final 'housekeeping' method that is called after all realms have been consulted during the\n     * authentication attempt for the specified token.\n     *\n     * <p>The default implementation only verifies that one or more realms successfully retrieved AuthenticationInfo\n     * for the specified <tt>AuthenticationToken<\/tt> (i.e. <tt>oneOrMoreSuccessful == true<\/tt>).  If so, it just\n     * returns the <tt>aggregated<\/tt> argument.  If not, it throws an AuthenticationException stating that no realms\n     * could authenticate the token.  Subclasses may override this method for more custom behavior, but a\n     * non-null value must be returned (otherwise the authentication attempt is considered to be failed and an\n     * exception will be thrown).\n     *\n     * @param oneOrMoreSuccessful specifies if one or more <tt>Realm<\/tt>s were able to obtain\n     * <tt>AuthenticationInfo<\/tt> for the specified token\n     * @param authenticationToken the token submitted during the login process that encapsulates the user's\n     * principals and credentials.\n     * @param aggregated the aggregated <tt>AuthenticationInfo<\/tt> data from all realms that processed the token\n     * during the authentication attempt.\n     * @return the realms' <tt>AuthenticationInfo<\/tt> for the given token\n     * @throws AuthenticationException if no realms could associate any <tt>AuthenticationInfo<\/tt> with the token\n     */\n    protected AuthenticationInfo realmsComplete( boolean oneOrMoreSuccessful, AuthenticationToken authenticationToken,\n                                                  AuthenticationInfo aggregated ) throws AuthenticationException {\n        // If no realm authenticated the user, throw an exception\n        if( !oneOrMoreSuccessful ) {\n            throw new AuthenticationException( \"Authentication token of type [\" + authenticationToken.getClass() + \"] \" +\n                \"could not be authenticated by any configured realms.  Check that this authenticator is configured \" +\n                \"with appropriate realms.\" );\n        } else {\n            return aggregated;\n        }\n    }\n\n\n    /**\n     * <p>Attempts to authenticate the given token by iterating over the internal collection of\n     * {@link Realm}s.  For each realm, first the {@link Realm#supports(Class)}\n     * method will be called to determine if the realm supports the <tt>authenticationToken<\/tt> method argument.\n     *\n     * If a realm does support\n     * the token, its {@link Realm#getAuthenticationInfo(org.jsecurity.authc.AuthenticationToken)}\n     * method will be called.  If the realm returns non-null authentication information, the token will be\n     * considered authenticated and the authentication info recorded.  If the realm returns <tt>null<\/tt>, the next\n     * realm will be consulted.  If no realms support the token or all supported realms return null,\n     * an {@link AuthenticationException} will be thrown to indicate that the user could not be authenticated.\n     *\n     * <p>After all realms have been consulted, the information from each realm is aggregated into a single\n     * {@link AuthenticationInfo} object and returned.\n     *\n     * @param authenticationToken the token containing the authentication principal and credentials for the\n     * user being authenticated.\n     * @return account information attributed to the authenticated user.\n     * @throws AuthenticationException if the user could not be authenticated or the user is denied authentication\n     * for the given principal and credentials.\n     */\n    protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException {\n\n        assertRealmsConfigured();\n\n        AuthenticationInfo aggregatedInfo = createAggregatedAuthenticationInfo( authenticationToken );\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Iterating through [\" + realms.size() + \"] realms\");\n        }\n\n        boolean authenticated = false;\n        for( Realm realm : realms) {\n\n            if( realm.supports( authenticationToken.getClass() ) ) {\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Attempting to authenticate token [\" + authenticationToken + \"] \" +\n                        \"using realm of type [\" + realm.getClass() + \"]\");\n                }\n\n                AuthenticationInfo realmInfo = realm.getAuthenticationInfo( authenticationToken );\n\n                // If non-null info is returned, then the realm was able to authenticate the\n                // user - so return the context.\n                if( realmInfo != null ) {\n\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Account authenticated using realm of type [\" + realm.getClass().getName() + \"]\");\n                    }\n\n                    // Merge the module-returned data with the aggregate data\n                    merge( aggregatedInfo, realmInfo );\n                    authenticated = true;\n\n                }\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Realm of type [\" + realm.getClass().getName() + \"] does not support token \" +\n                            \"of type [\" + authenticationToken.getClass().getName() + \"].  Skipping realm.\" );\n                }\n            }\n        }\n\n        AuthenticationInfo info = realmsComplete( authenticated, authenticationToken, aggregatedInfo );\n        if ( info == null ) {\n            throw new AuthenticationException( \"Authentication token of type [\" + authenticationToken.getClass() + \"] \" +\n                \"could not be authenticated by any configured realms.  Check that this authenticator is configured \" +\n                \"with appropriate realms.\" );\n        }\n\n        return info;\n    }\n}\n","lineNo":231}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.session.support;\n\nimport org.jsecurity.session.ExpiredSessionException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.support.eis.SessionDAO;\nimport org.jsecurity.session.support.eis.ehcache.EhcacheSessionDAO;\nimport org.jsecurity.session.support.eis.support.MemorySessionDAO;\nimport org.jsecurity.session.support.quartz.QuartzSessionValidationScheduler;\nimport org.jsecurity.util.ClassUtils;\nimport org.jsecurity.util.Destroyable;\nimport org.jsecurity.util.Initializable;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport java.util.Date;\n\n/**\n * Default business-tier implementation of the {@link ValidatingSessionManager} interface.\n *\n * @since 0.1\n * @author Les Hazlewood\n * @author Jeremy Haile\n */\npublic class DefaultSessionManager extends AbstractSessionManager\n        implements ValidatingSessionManager, Destroyable {\n\n    private static final String EHCACHE_VALID_CLASS_NAME = \"net.sf.ehcache.CacheManager\";\n\n    /**\n     * Validator used to validate sessions on a regular basis.\n     * By default, the session manager will use Quartz to schedule session validation, but this\n     * can be overridden by calling {@link #setSessionValidationScheduler(SessionValidationScheduler)}\n     */\n    protected SessionValidationScheduler sessionValidationScheduler = new QuartzSessionValidationScheduler( this );\n\n    private boolean sessionDAOImplicitlyCreated = false;\n\n\n    public DefaultSessionManager(){\n        setSessionClass( SimpleSession.class );\n    }\n\n    private boolean isEhcacheAvailable() {\n        return ClassUtils.isAvailable( EHCACHE_VALID_CLASS_NAME );\n    }\n\n    /**\n     * Creates a default <tt>SessionDAO<\/tt> during {@link #init initialization} as a fail-safe mechanism if one has\n     * not already been explicitly set via {@link #setSessionDAO}.\n     *\n     * <p>This default implementation tries to use an {@link EhcacheSessionDAO EhcacheSessionDAO} instance by default if\n     * <a href=\"\">Ehcache<\/a> is in the classpath.  If ehcache is not in the classpath, a\n     * {@link org.jsecurity.session.support.eis.support.MemorySessionDAO} will be used instead.\n     *\n     * <p><b>N.B.<\/b> The MemorySessionDAO implementation is not production capable, as it maintains all sessions in\n     * memory (never removed, eating up memory over time) and loses session after server restarts.  It is really only\n     * suitable during testing.  For production environments, please ensure\n     * that you either have the <tt>ehcache<\/tt> jar in the classpath, or explicitly set a SessionDAO via the\n     * {@link #setSessionDAO} method so a sensible default will be used.\n     *\n     * @return a lazily created SessionDAO instance.\n     */\n    protected SessionDAO createSessionDAO() {\n        SessionDAO dao = null;\n\n        if ( log.isDebugEnabled() ) {\n            log.debug( \"No sessionDAO set.  Attempting to create default instance.\" );\n        }\n        if ( isEhcacheAvailable() ) {\n            if ( log.isDebugEnabled() ) {\n                String msg = \"Ehcache found in the classpath.  Using default EhcacheSessionDAO implementation.\";\n                log.debug( msg );\n            }\n            dao = new EhcacheSessionDAO();\n        } else {\n            if ( log.isWarnEnabled() ) {\n                String msg = \"Ehcache is not in the classpath.  JSecurity's default production-quality session \" +\n                        \"DAO is implemented w/ Ehcache.  Defaulting to a simple memory-based DAO, but this should \" +\n                        \"NOT be used in a production environment.  Please either put ehcache.jar in the classpath \" +\n                        \"or set a production-quality implementation explicitly via the \" + getClass().getName() +\n                        \"#setSessionDAO method.\";\n                log.warn( msg );\n            }\n            dao = new MemorySessionDAO();\n        }\n        this.sessionDAOImplicitlyCreated = true;\n        return dao;\n    }\n\n    public void init() {\n\n        SessionDAO sessionDAO = getSessionDAO();\n        if ( sessionDAO == null ) {\n            sessionDAO = createSessionDAO();\n            setSessionDAO( sessionDAO );\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No sessionDAO set.  Attempting to create default instance.\" );\n            }\n            if ( sessionDAOImplicitlyCreated && (sessionDAO instanceof Initializable ) ) {\n                if ( log.isTraceEnabled() ) {\n                    log.trace( \"Initializing implicitly created instance...\" );\n                }\n                try {\n                    ((Initializable)sessionDAO).init();\n                    if ( log.isDebugEnabled() ) {\n                        log.debug( \"Initializing default instance...\" );\n                    }\n                } catch (Exception e) {\n                    String msg = \"Unable to initialize sessionDAO [\" + sessionDAO + \"]\";\n                    throw new IllegalStateException( msg );\n                }\n            }\n        }\n\n        super.init();\n\n        // Start session validation\n        if ( sessionValidationScheduler != null ) {\n\n            if( log.isInfoEnabled() ) {\n                log.info( \"Starting session validation scheduler...\" );\n            }\n\n            sessionValidationScheduler.startSessionValidation();\n        } else {\n            if (log.isWarnEnabled()) {\n                log.warn(\"No session validation scheduler is configured, so sessions may not be validated.\");\n            }\n        }\n    }\n\n    public void destroy() {\n        try {\n            if ( sessionValidationScheduler != null ) {\n                sessionValidationScheduler.stopSessionValidation();\n            }\n        } catch (Exception e) {\n            if ( log.isWarnEnabled() ) {\n                String msg = \"Unable to cleanly destroy sessionValidationScheduler [\" + sessionValidationScheduler + \"].\";\n                log.warn( msg, e );\n            }\n        }\n\n        if ( sessionDAOImplicitlyCreated ) {\n            if ( sessionDAO instanceof Destroyable ) {\n                try {\n                    ((Destroyable)sessionDAO).destroy();\n                } catch ( Exception e ) {\n                    if ( log.isDebugEnabled() ) {\n                        log.debug( \"Unable to cleanly destroy implicitly created sessionDAO [\" + sessionDAO + \"].\" );\n                    }\n                }\n            }\n        }\n    }\n\n    public void setSessionValidationScheduler(SessionValidationScheduler sessionValidationScheduler) {\n        this.sessionValidationScheduler = sessionValidationScheduler;\n    }\n\n\n    protected void onStop( Session session ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Updating last access and destroy time of session with id [\" + session.getSessionId() + \"]\" );\n        }\n        // when properly stopping a session, it makes sense (for most systems) that the stop time and last access time\n        // are the same:\n        Date timestamp = new Date();\n        SimpleSession simpleSession = (SimpleSession)session;\n        simpleSession.setLastAccessTime( timestamp );\n        simpleSession.setStopTimestamp( timestamp );\n    }\n\n    protected void onExpire( Session session ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Updating destroy time and expiration status of session with id \" +\n                       session.getSessionId() + \"]\");\n        }\n        SimpleSession ss = (SimpleSession)session;\n        ss.setStopTimestamp( new Date() );\n        ss.setExpired( true );\n    }\n\n    protected void onTouch( Session session ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Updating last access time of session with id [\" +\n                       session.getSessionId() + \"]\");\n        }\n        ((SimpleSession)session).setLastAccessTime( new Date() );\n    }\n\n    protected void init( Session newInstance, InetAddress hostAddr ) {\n        if ( newInstance instanceof SimpleSession ) {\n            SimpleSession ss = (SimpleSession)newInstance;\n            ss.setHostAddress( hostAddr );\n        }\n    }\n\n    /**\n     * @see org.jsecurity.session.support.ValidatingSessionManager#validateSessions()\n     */\n    public void validateSessions() {\n        if ( log.isInfoEnabled() ) {\n            log.info( \"Validating all active sessions...\" );\n        }\n\n        int invalidCount = 0;\n\n        Collection<Session> activeSessions = getSessionDAO().getActiveSessions();\n\n        if ( activeSessions != null && !activeSessions.isEmpty() ) {\n            for( Session s : activeSessions ) {\n                try {\n                    validate( s );\n                } catch ( InvalidSessionException e ) {\n                    if ( log.isDebugEnabled() ) {\n                        boolean expired = (e instanceof ExpiredSessionException );\n                        String msg = \"Invalidated session with id [\" + s.getSessionId() + \"]\" +\n                            ( expired ? \" (expired)\" : \" (stopped)\" );\n                        log.debug( msg );\n                    }\n                    invalidCount++;\n                }\n            }\n        }\n\n        if ( log.isInfoEnabled() ) {\n            String msg = \"Finished session validation.\";\n            if ( invalidCount > 0 ) {\n                msg += \"  [\" + invalidCount + \"] sessions were stopped.\";\n            } else {\n                msg += \"  No sessions were stopped.\";\n            }\n            log.info( msg );\n        }\n    }\n\n    public void validateSession( Serializable sessionId ) {\n        retrieveAndValidateSession( sessionId );\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.session.support;\n\nimport org.jsecurity.session.ExpiredSessionException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.support.eis.SessionDAO;\nimport org.jsecurity.session.support.eis.ehcache.EhcacheSessionDAO;\nimport org.jsecurity.session.support.eis.support.MemorySessionDAO;\nimport org.jsecurity.session.support.quartz.QuartzSessionValidationScheduler;\nimport org.jsecurity.util.ClassUtils;\nimport org.jsecurity.util.Destroyable;\nimport org.jsecurity.util.Initializable;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport java.util.Date;\n\n/**\n * Default business-tier implementation of the {@link ValidatingSessionManager} interface.\n *\n * @since 0.1\n * @author Les Hazlewood\n * @author Jeremy Haile\n */\npublic class DefaultSessionManager extends AbstractSessionManager\n        implements ValidatingSessionManager, Destroyable {\n\n    private static final String EHCACHE_VALID_CLASS_NAME = \"net.sf.ehcache.CacheManager\";\n\n    /**\n     * Validator used to validate sessions on a regular basis.\n     * By default, the session manager will use Quartz to schedule session validation, but this\n     * can be overridden by calling {@link #setSessionValidationScheduler(SessionValidationScheduler)}\n     */\n    protected SessionValidationScheduler sessionValidationScheduler = new QuartzSessionValidationScheduler( this );\n\n    private boolean sessionDAOImplicitlyCreated = false;\n\n\n    public DefaultSessionManager(){\n        setSessionClass( SimpleSession.class );\n    }\n\n    private boolean isEhcacheAvailable() {\n        return ClassUtils.isAvailable( EHCACHE_VALID_CLASS_NAME );\n    }\n\n    /**\n     * Creates a default <tt>SessionDAO<\/tt> during {@link #init initialization} as a fail-safe mechanism if one has\n     * not already been explicitly set via {@link #setSessionDAO}.\n     *\n     * <p>This default implementation tries to use an {@link EhcacheSessionDAO EhcacheSessionDAO} instance by default if\n     * <a href=\"\">Ehcache<\/a> is in the classpath.  If ehcache is not in the classpath, a\n     * {@link org.jsecurity.session.support.eis.support.MemorySessionDAO} will be used instead.\n     *\n     * <p><b>N.B.<\/b> The MemorySessionDAO implementation is not production capable, as it maintains all sessions in\n     * memory (never removed, eating up memory over time) and loses session after server restarts.  It is really only\n     * suitable during testing.  For production environments, please ensure\n     * that you either have the <tt>ehcache<\/tt> jar in the classpath, or explicitly set a SessionDAO via the\n     * {@link #setSessionDAO} method so a sensible default will be used.\n     *\n     * @return a lazily created SessionDAO instance.\n     */\n    protected SessionDAO createSessionDAO() {\n        SessionDAO dao = null;\n\n        if ( log.isDebugEnabled() ) {\n            log.debug( \"No sessionDAO set.  Attempting to create default instance.\" );\n        }\n        if ( isEhcacheAvailable() ) {\n            if ( log.isDebugEnabled() ) {\n                String msg = \"Ehcache found in the classpath.  Using default EhcacheSessionDAO implementation.\";\n                log.debug( msg );\n            }\n            dao = new EhcacheSessionDAO();\n        } else {\n            if ( log.isWarnEnabled() ) {\n                String msg = \"Ehcache is not in the classpath.  JSecurity's default production-quality session \" +\n                        \"DAO is implemented w/ Ehcache.  Defaulting to a simple memory-based DAO, but this should \" +\n                        \"NOT be used in a production environment.  Please either put ehcache.jar in the classpath \" +\n                        \"or set a production-quality implementation explicitly via the \" + getClass().getName() +\n                        \"#setSessionDAO method.\";\n                log.warn( msg );\n            }\n            dao = new MemorySessionDAO();\n        }\n        this.sessionDAOImplicitlyCreated = true;\n        return dao;\n    }\n\n    public void init() {\n\n        SessionDAO sessionDAO = getSessionDAO();\n        if ( sessionDAO == null ) {\n            sessionDAO = createSessionDAO();\n            setSessionDAO( sessionDAO );\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No sessionDAO set.  Attempting to create default instance.\" );\n            }\n            if ( sessionDAOImplicitlyCreated && (sessionDAO instanceof Initializable ) ) {\n                if ( log.isTraceEnabled() ) {\n                    log.trace( \"Initializing implicitly created instance...\" );\n                }\n                try {\n                    ((Initializable)sessionDAO).init();\n                    if ( log.isDebugEnabled() ) {\n                        log.debug( \"Initializing default instance...\" );\n                    }\n                } catch (Exception e) {\n                    String msg = \"Unable to initialize sessionDAO [\" + sessionDAO + \"]\";\n                    throw new IllegalStateException( msg );\n                }\n            }\n        }\n\n        super.init();\n\n        // Start session validation\n        if ( sessionValidationScheduler != null ) {\n\n            if( log.isInfoEnabled() ) {\n                log.info( \"Starting session validation scheduler...\" );\n            }\n\n            sessionValidationScheduler.startSessionValidation();\n        } else {\n            if (log.isWarnEnabled()) {\n                log.warn(\"No session validation scheduler is configured, so sessions may not be validated.\");\n            }\n        }\n    }\n\n    public void destroy() {\n        try {\n            if ( sessionValidationScheduler != null ) {\n                sessionValidationScheduler.stopSessionValidation();\n            }\n        } catch (Exception e) {\n            if ( log.isWarnEnabled() ) {\n                String msg = \"Unable to cleanly destroy sessionValidationScheduler [\" + sessionValidationScheduler + \"].\";\n                log.warn( msg, e );\n            }\n        }\n\n        if ( sessionDAOImplicitlyCreated ) {\n            if ( sessionDAO instanceof Destroyable ) {\n                try {\n                    ((Destroyable)sessionDAO).destroy();\n                } catch ( Exception e ) {\n                    if ( log.isDebugEnabled() ) {\n                        log.debug( \"Unable to cleanly destroy implicitly created sessionDAO [\" + sessionDAO + \"].\" );\n                    }\n                }\n            }\n        }\n    }\n\n    public void setSessionValidationScheduler(SessionValidationScheduler sessionValidationScheduler) {\n        this.sessionValidationScheduler = sessionValidationScheduler;\n    }\n\n\n    protected void onStop( Session session ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Updating destroy time of session with id [\" + session.getSessionId() + \"]\" );\n        }\n        ((SimpleSession)session).setStopTimestamp( new Date() );\n    }\n\n    protected void onExpire( Session session ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Updating destroy time and expiration status of session with id \" +\n                       session.getSessionId() + \"]\");\n        }\n        SimpleSession ss = (SimpleSession)session;\n        ss.setStopTimestamp( new Date() );\n        ss.setExpired( true );\n    }\n\n    protected void onTouch( Session session ) {\n        if ( log.isTraceEnabled() ) {\n            log.trace( \"Updating last access time of session with id [\" +\n                       session.getSessionId() + \"]\");\n        }\n        ((SimpleSession)session).setLastAccessTime( new Date() );\n    }\n\n    protected void init( Session newInstance, InetAddress hostAddr ) {\n        if ( newInstance instanceof SimpleSession ) {\n            SimpleSession ss = (SimpleSession)newInstance;\n            ss.setHostAddress( hostAddr );\n        }\n    }\n\n    /**\n     * @see org.jsecurity.session.support.ValidatingSessionManager#validateSessions()\n     */\n    public void validateSessions() {\n        if ( log.isInfoEnabled() ) {\n            log.info( \"Validating all active sessions...\" );\n        }\n\n        int invalidCount = 0;\n\n        Collection<Session> activeSessions = getSessionDAO().getActiveSessions();\n\n        if ( activeSessions != null && !activeSessions.isEmpty() ) {\n            for( Session s : activeSessions ) {\n                try {\n                    validate( s );\n                } catch ( InvalidSessionException e ) {\n                    if ( log.isDebugEnabled() ) {\n                        boolean expired = (e instanceof ExpiredSessionException );\n                        String msg = \"Invalidated session with id [\" + s.getSessionId() + \"]\" +\n                            ( expired ? \" (expired)\" : \" (stopped)\" );\n                        log.debug( msg );\n                    }\n                    invalidCount++;\n                }\n            }\n        }\n\n        if ( log.isInfoEnabled() ) {\n            String msg = \"Finished session validation.\";\n            if ( invalidCount > 0 ) {\n                msg += \"  [\" + invalidCount + \"] sessions were stopped.\";\n            } else {\n                msg += \"  No sessions were stopped.\";\n            }\n            log.info( msg );\n        }\n    }\n\n    public void validateSession( Serializable sessionId ) {\n        retrieveAndValidateSession( sessionId );\n    }\n\n}\n","lineNo":194}
{"Refactored Sample":"package org.jsecurity.samples.spring.web;\n\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.support.ThreadLocalSecurityContext;\nimport org.jsecurity.session.Session;\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.mvc.AbstractController;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Controller used to dynamically build a JNLP file used to launch the JSecurity\n * Spring WebStart sample application.\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class JnlpController extends AbstractController {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    private String jnlpView;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    public void setJnlpView(String jnlpView) {\n        this.jnlpView = jnlpView;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\n        SecurityContext securityContext = ThreadLocalSecurityContext.current();\n        Session session = null;\n\n        if ( securityContext != null ) {\n            session = securityContext.getSession();\n        }\n        if ( session == null ) {\n            String msg = \"Expected a non-null JSecurity session.\";\n            throw new IllegalArgumentException( msg );\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append( \"http://\" );\n        sb.append( request.getServerName() );\n        if( request.getServerPort() != 80 ) {\n            sb.append( \":\" );\n            sb.append( request.getServerPort() );\n        }\n        sb.append( request.getContextPath() );\n\n        // prevent JNLP caching by setting response headers\n        response.setHeader( \"cache-control\", \"no-cache\" );\n        response.setHeader( \"pragma\", \"no-cache\" );\n\n        Map<String,Object> model = new HashMap<String,Object>();\n        model.put( \"codebaseUrl\", sb.toString() );\n        model.put( \"sessionId\", session.getSessionId() );\n        return new ModelAndView( jnlpView, model );\n    }\n}\n","Smelly Sample":"package org.jsecurity.samples.spring.web;\n\nimport org.jsecurity.context.support.ThreadLocalSecurityContext;\nimport org.jsecurity.session.Session;\nimport org.springframework.util.Assert;\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.mvc.AbstractController;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Controller used to dynamically build a JNLP file used to launch the JSecurity\n * Spring WebStart sample application.\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class JnlpController extends AbstractController {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    private String jnlpView;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    public void setJnlpView(String jnlpView) {\n        this.jnlpView = jnlpView;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\n        // Assume the user is authenticated\n        Session session = ThreadLocalSecurityContext.current().getSession();\n        Assert.notNull( session, \"Expected a non-null JSecurity session.\" );\n\n        StringBuilder sb = new StringBuilder();\n        sb.append( \"http://\" );\n        sb.append( request.getServerName() );\n        if( request.getServerPort() != 80 ) {\n            sb.append( \":\" );\n            sb.append( request.getServerPort() );\n        }\n        sb.append( request.getContextPath() );\n\n        // prevent JNLP caching by setting response headers\n        response.setHeader( \"cache-control\", \"no-cache\" );\n        response.setHeader( \"pragma\", \"no-cache\" );\n\n        Map<String,Object> model = new HashMap<String,Object>();\n        model.put( \"codebaseUrl\", sb.toString() );\n        model.put( \"sessionId\", session.getSessionId() );\n        return new ModelAndView( jnlpView, model );\n    }\n}\n","lineNo":50}
{"Refactored Sample":"/*\n * Copyright (C) 2007 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.samples.spring.web;\n\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.support.ThreadLocalSecurityContext;\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.mvc.AbstractController;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * Controller responsible for logging out the current user by invoking\n * {@link org.jsecurity.context.SecurityContext#invalidate()} \n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class LogoutController extends AbstractController {\n\n    protected ModelAndView handleRequestInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {\n        SecurityContext securityContext = ThreadLocalSecurityContext.current();\n\n        if( securityContext != null ) {\n            securityContext.invalidate();\n        }\n\n        return new ModelAndView( \"redirect:login\" );\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2007 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.samples.spring.web;\n\nimport org.jsecurity.context.support.ThreadLocalSecurityContext;\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.mvc.AbstractController;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * Controller responsible for logging out the current user by invoking\n * {@link org.jsecurity.context.SecurityContext#invalidate()} \n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class LogoutController extends AbstractController {\n\n    protected ModelAndView handleRequestInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {\n        ThreadLocalSecurityContext.current().invalidate();\n        return new ModelAndView( \"redirect:login\" );\n    }\n}\n","lineNo":45}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.realm.support.jdbc;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authc.support.SimpleAuthenticationInfo;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.realm.support.AbstractCachingRealm;\nimport org.jsecurity.realm.support.AuthorizationInfo;\nimport org.jsecurity.util.JdbcUtils;\nimport org.jsecurity.util.PermissionUtils;\nimport org.jsecurity.util.UsernamePrincipal;\n\nimport javax.sql.DataSource;\nimport java.security.Permission;\nimport java.security.Principal;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collection;\nimport java.util.HashSet;\n\n/**\n * <p>\n * Realm that allows authentication and authorization via JDBC calls.  The default queries suggest a potential schema\n * for retrieving the user's password for authentication, and querying for a user's roles and permissions.  The\n * default queries can be overridden by setting the query properties of the realm.\n * <\/p>\n *\n * <p>\n * If the default implementation\n * of authentication and authorization cannot handle your schema, this class can be subclassed and the\n * appropriate methods overridden. (usually {@link #doGetAuthenticationInfo(org.jsecurity.authc.AuthenticationToken)},\n * {@link #getRoleNamesForUser(java.sql.Connection, String)}, and/or {@link #getPermissions(java.sql.Connection, String, java.util.Collection)}\n * <\/p>\n *\n * <p>\n * This realm supports caching by extending from {@link org.jsecurity.realm.support.AbstractCachingRealm}.\n * <\/p>\n *\n * @see AbstractCachingRealm\n *\n * @since 0.2\n * @author Jeremy Haile\n */\npublic class JdbcRealm extends AbstractCachingRealm {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * The default query used to retrieve authentication information for the user.\n     */\n    protected static final String DEFAULT_AUTHENTICATION_QUERY = \"select password from users where username = ?\";\n\n    /**\n     * The default query used to retrieve the roles that apply to a user.\n     */\n    protected static final String DEFAULT_USER_ROLES_QUERY = \"select role_name from user_roles where username = ?\";\n\n    /**\n     * The default query used to retrieve permissions that apply to a particular role.\n     */\n    protected static final String DEFAULT_PERMISSIONS_QUERY = \"select permission_class, permission_target, permission_actions from roles_permissions where role_name = ?\";\n\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    protected DataSource dataSource;\n\n    protected String authenticationQuery = DEFAULT_AUTHENTICATION_QUERY;\n\n    protected String userRolesQuery = DEFAULT_USER_ROLES_QUERY;\n\n    protected String permissionsQuery = DEFAULT_PERMISSIONS_QUERY;\n\n    protected boolean permissionsLookupEnabled = false;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    /**\n     * Sets the datasource that should be used to retrieve connections used by this realm.\n     * @param dataSource the SQL data source.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Overrides the default query used to retrieve a user's password during authentication.  When using the default\n     * implementation, this query must take the user's username as a single parameter and return a single result\n     * with the user's password as the first column.  If you require a solution that does not match this query\n     * structure, you can override {@link #doGetAuthenticationInfo(org.jsecurity.authc.AuthenticationToken)} or\n     * just {@link #getPasswordForUser(java.sql.Connection, String)}\n     *\n     * @param authenticationQuery the query to use for authentication.\n     * @see #DEFAULT_AUTHENTICATION_QUERY\n     */\n    public void setAuthenticationQuery(String authenticationQuery) {\n        this.authenticationQuery = authenticationQuery;\n    }\n\n    /**\n     * Overrides the default query used to retrieve a user's roles during authorization.  When using the default\n     * implementation, this query must take the user's username as a single parameter and return a row\n     * per role with a single column containing the role name.  If you require a solution that does not match this query\n     * structure, you can override {@link #doGetAuthorizationInfo(java.security.Principal)} or just\n     * {@link #getRoleNamesForUser(java.sql.Connection, String)}\n     *\n     * @param userRolesQuery the query to use for retrieving a user's roles.\n     * @see #DEFAULT_USER_ROLES_QUERY\n     */\n    public void setUserRolesQuery(String userRolesQuery) {\n        this.userRolesQuery = userRolesQuery;\n    }\n\n    /**\n     * <p>\n     * Overrides the default query used to retrieve a user's permissions during authorization.  When using the default\n     * implementation, this query must take a role name as the single parameter and return a row\n     * per permission with three columns containing the fully qualified name of the permission class, the permission\n     * target, and the permission actions (in that order).  If you require a solution that does not match this query\n     * structure, you can override {@link #doGetAuthorizationInfo(java.security.Principal)} or just\n     * {@link #getPermissions(java.sql.Connection, String, java.util.Collection)}<\/p>\n     *\n     * <p><b>Permissions are only retrieved if you set {@link #permissionsLookupEnabled} to true.  Otherwise,\n     * this query is ignored.<\/b><\/p>\n     * @param permissionsQuery the query to use for retrieving permissions for a role.\n     * @see #DEFAULT_PERMISSIONS_QUERY\n     * @see #setPermissionsLookupEnabled(boolean)\n     */\n    public void setPermissionsQuery(String permissionsQuery) {\n        this.permissionsQuery = permissionsQuery;\n    }\n\n    /**\n     * Enables lookup of permissions during authorization.  The default is \"false\" - meaning that only roles\n     * are associated with a user.  Set this to true in order to lookup roles <b>and<\/b> permissions.\n     *\n     * @param permissionsLookupEnabled true if permissions should be looked up during authorization, or false if only\n     * roles should be looked up.\n     */\n    public void setPermissionsLookupEnabled(boolean permissionsLookupEnabled) {\n        this.permissionsLookupEnabled = permissionsLookupEnabled;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    public void onInit() {\n        setAuthenticationTokenClass( UsernamePasswordToken.class );\n    }\n\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n        String username = upToken.getUsername();\n\n        // Null username is invalid\n        if( username == null ) {\n            throw new AccountException( \"Null usernames are not allowed by this realm.\" );\n        }\n\n        Connection conn = null;\n        SimpleAuthenticationInfo info = null;\n        try {\n            conn = dataSource.getConnection();\n\n            String password = getPasswordForUser(conn, username);\n\n            if( password == null ) {\n                throw new UnknownAccountException( \"No account found for user [\" + username + \"]\" );\n            }\n\n            info = new SimpleAuthenticationInfo();\n\n            // Populate the authentication info\n            info.addPrincipal( new UsernamePrincipal( username ) );\n            info.setCredentials( password );\n\n        } catch( SQLException e ) {\n            final String message = \"There was a SQL error while authenticating user [\" + username + \"]\";\n            if (logger.isErrorEnabled()) {\n                logger.error(message, e);\n            }\n\n            // Rethrow any SQL errors as an authentication exception\n            throw new AuthenticationException(message, e );\n        } finally {\n            JdbcUtils.closeConnection( conn );\n        }\n\n        return info;\n    }\n\n    private String getPasswordForUser(Connection conn, String username) throws SQLException {\n\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        String password = null;\n        try {\n            ps = conn.prepareStatement( authenticationQuery );\n            ps.setString( 1, username );\n\n            // Execute query\n            rs = ps.executeQuery();\n\n            // Loop over results - although we are only expecting one result, since usernames should be unique\n            boolean foundResult = false;\n            while( rs.next() ) {\n\n                // Check to ensure only one row is processed\n                if( foundResult ) {\n                    throw new AuthenticationException( \"More than one user row found for user [\" + username + \"]. Usernames must be unique.\" );\n                }\n\n                password = rs.getString( 1 );\n\n                foundResult = true;\n            }\n        } finally {\n            JdbcUtils.closeResultSet( rs );\n            JdbcUtils.closeStatement( ps );\n        }\n\n        return password;\n    }\n\n    protected AuthorizationInfo doGetAuthorizationInfo(Principal principal) {\n\n        UsernamePrincipal usernamePrincipal = (UsernamePrincipal) principal;\n        String username = usernamePrincipal.getUsername();\n\n        // Null username is invalid\n        if( username == null ) {\n            throw new AuthorizationException( \"Null usernames are not allowed by this realm.\" );\n        }\n\n        Connection conn = null;\n        Collection<String> roleNames = null;\n        Collection<Permission> permissions = null;\n        try {\n            conn = dataSource.getConnection();\n\n            // Retrieve roles and permissions from database\n            roleNames = getRoleNamesForUser(conn, username);\n            permissions = getPermissions(conn, username, roleNames);\n\n        } catch( SQLException e ) {\n            final String message = \"There was a SQL error while authorizing user [\" + username + \"]\";\n            if (logger.isErrorEnabled()) {\n                logger.error(message, e);\n            }\n\n            // Rethrow any SQL errors as an authorization exception\n            throw new AuthorizationException( message, e );\n        } finally {\n            JdbcUtils.closeConnection( conn );\n        }\n\n        return new AuthorizationInfo( roleNames, permissions );\n    }\n\n    protected Collection<String> getRoleNamesForUser(Connection conn, String username) throws SQLException {\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        Collection<String> roleNames = new HashSet<String>();\n        try {\n            ps = conn.prepareStatement( userRolesQuery );\n            ps.setString( 1, username );\n\n            // Execute query\n            rs = ps.executeQuery();\n\n            // Loop over results and add each returned role to a set\n            while( rs.next() ) {\n\n                String roleName = rs.getString( 1 );\n\n                // Add the role to the list of names if it isn't null\n                if( roleName != null ) {\n                    roleNames.add( roleName );\n                } else {\n                    if( log.isWarnEnabled() ) {\n                        log.warn( \"Null role name found while retrieving role names for user [\" + username + \"]\" );\n                    }\n                }\n            }\n        } finally {\n            JdbcUtils.closeResultSet( rs );\n            JdbcUtils.closeStatement( ps );\n        }\n        return roleNames;\n    }\n\n    protected Collection<Permission> getPermissions(Connection conn, String username, Collection<String> roleNames) throws SQLException {\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        Collection<Permission> permissions = new HashSet<Permission>();\n        try {\n            for( String roleName : roleNames ) {\n\n                ps = conn.prepareStatement( permissionsQuery );\n                ps.setString( 1, roleName);\n\n                // Execute query\n                rs = ps.executeQuery();\n\n                // Loop over results and add each returned role to a set\n                while( rs.next() ) {\n\n                    String className = rs.getString( 1 );\n                    String target = rs.getString( 2 );\n                    String actions = rs.getString( 3 );\n\n                    // Instantiate a permission object using reflection\n                    Permission permission = PermissionUtils.createPermission( className, target, actions );\n\n                    // Add the permission to the set of permissions\n                    permissions.add( permission );\n                }\n\n            }\n        } finally {\n            JdbcUtils.closeResultSet( rs );\n            JdbcUtils.closeStatement( ps );\n        }\n\n        return permissions;\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.realm.support.jdbc;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authc.support.SimpleAuthenticationInfo;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.realm.support.AbstractCachingRealm;\nimport org.jsecurity.realm.support.AuthorizationInfo;\nimport org.jsecurity.util.JdbcUtils;\nimport org.jsecurity.util.PermissionUtils;\nimport org.jsecurity.util.UsernamePrincipal;\n\nimport javax.sql.DataSource;\nimport java.security.Permission;\nimport java.security.Principal;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collection;\nimport java.util.HashSet;\n\n/**\n * <p>\n * Realm that allows authentication and authorization via JDBC calls.  The default queries suggest a potential schema\n * for retrieving the user's password for authentication, and querying for a user's roles and permissions.  The\n * default queries can be overridden by setting the query properties of the realm.\n * <\/p>\n *\n * <p>\n * If the default implementation\n * of authentication and authorization cannot handle your schema, this class can be subclassed and the\n * appropriate methods overridden. (usually {@link #doGetAuthenticationInfo(org.jsecurity.authc.AuthenticationToken)},\n * {@link #getRoleNamesForUser(java.sql.Connection, String)}, and/or {@link #getPermissions(java.sql.Connection, String, java.util.Collection)}\n * <\/p>\n *\n * <p>\n * This realm supports caching by extending from {@link org.jsecurity.realm.support.AbstractCachingRealm}.\n * <\/p>\n *\n * @see AbstractCachingRealm\n *\n * @since 0.2\n * @author Jeremy Haile\n */\npublic class JdbcRealm extends AbstractCachingRealm {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * The default query used to retrieve authentication information for the user.\n     */\n    protected static final String DEFAULT_AUTHENTICATION_QUERY = \"select password from users where username = ?\";\n\n    /**\n     * The default query used to retrieve the roles that apply to a user.\n     */\n    protected static final String DEFAULT_USER_ROLES_QUERY = \"select role_name from user_roles where username = ?\";\n\n    /**\n     * The default query used to retrieve permissions that apply to a particular role.\n     */\n    protected static final String DEFAULT_PERMISSIONS_QUERY = \"select permission_class, permission_target, permission_actions from roles_permissions where role_name = ?\";\n\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    protected DataSource dataSource;\n\n    protected String authenticationQuery = DEFAULT_AUTHENTICATION_QUERY;\n\n    protected String userRolesQuery = DEFAULT_USER_ROLES_QUERY;\n\n    protected String permissionsQuery = DEFAULT_PERMISSIONS_QUERY;\n\n    protected boolean permissionsLookupEnabled = false;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    /**\n     * Sets the datasource that should be used to retrieve connections used by this realm.\n     * @param dataSource the SQL data source.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Overrides the default query used to retrieve a user's password during authentication.  When using the default\n     * implementation, this query must take the user's username as a single parameter and return a single result\n     * with the user's password as the first column.  If you require a solution that does not match this query\n     * structure, you can override {@link #doGetAuthenticationInfo(org.jsecurity.authc.AuthenticationToken)} or\n     * just {@link #getPasswordForUser(java.sql.Connection, String)}\n     *\n     * @param authenticationQuery the query to use for authentication.\n     * @see #DEFAULT_AUTHENTICATION_QUERY\n     */\n    public void setAuthenticationQuery(String authenticationQuery) {\n        this.authenticationQuery = authenticationQuery;\n    }\n\n    /**\n     * Overrides the default query used to retrieve a user's roles during authorization.  When using the default\n     * implementation, this query must take the user's username as a single parameter and return a row\n     * per role with a single column containing the role name.  If you require a solution that does not match this query\n     * structure, you can override {@link #doGetAuthorizationInfo(java.security.Principal)} or just\n     * {@link #getRoleNamesForUser(java.sql.Connection, String)}\n     *\n     * @param userRolesQuery the query to use for retrieving a user's roles.\n     * @see #DEFAULT_USER_ROLES_QUERY\n     */\n    public void setUserRolesQuery(String userRolesQuery) {\n        this.userRolesQuery = userRolesQuery;\n    }\n\n    /**\n     * <p>\n     * Overrides the default query used to retrieve a user's permissions during authorization.  When using the default\n     * implementation, this query must take a role name as the single parameter and return a row\n     * per permission with three columns containing the fully qualified name of the permission class, the permission\n     * target, and the permission actions (in that order).  If you require a solution that does not match this query\n     * structure, you can override {@link #doGetAuthorizationInfo(java.security.Principal)} or just\n     * {@link #getPermissions(java.sql.Connection, String, java.util.Collection)}<\/p>\n     *\n     * <p><b>Permissions are only retrieved if you set {@link #permissionsLookupEnabled} to true.  Otherwise,\n     * this query is ignored.<\/b><\/p>\n     * @param permissionsQuery the query to use for retrieving permissions for a role.\n     * @see #DEFAULT_PERMISSIONS_QUERY\n     * @see #setPermissionsLookupEnabled(boolean)\n     */\n    public void setPermissionsQuery(String permissionsQuery) {\n        this.permissionsQuery = permissionsQuery;\n    }\n\n    /**\n     * Enables lookup of permissions during authorization.  The default is \"false\" - meaning that only roles\n     * are associated with a user.  Set this to true in order to lookup roles <b>and<\/b> permissions.\n     *\n     * @param permissionsLookupEnabled true if permissions should be looked up during authorization, or false if only\n     * roles should be looked up.\n     */\n    public void setPermissionsLookupEnabled(boolean permissionsLookupEnabled) {\n        this.permissionsLookupEnabled = permissionsLookupEnabled;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    public void onInit() {\n        setAuthenticationTokenClass( UsernamePasswordToken.class );\n    }\n\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n        String username = upToken.getUsername();\n\n        // Null username is invalid\n        if( username == null ) {\n            throw new AccountException( \"Null usernames are not allowed by this realm.\" );\n        }\n\n        Connection conn = null;\n        SimpleAuthenticationInfo info = null;\n        try {\n            conn = dataSource.getConnection();\n\n            String password = getPasswordForUser(conn, username);\n\n            if( password == null ) {\n                throw new UnknownAccountException( \"No account found for user [\" + username + \"]\" );\n            }\n\n            info = new SimpleAuthenticationInfo();\n\n            // Populate the authentication info\n            info.addPrincipal( new UsernamePrincipal( username ) );\n            info.setCredentials( password );\n\n        } catch( SQLException e ) {\n            // Rethrow any SQL errors as an authentication exception\n            throw new AuthenticationException( \"There was a SQL error while authenticating user [\" + username + \"]\", e );\n        } finally {\n            JdbcUtils.closeConnection( conn );\n        }\n\n        return info;\n    }\n\n    private String getPasswordForUser(Connection conn, String username) throws SQLException {\n\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        String password = null;\n        try {\n            ps = conn.prepareStatement( authenticationQuery );\n            ps.setString( 1, username );\n\n            // Execute query\n            rs = ps.executeQuery();\n\n            // Loop over results - although we are only expecting one result, since usernames should be unique\n            boolean foundResult = false;\n            while( rs.next() ) {\n\n                // Check to ensure only one row is processed\n                if( foundResult ) {\n                    throw new AuthenticationException( \"More than one user row found for user [\" + username + \"]. Usernames must be unique.\" );\n                }\n\n                password = rs.getString( 1 );\n\n                foundResult = true;\n            }\n        } finally {\n            JdbcUtils.closeResultSet( rs );\n            JdbcUtils.closeStatement( ps );\n        }\n\n        return password;\n    }\n\n    protected AuthorizationInfo doGetAuthorizationInfo(Principal principal) {\n\n        UsernamePrincipal usernamePrincipal = (UsernamePrincipal) principal;\n        String username = usernamePrincipal.getUsername();\n\n        // Null username is invalid\n        if( username == null ) {\n            throw new AuthorizationException( \"Null usernames are not allowed by this realm.\" );\n        }\n\n        Connection conn = null;\n        Collection<String> roleNames = null;\n        Collection<Permission> permissions = null;\n        try {\n            conn = dataSource.getConnection();\n\n            // Retrieve roles and permissions from database\n            roleNames = getRoleNamesForUser(conn, username);\n            permissions = getPermissions(conn, username, roleNames);\n\n        } catch( SQLException e ) {\n            // Rethrow any SQL errors as an authorization exception\n            throw new AuthorizationException( \"There was a SQL error while authorizing user [\" + username + \"]\", e );\n        } finally {\n            JdbcUtils.closeConnection( conn );\n        }\n\n        return new AuthorizationInfo( roleNames, permissions );\n    }\n\n    protected Collection<String> getRoleNamesForUser(Connection conn, String username) throws SQLException {\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        Collection<String> roleNames = new HashSet<String>();\n        try {\n            ps = conn.prepareStatement( userRolesQuery );\n            ps.setString( 1, username );\n\n            // Execute query\n            rs = ps.executeQuery();\n\n            // Loop over results and add each returned role to a set\n            while( rs.next() ) {\n\n                String roleName = rs.getString( 1 );\n\n                // Add the role to the list of names if it isn't null\n                if( roleName != null ) {\n                    roleNames.add( roleName );\n                } else {\n                    if( log.isWarnEnabled() ) {\n                        log.warn( \"Null role name found while retrieving role names for user [\" + username + \"]\" );\n                    }\n                }\n            }\n        } finally {\n            JdbcUtils.closeResultSet( rs );\n            JdbcUtils.closeStatement( ps );\n        }\n        return roleNames;\n    }\n\n    protected Collection<Permission> getPermissions(Connection conn, String username, Collection<String> roleNames) throws SQLException {\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        Collection<Permission> permissions = new HashSet<Permission>();\n        try {\n            for( String roleName : roleNames ) {\n\n                ps = conn.prepareStatement( permissionsQuery );\n                ps.setString( 1, roleName);\n\n                // Execute query\n                rs = ps.executeQuery();\n\n                // Loop over results and add each returned role to a set\n                while( rs.next() ) {\n\n                    String className = rs.getString( 1 );\n                    String target = rs.getString( 2 );\n                    String actions = rs.getString( 3 );\n\n                    // Instantiate a permission object using reflection\n                    Permission permission = PermissionUtils.createPermission( className, target, actions );\n\n                    // Add the permission to the set of permissions\n                    permissions.add( permission );\n                }\n\n            }\n        } finally {\n            JdbcUtils.closeResultSet( rs );\n            JdbcUtils.closeStatement( ps );\n        }\n\n        return permissions;\n    }\n\n}\n","lineNo":213}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.realm.support.jdbc;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authc.support.SimpleAuthenticationInfo;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.realm.support.AbstractCachingRealm;\nimport org.jsecurity.realm.support.AuthorizationInfo;\nimport org.jsecurity.util.JdbcUtils;\nimport org.jsecurity.util.PermissionUtils;\nimport org.jsecurity.util.UsernamePrincipal;\n\nimport javax.sql.DataSource;\nimport java.security.Permission;\nimport java.security.Principal;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collection;\nimport java.util.HashSet;\n\n/**\n * <p>\n * Realm that allows authentication and authorization via JDBC calls.  The default queries suggest a potential schema\n * for retrieving the user's password for authentication, and querying for a user's roles and permissions.  The\n * default queries can be overridden by setting the query properties of the realm.\n * <\/p>\n *\n * <p>\n * If the default implementation\n * of authentication and authorization cannot handle your schema, this class can be subclassed and the\n * appropriate methods overridden. (usually {@link #doGetAuthenticationInfo(org.jsecurity.authc.AuthenticationToken)},\n * {@link #getRoleNamesForUser(java.sql.Connection, String)}, and/or {@link #getPermissions(java.sql.Connection, String, java.util.Collection)}\n * <\/p>\n *\n * <p>\n * This realm supports caching by extending from {@link org.jsecurity.realm.support.AbstractCachingRealm}.\n * <\/p>\n *\n * @see AbstractCachingRealm\n *\n * @since 0.2\n * @author Jeremy Haile\n */\npublic class JdbcRealm extends AbstractCachingRealm {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * The default query used to retrieve authentication information for the user.\n     */\n    protected static final String DEFAULT_AUTHENTICATION_QUERY = \"select password from users where username = ?\";\n\n    /**\n     * The default query used to retrieve the roles that apply to a user.\n     */\n    protected static final String DEFAULT_USER_ROLES_QUERY = \"select role_name from user_roles where username = ?\";\n\n    /**\n     * The default query used to retrieve permissions that apply to a particular role.\n     */\n    protected static final String DEFAULT_PERMISSIONS_QUERY = \"select permission_class, permission_target, permission_actions from roles_permissions where role_name = ?\";\n\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    protected DataSource dataSource;\n\n    protected String authenticationQuery = DEFAULT_AUTHENTICATION_QUERY;\n\n    protected String userRolesQuery = DEFAULT_USER_ROLES_QUERY;\n\n    protected String permissionsQuery = DEFAULT_PERMISSIONS_QUERY;\n\n    protected boolean permissionsLookupEnabled = false;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    /**\n     * Sets the datasource that should be used to retrieve connections used by this realm.\n     * @param dataSource the SQL data source.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Overrides the default query used to retrieve a user's password during authentication.  When using the default\n     * implementation, this query must take the user's username as a single parameter and return a single result\n     * with the user's password as the first column.  If you require a solution that does not match this query\n     * structure, you can override {@link #doGetAuthenticationInfo(org.jsecurity.authc.AuthenticationToken)} or\n     * just {@link #getPasswordForUser(java.sql.Connection, String)}\n     *\n     * @param authenticationQuery the query to use for authentication.\n     * @see #DEFAULT_AUTHENTICATION_QUERY\n     */\n    public void setAuthenticationQuery(String authenticationQuery) {\n        this.authenticationQuery = authenticationQuery;\n    }\n\n    /**\n     * Overrides the default query used to retrieve a user's roles during authorization.  When using the default\n     * implementation, this query must take the user's username as a single parameter and return a row\n     * per role with a single column containing the role name.  If you require a solution that does not match this query\n     * structure, you can override {@link #doGetAuthorizationInfo(java.security.Principal)} or just\n     * {@link #getRoleNamesForUser(java.sql.Connection, String)}\n     *\n     * @param userRolesQuery the query to use for retrieving a user's roles.\n     * @see #DEFAULT_USER_ROLES_QUERY\n     */\n    public void setUserRolesQuery(String userRolesQuery) {\n        this.userRolesQuery = userRolesQuery;\n    }\n\n    /**\n     * <p>\n     * Overrides the default query used to retrieve a user's permissions during authorization.  When using the default\n     * implementation, this query must take a role name as the single parameter and return a row\n     * per permission with three columns containing the fully qualified name of the permission class, the permission\n     * target, and the permission actions (in that order).  If you require a solution that does not match this query\n     * structure, you can override {@link #doGetAuthorizationInfo(java.security.Principal)} or just\n     * {@link #getPermissions(java.sql.Connection, String, java.util.Collection)}<\/p>\n     *\n     * <p><b>Permissions are only retrieved if you set {@link #permissionsLookupEnabled} to true.  Otherwise,\n     * this query is ignored.<\/b><\/p>\n     * @param permissionsQuery the query to use for retrieving permissions for a role.\n     * @see #DEFAULT_PERMISSIONS_QUERY\n     * @see #setPermissionsLookupEnabled(boolean)\n     */\n    public void setPermissionsQuery(String permissionsQuery) {\n        this.permissionsQuery = permissionsQuery;\n    }\n\n    /**\n     * Enables lookup of permissions during authorization.  The default is \"false\" - meaning that only roles\n     * are associated with a user.  Set this to true in order to lookup roles <b>and<\/b> permissions.\n     *\n     * @param permissionsLookupEnabled true if permissions should be looked up during authorization, or false if only\n     * roles should be looked up.\n     */\n    public void setPermissionsLookupEnabled(boolean permissionsLookupEnabled) {\n        this.permissionsLookupEnabled = permissionsLookupEnabled;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    public void onInit() {\n        setAuthenticationTokenClass( UsernamePasswordToken.class );\n    }\n\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n        String username = upToken.getUsername();\n\n        // Null username is invalid\n        if( username == null ) {\n            throw new AccountException( \"Null usernames are not allowed by this realm.\" );\n        }\n\n        Connection conn = null;\n        SimpleAuthenticationInfo info = null;\n        try {\n            conn = dataSource.getConnection();\n\n            String password = getPasswordForUser(conn, username);\n\n            if( password == null ) {\n                throw new UnknownAccountException( \"No account found for user [\" + username + \"]\" );\n            }\n\n            info = new SimpleAuthenticationInfo();\n\n            // Populate the authentication info\n            info.addPrincipal( new UsernamePrincipal( username ) );\n            info.setCredentials( password );\n\n        } catch( SQLException e ) {\n            final String message = \"There was a SQL error while authenticating user [\" + username + \"]\";\n            if (logger.isErrorEnabled()) {\n                logger.error(message, e);\n            }\n\n            // Rethrow any SQL errors as an authentication exception\n            throw new AuthenticationException(message, e );\n        } finally {\n            JdbcUtils.closeConnection( conn );\n        }\n\n        return info;\n    }\n\n    private String getPasswordForUser(Connection conn, String username) throws SQLException {\n\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        String password = null;\n        try {\n            ps = conn.prepareStatement( authenticationQuery );\n            ps.setString( 1, username );\n\n            // Execute query\n            rs = ps.executeQuery();\n\n            // Loop over results - although we are only expecting one result, since usernames should be unique\n            boolean foundResult = false;\n            while( rs.next() ) {\n\n                // Check to ensure only one row is processed\n                if( foundResult ) {\n                    throw new AuthenticationException( \"More than one user row found for user [\" + username + \"]. Usernames must be unique.\" );\n                }\n\n                password = rs.getString( 1 );\n\n                foundResult = true;\n            }\n        } finally {\n            JdbcUtils.closeResultSet( rs );\n            JdbcUtils.closeStatement( ps );\n        }\n\n        return password;\n    }\n\n    protected AuthorizationInfo doGetAuthorizationInfo(Principal principal) {\n\n        UsernamePrincipal usernamePrincipal = (UsernamePrincipal) principal;\n        String username = usernamePrincipal.getUsername();\n\n        // Null username is invalid\n        if( username == null ) {\n            throw new AuthorizationException( \"Null usernames are not allowed by this realm.\" );\n        }\n\n        Connection conn = null;\n        Collection<String> roleNames = null;\n        Collection<Permission> permissions = null;\n        try {\n            conn = dataSource.getConnection();\n\n            // Retrieve roles and permissions from database\n            roleNames = getRoleNamesForUser(conn, username);\n            permissions = getPermissions(conn, username, roleNames);\n\n        } catch( SQLException e ) {\n            final String message = \"There was a SQL error while authorizing user [\" + username + \"]\";\n            if (logger.isErrorEnabled()) {\n                logger.error(message, e);\n            }\n\n            // Rethrow any SQL errors as an authorization exception\n            throw new AuthorizationException( message, e );\n        } finally {\n            JdbcUtils.closeConnection( conn );\n        }\n\n        return new AuthorizationInfo( roleNames, permissions );\n    }\n\n    protected Collection<String> getRoleNamesForUser(Connection conn, String username) throws SQLException {\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        Collection<String> roleNames = new HashSet<String>();\n        try {\n            ps = conn.prepareStatement( userRolesQuery );\n            ps.setString( 1, username );\n\n            // Execute query\n            rs = ps.executeQuery();\n\n            // Loop over results and add each returned role to a set\n            while( rs.next() ) {\n\n                String roleName = rs.getString( 1 );\n\n                // Add the role to the list of names if it isn't null\n                if( roleName != null ) {\n                    roleNames.add( roleName );\n                } else {\n                    if( log.isWarnEnabled() ) {\n                        log.warn( \"Null role name found while retrieving role names for user [\" + username + \"]\" );\n                    }\n                }\n            }\n        } finally {\n            JdbcUtils.closeResultSet( rs );\n            JdbcUtils.closeStatement( ps );\n        }\n        return roleNames;\n    }\n\n    protected Collection<Permission> getPermissions(Connection conn, String username, Collection<String> roleNames) throws SQLException {\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        Collection<Permission> permissions = new HashSet<Permission>();\n        try {\n            for( String roleName : roleNames ) {\n\n                ps = conn.prepareStatement( permissionsQuery );\n                ps.setString( 1, roleName);\n\n                // Execute query\n                rs = ps.executeQuery();\n\n                // Loop over results and add each returned role to a set\n                while( rs.next() ) {\n\n                    String className = rs.getString( 1 );\n                    String target = rs.getString( 2 );\n                    String actions = rs.getString( 3 );\n\n                    // Instantiate a permission object using reflection\n                    Permission permission = PermissionUtils.createPermission( className, target, actions );\n\n                    // Add the permission to the set of permissions\n                    permissions.add( permission );\n                }\n\n            }\n        } finally {\n            JdbcUtils.closeResultSet( rs );\n            JdbcUtils.closeStatement( ps );\n        }\n\n        return permissions;\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.realm.support.jdbc;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authc.support.SimpleAuthenticationInfo;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.realm.support.AbstractCachingRealm;\nimport org.jsecurity.realm.support.AuthorizationInfo;\nimport org.jsecurity.util.JdbcUtils;\nimport org.jsecurity.util.PermissionUtils;\nimport org.jsecurity.util.UsernamePrincipal;\n\nimport javax.sql.DataSource;\nimport java.security.Permission;\nimport java.security.Principal;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collection;\nimport java.util.HashSet;\n\n/**\n * <p>\n * Realm that allows authentication and authorization via JDBC calls.  The default queries suggest a potential schema\n * for retrieving the user's password for authentication, and querying for a user's roles and permissions.  The\n * default queries can be overridden by setting the query properties of the realm.\n * <\/p>\n *\n * <p>\n * If the default implementation\n * of authentication and authorization cannot handle your schema, this class can be subclassed and the\n * appropriate methods overridden. (usually {@link #doGetAuthenticationInfo(org.jsecurity.authc.AuthenticationToken)},\n * {@link #getRoleNamesForUser(java.sql.Connection, String)}, and/or {@link #getPermissions(java.sql.Connection, String, java.util.Collection)}\n * <\/p>\n *\n * <p>\n * This realm supports caching by extending from {@link org.jsecurity.realm.support.AbstractCachingRealm}.\n * <\/p>\n *\n * @see AbstractCachingRealm\n *\n * @since 0.2\n * @author Jeremy Haile\n */\npublic class JdbcRealm extends AbstractCachingRealm {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * The default query used to retrieve authentication information for the user.\n     */\n    protected static final String DEFAULT_AUTHENTICATION_QUERY = \"select password from users where username = ?\";\n\n    /**\n     * The default query used to retrieve the roles that apply to a user.\n     */\n    protected static final String DEFAULT_USER_ROLES_QUERY = \"select role_name from user_roles where username = ?\";\n\n    /**\n     * The default query used to retrieve permissions that apply to a particular role.\n     */\n    protected static final String DEFAULT_PERMISSIONS_QUERY = \"select permission_class, permission_target, permission_actions from roles_permissions where role_name = ?\";\n\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    protected DataSource dataSource;\n\n    protected String authenticationQuery = DEFAULT_AUTHENTICATION_QUERY;\n\n    protected String userRolesQuery = DEFAULT_USER_ROLES_QUERY;\n\n    protected String permissionsQuery = DEFAULT_PERMISSIONS_QUERY;\n\n    protected boolean permissionsLookupEnabled = false;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    /**\n     * Sets the datasource that should be used to retrieve connections used by this realm.\n     * @param dataSource the SQL data source.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Overrides the default query used to retrieve a user's password during authentication.  When using the default\n     * implementation, this query must take the user's username as a single parameter and return a single result\n     * with the user's password as the first column.  If you require a solution that does not match this query\n     * structure, you can override {@link #doGetAuthenticationInfo(org.jsecurity.authc.AuthenticationToken)} or\n     * just {@link #getPasswordForUser(java.sql.Connection, String)}\n     *\n     * @param authenticationQuery the query to use for authentication.\n     * @see #DEFAULT_AUTHENTICATION_QUERY\n     */\n    public void setAuthenticationQuery(String authenticationQuery) {\n        this.authenticationQuery = authenticationQuery;\n    }\n\n    /**\n     * Overrides the default query used to retrieve a user's roles during authorization.  When using the default\n     * implementation, this query must take the user's username as a single parameter and return a row\n     * per role with a single column containing the role name.  If you require a solution that does not match this query\n     * structure, you can override {@link #doGetAuthorizationInfo(java.security.Principal)} or just\n     * {@link #getRoleNamesForUser(java.sql.Connection, String)}\n     *\n     * @param userRolesQuery the query to use for retrieving a user's roles.\n     * @see #DEFAULT_USER_ROLES_QUERY\n     */\n    public void setUserRolesQuery(String userRolesQuery) {\n        this.userRolesQuery = userRolesQuery;\n    }\n\n    /**\n     * <p>\n     * Overrides the default query used to retrieve a user's permissions during authorization.  When using the default\n     * implementation, this query must take a role name as the single parameter and return a row\n     * per permission with three columns containing the fully qualified name of the permission class, the permission\n     * target, and the permission actions (in that order).  If you require a solution that does not match this query\n     * structure, you can override {@link #doGetAuthorizationInfo(java.security.Principal)} or just\n     * {@link #getPermissions(java.sql.Connection, String, java.util.Collection)}<\/p>\n     *\n     * <p><b>Permissions are only retrieved if you set {@link #permissionsLookupEnabled} to true.  Otherwise,\n     * this query is ignored.<\/b><\/p>\n     * @param permissionsQuery the query to use for retrieving permissions for a role.\n     * @see #DEFAULT_PERMISSIONS_QUERY\n     * @see #setPermissionsLookupEnabled(boolean)\n     */\n    public void setPermissionsQuery(String permissionsQuery) {\n        this.permissionsQuery = permissionsQuery;\n    }\n\n    /**\n     * Enables lookup of permissions during authorization.  The default is \"false\" - meaning that only roles\n     * are associated with a user.  Set this to true in order to lookup roles <b>and<\/b> permissions.\n     *\n     * @param permissionsLookupEnabled true if permissions should be looked up during authorization, or false if only\n     * roles should be looked up.\n     */\n    public void setPermissionsLookupEnabled(boolean permissionsLookupEnabled) {\n        this.permissionsLookupEnabled = permissionsLookupEnabled;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    public void onInit() {\n        setAuthenticationTokenClass( UsernamePasswordToken.class );\n    }\n\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n        String username = upToken.getUsername();\n\n        // Null username is invalid\n        if( username == null ) {\n            throw new AccountException( \"Null usernames are not allowed by this realm.\" );\n        }\n\n        Connection conn = null;\n        SimpleAuthenticationInfo info = null;\n        try {\n            conn = dataSource.getConnection();\n\n            String password = getPasswordForUser(conn, username);\n\n            if( password == null ) {\n                throw new UnknownAccountException( \"No account found for user [\" + username + \"]\" );\n            }\n\n            info = new SimpleAuthenticationInfo();\n\n            // Populate the authentication info\n            info.addPrincipal( new UsernamePrincipal( username ) );\n            info.setCredentials( password );\n\n        } catch( SQLException e ) {\n            // Rethrow any SQL errors as an authentication exception\n            throw new AuthenticationException( \"There was a SQL error while authenticating user [\" + username + \"]\", e );\n        } finally {\n            JdbcUtils.closeConnection( conn );\n        }\n\n        return info;\n    }\n\n    private String getPasswordForUser(Connection conn, String username) throws SQLException {\n\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        String password = null;\n        try {\n            ps = conn.prepareStatement( authenticationQuery );\n            ps.setString( 1, username );\n\n            // Execute query\n            rs = ps.executeQuery();\n\n            // Loop over results - although we are only expecting one result, since usernames should be unique\n            boolean foundResult = false;\n            while( rs.next() ) {\n\n                // Check to ensure only one row is processed\n                if( foundResult ) {\n                    throw new AuthenticationException( \"More than one user row found for user [\" + username + \"]. Usernames must be unique.\" );\n                }\n\n                password = rs.getString( 1 );\n\n                foundResult = true;\n            }\n        } finally {\n            JdbcUtils.closeResultSet( rs );\n            JdbcUtils.closeStatement( ps );\n        }\n\n        return password;\n    }\n\n    protected AuthorizationInfo doGetAuthorizationInfo(Principal principal) {\n\n        UsernamePrincipal usernamePrincipal = (UsernamePrincipal) principal;\n        String username = usernamePrincipal.getUsername();\n\n        // Null username is invalid\n        if( username == null ) {\n            throw new AuthorizationException( \"Null usernames are not allowed by this realm.\" );\n        }\n\n        Connection conn = null;\n        Collection<String> roleNames = null;\n        Collection<Permission> permissions = null;\n        try {\n            conn = dataSource.getConnection();\n\n            // Retrieve roles and permissions from database\n            roleNames = getRoleNamesForUser(conn, username);\n            permissions = getPermissions(conn, username, roleNames);\n\n        } catch( SQLException e ) {\n            // Rethrow any SQL errors as an authorization exception\n            throw new AuthorizationException( \"There was a SQL error while authorizing user [\" + username + \"]\", e );\n        } finally {\n            JdbcUtils.closeConnection( conn );\n        }\n\n        return new AuthorizationInfo( roleNames, permissions );\n    }\n\n    protected Collection<String> getRoleNamesForUser(Connection conn, String username) throws SQLException {\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        Collection<String> roleNames = new HashSet<String>();\n        try {\n            ps = conn.prepareStatement( userRolesQuery );\n            ps.setString( 1, username );\n\n            // Execute query\n            rs = ps.executeQuery();\n\n            // Loop over results and add each returned role to a set\n            while( rs.next() ) {\n\n                String roleName = rs.getString( 1 );\n\n                // Add the role to the list of names if it isn't null\n                if( roleName != null ) {\n                    roleNames.add( roleName );\n                } else {\n                    if( log.isWarnEnabled() ) {\n                        log.warn( \"Null role name found while retrieving role names for user [\" + username + \"]\" );\n                    }\n                }\n            }\n        } finally {\n            JdbcUtils.closeResultSet( rs );\n            JdbcUtils.closeStatement( ps );\n        }\n        return roleNames;\n    }\n\n    protected Collection<Permission> getPermissions(Connection conn, String username, Collection<String> roleNames) throws SQLException {\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        Collection<Permission> permissions = new HashSet<Permission>();\n        try {\n            for( String roleName : roleNames ) {\n\n                ps = conn.prepareStatement( permissionsQuery );\n                ps.setString( 1, roleName);\n\n                // Execute query\n                rs = ps.executeQuery();\n\n                // Loop over results and add each returned role to a set\n                while( rs.next() ) {\n\n                    String className = rs.getString( 1 );\n                    String target = rs.getString( 2 );\n                    String actions = rs.getString( 3 );\n\n                    // Instantiate a permission object using reflection\n                    Permission permission = PermissionUtils.createPermission( className, target, actions );\n\n                    // Add the permission to the set of permissions\n                    permissions.add( permission );\n                }\n\n            }\n        } finally {\n            JdbcUtils.closeResultSet( rs );\n            JdbcUtils.closeStatement( ps );\n        }\n\n        return permissions;\n    }\n\n}\n","lineNo":281}
{"Refactored Sample":"/*\n* Copyright (C) 2005-2007 Jeremy Haile\n*\n* This library is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as published\n* by the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n* Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the\n*\n* Free Software Foundation, Inc.\n* 59 Temple Place, Suite 330\n* Boston, MA 02111-1307\n* USA\n*\n* Or, you may view it online at\n* http://www.opensource.org/licenses/lgpl-license.php\n*/\n\npackage org.jsecurity.cache.ehcache;\n\nimport net.sf.ehcache.CacheManager;\nimport net.sf.ehcache.Element;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheException;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.List;\n\n/**\n * JSecurity {@link org.jsecurity.cache.Cache} implementation that wraps an EhCache cache.\n *\n * @since 0.2\n * @author Jeremy Haile\n */\n@SuppressWarnings( \"unchecked\" )\npublic class EhCache implements Cache {\n\n    /**\n     * Commons-logging logger\n     */\n    protected final transient Log logger = LogFactory.getLog(getClass());\n\n    /**\n     * The underlying EhCache cache used by this JSecurity cache.\n     */\n    private net.sf.ehcache.Cache cache;\n\n    /**\n     * Constructs a new EhCache instance with the given cache.\n     */\n    public EhCache(net.sf.ehcache.Cache cache) {\n        this.cache = cache;\n    }\n\n    public String getCacheName() {\n        return cache.getName();\n    }\n\n    /**\n     * Gets a value of an element which matches the given key.\n     * @param key the key of the element to return.\n     * @return The value placed into the cache with an earlier put, or null if not found or expired\n     */\n    public Object get(Object key) throws CacheException {\n        try {\n            if ( logger.isDebugEnabled() ) {\n                logger.debug(\"Getting object from cache [\" + getCacheName() + \"] for key [\" + key + \"]\");\n            }\n            if (key == null) {\n                return null;\n            }\n            else {\n                Element element = cache.get( key );\n                if (element == null) {\n                    if ( logger.isDebugEnabled() ) {\n                        logger.debug(\"Element for [\" + key + \"] is null.\");\n                    }\n                    return null;\n                }\n                else {\n                    return element.getObjectValue();\n                }\n            }\n        }\n        catch (net.sf.ehcache.CacheException e) {\n            throw new CacheException(e);\n        }\n    }\n\n\n    /**\n     * Puts an object into the cache.\n     * @param key the key associated with the object\n     * @param value the value associated with the key.\n     */\n    public void update(Object key, Object value) throws CacheException {\n        put(key, value);\n    }\n\n    /**\n     * Puts an object into the cache.\n     * @param key the key.\n     * @param value the value.\n     */\n    public void put(Object key, Object value) throws CacheException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Putting object in cache [\" + getCacheName() + \"] for key [\" + key + \"]\" );\n        }\n\n        try {\n            Element element = new Element( key, value );\n            cache.put(element);\n        }\n        catch (IllegalArgumentException e) {\n            throw new CacheException(e);\n        }\n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n\n    }\n\n    /**\n     * Removes the element which matches the key.\n     * <p>\n     * If no element matches, nothing is removed and no Exception is thrown.\n     * @param key the key of the element to remove\n     */\n    public void remove(Object key) throws CacheException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Removing object from cache [\" + getCacheName() + \"] for key [\" + key + \"]\" );\n        }\n        try {\n            cache.remove( key );\n        }\n        catch (ClassCastException e) {\n            throw new CacheException(e);\n        }\n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n    }\n\n    /**\n     * Remove all elements in the cache, but leave the cache\n     * in a useable state.\n     */\n    public void clear() throws CacheException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Clearing all objects from cache [\" + getCacheName() + \"]\" );\n        }\n        try {\n            cache.removeAll();\n        }\n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n    }\n\n    /**\n     * Remove the cache and make it unuseable.\n     */\n    public void destroy() throws CacheException {\n        try {\n            CacheManager.getInstance().removeCache( cache.getName() );\n        }\n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n        catch (net.sf.ehcache.CacheException e) {\n            throw new CacheException(e);\n        }\n    }\n\n\n    public long getSizeInMemory() {\n        try {\n            return cache.calculateInMemorySize();\n        }\n        catch(Throwable t) {\n            return -1;\n        }\n    }\n\n\n    public long getElementCount() {\n        try {\n            return cache.getSize();\n        } catch( net.sf.ehcache.CacheException ce ) {\n            throw new CacheException( ce );\n        }\n    }\n\n    public long getElementCountInMemory() {\n        try {\n            return cache.getMemoryStoreSize();\n        }\n        catch (net.sf.ehcache.CacheException ce) {\n            throw new CacheException(ce);\n        }\n    }\n\n    public long getElementCountOnDisk() {\n        return cache.getDiskStoreSize();\n    }\n\n    public Map toMap() {\n        try {\n            Map result = new HashMap();\n            if ( cache != null ) {\n                List keys = cache.getKeys();\n                for (Object key : keys) {\n                    Element cacheElement = cache.get( key );\n                    if ( cacheElement != null ) {\n                        Object value = cacheElement.getValue();\n                        if ( value != null ) {\n                            result.put( key, value );\n                        }\n                    }\n                }\n            }\n            return Collections.unmodifiableMap( result );\n        }\n        catch (Exception e) {\n            throw new CacheException(e);\n        }\n    }\n\n    public String toString() {\n        return \"EhCache [\" + getCacheName() + \"]\";\n    }\n}\n","Smelly Sample":"/*\n* Copyright (C) 2005-2007 Jeremy Haile\n*\n* This library is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as published\n* by the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n* Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the\n*\n* Free Software Foundation, Inc.\n* 59 Temple Place, Suite 330\n* Boston, MA 02111-1307\n* USA\n*\n* Or, you may view it online at\n* http://www.opensource.org/licenses/lgpl-license.php\n*/\n\npackage org.jsecurity.cache.ehcache;\n\nimport net.sf.ehcache.CacheManager;\nimport net.sf.ehcache.Element;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheException;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * JSecurity {@link org.jsecurity.cache.Cache} implementation that wraps an EhCache cache.\n *\n * @since 0.2\n * @author Jeremy Haile\n */\n@SuppressWarnings( \"unchecked\" )\npublic class EhCache implements Cache {\n\n    /**\n     * Commons-logging logger\n     */\n    protected final transient Log logger = LogFactory.getLog(getClass());\n\n    /**\n     * The underlying EhCache cache used by this JSecurity cache.\n     */\n    private net.sf.ehcache.Cache cache;\n\n    /**\n     * Constructs a new EhCache instance with the given cache.\n     */\n    public EhCache(net.sf.ehcache.Cache cache) {\n        this.cache = cache;\n    }\n\n    public String getCacheName() {\n        return cache.getName();\n    }\n\n    /**\n     * Gets a value of an element which matches the given key.\n     * @param key the key of the element to return.\n     * @return The value placed into the cache with an earlier put, or null if not found or expired\n     */\n    public Object get(Object key) throws CacheException {\n        try {\n            if ( logger.isDebugEnabled() ) {\n                logger.debug(\"Getting object from cache [\" + getCacheName() + \"] for key [\" + key + \"]\");\n            }\n            if (key == null) {\n                return null;\n            }\n            else {\n                Element element = cache.get( key );\n                if (element == null) {\n                    if ( logger.isDebugEnabled() ) {\n                        logger.debug(\"Element for [\" + key + \"] is null.\");\n                    }\n                    return null;\n                }\n                else {\n                    return element.getObjectValue();\n                }\n            }\n        }\n        catch (net.sf.ehcache.CacheException e) {\n            throw new CacheException(e);\n        }\n    }\n\n\n    /**\n     * Puts an object into the cache.\n     * @param key the key associated with the object\n     * @param value the value associated with the key.\n     */\n    public void update(Object key, Object value) throws CacheException {\n        put(key, value);\n    }\n\n    /**\n     * Puts an object into the cache.\n     * @param key the key.\n     * @param value the value.\n     */\n    public void put(Object key, Object value) throws CacheException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Putting object in cache [\" + getCacheName() + \"] for key [\" + key + \"]\" );\n        }\n\n        try {\n            Element element = new Element( key, value );\n            cache.put(element);\n        }\n        catch (IllegalArgumentException e) {\n            throw new CacheException(e);\n        }\n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n\n    }\n\n    /**\n     * Removes the element which matches the key.\n     * <p>\n     * If no element matches, nothing is removed and no Exception is thrown.\n     * @param key the key of the element to remove\n     */\n    public void remove(Object key) throws CacheException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Removing object from cache [\" + getCacheName() + \"] for key [\" + key + \"]\" );\n        }\n        try {\n            cache.remove( key );\n        }\n        catch (ClassCastException e) {\n            throw new CacheException(e);\n        }\n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n    }\n\n    /**\n     * Remove all elements in the cache, but leave the cache\n     * in a useable state.\n     */\n    public void clear() throws CacheException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Clearing all objects from cache [\" + getCacheName() + \"]\" );\n        }\n        try {\n            cache.removeAll();\n        }\n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n    }\n\n    /**\n     * Remove the cache and make it unuseable.\n     */\n    public void destroy() throws CacheException {\n        try {\n            CacheManager.getInstance().removeCache( cache.getName() );\n        }\n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n        catch (net.sf.ehcache.CacheException e) {\n            throw new CacheException(e);\n        }\n    }\n\n\n    public long getSizeInMemory() {\n        try {\n            return cache.calculateInMemorySize();\n        }\n        catch(Throwable t) {\n            return -1;\n        }\n    }\n\n\n    public long getElementCount() {\n        try {\n            return cache.getSize();\n        } catch( net.sf.ehcache.CacheException ce ) {\n            throw new CacheException( ce );\n        }\n    }\n\n    public long getElementCountInMemory() {\n        try {\n            return cache.getMemoryStoreSize();\n        }\n        catch (net.sf.ehcache.CacheException ce) {\n            throw new CacheException(ce);\n        }\n    }\n\n    public long getElementCountOnDisk() {\n        return cache.getDiskStoreSize();\n    }\n\n    public Map toMap() {\n        try {\n            Map result = new HashMap();\n            for (Object key : cache.getKeys()) {\n                Object value = cache.get(key).getValue();\n                result.put(key, value);\n            }\n            return Collections.unmodifiableMap( result );\n        }\n        catch (Exception e) {\n            throw new CacheException(e);\n        }\n    }\n\n    public String toString() {\n        return \"EhCache [\" + getCacheName() + \"]\";\n    }\n}\n","lineNo":227}
{"Refactored Sample":"/*\n* Copyright (C) 2005-2007 Jeremy Haile\n*\n* This library is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as published\n* by the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n* Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the\n*\n* Free Software Foundation, Inc.\n* 59 Temple Place, Suite 330\n* Boston, MA 02111-1307\n* USA\n*\n* Or, you may view it online at\n* http://www.opensource.org/licenses/lgpl-license.php\n*/\n\npackage org.jsecurity.cache.ehcache;\n\nimport net.sf.ehcache.CacheManager;\nimport net.sf.ehcache.Element;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheException;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.List;\n\n/**\n * JSecurity {@link org.jsecurity.cache.Cache} implementation that wraps an EhCache cache.\n *\n * @since 0.2\n * @author Jeremy Haile\n */\n@SuppressWarnings( \"unchecked\" )\npublic class EhCache implements Cache {\n\n    /**\n     * Commons-logging logger\n     */\n    protected final transient Log logger = LogFactory.getLog(getClass());\n\n    /**\n     * The underlying EhCache cache used by this JSecurity cache.\n     */\n    private net.sf.ehcache.Cache cache;\n\n    /**\n     * Constructs a new EhCache instance with the given cache.\n     */\n    public EhCache(net.sf.ehcache.Cache cache) {\n        this.cache = cache;\n    }\n\n    public String getCacheName() {\n        return cache.getName();\n    }\n\n    /**\n     * Gets a value of an element which matches the given key.\n     * @param key the key of the element to return.\n     * @return The value placed into the cache with an earlier put, or null if not found or expired\n     */\n    public Object get(Object key) throws CacheException {\n        try {\n            if ( logger.isDebugEnabled() ) {\n                logger.debug(\"Getting object from cache [\" + getCacheName() + \"] for key [\" + key + \"]\");\n            }\n            if (key == null) {\n                return null;\n            }\n            else {\n                Element element = cache.get( key );\n                if (element == null) {\n                    if ( logger.isDebugEnabled() ) {\n                        logger.debug(\"Element for [\" + key + \"] is null.\");\n                    }\n                    return null;\n                }\n                else {\n                    return element.getObjectValue();\n                }\n            }\n        }\n        catch (net.sf.ehcache.CacheException e) {\n            throw new CacheException(e);\n        }\n    }\n\n\n    /**\n     * Puts an object into the cache.\n     * @param key the key associated with the object\n     * @param value the value associated with the key.\n     */\n    public void update(Object key, Object value) throws CacheException {\n        put(key, value);\n    }\n\n    /**\n     * Puts an object into the cache.\n     * @param key the key.\n     * @param value the value.\n     */\n    public void put(Object key, Object value) throws CacheException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Putting object in cache [\" + getCacheName() + \"] for key [\" + key + \"]\" );\n        }\n\n        try {\n            Element element = new Element( key, value );\n            cache.put(element);\n        }\n        catch (IllegalArgumentException e) {\n            throw new CacheException(e);\n        }\n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n\n    }\n\n    /**\n     * Removes the element which matches the key.\n     * <p>\n     * If no element matches, nothing is removed and no Exception is thrown.\n     * @param key the key of the element to remove\n     */\n    public void remove(Object key) throws CacheException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Removing object from cache [\" + getCacheName() + \"] for key [\" + key + \"]\" );\n        }\n        try {\n            cache.remove( key );\n        }\n        catch (ClassCastException e) {\n            throw new CacheException(e);\n        }\n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n    }\n\n    /**\n     * Remove all elements in the cache, but leave the cache\n     * in a useable state.\n     */\n    public void clear() throws CacheException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Clearing all objects from cache [\" + getCacheName() + \"]\" );\n        }\n        try {\n            cache.removeAll();\n        }\n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n    }\n\n    /**\n     * Remove the cache and make it unuseable.\n     */\n    public void destroy() throws CacheException {\n        try {\n            CacheManager.getInstance().removeCache( cache.getName() );\n        }\n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n        catch (net.sf.ehcache.CacheException e) {\n            throw new CacheException(e);\n        }\n    }\n\n\n    public long getSizeInMemory() {\n        try {\n            return cache.calculateInMemorySize();\n        }\n        catch(Throwable t) {\n            return -1;\n        }\n    }\n\n\n    public long getElementCount() {\n        try {\n            return cache.getSize();\n        } catch( net.sf.ehcache.CacheException ce ) {\n            throw new CacheException( ce );\n        }\n    }\n\n    public long getElementCountInMemory() {\n        try {\n            return cache.getMemoryStoreSize();\n        }\n        catch (net.sf.ehcache.CacheException ce) {\n            throw new CacheException(ce);\n        }\n    }\n\n    public long getElementCountOnDisk() {\n        return cache.getDiskStoreSize();\n    }\n\n    public Map toMap() {\n        try {\n            Map result = new HashMap();\n            if ( cache != null ) {\n                List keys = cache.getKeys();\n                for (Object key : keys) {\n                    Element cacheElement = cache.get( key );\n                    if ( cacheElement != null ) {\n                        Object value = cacheElement.getValue();\n                        if ( value != null ) {\n                            result.put( key, value );\n                        }\n                    }\n                }\n            }\n            return Collections.unmodifiableMap( result );\n        }\n        catch (Exception e) {\n            throw new CacheException(e);\n        }\n    }\n\n    public String toString() {\n        return \"EhCache [\" + getCacheName() + \"]\";\n    }\n}\n","Smelly Sample":"/*\n* Copyright (C) 2005-2007 Jeremy Haile\n*\n* This library is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as published\n* by the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n* Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the\n*\n* Free Software Foundation, Inc.\n* 59 Temple Place, Suite 330\n* Boston, MA 02111-1307\n* USA\n*\n* Or, you may view it online at\n* http://www.opensource.org/licenses/lgpl-license.php\n*/\n\npackage org.jsecurity.cache.ehcache;\n\nimport net.sf.ehcache.CacheManager;\nimport net.sf.ehcache.Element;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheException;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * JSecurity {@link org.jsecurity.cache.Cache} implementation that wraps an EhCache cache.\n *\n * @since 0.2\n * @author Jeremy Haile\n */\n@SuppressWarnings( \"unchecked\" )\npublic class EhCache implements Cache {\n\n    /**\n     * Commons-logging logger\n     */\n    protected final transient Log logger = LogFactory.getLog(getClass());\n\n    /**\n     * The underlying EhCache cache used by this JSecurity cache.\n     */\n    private net.sf.ehcache.Cache cache;\n\n    /**\n     * Constructs a new EhCache instance with the given cache.\n     */\n    public EhCache(net.sf.ehcache.Cache cache) {\n        this.cache = cache;\n    }\n\n    public String getCacheName() {\n        return cache.getName();\n    }\n\n    /**\n     * Gets a value of an element which matches the given key.\n     * @param key the key of the element to return.\n     * @return The value placed into the cache with an earlier put, or null if not found or expired\n     */\n    public Object get(Object key) throws CacheException {\n        try {\n            if ( logger.isDebugEnabled() ) {\n                logger.debug(\"Getting object from cache [\" + getCacheName() + \"] for key [\" + key + \"]\");\n            }\n            if (key == null) {\n                return null;\n            }\n            else {\n                Element element = cache.get( key );\n                if (element == null) {\n                    if ( logger.isDebugEnabled() ) {\n                        logger.debug(\"Element for [\" + key + \"] is null.\");\n                    }\n                    return null;\n                }\n                else {\n                    return element.getObjectValue();\n                }\n            }\n        }\n        catch (net.sf.ehcache.CacheException e) {\n            throw new CacheException(e);\n        }\n    }\n\n\n    /**\n     * Puts an object into the cache.\n     * @param key the key associated with the object\n     * @param value the value associated with the key.\n     */\n    public void update(Object key, Object value) throws CacheException {\n        put(key, value);\n    }\n\n    /**\n     * Puts an object into the cache.\n     * @param key the key.\n     * @param value the value.\n     */\n    public void put(Object key, Object value) throws CacheException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Putting object in cache [\" + getCacheName() + \"] for key [\" + key + \"]\" );\n        }\n\n        try {\n            Element element = new Element( key, value );\n            cache.put(element);\n        }\n        catch (IllegalArgumentException e) {\n            throw new CacheException(e);\n        }\n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n\n    }\n\n    /**\n     * Removes the element which matches the key.\n     * <p>\n     * If no element matches, nothing is removed and no Exception is thrown.\n     * @param key the key of the element to remove\n     */\n    public void remove(Object key) throws CacheException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Removing object from cache [\" + getCacheName() + \"] for key [\" + key + \"]\" );\n        }\n        try {\n            cache.remove( key );\n        }\n        catch (ClassCastException e) {\n            throw new CacheException(e);\n        }\n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n    }\n\n    /**\n     * Remove all elements in the cache, but leave the cache\n     * in a useable state.\n     */\n    public void clear() throws CacheException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Clearing all objects from cache [\" + getCacheName() + \"]\" );\n        }\n        try {\n            cache.removeAll();\n        }\n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n    }\n\n    /**\n     * Remove the cache and make it unuseable.\n     */\n    public void destroy() throws CacheException {\n        try {\n            CacheManager.getInstance().removeCache( cache.getName() );\n        }\n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n        catch (net.sf.ehcache.CacheException e) {\n            throw new CacheException(e);\n        }\n    }\n\n\n    public long getSizeInMemory() {\n        try {\n            return cache.calculateInMemorySize();\n        }\n        catch(Throwable t) {\n            return -1;\n        }\n    }\n\n\n    public long getElementCount() {\n        try {\n            return cache.getSize();\n        } catch( net.sf.ehcache.CacheException ce ) {\n            throw new CacheException( ce );\n        }\n    }\n\n    public long getElementCountInMemory() {\n        try {\n            return cache.getMemoryStoreSize();\n        }\n        catch (net.sf.ehcache.CacheException ce) {\n            throw new CacheException(ce);\n        }\n    }\n\n    public long getElementCountOnDisk() {\n        return cache.getDiskStoreSize();\n    }\n\n    public Map toMap() {\n        try {\n            Map result = new HashMap();\n            for (Object key : cache.getKeys()) {\n                Object value = cache.get(key).getValue();\n                result.put(key, value);\n            }\n            return Collections.unmodifiableMap( result );\n        }\n        catch (Exception e) {\n            throw new CacheException(e);\n        }\n    }\n\n    public String toString() {\n        return \"EhCache [\" + getCacheName() + \"]\";\n    }\n}\n","lineNo":225}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.session.support.eis.support;\n\nimport org.jsecurity.cache.support.HashtableCacheProvider;\nimport org.jsecurity.session.Session;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Map;\n\n/**\n * Simple memory-based implementation of the SessionDAO.  It does not save session data to disk, so\n * this implementation is not recommended in production-quality recoverable environments\n * (i.e. those needing session state restored when a server restarts).\n *\n * <p>If you need session recovery in the event of a server failure or restart, consider using\n * a file-based or RDBMS-based implementation.\n *\n * @since 0.1\n * @author Les Hazlewood\n */\npublic class MemorySessionDAO extends AbstractCachingSessionDAO {\n\n    public MemorySessionDAO() {\n        setCacheProvider( new HashtableCacheProvider() );\n        setMaintainStoppedSessions( true );\n    }\n\n\n    protected Serializable doCreate(Session session) {\n        //no need to do anything with the session - parent class persists to in-memory cache already.  Just return id:\n        return session.getSessionId();\n    }\n\n    protected Session doReadSession( Serializable sessionId ) {\n        return null; //should never execute because this implementation relies on parent class to access cache, which\n                     //is where all in-memory sessions reside.\n    }\n\n    protected void doUpdate(Session session) {\n        //does nothing - parent class persists to in-memory cache.\n    }\n\n    protected void doDelete(Session session) {\n        //does nothing - parent class removes from in-memory cache.\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Collection<Session> getActiveSessions() {\n        if ( activeSessions != null ) {\n            Map sessionsMap = activeSessions.toMap();\n            if ( sessionsMap != null && !sessionsMap.isEmpty() ) {\n                return Collections.unmodifiableCollection( sessionsMap.values() );\n            }\n        }\n        return Collections.EMPTY_LIST;\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.session.support.eis.support;\n\nimport org.jsecurity.cache.support.HashtableCacheProvider;\nimport org.jsecurity.session.Session;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * Simple memory-based implementation of the SessionDAO.  It does not save session data to disk, so\n * this implementation is not recommended in production-quality recoverable environments\n * (i.e. those needing session state restored when a server restarts).\n *\n * <p>If you need session recovery in the event of a server failure or restart, consider using\n * a file-based or RDBMS-based implementation.\n *\n * @since 0.1\n * @author Les Hazlewood\n */\npublic class MemorySessionDAO extends AbstractCachingSessionDAO {\n\n    public MemorySessionDAO() {\n        setCacheProvider( new HashtableCacheProvider() );\n        setMaintainStoppedSessions( true );\n    }\n\n\n    protected Serializable doCreate(Session session) {\n        //no need to do anything with the session - parent class persists to in-memory cache already.  Just return id:\n        return session.getSessionId();\n    }\n\n    protected Session doReadSession( Serializable sessionId ) {\n        return null; //should never execute because this implementation relies on parent class to access cache, which\n                     //is where all in-memory sessions reside.\n    }\n\n    protected void doUpdate(Session session) {\n        //does nothing - parent class persists to in-memory cache.\n    }\n\n    protected void doDelete(Session session) {\n        //does nothing - parent class removes from in-memory cache.\n    }\n\n    public Collection<Session> getActiveSessions() {\n        return Collections.unmodifiableCollection( activeSessions.toMap().values() );\n    }\n}\n","lineNo":76}
{"Refactored Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile, Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.authc.support;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.Authenticator;\nimport org.jsecurity.authc.event.AuthenticationEvent;\nimport org.jsecurity.authc.event.AuthenticationEventFactory;\nimport org.jsecurity.authc.event.AuthenticationEventSender;\nimport org.jsecurity.authc.event.support.SimpleAuthenticationEventFactory;\nimport org.jsecurity.authc.module.AuthenticationInfo;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.bind.SecurityContextBinder;\nimport org.jsecurity.context.bind.support.ThreadLocalSecurityContextBinder;\nimport org.jsecurity.context.factory.SecurityContextFactory;\nimport org.jsecurity.context.factory.support.DelegatingSecurityContextFactory;\nimport org.jsecurity.realm.RealmManager;\n\n/**\n * Superclass for almost all {@link Authenticator} implementations that performs the common work around authentication\n * attempts.\n *\n * <p>This class delegates the actual authentication attempt to subclasses but will send events based on a\n * successful or failed attempt, create a {@link SecurityContext SecurityContext} in the event of a successful attmept,\n * and bind this <tt>SecurityContext<\/tt> to the application for further use.\n *\n * <p>In most cases, the only thing a subclass needs to do (via its {@link #doAuthenticate} implementation)\n * is perform the actual principal/credential verification process for the submitted <tt>AuthenticationToken<\/tt>.\n *\n * <p>Failure or success events are triggered based on {@link #doAuthenticate} throwing an exception or not,\n * respectively.  The actual events themselves are constructed via an {@link AuthenticationEventFactory} and sent\n * to interested parties via a {@link AuthenticationEventSender}, both of which may be set as properties of this class\n * (instead of overriding this class for event creation and sending).\n *\n * <p>After a successful login attempt, <tt>SecurityContext<\/tt>s are also created via a {@link SecurityContextFactory}.\n * This may also be set as a property of this class to avoid overriding this class if desired.\n *\n * <p>Once a <tt>SecurityContext<\/tt> is created for authenticated subject, it is <em>bound<\/em> to the application for\n * later access in an application-specific manner (thread-local, http cookie, etc).  This binding is performed by this \n * class via a default thread-local {@link SecurityContextBinder}, which also may be overridden as a\n * {@link #setSecurityContextBinder class property}.\n *\n * @since 0.1\n * @author Jeremy Haile\n * @author Les Hazlewood\n */\npublic abstract class AbstractAuthenticator implements Authenticator {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logging logger\n     */\n    protected final transient Log logger = LogFactory.getLog(getClass());\n\n    /**\n     * The factory used to wrap authorization context after authentication.\n     */\n    private SecurityContextFactory securityContextFactory = null;\n\n    /**\n     * The binder used to bind the authorization context so that it is accessible on subsequent\n     * requests.\n     */\n    private SecurityContextBinder securityContextBinder = new ThreadLocalSecurityContextBinder();\n\n    /**\n     * Factory used to create authentication events for publishing.\n     */\n    private AuthenticationEventFactory authcEventFactory = new SimpleAuthenticationEventFactory();\n\n    /**\n     * Sender used to publish authentication events.  The default is null, which means the events\n     * are not published.\n     */\n    private AuthenticationEventSender authcEventSender = null;\n\n    /**\n     * Used to initialize the default authorization context factory.\n     */\n    private RealmManager realmManager = null;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AbstractAuthenticator(){}\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    /**\n     * Returns the <tt>SecurityContextFactory<\/tt> that this Authenticator will use to create a <tt>SecurityContext<\/tt>\n     * upon a successful authentication attempt.\n     * @return the <tt>SecurityContextFactory<\/tt> that this Authenticator will use to create a <tt>SecurityContext<\/tt>\n     * upon a successful authentication attempt.\n     *\n     * @see #setSecurityContextFactory #setSecurityContextFactory for more explanation.\n     */\n    protected SecurityContextFactory getSecurityContextFactory() {\n        return securityContextFactory;\n    }\n\n\n    /**\n     * Sets the <tt>SecurityContextFactory<\/tt> that this Authenticator will use to create a <tt>SecurityContext<\/tt>\n     * upon a successful authentication attempt.\n     *\n     * <p>It is not recommended to override this property, but instead set the\n     * {@link #setRealmManager RealmManager} property.  When a <tt>RealmManager<\/tt> property is set, this class will\n     * use it to construct an internal {@link DelegatingSecurityContextFactory DelegatingSecurityContextFactory}, which\n     * uses the RealmManager in a more efficient manner.\n     *\n     * @param securityContextFactory the <tt>SecurityContextFactory<\/tt> that this Authenticator will use to create a\n     * <tt>SecurityContext<\/tt> upon a successful authentication attempt.\n     */\n    public void setSecurityContextFactory( SecurityContextFactory securityContextFactory ) {\n        this.securityContextFactory = securityContextFactory;\n    }\n\n\n    /**\n     * Returns the <tt>SecurityContextBinder<\/tt> this <tt>Authenticator<\/tt> will use to <em>bind<\/em> a subject's\n     * <tt>SecurityContext<\/tt> to the application for later use.\n     * @return the <tt>SecurityContextBinder<\/tt> this <tt>Authenticator<\/tt> will use to <em>bind<\/em> a subject's\n     * <tt>SecurityContext<\/tt> to the application for later use.\n     *\n     * @see #setSecurityContextBinder #setSecurityContextBinder for more explanation.\n     */\n    public SecurityContextBinder getSecurityContextBinder() {\n        return securityContextBinder;\n    }\n\n    /**\n     * Sets the <tt>SecurityContextBinder<\/tt> this <tt>Authenticator<\/tt> will use to <em>bind<\/em> a subject's\n     * <tt>SecurityContext<\/tt> to the application for later use.\n     *\n     * <p>The default implementation used by this class is a\n     * {@link ThreadLocalSecurityContextBinder ThreadLocalSecurityContextBinder} and probably shouldn't be overridden\n     * in server-side applications such as Web or EJB apps unless you know what you are doing.\n     *\n     * <p>This property probably <b><em>will<\/em><\/b> however probably need to be changed if in a standalone\n     * client environment, such as in an Applet or Java Web Start application, where the <tt>SecurityContext<\/tt> will\n     * need to be accessible in a well-known location such as in a static memory variable (less desireable), or in\n     * a better managed application context (e.g. Spring or Pico - more desireable).\n     *\n     * @param securityContextBinder the <tt>SecurityContextBinder<\/tt> this <tt>Authenticator<\/tt> will use to\n     * <em>bind<\/em> a subject's <tt>SecurityContext<\/tt> to the application for later use.\n     */\n    public void setSecurityContextBinder( SecurityContextBinder securityContextBinder ) {\n        this.securityContextBinder = securityContextBinder;\n    }\n\n    /**\n     * Returns the <tt>AuthenticationEventFactory<\/tt> this <tt>Authenticator<\/tt> will use to create\n     * <tt>AuthenticationEvents<\/tt> during successful or failed authentication attempts.\n     * @return the <tt>AuthenticationEventFactory<\/tt> this <tt>Authenticator<\/tt> will use to create\n     * <tt>AuthenticationEvents<\/tt> during successful or failed authentication attempts.\n     */\n    public AuthenticationEventFactory getAuthenticationEventFactory() {\n        return authcEventFactory;\n    }\n\n    /**\n     * Sets the <tt>AuthenticationEventFactory<\/tt> this <tt>Authenticator<\/tt> will use to create\n     * <tt>AuthenticationEvents<\/tt> during successful or failed authentication attempts.\n     * @param factory the <tt>AuthenticationEventFactory<\/tt> this <tt>Authenticator<\/tt> will use to create\n     * <tt>AuthenticationEvents<\/tt> during successful or failed authentication attempts.\n     */\n    public void setAuthenticationEventFactory( AuthenticationEventFactory factory ) {\n        this.authcEventFactory = factory;\n    }\n\n    /**\n     * Returns the <tt>AuthenticationEventSender<\/tt> this Authenticator will use to send <tt>AuthenticationEvent<\/tt>s\n     * to interested parties once an event is created.\n     * @return the <tt>AuthenticationEventSender<\/tt> this Authenticator will use to send <tt>AuthenticationEvent<\/tt>s\n     * to interested parties once an event is created.\n     */\n    public AuthenticationEventSender getAuthenticationEventSender() {\n        return authcEventSender;\n    }\n\n    /**\n     * Sets the <tt>AuthenticationEventSender<\/tt> this Authenticator will use to send <tt>AuthenticationEvent<\/tt>s\n     * to interested parties once an event is created.\n     * @param authcEventSender the <tt>AuthenticationEventSender<\/tt> this Authenticator will use to send\n     * <tt>AuthenticationEvent<\/tt>s to interested parties once an event is created.\n     */\n    public void setAuthenticationEventSender( AuthenticationEventSender authcEventSender ) {\n        this.authcEventSender = authcEventSender;\n    }\n\n    /**\n     * Sets the RealmManager that will be used to construct and set this class's <tt>SecurityContextFactory<\/tt>\n     * property if one is not explicitly set via the {@link #setSecurityContextFactory} method.\n     *\n     * <p>It <b>IS<\/b> recommended that most configurations set this <tt>realmManager<\/tt> property and\n     * <b><em>NOT<\/em><\/b> explicitly set the <tt>SecurityContextFactory<\/tt> property unless you know what you're\n     * doing and/or need special behavior.\n     * \n     * @param realmManager the RealmManager that will be used to construct an internal <tt>SecurityContextFactory<\/tt>.\n     */\n    public void setRealmManager(RealmManager realmManager) {\n        this.realmManager = realmManager;\n    }\n\n\n    /*-------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Public initializer that should be called after all class properties have been set, but before the instance\n     * is used to process authentications.\n     */\n    public void init() {\n        if( getSecurityContextFactory() == null ) {\n            if( realmManager == null ) {\n                throw new IllegalStateException( \"If an authorization context factory is not injected, a realm manager must be \" +\n                    \"provided so that the default \" + DelegatingSecurityContextFactory.class.getName() +\n                    \" factory can be initialized.\" );\n            }\n            setSecurityContextFactory( new DelegatingSecurityContextFactory( realmManager ) );\n        }\n        onInit();\n    }\n\n    /**\n     * Subclass template hook to allow subclasses additional initialization behavior without having to override the\n     * {@link #init init()} method.\n     */\n    protected void onInit(){}\n\n    /**\n     * Creates an <tt>AuthenticationEvent<\/tt> in the event of a failed authentication attempt, based on the given\n     * authentication token and exception that occurred during the attempt.\n     *\n     * <p>The default implementation merely delegates creation to the internal {@link AuthenticationEventFactory}\n     * property.\n     *\n     * @param token the authentication token reprenting the subject (user)'s authentication attempt.\n     * @param ae the <tt>AuthenticationException<\/tt> that occurred as a result of the attempt.\n     * @return an event that represents the failed attempt.\n     */\n    protected AuthenticationEvent createFailureEvent( AuthenticationToken token,\n                                                      AuthenticationException ae ) {\n        AuthenticationEventFactory factory = getAuthenticationEventFactory();\n        return factory.createFailureEvent( token, ae );\n    }\n\n    /**\n     * Creates an <tt>AuthenticationEvent<\/tt> in the event of a successful authentication attempt, based on the given\n     * authentication token and <tt>AuthenticationInfo<\/tt> that was created as a result of the successful attempt.\n     *\n     * <p>The default implementation merely delegates creation to the internal {@link AuthenticationEventFactory}\n     * property.\n     *\n     * @param token the authentication token reprenting the subject (user)'s authentication attempt.\n     * @param info the <tt>AuthenticationInfo<\/tt> returned by {@link #doAuthenticate} after the successful attempt.\n     * @return an event that represents the successful attempt.\n     */\n    protected AuthenticationEvent createSuccessEvent( AuthenticationToken token,\n                                                      AuthenticationInfo info ) {\n        AuthenticationEventFactory factory = getAuthenticationEventFactory();\n        return factory.createSuccessEvent( token, info );\n    }\n\n    /**\n     * Utility method that first creates a failure event based on the given token and exception and then actually sends\n     * the event.\n     *\n     * <p>The default implementation does not attempt to create an event if the {@link #setAuthenticationEventSender}\n     * property has not been set - the logic is that event creation overhead will not be incurred if it would never\n     * be sent.\n     *\n     * @param token the authentication token reprenting the subject (user)'s authentication attempt.\n     * @param ae the <tt>AuthenticationException<\/tt> that occurred as a result of the attempt.\n     */\n    protected void sendFailureEvent( AuthenticationToken token, AuthenticationException ae ) {\n        AuthenticationEventSender sender = getAuthenticationEventSender();\n        //only incur event creation overhead if the event can actually be sent:\n        if ( sender != null ) {\n            AuthenticationEvent event = createFailureEvent( token, ae );\n            if ( event != null ) {\n                send( event );\n            } else {\n                if ( logger.isDebugEnabled() ) {\n                    logger.debug( \"No AuthenticationEvent instance returned from \" +\n                               \"'createFailureEvent' method call.  No failed authentication \" +\n                               \"event will be sent.\" );\n                }\n            }\n        } else {\n            if ( logger.isTraceEnabled() ) {\n                logger.trace( \"No AuthenticationEventSender configured.  No failure event will \" +\n                           \"be sent\" );\n            }\n        }\n\n    }\n\n    /**\n     * Utility method that first creates a success event based on the given token and info and then actually sends\n     * the event.\n     *\n     * <p>The default implementation does not attempt to create an event if the {@link #setAuthenticationEventSender}\n     * property has not been set - the logic is that event creation overhead will not be incurred if it would never be\n     * sent.\n     *\n     * @param token the authentication token reprenting the subject (user)'s authentication attempt.\n     * @param info the <tt>AuthenticationInfo<\/tt> returned by {@link #doAuthenticate} after the successful attempt.\n     */\n    protected void sendSuccessEvent( AuthenticationToken token, AuthenticationInfo info ) {\n        AuthenticationEventSender sender = getAuthenticationEventSender();\n        //only incur event creation overhead if the event can actually be sent:\n        if ( sender != null ) {\n            AuthenticationEvent event = createSuccessEvent( token, info );\n            if ( event != null ) {\n                send( event );\n            } else {\n                if ( logger.isDebugEnabled() ) {\n                    logger.debug( \"No AuthenticationEvent instance returned from \" +\n                            \"'createSuccessEvent' method call.  No successful authentication \" +\n                            \"event will be sent.\" );\n                }\n            }\n        } else {\n            if ( logger.isTraceEnabled() ) {\n                logger.trace( \"No AuthenticationEventSender configured.  No success event will \" +\n                           \"be sent\" );\n            }\n        }\n    }\n\n    /**\n     * Utility method that will send any type of <tt>AuthenticationEvent<\/tt> instance.\n     *\n     * <p>The default implementation merely delegates to the internal {@link AuthenticationEventSender} property if\n     * it exists.\n     *\n     * @param event the <tt>AuthenticationEvent<\/tt> to send to interested parties.\n     * \n     * @throws IllegalArgumentException if the method argument is null\n     */\n    protected void send( AuthenticationEvent event ) throws IllegalArgumentException {\n        if ( event == null ) {\n            throw new IllegalArgumentException( \"AuthenticationEvent argument cannot be null\" );\n        }\n        AuthenticationEventSender sender = getAuthenticationEventSender();\n        if ( sender != null ) {\n            try {\n                sender.send( event );\n            } catch ( Throwable t ) {\n                if ( logger.isWarnEnabled() ) {\n                    logger.warn( \"Unable to send AuthenticationEvent [\" + event + \"]\", t );\n                }\n            }\n        } else {\n            if ( logger.isTraceEnabled() ) {\n                logger.trace( \"No AuthenticationEventSender configured.  Event [\" + event + \"] will \" +\n                        \"not be sent.\" );\n            }\n        }\n    }\n\n    /**\n     * Creates a <tt>SecurityContext<\/tt> instance for the user represented by the given method argument.\n     *\n     * <p>The default implementation delegates to the internal {@link SecurityContextFactory} property.\n     *\n     * @param info the <tt>AuthenticationInfo<\/tt> of a newly authenticated subject/user.\n     * @return the <tt>SecurityContext<\/tt> that represents the authorization and session data for the newly\n     * authenticated subject/user.\n     */\n    protected SecurityContext createSecurityContext( AuthenticationInfo info ) {\n        SecurityContextFactory factory = getSecurityContextFactory();\n        if( factory == null ) {\n            throw new IllegalStateException(\n                    \"No security context factory is configured, so authentication cannot \" +\n                    \"be completed.  Make sure the init() method is being called on the \" +\n                    \"authenticator before it is used.\" );\n        }\n\n        return factory.createSecurityContext( info );\n    }\n\n    /**\n     * Binds a <tt>SecurityContext<\/tt> instance created after authentication to the application for later use.\n     *\n     * <p>The default implementation merely delegates to the internal {@link SecurityContextBinder} property.\n     *\n     * @param secCtx the <tt>SecurityContext<\/tt> instance created after authentication to be bound to the application\n     * for later use.\n     */\n    protected void bind( SecurityContext secCtx ) {\n        getSecurityContextBinder().bindSecurityContext( secCtx );\n    }\n\n    private void assertCreation( SecurityContext secCtx ) throws IllegalStateException {\n        if ( secCtx == null ) {\n            String msg = \"Programming or configuration error - No SecurityContext was created after successful \" +\n                    \"authentication.  Verify that you have either configured the \" + getClass().getName() +\n                    \" instance with a proper \" + SecurityContextFactory.class.getName() + \" (easier) or \" +\n                    \"that you have overridden the \" + AbstractAuthenticator.class.getName() +\n                    \".createSecurityContext( AuthenticationInfo info ) method.\";\n            throw new IllegalStateException( msg );\n        }\n    }\n\n    /**\n     * Implementation of the {@link Authenticator} interface that functions in the following manner:\n     *\n     * <ol>\n     * <li>Calls template {@link #doAuthenticate doAuthenticate} method for subclass execution of the actual\n     * authentication behavior.<\/li>\n     * <li>If an <tt>AuthenticationException<\/tt> is thrown during <tt>doAuthenticate<\/tt>, create and send a\n     * failure <tt>AuthenticationEvent<\/tt> that represents this failure, and then propogate this exception\n     * for the caller to handle.<\/li>\n     * <li>If no exception is thrown (indicating a successful login), perform the following:\n     *     <ol>\n     *         <li>{@link #createSecurityContext Create a <tt>SecurityContext<\/tt>} instance that represents the\n     *             <tt>AuthenticationInfo<\/tt> returned by <tt>doAuthenticate<\/tt><\/li>\n     *         <li>{@link #bind Bind this newly created SecurityContext} to the application such that it can be\n     *             referenced by the application later.<\/li>\n     *         <li>Create and send a success <tt>AuthenticationEvent<\/tt> noting the successful authentication.<\/li>\n     *         <li>Return the newly created <tt>SecurityContext<\/tt> to the caller should they wish to use it\n     *             immediately.<\/li>\n     *     <\/ol>\n     * <\/li>\n     * <\/ol>\n     * @param token the submitted token representing the subject's (user's) login principals and credentials.\n     * @return the SecurityContext referencing the authenticated user's access rights.\n     *\n     * @throws AuthenticationException if there is any problem during the authentication process - see the\n     * interface's JavaDoc for a more detailed explanation.\n     */\n    public final SecurityContext authenticate( AuthenticationToken token )\n            throws AuthenticationException {\n\n        if ( logger.isTraceEnabled() ) {\n            logger.trace( \"Authentication request received for token [\" + token + \"]\" );\n        }\n\n        AuthenticationInfo info;\n        try {\n            info = doAuthenticate( token );\n            if ( info == null ) {\n                throw new AuthenticationException( \"Authentication token of type [\" +\n                    token.getClass() + \"] could not be processed for authentication.  Check that \" +\n                    \"the Authenticator is configured correctly.\" );\n            }\n        } catch ( AuthenticationException e ) {\n            if ( logger.isInfoEnabled() ) {\n                logger.info( \"Authentication failed for token submission [\" + token + \"] because [\" + e.getMessage() + \"]\" );\n            }\n            sendFailureEvent( token, e );\n            throw e;\n        }\n\n        if ( logger.isInfoEnabled() ) {\n            logger.info( \"Authentication successful.  Returned authentication info: [\" + info + \"]\" );\n        }\n\n        SecurityContext secCtx = createSecurityContext( info );\n\n        assertCreation( secCtx );\n\n        bind( secCtx );\n\n        sendSuccessEvent( token, info );\n\n        return secCtx;\n    }\n\n    /**\n     * Template design pattern hook for subclasses to implement specific authentication behavior.\n     *\n     * <p>Common behavior for most all common authentication attempts is encapsulated in the \n     * {@link #authenticate} method and that method invokes this one for custom behavior.\n     *\n     * <p><b>N.B.<\/b> Subclasses <em>should<\/em> throw some kind of\n     * <tt>AuthenticationException<\/tt> if there is a problem during\n     * authentication instead of returning <tt>null<\/tt>.  A <tt>null<\/tt> return value indicates\n     * a configuration or programming error, since <tt>AuthenticationException<\/tt>s should\n     * indicate any expected problem.\n     *\n     * @param token the authentication token encapsulating the user's login information.\n     * @return an <tt>AuthenticationInfo<\/tt> object encapsulating the user's account information\n     * important to JSecurity.  <tt>null<\/tt> should <em>not<\/em> be returned.\n     * @throws AuthenticationException if there is a problem logging in the user.\n     */\n    protected abstract AuthenticationInfo doAuthenticate( AuthenticationToken token )\n            throws AuthenticationException;\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005-2007 Jeremy Haile, Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.authc.support;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.Authenticator;\nimport org.jsecurity.authc.event.AuthenticationEvent;\nimport org.jsecurity.authc.event.AuthenticationEventFactory;\nimport org.jsecurity.authc.event.AuthenticationEventSender;\nimport org.jsecurity.authc.event.support.SimpleAuthenticationEventFactory;\nimport org.jsecurity.authc.module.AuthenticationInfo;\nimport org.jsecurity.context.SecurityContext;\nimport org.jsecurity.context.bind.SecurityContextBinder;\nimport org.jsecurity.context.bind.support.ThreadLocalSecurityContextBinder;\nimport org.jsecurity.context.factory.SecurityContextFactory;\nimport org.jsecurity.context.factory.support.DelegatingSecurityContextFactory;\nimport org.jsecurity.realm.RealmManager;\n\n/**\n * Superclass for {@link Authenticator} implementations that performs the common work of wrapping a\n * returned {@link SecurityContext} using an {@link SecurityContextFactory} and binding\n * the context using an {@link org.jsecurity.context.bind.SecurityContextBinder}.  Subclasses should implement the {@link\n * #doAuthenticate(org.jsecurity.authc.AuthenticationToken)} method.\n *\n * @since 0.1\n * @author Jeremy Haile\n * @author Les Hazlewood\n */\npublic abstract class AbstractAuthenticator implements Authenticator {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logging logger\n     */\n    protected final transient Log logger = LogFactory.getLog(getClass());\n\n    /**\n     * The factory used to wrap authorization context after authentication.\n     */\n    private SecurityContextFactory securityContextFactory = null;\n\n    /**\n     * The binder used to bind the authorization context so that it is accessible on subsequent\n     * requests.\n     */\n    private SecurityContextBinder securityContextBinder = new ThreadLocalSecurityContextBinder();\n\n    /**\n     * Factory used to create authentication events for publishing.\n     */\n    private AuthenticationEventFactory authcEventFactory = new SimpleAuthenticationEventFactory();\n\n    /**\n     * Sender used to publish authentication events.  The default is null, which means the events\n     * are not published.\n     */\n    private AuthenticationEventSender authcEventSender = null;\n\n    /**\n     * Used to initialize the default authorization context factory.\n     */\n    private RealmManager realmManager = null;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AbstractAuthenticator(){}\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    protected SecurityContextFactory getSecurityContextFactory() {\n        return securityContextFactory;\n    }\n\n\n    public void setSecurityContextFactory( SecurityContextFactory securityContextFactory ) {\n        this.securityContextFactory = securityContextFactory;\n    }\n\n\n    public SecurityContextBinder getSecurityContextBinder() {\n        return securityContextBinder;\n    }\n\n\n    public void setSecurityContextBinder( SecurityContextBinder securityContextBinder ) {\n        this.securityContextBinder = securityContextBinder;\n    }\n\n    public AuthenticationEventFactory getAuthenticationEventFactory() {\n        return authcEventFactory;\n    }\n\n    public void setAuthenticationEventFactory( AuthenticationEventFactory factory ) {\n        this.authcEventFactory = factory;\n    }\n\n    public AuthenticationEventSender getAuthenticationEventSender() {\n        return authcEventSender;\n    }\n\n    public void setAuthenticationEventSender( AuthenticationEventSender authcEventSender ) {\n        this.authcEventSender = authcEventSender;\n    }\n\n\n    public void setRealmManager(RealmManager realmManager) {\n        this.realmManager = realmManager;\n    }\n\n\n    /*-------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    public void init() {\n        if( getSecurityContextFactory() == null ) {\n            if( realmManager == null ) {\n                throw new IllegalStateException( \"If an authorization context factory is not injected, a realm manager must be \" +\n                    \"provided so that the default \" + DelegatingSecurityContextFactory.class.getName() + \"] \" +\n                    \"factory can be initialized.\" );\n            }\n            setSecurityContextFactory( new DelegatingSecurityContextFactory( realmManager ) );\n        }\n    }\n\n    protected AuthenticationEvent createFailureEvent( AuthenticationToken token,\n                                                      AuthenticationException ae ) {\n        AuthenticationEventFactory factory = getAuthenticationEventFactory();\n        return factory.createFailureEvent( token, ae );\n    }\n\n    protected AuthenticationEvent createSuccessEvent( AuthenticationToken token,\n                                                      AuthenticationInfo info ) {\n        AuthenticationEventFactory factory = getAuthenticationEventFactory();\n        return factory.createSuccessEvent( token, info );\n    }\n\n    protected void sendFailureEvent( AuthenticationToken token, AuthenticationException ae ) {\n        AuthenticationEventSender sender = getAuthenticationEventSender();\n        //only incur event creation overhead if the event can actually be sent:\n        if ( sender != null ) {\n            AuthenticationEvent event = createFailureEvent( token, ae );\n            if ( event != null ) {\n                send( event );\n            } else {\n                if ( logger.isDebugEnabled() ) {\n                    logger.debug( \"No AuthenticationEvent instance returned from \" +\n                               \"'createFailureEvent' method call.  No failed authentication \" +\n                               \"event will be sent.\" );\n                }\n            }\n        } else {\n            if ( logger.isTraceEnabled() ) {\n                logger.trace( \"No AuthenticationEventSender configured.  No failure event will \" +\n                           \"be sent\" );\n            }\n        }\n\n    }\n\n    protected void sendSuccessEvent( AuthenticationToken token, AuthenticationInfo info ) {\n        AuthenticationEventSender sender = getAuthenticationEventSender();\n        //only incur event creation overhead if the event can actually be sent:\n        if ( sender != null ) {\n            AuthenticationEvent event = createSuccessEvent( token, info );\n            if ( event != null ) {\n                send( event );\n            } else {\n                if ( logger.isDebugEnabled() ) {\n                    logger.debug( \"No AuthenticationEvent instance returned from \" +\n                            \"'createSuccessEvent' method call.  No successful authentication \" +\n                            \"event will be sent.\" );\n                }\n            }\n        } else {\n            if ( logger.isTraceEnabled() ) {\n                logger.trace( \"No AuthenticationEventSender configured.  No success event will \" +\n                           \"be sent\" );\n            }\n        }\n    }\n\n    protected void send( AuthenticationEvent event ) throws IllegalArgumentException {\n        if ( event == null ) {\n            throw new IllegalArgumentException( \"AuthenticationEvent argument cannot be null\" );\n        }\n        AuthenticationEventSender sender = getAuthenticationEventSender();\n        if ( sender != null ) {\n            try {\n                sender.send( event );\n            } catch ( Throwable t ) {\n                if ( logger.isWarnEnabled() ) {\n                    logger.warn( \"Unable to send AuthenticationEvent [\" + event + \"]\", t );\n                }\n            }\n        } else {\n            if ( logger.isTraceEnabled() ) {\n                logger.trace( \"No AuthenticationEventSender configured.  Event [\" + event + \"] will \" +\n                        \"not be sent.\" );\n            }\n        }\n    }\n\n    protected SecurityContext createSecurityContext( AuthenticationInfo info ) {\n        if( getSecurityContextFactory() == null ) {\n            throw new IllegalStateException(\n                    \"No security context factory is configured, so authentication cannot \" +\n                    \"be completed.  Make sure the init() method is being called on the \" +\n                    \"authenticator before it is used.\" );\n        }\n\n        return getSecurityContextFactory().createSecurityContext( info );\n    }\n\n    protected void bind( SecurityContext authzCtx ) {\n        getSecurityContextBinder().bindSecurityContext( authzCtx );\n    }\n\n    private void assertCreation( SecurityContext authzCtx ) throws IllegalStateException {\n        if ( authzCtx == null ) {\n            String msg = \"Programming or configuration error - No SecurityContext was created after successful \" +\n                    \"authentication.  Verify that you have either configured the \" + getClass().getName() +\n                    \" instance with a proper \" + SecurityContextFactory.class.getName() + \" (easier) or \" +\n                    \"that you have overridden the \" + AbstractAuthenticator.class.getName() +\n                    \".createSecurityContext( AuthenticationInfo info ) method.\";\n            throw new IllegalStateException( msg );\n        }\n    }\n\n    public final SecurityContext authenticate( AuthenticationToken token )\n            throws AuthenticationException {\n\n        if ( logger.isTraceEnabled() ) {\n            logger.trace( \"Authentication request received for token [\" + token + \"]\" );\n        }\n\n        AuthenticationInfo info;\n        try {\n            info = doAuthenticate( token );\n            if ( info == null ) {\n                throw new AuthenticationException( \"Authentication token of type [\" +\n                    token.getClass() + \"] could not be processed for authentication.  Check that \" +\n                    \"the Authenticator is configured correctly.\" );\n            }\n        } catch ( AuthenticationException e ) {\n            if ( logger.isInfoEnabled() ) {\n                logger.info( \"Authentication failed for token submission [\" + token + \"] because [\" + e.getMessage() + \"]\" );\n            }\n            sendFailureEvent( token, e );\n            throw e;\n        }\n\n        if ( logger.isInfoEnabled() ) {\n            logger.info( \"Authentication successful.  Returned authentication info: [\" + info + \"]\" );\n        }\n\n        SecurityContext authzCtx = createSecurityContext( info );\n\n        assertCreation( authzCtx );\n\n        bind( authzCtx );\n\n        sendSuccessEvent( token, info );\n\n        return authzCtx;\n    }\n\n    /**\n     * Template design pattern hook for subclasses to implement specific authentication behavior.\n     *\n     * <p>Common behavior for most all common authentication attempts is encapsulated in the \n     * {@link #authenticate} method and that method invokes this one for custom behavior.\n     *\n     * <p><b>N.B.<\/b> Subclasses <em>should<\/em> throw some kind of\n     * <tt>AuthenticationException<\/tt> if there is a problem during\n     * authentication instead of returning <tt>null<\/tt>.  A <tt>null<\/tt> return value indicates\n     * a configuration or programming error, since <tt>AuthenticationException<\/tt>s should\n     * indicate any expected problem.\n     *\n     * @param token the authentication token encapsulating the user's login information.\n     * @return an <tt>AuthenticationInfo<\/tt> object encapsulating the user's account information\n     * important to JSecurity.  <tt>null<\/tt> should <em>not<\/em> be returned.\n     * @throws AuthenticationException if there is a problem logging in the user.\n     */\n    protected abstract AuthenticationInfo doAuthenticate( AuthenticationToken token )\n            throws AuthenticationException;\n}\n","lineNo":406}
{"Refactored Sample":"/*\n * Copyright (C) 2005 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.ri.authc.module;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authc.module.AuthenticationInfo;\nimport org.jsecurity.authc.module.AuthenticationModule;\nimport org.jsecurity.ri.authc.credential.CredentialMatcher;\n\nimport java.security.Principal;\n\n/**\n * Abstract implementation of the <tt>AuthenticationModule<\/tt> interface.  Most implementations\n * can subclass this one for protocol-specific behavior.\n *\n * @since 0.1\n * @author Les Hazlewood\n */\npublic abstract class AbstractAuthenticationModule implements AuthenticationModule {\n\n    protected final transient Log log = LogFactory.getLog( getClass() );\n\n    /**\n     * Password matcher used to determine if the provided password matches\n     * the password stored in the data store.  Only utilized if non-null.\n     */\n    protected CredentialMatcher credentialMatcher = null;\n\n    protected Class<? extends AuthenticationToken> authenticationTokenClass = UsernamePasswordToken.class;\n\n    public CredentialMatcher getCredentialMatcher() {\n        return credentialMatcher;\n    }\n\n    /**\n     * Sets the CrendialMatcher implementation to use to verify submitted credentials with those stored in the system\n     * for a given authentication attempt.  The implementation of this matcher can be switched via configuration to\n     * support any number of schemes, including plain text password comparison, digest/hashing comparisons, and others.\n     *\n     * <p>If not set, no crendtial checking will occur.\n     *\n     * @param credentialMatcher\n     */\n    public void setCredentialMatcher(CredentialMatcher credentialMatcher) {\n        this.credentialMatcher = credentialMatcher;\n    }\n\n    /**\n     * Returns the authenticationToken class supported by this module.\n     *\n     * <p>The default value is <tt>{@link UsernamePasswordToken UsernamePasswordToken.class}<\/tt>, since\n     * about 90% of modules use username/password authentication, regardless of their protocol (e.g. over jdbc, ldap,\n     * kerberos, http, etc).\n     *\n     * <p>Subclasses must override this method if they won't support <tt>UsernamePasswordToken<\/tt> authentications and\n     * they haven't already overridden the {@link #supports} method.\n     *\n     * @return the authenticationToken class supported by this module.\n     *\n     * @see #setAuthenticationTokenClass\n     */\n    public Class getAuthenticationTokenClass() {\n        return authenticationTokenClass;\n    }\n\n    /**\n     * Sets the authenticationToken class supported by this module.\n     *\n     * @param authenticationTokenClass the class of authentication token instances supported by this module.\n     */\n    public void setAuthenticationTokenClass(Class<? extends AuthenticationToken> authenticationTokenClass) {\n        this.authenticationTokenClass = authenticationTokenClass;\n    }\n\n    /**\n     * Convenience implementation that returns\n     * <tt>getAuthenticationTokenClass().isAssignableFrom( tokenClass );<\/tt>.  Can be overridden\n     * by subclasses for more complex token type checking.\n     * <p>Most implementations will only need to set a different class via\n     * {@link #setAuthenticationTokenClass}, as opposed to overriding this method.\n     *\n     * @param tokenClass the class of the authenticationToken being submitted for authentication.\n     * @return true if this authentication module \"understands\" how to process submissions for the submitted token\n     * instances of the class, false otherwise.\n     */\n    public boolean supports(Class tokenClass) {\n        return getAuthenticationTokenClass().isAssignableFrom( tokenClass );\n    }\n\n    /**\n     * Primarily used to acquire a string to display in exceptions and logging.  Default implementation\n     * returns a value based on info.getPrincipal();\n     *\n     * <p>If overridding, be careful to not include any private credentials (such as passwords or private keys) if this\n     * information should not show up in log entries or error messages.\n     * @param info account info after a successful authentication attempt.\n     * @return string representation of the given info that can be used in exceptions and logging.\n     */\n    protected String displayName( AuthenticationInfo info ) {\n        Principal p = info.getPrincipal();\n        if ( p != null ) {\n            return p.toString();\n        } else {\n            return info.toString();\n        }\n    }\n\n    protected boolean isAccountLocked( AuthenticationInfo info ) {\n        return info.isAccountLocked();\n    }\n\n    protected boolean isCredentialsExpired( AuthenticationInfo info ) {\n        return info.isCredentialsExpired();\n    }\n\n    public final AuthenticationInfo getAuthenticationInfo( AuthenticationToken token ) throws AuthenticationException {\n        AuthenticationInfo info;\n        try {\n            info = doGetAuthenticationInfo( token );\n        } catch( AuthenticationException ae ) {\n            //the subclass already formulated a meaningful AuthenticationException, just let it\n            //propagate:\n            throw ae;\n        } catch (Throwable t) {\n            //probably unexpected exception.  Wrap and propagate:\n            final String message = \"AuthenticationToken [\" + token + \"] could not be authenticated because an error \" +\n                    \"occurred during authentication.\";\n            if( log.isErrorEnabled() ) {\n                log.error( message, t );\n            }\n            throw new AuthenticationException( message, t );\n        }\n\n        if( info == null ) {\n            String msg = \"No account information found for submitted authentication token [\" + token + \"]\";\n            throw new UnknownAccountException( msg );\n        }\n\n        if( isAccountLocked( info ) ) {\n            throw new LockedAccountException( \"Account [\" + displayName( info ) + \"] is locked.\" );\n        }\n\n        if( isCredentialsExpired( info ) ) {\n            String msg = \"The credentials for account [\" + displayName( info ) + \"] are expired\";\n            throw new ExpiredCredentialException( msg );\n        }\n\n        CredentialMatcher cm = getCredentialMatcher();\n        if ( cm != null ) {\n            if ( !cm.doCredentialsMatch( token.getCredentials(), info.getCredentials() ) ) {\n                String msg = \"The credentials provided for account [\" + token +\n                             \"] did not match the expected credentials.\";\n                throw new IncorrectCredentialException( msg );\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No CredentialMatcher configured.  Credential comparison check has been bypassed.\" );\n            }\n        }\n\n        return info;\n    }\n\n    protected abstract AuthenticationInfo doGetAuthenticationInfo( AuthenticationToken token ) throws AuthenticationException;\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.ri.authc.module;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authc.module.AuthenticationInfo;\nimport org.jsecurity.authc.module.AuthenticationModule;\nimport org.jsecurity.ri.authc.credential.CredentialMatcher;\n\nimport java.security.Principal;\n\n/**\n * Abstract implementation of the <tt>AuthenticationModule<\/tt> interface.  Most implementations\n * can subclass this one for protocol-specific behavior.\n *\n * @since 0.1\n * @author Les Hazlewood\n */\npublic abstract class AbstractAuthenticationModule implements AuthenticationModule {\n\n    protected final transient Log log = LogFactory.getLog( getClass() );\n\n    /**\n     * Password matcher used to determine if the provided password matches\n     * the password stored in the data store.  Only utilized if non-null.\n     */\n    protected CredentialMatcher credentialMatcher = null;\n\n    protected Class<? extends AuthenticationToken> authenticationTokenClass = UsernamePasswordToken.class;\n\n    public CredentialMatcher getCredentialMatcher() {\n        return credentialMatcher;\n    }\n\n    /**\n     * Sets the CrendialMatcher implementation to use to verify submitted credentials with those stored in the system\n     * for a given authentication attempt.  The implementation of this matcher can be switched via configuration to\n     * support any number of schemes, including plain text password comparison, digest/hashing comparisons, and others.\n     *\n     * <p>If not set, no crendtial checking will occur.\n     *\n     * @param credentialMatcher\n     */\n    public void setCredentialMatcher(CredentialMatcher credentialMatcher) {\n        this.credentialMatcher = credentialMatcher;\n    }\n\n    /**\n     * Returns the authenticationToken class supported by this module.\n     *\n     * <p>The default value is <tt>{@link UsernamePasswordToken UsernamePasswordToken.class}<\/tt>, since\n     * about 90% of modules use username/password authentication, regardless of their protocol (e.g. over jdbc, ldap,\n     * kerberos, http, etc).\n     *\n     * <p>Subclasses must override this method if they won't support <tt>UsernamePasswordToken<\/tt> authentications and\n     * they haven't already overridden the {@link #supports} method.\n     *\n     * @return the authenticationToken class supported by this module.\n     *\n     * @see #setAuthenticationTokenClass\n     */\n    public Class getAuthenticationTokenClass() {\n        return authenticationTokenClass;\n    }\n\n    /**\n     * Sets the authenticationToken class supported by this module.\n     *\n     * @param authenticationTokenClass the class of authentication token instances supported by this module.\n     */\n    public void setAuthenticationTokenClass(Class<? extends AuthenticationToken> authenticationTokenClass) {\n        this.authenticationTokenClass = authenticationTokenClass;\n    }\n\n    /**\n     * Convenience implementation that returns\n     * <tt>getAuthenticationTokenClass().isAssignableFrom( tokenClass );<\/tt>.  Can be overridden\n     * by subclasses for more complex token type checking.\n     * <p>Most implementations will only need to set a different class via\n     * {@link #setAuthenticationTokenClass}, as opposed to overriding this method.\n     *\n     * @param tokenClass the class of the authenticationToken being submitted for authentication.\n     * @return true if this authentication module \"understands\" how to process submissions for the submitted token\n     * instances of the class, false otherwise.\n     */\n    public boolean supports(Class tokenClass) {\n        return getAuthenticationTokenClass().isAssignableFrom( tokenClass );\n    }\n\n    /**\n     * Primarily used to acquire a string to display in exceptions and logging.  Default implementation\n     * returns a value based on info.getPrincipal();\n     *\n     * <p>If overridding, be careful to not include any private credentials (such as passwords or private keys) if this\n     * information should not show up in log entries or error messages.\n     * @param info account info after a successful authentication attempt.\n     * @return string representation of the given info that can be used in exceptions and logging.\n     */\n    protected String displayName( AuthenticationInfo info ) {\n        Principal p = info.getPrincipal();\n        if ( p != null ) {\n            return p.toString();\n        } else {\n            return info.toString();\n        }\n    }\n\n    protected boolean isAccountLocked( AuthenticationInfo info ) {\n        return info.isAccountLocked();\n    }\n\n    protected boolean isCredentialsExpired( AuthenticationInfo info ) {\n        return info.isCredentialsExpired();\n    }\n\n    public final AuthenticationInfo getAuthenticationInfo( AuthenticationToken token ) throws AuthenticationException {\n        AuthenticationInfo info;\n        try {\n            info = doGetAuthenticationInfo( token );\n        } catch( AuthenticationException ae ) {\n            //the subclass already formulated a meaningful AuthenticationException, just let it\n            //propagate:\n            throw ae;\n        } catch (Throwable t) {\n            //probably unexpected exception.  Wrap and propagate:\n            throw new AuthenticationException(\n                \"AuthenticationToken [\" + token + \"] could not be authenticated because an error \" +\n                \"occurred during authentication.\", t );\n        }\n\n        if( info == null ) {\n            String msg = \"No account information found for submitted authentication token [\" + token + \"]\";\n            throw new UnknownAccountException( msg );\n        }\n\n        if( isAccountLocked( info ) ) {\n            throw new LockedAccountException( \"Account [\" + displayName( info ) + \"] is locked.\" );\n        }\n\n        if( isCredentialsExpired( info ) ) {\n            String msg = \"The credentials for account [\" + displayName( info ) + \"] are expired\";\n            throw new ExpiredCredentialException( msg );\n        }\n\n        CredentialMatcher cm = getCredentialMatcher();\n        if ( cm != null ) {\n            if ( !cm.doCredentialsMatch( token.getCredentials(), info.getCredentials() ) ) {\n                String msg = \"The credentials provided for account [\" + token +\n                             \"] did not match the expected credentials.\";\n                throw new IncorrectCredentialException( msg );\n            }\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No CredentialMatcher configured.  Credential comparison check has been bypassed.\" );\n            }\n        }\n\n        return info;\n    }\n\n    protected abstract AuthenticationInfo doGetAuthenticationInfo( AuthenticationToken token ) throws AuthenticationException;\n}\n","lineNo":150}
{"Refactored Sample":"/*\n * Copyright (C) 2005 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.ri.authc.credential;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.codec.binary.Hex;\n\nimport java.util.Arrays;\n\n/**\n * A superclass for any digest-based password matcher that provides support\n * for encoding passwords in Base64 or Hex.\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic abstract class DigestCredentialMatcher implements CredentialMatcher {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Set to true if the passwords are encoded using Base64 encoding.  If\n     * this is false, the passwords are assumed to be encoded in hex format.\n     */\n    private boolean base64Encoded;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    protected boolean isBase64Encoded() {\n        return base64Encoded;\n    }\n\n\n    public void setBase64Encoded(boolean base64Encoded) {\n        this.base64Encoded = base64Encoded;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n\n    /**\n     * Calls the abstract {@link #doDigest(byte[])} method to digest the provided password\n     * and compares it with the stored password after encoding the passwords using hex\n     * or base64 encodings.\n     * @param providedPassword the unhashed password char array (char[]) provided by the user.\n     * @param storedPassword the hashed password char array (char[]) stored in the system.\n     * @return true if the hashes match, false otherwise.\n     */\n    public boolean doCredentialsMatch( Object providedPassword,\n                                       Object storedPassword ) {\n\n        char[] providedPasswordChars = castToCharArray( providedPassword );\n        char[] storedPasswordChars = castToCharArray( storedPassword );\n\n        byte[] digestedBytes = doDigest( charsToBytes( providedPasswordChars ) );\n\n        if( isBase64Encoded() ) {\n            byte[] encodedPasswordBase64 = Base64.encodeBase64( digestedBytes );\n            byte[] storedPasswordBytes = charsToBytes( storedPasswordChars );\n            return Arrays.equals( encodedPasswordBase64, storedPasswordBytes );\n        } else {\n            char[] encodedPasswordHex = Hex.encodeHex( digestedBytes );\n            return Arrays.equals( encodedPasswordHex, storedPasswordChars );\n        }\n    }\n\n\n    /**\n     * Converts an array of characters to bytes.\n     * @param passwd the password being converted.\n     * @return an array of bytes that match the characters given.\n     */\n    private byte[] charsToBytes( char[] passwd ) {\n        byte[] buf = new byte[passwd.length];\n        for (int i = 0; i < passwd.length; i++) {\n            buf[i] = (byte) passwd[i];\n        }\n        return buf;\n    }\n\n\n    /**\n     * Performs the actual digest of the provided password - to be implemented\n     * by subclasses.\n     * @param providedPassword the bytes of the provided password.\n     * @return a hash of the given password bytes.\n     */\n    protected abstract byte[] doDigest( byte[] providedPassword );\n\n\n    /**\n     * Converts given credentials into a char[] if they are of type String or char[].\n     * @param credential the credential.\n     * @return the credential in char[] form.\n     */\n    private char[] castToCharArray(Object credential) {\n        char[] chars;\n\n        if( credential instanceof String ) {\n            chars = ((String)credential).toCharArray();\n\n        } else if( credential instanceof char[] ) {\n            chars = (char[])credential;\n\n        } else {\n            throw new IllegalArgumentException( \"This credential matcher only supports credentials of type String or char[].\" );\n        }\n\n        return chars;\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.ri.authc.credential;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.codec.binary.Hex;\n\nimport java.util.Arrays;\n\n/**\n * A superclass for any digest-based password matcher that provides support\n * for encoding passwords in Base64 or Hex.\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic abstract class DigestCredentialMatcher implements CredentialMatcher {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Set to true if the passwords are encoded using Base64 encoding.  If\n     * this is false, the passwords are assumed to be encoded in hex format.\n     */\n    private boolean base64Encoded;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    protected boolean isBase64Encoded() {\n        return base64Encoded;\n    }\n\n\n    public void setBase64Encoded(boolean base64Encoded) {\n        this.base64Encoded = base64Encoded;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n\n    /**\n     * Calls the abstract {@link #doDigest(byte[])} method to digest the provided password\n     * and compares it with the stored password after encoding the passwords using hex\n     * or base64 encodings.\n     * @param providedPasswordCharArray the unhashed password char array (char[]) provided by the user.\n     * @param storedPasswordCharArray the hashed password char array (char[]) stored in the system.\n     * @return true if the hashes match, false otherwise.\n     */\n    public boolean doCredentialsMatch( Object providedPasswordCharArray,\n                                       Object storedPasswordCharArray ) {\n\n        char[] providedPassword = (char[])providedPasswordCharArray;\n        char[] storedPassword = (char[])storedPasswordCharArray;\n\n        byte[] digestedBytes = doDigest( charsToBytes( providedPassword ) );\n\n        if( isBase64Encoded() ) {\n            byte[] encodedPasswordBase64 = Base64.encodeBase64( digestedBytes );\n            byte[] storedPasswordBytes = charsToBytes( storedPassword );\n            return Arrays.equals( encodedPasswordBase64, storedPasswordBytes );\n        } else {\n            char[] encodedPasswordHex = Hex.encodeHex( digestedBytes );\n            return Arrays.equals( encodedPasswordHex, storedPassword );\n        }\n    }\n\n\n    /**\n     * Converts an array of characters to bytes.\n     * @param passwd the password being converted.\n     * @return an array of bytes that match the characters given.\n     */\n    private byte[] charsToBytes( char[] passwd ) {\n        byte[] buf = new byte[passwd.length];\n        for (int i = 0; i < passwd.length; i++) {\n            buf[i] = (byte) passwd[i];\n        }\n        return buf;\n    }\n\n\n    /**\n     * Performs the actual digest of the provided password - to be implemented\n     * by subclasses.\n     * @param providedPassword the bytes of the provided password.\n     * @return a hash of the given password bytes.\n     */\n    protected abstract byte[] doDigest( byte[] providedPassword );\n\n\n}\n","lineNo":89}
{"Refactored Sample":"/*\n * Copyright (C) 2005 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.ri.authc.credential;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.codec.binary.Hex;\n\nimport java.util.Arrays;\n\n/**\n * A superclass for any digest-based password matcher that provides support\n * for encoding passwords in Base64 or Hex.\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic abstract class DigestCredentialMatcher implements CredentialMatcher {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Set to true if the passwords are encoded using Base64 encoding.  If\n     * this is false, the passwords are assumed to be encoded in hex format.\n     */\n    private boolean base64Encoded;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    protected boolean isBase64Encoded() {\n        return base64Encoded;\n    }\n\n\n    public void setBase64Encoded(boolean base64Encoded) {\n        this.base64Encoded = base64Encoded;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n\n    /**\n     * Calls the abstract {@link #doDigest(byte[])} method to digest the provided password\n     * and compares it with the stored password after encoding the passwords using hex\n     * or base64 encodings.\n     * @param providedPassword the unhashed password char array (char[]) provided by the user.\n     * @param storedPassword the hashed password char array (char[]) stored in the system.\n     * @return true if the hashes match, false otherwise.\n     */\n    public boolean doCredentialsMatch( Object providedPassword,\n                                       Object storedPassword ) {\n\n        char[] providedPasswordChars = castToCharArray( providedPassword );\n        char[] storedPasswordChars = castToCharArray( storedPassword );\n\n        byte[] digestedBytes = doDigest( charsToBytes( providedPasswordChars ) );\n\n        if( isBase64Encoded() ) {\n            byte[] encodedPasswordBase64 = Base64.encodeBase64( digestedBytes );\n            byte[] storedPasswordBytes = charsToBytes( storedPasswordChars );\n            return Arrays.equals( encodedPasswordBase64, storedPasswordBytes );\n        } else {\n            char[] encodedPasswordHex = Hex.encodeHex( digestedBytes );\n            return Arrays.equals( encodedPasswordHex, storedPasswordChars );\n        }\n    }\n\n\n    /**\n     * Converts an array of characters to bytes.\n     * @param passwd the password being converted.\n     * @return an array of bytes that match the characters given.\n     */\n    private byte[] charsToBytes( char[] passwd ) {\n        byte[] buf = new byte[passwd.length];\n        for (int i = 0; i < passwd.length; i++) {\n            buf[i] = (byte) passwd[i];\n        }\n        return buf;\n    }\n\n\n    /**\n     * Performs the actual digest of the provided password - to be implemented\n     * by subclasses.\n     * @param providedPassword the bytes of the provided password.\n     * @return a hash of the given password bytes.\n     */\n    protected abstract byte[] doDigest( byte[] providedPassword );\n\n\n    /**\n     * Converts given credentials into a char[] if they are of type String or char[].\n     * @param credential the credential.\n     * @return the credential in char[] form.\n     */\n    private char[] castToCharArray(Object credential) {\n        char[] chars;\n\n        if( credential instanceof String ) {\n            chars = ((String)credential).toCharArray();\n\n        } else if( credential instanceof char[] ) {\n            chars = (char[])credential;\n\n        } else {\n            throw new IllegalArgumentException( \"This credential matcher only supports credentials of type String or char[].\" );\n        }\n\n        return chars;\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.ri.authc.credential;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.codec.binary.Hex;\n\nimport java.util.Arrays;\n\n/**\n * A superclass for any digest-based password matcher that provides support\n * for encoding passwords in Base64 or Hex.\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic abstract class DigestCredentialMatcher implements CredentialMatcher {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Set to true if the passwords are encoded using Base64 encoding.  If\n     * this is false, the passwords are assumed to be encoded in hex format.\n     */\n    private boolean base64Encoded;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    protected boolean isBase64Encoded() {\n        return base64Encoded;\n    }\n\n\n    public void setBase64Encoded(boolean base64Encoded) {\n        this.base64Encoded = base64Encoded;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n\n    /**\n     * Calls the abstract {@link #doDigest(byte[])} method to digest the provided password\n     * and compares it with the stored password after encoding the passwords using hex\n     * or base64 encodings.\n     * @param providedPasswordCharArray the unhashed password char array (char[]) provided by the user.\n     * @param storedPasswordCharArray the hashed password char array (char[]) stored in the system.\n     * @return true if the hashes match, false otherwise.\n     */\n    public boolean doCredentialsMatch( Object providedPasswordCharArray,\n                                       Object storedPasswordCharArray ) {\n\n        char[] providedPassword = (char[])providedPasswordCharArray;\n        char[] storedPassword = (char[])storedPasswordCharArray;\n\n        byte[] digestedBytes = doDigest( charsToBytes( providedPassword ) );\n\n        if( isBase64Encoded() ) {\n            byte[] encodedPasswordBase64 = Base64.encodeBase64( digestedBytes );\n            byte[] storedPasswordBytes = charsToBytes( storedPassword );\n            return Arrays.equals( encodedPasswordBase64, storedPasswordBytes );\n        } else {\n            char[] encodedPasswordHex = Hex.encodeHex( digestedBytes );\n            return Arrays.equals( encodedPasswordHex, storedPassword );\n        }\n    }\n\n\n    /**\n     * Converts an array of characters to bytes.\n     * @param passwd the password being converted.\n     * @return an array of bytes that match the characters given.\n     */\n    private byte[] charsToBytes( char[] passwd ) {\n        byte[] buf = new byte[passwd.length];\n        for (int i = 0; i < passwd.length; i++) {\n            buf[i] = (byte) passwd[i];\n        }\n        return buf;\n    }\n\n\n    /**\n     * Performs the actual digest of the provided password - to be implemented\n     * by subclasses.\n     * @param providedPassword the bytes of the provided password.\n     * @return a hash of the given password bytes.\n     */\n    protected abstract byte[] doDigest( byte[] providedPassword );\n\n\n}\n","lineNo":90}
{"Refactored Sample":"/*\n * Copyright (C) 2005 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.ri.authc.credential;\n\nimport java.util.Arrays;\n\n/**\n * Simple implementation of the {@link CredentialMatcher} interface that\n * compares two plain text passwords.\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class PlainTextCredentialMatcher implements CredentialMatcher {\n\n\n    /**\n     * Compares two plain text passwords.\n     * \n     * @param providedPassword the user-provided password as a char array (char[])\n     * @param storedPassword the password stored in the system as a char array (char[]).\n     * @return true if the passwords match, false otherwise.\n     */\n    public boolean doCredentialsMatch( Object providedPassword,\n                                       Object storedPassword ) {\n        char[] providedPasswordChars = castToCharArray(providedPassword);\n        char[] storedPasswordChars = castToCharArray(storedPassword);\n\n        return Arrays.equals( providedPasswordChars, storedPasswordChars );\n    }\n\n\n    /**\n     * Converts given credentials into a char[] if they are of type String or char[].\n     * @param credential the credential.\n     * @return the credential in char[] form.\n     */\n    private char[] castToCharArray(Object credential) {\n        char[] chars;\n\n        if( credential instanceof String ) {\n            chars = ((String)credential).toCharArray();\n\n        } else if( credential instanceof char[] ) {\n            chars = (char[])credential;\n\n        } else {\n            throw new IllegalArgumentException( \"This credential matcher only supports credentials of type String or char[].\" );\n        }\n\n        return chars;\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.ri.authc.credential;\n\nimport java.util.Arrays;\n\n/**\n * Simple implementation of the {@link CredentialMatcher} interface that\n * compares two plain text passwords.\n *\n * todo Make this class accept char[] or Strings.. or at least give a better error message than a ClassCastException\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class PlainTextCredentialMatcher implements CredentialMatcher {\n\n\n    /**\n     * Compares two plain text passwords.\n     * \n     * @param providedPasswordCharArray the user-provided password as a char array (char[])\n     * @param storedPasswordCharArray the password stored in the system as a char array (char[]).\n     * @return true if the passwords match, false otherwise.\n     */\n    public boolean doCredentialsMatch( Object providedPasswordCharArray,\n                                       Object storedPasswordCharArray ) {\n        char[] providedPassword = (char[])providedPasswordCharArray;\n        char[] storedPassword = (char[])storedPasswordCharArray;\n        return Arrays.equals( providedPassword, storedPassword );\n    }\n}\n","lineNo":49}
{"Refactored Sample":"/*\n * Copyright (C) 2005 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.ri.authc.credential;\n\nimport java.util.Arrays;\n\n/**\n * Simple implementation of the {@link CredentialMatcher} interface that\n * compares two plain text passwords.\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class PlainTextCredentialMatcher implements CredentialMatcher {\n\n\n    /**\n     * Compares two plain text passwords.\n     * \n     * @param providedPassword the user-provided password as a char array (char[])\n     * @param storedPassword the password stored in the system as a char array (char[]).\n     * @return true if the passwords match, false otherwise.\n     */\n    public boolean doCredentialsMatch( Object providedPassword,\n                                       Object storedPassword ) {\n        char[] providedPasswordChars = castToCharArray(providedPassword);\n        char[] storedPasswordChars = castToCharArray(storedPassword);\n\n        return Arrays.equals( providedPasswordChars, storedPasswordChars );\n    }\n\n\n    /**\n     * Converts given credentials into a char[] if they are of type String or char[].\n     * @param credential the credential.\n     * @return the credential in char[] form.\n     */\n    private char[] castToCharArray(Object credential) {\n        char[] chars;\n\n        if( credential instanceof String ) {\n            chars = ((String)credential).toCharArray();\n\n        } else if( credential instanceof char[] ) {\n            chars = (char[])credential;\n\n        } else {\n            throw new IllegalArgumentException( \"This credential matcher only supports credentials of type String or char[].\" );\n        }\n\n        return chars;\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.ri.authc.credential;\n\nimport java.util.Arrays;\n\n/**\n * Simple implementation of the {@link CredentialMatcher} interface that\n * compares two plain text passwords.\n *\n * todo Make this class accept char[] or Strings.. or at least give a better error message than a ClassCastException\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class PlainTextCredentialMatcher implements CredentialMatcher {\n\n\n    /**\n     * Compares two plain text passwords.\n     * \n     * @param providedPasswordCharArray the user-provided password as a char array (char[])\n     * @param storedPasswordCharArray the password stored in the system as a char array (char[]).\n     * @return true if the passwords match, false otherwise.\n     */\n    public boolean doCredentialsMatch( Object providedPasswordCharArray,\n                                       Object storedPasswordCharArray ) {\n        char[] providedPassword = (char[])providedPasswordCharArray;\n        char[] storedPassword = (char[])storedPasswordCharArray;\n        return Arrays.equals( providedPassword, storedPassword );\n    }\n}\n","lineNo":50}
{"Refactored Sample":"/*\n * Copyright (C) 2005 Jeremy Haile, Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.ri.authc;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.Authenticator;\nimport org.jsecurity.authc.event.AuthenticationEvent;\nimport org.jsecurity.authc.module.AuthenticationInfo;\nimport org.jsecurity.authz.AuthorizationContext;\nimport org.jsecurity.ri.authc.event.AuthenticationEventFactory;\nimport org.jsecurity.ri.authc.event.AuthenticationEventSender;\nimport org.jsecurity.ri.authc.event.SimpleAuthenticationEventFactory;\nimport org.jsecurity.ri.authz.AuthorizationContextFactory;\nimport org.jsecurity.ri.authz.support.SimpleAuthorizationContextFactory;\n\n/**\n * Superclass for {@link Authenticator} implementations that performs the common work\n * of wrapping a returned {@link AuthorizationContext} using an {@link AuthorizationContextFactory}\n * and binding the context using an {@link AuthorizationContextBinder}.  Subclasses should\n * implement the {@link #doAuthenticate(org.jsecurity.authc.AuthenticationToken)} method.\n *\n * @since 0.1\n * @author Jeremy Haile\n * @author Les Hazlewood\n */\npublic abstract class AbstractAuthenticator implements Authenticator {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons logger.\n     */\n    protected Log log = LogFactory.getLog( getClass() );\n    /** Alias for the 'log' protected class attribute for subclass authors that may prefer one over the other. */\n    protected Log logger = log;\n\n    /**\n     * The factory used to wrap authorization context after authentication.\n     */\n    private AuthorizationContextFactory authContextFactory = new SimpleAuthorizationContextFactory();\n\n    /**\n     * The binder used to bind the authorization context so that it is accessible on subsequent\n     * requests.\n     */\n    private AuthorizationContextBinder authzCtxBinder = new ThreadLocalAuthorizationContextBinder();\n\n    private AuthenticationEventFactory authcEventFactory = new SimpleAuthenticationEventFactory();\n\n    private AuthenticationEventSender authcEventSender = null;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    protected AuthorizationContextFactory getAuthorizationContextFactory() {\n        return authContextFactory;\n    }\n\n\n    public void setAuthorizationContextFactory(AuthorizationContextFactory authContextFactory) {\n        this.authContextFactory = authContextFactory;\n    }\n\n\n    public AuthorizationContextBinder getAuthorizationContextBinder() {\n        return authzCtxBinder;\n    }\n\n\n    public void setAuthorizationContextBinder(AuthorizationContextBinder authContextBinder) {\n        this.authzCtxBinder = authContextBinder;\n    }\n\n    public AuthenticationEventFactory getAuthenticationEventFactory() {\n        return authcEventFactory;\n    }\n\n    public void setAuthenticationEventFactory( AuthenticationEventFactory factory ) {\n        this.authcEventFactory = factory;\n    }\n\n    public AuthenticationEventSender getAuthenticationEventSender() {\n        return authcEventSender;\n    }\n\n    public void setAuthenticationEventSender( AuthenticationEventSender authcEventSender ) {\n        this.authcEventSender = authcEventSender;\n    }\n\n    protected AuthenticationEvent createFailureEvent( AuthenticationToken token, AuthenticationException ae ) {\n        AuthenticationEventFactory factory = getAuthenticationEventFactory();\n        return factory.createFailureEvent( token, ae );\n    }\n\n    protected AuthenticationEvent createSuccessEvent( AuthenticationToken token, AuthenticationInfo info ) {\n        AuthenticationEventFactory factory = getAuthenticationEventFactory();\n        return factory.createSuccessEvent( token, info );\n    }\n\n    protected void sendFailureEvent( AuthenticationToken token, AuthenticationException ae ) {\n        AuthenticationEvent event = createFailureEvent( token, ae );\n        if ( event != null ) {\n            send( event );\n        } else {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No AuthenticationEvent instance returned from 'createFailureEvent' method call.  \" +\n                    \"No failed authentication event will be sent.\" );\n            }\n        }\n    }\n\n    protected void sendSuccessEvent( AuthenticationToken token, AuthenticationInfo info ) {\n        AuthenticationEvent event = createSuccessEvent( token, info );\n        if ( event != null ) {\n            send( event );\n        } else {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No AuthenticationEvent instance returned from 'createSuccessEvent' method call.  \" +\n                    \"No successful authentication event will be sent.\" );\n            }\n        }\n    }\n\n    protected void send( AuthenticationEvent event ) throws IllegalArgumentException {\n        if ( event == null ) {\n            throw new IllegalArgumentException( \"AuthenticationEvent argument cannot be null\" );\n        }\n        AuthenticationEventSender sender = getAuthenticationEventSender();\n        if ( sender != null ) {\n            sender.send( event );\n        } else {\n            if ( log.isTraceEnabled() ) {\n                log.trace( \"No AuthenticationEventSender configured.  Event [\" + event + \"] will not \" +\n                    \"be sent.\" );\n            }\n        }\n    }\n\n    protected AuthorizationContext createAuthorizationContext( AuthenticationInfo info ) {\n        return getAuthorizationContextFactory().createAuthorizationContext( info );\n    }\n\n    protected void bind( AuthorizationContext authzCtx ) {\n        getAuthorizationContextBinder().bindAuthorizationContext( authzCtx );\n    }\n\n    private void assertCreation( AuthorizationContext authzCtx ) throws IllegalStateException {\n        if ( authzCtx == null ) {\n            String msg = \"Programming or configuration error - No AuthorizationContext was created after successful \" +\n                \"authentication.  Verify that you have either configured the \" + getClass().getName() +\n                \" instance with a proper \" + AuthorizationContextFactory.class.getName() + \" (easier) or \" +\n                \"that you have overridden the \" + AbstractAuthenticator.class.getName() +\n                \".createAuthorizationContext( AuthenticationInfo info ) method.\";\n            throw new IllegalStateException( msg );\n        }\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    public final AuthorizationContext authenticate( AuthenticationToken token ) throws AuthenticationException {\n\n        if (log.isInfoEnabled()) {\n            log.info(\"Authentication request received for token [\" + token + \"]\");\n        }\n\n        AuthenticationInfo info;\n        try {\n            info = doAuthenticate( token );\n            if( info == null ) {\n                throw new AuthenticationException( \"Authentication token of type [\" + token.getClass() + \"] \" +\n                    \"could not be authenticated.  Check that the Authenticator is configured correctly.\" );\n            }\n        } catch (AuthenticationException e) {\n            // Catch exception for debugging\n            if (log.isDebugEnabled()) {\n                log.debug(\"Authentication failed for token [\" + token + \"]\", e);\n            }\n\n            sendFailureEvent( token, e );\n\n            throw e;\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Authentication successful.  Returned authentication info: [\" + info + \"]\");\n        }\n\n        AuthorizationContext authzCtx = createAuthorizationContext( info );\n\n        assertCreation( authzCtx );\n\n        bind( authzCtx );\n\n        sendSuccessEvent( token, info );\n\n        return authzCtx;\n    }\n\n    protected abstract AuthenticationInfo doAuthenticate( AuthenticationToken token ) throws AuthenticationException;\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005 Jeremy Haile, Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.ri.authc;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.Authenticator;\nimport org.jsecurity.authc.event.AuthenticationEvent;\nimport org.jsecurity.authc.module.AuthenticationInfo;\nimport org.jsecurity.authz.AuthorizationContext;\nimport org.jsecurity.ri.authc.event.AuthenticationEventFactory;\nimport org.jsecurity.ri.authc.event.AuthenticationEventSender;\nimport org.jsecurity.ri.authc.event.SimpleAuthenticationEventFactory;\nimport org.jsecurity.ri.authz.AuthorizationContextFactory;\nimport org.jsecurity.ri.authz.support.SimpleAuthorizationContextFactory;\n\n/**\n * Superclass for {@link Authenticator} implementations that performs the common work\n * of wrapping a returned {@link AuthorizationContext} using an {@link AuthorizationContextFactory}\n * and binding the context using an {@link AuthorizationContextBinder}.  Subclasses should\n * implement the {@link #doAuthenticate(org.jsecurity.authc.AuthenticationToken)} method.\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic abstract class AbstractAuthenticator implements Authenticator {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons logger.\n     */\n    protected Log logger = LogFactory.getLog( getClass() );\n\n    /**\n     * The factory used to wrap authorization context after authentication.\n     */\n    private AuthorizationContextFactory authContextFactory = new SimpleAuthorizationContextFactory();\n\n    /**\n     * The binder used to bind the authorization context so that it is accessible on subsequent\n     * requests.\n     */\n    private AuthorizationContextBinder authzCtxBinder = new ThreadLocalAuthorizationContextBinder();\n\n    private AuthenticationEventFactory authcEventFactory = new SimpleAuthenticationEventFactory();\n\n    private AuthenticationEventSender authcEventSender = null;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    protected AuthorizationContextFactory getAuthorizationContextFactory() {\n        return authContextFactory;\n    }\n\n\n    public void setAuthorizationContextFactory(AuthorizationContextFactory authContextFactory) {\n        this.authContextFactory = authContextFactory;\n    }\n\n\n    public AuthorizationContextBinder getAuthorizationContextBinder() {\n        return authzCtxBinder;\n    }\n\n\n    public void setAuthorizationContextBinder(AuthorizationContextBinder authContextBinder) {\n        this.authzCtxBinder = authContextBinder;\n    }\n\n    public AuthenticationEventFactory getAuthenticationEventFactory() {\n        return authcEventFactory;\n    }\n\n    public void setAuthenticationEventFactory( AuthenticationEventFactory factory ) {\n        this.authcEventFactory = factory;\n    }\n\n    public AuthenticationEventSender getAuthenticationEventSender() {\n        return authcEventSender;\n    }\n\n    public void setAuthenticationEventSender( AuthenticationEventSender authcEventSender ) {\n        this.authcEventSender = authcEventSender;\n    }\n\n    private void sendEvent( AuthenticationToken token, AuthenticationInfo info, AuthenticationException ex ) {\n        boolean failed = ( ex != null );\n        String status = failed ? \"Failed\" : \"Success\";\n        AuthenticationEventSender sender = getAuthenticationEventSender();\n        if ( sender != null ) {\n            AuthenticationEventFactory factory = getAuthenticationEventFactory();\n            AuthenticationEvent event;\n            if ( failed ) {\n                event = factory.createFailureEvent( token, ex );\n            } else {\n                event = factory.createSuccessEvent( token, info );\n            }\n            if ( event != null ) {\n                sender.send( event );\n            } else {\n                if ( logger.isDebugEnabled() ) {\n                    logger.debug( \"Event object returned from authenticationEventFactory was null.  \" +\n                                  status + \" event will not be sent.\" );\n\n                }\n            }\n        } else {\n            if ( logger.isTraceEnabled() ) {\n                logger.trace( \"Property 'authenticationEventSender' was not set.  \" + status + \" event \" +\n                        \"will not be sent.\");\n            }\n        }\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    public final AuthorizationContext authenticate( AuthenticationToken token ) throws AuthenticationException {\n\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Authentication request received for token [\" + token + \"]\");\n        }\n\n        AuthenticationInfo info;\n        try {\n            info = doAuthenticate( token );\n            if( info == null ) {\n                throw new AuthenticationException( \"Authentication token of type [\" + token.getClass() + \"] \" +\n                    \"could not be authenticated.  Check that the Authenticator is configured correctly.\" );\n            }\n        } catch (AuthenticationException e) {\n            // Catch exception for debugging\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Authentication failed for token [\" + token + \"]\", e);\n            }\n\n            sendEvent( token, null, e );\n\n            throw e;\n        }\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Authentication successful.  Returned authentication info: [\" + info + \"]\");\n        }\n\n        sendEvent( token, info, null );\n\n        AuthorizationContextFactory factory = getAuthorizationContextFactory();\n\n        AuthorizationContext authzCtx = factory.createAuthorizationContext( info );\n\n        // Bind the context to the application\n        getAuthorizationContextBinder().bindAuthorizationContext( authzCtx );\n\n        return authzCtx;\n    }\n\n    protected abstract AuthenticationInfo doAuthenticate( AuthenticationToken token ) throws AuthenticationException;\n}\n","lineNo":148}
{"Refactored Sample":"package org.jsecurity.ri.web.tags;\n\nimport org.jsecurity.authz.InstancePermission;\nimport org.jsecurity.ri.util.PermissionUtils;\n\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport java.security.Permission;\n\n/**\n * @author Les Hazlewood\n * @author Jeremy Haile\n */\npublic abstract class PermissionTag extends SecureTag {\n\n    private String type = null;\n    private String target = null;\n    private String actions = null;\n\n    public PermissionTag() {\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType( String type ) {\n        this.type = type;\n    }\n\n    public String getTarget() {\n        return target;\n    }\n\n    public void setTarget( String target ) {\n        this.target = target;\n    }\n\n    public String getActions() {\n        return actions;\n    }\n\n    public void setActions( String actions ) {\n        this.actions = actions;\n    }\n\n    protected void verifyAttributes() throws JspException {\n        String type = getType();\n        String target = getTarget();\n        String actions = getActions();\n\n        if ( type == null ) {\n            String msg = \"the 'type' tag attribute must be set\";\n            throw new JspException( msg );\n        }\n\n        if ( target == null ) {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"'target' tag attribute was not specified.  Assuming default of \" +\n                           \"\\\"*\\\", as all Permission objects must be instantiated with a \" +\n                           \"name/target.\" );\n            }\n            setTarget( InstancePermission.WILDCARD );\n        }\n    }\n\n    public int onDoStartTag() throws JspException {\n\n        Permission p = null;\n\n        String actions = getActions();\n\n        if ( actions == null ) {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No actions attribute specified, creating permission with target only.\" );\n            }\n            p = PermissionUtils.createPermission( getType(), getTarget() );\n        } else {\n            p = PermissionUtils.createPermission( getType(), getTarget(), actions );\n        }\n\n        boolean show = showTagBody( p );\n        if ( show ) {\n            return TagSupport.EVAL_BODY_INCLUDE;\n        } else {\n            return TagSupport.SKIP_BODY;\n        }\n    }\n\n    protected abstract boolean showTagBody( Permission p );\n\n}\n","Smelly Sample":"package org.jsecurity.ri.web.tags;\n\nimport org.jsecurity.ri.util.PermissionUtils;\n\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport java.security.Permission;\n\n/**\n * @author Les Hazlewood\n * @author Jeremy Haile\n */\npublic abstract class PermissionTag extends SecureTag {\n\n    private String type = null;\n    private String target = null;\n    private String actions = null;\n\n    private boolean applyWildcard = true;\n\n    public PermissionTag() {\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType( String type ) {\n        this.type = type;\n    }\n\n    public String getTarget() {\n        return target;\n    }\n\n    public void setTarget( String target ) {\n        this.target = target;\n    }\n\n    public String getActions() {\n        return actions;\n    }\n\n    public void setActions( String actions ) {\n        this.actions = actions;\n    }\n\n    /**\n     * Returns whether or not to apply the wildcard ('*') if the {@link #getTarget target} or\n     * {@link #getActions actions} tag attributes are unspecified.\n     *\n     * <p>That is, if this property is set to <tt>true<\/tt> (the default), and the <tt>target<\/tt> property is not\n     * specified (i.e. <tt>null<\/tt>), the target property will automatically be set to '*'.  And, if the\n     * <tt>actions<\/tt> property is not specified (i.e. <tt>null<\/tt>), the actions property will automatically be set\n     * to '*'.\n     *\n     * <p>If this attribute is set to <tt>false<\/tt>, and the <tt>target<\/tt> or <tt>actions<\/tt> attributes are not set,\n     * this tag considers this state a programming error, and will throw an exception.\n     *\n     * <p>The default setting is <b><tt>true<\/tt><\/b>.\n     *\n     * @return <tt>true<\/tt> if the wildcard token should be applied to null <tt>target<\/tt> or <tt>actions<\/tt>\n     * properties, <tt>false<\/tt> otherwise.\n     *\n     */\n    public boolean isApplyWildcard() {\n        return applyWildcard;\n    }\n\n    /**\n     * Turns on or off default application of the wildcard token ('*') if the {@link #getTarget target} or\n     * {@link #getActions actions} attributes are null.\n     *\n     * @param applyWildcard whether or not to apply the wildcard token in the event of null attributes.\n     * @see #isApplyWildcard\n     */\n    public void setApplyWildcard( boolean applyWildcard ) {\n        this.applyWildcard = applyWildcard;\n    }\n\n    protected void verifyAttributes() throws JspException {\n        if ( getType() == null ) {\n            String msg = \"the 'type' tag attribute must be set\";\n            throw new JspException( msg );\n        }\n        if ( getTarget() == null ) {\n            if ( isApplyWildcard() ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"'target' tag attribute was not specified.  Assuming default of '*'.  If you \" +\n                        \"do not want this default to be applied set the 'applyWildcard' attribute \" +\n                        \"to false.\" );\n                }\n                setTarget( \"*\" );\n            } else {\n                String msg = \"the 'target' tag attribute has not been set and default application of wildcards is \" +\n                    \"turned off.\";\n                throw new JspException( msg );\n            }\n        }\n        if ( getActions() == null ) {\n            if ( isApplyWildcard() ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"'actions' tag attribute was not specified.  Assuming default of '*'.  If you \" +\n                        \"do not want this default to be applied set the 'applyWildcard' attribute \" +\n                        \"to false.\" );\n                }\n                setTarget( \"*\" );\n            } else {\n                String msg = \"the 'actions' tag attribute has not been set and default application of wildcards is \" +\n                    \"turned off.\";\n                throw new JspException( msg );\n            }\n\n        }\n    }\n\n    public int onDoStartTag() throws JspException {\n        Permission p = PermissionUtils.createPermission( getType(), getTarget(), getActions() );\n        boolean show = showTagBody( p );\n        if ( show ) {\n            return TagSupport.EVAL_BODY_INCLUDE;\n        } else {\n            return TagSupport.SKIP_BODY;\n        }\n    }\n\n    protected abstract boolean showTagBody( Permission p );\n\n}\n","lineNo":48}
{"Refactored Sample":"package org.jsecurity.ri.web.tags;\n\nimport org.jsecurity.authz.InstancePermission;\nimport org.jsecurity.ri.util.PermissionUtils;\n\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport java.security.Permission;\n\n/**\n * @author Les Hazlewood\n * @author Jeremy Haile\n */\npublic abstract class PermissionTag extends SecureTag {\n\n    private String type = null;\n    private String target = null;\n    private String actions = null;\n\n    public PermissionTag() {\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType( String type ) {\n        this.type = type;\n    }\n\n    public String getTarget() {\n        return target;\n    }\n\n    public void setTarget( String target ) {\n        this.target = target;\n    }\n\n    public String getActions() {\n        return actions;\n    }\n\n    public void setActions( String actions ) {\n        this.actions = actions;\n    }\n\n    protected void verifyAttributes() throws JspException {\n        String type = getType();\n        String target = getTarget();\n        String actions = getActions();\n\n        if ( type == null ) {\n            String msg = \"the 'type' tag attribute must be set\";\n            throw new JspException( msg );\n        }\n\n        if ( target == null ) {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"'target' tag attribute was not specified.  Assuming default of \" +\n                           \"\\\"*\\\", as all Permission objects must be instantiated with a \" +\n                           \"name/target.\" );\n            }\n            setTarget( InstancePermission.WILDCARD );\n        }\n    }\n\n    public int onDoStartTag() throws JspException {\n\n        Permission p = null;\n\n        String actions = getActions();\n\n        if ( actions == null ) {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No actions attribute specified, creating permission with target only.\" );\n            }\n            p = PermissionUtils.createPermission( getType(), getTarget() );\n        } else {\n            p = PermissionUtils.createPermission( getType(), getTarget(), actions );\n        }\n\n        boolean show = showTagBody( p );\n        if ( show ) {\n            return TagSupport.EVAL_BODY_INCLUDE;\n        } else {\n            return TagSupport.SKIP_BODY;\n        }\n    }\n\n    protected abstract boolean showTagBody( Permission p );\n\n}\n","Smelly Sample":"package org.jsecurity.ri.web.tags;\n\nimport org.jsecurity.ri.util.PermissionUtils;\n\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport java.security.Permission;\n\n/**\n * @author Les Hazlewood\n * @author Jeremy Haile\n */\npublic abstract class PermissionTag extends SecureTag {\n\n    private String type = null;\n    private String target = null;\n    private String actions = null;\n\n    private boolean applyWildcard = true;\n\n    public PermissionTag() {\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType( String type ) {\n        this.type = type;\n    }\n\n    public String getTarget() {\n        return target;\n    }\n\n    public void setTarget( String target ) {\n        this.target = target;\n    }\n\n    public String getActions() {\n        return actions;\n    }\n\n    public void setActions( String actions ) {\n        this.actions = actions;\n    }\n\n    /**\n     * Returns whether or not to apply the wildcard ('*') if the {@link #getTarget target} or\n     * {@link #getActions actions} tag attributes are unspecified.\n     *\n     * <p>That is, if this property is set to <tt>true<\/tt> (the default), and the <tt>target<\/tt> property is not\n     * specified (i.e. <tt>null<\/tt>), the target property will automatically be set to '*'.  And, if the\n     * <tt>actions<\/tt> property is not specified (i.e. <tt>null<\/tt>), the actions property will automatically be set\n     * to '*'.\n     *\n     * <p>If this attribute is set to <tt>false<\/tt>, and the <tt>target<\/tt> or <tt>actions<\/tt> attributes are not set,\n     * this tag considers this state a programming error, and will throw an exception.\n     *\n     * <p>The default setting is <b><tt>true<\/tt><\/b>.\n     *\n     * @return <tt>true<\/tt> if the wildcard token should be applied to null <tt>target<\/tt> or <tt>actions<\/tt>\n     * properties, <tt>false<\/tt> otherwise.\n     *\n     */\n    public boolean isApplyWildcard() {\n        return applyWildcard;\n    }\n\n    /**\n     * Turns on or off default application of the wildcard token ('*') if the {@link #getTarget target} or\n     * {@link #getActions actions} attributes are null.\n     *\n     * @param applyWildcard whether or not to apply the wildcard token in the event of null attributes.\n     * @see #isApplyWildcard\n     */\n    public void setApplyWildcard( boolean applyWildcard ) {\n        this.applyWildcard = applyWildcard;\n    }\n\n    protected void verifyAttributes() throws JspException {\n        if ( getType() == null ) {\n            String msg = \"the 'type' tag attribute must be set\";\n            throw new JspException( msg );\n        }\n        if ( getTarget() == null ) {\n            if ( isApplyWildcard() ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"'target' tag attribute was not specified.  Assuming default of '*'.  If you \" +\n                        \"do not want this default to be applied set the 'applyWildcard' attribute \" +\n                        \"to false.\" );\n                }\n                setTarget( \"*\" );\n            } else {\n                String msg = \"the 'target' tag attribute has not been set and default application of wildcards is \" +\n                    \"turned off.\";\n                throw new JspException( msg );\n            }\n        }\n        if ( getActions() == null ) {\n            if ( isApplyWildcard() ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"'actions' tag attribute was not specified.  Assuming default of '*'.  If you \" +\n                        \"do not want this default to be applied set the 'applyWildcard' attribute \" +\n                        \"to false.\" );\n                }\n                setTarget( \"*\" );\n            } else {\n                String msg = \"the 'actions' tag attribute has not been set and default application of wildcards is \" +\n                    \"turned off.\";\n                throw new JspException( msg );\n            }\n\n        }\n    }\n\n    public int onDoStartTag() throws JspException {\n        Permission p = PermissionUtils.createPermission( getType(), getTarget(), getActions() );\n        boolean show = showTagBody( p );\n        if ( show ) {\n            return TagSupport.EVAL_BODY_INCLUDE;\n        } else {\n            return TagSupport.SKIP_BODY;\n        }\n    }\n\n    protected abstract boolean showTagBody( Permission p );\n\n}\n","lineNo":49}
{"Refactored Sample":"package org.jsecurity.ri.web.tags;\n\nimport org.jsecurity.authz.InstancePermission;\nimport org.jsecurity.ri.util.PermissionUtils;\n\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport java.security.Permission;\n\n/**\n * @author Les Hazlewood\n * @author Jeremy Haile\n */\npublic abstract class PermissionTag extends SecureTag {\n\n    private String type = null;\n    private String target = null;\n    private String actions = null;\n\n    public PermissionTag() {\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType( String type ) {\n        this.type = type;\n    }\n\n    public String getTarget() {\n        return target;\n    }\n\n    public void setTarget( String target ) {\n        this.target = target;\n    }\n\n    public String getActions() {\n        return actions;\n    }\n\n    public void setActions( String actions ) {\n        this.actions = actions;\n    }\n\n    protected void verifyAttributes() throws JspException {\n        String type = getType();\n        String target = getTarget();\n        String actions = getActions();\n\n        if ( type == null ) {\n            String msg = \"the 'type' tag attribute must be set\";\n            throw new JspException( msg );\n        }\n\n        if ( target == null ) {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"'target' tag attribute was not specified.  Assuming default of \" +\n                           \"\\\"*\\\", as all Permission objects must be instantiated with a \" +\n                           \"name/target.\" );\n            }\n            setTarget( InstancePermission.WILDCARD );\n        }\n    }\n\n    public int onDoStartTag() throws JspException {\n\n        Permission p = null;\n\n        String actions = getActions();\n\n        if ( actions == null ) {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No actions attribute specified, creating permission with target only.\" );\n            }\n            p = PermissionUtils.createPermission( getType(), getTarget() );\n        } else {\n            p = PermissionUtils.createPermission( getType(), getTarget(), actions );\n        }\n\n        boolean show = showTagBody( p );\n        if ( show ) {\n            return TagSupport.EVAL_BODY_INCLUDE;\n        } else {\n            return TagSupport.SKIP_BODY;\n        }\n    }\n\n    protected abstract boolean showTagBody( Permission p );\n\n}\n","Smelly Sample":"package org.jsecurity.ri.web.tags;\n\nimport org.jsecurity.ri.util.PermissionUtils;\n\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport java.security.Permission;\n\n/**\n * @author Les Hazlewood\n * @author Jeremy Haile\n */\npublic abstract class PermissionTag extends SecureTag {\n\n    private String type = null;\n    private String target = null;\n    private String actions = null;\n\n    private boolean applyWildcard = true;\n\n    public PermissionTag() {\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType( String type ) {\n        this.type = type;\n    }\n\n    public String getTarget() {\n        return target;\n    }\n\n    public void setTarget( String target ) {\n        this.target = target;\n    }\n\n    public String getActions() {\n        return actions;\n    }\n\n    public void setActions( String actions ) {\n        this.actions = actions;\n    }\n\n    /**\n     * Returns whether or not to apply the wildcard ('*') if the {@link #getTarget target} or\n     * {@link #getActions actions} tag attributes are unspecified.\n     *\n     * <p>That is, if this property is set to <tt>true<\/tt> (the default), and the <tt>target<\/tt> property is not\n     * specified (i.e. <tt>null<\/tt>), the target property will automatically be set to '*'.  And, if the\n     * <tt>actions<\/tt> property is not specified (i.e. <tt>null<\/tt>), the actions property will automatically be set\n     * to '*'.\n     *\n     * <p>If this attribute is set to <tt>false<\/tt>, and the <tt>target<\/tt> or <tt>actions<\/tt> attributes are not set,\n     * this tag considers this state a programming error, and will throw an exception.\n     *\n     * <p>The default setting is <b><tt>true<\/tt><\/b>.\n     *\n     * @return <tt>true<\/tt> if the wildcard token should be applied to null <tt>target<\/tt> or <tt>actions<\/tt>\n     * properties, <tt>false<\/tt> otherwise.\n     *\n     */\n    public boolean isApplyWildcard() {\n        return applyWildcard;\n    }\n\n    /**\n     * Turns on or off default application of the wildcard token ('*') if the {@link #getTarget target} or\n     * {@link #getActions actions} attributes are null.\n     *\n     * @param applyWildcard whether or not to apply the wildcard token in the event of null attributes.\n     * @see #isApplyWildcard\n     */\n    public void setApplyWildcard( boolean applyWildcard ) {\n        this.applyWildcard = applyWildcard;\n    }\n\n    protected void verifyAttributes() throws JspException {\n        if ( getType() == null ) {\n            String msg = \"the 'type' tag attribute must be set\";\n            throw new JspException( msg );\n        }\n        if ( getTarget() == null ) {\n            if ( isApplyWildcard() ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"'target' tag attribute was not specified.  Assuming default of '*'.  If you \" +\n                        \"do not want this default to be applied set the 'applyWildcard' attribute \" +\n                        \"to false.\" );\n                }\n                setTarget( \"*\" );\n            } else {\n                String msg = \"the 'target' tag attribute has not been set and default application of wildcards is \" +\n                    \"turned off.\";\n                throw new JspException( msg );\n            }\n        }\n        if ( getActions() == null ) {\n            if ( isApplyWildcard() ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"'actions' tag attribute was not specified.  Assuming default of '*'.  If you \" +\n                        \"do not want this default to be applied set the 'applyWildcard' attribute \" +\n                        \"to false.\" );\n                }\n                setTarget( \"*\" );\n            } else {\n                String msg = \"the 'actions' tag attribute has not been set and default application of wildcards is \" +\n                    \"turned off.\";\n                throw new JspException( msg );\n            }\n\n        }\n    }\n\n    public int onDoStartTag() throws JspException {\n        Permission p = PermissionUtils.createPermission( getType(), getTarget(), getActions() );\n        boolean show = showTagBody( p );\n        if ( show ) {\n            return TagSupport.EVAL_BODY_INCLUDE;\n        } else {\n            return TagSupport.SKIP_BODY;\n        }\n    }\n\n    protected abstract boolean showTagBody( Permission p );\n\n}\n","lineNo":71}
{"Refactored Sample":"/*\n * Copyright (C) 2005 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.ri.authc.module.activedirectory;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.IncorrectCredentialException;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authc.module.AuthenticationInfo;\nimport org.jsecurity.authc.module.AuthenticationModule;\nimport org.jsecurity.ri.authc.module.dao.SimpleAuthenticationInfo;\nimport org.jsecurity.ri.util.UsernamePrincipal;\n\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.naming.ldap.InitialLdapContext;\nimport javax.naming.ldap.LdapContext;\nimport java.security.Principal;\nimport java.util.*;\n\n/**\n * <p>An {@link AuthenticationModule} that authenticates with an active directory LDAP\n * server to determine the roles for a particular user.  This module accepts authentication\n * tokens of type {@link UsernamePasswordToken}.  This implementation only returns roles for a\n * particular user, and not permissions - but it can be subclassed to build a permission\n * list as well.<\/p>\n *\n * <p>More advanced implementations would likely want to override the\n * {@link #getLdapDirectoryInfo(String, javax.naming.ldap.LdapContext)} and\n * {@link #buildAuthenticationInfo(String, char[], LdapDirectoryInfo)} methods.<\/p>\n *\n * todo This class needs to be refactored to have an LdapAuthenticationModule superclass\n *\n * @see LdapDirectoryInfo\n * @see #getLdapDirectoryInfo(String, javax.naming.ldap.LdapContext)\n * @see #buildAuthenticationInfo(String, char[], LdapDirectoryInfo)\n *\n * @author Tim Veil\n * @author Jeremy Haile\n */\npublic class ActiveDirectoryAuthenticationModule implements AuthenticationModule {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logger.\n     */\n    protected transient final Log log = LogFactory.getLog( getClass() );\n\n    /**\n     * The type of LDAP authentication to perform.\n     */\n    private String authentication = \"simple\";\n\n    /**\n     * A suffix appended to the username when searching in the LDAP context.\n     * This is typically for domain names.  (e.g. \"@MyDomain.local\")\n     */\n    private String principalSuffix = null;\n\n    /**\n     * The search base for the search to perform in the LDAP server.\n     * (e.g. OU=OrganizationName,DC=MyDomain,DC=local )\n     */\n    private String searchBase = null;\n\n    /**\n     * The context factory to use. This defaults to the SUN LDAP JNDI implementation\n     * but can be overridden to use custom LDAP factories.\n     */\n    private String contextFactory = \"com.sun.jndi.ldap.LdapCtxFactory\";\n\n    /**\n     * The LDAP url to connect to. (e.g. ldap://<activeDirectoryHostname>:<port>)\n     */\n    private String url = null;\n\n    /**\n     * The LDAP referral property.  Defaults to \"follow\"\n     */\n    private String refferal = \"follow\";\n\n    /**\n     * Mapping from fully qualified group names (e.g. CN=Group,OU=Company,DC=MyDomain,DC=local)\n     * as returned by active directory to role names.\n     */\n    private Map<String, String> groupRoleMap;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAuthentication(String authentication) {\n        this.authentication = authentication;\n    }\n\n    public void setPrincipalSuffix(String principalSuffix) {\n        this.principalSuffix = principalSuffix;\n    }\n\n    public void setSearchBase(String searchBase) {\n        this.searchBase = searchBase;\n    }\n\n    public void setContextFactory(String contextFactory) {\n        this.contextFactory = contextFactory;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public void setRefferal(String refferal) {\n        this.refferal = refferal;\n    }\n\n    public void setGroupRoleMap(Map<String, String> groupRoleMap) {\n        this.groupRoleMap = groupRoleMap;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    public boolean supports(Class tokenClass) {\n        return UsernamePasswordToken.class.isAssignableFrom( tokenClass );\n    }\n\n    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n\n        LdapDirectoryInfo ldapDirectoryInfo = performAuthentication(upToken.getUsername(), upToken.getPassword());\n\n        return buildAuthenticationInfo( upToken.getUsername(), upToken.getPassword(), ldapDirectoryInfo );\n    }\n\n    /**\n     * Builds an {@link AuthenticationInfo} object to return based on an {@link LdapDirectoryInfo} object\n     * returned from {@link #performAuthentication(String, char[])}\n     *\n     * @param username the username of the user being authenticated.\n     * @param password the password of the user being authenticated.\n     * @param ldapDirectoryInfo the LDAP directory information queried from the LDAP server.\n     * @return an instance of {@link AuthenticationInfo} that represents the principal, credentials, and\n     * roles that this user has.\n     */\n    protected AuthenticationInfo buildAuthenticationInfo(String username, char[] password, LdapDirectoryInfo ldapDirectoryInfo) {\n        List<Principal> principals = new ArrayList<Principal>( ldapDirectoryInfo.getPrincipals().size() + 1 );\n\n        UsernamePrincipal principal = new UsernamePrincipal( username );\n\n        principals.add( principal );\n        principals.addAll( ldapDirectoryInfo.getPrincipals() );\n\n        return new SimpleAuthenticationInfo( principals, password, ldapDirectoryInfo.getRoleNames() );\n    }\n\n\n    /**\n     * Performs the actual authentication of the user by connecting to the LDAP server, querying it\n     * for user information, and returning an {@link LdapDirectoryInfo} instance containing the\n     * results.\n     *\n     * <p>Typically, users that need special behavior will not override this method, but will instead\n     * override {@link #getLdapDirectoryInfo(String, javax.naming.ldap.LdapContext)}<\/p>\n     *\n     * @param username the username of the user being authenticated.\n     * @param password the password of the user being authenticated.\n     *\n     * @return the results of the LDAP directory search.\n     */\n    protected LdapDirectoryInfo performAuthentication(String username, char[] password) {\n\n        if( searchBase == null ) {\n            throw new IllegalStateException( \"A search base must be specified.\" );\n        }\n        if( url == null ) {\n            throw new IllegalStateException( \"An LDAP URL must be specified of the form ldap://<hostname>:<port>\" );\n        }\n\n\n        if( principalSuffix != null ) {\n            username = username + principalSuffix;\n        }\n\n        Hashtable<String, String> env = new Hashtable<String, String>(6);\n\n        env.put(Context.SECURITY_AUTHENTICATION, authentication);\n        env.put(Context.SECURITY_PRINCIPAL, username);\n        env.put(Context.SECURITY_CREDENTIALS, new String( password ));\n        env.put(Context.INITIAL_CONTEXT_FACTORY, contextFactory);\n        env.put(Context.PROVIDER_URL, url);\n        env.put(Context.REFERRAL, refferal);\n\n        if (log.isDebugEnabled()) {\n            log.debug( \"Initializing LDAP context using environment properties [\" + env + \"]\" );\n        }\n\n        LdapContext ctx = null;\n        try {\n            ctx = new InitialLdapContext(env, null);\n\n            return getLdapDirectoryInfo(username, ctx);\n\n\n        } catch (javax.naming.AuthenticationException e) {\n            throw new IncorrectCredentialException( \"User could not be authenticated with LDAP server.\", e );\n\n        } catch (NamingException e) {\n            throw new AuthenticationException( \"LDAP naming error while attempting to authenticate user.\", e );\n\n        } finally {\n            // Always close the LDAP context\n            try {\n                if (ctx != null) {\n                    ctx.close();\n                }\n            } catch (NamingException e) {\n                if( log.isErrorEnabled() ) {\n                    log.error(\"Problem closing Context: \", e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Builds an {@link LdapDirectoryInfo} object by querying the given LDAP context for the\n     * specified username.  The default implementation queries for all groups that\n     * the user is a member of and returns them as roles for that user.\n     *\n     * <p>This method can be overridden by subclasses to query the LDAP server\n     *\n     * @param username the username whose information should be queried from the LDAP server.\n     * @param ctx the LDAP context that is connected to the LDAP server.\n     *\n     * @return an {@link LdapDirectoryInfo} instance containing information retrieved from LDAP\n     * that can be used to build an {@link AuthenticationInfo} instance to return.\n     *\n     * @throws NamingException if any LDAP errors occur during the search.\n     */\n    protected LdapDirectoryInfo getLdapDirectoryInfo(String username, LdapContext ctx) throws NamingException {\n\n        LdapDirectoryInfo info = new LdapDirectoryInfo();\n\n\n        SearchControls searchCtls = new SearchControls();\n        searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        String searchFilter = \"(&(objectClass=*)(userPrincipalName=\" + username + \"))\";\n\n        // Perform context search\n        NamingEnumeration answer = ctx.search(searchBase, searchFilter, searchCtls);\n\n        while (answer.hasMoreElements()) {\n            SearchResult sr = (SearchResult) answer.next();\n\n            log.debug(\"Retrieving group names for user [\" + sr.getName() + \"]\");\n\n            Attributes attrs = sr.getAttributes();\n\n            if (attrs != null) {\n                NamingEnumeration ae = attrs.getAll();\n                while( ae.hasMore() ) {\n                    Attribute attr = (Attribute) ae.next();\n                    processAttribute(info, attr);\n                }\n            }\n        }\n\n        return info;\n    }\n\n    protected void processAttribute(LdapDirectoryInfo info, Attribute attr) throws NamingException {\n\n        if( attr.getID().equals( \"memberOf\" ) ) {\n\n            Collection<String> groupNames = getAllAttributeValues(attr);\n            Collection<String> roleNames = translateRoleNames(groupNames);\n\n            if( log.isDebugEnabled() ) {\n                log.debug( \"Adding roles [\" + groupNames + \"] to LDAP directory info.\" );\n            }\n\n            info.addAllRoleNames( roleNames );\n\n        }\n\n    }\n\n    protected Collection<String> translateRoleNames(Collection<String> groupNames) {\n        Set<String> roleNames = new HashSet<String>( groupNames.size() );\n\n        for( String groupName : groupNames ) {\n            String roleName = groupRoleMap.get( groupName );\n            roleNames.add( roleName );\n        }\n        return roleNames;\n    }\n\n\n    /**\n     * Helper method used to retrieve all attribute values from a particular context attribute.\n     */\n    protected Collection<String> getAllAttributeValues(Attribute attr) throws NamingException {\n        Set<String> values = new HashSet<String>();\n        for (NamingEnumeration e = attr.getAll(); e.hasMore();) {\n            String value = (String) e.next();\n            values.add( value );\n        }\n        return values;\n    }\n\n    public static void main(String[] args) {\n        ActiveDirectoryAuthenticationModule m = new ActiveDirectoryAuthenticationModule();\n        m.setUrl( \"ldap://10.0.0.2:389\" );\n        m.setSearchBase( \"OU=SolTech,DC=Solad,DC=local\" );\n        m.setPrincipalSuffix( \"@Solad.local\" );\n\n        UsernamePasswordToken t = new UsernamePasswordToken( \"jhaile\", \"differen\" );\n        AuthenticationInfo ai = m.getAuthenticationInfo( t );\n        System.out.println( ai );\n        for( String roleName : ai.getRoles() ) {\n            System.out.println( roleName );\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.ri.authc.module.activedirectory;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.IncorrectCredentialException;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authc.module.AuthenticationInfo;\nimport org.jsecurity.authc.module.AuthenticationModule;\nimport org.jsecurity.ri.authc.module.dao.SimpleAuthenticationInfo;\nimport org.jsecurity.ri.util.UsernamePrincipal;\n\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.naming.ldap.InitialLdapContext;\nimport javax.naming.ldap.LdapContext;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Set;\n\n/**\n * <p>An {@link AuthenticationModule} that authenticates with an active directory LDAP\n * server to determine the roles for a particular user.  This module accepts authentication\n * tokens of type {@link UsernamePasswordToken}.  This implementation only returns roles for a\n * particular user, and not permissions - but it can be subclassed to build a permission\n * list as well.<\/p>\n *\n * <p>More advanced implementations would likely want to override the\n * {@link #getActiveDirectoryInfo(String, javax.naming.ldap.LdapContext)} and\n * {@link #buildAuthenticationInfo(String, char[], ActiveDirectoryInfo)} methods.<\/p>\n *\n * @see ActiveDirectoryInfo\n * @see #getActiveDirectoryInfo(String, javax.naming.ldap.LdapContext)\n * @see #buildAuthenticationInfo(String, char[], ActiveDirectoryInfo)\n *\n * @author Tim Veil\n * @author Jeremy Haile\n */\npublic class ActiveDirectoryAuthenticationModule implements AuthenticationModule {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Commons-logger.\n     */\n    protected transient final Log log = LogFactory.getLog( getClass() );\n\n    /**\n     * The type of LDAP authentication to perform.\n     */\n    private String authentication = \"simple\";\n\n    /**\n     * A suffix appended to the username when searching in the LDAP context.\n     * This is typically for domain names.  (e.g. \"@MyDomain.local\")\n     */\n    private String principalSuffix = null;\n\n    /**\n     * The search base for the search to perform in the LDAP server.\n     * (e.g. OU=OrganizationName,DC=MyDomain,DC=local )\n     */\n    private String searchBase = null;\n\n    /**\n     * The context factory to use. This defaults to the SUN LDAP JNDI implementation\n     * but can be overridden to use custom LDAP factories.\n     */\n    private String contextFactory = \"com.sun.jndi.ldap.LdapCtxFactory\";\n\n    /**\n     * The LDAP url to connect to. (e.g. ldap://<activeDirectoryHostname>:<port>)\n     */\n    private String url = null;\n\n    /**\n     * The LDAP referral property.  Defaults to \"follow\"\n     */\n    private String refferal = \"follow\";\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAuthentication(String authentication) {\n        this.authentication = authentication;\n    }\n\n    public void setPrincipalSuffix(String principalSuffix) {\n        this.principalSuffix = principalSuffix;\n    }\n\n    public void setSearchBase(String searchBase) {\n        this.searchBase = searchBase;\n    }\n\n    public void setContextFactory(String contextFactory) {\n        this.contextFactory = contextFactory;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public void setRefferal(String refferal) {\n        this.refferal = refferal;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    public boolean supports(Class tokenClass) {\n        return UsernamePasswordToken.class.isAssignableFrom( tokenClass );\n    }\n\n    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n\n        ActiveDirectoryInfo activeDirectoryInfo = performAuthentication(upToken.getUsername(), upToken.getPassword());\n\n        return buildAuthenticationInfo( upToken.getUsername(), upToken.getPassword(), activeDirectoryInfo );\n    }\n\n    /**\n     * Builds an {@link AuthenticationInfo} object to return based on an {@link ActiveDirectoryInfo} object\n     * returned from {@link #performAuthentication(String, char[])}\n     *\n     * @param username the username of the user being authenticated.\n     * @param password the password of the user being authenticated.\n     * @param activeDirectoryInfo the active directory information queried from the active directory\n     * LDAP server.\n     * @return an instance of {@link AuthenticationInfo} that represents the principal, credentials, and\n     * roles that this user has.\n     */\n    protected AuthenticationInfo buildAuthenticationInfo(String username, char[] password, ActiveDirectoryInfo activeDirectoryInfo) {\n        UsernamePrincipal principal = new UsernamePrincipal( username );\n\n        return new SimpleAuthenticationInfo( principal, password, activeDirectoryInfo.getRoleNames() );\n    }\n\n\n    /**\n     * Performs the actual authentication of the user by connecting to the LDAP server, querying it\n     * for user information, and returning an {@link ActiveDirectoryInfo} instance containing the\n     * results.\n     *\n     * <p>Typically, users that need special behavior will not override this method, but will instead\n     * override {@link #getActiveDirectoryInfo(String, javax.naming.ldap.LdapContext)}<\/p>\n     *\n     * @param username the username of the user being authenticated.\n     * @param password the password of the user being authenticated.\n     *\n     * @return the results of the active directory search.\n     */\n    protected ActiveDirectoryInfo performAuthentication(String username, char[] password) {\n\n        if( searchBase == null ) {\n            throw new IllegalStateException( \"A search base must be specified.\" );\n        }\n        if( url == null ) {\n            throw new IllegalStateException( \"An LDAP URL must be specified of the form ldap://<hostname>:<port>\" );\n        }\n\n\n        if( principalSuffix != null ) {\n            username = username + principalSuffix;\n        }\n\n        Hashtable<String, String> env = new Hashtable<String, String>(6);\n\n        env.put(Context.SECURITY_AUTHENTICATION, authentication);\n        env.put(Context.SECURITY_PRINCIPAL, username);\n        env.put(Context.SECURITY_CREDENTIALS, new String( password ));\n        env.put(Context.INITIAL_CONTEXT_FACTORY, contextFactory);\n        env.put(Context.PROVIDER_URL, url);\n        env.put(Context.REFERRAL, refferal);\n\n        if (log.isDebugEnabled()) {\n            log.debug( \"Initializing LDAP context using environment properties [\" + env + \"]\" );\n        }\n\n        LdapContext ctx = null;\n        try {\n            ctx = new InitialLdapContext(env, null);\n\n            return getActiveDirectoryInfo(username, ctx);\n\n\n        } catch (javax.naming.AuthenticationException e) {\n            throw new IncorrectCredentialException( \"User could not be authenticated with LDAP server.\", e );\n\n        } catch (NamingException e) {\n            throw new AuthenticationException( \"LDAP naming error while attempting to authenticate user.\", e );\n\n        } finally {\n            // Always close the LDAP context\n            try {\n                if (ctx != null) {\n                    ctx.close();\n                }\n            } catch (NamingException e) {\n                if( log.isErrorEnabled() ) {\n                    log.error(\"Problem closing Context: \", e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Builds an active directory info object by querying the given LDAP context for the\n     * specified username.  The default implementation queries for all groups that\n     * the user is a member of and returns them as roles for that user.\n     *\n     * <p>This method can be overridden by subclasses to query the LDAP server\n     *\n     * @param username the username whose information should be queried from the Active Directory\n     * LDAP server.\n     * @param ctx the LDAP context that is connected to the active directory server.\n     *\n     * @return an {@link ActiveDirectoryInfo} instance containing information retrieved from LDAP\n     * that can be used to build an {@link AuthenticationInfo} instance to return.\n     *\n     * @throws NamingException if any LDAP errors occur during the search.\n     */\n    private ActiveDirectoryInfo getActiveDirectoryInfo(String username, LdapContext ctx) throws NamingException {\n\n        Set<String> groupNames = new HashSet<String>();\n\n        String[] returnedAtts = {\"memberOf\"};\n\n        SearchControls searchCtls = new SearchControls();\n        searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        searchCtls.setReturningAttributes(returnedAtts);\n\n        String searchFilter = \"(&(objectClass=*)(userPrincipalName=\" + username + \"))\";\n\n        // Perform context search\n        NamingEnumeration answer = ctx.search(searchBase, searchFilter, searchCtls);\n\n        while (answer.hasMoreElements()) {\n            SearchResult sr = (SearchResult) answer.next();\n\n            log.debug(\"Retrieving group names for user [\" + sr.getName() + \"]\");\n\n            Attributes attrs = sr.getAttributes();\n\n            if (attrs != null) {\n                NamingEnumeration ae = attrs.getAll();\n                while( ae.hasMore() ) {\n                    Attribute attr = (Attribute) ae.next();\n\n                    if( attr.getID().equals( \"memberOf\" ) ) {\n                        groupNames.addAll( getAllAttributeValues(attr) );\n                    } else {\n                        throw new RuntimeException( \"Unexpected attribute type [\" + attr.getID() + \"] found in search results.\" );\n                    }\n                }\n            }\n        }\n\n        if( log.isDebugEnabled() ) {\n            log.debug( \"Returning active directory info with roles [\" + groupNames + \"]\" );\n        }\n\n        ActiveDirectoryInfo info = new ActiveDirectoryInfo();\n        info.setRoleNames( groupNames );\n\n        return info;\n    }\n\n\n    /**\n     * Helper method used to retrieve all attribute values from a particular context attribute.\n     */\n    private Collection<String> getAllAttributeValues(Attribute attr) throws NamingException {\n        Set<String> values = new HashSet<String>();\n        for (NamingEnumeration e = attr.getAll(); e.hasMore();) {\n            String value = (String) e.next();\n            values.add( value );\n        }\n        return values;\n    }\n\n    public static void main(String[] args) {\n        ActiveDirectoryAuthenticationModule m = new ActiveDirectoryAuthenticationModule();\n        m.setUrl( \"ldap://10.0.0.2:389\" );\n        m.setSearchBase( \"OU=SolTech,DC=Solad,DC=local\" );\n        m.setPrincipalSuffix( \"@Solad.local\" );\n\n        UsernamePasswordToken t = new UsernamePasswordToken( \"jhaile\", \"differen\" );\n        AuthenticationInfo ai = m.getAuthenticationInfo( t );\n        System.out.println( ai );\n        for( String roleName : ai.getRoles() ) {\n            System.out.println( roleName );\n        }\n    }\n}\n","lineNo":315}
{"Refactored Sample":"/*\n * Copyright (C) 2005 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.ri.session;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.session.Session;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Simple {@link org.jsecurity.session.Session} implementation, intended to be used on the business/server tier.\n * \n * @since 0.1\n * @author Les Hazlewood\n */\npublic class SimpleSession implements Session, Serializable {\n\n    private final transient Log log = LogFactory.getLog( getClass() );\n\n    private Serializable sessionId = null;\n    private Date startTimestamp = null;\n    private Date stopTimestamp = null;\n    private Date lastAccessTime = null;\n    private boolean expired = false;\n    private InetAddress hostAddress = null;\n\n    private Map<Object, Object> attributes = null;\n\n    public SimpleSession() {\n\n        //JSecurity uses UUID's by default.  This can be overridden via the setSessionId method:\n        sessionId = java.util.UUID.randomUUID();\n        startTimestamp = new Date();\n        lastAccessTime = startTimestamp; //default when first instantiated\n        try {\n            hostAddress = InetAddress.getLocalHost();\n        } catch ( Exception e ) {\n            if ( log.isWarnEnabled() ) {\n                log.warn( \"Unable to acquire localhost address from \" +\n                          \"method call java.net.InetAddress.getLocalHost().  hostAddress \" +\n                          \"will be null\", e );\n            }\n        }\n\n        attributes = new HashMap<Object,Object>();\n    }\n\n    public Serializable getSessionId() {\n        return this.sessionId;\n    }\n\n    public void setSessionId( Serializable sessionId ) {\n        this.sessionId = sessionId;\n    }\n\n    public Date getStartTimestamp() {\n        return startTimestamp;\n    }\n\n    public void setStartTimestamp( Date startTimestamp ) {\n        this.startTimestamp = startTimestamp;\n    }\n\n    public Date getStopTimestamp() {\n        return stopTimestamp;\n    }\n\n    public void setStopTimestamp( Date stopTimestamp ) {\n        this.stopTimestamp = stopTimestamp;\n    }\n\n    public Date getLastAccessTime() {\n        return lastAccessTime;\n    }\n\n    public void setLastAccessTime( Date lastAccessTime ) {\n        this.lastAccessTime = lastAccessTime;\n    }\n\n    public boolean isExpired() {\n        return expired;\n    }\n\n    public void setExpired( boolean expired ) {\n        this.expired = expired;\n    }\n\n    public InetAddress getHostAddress() {\n        return hostAddress;\n    }\n\n    public void setHostAddress( InetAddress hostAddress ) {\n        this.hostAddress = hostAddress;\n    }\n\n    public Map<Object, Object> getAttributes() {\n        return attributes;\n    }\n\n    public void setAttributes( Map<Object, Object> attributes ) {\n        this.attributes = attributes;\n    }\n\n    public void touch() {\n        this.lastAccessTime = new Date();\n    }\n\n    public void stop() {\n        this.stopTimestamp = new Date();\n    }\n\n    private Map<Object,Object> getAttributesLazy() {\n        Map<Object,Object> attributes = getAttributes();\n        if ( attributes == null ) {\n            attributes = new HashMap<Object,Object>();\n            setAttributes( attributes );\n        }\n        return attributes;\n    }\n\n    public Object getAttribute( Object key ) {\n        Map<Object,Object> attributes = getAttributes();\n        if ( attributes == null ) {\n            return null;\n        }\n        return attributes.get( key );\n    }\n\n    public void setAttribute( Object key, Object value ) {\n        if ( value == null ) {\n            removeAttribute( key );\n        } else {\n            getAttributesLazy().put( key, value );\n        }\n    }\n\n    public Object removeAttribute( Object key ) {\n        Map<Object,Object> attributes = getAttributes();\n        if ( attributes == null ) {\n            return null;\n        } else {\n            return attributes.remove( key );\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.ri.session;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.session.Session;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Simple {@link org.jsecurity.session.Session} implementation, intended to be used on the business/server tier.\n * \n * @since 0.1\n * @author Les Hazlewood\n */\npublic class SimpleSession implements Session, Serializable {\n\n    private final transient Log log = LogFactory.getLog( getClass() );\n\n    private Serializable sessionId = null;\n    private Date startTimestamp = null;\n    private Date stopTimestamp = null;\n    private Date lastAccessTime = null;\n    private boolean expired = false;\n    private InetAddress hostAddress = null;\n\n    private Map<Object, Object> attributes = null;\n\n    public SimpleSession() {\n\n        //JSecurity uses UUID's by default.  This can be overridden via the setSessionId method:\n        sessionId = java.util.UUID.randomUUID();\n        startTimestamp = new Date();\n        lastAccessTime = startTimestamp; //default when first instantiated\n        try {\n            hostAddress = InetAddress.getLocalHost();\n        } catch ( Exception e ) {\n            if ( log.isWarnEnabled() ) {\n                log.warn( \"Unable to acquire localhost address from \" +\n                          \"method call java.net.InetAddress.getLocalHost().  hostAddress \" +\n                          \"will be null\", e );\n            }\n        }\n\n        attributes = new HashMap<Object,Object>();\n    }\n\n    public Serializable getSessionId() {\n        return this.sessionId;\n    }\n\n    public void setSessionId( Serializable sessionId ) {\n        this.sessionId = sessionId;\n    }\n\n    public Date getStartTimestamp() {\n        return startTimestamp;\n    }\n\n    public void setStartTimestamp( Date startTimestamp ) {\n        this.startTimestamp = startTimestamp;\n    }\n\n    public Date getStopTimestamp() {\n        return stopTimestamp;\n    }\n\n    public void setStopTimestamp( Date stopTimestamp ) {\n        this.stopTimestamp = stopTimestamp;\n    }\n\n    public Date getLastAccessTime() {\n        return lastAccessTime;\n    }\n\n    public void setLastAccessTime( Date lastAccessTime ) {\n        this.lastAccessTime = lastAccessTime;\n    }\n\n    public boolean isExpired() {\n        return expired;\n    }\n\n    public void setExpired( boolean expired ) {\n        this.expired = expired;\n    }\n\n    public InetAddress getHostAddress() {\n        return hostAddress;\n    }\n\n    public void setHostAddress( InetAddress hostAddress ) {\n        this.hostAddress = hostAddress;\n    }\n\n    public Map<Object, Object> getAttributes() {\n        return attributes;\n    }\n\n    public void setAttributes( Map<Object, Object> attributes ) {\n        this.attributes = attributes;\n    }\n\n    public void touch() {\n        this.lastAccessTime = new Date();\n    }\n\n    public void stop() {\n        this.stopTimestamp = new Date();\n    }\n\n    public Object getAttribute( Object key ) {\n        return getAttributes().get( key );\n    }\n\n    public void setAttribute( Object key, Object value ) {\n        if ( value == null ) {\n            removeAttribute( key );\n        } else {\n            getAttributes().put( key, value );\n        }\n    }\n\n    public Object removeAttribute( Object key ) {\n        return getAttributes().remove( key );\n    }\n\n}\n","lineNo":149}
{"Refactored Sample":"/*\n * Copyright (C) 2005 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.ri.session;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.session.Session;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Simple {@link org.jsecurity.session.Session} implementation, intended to be used on the business/server tier.\n * \n * @since 0.1\n * @author Les Hazlewood\n */\npublic class SimpleSession implements Session, Serializable {\n\n    private final transient Log log = LogFactory.getLog( getClass() );\n\n    private Serializable sessionId = null;\n    private Date startTimestamp = null;\n    private Date stopTimestamp = null;\n    private Date lastAccessTime = null;\n    private boolean expired = false;\n    private InetAddress hostAddress = null;\n\n    private Map<Object, Object> attributes = null;\n\n    public SimpleSession() {\n\n        //JSecurity uses UUID's by default.  This can be overridden via the setSessionId method:\n        sessionId = java.util.UUID.randomUUID();\n        startTimestamp = new Date();\n        lastAccessTime = startTimestamp; //default when first instantiated\n        try {\n            hostAddress = InetAddress.getLocalHost();\n        } catch ( Exception e ) {\n            if ( log.isWarnEnabled() ) {\n                log.warn( \"Unable to acquire localhost address from \" +\n                          \"method call java.net.InetAddress.getLocalHost().  hostAddress \" +\n                          \"will be null\", e );\n            }\n        }\n\n        attributes = new HashMap<Object,Object>();\n    }\n\n    public Serializable getSessionId() {\n        return this.sessionId;\n    }\n\n    public void setSessionId( Serializable sessionId ) {\n        this.sessionId = sessionId;\n    }\n\n    public Date getStartTimestamp() {\n        return startTimestamp;\n    }\n\n    public void setStartTimestamp( Date startTimestamp ) {\n        this.startTimestamp = startTimestamp;\n    }\n\n    public Date getStopTimestamp() {\n        return stopTimestamp;\n    }\n\n    public void setStopTimestamp( Date stopTimestamp ) {\n        this.stopTimestamp = stopTimestamp;\n    }\n\n    public Date getLastAccessTime() {\n        return lastAccessTime;\n    }\n\n    public void setLastAccessTime( Date lastAccessTime ) {\n        this.lastAccessTime = lastAccessTime;\n    }\n\n    public boolean isExpired() {\n        return expired;\n    }\n\n    public void setExpired( boolean expired ) {\n        this.expired = expired;\n    }\n\n    public InetAddress getHostAddress() {\n        return hostAddress;\n    }\n\n    public void setHostAddress( InetAddress hostAddress ) {\n        this.hostAddress = hostAddress;\n    }\n\n    public Map<Object, Object> getAttributes() {\n        return attributes;\n    }\n\n    public void setAttributes( Map<Object, Object> attributes ) {\n        this.attributes = attributes;\n    }\n\n    public void touch() {\n        this.lastAccessTime = new Date();\n    }\n\n    public void stop() {\n        this.stopTimestamp = new Date();\n    }\n\n    private Map<Object,Object> getAttributesLazy() {\n        Map<Object,Object> attributes = getAttributes();\n        if ( attributes == null ) {\n            attributes = new HashMap<Object,Object>();\n            setAttributes( attributes );\n        }\n        return attributes;\n    }\n\n    public Object getAttribute( Object key ) {\n        Map<Object,Object> attributes = getAttributes();\n        if ( attributes == null ) {\n            return null;\n        }\n        return attributes.get( key );\n    }\n\n    public void setAttribute( Object key, Object value ) {\n        if ( value == null ) {\n            removeAttribute( key );\n        } else {\n            getAttributesLazy().put( key, value );\n        }\n    }\n\n    public Object removeAttribute( Object key ) {\n        Map<Object,Object> attributes = getAttributes();\n        if ( attributes == null ) {\n            return null;\n        } else {\n            return attributes.remove( key );\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005 Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.ri.session;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.session.Session;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Simple {@link org.jsecurity.session.Session} implementation, intended to be used on the business/server tier.\n * \n * @since 0.1\n * @author Les Hazlewood\n */\npublic class SimpleSession implements Session, Serializable {\n\n    private final transient Log log = LogFactory.getLog( getClass() );\n\n    private Serializable sessionId = null;\n    private Date startTimestamp = null;\n    private Date stopTimestamp = null;\n    private Date lastAccessTime = null;\n    private boolean expired = false;\n    private InetAddress hostAddress = null;\n\n    private Map<Object, Object> attributes = null;\n\n    public SimpleSession() {\n\n        //JSecurity uses UUID's by default.  This can be overridden via the setSessionId method:\n        sessionId = java.util.UUID.randomUUID();\n        startTimestamp = new Date();\n        lastAccessTime = startTimestamp; //default when first instantiated\n        try {\n            hostAddress = InetAddress.getLocalHost();\n        } catch ( Exception e ) {\n            if ( log.isWarnEnabled() ) {\n                log.warn( \"Unable to acquire localhost address from \" +\n                          \"method call java.net.InetAddress.getLocalHost().  hostAddress \" +\n                          \"will be null\", e );\n            }\n        }\n\n        attributes = new HashMap<Object,Object>();\n    }\n\n    public Serializable getSessionId() {\n        return this.sessionId;\n    }\n\n    public void setSessionId( Serializable sessionId ) {\n        this.sessionId = sessionId;\n    }\n\n    public Date getStartTimestamp() {\n        return startTimestamp;\n    }\n\n    public void setStartTimestamp( Date startTimestamp ) {\n        this.startTimestamp = startTimestamp;\n    }\n\n    public Date getStopTimestamp() {\n        return stopTimestamp;\n    }\n\n    public void setStopTimestamp( Date stopTimestamp ) {\n        this.stopTimestamp = stopTimestamp;\n    }\n\n    public Date getLastAccessTime() {\n        return lastAccessTime;\n    }\n\n    public void setLastAccessTime( Date lastAccessTime ) {\n        this.lastAccessTime = lastAccessTime;\n    }\n\n    public boolean isExpired() {\n        return expired;\n    }\n\n    public void setExpired( boolean expired ) {\n        this.expired = expired;\n    }\n\n    public InetAddress getHostAddress() {\n        return hostAddress;\n    }\n\n    public void setHostAddress( InetAddress hostAddress ) {\n        this.hostAddress = hostAddress;\n    }\n\n    public Map<Object, Object> getAttributes() {\n        return attributes;\n    }\n\n    public void setAttributes( Map<Object, Object> attributes ) {\n        this.attributes = attributes;\n    }\n\n    public void touch() {\n        this.lastAccessTime = new Date();\n    }\n\n    public void stop() {\n        this.stopTimestamp = new Date();\n    }\n\n    public Object getAttribute( Object key ) {\n        return getAttributes().get( key );\n    }\n\n    public void setAttribute( Object key, Object value ) {\n        if ( value == null ) {\n            removeAttribute( key );\n        } else {\n            getAttributes().put( key, value );\n        }\n    }\n\n    public Object removeAttribute( Object key ) {\n        return getAttributes().remove( key );\n    }\n\n}\n","lineNo":165}
{"Refactored Sample":"/*\n * Copyright (C) 2005 Jeremy C. Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.ri.authc.module.dao;\n\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.ExpiredCredentialException;\nimport org.jsecurity.authc.IncorrectCredentialException;\nimport org.jsecurity.authc.LockedAccountException;\nimport org.jsecurity.authc.UnknownAccountException;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authc.module.AuthenticationModule;\nimport org.jsecurity.authz.AuthorizationContext;\nimport org.jsecurity.ri.authc.password.PasswordMatcher;\nimport org.jsecurity.ri.authc.password.PlainTextPasswordMatcher;\nimport org.jsecurity.ri.authz.SimpleAuthorizationContext;\nimport org.jsecurity.ri.util.StringPrincipal;\n\nimport java.io.Serializable;\nimport java.security.Permission;\nimport java.security.Principal;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * <p>Module that authenticates a user by delegating the lookup of\n * authentication and authorization information to an {@link AuthenticationDAO}.\n * Users of JSecurity can create their own DAO, or use one of the provided\n * DAO implementations.<\/p>\n *\n * <p>This module is intended to encapsulate the generic behavior of\n * authenticating a user from a username and password based on the\n * {@link AuthenticationInfo} retrieved from the {@link AuthenticationDAO}.<\/p>\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class DAOAuthenticationModule implements AuthenticationModule {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The DAO used to retrieve user authentication and authorization\n     * information from a data store.\n     */\n    private AuthenticationDAO authenticationDao;\n\n    /**\n     * Password matcher used to determine if the provided password matches\n     * the password stored in the data store.\n     */\n    private PasswordMatcher passwordMatcher = new PlainTextPasswordMatcher();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAuthenticationDao(AuthenticationDAO authenticationDao) {\n        this.authenticationDao = authenticationDao;\n    }\n\n    public void setPasswordMatcher(PasswordMatcher passwordMatcher) {\n        this.passwordMatcher = passwordMatcher;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    public boolean supports(Class tokenClass) {\n        return UsernamePasswordToken.class.isAssignableFrom( tokenClass );\n    }\n\n\n    public AuthorizationContext authenticate(AuthenticationToken token) throws AuthenticationException {\n\n        Principal accountIdentifier = getPrincipal( token );\n        Object credentials = getCredentials( token );\n\n        AuthenticationInfo info;\n        try {\n            info = authenticationDao.getAuthenticationInfo( accountIdentifier );\n        } catch (Exception e) {\n            throw new AuthenticationException(\n                \"Account [\" + accountIdentifier + \"] could not be authenticated because an error \" +\n                \"occurred during authentication.\", e );\n        }\n\n        if( info == null ) {\n            String msg = \"No account information found for account [\" + accountIdentifier + \"]\";\n            throw new UnknownAccountException( msg );\n        }\n\n        if( info.isAccountLocked() ) {\n            throw new LockedAccountException( \"Account [\" + accountIdentifier + \"] is locked.\" );\n        }\n\n        if( info.isCredentialsExpired() ) {\n            String msg = \"The credentials for account [\" + accountIdentifier + \"] are expired\";\n            throw new ExpiredCredentialException( msg );\n        }\n\n        if( !passwordMatcher.doPasswordsMatch( (char[])credentials, (char[])info.getCredentials() ) ) {\n            String msg = \"The credentials provided for account [\" +\n                         accountIdentifier + \"] did not match the expected credentials.\";\n            throw new IncorrectCredentialException( msg );\n        }\n\n        return buildAuthorizationContext( info );\n    }\n\n\n    protected AuthorizationContext buildAuthorizationContext(AuthenticationInfo info) {\n\n        return new SimpleAuthorizationContext( info.getPrincipal(),\n                                               info.getRoles(),\n                                               info.getPermissions());\n    }\n\n\n    private Set<Permission> getPermissionsForRoles(Collection<? extends Serializable> roles) {\n        return new HashSet<Permission>();\n    }\n\n\n    protected Principal getPrincipal(AuthenticationToken token) {\n        return new StringPrincipal( ((UsernamePasswordToken)token).getUsername() );\n    }\n\n    private Object getCredentials(AuthenticationToken token) {\n        return ((UsernamePasswordToken)token).getPassword();\n    }\n\n\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005 Jeremy C. Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.ri.authc.module.dao;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authc.module.AuthenticationModule;\nimport org.jsecurity.authz.AuthorizationContext;\nimport org.jsecurity.ri.authc.password.PasswordMatcher;\nimport org.jsecurity.ri.authc.password.PlainTextPasswordMatcher;\nimport org.jsecurity.ri.authz.SimpleAuthorizationContext;\nimport org.jsecurity.ri.authz.UsernamePrincipal;\n\nimport java.io.Serializable;\nimport java.security.Permission;\nimport java.security.Principal;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * <p>Module that authenticates a user by delegating the lookup of\n * authentication and authorization information to an {@link AuthenticationDAO}.\n * Users of JSecurity can create their own DAO, or use one of the provided\n * DAO implementations.<\/p>\n *\n * <p>This module is intended to encapsulate the generic behavior of\n * authenticating a user from a username and password based on the\n * {@link AuthenticationInfo} retrieved from the {@link AuthenticationDAO}.<\/p>\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class DAOAuthenticationModule implements AuthenticationModule {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The DAO used to retrieve user authentication and authorization\n     * information from a data store.\n     */\n    private AuthenticationDAO authenticationDao;\n\n    /**\n     * Password matcher used to determine if the provided password matches\n     * the password stored in the data store.\n     */\n    private PasswordMatcher passwordMatcher = new PlainTextPasswordMatcher();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAuthenticationDao(AuthenticationDAO authenticationDao) {\n        this.authenticationDao = authenticationDao;\n    }\n\n    public void setPasswordMatcher(PasswordMatcher passwordMatcher) {\n        this.passwordMatcher = passwordMatcher;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    public boolean supports(Class tokenClass) {\n        return UsernamePasswordToken.class.isAssignableFrom( tokenClass );\n    }\n\n\n    public AuthorizationContext authenticate(AuthenticationToken token) throws AuthenticationException {\n\n        String username = getUsername( token );\n        char[] password = getPassword( token );\n\n        AuthenticationInfo info = null;\n        try {\n            info = authenticationDao.getUserAuthenticationInfo( username );\n        } catch (Exception e) {\n            throw new AuthenticationException(\n                \"User [\" + username + \"] could not be authenticated because an error occurred \" +\n                \"during authentication.\", e );\n        }\n\n        if( info == null ) {\n            throw new UnknownAccountException( \"No account information found for username [\" + username + \"]\" );\n        }\n\n        if( info.isAccountLocked() ) {\n            throw new LockedAccountException( \"The account for user [\" + username + \"] is locked.\" );\n        }\n\n        if( info.isCredentialsExpired() ) {\n            throw new ExpiredCredentialException( \"The credentials for user [\" + username + \"] are expired.\" );\n        }\n\n        if( !passwordMatcher.doPasswordsMatch( password, info.getPassword() ) ) {\n            throw new IncorrectCredentialException( \"The password provided for user [\" + username + \"] was incorrect.\" );\n        }\n\n        return buildAuthorizationContext( info );\n    }\n\n\n    protected AuthorizationContext buildAuthorizationContext(AuthenticationInfo info) {\n\n        Principal principal = new UsernamePrincipal( info.getUsername() );\n\n        SimpleAuthorizationContext authContext = new SimpleAuthorizationContext( principal,\n                                                                                 info.getRoles(),\n                                                                                 info.getPermissions());\n\n        return authContext;\n    }\n\n\n    private Set<Permission> getPermissionsForRoles(Collection<? extends Serializable> roles) {\n        return new HashSet<Permission>();\n    }\n\n\n    protected String getUsername(AuthenticationToken token) {\n        return ((UsernamePasswordToken)token).getUsername();\n    }\n\n    private char[] getPassword(AuthenticationToken token) {\n        return ((UsernamePasswordToken)token).getPassword();\n    }\n\n\n\n}\n","lineNo":123}
{"Refactored Sample":"/*\n * Copyright (C) 2005 Jeremy C. Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.ri.authc.module.dao;\n\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.ExpiredCredentialException;\nimport org.jsecurity.authc.IncorrectCredentialException;\nimport org.jsecurity.authc.LockedAccountException;\nimport org.jsecurity.authc.UnknownAccountException;\nimport org.jsecurity.authc.UsernamePasswordToken;\nimport org.jsecurity.authc.module.AuthenticationModule;\nimport org.jsecurity.authz.AuthorizationContext;\nimport org.jsecurity.ri.authc.password.PasswordMatcher;\nimport org.jsecurity.ri.authc.password.PlainTextPasswordMatcher;\nimport org.jsecurity.ri.authz.SimpleAuthorizationContext;\nimport org.jsecurity.ri.util.StringPrincipal;\n\nimport java.io.Serializable;\nimport java.security.Permission;\nimport java.security.Principal;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * <p>Module that authenticates a user by delegating the lookup of\n * authentication and authorization information to an {@link AuthenticationDAO}.\n * Users of JSecurity can create their own DAO, or use one of the provided\n * DAO implementations.<\/p>\n *\n * <p>This module is intended to encapsulate the generic behavior of\n * authenticating a user from a username and password based on the\n * {@link AuthenticationInfo} retrieved from the {@link AuthenticationDAO}.<\/p>\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class DAOAuthenticationModule implements AuthenticationModule {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The DAO used to retrieve user authentication and authorization\n     * information from a data store.\n     */\n    private AuthenticationDAO authenticationDao;\n\n    /**\n     * Password matcher used to determine if the provided password matches\n     * the password stored in the data store.\n     */\n    private PasswordMatcher passwordMatcher = new PlainTextPasswordMatcher();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAuthenticationDao(AuthenticationDAO authenticationDao) {\n        this.authenticationDao = authenticationDao;\n    }\n\n    public void setPasswordMatcher(PasswordMatcher passwordMatcher) {\n        this.passwordMatcher = passwordMatcher;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    public boolean supports(Class tokenClass) {\n        return UsernamePasswordToken.class.isAssignableFrom( tokenClass );\n    }\n\n\n    public AuthorizationContext authenticate(AuthenticationToken token) throws AuthenticationException {\n\n        Principal accountIdentifier = getPrincipal( token );\n        Object credentials = getCredentials( token );\n\n        AuthenticationInfo info;\n        try {\n            info = authenticationDao.getAuthenticationInfo( accountIdentifier );\n        } catch (Exception e) {\n            throw new AuthenticationException(\n                \"Account [\" + accountIdentifier + \"] could not be authenticated because an error \" +\n                \"occurred during authentication.\", e );\n        }\n\n        if( info == null ) {\n            String msg = \"No account information found for account [\" + accountIdentifier + \"]\";\n            throw new UnknownAccountException( msg );\n        }\n\n        if( info.isAccountLocked() ) {\n            throw new LockedAccountException( \"Account [\" + accountIdentifier + \"] is locked.\" );\n        }\n\n        if( info.isCredentialsExpired() ) {\n            String msg = \"The credentials for account [\" + accountIdentifier + \"] are expired\";\n            throw new ExpiredCredentialException( msg );\n        }\n\n        if( !passwordMatcher.doPasswordsMatch( (char[])credentials, (char[])info.getCredentials() ) ) {\n            String msg = \"The credentials provided for account [\" +\n                         accountIdentifier + \"] did not match the expected credentials.\";\n            throw new IncorrectCredentialException( msg );\n        }\n\n        return buildAuthorizationContext( info );\n    }\n\n\n    protected AuthorizationContext buildAuthorizationContext(AuthenticationInfo info) {\n\n        return new SimpleAuthorizationContext( info.getPrincipal(),\n                                               info.getRoles(),\n                                               info.getPermissions());\n    }\n\n\n    private Set<Permission> getPermissionsForRoles(Collection<? extends Serializable> roles) {\n        return new HashSet<Permission>();\n    }\n\n\n    protected Principal getPrincipal(AuthenticationToken token) {\n        return new StringPrincipal( ((UsernamePasswordToken)token).getUsername() );\n    }\n\n    private Object getCredentials(AuthenticationToken token) {\n        return ((UsernamePasswordToken)token).getPassword();\n    }\n\n\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005 Jeremy C. Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.ri.authc.module.dao;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authc.module.AuthenticationModule;\nimport org.jsecurity.authz.AuthorizationContext;\nimport org.jsecurity.ri.authc.password.PasswordMatcher;\nimport org.jsecurity.ri.authc.password.PlainTextPasswordMatcher;\nimport org.jsecurity.ri.authz.SimpleAuthorizationContext;\nimport org.jsecurity.ri.authz.UsernamePrincipal;\n\nimport java.io.Serializable;\nimport java.security.Permission;\nimport java.security.Principal;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * <p>Module that authenticates a user by delegating the lookup of\n * authentication and authorization information to an {@link AuthenticationDAO}.\n * Users of JSecurity can create their own DAO, or use one of the provided\n * DAO implementations.<\/p>\n *\n * <p>This module is intended to encapsulate the generic behavior of\n * authenticating a user from a username and password based on the\n * {@link AuthenticationInfo} retrieved from the {@link AuthenticationDAO}.<\/p>\n *\n * @since 0.1\n * @author Jeremy Haile\n */\npublic class DAOAuthenticationModule implements AuthenticationModule {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The DAO used to retrieve user authentication and authorization\n     * information from a data store.\n     */\n    private AuthenticationDAO authenticationDao;\n\n    /**\n     * Password matcher used to determine if the provided password matches\n     * the password stored in the data store.\n     */\n    private PasswordMatcher passwordMatcher = new PlainTextPasswordMatcher();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAuthenticationDao(AuthenticationDAO authenticationDao) {\n        this.authenticationDao = authenticationDao;\n    }\n\n    public void setPasswordMatcher(PasswordMatcher passwordMatcher) {\n        this.passwordMatcher = passwordMatcher;\n    }\n\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n\n    public boolean supports(Class tokenClass) {\n        return UsernamePasswordToken.class.isAssignableFrom( tokenClass );\n    }\n\n\n    public AuthorizationContext authenticate(AuthenticationToken token) throws AuthenticationException {\n\n        String username = getUsername( token );\n        char[] password = getPassword( token );\n\n        AuthenticationInfo info = null;\n        try {\n            info = authenticationDao.getUserAuthenticationInfo( username );\n        } catch (Exception e) {\n            throw new AuthenticationException(\n                \"User [\" + username + \"] could not be authenticated because an error occurred \" +\n                \"during authentication.\", e );\n        }\n\n        if( info == null ) {\n            throw new UnknownAccountException( \"No account information found for username [\" + username + \"]\" );\n        }\n\n        if( info.isAccountLocked() ) {\n            throw new LockedAccountException( \"The account for user [\" + username + \"] is locked.\" );\n        }\n\n        if( info.isCredentialsExpired() ) {\n            throw new ExpiredCredentialException( \"The credentials for user [\" + username + \"] are expired.\" );\n        }\n\n        if( !passwordMatcher.doPasswordsMatch( password, info.getPassword() ) ) {\n            throw new IncorrectCredentialException( \"The password provided for user [\" + username + \"] was incorrect.\" );\n        }\n\n        return buildAuthorizationContext( info );\n    }\n\n\n    protected AuthorizationContext buildAuthorizationContext(AuthenticationInfo info) {\n\n        Principal principal = new UsernamePrincipal( info.getUsername() );\n\n        SimpleAuthorizationContext authContext = new SimpleAuthorizationContext( principal,\n                                                                                 info.getRoles(),\n                                                                                 info.getPermissions());\n\n        return authContext;\n    }\n\n\n    private Set<Permission> getPermissionsForRoles(Collection<? extends Serializable> roles) {\n        return new HashSet<Permission>();\n    }\n\n\n    protected String getUsername(AuthenticationToken token) {\n        return ((UsernamePasswordToken)token).getUsername();\n    }\n\n    private char[] getPassword(AuthenticationToken token) {\n        return ((UsernamePasswordToken)token).getPassword();\n    }\n\n\n\n}\n","lineNo":137}
{"Refactored Sample":"/*\n * Copyright (C) 2005 Les A. Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.authz;\n\nimport java.io.Serializable;\nimport java.security.Permission;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\nimport java.util.HashSet;\n\n/**\n * A InstancePermission represents an action or actions that might be performed on a single\n * identifiable instance or multiple instances of a particular object type.\n *\n * <p>The target of this Permission is an instance's <tt>identifier<\/tt>, or the\n * {@link #WILDCARD WILDCARD} constant.\n *\n * <p>An instance's <tt>identifier<\/tt> is obtained in a system-specific manner.  For example,\n * in most database-driven applications, this identifier is usally a primary key value that is\n * obtained from an instance's <tt>getId()<\/tt> (or similar) method.\n *\n * <p>The {@link #WILDCARD WILDCARD} constant represents <b>all<\/b> instances of a particular\n * object type, or if used in the actions field, <b>all<\/b> possible actions.\n *\n * <p>For example, the following instance:\n *\n * <pre>new com.domain.PrinterPermission( WILDCARD, \"print\" );<\/pre>\n *\n * means that any <tt>role<\/tt> assigned that permission would have\n * the ability to \"print\" documents to any printer available to a system.  Such a permission\n * could be assigned to all users in a system where printers are not considered\n * restricted resources.  Then any user may print to any printer they wish.\n *\n * <p>This instance:\n * <pre>new com.domain.UserPermission( aUser.getId(), \"read, write\" );<\/pre>\n *\n * means that any <tt>role<\/tt> assigned that permission would have\n * the ability to \"read\" (view) and \"write\" (change) the user account data for the user with the\n * system id <tt>aUser.getId()<\/tt>.  Such a permission would usually be associated with the user\n * account with the same Id, so the user could edit their own account information.\n *\n * <p>Finally, this instance:\n * <pre>new com.domain.UserPermission( WILDCARD, WILDCARD );<\/pre>\n *\n * means that the <tt>role<\/tt> assigned that permission would have the\n * ability to do anything (create, read, update, delete) <em>any<\/em> user account.  Such a\n * permission would generally be assigned to an administrative account.\n *\n * @since 1.0\n * @author Les Hazlewood\n */\npublic abstract class InstancePermission extends Permission implements Serializable, Cloneable {\n\n    /**\n     * Used to specify all instances of an object type when used in the {@link #getName() name/target}\n     * field or all permission actions when used in the {@link #getActions actions} field.\n     */\n    public static final String WILDCARD = \"*\";\n    public static final char WILDCARD_CHAR = '*';\n\n    /**\n     * Used to delimit mutli-value action strings.\n     */\n    public static final String ACTION_DELIMITER = \",\";\n    public static final char ACTION_DELIMITER_CHAR = ',';\n\n    /**\n     * Canonically ordered actions string for an instance of this class.\n     */\n    private String actions;\n\n    /**\n     * The actions of an instance of this class, which is a\n     * perfect subset of the <code>getPossibleActions<\/code> Set. It is constructed\n     * by this class during the setActions method\n     */\n    private Set<String> actionsSet;\n\n    /**\n     * Constructs an instance with <em>all<\/em> permissions (via the {@link #WILDCARD WILDCARD}\n     * constant).\n     * @param targetName\n     */\n    protected InstancePermission( String targetName ) {\n        this( targetName, WILDCARD );\n    }\n\n    /**\n     * Constructs a new InstancePermission associated with an entity instance with the given\n     * identifier with <em>all<\/em> permissions (via the {@link #WILDCARD WILDCARD}\n     * constant).\n     * @param identifier the instance identifier\n     */\n    protected InstancePermission( Serializable identifier ) {\n        this( identifier.toString() );\n    }\n\n    /**\n     * Creates a new InstancePermission bject with the specified target and\n     * instance-specific actions.\n     *\n     * <p>The actions\n     * String is a comma-delimited list of instance-specific actions.  That is,\n     * all actions specified must be a perfect subset of those in the\n     * {@link #getPossibleActions() possibleActions} Set.\n     *\n     * @param targetName - the logical name (unique identifier) of the permission's target instance\n     * @param actions - a comma-delimited string of actions understood\n     *        by this class.\n     * @throws UnknownPermissionActionException if an action in the\n     *         <code>actions<\/code> string is unknown to the class.\n     */\n    protected InstancePermission( String targetName, String actions ) {\n        super( targetName );\n        setActions(actions);\n    }\n\n    protected InstancePermission( Serializable identifier, String actions ) {\n        this( identifier.toString(), actions );\n    }\n\n    /**\n     * Sets the {@link #getActions() actions} for this instance.  Once set on this instance,\n     * either via this method or via a constructory, they cannot be set again or\n     * changed (Permissions are intended to be immutable).\n     * @param actions the actions to set for this instance\n     */\n    public void setActions( String actions ) {\n\n        if ( actions == null ) {\n            String msg = \"actions parameter cannot be null\";\n            throw new NullPointerException( msg );\n        }\n\n        if ( actions.contains( WILDCARD ) ) {\n            this.actions = WILDCARD;\n            this.actionsSet = new HashSet<String>(1);\n            this.actionsSet.add( WILDCARD );\n            return;\n        }\n\n        Set<String> possibleActions = getPossibleActions();\n        if ( possibleActions == null || possibleActions.size() <= 0 ) {\n            String msg = \"Subclass implementation '\" + getClass().getName() + \" did not \" +\n                         \"return a valid possibleActions Set from the getPossibleActions() \" +\n                         \"method.  A non-null and populated Set is required.\";\n            throw new IllegalStateException( msg );\n        }\n\n        LinkedHashSet<String> nonCanonicalActions = new LinkedHashSet<String>();\n\n        String[] actionsArray = actions.split(\"[,; ][ ]*\");\n\n        for( String s : actionsArray ) {\n            if ( !possibleActions.contains( s ) ) {\n                String msg = \"Action \\\"\" + s + \"\\\" is unknown to class [\" +\n                             getClass().getName() + \"]\";\n                throw new UnknownPermissionActionException( msg );\n            }\n            nonCanonicalActions.add( s );\n        }\n\n\n        //Now arrange them in canonical order, as required by the\n        //java.security.Permission class:\n        LinkedHashSet<String> canonicalActions = new LinkedHashSet<String>();\n        for( String s : possibleActions ) {\n            if ( nonCanonicalActions.contains( s ) ) {\n                canonicalActions.add( s );\n            }\n        }\n\n        //now, the actions string must be in the same order as well:\n        StringBuffer sb = new StringBuffer();\n        Iterator<String> i = canonicalActions.iterator();\n        while( i.hasNext() ) {\n            sb.append( i.next() );\n            if ( i.hasNext() ) {\n                sb.append( ACTION_DELIMITER_CHAR );\n            }\n        }\n        this.actions = sb.toString();\n\n        this.actionsSet = canonicalActions;\n    }\n\n\n    /**\n     * Returns the comma-delimited canonical string representation\n     * of this instance's declared actions.\n     * @return the canonical string representation of this instance's permission actions.\n     */\n    public String getActions() {\n        return this.actions;\n    }\n\n\n    /**\n     * Returns this permission's actions in <em>canonical order<\/em>\n     */\n    public Set<String> getActionsSet() {\n        return this.actionsSet;\n    }\n\n\n    /**\n     * Returns a \"canonically ordered\" Set of all actions that this permission\n     * class understands.  This set is used to verify instantiation of a new permission.\n     * That is, when a permission is being instantiated, the specified actions are verified to\n     * be a perfect subset of the values found in this Set.\n     *\n     * <p>Since this data never changes for any given InstancePermission subclass, the returned Set\n     * should be constructed via a static initializer that will be executed when the class\n     * is loaded by the class loader.  This ensures the data is only constructed once for\n     * <em>all<\/em> instances, increasing overall performance.\n     *\n     * <p>E.g.:\n     *\n     * <pre>public class MyPermission extends InstancePermission {\n    ...\n    private static final LinkedHashSet&lt;String&gt; possibleActions = initPossibleActionsSet();\n    ...\n    private static LinkedHashSet&lt;String&gt; initPossibleActionsSet() {\n        LinkedHashSet&lt;String&gt; possibleActions = new LinkedHashSet&lt;String&gt;();\n        //make sure the actions are added in canonical order:\n        possibleActions.add( \"action1\" );\n        possibleActions.add( \"action2\" );\n        ...\n        return possibleActions;\n    }\n    ...\n}<\/pre>\n     */\n    public abstract Set<String> getPossibleActions();\n\n\n    public boolean implies( Permission p ) {\n\n        boolean implies = false;\n\n        if ( p != null && (p instanceof InstancePermission ) ) {\n            InstancePermission ep = (InstancePermission)p;\n\n            String name = getName();\n            if ( name != null ) {\n                implies = name.equals( WILDCARD ) || name.equals( ep.getName() );\n            } else {\n                implies = (ep.getName() == null);\n            }\n\n            if ( implies ) {\n                if ( !getActions().equals( WILDCARD ) ) {\n                    implies = getActionsSet().containsAll( ep.getActionsSet() );\n                }\n            }\n        }\n\n        return implies;\n    }\n\n    /**\n     * Returns a string describing this Permission.  The convention is to\n     * specify the class name, the permission name, and the actions in\n     * the following format: '(\"ClassName\" \"name\" \"actions\")'.\n     *\n     * <b>N.B.<\/b> Subclasses should not override this method.  Instead, they should override the\n     * {@link #toStringBuffer()} implementation which is more efficient.\n     */\n    public String toString() {\n        return toStringBuffer().toString();\n    }\n\n    protected StringBuffer toStringBuffer() {\n        StringBuffer sb = new StringBuffer();\n        sb.append( \"(\\\"\" ).append( getClass().getName() ).append(\"\\\" \");\n        sb.append( \"\\\"\" ).append( getName() ).append(\"\\\" \");\n        sb.append( \"\\\"\" ).append( getActions() ).append( \"\\\")\" );\n        return sb;\n    }\n\n    public boolean equals( Object o ) {\n        if ( o == this ) {\n            return true;\n        }\n\n        if ( o instanceof InstancePermission ) {\n            InstancePermission ep = (InstancePermission)o;\n            return ( getClass().getName().equals( ep.getClass().getName() ) ) &&\n                   ( getName() != null ? getName().equals(ep.getName()) : ep.getName() == null ) &&\n                   ( this.actions != null ? this.actions.equals( ep.actions ) : ep.actions == null );\n        }\n\n        return false;\n    }\n\n    public int hashCode() {\n        int result = getClass().getName().hashCode();\n        result = 29 * result + ( getName() != null ? getName().hashCode() : 0 );\n        result = 29 * result + ( this.actions != null ? this.actions.hashCode() : 0 );\n        return result;\n    }\n\n    @Override\n    @SuppressWarnings({\"CloneDoesntDeclareCloneNotSupportedException\"})\n    public Object clone() {\n        InstancePermission ip;\n        try {\n            ip = (InstancePermission)super.clone();\n        } catch ( CloneNotSupportedException e ) {\n            String msg = \"Unable to clone InstancePermission of type [\" +\n                         getClass().getName() + \"].  Check implementation (this should never \" +\n                         \"happen).\";\n            throw new InternalError( msg );\n        }\n        ip.setActions( getActions() );\n        return ip;\n\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005 Les A. Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\npackage org.jsecurity.authz;\n\nimport java.io.Serializable;\nimport java.security.Permission;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\n/**\n * A InstancePermission represents an action or actions that might be performed on a single\n * identifiable instance or multiple instances of a particular object type.\n *\n * <p>The target of this Permission is an instance's <tt>identifier<\/tt>, or the\n * {@link #WILDCARD WILDCARD} constant.\n *\n * <p>An instance's <tt>identifier<\/tt> is obtained in a system-specific manner.  For example,\n * in most database-driven applications, this identifier is usally a primary key value that is\n * obtained from an instance's <tt>getId()<\/tt> (or similar) method.\n *\n * <p>The {@link #WILDCARD WILDCARD} constant represents <b>all<\/b> instances of a particular\n * object type, or if used in the actions field, <b>all<\/b> possible actions.\n *\n * <p>For example, the following instance:\n *\n * <pre>new com.domain.PrinterPermission( WILDCARD, \"print\" );<\/pre>\n *\n * means that any <tt>role<\/tt> assigned that permission would have\n * the ability to \"print\" documents to any printer available to a system.  Such a permission\n * could be assigned to all users in a system where printers are not considered\n * restricted resources.  Then any user may print to any printer they wish.\n *\n * <p>This instance:\n * <pre>new com.domain.UserPermission( aUser.getId(), \"read, write\" );<\/pre>\n *\n * means that any <tt>role<\/tt> assigned that permission would have\n * the ability to \"read\" (view) and \"write\" (change) the user account data for the user with the\n * system id <tt>aUser.getId()<\/tt>.  Such a permission would usually be associated with the user\n * account with the same Id, so the user could edit their own account information.\n *\n * <p>Finally, this instance:\n * <pre>new com.domain.UserPermission( WILDCARD, WILDCARD );<\/pre>\n *\n * means that the <tt>role<\/tt> assigned that permission would have the\n * ability to do anything (create, read, update, delete) <em>any<\/em> user account.  Such a\n * permission would generally be assigned to an administrative account.\n *\n * @since 1.0\n * @author Les Hazlewood\n */\npublic abstract class InstancePermission extends Permission implements Serializable, Cloneable {\n\n    /**\n     * Used to specify all instances of an object type when used in the {@link #getName() name/target}\n     * field or all permission actions when used in the {@link #getActions actions} field.\n     */\n    public static final String WILDCARD = \"*\";\n    public static final char WILDCARD_CHAR = '*';\n\n    /**\n     * Used to delimit mutli-value action strings.\n     */\n    public static final String ACTION_DELIMITER = \",\";\n    public static final char ACTION_DELIMITER_CHAR = ',';\n\n    /**\n     * Canonically ordered actions string for an instance of this class.\n     */\n    private String actions;\n\n    /**\n     * The actions of an instance of this class, which is a\n     * perfect subset of the <code>getPossibleActions<\/code> Set. It is constructed\n     * by this class during the setActions method\n     */\n    private Set<String> actionsSet;\n\n    protected InstancePermission( String name ) {\n        super( name );\n    }\n\n    /**\n     * Constructs a new InstancePermission associated with an entity instance with the given\n     * identifier.\n     * @param identifier the instance identifier\n     */\n    protected InstancePermission( Serializable identifier ) {\n        this( identifier.toString() );\n    }\n\n    /**\n     * Creates a new InstancePermission bject with the specified target and\n     * instance-specific actions.\n     *\n     * <p>The actions\n     * String is a comma-delimited list of instance-specific actions.  That is,\n     * all actions specified must be a perfect subset of those in the\n     * {@link #getPossibleActions() possibleActions} Set.\n     *\n     * @param name - the logical\n     * @param actions - a comma-delimited string of actions understood\n     *        by this class.\n     * @throws UnknownPermissionActionException if an action in the\n     *         <code>actions<\/code> string is unknown to the class.\n     */\n    protected InstancePermission( String name, String actions ) {\n        super( name );\n        setActions(actions);\n    }\n\n    protected InstancePermission( Serializable identifier, String actions ) {\n        super( identifier.toString() );\n        setActions( actions );\n    }\n\n    /**\n     * Sets the {@link #getActions() actions} for this instance.  Once set on this instance,\n     * either via this method or via a constructory, they cannot be set again or\n     * changed (Permissions are intended to be immutable).\n     * @param actions the actions to set for this instance\n     */\n    public void setActions( String actions ) {\n\n        if ( actions == null ) {\n            String msg = \"actions parameter cannot be null\";\n            throw new NullPointerException( msg );\n        }\n\n        if ( this.actions != null ) {\n            String msg = \"Actions have already been set for this permission instance.  \" +\n                         \"Permissions are immutable once constructed.\";\n            throw new IllegalArgumentException( msg );\n        }\n\n        Set<String> possibleActions = getPossibleActions();\n        if ( possibleActions == null || possibleActions.size() <= 0 ) {\n            String msg = \"Subclass implementation '\" + getClass().getName() + \" did not \" +\n                         \"return a valid possibleActions Set from the getPossibleActions() \" +\n                         \"method.  A non-null and populated Set is required.\";\n            throw new IllegalStateException( msg );\n        }\n\n        LinkedHashSet<String> nonCanonicalActions = new LinkedHashSet<String>();\n\n        String[] actionsArray = actions.split(\"[,; ][ ]*\");\n\n        for( String s : actionsArray ) {\n            if ( !possibleActions.contains( s ) ) {\n                String msg = \"Action \\\"\" + s + \"\\\" is unknown to class [\" +\n                             getClass().getName() + \"]\";\n                throw new UnknownPermissionActionException( msg );\n            }\n            nonCanonicalActions.add( s );\n        }\n\n\n        //Now arrange them in canonical order, as required by the\n        //java.security.Permission class:\n        LinkedHashSet<String> canonicalActions = new LinkedHashSet<String>();\n        for( String s : possibleActions ) {\n            if ( nonCanonicalActions.contains( s ) ) {\n                canonicalActions.add( s );\n            }\n        }\n\n        //now, the actions string must be in the same order as well:\n        StringBuffer sb = new StringBuffer();\n        Iterator<String> i = canonicalActions.iterator();\n        while( i.hasNext() ) {\n            sb.append( i.next() );\n            if ( i.hasNext() ) {\n                sb.append( ACTION_DELIMITER_CHAR );\n            }\n        }\n        this.actions = sb.toString();\n\n        this.actionsSet = canonicalActions;\n    }\n\n\n    /**\n     * Returns the comma-delimited canonical string representation\n     * of this instance's declared actions.\n     * @return the canonical string representation of this instance's permission actions.\n     */\n    public String getActions() {\n        return this.actions;\n    }\n\n\n    /**\n     * Returns this permission's actions in <em>canonical order<\/em>\n     */\n    public Set<String> getActionsSet() {\n        return this.actionsSet;\n    }\n\n\n    /**\n     * Returns a \"canonically ordered\" Set of all actions that this permission\n     * class understands.  This set is used to verify instantiation of a new permission.\n     * That is, when a permission is being instantiated, the specified actions are verified to\n     * be a perfect subset of the values found in this Set.\n     *\n     * <p>Since this data never changes for any given InstancePermission subclass, the returned Set\n     * should be constructed via a static initializer that will be executed when the class\n     * is loaded by the class loader.  This ensures the data is only constructed once for\n     * <em>all<\/em> instances, increasing overall performance.\n     *\n     * <p>E.g.:\n     *\n     * <pre>public class MyPermission extends InstancePermission {\n    ...\n    private static final LinkedHashSet&lt;String&gt; possibleActions = initPossibleActionsSet();\n    ...\n    private static LinkedHashSet&lt;String&gt; initPossibleActionsSet() {\n        LinkedHashSet&lt;String&gt; possibleActions = new LinkedHashSet&lt;String&gt;();\n        //make sure the actions are added in canonical order:\n        possibleActions.add( \"action1\" );\n        possibleActions.add( \"action2\" );\n        ...\n        return possibleActions;\n    }\n    ...\n}<\/pre>\n     */\n    public abstract Set<String> getPossibleActions();\n\n\n    public boolean implies( Permission p ) {\n\n        if ( p != null && (p instanceof InstancePermission ) ) {\n            InstancePermission ep = (InstancePermission)p;\n            return (getName() != null ? getName().equals( ep.getName() ) : ep.getName() == null) &&\n                   getActionsSet().containsAll( ep.getActionsSet() );\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns a string describing this Permission.  The convention is to\n     * specify the class name, the permission name, and the actions in\n     * the following format: '(\"ClassName\" \"name\" \"actions\")'.\n     *\n     * <b>N.B.<\/b> Subclasses should not override this method.  Instead, they should override the\n     * {@link #toStringBuffer()} implementation which is more efficient.\n     */\n    public String toString() {\n        return toStringBuffer().toString();\n    }\n\n    protected StringBuffer toStringBuffer() {\n        StringBuffer sb = new StringBuffer();\n        sb.append( \"(\\\"\" ).append( getClass().getName() ).append(\"\\\" \");\n        sb.append( \"\\\"\" ).append( getName() ).append(\"\\\" \");\n        sb.append( \"\\\"\" ).append( getActions() ).append( \"\\\")\" );\n        return sb;\n    }\n\n    public boolean equals( Object o ) {\n        if ( o == this ) {\n            return true;\n        }\n\n        if ( o instanceof InstancePermission ) {\n            InstancePermission ep = (InstancePermission)o;\n            return ( getClass().getName().equals( ep.getClass().getName() ) ) &&\n                   ( getName() != null ? getName().equals(ep.getName()) : ep.getName() == null ) &&\n                   ( this.actions != null ? this.actions.equals( ep.actions ) : ep.actions == null );\n        }\n\n        return false;\n    }\n\n    public int hashCode() {\n        int result = getClass().getName().hashCode();\n        result = 29 * result + ( getName() != null ? getName().hashCode() : 0 );\n        result = 29 * result + ( this.actions != null ? this.actions.hashCode() : 0 );\n        return result;\n    }\n\n    protected Object clone() throws CloneNotSupportedException {\n        InstancePermission ep = (InstancePermission)super.clone();\n        ep.setActions( getActions() );\n        return ep;\n    }\n}\n","lineNo":262}
{"Refactored Sample":"package org.jsecurity.web.support;\n\nimport org.jsecurity.web.WebSessionFactory;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.SessionFactory;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.JSecurityException;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpSession;\nimport javax.servlet.http.HttpServletResponse;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.io.Serializable;\nimport java.beans.PropertyEditor;\n\n/**\n * Default JSecurity Reference Implementation of the {@link WebSessionFactory} interface.\n *\n * @author Les Hazlewood\n */\npublic class DefaultWebSessionFactory implements WebSessionFactory {\n\n    protected transient final Log log = LogFactory.getLog( getClass() );\n\n    public static final String SESSION_ID_REQUEST_PARAM_NAME = \"sessionId\";\n\n    /**\n     * Session ID cookie will last a year by default.\n     * <p>\n     * This is ok, because the session expiration\n     * will handle stopping a user from logging in with an old session.  We dont want\n     * the cookie to expire before the session because then the user will have to log in again.\n     * This would only occur if the user was using applets/webstart applications that updated\n     * the session but not making web requests.  With an expiration time of one year, this\n     * should never realistically happen.\n     */\n    protected static final int SESSION_ID_COOKIE_MAX_AGE = 60*60*24*365;\n\n    SessionFactory sessionFactory;\n\n    private String sessionIdRequestParamName = SESSION_ID_REQUEST_PARAM_NAME; //default;\n    private String sessionIdCookieName = SESSION_ID_REQUEST_PARAM_NAME; //default;\n    private String sessionIdHttpSessionKeyName = Session.class.getName() + \"_HTTP_SESSION_KEY\";\n    private int sessionIdCookieMaxAge = SESSION_ID_COOKIE_MAX_AGE;\n\n    private Class<? extends PropertyEditor> sessionIdEditorClass = null;\n\n    private boolean validateSessionOrigin = false; //default\n\n    public DefaultWebSessionFactory(){}\n\n    public void setSessionFactory( SessionFactory sessionFactory ) {\n        this.sessionFactory = sessionFactory;\n    }\n\n    public String getSessionIdRequestParamName() {\n        return sessionIdRequestParamName;\n    }\n\n    public void setSessionIdRequestParamName( String sessionIdRequestParamName ) {\n        this.sessionIdRequestParamName = sessionIdRequestParamName;\n    }\n\n    public String getSessionIdCookieName() {\n        return sessionIdCookieName;\n    }\n\n    public void setSessionIdCookieName( String sessionIdCookieName ) {\n        this.sessionIdCookieName = sessionIdCookieName;\n    }\n\n    public int getSessionIdCookieMaxAge() {\n        return sessionIdCookieMaxAge;\n    }\n\n    public void setSessionIdCookieMaxAge( int sessionIdCookieMaxAge ) {\n        this.sessionIdCookieMaxAge = sessionIdCookieMaxAge;\n    }\n\n    public String getSessionIdHttpSessionKeyName() {\n        return sessionIdHttpSessionKeyName;\n    }\n\n    public void setSessionIdHttpSessionKeyName( String sessionIdHttpSessionKeyName ) {\n        this.sessionIdHttpSessionKeyName = sessionIdHttpSessionKeyName;\n    }\n\n    public Class<? extends PropertyEditor> getSessionIdEditorClass() {\n        return sessionIdEditorClass;\n    }\n\n    /**\n     * If set to <tt>true<\/tt>, this WebSessionFactory will ensure that any HttpRequest attempting\n     * to join a session (i.e. via {@link #getSession getSession} must have the same\n     * IP Address of the HttpRequest that started the session.\n     *\n     * <p> If set to <tt>false<\/tt>, any request with a reference to a valid session id may\n     * acquire that <tt>Session<\/tt>.\n     *\n     * <p>Although convenient, this should only be enabled in environments where the\n     * system can <em>guarantee<\/em> that each IP address represents one and only one\n     * machine accessing the system.\n     *\n     * <p>Public websites are not good candidates for enabling this\n     * feature since many browser clients often sit behind NAT routers (in\n     * which case many machines are viewed to come from the same IP, thereby making this\n     * validation check useless).  Also, some internet service providers (e.g. AOL) may change a\n     * client's IP in mid-session, making subsequent requests appear to come from a different\n     * location.  Again, this feature should only be enabled where IP Addresses can be guaranteed a\n     * 1-to-1 relationship with a user's session.\n     *\n     * <p>For the reasons specified above, this property is <tt>false<\/tt> by default.\n     *\n     * @return true if this factory will verify each HttpRequest joining a session\n     */\n    public boolean isValidateSessionOrigin() {\n        return validateSessionOrigin;\n    }\n\n    /**\n     *\n     *\n     * @param validateSessionOrigin whether or not to\n     */\n    public void setValidateSessionOrigin( boolean validateSessionOrigin ) {\n        this.validateSessionOrigin = validateSessionOrigin;\n    }\n\n    /**\n     * If set, an instance of this class will be used to convert a JSecurity\n     * {@link Serializable Serializable} sessionId to a string value (and vice versa) when\n     * reading and populating values in\n     * {@link HttpServletRequest HttpServletRequest}s, {@link Cookie Cookie}s or\n     * {@link HttpSession HttpSession}s.\n     * @param clazz {@link PropertyEditor PropertyEditor} implementation used to\n     * convert between string values and JSecurity sessionId objects.\n     */\n    public void setSessionIdEditorClass( Class<? extends PropertyEditor> clazz ) {\n        this.sessionIdEditorClass = clazz;\n    }\n\n    public void init() {\n        if ( this.sessionFactory == null ) {\n            String msg = \"sessionFactory property must be set\";\n            throw new IllegalStateException( msg );\n        }\n    }\n\n    protected InetAddress getInetAddress( HttpServletRequest request ) {\n        InetAddress clientAddress = null;\n        //get the Host/IP they're coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName( addrString );\n        } catch ( UnknownHostException e ) {\n            if ( log.isWarnEnabled() ) {\n                log.warn( \"Unable to acquire InetAddress from HttpServletRequest\", e );\n            }\n        }\n\n        return clientAddress;\n    }\n\n    public Session start( HttpServletRequest request ) {\n        InetAddress clientAddress = getInetAddress( request );\n        return sessionFactory.start( clientAddress );\n    }\n\n    public Session getSession( HttpServletRequest request )\n        throws InvalidSessionException, AuthorizationException {\n        Session session = null;\n        Serializable sessionId = getSessionId( request );\n        if ( sessionId != null ) {\n            session = sessionFactory.getSession( sessionId );\n            if ( isValidateSessionOrigin() ) {\n                validateSessionOrigin( request, session );\n            }\n        }\n        return session;\n    }\n\n    protected void validateSessionOrigin( HttpServletRequest request, Session session )\n        throws HostUnauthorizedException {\n        InetAddress requestIp = getInetAddress( request );\n        InetAddress originIp = session.getHostAddress();\n        Serializable sessionId = session.getSessionId();\n\n        if ( originIp == null ) {\n            if ( requestIp != null ) {\n                String msg = \"No IP Address was specified when creating session with id [\" +\n                             sessionId + \"].  Attempting to access session from \" +\n                             \"IP [\" + requestIp + \"].  Origin IP and request IP must match.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        } else {\n            if ( requestIp != null ) {\n                if ( !requestIp.equals( originIp ) ) {\n                    String msg = \"Session with id [\" + sessionId + \"] originated from [\" +\n                                 originIp + \"], but the current HttpServletRequest originated \" +\n                                 \"from [\" + requestIp + \"].  Disallowing session access - \" +\n                                 \"session origin and request origin must match to allow access.\";\n                    throw new HostUnauthorizedException( msg );\n                }\n\n            } else {\n                String msg = \"No IP Address associated with the current HttpServletRequest.  \" +\n                             \"Session with id [\" + sessionId + \"] originated from \" +\n                             \"[\" + originIp + \"].  Request IP must match the session's origin \" +\n                             \"IP in order to gain access to the session.\";\n                throw new HostUnauthorizedException( msg );\n            }\n        }\n    }\n\n    protected Serializable getSessionId( HttpServletRequest request ) {\n        Serializable sessionId = null;\n        String sessionIdString = getSessionIdFromRequestParam( request );\n        if ( sessionIdString == null ) {\n            sessionIdString = getSessionIdFromCookie( request );\n            if ( sessionIdString == null ) {\n                sessionIdString = getSessionIdFromHttpSession( request );\n                if ( log.isDebugEnabled() ) {\n                    log.debug( \"Unable to find JSecurity session id from request parameters, \" +\n                               \"cookies, or inside the HttpSession.  All heuristics exhausted. \" +\n                               \"Returning null session id\");\n                }\n            }\n        }\n\n        if ( sessionIdString != null ) {\n            sessionId = resolveSessionIdFromString( sessionIdString );\n        }\n\n        return sessionId;\n    }\n\n    protected String getSessionIdFromRequestParam( HttpServletRequest request ) {\n        String paramName = getSessionIdRequestParamName();\n        String param = request.getParameter( paramName );\n        if ( param != null ) {\n            if ( log.isInfoEnabled() ) {\n                log.info( \"Found JSecurity session id [\" + param + \"] from HttpServletRequest \" +\n                          \"parameter [\" + paramName + \"]\");\n            }\n        } else {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No JSecurity session id found in the HttpServletRequest from \" +\n                           \"request parameter named [\" + paramName + \"]\" );\n            }\n        }\n\n        return param;\n    }\n\n    /**\n     * Returns the cookie with the given name from the request or <tt>null<\/tt> if no cookie\n     * with that name could be found.\n     * @param request the current executing http request.\n     * @param cookieName the name of the cookie to find and return.\n     * @return the cookie with the given name from the request or <tt>null<\/tt> if no cookie\n     * with that name could be found.\n     */\n    private static Cookie getCookie(HttpServletRequest request, String cookieName) {\n        Cookie cookies[] = request.getCookies();\n        if (cookies != null) {\n            for( Cookie cookie : cookies ) {\n                if ( cookieName.equals( cookie.getName() ) ) {\n                    return cookie;\n                }\n            }\n        }\n        return null;\n    }\n\n    protected String getSessionIdFromCookie( HttpServletRequest request ) {\n        String sessionIdString = null;\n        String cookieName = getSessionIdCookieName();\n        Cookie cookie = getCookie( request, cookieName );\n        if ( cookie != null ) {\n            sessionIdString = cookie.getValue();\n            if ( log.isInfoEnabled() ) {\n                log.info( \"Found JSecurity session id [\" + sessionIdString + \"] from \" +\n                          \"HttpServletRequest Cookie [\" + cookieName + \"]\" );\n            }\n        } else {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No JSecurity session id found in request Cookies under \" +\n                           \"cookie name [\" + cookieName + \"]\" );\n            }\n        }\n\n        return sessionIdString;\n    }\n\n    protected void storeSessionIdInCookie( HttpServletResponse response, Serializable sessionId ) {\n        String cookieName = getSessionIdCookieName();\n        int maxAge = getSessionIdCookieMaxAge();\n\n        Cookie sessionIdCookie = new Cookie( cookieName, sessionId.toString() );\n\n        sessionIdCookie.setMaxAge( maxAge );\n\n        // We only want one cookie for the entire application, so set the path\n        // to be \"/\" - otherwise it will create one cookie for every directory the\n        // user navigates.\n        sessionIdCookie.setPath( \"/\" );\n\n        response.addCookie( sessionIdCookie );\n        if ( log.isDebugEnabled() ) {\n            log.debug( \"Added Cookie [\" + cookieName + \"] with value [\" + sessionId + \"] \" +\n                       \"to HttpServletResponse.\" );\n        }\n    }\n\n    protected String getSessionIdFromHttpSession( HttpServletRequest request ) {\n        String sessionIdString = null;\n        String sessionKey = getSessionIdHttpSessionKeyName();\n\n        HttpSession session = request.getSession( false );\n        if ( session != null ) {\n            sessionIdString = (String)session.getAttribute( sessionKey );\n        }\n\n        if ( sessionIdString != null ) {\n            if ( log.isInfoEnabled() ) {\n                log.info( \"Found JSecurity session id [\" + sessionIdString + \"] via \" +\n                          \"HttpSession key [\" + sessionKey + \"]\");\n            }\n        } else {\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"No JSecurity session id fround in HttpSession via \" +\n                           \"session key [\" + sessionKey + \"]\" );\n            }\n        }\n\n        return sessionIdString;\n    }\n\n    protected void storeSessionIdInHttpSession( HttpServletRequest request, Serializable sessionId ) {\n        String sessionKey = getSessionIdHttpSessionKeyName();\n\n        HttpSession session = request.getSession();\n        if ( session != null ) {\n            session.setAttribute( sessionKey, sessionId );\n            if ( log.isDebugEnabled() ) {\n                log.debug( \"Set HttpSession attribute [\" + sessionKey + \"] with value [\" +\n                           sessionId + \"]\" );\n            }\n        }\n    }\n\n    protected PropertyEditor newPropertyEditor( Class<? extends PropertyEditor> clazz ) {\n        try {\n            return clazz.newInstance();\n        } catch ( Exception e ) {\n            String msg = \"Unable to instantiate PropertyEditor of type [\" + clazz.getName() + \"].\";\n            throw new JSecurityException( msg, e );\n        }\n    }\n\n    /**\n     * If the {@link #getSessionIdEditorClass() sessionIdEditorClass} is set, it will be used\n     * to instantiate a new property editor and use that editor to convert the session id\n     * string value to a JSecurity session id.\n     * <p>If not set, the sessionId parameter (a String) will be returned.\n     * @param sessionId JSecurity session id string value to convert to the actual\n     * @return the Serializable representation of the sessionId string.\n     */\n    protected Serializable resolveSessionIdFromString( String sessionId ) {\n        Class<? extends PropertyEditor> peClass = getSessionIdEditorClass();\n        if ( peClass != null ) {\n            PropertyEditor pe = newPropertyEditor( peClass );\n            pe.setAsText( sessionId );\n            return (Serializable)pe.getValue();\n        }\n\n        return sessionId;\n    }\n\n\n}\n","Smelly Sample":"package org.jsecurity.web.support;\n\nimport org.jsecurity.web.WebSessionFactory;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.SessionFactory;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\n/**\n * Default JSecurity Reference Implementation of the {@link WebSessionFactory} interface.\n *\n * @author Les Hazlewood\n */\npublic class DefaultWebSessionFactory implements WebSessionFactory {\n\n    protected transient final Log log = LogFactory.getLog( getClass() );\n\n    SessionFactory sessionFactory;\n\n    public DefaultWebSessionFactory(){}\n\n    public void setSessionFactory( SessionFactory sessionFactory ) {\n        this.sessionFactory = sessionFactory;\n    }\n\n    public void init() {\n        if ( this.sessionFactory == null ) {\n            String msg = \"sessionFactory property must be set\";\n            throw new IllegalStateException( msg );\n        }\n    }\n\n    protected InetAddress getInetAddress( HttpServletRequest request ) {\n        InetAddress clientAddress = null;\n        //get the Host/IP they're coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName( addrString );\n        } catch ( UnknownHostException e ) {\n            if ( log.isWarnEnabled() ) {\n                log.warn( \"Unable to acquire InetAddress from HttpServletRequest, \" +\n                          \"using null for Session creation\", e );\n            }\n        }\n\n        return clientAddress;\n    }\n\n    public Session start( HttpServletRequest request ) {\n        InetAddress clientAddress = getInetAddress( request );\n        return sessionFactory.start( clientAddress );\n    }\n\n    public Session getSession( HttpServletRequest request ) {\n        //todo - implement\n        return null;  //To change body of implemented methods use File | Settings | File Templates.\n    }\n}\n","lineNo":177}
{"Refactored Sample":"/*\n * Copyright (C) 2005 Jeremy Haile, Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.context;\n\nimport org.jsecurity.authz.AuthorizationContext;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.SessionFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Authenticator;\nimport java.util.Properties;\n\n/**\n * <p>The <code>SecurityContext<\/code> is the programmatic entry point into the JSecurity API. This\n * class provides access to the core services of JSecurity, such as the {@link\n * org.jsecurity.session.SessionFactory}, {@link org.jsecurity.authc.Authenticator}, {@link\n * org.jsecurity.authz.Authorizer}, etc. as well as current context of the calling code, such as its\n * {@link org.jsecurity.session.Session} and {@link org.jsecurity.authz.AuthorizationContext}<\/p>\n * <p/>\n * <p>To gain access to a <code>SecurityContext<\/code> instance, the following code should be\n * executed:\n * <p/>\n * <blockquote><pre>SecurityContext context = SecurityContext.getInstance();<\/pre><\/blockquote>\n * The returned <code>SecurityContext<\/code> instance will be an implementation from the JSecurity\n * implementation.  The <code>SecurityContext<\/code> is obtained using a {@link\n * SecurityContextFactory} that is implemented by the JSecurity implementation provider.<\/p>\n * <p/>\n * <p>The algorithm used in retrieving a <code>SecurityContext<\/code> using a {@link\n * SecurityContextFactory} is described in detail in the {@link #getContext(ClassLoader)}\n * JavaDoc.<\/p>\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @see SecurityContextFactory\n * @since 0.1\n */\npublic abstract class SecurityContext {\n\n    /*--------------------------------------------\n     |             C O N S T A N T S             |\n     ============================================*/\n    /**\n     * Name of the system property or file property that determines the class name of the {@link\n     * SecurityContextFactory} implementation class to use.\n     */\n    private static final String SECURITY_CONTEXT_FACTORY_PROP = \"security.context.factory.class\";\n\n    /**\n     * Name of the JSecurity properties file to be loaded.  This file should contain properties\n     * telling JSecurity how to create a security context.\n     */\n    private static final String JSECURITY_PROPS_FILE = \"jsecurity.properties\";\n\n    private static boolean factoryCached = true;\n\n    /** Will always be <tt>null<\/tt> if caching is turned off (i.e. factoryCached == false); */\n    private static SecurityContextFactory factory = null;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    /*--------------------------------------------\n     |        S T A T I C   M E T H O D S        |\n     ============================================*/\n\n    /**\n     * Returns whether or not the same <tt>SecurityContextFactory<\/tt> will be used each time {@link\n     * #getContext()} is called.\n     * <p/>\n     * <p>The system default is <tt>true<\/tt>.\n     * <p/>\n     * <p>Note: this does <em>not<\/em> determine whether or not each call to {@link #getContext()}\n     * returns a cached <tt>SecurityContext<\/tt> each time.  That is determined by the Factory\n     * implementation.\n     *\n     * @return whether or not the same <tt>SecurityContextFactory<\/tt> will be used each time {@link\n     *         #getContext()} is called.\n     */\n    public static boolean isFactoryCached() {\n        return factoryCached;\n    }\n\n    /**\n     * Sets whether or not the same <tt>SecurityContextFactory<\/tt> will be used each time {@link\n     * #getContext()} is called. <p>The system default is <tt>true<\/tt>.\n     * <p/>\n     * <p>Note: this does <em>not<\/em> determine whether or not each call to {@link #getContext()}\n     * returns a cached <tt>SecurityContext<\/tt> each time.  That is determined by the Factory\n     * implementation.\n     *\n     * @param cached whether or not to cache the factory instance.\n     */\n    public static void setFactoryCached( boolean cached ) {\n        factoryCached = cached;\n    }\n\n\n    /**\n     * Retrieves a {@link SecurityContext} instance based on a JSecurity implementation's\n     * <tt>SecurityContextFactory<\/tt>.\n     *\n     * @return the current SecurityContext.\n     */\n    public static SecurityContext getContext() {\n\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if ( cl == null ) {\n            cl = SecurityContext.class.getClassLoader();\n        }\n        return getContext( cl );\n    }\n\n    private static SecurityContext getContext( ClassLoader cl ) {\n\n        SecurityContext context = null;\n\n        if ( isFactoryCached() ) {\n            if ( factory != null ) {\n                context = factory.getContext( cl );\n            }\n        } else {\n            String factoryClassName = getFactoryClassName( cl );\n            SecurityContextFactory factory = getFactory( factoryClassName, cl );\n            context = factory.getContext( cl );\n        }\n\n        if ( context == null ) {\n            throw new SecurityContextException( \"SecurityContext returned by factory was null.\" );\n        }\n\n        return context;\n    }\n\n    private static String getFactoryClassName( ClassLoader cl ) {\n        String factoryClassName = System.getProperty( SECURITY_CONTEXT_FACTORY_PROP );\n\n        if ( factoryClassName == null ) {\n\n            InputStream propsFileIs = cl.getResourceAsStream( JSECURITY_PROPS_FILE );\n            Properties props = new Properties();\n            try {\n                props.load( propsFileIs );\n            } catch ( IOException e ) {\n                String msg = \"No [\" + SECURITY_CONTEXT_FACTORY_PROP + \"] system property \" +\n                             \"is defined and [\" + JSECURITY_PROPS_FILE + \"] cannot be \" +\n                             \"loaded from the classloader.  A SecurityContextFactory cannot \" +\n                             \"be created.\";\n                throw new SecurityContextException( msg );\n            }\n\n            factoryClassName = props.getProperty( SECURITY_CONTEXT_FACTORY_PROP );\n\n        }\n\n        if ( factoryClassName == null || factoryClassName.length() == 0 ) {\n            String msg = \"No [\" + SecurityContextFactory.class.getName() + \"] implementation \" +\n                         \"class was found configured in the system.  The factory \" +\n                         \"implementation should normally be specified by including the \" +\n                         \"JSecurity implementation JAR in the classpath.  The factory can \" +\n                         \"also be specified by setting the [\" + SECURITY_CONTEXT_FACTORY_PROP +\n                         \"] system property or manually including a jsecurity.properties file \" +\n                         \"at the root of the classpath.\";\n            throw new SecurityContextException( msg );\n        }\n\n        return factoryClassName;\n\n    }\n\n\n    /**\n     * Obtains a {@link SecurityContextFactory} instance of the specified factory class name,\n     * loading any necessary classes using the given class loader.\n     *\n     * @param factoryClassName the class name of the factory implementation that should be\n     *                         obtained.\n     * @param cl               the class loader to use if any classes must be loaded.\n     *\n     * @return a {@link SecurityContextFactory} implementation of the specified type.\n     */\n    private static SecurityContextFactory getFactory( String factoryClassName, ClassLoader cl ) {\n        if ( isFactoryCached() ) {\n            if ( factory == null ) {\n                factory = instantiateFactory( factoryClassName, cl );\n            }\n            return factory;\n        } else {\n            return instantiateFactory( factoryClassName, cl );\n        }\n    }\n\n    private static SecurityContextFactory instantiateFactory( String factoryClassName,\n                                                              ClassLoader cl ) {\n        SecurityContextFactory factory;\n        try {\n\n            Class factoryClass = cl.loadClass( factoryClassName );\n            factory = (SecurityContextFactory)factoryClass.newInstance();\n\n        } catch ( ClassNotFoundException e ) {\n            String msg = \"Factory class [\" + factoryClassName + \"] could not be found.  No \" +\n                         \"SecurityContext can be loaded.\";\n            throw new SecurityContextException( msg, e );\n        } catch ( IllegalAccessException e ) {\n            String msg = \"Factory class [\" + factoryClassName + \"] constructor could not be \" +\n                         \"accessed.  SecurityContext cannot be loaded.\";\n            throw new SecurityContextException( msg, e );\n        } catch ( InstantiationException e ) {\n            String msg = \"Factory class [\" + factoryClassName + \"] could not be instantiated.  \" +\n                         \"SecurityContext cannot be loaded.\";\n            throw new SecurityContextException( msg, e );\n        }\n\n        return factory;\n    }\n\n    /*--------------------------------------------\n    |     A B S T R A C T   M E T H O D S       |\n    ============================================*/\n    public abstract SessionFactory getSessionFactory();\n\n    public abstract Authenticator getAuthenticator();\n\n    public abstract Authorizer getAuthorizer();\n\n    public abstract Session getCurrentSession();\n\n    public abstract AuthorizationContext getCurrentAuthContext();\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.context;\n\nimport org.jsecurity.authz.AuthorizationContext;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.SessionFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Authenticator;\nimport java.util.Properties;\n\n/**\n * <p>The <code>SecurityContext<\/code> is the programmatic entry point into the JSecurity API.\n * This class provides access to the core services of JSecurity, such as the\n * {@link org.jsecurity.session.SessionFactory}, {@link org.jsecurity.authc.Authenticator},\n * {@link org.jsecurity.authz.Authorizer}, etc. as well as current context of the calling code,\n * such as its {@link org.jsecurity.session.Session} and {@link org.jsecurity.authz.AuthorizationContext}\n * <\/p>\n *\n * <p>To gain access to a <code>SecurityContext<\/code> instance, the following code should be executed:\n * <blockquote><pre>SecurityContext context = SecurityContext.getInstance();<\/pre><\/blockquote>\n * The returned <code>SecurityContext<\/code> instance will be an implementation from the\n * JSecurity implementation.  The <code>SecurityContext<\/code> is obtained using a\n * {@link SecurityContextFactory} that is implemented by the JSecurity implementation provider.<\/p>\n *\n * <p>The algorithm used in retrieving a <code>SecurityContext<\/code> using a {@link SecurityContextFactory}\n * is described in detail in the {@link #getContext(ClassLoader)} JavaDoc.<\/p>\n *\n * @see SecurityContextFactory\n *\n * @author Jeremy Haile\n * @since 0.1\n */\npublic abstract class SecurityContext {\n\n    /*--------------------------------------------\n     |             C O N S T A N T S             |\n     ============================================*/\n    /**\n     * Name of the system property or file property that determines the class name of the\n     * {@link SecurityContextFactory} implementation class to use.\n     */\n    private static final String SECURITY_CONTEXT_FACTORY_PROP = \"security.context.factory.class\";\n\n    /**\n     * Name of the JSecurity properties file to be loaded.  This file should contain properties\n     * telling JSecurity how to create a security context.\n     */\n    private static final String JSECURITY_PROPS_FILE = \"jsecurity.properties\";\n\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    /*--------------------------------------------\n     |        S T A T I C   M E T H O D S        |\n     ============================================*/\n\n\n    /**\n     * Retrieves a {@link SecurityContext} instance by invoking {@link #getContext(ClassLoader)}\n     * with the thread context class loader.\n     * @return the current SecurityContext.\n     */\n    public static SecurityContext getContext() {\n        return getContext( Thread.currentThread().getContextClassLoader() );\n    }\n\n\n    private static SecurityContext getContext(ClassLoader cl) {\n        String factoryClassName = System.getProperty( SECURITY_CONTEXT_FACTORY_PROP );\n\n        if( factoryClassName == null ) {\n\n            InputStream propsFileIs = cl.getResourceAsStream( JSECURITY_PROPS_FILE );\n            Properties props = new Properties();\n            try {\n                props.load( propsFileIs );\n            } catch (IOException e) {\n                throw new SecurityContextException( \"No [\" + SECURITY_CONTEXT_FACTORY_PROP + \"] system property \" +\n                                                    \"is defined and [\" + JSECURITY_PROPS_FILE + \"] cannot be \" +\n                                                    \"loaded from the classloader, so the SecurityContextFactory cannot \" +\n                                                    \"be created.\" );\n            }\n\n            factoryClassName = props.getProperty( SECURITY_CONTEXT_FACTORY_PROP );\n\n        }\n\n        if( factoryClassName == null || factoryClassName.length() == 0 ) {\n            throw new SecurityContextException( \"No [\" + SecurityContextFactory.class.getName() + \"] implementation \" +\n                \"class was found configured in the system.  The factory implementation should normally be specified \" +\n                \"by including the JSecurity implementation JAR in the classpath.  The factory can also be specified \" +\n                \"by setting the [\" + SECURITY_CONTEXT_FACTORY_PROP + \"] system property.\");\n        }\n\n        SecurityContextFactory factory = getSecurityContextFactory( factoryClassName, cl );\n\n        SecurityContext context = factory.getContext( cl );\n\n        if( context == null ) {\n            throw new SecurityContextException( \"SecurityContext returned by factory was null.\" );\n        }\n\n        return context;\n\n    }\n\n\n    /**\n     * Obtains a {@link SecurityContextFactory} instance of the specified factory class name,\n     * loading any necessary classes using the given class loader.\n     *\n     * todo Should we cache the factory?\n     *\n     * @param factoryClassName the class name of the factory implementation that should be obtained.\n     * @param cl the class loader to use if any classes must be loaded.\n     * @return a {@link SecurityContextFactory} implementation of the specified type.\n     */\n    private static SecurityContextFactory getSecurityContextFactory( String factoryClassName, ClassLoader cl ) {\n\n        SecurityContextFactory factory = null;\n        try {\n\n            Class factoryClass = cl.loadClass( factoryClassName );\n            factory = (SecurityContextFactory) factoryClass.newInstance();\n\n        } catch (ClassNotFoundException e) {\n            throw new SecurityContextException( \"Factory class [\" + factoryClassName + \"] could not be \" +\n                                                \"found so SecurityContext could not be loaded.\", e);\n        } catch (IllegalAccessException e) {\n            throw new SecurityContextException( \"Factory class [\" + factoryClassName + \"] constructor could \" +\n                                                \"not be accessed.\", e);\n\n        } catch (InstantiationException e) {\n            throw new SecurityContextException( \"New instance of factory class [\" + factoryClassName + \"] \" +\n                                                \"could not be instantiated.\", e);\n        }\n\n        return factory;\n    }\n\n    /*--------------------------------------------\n     |     A B S T R A C T   M E T H O D S       |\n     ============================================*/\n    public abstract SessionFactory getSessionFactory();\n\n    public abstract Authenticator getAuthenticator();\n\n    public abstract Authorizer getAuthorizer();\n\n    public abstract Session getCurrentSession();\n\n    public abstract AuthorizationContext getCurrentAuthContext();\n}\n","lineNo":178}
{"Refactored Sample":"/*\n * Copyright (C) 2005 Jeremy Haile, Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.context;\n\nimport org.jsecurity.authz.AuthorizationContext;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.SessionFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Authenticator;\nimport java.util.Properties;\n\n/**\n * <p>The <code>SecurityContext<\/code> is the programmatic entry point into the JSecurity API. This\n * class provides access to the core services of JSecurity, such as the {@link\n * org.jsecurity.session.SessionFactory}, {@link org.jsecurity.authc.Authenticator}, {@link\n * org.jsecurity.authz.Authorizer}, etc. as well as current context of the calling code, such as its\n * {@link org.jsecurity.session.Session} and {@link org.jsecurity.authz.AuthorizationContext}<\/p>\n * <p/>\n * <p>To gain access to a <code>SecurityContext<\/code> instance, the following code should be\n * executed:\n * <p/>\n * <blockquote><pre>SecurityContext context = SecurityContext.getInstance();<\/pre><\/blockquote>\n * The returned <code>SecurityContext<\/code> instance will be an implementation from the JSecurity\n * implementation.  The <code>SecurityContext<\/code> is obtained using a {@link\n * SecurityContextFactory} that is implemented by the JSecurity implementation provider.<\/p>\n * <p/>\n * <p>The algorithm used in retrieving a <code>SecurityContext<\/code> using a {@link\n * SecurityContextFactory} is described in detail in the {@link #getContext(ClassLoader)}\n * JavaDoc.<\/p>\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @see SecurityContextFactory\n * @since 0.1\n */\npublic abstract class SecurityContext {\n\n    /*--------------------------------------------\n     |             C O N S T A N T S             |\n     ============================================*/\n    /**\n     * Name of the system property or file property that determines the class name of the {@link\n     * SecurityContextFactory} implementation class to use.\n     */\n    private static final String SECURITY_CONTEXT_FACTORY_PROP = \"security.context.factory.class\";\n\n    /**\n     * Name of the JSecurity properties file to be loaded.  This file should contain properties\n     * telling JSecurity how to create a security context.\n     */\n    private static final String JSECURITY_PROPS_FILE = \"jsecurity.properties\";\n\n    private static boolean factoryCached = true;\n\n    /** Will always be <tt>null<\/tt> if caching is turned off (i.e. factoryCached == false); */\n    private static SecurityContextFactory factory = null;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    /*--------------------------------------------\n     |        S T A T I C   M E T H O D S        |\n     ============================================*/\n\n    /**\n     * Returns whether or not the same <tt>SecurityContextFactory<\/tt> will be used each time {@link\n     * #getContext()} is called.\n     * <p/>\n     * <p>The system default is <tt>true<\/tt>.\n     * <p/>\n     * <p>Note: this does <em>not<\/em> determine whether or not each call to {@link #getContext()}\n     * returns a cached <tt>SecurityContext<\/tt> each time.  That is determined by the Factory\n     * implementation.\n     *\n     * @return whether or not the same <tt>SecurityContextFactory<\/tt> will be used each time {@link\n     *         #getContext()} is called.\n     */\n    public static boolean isFactoryCached() {\n        return factoryCached;\n    }\n\n    /**\n     * Sets whether or not the same <tt>SecurityContextFactory<\/tt> will be used each time {@link\n     * #getContext()} is called. <p>The system default is <tt>true<\/tt>.\n     * <p/>\n     * <p>Note: this does <em>not<\/em> determine whether or not each call to {@link #getContext()}\n     * returns a cached <tt>SecurityContext<\/tt> each time.  That is determined by the Factory\n     * implementation.\n     *\n     * @param cached whether or not to cache the factory instance.\n     */\n    public static void setFactoryCached( boolean cached ) {\n        factoryCached = cached;\n    }\n\n\n    /**\n     * Retrieves a {@link SecurityContext} instance based on a JSecurity implementation's\n     * <tt>SecurityContextFactory<\/tt>.\n     *\n     * @return the current SecurityContext.\n     */\n    public static SecurityContext getContext() {\n\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if ( cl == null ) {\n            cl = SecurityContext.class.getClassLoader();\n        }\n        return getContext( cl );\n    }\n\n    private static SecurityContext getContext( ClassLoader cl ) {\n\n        SecurityContext context = null;\n\n        if ( isFactoryCached() ) {\n            if ( factory != null ) {\n                context = factory.getContext( cl );\n            }\n        } else {\n            String factoryClassName = getFactoryClassName( cl );\n            SecurityContextFactory factory = getFactory( factoryClassName, cl );\n            context = factory.getContext( cl );\n        }\n\n        if ( context == null ) {\n            throw new SecurityContextException( \"SecurityContext returned by factory was null.\" );\n        }\n\n        return context;\n    }\n\n    private static String getFactoryClassName( ClassLoader cl ) {\n        String factoryClassName = System.getProperty( SECURITY_CONTEXT_FACTORY_PROP );\n\n        if ( factoryClassName == null ) {\n\n            InputStream propsFileIs = cl.getResourceAsStream( JSECURITY_PROPS_FILE );\n            Properties props = new Properties();\n            try {\n                props.load( propsFileIs );\n            } catch ( IOException e ) {\n                String msg = \"No [\" + SECURITY_CONTEXT_FACTORY_PROP + \"] system property \" +\n                             \"is defined and [\" + JSECURITY_PROPS_FILE + \"] cannot be \" +\n                             \"loaded from the classloader.  A SecurityContextFactory cannot \" +\n                             \"be created.\";\n                throw new SecurityContextException( msg );\n            }\n\n            factoryClassName = props.getProperty( SECURITY_CONTEXT_FACTORY_PROP );\n\n        }\n\n        if ( factoryClassName == null || factoryClassName.length() == 0 ) {\n            String msg = \"No [\" + SecurityContextFactory.class.getName() + \"] implementation \" +\n                         \"class was found configured in the system.  The factory \" +\n                         \"implementation should normally be specified by including the \" +\n                         \"JSecurity implementation JAR in the classpath.  The factory can \" +\n                         \"also be specified by setting the [\" + SECURITY_CONTEXT_FACTORY_PROP +\n                         \"] system property or manually including a jsecurity.properties file \" +\n                         \"at the root of the classpath.\";\n            throw new SecurityContextException( msg );\n        }\n\n        return factoryClassName;\n\n    }\n\n\n    /**\n     * Obtains a {@link SecurityContextFactory} instance of the specified factory class name,\n     * loading any necessary classes using the given class loader.\n     *\n     * @param factoryClassName the class name of the factory implementation that should be\n     *                         obtained.\n     * @param cl               the class loader to use if any classes must be loaded.\n     *\n     * @return a {@link SecurityContextFactory} implementation of the specified type.\n     */\n    private static SecurityContextFactory getFactory( String factoryClassName, ClassLoader cl ) {\n        if ( isFactoryCached() ) {\n            if ( factory == null ) {\n                factory = instantiateFactory( factoryClassName, cl );\n            }\n            return factory;\n        } else {\n            return instantiateFactory( factoryClassName, cl );\n        }\n    }\n\n    private static SecurityContextFactory instantiateFactory( String factoryClassName,\n                                                              ClassLoader cl ) {\n        SecurityContextFactory factory;\n        try {\n\n            Class factoryClass = cl.loadClass( factoryClassName );\n            factory = (SecurityContextFactory)factoryClass.newInstance();\n\n        } catch ( ClassNotFoundException e ) {\n            String msg = \"Factory class [\" + factoryClassName + \"] could not be found.  No \" +\n                         \"SecurityContext can be loaded.\";\n            throw new SecurityContextException( msg, e );\n        } catch ( IllegalAccessException e ) {\n            String msg = \"Factory class [\" + factoryClassName + \"] constructor could not be \" +\n                         \"accessed.  SecurityContext cannot be loaded.\";\n            throw new SecurityContextException( msg, e );\n        } catch ( InstantiationException e ) {\n            String msg = \"Factory class [\" + factoryClassName + \"] could not be instantiated.  \" +\n                         \"SecurityContext cannot be loaded.\";\n            throw new SecurityContextException( msg, e );\n        }\n\n        return factory;\n    }\n\n    /*--------------------------------------------\n    |     A B S T R A C T   M E T H O D S       |\n    ============================================*/\n    public abstract SessionFactory getSessionFactory();\n\n    public abstract Authenticator getAuthenticator();\n\n    public abstract Authorizer getAuthorizer();\n\n    public abstract Session getCurrentSession();\n\n    public abstract AuthorizationContext getCurrentAuthContext();\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.context;\n\nimport org.jsecurity.authz.AuthorizationContext;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.SessionFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Authenticator;\nimport java.util.Properties;\n\n/**\n * <p>The <code>SecurityContext<\/code> is the programmatic entry point into the JSecurity API.\n * This class provides access to the core services of JSecurity, such as the\n * {@link org.jsecurity.session.SessionFactory}, {@link org.jsecurity.authc.Authenticator},\n * {@link org.jsecurity.authz.Authorizer}, etc. as well as current context of the calling code,\n * such as its {@link org.jsecurity.session.Session} and {@link org.jsecurity.authz.AuthorizationContext}\n * <\/p>\n *\n * <p>To gain access to a <code>SecurityContext<\/code> instance, the following code should be executed:\n * <blockquote><pre>SecurityContext context = SecurityContext.getInstance();<\/pre><\/blockquote>\n * The returned <code>SecurityContext<\/code> instance will be an implementation from the\n * JSecurity implementation.  The <code>SecurityContext<\/code> is obtained using a\n * {@link SecurityContextFactory} that is implemented by the JSecurity implementation provider.<\/p>\n *\n * <p>The algorithm used in retrieving a <code>SecurityContext<\/code> using a {@link SecurityContextFactory}\n * is described in detail in the {@link #getContext(ClassLoader)} JavaDoc.<\/p>\n *\n * @see SecurityContextFactory\n *\n * @author Jeremy Haile\n * @since 0.1\n */\npublic abstract class SecurityContext {\n\n    /*--------------------------------------------\n     |             C O N S T A N T S             |\n     ============================================*/\n    /**\n     * Name of the system property or file property that determines the class name of the\n     * {@link SecurityContextFactory} implementation class to use.\n     */\n    private static final String SECURITY_CONTEXT_FACTORY_PROP = \"security.context.factory.class\";\n\n    /**\n     * Name of the JSecurity properties file to be loaded.  This file should contain properties\n     * telling JSecurity how to create a security context.\n     */\n    private static final String JSECURITY_PROPS_FILE = \"jsecurity.properties\";\n\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    /*--------------------------------------------\n     |        S T A T I C   M E T H O D S        |\n     ============================================*/\n\n\n    /**\n     * Retrieves a {@link SecurityContext} instance by invoking {@link #getContext(ClassLoader)}\n     * with the thread context class loader.\n     * @return the current SecurityContext.\n     */\n    public static SecurityContext getContext() {\n        return getContext( Thread.currentThread().getContextClassLoader() );\n    }\n\n\n    private static SecurityContext getContext(ClassLoader cl) {\n        String factoryClassName = System.getProperty( SECURITY_CONTEXT_FACTORY_PROP );\n\n        if( factoryClassName == null ) {\n\n            InputStream propsFileIs = cl.getResourceAsStream( JSECURITY_PROPS_FILE );\n            Properties props = new Properties();\n            try {\n                props.load( propsFileIs );\n            } catch (IOException e) {\n                throw new SecurityContextException( \"No [\" + SECURITY_CONTEXT_FACTORY_PROP + \"] system property \" +\n                                                    \"is defined and [\" + JSECURITY_PROPS_FILE + \"] cannot be \" +\n                                                    \"loaded from the classloader, so the SecurityContextFactory cannot \" +\n                                                    \"be created.\" );\n            }\n\n            factoryClassName = props.getProperty( SECURITY_CONTEXT_FACTORY_PROP );\n\n        }\n\n        if( factoryClassName == null || factoryClassName.length() == 0 ) {\n            throw new SecurityContextException( \"No [\" + SecurityContextFactory.class.getName() + \"] implementation \" +\n                \"class was found configured in the system.  The factory implementation should normally be specified \" +\n                \"by including the JSecurity implementation JAR in the classpath.  The factory can also be specified \" +\n                \"by setting the [\" + SECURITY_CONTEXT_FACTORY_PROP + \"] system property.\");\n        }\n\n        SecurityContextFactory factory = getSecurityContextFactory( factoryClassName, cl );\n\n        SecurityContext context = factory.getContext( cl );\n\n        if( context == null ) {\n            throw new SecurityContextException( \"SecurityContext returned by factory was null.\" );\n        }\n\n        return context;\n\n    }\n\n\n    /**\n     * Obtains a {@link SecurityContextFactory} instance of the specified factory class name,\n     * loading any necessary classes using the given class loader.\n     *\n     * todo Should we cache the factory?\n     *\n     * @param factoryClassName the class name of the factory implementation that should be obtained.\n     * @param cl the class loader to use if any classes must be loaded.\n     * @return a {@link SecurityContextFactory} implementation of the specified type.\n     */\n    private static SecurityContextFactory getSecurityContextFactory( String factoryClassName, ClassLoader cl ) {\n\n        SecurityContextFactory factory = null;\n        try {\n\n            Class factoryClass = cl.loadClass( factoryClassName );\n            factory = (SecurityContextFactory) factoryClass.newInstance();\n\n        } catch (ClassNotFoundException e) {\n            throw new SecurityContextException( \"Factory class [\" + factoryClassName + \"] could not be \" +\n                                                \"found so SecurityContext could not be loaded.\", e);\n        } catch (IllegalAccessException e) {\n            throw new SecurityContextException( \"Factory class [\" + factoryClassName + \"] constructor could \" +\n                                                \"not be accessed.\", e);\n\n        } catch (InstantiationException e) {\n            throw new SecurityContextException( \"New instance of factory class [\" + factoryClassName + \"] \" +\n                                                \"could not be instantiated.\", e);\n        }\n\n        return factory;\n    }\n\n    /*--------------------------------------------\n     |     A B S T R A C T   M E T H O D S       |\n     ============================================*/\n    public abstract SessionFactory getSessionFactory();\n\n    public abstract Authenticator getAuthenticator();\n\n    public abstract Authorizer getAuthorizer();\n\n    public abstract Session getCurrentSession();\n\n    public abstract AuthorizationContext getCurrentAuthContext();\n}\n","lineNo":190}
{"Refactored Sample":"/*\n * Copyright (C) 2005 Jeremy Haile, Les Hazlewood\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.context;\n\nimport org.jsecurity.authz.AuthorizationContext;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.SessionFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Authenticator;\nimport java.util.Properties;\n\n/**\n * <p>The <code>SecurityContext<\/code> is the programmatic entry point into the JSecurity API. This\n * class provides access to the core services of JSecurity, such as the {@link\n * org.jsecurity.session.SessionFactory}, {@link org.jsecurity.authc.Authenticator}, {@link\n * org.jsecurity.authz.Authorizer}, etc. as well as current context of the calling code, such as its\n * {@link org.jsecurity.session.Session} and {@link org.jsecurity.authz.AuthorizationContext}<\/p>\n * <p/>\n * <p>To gain access to a <code>SecurityContext<\/code> instance, the following code should be\n * executed:\n * <p/>\n * <blockquote><pre>SecurityContext context = SecurityContext.getInstance();<\/pre><\/blockquote>\n * The returned <code>SecurityContext<\/code> instance will be an implementation from the JSecurity\n * implementation.  The <code>SecurityContext<\/code> is obtained using a {@link\n * SecurityContextFactory} that is implemented by the JSecurity implementation provider.<\/p>\n * <p/>\n * <p>The algorithm used in retrieving a <code>SecurityContext<\/code> using a {@link\n * SecurityContextFactory} is described in detail in the {@link #getContext(ClassLoader)}\n * JavaDoc.<\/p>\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @see SecurityContextFactory\n * @since 0.1\n */\npublic abstract class SecurityContext {\n\n    /*--------------------------------------------\n     |             C O N S T A N T S             |\n     ============================================*/\n    /**\n     * Name of the system property or file property that determines the class name of the {@link\n     * SecurityContextFactory} implementation class to use.\n     */\n    private static final String SECURITY_CONTEXT_FACTORY_PROP = \"security.context.factory.class\";\n\n    /**\n     * Name of the JSecurity properties file to be loaded.  This file should contain properties\n     * telling JSecurity how to create a security context.\n     */\n    private static final String JSECURITY_PROPS_FILE = \"jsecurity.properties\";\n\n    private static boolean factoryCached = true;\n\n    /** Will always be <tt>null<\/tt> if caching is turned off (i.e. factoryCached == false); */\n    private static SecurityContextFactory factory = null;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    /*--------------------------------------------\n     |        S T A T I C   M E T H O D S        |\n     ============================================*/\n\n    /**\n     * Returns whether or not the same <tt>SecurityContextFactory<\/tt> will be used each time {@link\n     * #getContext()} is called.\n     * <p/>\n     * <p>The system default is <tt>true<\/tt>.\n     * <p/>\n     * <p>Note: this does <em>not<\/em> determine whether or not each call to {@link #getContext()}\n     * returns a cached <tt>SecurityContext<\/tt> each time.  That is determined by the Factory\n     * implementation.\n     *\n     * @return whether or not the same <tt>SecurityContextFactory<\/tt> will be used each time {@link\n     *         #getContext()} is called.\n     */\n    public static boolean isFactoryCached() {\n        return factoryCached;\n    }\n\n    /**\n     * Sets whether or not the same <tt>SecurityContextFactory<\/tt> will be used each time {@link\n     * #getContext()} is called. <p>The system default is <tt>true<\/tt>.\n     * <p/>\n     * <p>Note: this does <em>not<\/em> determine whether or not each call to {@link #getContext()}\n     * returns a cached <tt>SecurityContext<\/tt> each time.  That is determined by the Factory\n     * implementation.\n     *\n     * @param cached whether or not to cache the factory instance.\n     */\n    public static void setFactoryCached( boolean cached ) {\n        factoryCached = cached;\n    }\n\n\n    /**\n     * Retrieves a {@link SecurityContext} instance based on a JSecurity implementation's\n     * <tt>SecurityContextFactory<\/tt>.\n     *\n     * @return the current SecurityContext.\n     */\n    public static SecurityContext getContext() {\n\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if ( cl == null ) {\n            cl = SecurityContext.class.getClassLoader();\n        }\n        return getContext( cl );\n    }\n\n    private static SecurityContext getContext( ClassLoader cl ) {\n\n        SecurityContext context = null;\n\n        if ( isFactoryCached() ) {\n            if ( factory != null ) {\n                context = factory.getContext( cl );\n            }\n        } else {\n            String factoryClassName = getFactoryClassName( cl );\n            SecurityContextFactory factory = getFactory( factoryClassName, cl );\n            context = factory.getContext( cl );\n        }\n\n        if ( context == null ) {\n            throw new SecurityContextException( \"SecurityContext returned by factory was null.\" );\n        }\n\n        return context;\n    }\n\n    private static String getFactoryClassName( ClassLoader cl ) {\n        String factoryClassName = System.getProperty( SECURITY_CONTEXT_FACTORY_PROP );\n\n        if ( factoryClassName == null ) {\n\n            InputStream propsFileIs = cl.getResourceAsStream( JSECURITY_PROPS_FILE );\n            Properties props = new Properties();\n            try {\n                props.load( propsFileIs );\n            } catch ( IOException e ) {\n                String msg = \"No [\" + SECURITY_CONTEXT_FACTORY_PROP + \"] system property \" +\n                             \"is defined and [\" + JSECURITY_PROPS_FILE + \"] cannot be \" +\n                             \"loaded from the classloader.  A SecurityContextFactory cannot \" +\n                             \"be created.\";\n                throw new SecurityContextException( msg );\n            }\n\n            factoryClassName = props.getProperty( SECURITY_CONTEXT_FACTORY_PROP );\n\n        }\n\n        if ( factoryClassName == null || factoryClassName.length() == 0 ) {\n            String msg = \"No [\" + SecurityContextFactory.class.getName() + \"] implementation \" +\n                         \"class was found configured in the system.  The factory \" +\n                         \"implementation should normally be specified by including the \" +\n                         \"JSecurity implementation JAR in the classpath.  The factory can \" +\n                         \"also be specified by setting the [\" + SECURITY_CONTEXT_FACTORY_PROP +\n                         \"] system property or manually including a jsecurity.properties file \" +\n                         \"at the root of the classpath.\";\n            throw new SecurityContextException( msg );\n        }\n\n        return factoryClassName;\n\n    }\n\n\n    /**\n     * Obtains a {@link SecurityContextFactory} instance of the specified factory class name,\n     * loading any necessary classes using the given class loader.\n     *\n     * @param factoryClassName the class name of the factory implementation that should be\n     *                         obtained.\n     * @param cl               the class loader to use if any classes must be loaded.\n     *\n     * @return a {@link SecurityContextFactory} implementation of the specified type.\n     */\n    private static SecurityContextFactory getFactory( String factoryClassName, ClassLoader cl ) {\n        if ( isFactoryCached() ) {\n            if ( factory == null ) {\n                factory = instantiateFactory( factoryClassName, cl );\n            }\n            return factory;\n        } else {\n            return instantiateFactory( factoryClassName, cl );\n        }\n    }\n\n    private static SecurityContextFactory instantiateFactory( String factoryClassName,\n                                                              ClassLoader cl ) {\n        SecurityContextFactory factory;\n        try {\n\n            Class factoryClass = cl.loadClass( factoryClassName );\n            factory = (SecurityContextFactory)factoryClass.newInstance();\n\n        } catch ( ClassNotFoundException e ) {\n            String msg = \"Factory class [\" + factoryClassName + \"] could not be found.  No \" +\n                         \"SecurityContext can be loaded.\";\n            throw new SecurityContextException( msg, e );\n        } catch ( IllegalAccessException e ) {\n            String msg = \"Factory class [\" + factoryClassName + \"] constructor could not be \" +\n                         \"accessed.  SecurityContext cannot be loaded.\";\n            throw new SecurityContextException( msg, e );\n        } catch ( InstantiationException e ) {\n            String msg = \"Factory class [\" + factoryClassName + \"] could not be instantiated.  \" +\n                         \"SecurityContext cannot be loaded.\";\n            throw new SecurityContextException( msg, e );\n        }\n\n        return factory;\n    }\n\n    /*--------------------------------------------\n    |     A B S T R A C T   M E T H O D S       |\n    ============================================*/\n    public abstract SessionFactory getSessionFactory();\n\n    public abstract Authenticator getAuthenticator();\n\n    public abstract Authorizer getAuthorizer();\n\n    public abstract Session getCurrentSession();\n\n    public abstract AuthorizationContext getCurrentAuthContext();\n}\n","Smelly Sample":"/*\n * Copyright (C) 2005 Jeremy Haile\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the\n *\n * Free Software Foundation, Inc.\n * 59 Temple Place, Suite 330\n * Boston, MA 02111-1307\n * USA\n *\n * Or, you may view it online at\n * http://www.opensource.org/licenses/lgpl-license.php\n */\n\npackage org.jsecurity.context;\n\nimport org.jsecurity.authz.AuthorizationContext;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.SessionFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Authenticator;\nimport java.util.Properties;\n\n/**\n * <p>The <code>SecurityContext<\/code> is the programmatic entry point into the JSecurity API.\n * This class provides access to the core services of JSecurity, such as the\n * {@link org.jsecurity.session.SessionFactory}, {@link org.jsecurity.authc.Authenticator},\n * {@link org.jsecurity.authz.Authorizer}, etc. as well as current context of the calling code,\n * such as its {@link org.jsecurity.session.Session} and {@link org.jsecurity.authz.AuthorizationContext}\n * <\/p>\n *\n * <p>To gain access to a <code>SecurityContext<\/code> instance, the following code should be executed:\n * <blockquote><pre>SecurityContext context = SecurityContext.getInstance();<\/pre><\/blockquote>\n * The returned <code>SecurityContext<\/code> instance will be an implementation from the\n * JSecurity implementation.  The <code>SecurityContext<\/code> is obtained using a\n * {@link SecurityContextFactory} that is implemented by the JSecurity implementation provider.<\/p>\n *\n * <p>The algorithm used in retrieving a <code>SecurityContext<\/code> using a {@link SecurityContextFactory}\n * is described in detail in the {@link #getContext(ClassLoader)} JavaDoc.<\/p>\n *\n * @see SecurityContextFactory\n *\n * @author Jeremy Haile\n * @since 0.1\n */\npublic abstract class SecurityContext {\n\n    /*--------------------------------------------\n     |             C O N S T A N T S             |\n     ============================================*/\n    /**\n     * Name of the system property or file property that determines the class name of the\n     * {@link SecurityContextFactory} implementation class to use.\n     */\n    private static final String SECURITY_CONTEXT_FACTORY_PROP = \"security.context.factory.class\";\n\n    /**\n     * Name of the JSecurity properties file to be loaded.  This file should contain properties\n     * telling JSecurity how to create a security context.\n     */\n    private static final String JSECURITY_PROPS_FILE = \"jsecurity.properties\";\n\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n\n    /*--------------------------------------------\n     |        S T A T I C   M E T H O D S        |\n     ============================================*/\n\n\n    /**\n     * Retrieves a {@link SecurityContext} instance by invoking {@link #getContext(ClassLoader)}\n     * with the thread context class loader.\n     * @return the current SecurityContext.\n     */\n    public static SecurityContext getContext() {\n        return getContext( Thread.currentThread().getContextClassLoader() );\n    }\n\n\n    private static SecurityContext getContext(ClassLoader cl) {\n        String factoryClassName = System.getProperty( SECURITY_CONTEXT_FACTORY_PROP );\n\n        if( factoryClassName == null ) {\n\n            InputStream propsFileIs = cl.getResourceAsStream( JSECURITY_PROPS_FILE );\n            Properties props = new Properties();\n            try {\n                props.load( propsFileIs );\n            } catch (IOException e) {\n                throw new SecurityContextException( \"No [\" + SECURITY_CONTEXT_FACTORY_PROP + \"] system property \" +\n                                                    \"is defined and [\" + JSECURITY_PROPS_FILE + \"] cannot be \" +\n                                                    \"loaded from the classloader, so the SecurityContextFactory cannot \" +\n                                                    \"be created.\" );\n            }\n\n            factoryClassName = props.getProperty( SECURITY_CONTEXT_FACTORY_PROP );\n\n        }\n\n        if( factoryClassName == null || factoryClassName.length() == 0 ) {\n            throw new SecurityContextException( \"No [\" + SecurityContextFactory.class.getName() + \"] implementation \" +\n                \"class was found configured in the system.  The factory implementation should normally be specified \" +\n                \"by including the JSecurity implementation JAR in the classpath.  The factory can also be specified \" +\n                \"by setting the [\" + SECURITY_CONTEXT_FACTORY_PROP + \"] system property.\");\n        }\n\n        SecurityContextFactory factory = getSecurityContextFactory( factoryClassName, cl );\n\n        SecurityContext context = factory.getContext( cl );\n\n        if( context == null ) {\n            throw new SecurityContextException( \"SecurityContext returned by factory was null.\" );\n        }\n\n        return context;\n\n    }\n\n\n    /**\n     * Obtains a {@link SecurityContextFactory} instance of the specified factory class name,\n     * loading any necessary classes using the given class loader.\n     *\n     * todo Should we cache the factory?\n     *\n     * @param factoryClassName the class name of the factory implementation that should be obtained.\n     * @param cl the class loader to use if any classes must be loaded.\n     * @return a {@link SecurityContextFactory} implementation of the specified type.\n     */\n    private static SecurityContextFactory getSecurityContextFactory( String factoryClassName, ClassLoader cl ) {\n\n        SecurityContextFactory factory = null;\n        try {\n\n            Class factoryClass = cl.loadClass( factoryClassName );\n            factory = (SecurityContextFactory) factoryClass.newInstance();\n\n        } catch (ClassNotFoundException e) {\n            throw new SecurityContextException( \"Factory class [\" + factoryClassName + \"] could not be \" +\n                                                \"found so SecurityContext could not be loaded.\", e);\n        } catch (IllegalAccessException e) {\n            throw new SecurityContextException( \"Factory class [\" + factoryClassName + \"] constructor could \" +\n                                                \"not be accessed.\", e);\n\n        } catch (InstantiationException e) {\n            throw new SecurityContextException( \"New instance of factory class [\" + factoryClassName + \"] \" +\n                                                \"could not be instantiated.\", e);\n        }\n\n        return factory;\n    }\n\n    /*--------------------------------------------\n     |     A B S T R A C T   M E T H O D S       |\n     ============================================*/\n    public abstract SessionFactory getSessionFactory();\n\n    public abstract Authenticator getAuthenticator();\n\n    public abstract Authorizer getAuthorizer();\n\n    public abstract Session getCurrentSession();\n\n    public abstract AuthorizationContext getCurrentAuthContext();\n}\n","lineNo":140}
