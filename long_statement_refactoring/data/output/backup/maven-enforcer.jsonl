{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.maven.enforcer.rules.dependency;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\nimport org.apache.maven.RepositoryUtils;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.DependencyManagement;\nimport org.apache.maven.project.MavenProject;\nimport org.eclipse.aether.DefaultRepositorySystemSession;\nimport org.eclipse.aether.RepositorySystem;\nimport org.eclipse.aether.RepositorySystemSession;\nimport org.eclipse.aether.artifact.ArtifactTypeRegistry;\nimport org.eclipse.aether.collection.CollectRequest;\nimport org.eclipse.aether.collection.DependencyCollectionException;\nimport org.eclipse.aether.graph.Dependency;\nimport org.eclipse.aether.graph.DependencyNode;\nimport org.eclipse.aether.util.graph.manager.DependencyManagerUtils;\nimport org.eclipse.aether.util.graph.transformer.ConflictResolver;\n\nimport static java.util.Optional.ofNullable;\nimport static org.apache.maven.artifact.Artifact.SCOPE_PROVIDED;\nimport static org.apache.maven.artifact.Artifact.SCOPE_TEST;\n\n/**\n * Resolver helper class.\n */\n@Named\nclass ResolveUtil {\n\n    private final RepositorySystem repositorySystem;\n\n    private final MavenSession session;\n\n    /**\n     * Default constructor\n     */\n    @Inject\n    ResolveUtil(RepositorySystem repositorySystem, MavenSession session) {\n        this.repositorySystem = Objects.requireNonNull(repositorySystem);\n        this.session = Objects.requireNonNull(session);\n    }\n\n    /**\n     * Retrieves the {@link DependencyNode} instance containing the result of the transitive dependency\n     * for the current {@link MavenProject} in verbose mode.\n     * <p>\n     * In verbose mode all nodes participating in a conflict are retained.\n     * <\/p>\n     * <p>\n     * Please consult {@link ConflictResolver} and {@link DependencyManagerUtils}>\n     * <\/p>\n     *\n     * @param excludedScopes a project dependency scope to excluded\n     * @return a Dependency Node which is the root of the project's dependency tree\n     * @throws EnforcerRuleException thrown if the lookup fails\n     */\n    DependencyNode resolveTransitiveDependenciesVerbose(List<String> excludedScopes) throws EnforcerRuleException {\n        return resolveTransitiveDependencies(true, true, excludedScopes);\n    }\n\n    /**\n     * Retrieves the {@link DependencyNode} instance containing the result of the transitive dependency\n     * for the current {@link MavenProject}.\n     *\n     * @return a Dependency Node which is the root of the project's dependency tree\n     * @throws EnforcerRuleException thrown if the lookup fails\n     */\n    DependencyNode resolveTransitiveDependencies() throws EnforcerRuleException {\n        return resolveTransitiveDependencies(false, true, Arrays.asList(SCOPE_TEST, SCOPE_PROVIDED));\n    }\n\n    private DependencyNode resolveTransitiveDependencies(\n            boolean verbose, boolean excludeOptional, List<String> excludedScopes) throws EnforcerRuleException {\n\n        try {\n            RepositorySystemSession repositorySystemSession = session.getRepositorySession();\n\n            if (verbose) {\n                DefaultRepositorySystemSession defaultRepositorySystemSession =\n                        new DefaultRepositorySystemSession(repositorySystemSession);\n                defaultRepositorySystemSession.setConfigProperty(ConflictResolver.CONFIG_PROP_VERBOSE, true);\n                defaultRepositorySystemSession.setConfigProperty(DependencyManagerUtils.CONFIG_PROP_VERBOSE, true);\n                repositorySystemSession = defaultRepositorySystemSession;\n            }\n\n            MavenProject project = session.getCurrentProject();\n            ArtifactTypeRegistry artifactTypeRegistry =\n                    session.getRepositorySession().getArtifactTypeRegistry();\n\n            List<Dependency> dependencies = project.getDependencies().stream()\n                    .filter(d -> !(excludeOptional && d.isOptional()))\n                    .filter(d -> !excludedScopes.contains(d.getScope()))\n                    .map(d -> RepositoryUtils.toDependency(d, artifactTypeRegistry))\n                    .collect(Collectors.toList());\n\n            List<Dependency> managedDependencies = ofNullable(project.getDependencyManagement())\n                    .map(DependencyManagement::getDependencies)\n                    .map(list -> list.stream()\n                            .map(d -> RepositoryUtils.toDependency(d, artifactTypeRegistry))\n                            .collect(Collectors.toList()))\n                    .orElse(null);\n\n            CollectRequest collectRequest =\n                    new CollectRequest(dependencies, managedDependencies, project.getRemoteProjectRepositories());\n            collectRequest.setRootArtifact(RepositoryUtils.toArtifact(project.getArtifact()));\n\n            return repositorySystem\n                    .collectDependencies(repositorySystemSession, collectRequest)\n                    .getRoot();\n        } catch (DependencyCollectionException e) {\n            throw new EnforcerRuleException(\"Could not build dependency tree \" + e.getLocalizedMessage(), e);\n        }\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.maven.enforcer.rules.dependency;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\n\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\nimport org.apache.maven.RepositoryUtils;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.DependencyManagement;\nimport org.apache.maven.project.MavenProject;\nimport org.eclipse.aether.DefaultRepositorySystemSession;\nimport org.eclipse.aether.RepositorySystem;\nimport org.eclipse.aether.artifact.ArtifactTypeRegistry;\nimport org.eclipse.aether.collection.CollectRequest;\nimport org.eclipse.aether.collection.DependencyCollectionException;\nimport org.eclipse.aether.collection.DependencySelector;\nimport org.eclipse.aether.graph.DependencyNode;\nimport org.eclipse.aether.util.graph.manager.DependencyManagerUtils;\nimport org.eclipse.aether.util.graph.selector.AndDependencySelector;\nimport org.eclipse.aether.util.graph.transformer.ConflictResolver;\n\nimport static java.util.Optional.ofNullable;\n\n/**\n * Resolver helper class.\n */\n@Named\nclass ResolveUtil {\n\n    private final RepositorySystem repositorySystem;\n\n    private final MavenSession session;\n\n    /**\n     * Default constructor\n     */\n    @Inject\n    ResolveUtil(RepositorySystem repositorySystem, MavenSession session) {\n        this.repositorySystem = Objects.requireNonNull(repositorySystem);\n        this.session = Objects.requireNonNull(session);\n    }\n\n    /**\n     * Retrieves the {@link DependencyNode} instance containing the result of the transitive dependency\n     * for the current {@link MavenProject} in verbose mode.\n     * <p>\n     * In verbose mode all nodes participating in a conflict are retained.\n     * <\/p>\n     * <p>\n     * Please consult {@link ConflictResolver} and {@link DependencyManagerUtils}>\n     * <\/p>\n     *\n     * @param selectors zero or more {@link DependencySelector} instances\n     * @return a Dependency Node which is the root of the project's dependency tree\n     * @throws EnforcerRuleException thrown if the lookup fails\n     */\n    DependencyNode resolveTransitiveDependenciesVerbose(DependencySelector... selectors) throws EnforcerRuleException {\n        return resolveTransitiveDependencies(true, selectors);\n    }\n\n    /**\n     * Retrieves the {@link DependencyNode} instance containing the result of the transitive dependency\n     * for the current {@link MavenProject}.\n     *\n     * @param selectors zero or more {@link DependencySelector} instances\n     * @return a Dependency Node which is the root of the project's dependency tree\n     * @throws EnforcerRuleException thrown if the lookup fails\n     */\n    DependencyNode resolveTransitiveDependencies(DependencySelector... selectors) throws EnforcerRuleException {\n        return resolveTransitiveDependencies(false, selectors);\n    }\n\n    private DependencyNode resolveTransitiveDependencies(boolean verbose, DependencySelector... selectors)\n            throws EnforcerRuleException {\n\n        try {\n            MavenProject project = session.getCurrentProject();\n            ArtifactTypeRegistry artifactTypeRegistry =\n                    session.getRepositorySession().getArtifactTypeRegistry();\n\n            DefaultRepositorySystemSession repositorySystemSession =\n                    new DefaultRepositorySystemSession(session.getRepositorySession());\n\n            if (selectors.length > 0) {\n                repositorySystemSession.setDependencySelector(new AndDependencySelector(selectors));\n            }\n\n            if (verbose) {\n                repositorySystemSession.setConfigProperty(ConflictResolver.CONFIG_PROP_VERBOSE, true);\n                repositorySystemSession.setConfigProperty(DependencyManagerUtils.CONFIG_PROP_VERBOSE, true);\n            }\n\n            CollectRequest collectRequest = new CollectRequest(\n                    project.getDependencies().stream()\n                            .map(d -> RepositoryUtils.toDependency(d, artifactTypeRegistry))\n                            .collect(Collectors.toList()),\n                    ofNullable(project.getDependencyManagement())\n                            .map(DependencyManagement::getDependencies)\n                            .map(list -> list.stream()\n                                    .map(d -> RepositoryUtils.toDependency(d, artifactTypeRegistry))\n                                    .collect(Collectors.toList()))\n                            .orElse(null),\n                    project.getRemoteProjectRepositories());\n            Artifact artifact = project.getArtifact();\n            collectRequest.setRootArtifact(RepositoryUtils.toArtifact(artifact));\n\n            return repositorySystem\n                    .collectDependencies(repositorySystemSession, collectRequest)\n                    .getRoot();\n        } catch (DependencyCollectionException e) {\n            throw new EnforcerRuleException(\"Could not build dependency tree \" + e.getLocalizedMessage(), e);\n        }\n    }\n}\n","lineNo":101}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.maven.enforcer.rules.dependency;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\nimport org.apache.maven.RepositoryUtils;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.DependencyManagement;\nimport org.apache.maven.project.MavenProject;\nimport org.eclipse.aether.DefaultRepositorySystemSession;\nimport org.eclipse.aether.RepositorySystem;\nimport org.eclipse.aether.RepositorySystemSession;\nimport org.eclipse.aether.artifact.ArtifactTypeRegistry;\nimport org.eclipse.aether.collection.CollectRequest;\nimport org.eclipse.aether.collection.DependencyCollectionException;\nimport org.eclipse.aether.graph.Dependency;\nimport org.eclipse.aether.graph.DependencyNode;\nimport org.eclipse.aether.util.graph.manager.DependencyManagerUtils;\nimport org.eclipse.aether.util.graph.transformer.ConflictResolver;\n\nimport static java.util.Optional.ofNullable;\nimport static org.apache.maven.artifact.Artifact.SCOPE_PROVIDED;\nimport static org.apache.maven.artifact.Artifact.SCOPE_TEST;\n\n/**\n * Resolver helper class.\n */\n@Named\nclass ResolveUtil {\n\n    private final RepositorySystem repositorySystem;\n\n    private final MavenSession session;\n\n    /**\n     * Default constructor\n     */\n    @Inject\n    ResolveUtil(RepositorySystem repositorySystem, MavenSession session) {\n        this.repositorySystem = Objects.requireNonNull(repositorySystem);\n        this.session = Objects.requireNonNull(session);\n    }\n\n    /**\n     * Retrieves the {@link DependencyNode} instance containing the result of the transitive dependency\n     * for the current {@link MavenProject} in verbose mode.\n     * <p>\n     * In verbose mode all nodes participating in a conflict are retained.\n     * <\/p>\n     * <p>\n     * Please consult {@link ConflictResolver} and {@link DependencyManagerUtils}>\n     * <\/p>\n     *\n     * @param excludedScopes a project dependency scope to excluded\n     * @return a Dependency Node which is the root of the project's dependency tree\n     * @throws EnforcerRuleException thrown if the lookup fails\n     */\n    DependencyNode resolveTransitiveDependenciesVerbose(List<String> excludedScopes) throws EnforcerRuleException {\n        return resolveTransitiveDependencies(true, true, excludedScopes);\n    }\n\n    /**\n     * Retrieves the {@link DependencyNode} instance containing the result of the transitive dependency\n     * for the current {@link MavenProject}.\n     *\n     * @return a Dependency Node which is the root of the project's dependency tree\n     * @throws EnforcerRuleException thrown if the lookup fails\n     */\n    DependencyNode resolveTransitiveDependencies() throws EnforcerRuleException {\n        return resolveTransitiveDependencies(false, true, Arrays.asList(SCOPE_TEST, SCOPE_PROVIDED));\n    }\n\n    private DependencyNode resolveTransitiveDependencies(\n            boolean verbose, boolean excludeOptional, List<String> excludedScopes) throws EnforcerRuleException {\n\n        try {\n            RepositorySystemSession repositorySystemSession = session.getRepositorySession();\n\n            if (verbose) {\n                DefaultRepositorySystemSession defaultRepositorySystemSession =\n                        new DefaultRepositorySystemSession(repositorySystemSession);\n                defaultRepositorySystemSession.setConfigProperty(ConflictResolver.CONFIG_PROP_VERBOSE, true);\n                defaultRepositorySystemSession.setConfigProperty(DependencyManagerUtils.CONFIG_PROP_VERBOSE, true);\n                repositorySystemSession = defaultRepositorySystemSession;\n            }\n\n            MavenProject project = session.getCurrentProject();\n            ArtifactTypeRegistry artifactTypeRegistry =\n                    session.getRepositorySession().getArtifactTypeRegistry();\n\n            List<Dependency> dependencies = project.getDependencies().stream()\n                    .filter(d -> !(excludeOptional && d.isOptional()))\n                    .filter(d -> !excludedScopes.contains(d.getScope()))\n                    .map(d -> RepositoryUtils.toDependency(d, artifactTypeRegistry))\n                    .collect(Collectors.toList());\n\n            List<Dependency> managedDependencies = ofNullable(project.getDependencyManagement())\n                    .map(DependencyManagement::getDependencies)\n                    .map(list -> list.stream()\n                            .map(d -> RepositoryUtils.toDependency(d, artifactTypeRegistry))\n                            .collect(Collectors.toList()))\n                    .orElse(null);\n\n            CollectRequest collectRequest =\n                    new CollectRequest(dependencies, managedDependencies, project.getRemoteProjectRepositories());\n            collectRequest.setRootArtifact(RepositoryUtils.toArtifact(project.getArtifact()));\n\n            return repositorySystem\n                    .collectDependencies(repositorySystemSession, collectRequest)\n                    .getRoot();\n        } catch (DependencyCollectionException e) {\n            throw new EnforcerRuleException(\"Could not build dependency tree \" + e.getLocalizedMessage(), e);\n        }\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.maven.enforcer.rules.dependency;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\n\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\nimport org.apache.maven.RepositoryUtils;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.DependencyManagement;\nimport org.apache.maven.project.MavenProject;\nimport org.eclipse.aether.DefaultRepositorySystemSession;\nimport org.eclipse.aether.RepositorySystem;\nimport org.eclipse.aether.artifact.ArtifactTypeRegistry;\nimport org.eclipse.aether.collection.CollectRequest;\nimport org.eclipse.aether.collection.DependencyCollectionException;\nimport org.eclipse.aether.collection.DependencySelector;\nimport org.eclipse.aether.graph.DependencyNode;\nimport org.eclipse.aether.util.graph.manager.DependencyManagerUtils;\nimport org.eclipse.aether.util.graph.selector.AndDependencySelector;\nimport org.eclipse.aether.util.graph.transformer.ConflictResolver;\n\nimport static java.util.Optional.ofNullable;\n\n/**\n * Resolver helper class.\n */\n@Named\nclass ResolveUtil {\n\n    private final RepositorySystem repositorySystem;\n\n    private final MavenSession session;\n\n    /**\n     * Default constructor\n     */\n    @Inject\n    ResolveUtil(RepositorySystem repositorySystem, MavenSession session) {\n        this.repositorySystem = Objects.requireNonNull(repositorySystem);\n        this.session = Objects.requireNonNull(session);\n    }\n\n    /**\n     * Retrieves the {@link DependencyNode} instance containing the result of the transitive dependency\n     * for the current {@link MavenProject} in verbose mode.\n     * <p>\n     * In verbose mode all nodes participating in a conflict are retained.\n     * <\/p>\n     * <p>\n     * Please consult {@link ConflictResolver} and {@link DependencyManagerUtils}>\n     * <\/p>\n     *\n     * @param selectors zero or more {@link DependencySelector} instances\n     * @return a Dependency Node which is the root of the project's dependency tree\n     * @throws EnforcerRuleException thrown if the lookup fails\n     */\n    DependencyNode resolveTransitiveDependenciesVerbose(DependencySelector... selectors) throws EnforcerRuleException {\n        return resolveTransitiveDependencies(true, selectors);\n    }\n\n    /**\n     * Retrieves the {@link DependencyNode} instance containing the result of the transitive dependency\n     * for the current {@link MavenProject}.\n     *\n     * @param selectors zero or more {@link DependencySelector} instances\n     * @return a Dependency Node which is the root of the project's dependency tree\n     * @throws EnforcerRuleException thrown if the lookup fails\n     */\n    DependencyNode resolveTransitiveDependencies(DependencySelector... selectors) throws EnforcerRuleException {\n        return resolveTransitiveDependencies(false, selectors);\n    }\n\n    private DependencyNode resolveTransitiveDependencies(boolean verbose, DependencySelector... selectors)\n            throws EnforcerRuleException {\n\n        try {\n            MavenProject project = session.getCurrentProject();\n            ArtifactTypeRegistry artifactTypeRegistry =\n                    session.getRepositorySession().getArtifactTypeRegistry();\n\n            DefaultRepositorySystemSession repositorySystemSession =\n                    new DefaultRepositorySystemSession(session.getRepositorySession());\n\n            if (selectors.length > 0) {\n                repositorySystemSession.setDependencySelector(new AndDependencySelector(selectors));\n            }\n\n            if (verbose) {\n                repositorySystemSession.setConfigProperty(ConflictResolver.CONFIG_PROP_VERBOSE, true);\n                repositorySystemSession.setConfigProperty(DependencyManagerUtils.CONFIG_PROP_VERBOSE, true);\n            }\n\n            CollectRequest collectRequest = new CollectRequest(\n                    project.getDependencies().stream()\n                            .map(d -> RepositoryUtils.toDependency(d, artifactTypeRegistry))\n                            .collect(Collectors.toList()),\n                    ofNullable(project.getDependencyManagement())\n                            .map(DependencyManagement::getDependencies)\n                            .map(list -> list.stream()\n                                    .map(d -> RepositoryUtils.toDependency(d, artifactTypeRegistry))\n                                    .collect(Collectors.toList()))\n                            .orElse(null),\n                    project.getRemoteProjectRepositories());\n            Artifact artifact = project.getArtifact();\n            collectRequest.setRootArtifact(RepositoryUtils.toArtifact(artifact));\n\n            return repositorySystem\n                    .collectDependencies(repositorySystemSession, collectRequest)\n                    .getRoot();\n        } catch (DependencyCollectionException e) {\n            throw new EnforcerRuleException(\"Could not build dependency tree \" + e.getLocalizedMessage(), e);\n        }\n    }\n}\n","lineNo":121}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.maven.enforcer.rules.dependency;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\nimport org.apache.maven.RepositoryUtils;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.DependencyManagement;\nimport org.apache.maven.project.MavenProject;\nimport org.eclipse.aether.DefaultRepositorySystemSession;\nimport org.eclipse.aether.RepositorySystem;\nimport org.eclipse.aether.RepositorySystemSession;\nimport org.eclipse.aether.artifact.ArtifactTypeRegistry;\nimport org.eclipse.aether.collection.CollectRequest;\nimport org.eclipse.aether.collection.DependencyCollectionException;\nimport org.eclipse.aether.graph.Dependency;\nimport org.eclipse.aether.graph.DependencyNode;\nimport org.eclipse.aether.util.graph.manager.DependencyManagerUtils;\nimport org.eclipse.aether.util.graph.transformer.ConflictResolver;\n\nimport static java.util.Optional.ofNullable;\nimport static org.apache.maven.artifact.Artifact.SCOPE_PROVIDED;\nimport static org.apache.maven.artifact.Artifact.SCOPE_TEST;\n\n/**\n * Resolver helper class.\n */\n@Named\nclass ResolveUtil {\n\n    private final RepositorySystem repositorySystem;\n\n    private final MavenSession session;\n\n    /**\n     * Default constructor\n     */\n    @Inject\n    ResolveUtil(RepositorySystem repositorySystem, MavenSession session) {\n        this.repositorySystem = Objects.requireNonNull(repositorySystem);\n        this.session = Objects.requireNonNull(session);\n    }\n\n    /**\n     * Retrieves the {@link DependencyNode} instance containing the result of the transitive dependency\n     * for the current {@link MavenProject} in verbose mode.\n     * <p>\n     * In verbose mode all nodes participating in a conflict are retained.\n     * <\/p>\n     * <p>\n     * Please consult {@link ConflictResolver} and {@link DependencyManagerUtils}>\n     * <\/p>\n     *\n     * @param excludedScopes a project dependency scope to excluded\n     * @return a Dependency Node which is the root of the project's dependency tree\n     * @throws EnforcerRuleException thrown if the lookup fails\n     */\n    DependencyNode resolveTransitiveDependenciesVerbose(List<String> excludedScopes) throws EnforcerRuleException {\n        return resolveTransitiveDependencies(true, true, excludedScopes);\n    }\n\n    /**\n     * Retrieves the {@link DependencyNode} instance containing the result of the transitive dependency\n     * for the current {@link MavenProject}.\n     *\n     * @return a Dependency Node which is the root of the project's dependency tree\n     * @throws EnforcerRuleException thrown if the lookup fails\n     */\n    DependencyNode resolveTransitiveDependencies() throws EnforcerRuleException {\n        return resolveTransitiveDependencies(false, true, Arrays.asList(SCOPE_TEST, SCOPE_PROVIDED));\n    }\n\n    private DependencyNode resolveTransitiveDependencies(\n            boolean verbose, boolean excludeOptional, List<String> excludedScopes) throws EnforcerRuleException {\n\n        try {\n            RepositorySystemSession repositorySystemSession = session.getRepositorySession();\n\n            if (verbose) {\n                DefaultRepositorySystemSession defaultRepositorySystemSession =\n                        new DefaultRepositorySystemSession(repositorySystemSession);\n                defaultRepositorySystemSession.setConfigProperty(ConflictResolver.CONFIG_PROP_VERBOSE, true);\n                defaultRepositorySystemSession.setConfigProperty(DependencyManagerUtils.CONFIG_PROP_VERBOSE, true);\n                repositorySystemSession = defaultRepositorySystemSession;\n            }\n\n            MavenProject project = session.getCurrentProject();\n            ArtifactTypeRegistry artifactTypeRegistry =\n                    session.getRepositorySession().getArtifactTypeRegistry();\n\n            List<Dependency> dependencies = project.getDependencies().stream()\n                    .filter(d -> !(excludeOptional && d.isOptional()))\n                    .filter(d -> !excludedScopes.contains(d.getScope()))\n                    .map(d -> RepositoryUtils.toDependency(d, artifactTypeRegistry))\n                    .collect(Collectors.toList());\n\n            List<Dependency> managedDependencies = ofNullable(project.getDependencyManagement())\n                    .map(DependencyManagement::getDependencies)\n                    .map(list -> list.stream()\n                            .map(d -> RepositoryUtils.toDependency(d, artifactTypeRegistry))\n                            .collect(Collectors.toList()))\n                    .orElse(null);\n\n            CollectRequest collectRequest =\n                    new CollectRequest(dependencies, managedDependencies, project.getRemoteProjectRepositories());\n            collectRequest.setRootArtifact(RepositoryUtils.toArtifact(project.getArtifact()));\n\n            return repositorySystem\n                    .collectDependencies(repositorySystemSession, collectRequest)\n                    .getRoot();\n        } catch (DependencyCollectionException e) {\n            throw new EnforcerRuleException(\"Could not build dependency tree \" + e.getLocalizedMessage(), e);\n        }\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.maven.enforcer.rules.dependency;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\n\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\nimport org.apache.maven.RepositoryUtils;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.DependencyManagement;\nimport org.apache.maven.project.MavenProject;\nimport org.eclipse.aether.DefaultRepositorySystemSession;\nimport org.eclipse.aether.RepositorySystem;\nimport org.eclipse.aether.artifact.ArtifactTypeRegistry;\nimport org.eclipse.aether.collection.CollectRequest;\nimport org.eclipse.aether.collection.DependencyCollectionException;\nimport org.eclipse.aether.collection.DependencySelector;\nimport org.eclipse.aether.graph.DependencyNode;\nimport org.eclipse.aether.util.graph.manager.DependencyManagerUtils;\nimport org.eclipse.aether.util.graph.selector.AndDependencySelector;\nimport org.eclipse.aether.util.graph.transformer.ConflictResolver;\n\nimport static java.util.Optional.ofNullable;\n\n/**\n * Resolver helper class.\n */\n@Named\nclass ResolveUtil {\n\n    private final RepositorySystem repositorySystem;\n\n    private final MavenSession session;\n\n    /**\n     * Default constructor\n     */\n    @Inject\n    ResolveUtil(RepositorySystem repositorySystem, MavenSession session) {\n        this.repositorySystem = Objects.requireNonNull(repositorySystem);\n        this.session = Objects.requireNonNull(session);\n    }\n\n    /**\n     * Retrieves the {@link DependencyNode} instance containing the result of the transitive dependency\n     * for the current {@link MavenProject} in verbose mode.\n     * <p>\n     * In verbose mode all nodes participating in a conflict are retained.\n     * <\/p>\n     * <p>\n     * Please consult {@link ConflictResolver} and {@link DependencyManagerUtils}>\n     * <\/p>\n     *\n     * @param selectors zero or more {@link DependencySelector} instances\n     * @return a Dependency Node which is the root of the project's dependency tree\n     * @throws EnforcerRuleException thrown if the lookup fails\n     */\n    DependencyNode resolveTransitiveDependenciesVerbose(DependencySelector... selectors) throws EnforcerRuleException {\n        return resolveTransitiveDependencies(true, selectors);\n    }\n\n    /**\n     * Retrieves the {@link DependencyNode} instance containing the result of the transitive dependency\n     * for the current {@link MavenProject}.\n     *\n     * @param selectors zero or more {@link DependencySelector} instances\n     * @return a Dependency Node which is the root of the project's dependency tree\n     * @throws EnforcerRuleException thrown if the lookup fails\n     */\n    DependencyNode resolveTransitiveDependencies(DependencySelector... selectors) throws EnforcerRuleException {\n        return resolveTransitiveDependencies(false, selectors);\n    }\n\n    private DependencyNode resolveTransitiveDependencies(boolean verbose, DependencySelector... selectors)\n            throws EnforcerRuleException {\n\n        try {\n            MavenProject project = session.getCurrentProject();\n            ArtifactTypeRegistry artifactTypeRegistry =\n                    session.getRepositorySession().getArtifactTypeRegistry();\n\n            DefaultRepositorySystemSession repositorySystemSession =\n                    new DefaultRepositorySystemSession(session.getRepositorySession());\n\n            if (selectors.length > 0) {\n                repositorySystemSession.setDependencySelector(new AndDependencySelector(selectors));\n            }\n\n            if (verbose) {\n                repositorySystemSession.setConfigProperty(ConflictResolver.CONFIG_PROP_VERBOSE, true);\n                repositorySystemSession.setConfigProperty(DependencyManagerUtils.CONFIG_PROP_VERBOSE, true);\n            }\n\n            CollectRequest collectRequest = new CollectRequest(\n                    project.getDependencies().stream()\n                            .map(d -> RepositoryUtils.toDependency(d, artifactTypeRegistry))\n                            .collect(Collectors.toList()),\n                    ofNullable(project.getDependencyManagement())\n                            .map(DependencyManagement::getDependencies)\n                            .map(list -> list.stream()\n                                    .map(d -> RepositoryUtils.toDependency(d, artifactTypeRegistry))\n                                    .collect(Collectors.toList()))\n                            .orElse(null),\n                    project.getRemoteProjectRepositories());\n            Artifact artifact = project.getArtifact();\n            collectRequest.setRootArtifact(RepositoryUtils.toArtifact(artifact));\n\n            return repositorySystem\n                    .collectDependencies(repositorySystemSession, collectRequest)\n                    .getRoot();\n        } catch (DependencyCollectionException e) {\n            throw new EnforcerRuleException(\"Could not build dependency tree \" + e.getLocalizedMessage(), e);\n        }\n    }\n}\n","lineNo":115}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.maven.enforcer.rules.dependency;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\n\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rules.AbstractStandardEnforcerRule;\nimport org.apache.maven.enforcer.rules.dependency.selector.AllLevelsOptionalDependencySelector;\nimport org.apache.maven.enforcer.rules.dependency.selector.AllLevelsScopeDependencySelector;\nimport org.apache.maven.enforcer.rules.utils.ArtifactUtils;\nimport org.eclipse.aether.graph.DependencyNode;\nimport org.eclipse.aether.util.graph.selector.ExclusionDependencySelector;\n\nimport static org.apache.maven.artifact.Artifact.SCOPE_PROVIDED;\nimport static org.apache.maven.artifact.Artifact.SCOPE_TEST;\n\n/**\n * @author <a href=\"mailto:rex@e-hoffman.org\">Rex Hoffman<\/a>\n */\n@Named(\"dependencyConvergence\")\npublic final class DependencyConvergence extends AbstractStandardEnforcerRule {\n\n    // parameters\n\n    private boolean uniqueVersions;\n\n    private List<String> includes;\n\n    private List<String> excludes;\n\n    private List<String> excludedScopes = Arrays.asList(SCOPE_TEST, SCOPE_PROVIDED);\n\n    // parameters - end\n\n    private DependencyVersionMap dependencyVersionMap;\n\n    private final ResolveUtil resolveUtil;\n\n    @Inject\n    public DependencyConvergence(ResolveUtil resolveUtil) {\n        this.resolveUtil = Objects.requireNonNull(resolveUtil);\n    }\n\n    @Override\n    public void execute() throws EnforcerRuleException {\n\n        DependencyNode node = resolveUtil.resolveTransitiveDependenciesVerbose(\n                new AllLevelsOptionalDependencySelector(),\n                new AllLevelsScopeDependencySelector(excludedScopes),\n                new ExclusionDependencySelector());\n        dependencyVersionMap = new DependencyVersionMap().setUniqueVersions(uniqueVersions);\n        node.accept(dependencyVersionMap);\n\n        List<String> errorMsgs =\n                getConvergenceErrorMsgs(dependencyVersionMap.getConflictedVersionNumbers(includes, excludes));\n\n        if (!errorMsgs.isEmpty()) {\n            throw new EnforcerRuleException(\"Failed while enforcing releasability.\" + System.lineSeparator()\n                    + String.join(System.lineSeparator(), errorMsgs));\n        }\n    }\n\n    private StringBuilder buildTreeString(DependencyNode node) {\n        List<String> loc = new ArrayList<>();\n        DependencyNode currentNode = node;\n        while (currentNode != null) {\n            // ArtifactUtils.toArtifact(node) adds scope and optional information, if present\n            loc.add(ArtifactUtils.toArtifact(currentNode).toString());\n            currentNode = dependencyVersionMap.getParent(currentNode);\n        }\n        Collections.reverse(loc);\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < loc.size(); i++) {\n            for (int j = 0; j < i; j++) {\n                builder.append(\"  \");\n            }\n            builder.append(\"+-\").append(loc.get(i)).append(System.lineSeparator());\n        }\n        return builder;\n    }\n\n    private List<String> getConvergenceErrorMsgs(List<List<DependencyNode>> errors) {\n        List<String> errorMsgs = new ArrayList<>();\n        for (List<DependencyNode> nodeList : errors) {\n            errorMsgs.add(buildConvergenceErrorMsg(nodeList));\n        }\n        return errorMsgs;\n    }\n\n    private String buildConvergenceErrorMsg(List<DependencyNode> nodeList) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(System.lineSeparator())\n                .append(\"Dependency convergence error for \")\n                .append(nodeList.get(0).getArtifact().toString())\n                .append(\" paths to dependency are:\")\n                .append(System.lineSeparator());\n        if (nodeList.size() > 0) {\n            builder.append(buildTreeString(nodeList.get(0)));\n        }\n        for (DependencyNode node : nodeList.subList(1, nodeList.size())) {\n            builder.append(\"and\").append(System.lineSeparator()).append(buildTreeString(node));\n        }\n        return builder.toString();\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\n                \"DependencyConvergence[includes=%s, excludes=%s, uniqueVersions=%b]\",\n                includes, excludes, uniqueVersions);\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.maven.enforcer.rules.dependency;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\n\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rules.AbstractStandardEnforcerRule;\nimport org.apache.maven.enforcer.rules.dependency.selector.AllLevelsOptionalDependencySelector;\nimport org.apache.maven.enforcer.rules.dependency.selector.AllLevelsScopeDependencySelector;\nimport org.apache.maven.enforcer.rules.utils.ArtifactUtils;\nimport org.eclipse.aether.graph.DependencyNode;\nimport org.eclipse.aether.util.graph.selector.ExclusionDependencySelector;\n\nimport static org.apache.maven.artifact.Artifact.SCOPE_PROVIDED;\nimport static org.apache.maven.artifact.Artifact.SCOPE_TEST;\n\n/**\n * @author <a href=\"mailto:rex@e-hoffman.org\">Rex Hoffman<\/a>\n */\n@Named(\"dependencyConvergence\")\npublic final class DependencyConvergence extends AbstractStandardEnforcerRule {\n\n    private boolean uniqueVersions;\n\n    private List<String> includes;\n\n    private List<String> excludes;\n\n    private DependencyVersionMap dependencyVersionMap;\n\n    private final ResolveUtil resolveUtil;\n\n    @Inject\n    public DependencyConvergence(ResolveUtil resolveUtil) {\n        this.resolveUtil = Objects.requireNonNull(resolveUtil);\n    }\n\n    @Override\n    public void execute() throws EnforcerRuleException {\n\n        DependencyNode node = resolveUtil.resolveTransitiveDependenciesVerbose(\n                new AllLevelsOptionalDependencySelector(),\n                new AllLevelsScopeDependencySelector(SCOPE_TEST, SCOPE_PROVIDED),\n                new ExclusionDependencySelector());\n        dependencyVersionMap = new DependencyVersionMap().setUniqueVersions(uniqueVersions);\n        node.accept(dependencyVersionMap);\n\n        List<CharSequence> errorMsgs = new ArrayList<>(\n                getConvergenceErrorMsgs(dependencyVersionMap.getConflictedVersionNumbers(includes, excludes)));\n        for (CharSequence errorMsg : errorMsgs) {\n            getLog().warnOrError(errorMsg);\n        }\n        if (errorMsgs.size() > 0) {\n            throw new EnforcerRuleException(\n                    \"Failed while enforcing releasability. \" + \"See above detailed error message.\");\n        }\n    }\n\n    private StringBuilder buildTreeString(DependencyNode node) {\n        List<String> loc = new ArrayList<>();\n        DependencyNode currentNode = node;\n        while (currentNode != null) {\n            // ArtifactUtils.toArtifact(node) adds scope and optional information, if present\n            loc.add(ArtifactUtils.toArtifact(currentNode).toString());\n            currentNode = dependencyVersionMap.getParent(currentNode);\n        }\n        Collections.reverse(loc);\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < loc.size(); i++) {\n            for (int j = 0; j < i; j++) {\n                builder.append(\"  \");\n            }\n            builder.append(\"+-\").append(loc.get(i)).append(System.lineSeparator());\n        }\n        return builder;\n    }\n\n    private List<String> getConvergenceErrorMsgs(List<List<DependencyNode>> errors) {\n        List<String> errorMsgs = new ArrayList<>();\n        for (List<DependencyNode> nodeList : errors) {\n            errorMsgs.add(buildConvergenceErrorMsg(nodeList));\n        }\n        return errorMsgs;\n    }\n\n    private String buildConvergenceErrorMsg(List<DependencyNode> nodeList) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(System.lineSeparator())\n                .append(\"Dependency convergence error for \")\n                .append(nodeList.get(0).getArtifact().toString())\n                .append(\" paths to dependency are:\")\n                .append(System.lineSeparator());\n        if (nodeList.size() > 0) {\n            builder.append(buildTreeString(nodeList.get(0)));\n        }\n        for (DependencyNode node : nodeList.subList(1, nodeList.size())) {\n            builder.append(\"and\").append(System.lineSeparator()).append(buildTreeString(node));\n        }\n        return builder.toString();\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\n                \"DependencyConvergence[includes=%s, excludes=%s, uniqueVersions=%b]\",\n                includes, excludes, uniqueVersions);\n    }\n}\n","lineNo":78}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.maven.enforcer.rules.version;\n\nimport javax.inject.Named;\n\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.SystemUtils;\nimport org.apache.maven.artifact.versioning.ArtifactVersion;\nimport org.apache.maven.artifact.versioning.DefaultArtifactVersion;\nimport org.apache.maven.artifact.versioning.InvalidVersionSpecificationException;\nimport org.apache.maven.artifact.versioning.VersionRange;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * This rule checks that the Java version is allowed.\n *\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n */\n@Named(\"requireJavaVersion\")\npublic final class RequireJavaVersion extends AbstractVersionEnforcer {\n\n    private static final Pattern JDK8_VERSION_PATTERN = Pattern.compile(\"([\\\\[(,]?)(1\\\\.8|8)([]),]?)\");\n\n    /**\n     * Display the normalized JDK version.\n     */\n    private boolean display = false;\n\n    @Override\n    public void setVersion(String theVersion) {\n\n        if (\"8\".equals(theVersion)) {\n            super.setVersion(\"1.8\");\n            return;\n        }\n\n        Matcher matcher = JDK8_VERSION_PATTERN.matcher(theVersion);\n\n        StringBuffer result = new StringBuffer();\n        while (matcher.find()) {\n            matcher.appendReplacement(result, \"$11.8$3\");\n        }\n        matcher.appendTail(result);\n\n        super.setVersion(result.toString());\n    }\n\n    @Override\n    public void execute() throws EnforcerRuleException {\n        String javaVersion = SystemUtils.JAVA_VERSION;\n        String javaVersionNormalized = normalizeJDKVersion(javaVersion);\n        if (display) {\n            getLog().info(\"Detected Java Version: '\" + javaVersion + \"'\");\n            getLog().info(\"Normalized Java Version: '\" + javaVersionNormalized + \"'\");\n        } else {\n            getLog().debug(\"Detected Java Version: '\" + javaVersion + \"'\");\n            getLog().debug(\"Normalized Java Version: '\" + javaVersionNormalized + \"'\");\n        }\n\n        ArtifactVersion detectedJdkVersion = new DefaultArtifactVersion(javaVersionNormalized);\n\n        getLog().debug(\"Parsed Version: Major: \" + detectedJdkVersion.getMajorVersion() + \" Minor: \"\n                + detectedJdkVersion.getMinorVersion() + \" Incremental: \" + detectedJdkVersion.getIncrementalVersion()\n                + \" Build: \" + detectedJdkVersion.getBuildNumber() + \" Qualifier: \"\n                + detectedJdkVersion.getQualifier());\n\n        setCustomMessageIfNoneConfigured(detectedJdkVersion, getVersion());\n\n        enforceVersion(\"JDK\", getVersion(), detectedJdkVersion);\n    }\n\n    /**\n     * Converts a jdk string from 1.5.0-11b12 to a single 3 digit version like 1.5.0-11\n     *\n     * @param theJdkVersion to be converted.\n     * @return the converted string.\n     */\n    public static String normalizeJDKVersion(String theJdkVersion) {\n\n        theJdkVersion = theJdkVersion.replaceAll(\"_|-\", \".\");\n        String tokenArray[] = StringUtils.split(theJdkVersion, \".\");\n        List<String> tokens = Arrays.asList(tokenArray);\n        StringBuilder buffer = new StringBuilder(theJdkVersion.length());\n\n        Iterator<String> iter = tokens.iterator();\n        for (int i = 0; i < tokens.size() && i < 4; i++) {\n            String section = iter.next();\n            section = section.replaceAll(\"[^0-9]\", \"\");\n\n            if (StringUtils.isNotEmpty(section)) {\n                buffer.append(Integer.parseInt(section));\n\n                if (i != 2) {\n                    buffer.append('.');\n                } else {\n                    buffer.append('-');\n                }\n            }\n        }\n\n        String version = buffer.toString();\n        version = StringUtils.stripEnd(version, \"-\");\n        return StringUtils.stripEnd(version, \".\");\n    }\n\n    private void setCustomMessageIfNoneConfigured(ArtifactVersion detectedJdkVersion, String allowedVersionRange) {\n        if (getMessage() == null) {\n            String version;\n            try {\n                VersionRange vr = VersionRange.createFromVersionSpec(allowedVersionRange);\n                version = AbstractVersionEnforcer.toString(vr);\n            } catch (InvalidVersionSpecificationException e) {\n                getLog().debug(\"Could not parse allowed version range \" + allowedVersionRange + \" \" + e.getMessage());\n                version = allowedVersionRange;\n            }\n            String message = String.format(\n                    \"Detected JDK version %s (JAVA_HOME=%s) is not in the allowed range %s.\",\n                    detectedJdkVersion, SystemUtils.JAVA_HOME, version);\n            super.setMessage(message);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\n                \"%s[message=%s, version=%s, display=%b]\",\n                getClass().getSimpleName(), getMessage(), getVersion(), display);\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.maven.enforcer.rules.version;\n\nimport javax.inject.Named;\n\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.SystemUtils;\nimport org.apache.maven.artifact.versioning.ArtifactVersion;\nimport org.apache.maven.artifact.versioning.DefaultArtifactVersion;\nimport org.apache.maven.artifact.versioning.InvalidVersionSpecificationException;\nimport org.apache.maven.artifact.versioning.VersionRange;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * This rule checks that the Java version is allowed.\n *\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n */\n@Named(\"requireJavaVersion\")\npublic final class RequireJavaVersion extends AbstractVersionEnforcer {\n\n    private static final Pattern JDK8_VERSION_PATTERN = Pattern.compile(\"([\\\\[(,]?)(1\\\\.8|8)([]),]?)\");\n\n    @Override\n    public void setVersion(String theVersion) {\n\n        if (\"8\".equals(theVersion)) {\n            super.setVersion(\"1.8\");\n            return;\n        }\n\n        Matcher matcher = JDK8_VERSION_PATTERN.matcher(theVersion);\n\n        StringBuffer result = new StringBuffer();\n        while (matcher.find()) {\n            matcher.appendReplacement(result, \"$11.8$3\");\n        }\n        matcher.appendTail(result);\n\n        super.setVersion(result.toString());\n    }\n\n    @Override\n    public void execute() throws EnforcerRuleException {\n        String javaVersion = SystemUtils.JAVA_VERSION;\n\n        getLog().debug(\"Detected Java String: '\" + javaVersion + \"'\");\n        javaVersion = normalizeJDKVersion(javaVersion);\n        getLog().debug(\"Normalized Java String: '\" + javaVersion + \"'\");\n\n        ArtifactVersion detectedJdkVersion = new DefaultArtifactVersion(javaVersion);\n\n        getLog().debug(\"Parsed Version: Major: \" + detectedJdkVersion.getMajorVersion() + \" Minor: \"\n                + detectedJdkVersion.getMinorVersion() + \" Incremental: \" + detectedJdkVersion.getIncrementalVersion()\n                + \" Build: \" + detectedJdkVersion.getBuildNumber() + \" Qualifier: \"\n                + detectedJdkVersion.getQualifier());\n\n        setCustomMessageIfNoneConfigured(detectedJdkVersion, getVersion());\n\n        enforceVersion(\"JDK\", getVersion(), detectedJdkVersion);\n    }\n\n    /**\n     * Converts a jdk string from 1.5.0-11b12 to a single 3 digit version like 1.5.0-11\n     *\n     * @param theJdkVersion to be converted.\n     * @return the converted string.\n     */\n    public static String normalizeJDKVersion(String theJdkVersion) {\n\n        theJdkVersion = theJdkVersion.replaceAll(\"_|-\", \".\");\n        String tokenArray[] = StringUtils.split(theJdkVersion, \".\");\n        List<String> tokens = Arrays.asList(tokenArray);\n        StringBuilder buffer = new StringBuilder(theJdkVersion.length());\n\n        Iterator<String> iter = tokens.iterator();\n        for (int i = 0; i < tokens.size() && i < 4; i++) {\n            String section = iter.next();\n            section = section.replaceAll(\"[^0-9]\", \"\");\n\n            if (StringUtils.isNotEmpty(section)) {\n                buffer.append(Integer.parseInt(section));\n\n                if (i != 2) {\n                    buffer.append('.');\n                } else {\n                    buffer.append('-');\n                }\n            }\n        }\n\n        String version = buffer.toString();\n        version = StringUtils.stripEnd(version, \"-\");\n        return StringUtils.stripEnd(version, \".\");\n    }\n\n    private void setCustomMessageIfNoneConfigured(ArtifactVersion detectedJdkVersion, String allowedVersionRange) {\n        if (getMessage() == null) {\n            String version;\n            try {\n                VersionRange vr = VersionRange.createFromVersionSpec(allowedVersionRange);\n                version = AbstractVersionEnforcer.toString(vr);\n            } catch (InvalidVersionSpecificationException e) {\n                getLog().debug(\"Could not parse allowed version range \" + allowedVersionRange + \" \" + e.getMessage());\n                version = allowedVersionRange;\n            }\n            String message = String.format(\n                    \"Detected JDK version %s (JAVA_HOME=%s) is not in the allowed range %s.\",\n                    detectedJdkVersion, SystemUtils.JAVA_HOME, version);\n            super.setMessage(message);\n        }\n    }\n}\n","lineNo":74}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.maven.plugins.enforcer;\n\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.SystemUtils;\nimport org.apache.maven.artifact.versioning.ArtifactVersion;\nimport org.apache.maven.artifact.versioning.DefaultArtifactVersion;\nimport org.apache.maven.artifact.versioning.InvalidVersionSpecificationException;\nimport org.apache.maven.artifact.versioning.VersionRange;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.plugin.logging.Log;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * This rule checks that the Java version is allowed.\n *\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n */\npublic class RequireJavaVersion extends AbstractVersionEnforcer {\n\n    private static final Pattern JDK8_VERSION_PATTERN = Pattern.compile(\"([\\\\[(,]?)(1\\\\.8|8)([]),]?)\");\n\n    @Override\n    public void setVersion(String theVersion) {\n\n        if (\"8\".equals(theVersion)) {\n            super.setVersion(\"1.8\");\n            return;\n        }\n\n        Matcher matcher = JDK8_VERSION_PATTERN.matcher(theVersion);\n\n        StringBuffer result = new StringBuffer();\n        while (matcher.find()) {\n            matcher.appendReplacement(result, \"$11.8$3\");\n        }\n        matcher.appendTail(result);\n\n        super.setVersion(result.toString());\n    }\n\n    @Override\n    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n        String javaVersion = SystemUtils.JAVA_VERSION;\n        Log log = helper.getLog();\n\n        log.debug(\"Detected Java String: '\" + javaVersion + \"'\");\n        javaVersion = normalizeJDKVersion(javaVersion);\n        log.debug(\"Normalized Java String: '\" + javaVersion + \"'\");\n\n        ArtifactVersion detectedJdkVersion = new DefaultArtifactVersion(javaVersion);\n\n        log.debug(\"Parsed Version: Major: \" + detectedJdkVersion.getMajorVersion() + \" Minor: \"\n                + detectedJdkVersion.getMinorVersion() + \" Incremental: \" + detectedJdkVersion.getIncrementalVersion()\n                + \" Build: \" + detectedJdkVersion.getBuildNumber() + \" Qualifier: \"\n                + detectedJdkVersion.getQualifier());\n\n        setCustomMessageIfNoneConfigured(detectedJdkVersion, getVersion(), log);\n\n        enforceVersion(helper.getLog(), \"JDK\", getVersion(), detectedJdkVersion);\n    }\n\n    /**\n     * Converts a jdk string from 1.5.0-11b12 to a single 3 digit version like 1.5.0-11\n     *\n     * @param theJdkVersion to be converted.\n     * @return the converted string.\n     */\n    public static String normalizeJDKVersion(String theJdkVersion) {\n\n        theJdkVersion = theJdkVersion.replaceAll(\"_|-\", \".\");\n        String tokenArray[] = StringUtils.split(theJdkVersion, \".\");\n        List<String> tokens = Arrays.asList(tokenArray);\n        StringBuilder buffer = new StringBuilder(theJdkVersion.length());\n\n        Iterator<String> iter = tokens.iterator();\n        for (int i = 0; i < tokens.size() && i < 4; i++) {\n            String section = iter.next();\n            section = section.replaceAll(\"[^0-9]\", \"\");\n\n            if (StringUtils.isNotEmpty(section)) {\n                buffer.append(Integer.parseInt(section));\n\n                if (i != 2) {\n                    buffer.append('.');\n                } else {\n                    buffer.append('-');\n                }\n            }\n        }\n\n        String version = buffer.toString();\n        version = StringUtils.stripEnd(version, \"-\");\n        return StringUtils.stripEnd(version, \".\");\n    }\n\n    private void setCustomMessageIfNoneConfigured(\n            ArtifactVersion detectedJdkVersion, String allowedVersionRange, Log log) {\n        if (getMessage() == null) {\n            String version;\n            try {\n                VersionRange vr = VersionRange.createFromVersionSpec(allowedVersionRange);\n                version = AbstractVersionEnforcer.toString(vr);\n            } catch (InvalidVersionSpecificationException e) {\n                log.debug(\"Could not parse allowed version range \" + allowedVersionRange, e);\n                version = allowedVersionRange;\n            }\n            String message = String.format(\n                    \"Detected JDK version %s (JAVA_HOME=%s) is not in the allowed range %s.\",\n                    detectedJdkVersion, SystemUtils.JAVA_HOME, version);\n            super.setMessage(message);\n        }\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.maven.plugins.enforcer;\n\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.SystemUtils;\nimport org.apache.maven.artifact.versioning.ArtifactVersion;\nimport org.apache.maven.artifact.versioning.DefaultArtifactVersion;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.plugin.logging.Log;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * This rule checks that the Java version is allowed.\n *\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n */\npublic class RequireJavaVersion extends AbstractVersionEnforcer {\n\n    private static final Pattern JDK8_VERSION_PATTERN = Pattern.compile(\"([\\\\[(,]?)(1\\\\.8|8)([]),]?)\");\n\n    @Override\n    public void setVersion(String theVersion) {\n\n        if (\"8\".equals(theVersion)) {\n            super.setVersion(\"1.8\");\n            return;\n        }\n\n        Matcher matcher = JDK8_VERSION_PATTERN.matcher(theVersion);\n\n        StringBuffer result = new StringBuffer();\n        while (matcher.find()) {\n            matcher.appendReplacement(result, \"$11.8$3\");\n        }\n        matcher.appendTail(result);\n\n        super.setVersion(result.toString());\n    }\n\n    @Override\n    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n        String javaVersion = SystemUtils.JAVA_VERSION;\n        Log log = helper.getLog();\n\n        log.debug(\"Detected Java String: '\" + javaVersion + \"'\");\n        javaVersion = normalizeJDKVersion(javaVersion);\n        log.debug(\"Normalized Java String: '\" + javaVersion + \"'\");\n\n        ArtifactVersion detectedJdkVersion = new DefaultArtifactVersion(javaVersion);\n\n        log.debug(\"Parsed Version: Major: \" + detectedJdkVersion.getMajorVersion() + \" Minor: \"\n                + detectedJdkVersion.getMinorVersion() + \" Incremental: \" + detectedJdkVersion.getIncrementalVersion()\n                + \" Build: \" + detectedJdkVersion.getBuildNumber() + \" Qualifier: \"\n                + detectedJdkVersion.getQualifier());\n\n        setCustomMessageIfNoneConfigured(detectedJdkVersion, getVersion());\n\n        enforceVersion(helper.getLog(), \"JDK\", getVersion(), detectedJdkVersion);\n    }\n\n    /**\n     * Converts a jdk string from 1.5.0-11b12 to a single 3 digit version like 1.5.0-11\n     *\n     * @param theJdkVersion to be converted.\n     * @return the converted string.\n     */\n    public static String normalizeJDKVersion(String theJdkVersion) {\n\n        theJdkVersion = theJdkVersion.replaceAll(\"_|-\", \".\");\n        String tokenArray[] = StringUtils.split(theJdkVersion, \".\");\n        List<String> tokens = Arrays.asList(tokenArray);\n        StringBuilder buffer = new StringBuilder(theJdkVersion.length());\n\n        Iterator<String> iter = tokens.iterator();\n        for (int i = 0; i < tokens.size() && i < 4; i++) {\n            String section = iter.next();\n            section = section.replaceAll(\"[^0-9]\", \"\");\n\n            if (StringUtils.isNotEmpty(section)) {\n                buffer.append(Integer.parseInt(section));\n\n                if (i != 2) {\n                    buffer.append('.');\n                } else {\n                    buffer.append('-');\n                }\n            }\n        }\n\n        String version = buffer.toString();\n        version = StringUtils.stripEnd(version, \"-\");\n        return StringUtils.stripEnd(version, \".\");\n    }\n\n    private void setCustomMessageIfNoneConfigured(ArtifactVersion detectedJdkVersion, String allowedVersionRange) {\n        if (getMessage() == null) {\n            String message = String.format(\n                    \"Detected JDK version %s (JAVA_HOME=%s) is not in the allowed range %s.\",\n                    detectedJdkVersion, SystemUtils.JAVA_HOME, allowedVersionRange);\n            super.setMessage(message);\n        }\n    }\n}\n","lineNo":123}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.maven.plugins.enforcer;\n\nimport static java.util.Arrays.asList;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nimport java.util.Properties;\nimport org.apache.maven.RepositoryUtils;\nimport org.apache.maven.artifact.handler.DefaultArtifactHandler;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.execution.MavenExecutionRequest;\nimport org.apache.maven.execution.MavenExecutionResult;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.InputLocation;\nimport org.apache.maven.model.InputSource;\nimport org.apache.maven.model.Plugin;\nimport org.apache.maven.plugin.MojoExecution;\nimport org.apache.maven.plugin.PluginParameterExpressionEvaluator;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.logging.SystemStreamLog;\nimport org.apache.maven.plugins.enforcer.utils.MockEnforcerExpressionEvaluator;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.ProjectBuildingRequest;\nimport org.codehaus.plexus.PlexusContainer;\nimport org.codehaus.plexus.classworlds.ClassWorld;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluator;\nimport org.eclipse.aether.DefaultRepositorySystemSession;\nimport org.eclipse.aether.RepositorySystem;\nimport org.eclipse.aether.artifact.ArtifactType;\nimport org.eclipse.aether.artifact.DefaultArtifact;\nimport org.eclipse.aether.collection.CollectRequest;\nimport org.eclipse.aether.collection.CollectResult;\nimport org.eclipse.aether.collection.DependencyCollectionException;\nimport org.eclipse.aether.graph.DefaultDependencyNode;\nimport org.eclipse.aether.graph.DependencyNode;\n\n/**\n * The Class EnforcerTestUtils.\n *\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n */\npublic final class EnforcerTestUtils {\n    /**\n     * Gets the maven session.\n     *\n     * @return the maven session\n     */\n    public static MavenSession getMavenSession() {\n        PlexusContainer mock = mock(PlexusContainer.class);\n\n        MavenExecutionRequest mer = mock(MavenExecutionRequest.class);\n        ProjectBuildingRequest buildingRequest = mock(ProjectBuildingRequest.class);\n        when(buildingRequest.setRepositorySession(any())).thenReturn(buildingRequest);\n        when(mer.getProjectBuildingRequest()).thenReturn(buildingRequest);\n\n        Properties systemProperties = new Properties();\n        systemProperties.put(\"maven.version\", \"3.0\");\n        when(mer.getUserProperties()).thenReturn(new Properties());\n        when(mer.getSystemProperties()).thenReturn(systemProperties);\n\n        MavenExecutionResult meResult = mock(MavenExecutionResult.class);\n\n        return new MavenSession(mock, new DefaultRepositorySystemSession(), mer, meResult);\n    }\n\n    /**\n     * Gets the helper.\n     *\n     * @return the helper\n     */\n    public static EnforcerRuleHelper getHelper() {\n        return getHelper(new MockProject(), false);\n    }\n\n    /**\n     * Gets the helper.\n     *\n     * @param mockExpression the mock expression\n     * @return the helper\n     */\n    public static EnforcerRuleHelper getHelper(boolean mockExpression) {\n        return getHelper(new MockProject(), mockExpression);\n    }\n\n    /**\n     * Gets the helper.\n     *\n     * @param project the project\n     * @return the helper\n     */\n    public static EnforcerRuleHelper getHelper(MavenProject project) {\n        return getHelper(project, false);\n    }\n\n    private static RepositorySystem mockRepositorySystem() throws DependencyCollectionException {\n        ArtifactType jarType = RepositoryUtils.newArtifactType(\"jar\", new DefaultArtifactHandler(\"jar\"));\n        final DependencyNode node = new DefaultDependencyNode(\n                new DefaultArtifact(\"groupId\", \"artifactId\", \"classifier\", \"jar\", \"version\", jarType));\n        node.setChildren(asList(\n                new DefaultDependencyNode(\n                        new DefaultArtifact(\"groupId\", \"artifact\", \"classifier\", \"jar\", \"1.0.0\", jarType)),\n                new DefaultDependencyNode(\n                        new DefaultArtifact(\"groupId\", \"artifact\", \"classifier\", \"jar\", \"2.0.0\", jarType))));\n\n        RepositorySystem mockRepositorySystem = mock(RepositorySystem.class);\n        when(mockRepositorySystem.collectDependencies(any(), any(CollectRequest.class)))\n                .then(i -> new CollectResult(i.getArgument(1)).setRoot(node));\n        return mockRepositorySystem;\n    }\n\n    /**\n     * Gets the helper.\n     *\n     * @param project the project\n     * @param mockExpression the mock expression\n     * @return the helper\n     */\n    public static EnforcerRuleHelper getHelper(MavenProject project, boolean mockExpression) {\n        try {\n            MavenSession session = getMavenSession();\n            MojoExecution mockExecution = mock(MojoExecution.class);\n            ExpressionEvaluator eval;\n            if (mockExpression) {\n                eval = new MockEnforcerExpressionEvaluator(session);\n            } else {\n                session.setCurrentProject(project);\n                eval = new PluginParameterExpressionEvaluator(session, mockExecution);\n            }\n\n            PlexusContainer container = mock(PlexusContainer.class);\n            when(container.lookup(RepositorySystem.class)).then(i -> mockRepositorySystem());\n\n            ClassWorld classWorld = new ClassWorld(\"test\", EnforcerTestUtils.class.getClassLoader());\n            MojoDescriptor mojoDescriptor = new MojoDescriptor();\n            mojoDescriptor.setRealm(classWorld.getClassRealm(\"test\"));\n            when(mockExecution.getMojoDescriptor()).thenReturn(mojoDescriptor);\n            when(container.lookup(MojoExecution.class)).thenReturn(mockExecution);\n            return new DefaultEnforcementRuleHelper(session, eval, new SystemStreamLog(), container);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Gets the helper.\n     *\n     * @param project the project\n     * @param eval the expression evaluator to use\n     * @return the helper\n     */\n    public static EnforcerRuleHelper getHelper(MavenProject project, ExpressionEvaluator eval) {\n        MavenSession session = getMavenSession();\n        return new DefaultEnforcementRuleHelper(session, eval, new SystemStreamLog(), null);\n    }\n\n    /**\n     * New plugin.\n     *\n     * @param groupId the group id\n     * @param artifactId the artifact id\n     * @param version the version\n     * @return the plugin\n     */\n    public static Plugin newPlugin(String groupId, String artifactId, String version) {\n        InputSource inputSource = new InputSource();\n        inputSource.setModelId(\"unit\");\n\n        Plugin plugin = new Plugin();\n        plugin.setArtifactId(artifactId);\n        plugin.setGroupId(groupId);\n        plugin.setVersion(version);\n        plugin.setLocation(\"version\", new InputLocation(0, 0, inputSource));\n        return plugin;\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.maven.plugins.enforcer;\n\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Properties;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.DefaultArtifact;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.execution.MavenExecutionRequest;\nimport org.apache.maven.execution.MavenExecutionResult;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.InputLocation;\nimport org.apache.maven.model.InputSource;\nimport org.apache.maven.model.Plugin;\nimport org.apache.maven.plugin.MojoExecution;\nimport org.apache.maven.plugin.PluginParameterExpressionEvaluator;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.logging.SystemStreamLog;\nimport org.apache.maven.plugins.enforcer.utils.MockEnforcerExpressionEvaluator;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.ProjectBuildingRequest;\nimport org.apache.maven.shared.dependency.graph.DependencyCollectorBuilder;\nimport org.apache.maven.shared.dependency.graph.internal.DefaultDependencyNode;\nimport org.codehaus.plexus.PlexusContainer;\nimport org.codehaus.plexus.classworlds.ClassWorld;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluator;\nimport org.codehaus.plexus.component.repository.exception.ComponentLookupException;\nimport org.mockito.Mockito;\n\n/**\n * The Class EnforcerTestUtils.\n *\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n */\npublic final class EnforcerTestUtils {\n    /**\n     * Gets the maven session.\n     *\n     * @return the maven session\n     */\n    public static MavenSession getMavenSession() {\n        PlexusContainer mock = mock(PlexusContainer.class);\n\n        MavenExecutionRequest mer = mock(MavenExecutionRequest.class);\n        ProjectBuildingRequest buildingRequest = mock(ProjectBuildingRequest.class);\n        when(buildingRequest.setRepositorySession(any())).thenReturn(buildingRequest);\n        when(mer.getProjectBuildingRequest()).thenReturn(buildingRequest);\n\n        Properties systemProperties = new Properties();\n        systemProperties.put(\"maven.version\", \"3.0\");\n        when(mer.getUserProperties()).thenReturn(new Properties());\n        when(mer.getSystemProperties()).thenReturn(systemProperties);\n\n        MavenExecutionResult meresult = mock(MavenExecutionResult.class);\n        return new MavenSession(mock, null, mer, meresult);\n    }\n\n    /**\n     * Gets the helper.\n     *\n     * @return the helper\n     */\n    public static EnforcerRuleHelper getHelper() {\n        return getHelper(new MockProject(), false);\n    }\n\n    /**\n     * Gets the helper.\n     *\n     * @param mockExpression the mock expression\n     * @return the helper\n     */\n    public static EnforcerRuleHelper getHelper(boolean mockExpression) {\n        return getHelper(new MockProject(), mockExpression);\n    }\n\n    /**\n     * Gets the helper.\n     *\n     * @param project the project\n     * @return the helper\n     */\n    public static EnforcerRuleHelper getHelper(MavenProject project) {\n        return getHelper(project, false);\n    }\n\n    /**\n     * Gets the helper.\n     *\n     * @param project the project\n     * @param mockExpression the mock expression\n     * @return the helper\n     */\n    public static EnforcerRuleHelper getHelper(MavenProject project, boolean mockExpression) {\n        MavenSession session = getMavenSession();\n        MojoExecution mockExecution = mock(MojoExecution.class);\n        ExpressionEvaluator eval;\n        if (mockExpression) {\n            eval = new MockEnforcerExpressionEvaluator(session);\n        } else {\n            session.setCurrentProject(project);\n            eval = new PluginParameterExpressionEvaluator(session, mockExecution);\n        }\n        PlexusContainer container = Mockito.mock(PlexusContainer.class);\n\n        Artifact artifact =\n                new DefaultArtifact(\"groupId\", \"artifactId\", \"version\", \"compile\", \"jar\", \"classifier\", null);\n        Artifact v1 = new DefaultArtifact(\"groupId\", \"artifact\", \"1.0.0\", \"compile\", \"jar\", \"\", null);\n        Artifact v2 = new DefaultArtifact(\"groupId\", \"artifact\", \"2.0.0\", \"compile\", \"jar\", \"\", null);\n        final DefaultDependencyNode node = new DefaultDependencyNode(artifact);\n        DefaultDependencyNode child1 = new DefaultDependencyNode(node, v1, null, null, null);\n        child1.setChildren(Collections.emptyList());\n        DefaultDependencyNode child2 = new DefaultDependencyNode(node, v2, null, null, null);\n        child2.setChildren(Collections.emptyList());\n        node.setChildren(Arrays.asList(child1, child2));\n\n        try {\n            when(container.lookup(DependencyCollectorBuilder.class)).thenReturn((buildingRequest, filter) -> node);\n        } catch (ComponentLookupException e) {\n            // test will fail\n        }\n        ClassWorld classWorld = new ClassWorld(\"test\", EnforcerTestUtils.class.getClassLoader());\n        MojoDescriptor mojoDescriptor = new MojoDescriptor();\n        mojoDescriptor.setRealm(classWorld.getClassRealm(\"test\"));\n        when(mockExecution.getMojoDescriptor()).thenReturn(mojoDescriptor);\n        try {\n            when(container.lookup(MojoExecution.class)).thenReturn(mockExecution);\n        } catch (ComponentLookupException e) {\n            // test will fail\n        }\n        return new DefaultEnforcementRuleHelper(session, eval, new SystemStreamLog(), container);\n    }\n\n    /**\n     * Gets the helper.\n     *\n     * @param project the project\n     * @param eval the expression evaluator to use\n     * @return the helper\n     */\n    public static EnforcerRuleHelper getHelper(MavenProject project, ExpressionEvaluator eval) {\n        MavenSession session = getMavenSession();\n        return new DefaultEnforcementRuleHelper(session, eval, new SystemStreamLog(), null);\n    }\n\n    /**\n     * New plugin.\n     *\n     * @param groupId the group id\n     * @param artifactId the artifact id\n     * @param version the version\n     * @return the plugin\n     */\n    public static Plugin newPlugin(String groupId, String artifactId, String version) {\n        InputSource inputSource = new InputSource();\n        inputSource.setModelId(\"unit\");\n\n        Plugin plugin = new Plugin();\n        plugin.setArtifactId(artifactId);\n        plugin.setGroupId(groupId);\n        plugin.setVersion(version);\n        plugin.setLocation(\"version\", new InputLocation(0, 0, inputSource));\n        return plugin;\n    }\n}\n","lineNo":124}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.maven.plugins.enforcer.utils;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.shared.dependency.graph.DependencyNode;\nimport org.apache.maven.shared.dependency.graph.traversal.DependencyNodeVisitor;\n\n/**\n * @author Brian Fox\n *\n */\npublic class DependencyVersionMap implements DependencyNodeVisitor {\n    private boolean uniqueVersions;\n\n    private Map<String, List<DependencyNode>> idsToNode;\n\n    public DependencyVersionMap(Log log) {\n        idsToNode = new HashMap<>();\n    }\n\n    public void setUniqueVersions(boolean uniqueVersions) {\n        this.uniqueVersions = uniqueVersions;\n    }\n\n    @Override\n    public boolean visit(DependencyNode node) {\n        addDependency(node);\n        return !containsConflicts(node);\n    }\n\n    @Override\n    public boolean endVisit(DependencyNode node) {\n        return true;\n    }\n\n    private String constructKey(DependencyNode node) {\n        return constructKey(node.getArtifact());\n    }\n\n    private String constructKey(Artifact artifact) {\n        return artifact.getGroupId() + \":\" + artifact.getArtifactId();\n    }\n\n    public void addDependency(DependencyNode node) {\n        String key = constructKey(node);\n        List<DependencyNode> nodes = idsToNode.get(key);\n        if (nodes == null) {\n            nodes = new ArrayList<>();\n            idsToNode.put(key, nodes);\n        }\n        nodes.add(node);\n    }\n\n    private String getVersion(Artifact artifact) {\n        return uniqueVersions ? artifact.getVersion() : artifact.getBaseVersion();\n    }\n\n    private boolean containsConflicts(DependencyNode node) {\n        return containsConflicts(node.getArtifact());\n    }\n\n    private boolean containsConflicts(Artifact artifact) {\n        return containsConflicts(idsToNode.get(constructKey(artifact)));\n    }\n\n    private boolean containsConflicts(List<DependencyNode> nodes) {\n        String version = null;\n        for (DependencyNode node : nodes) {\n            if (version == null) {\n                version = getVersion(node.getArtifact());\n            } else {\n                if (version.compareTo(getVersion(node.getArtifact())) != 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public List<List<DependencyNode>> getConflictedVersionNumbers(List<String> includes, List<String> excludes)\n            throws EnforcerRuleException {\n        List<String> formattedIncludes = formatPatterns(includes);\n        List<String> formattedExcludes = formatPatterns(excludes);\n        List<List<DependencyNode>> output = new ArrayList<>();\n        for (List<DependencyNode> nodes : idsToNode.values()) {\n            List<DependencyNode> filteredNodes = nodes;\n            if (formattedIncludes != null || formattedExcludes != null) {\n                filteredNodes = new ArrayList<>();\n                for (DependencyNode node : nodes) {\n                    if (includeArtifact(node.getArtifact(), formattedIncludes, formattedExcludes)) {\n                        filteredNodes.add(node);\n                    }\n                }\n            }\n            if (containsConflicts(filteredNodes)) {\n                output.add(filteredNodes);\n            }\n        }\n        return output;\n    }\n\n    private static boolean includeArtifact(Artifact artifact, List<String> includes, List<String> excludes)\n            throws EnforcerRuleException {\n        boolean included = includes == null || includes.isEmpty();\n        if (!included) {\n            for (String pattern : includes) {\n                if (ArtifactUtils.compareDependency(pattern, artifact)) {\n                    included = true;\n                    break;\n                }\n            }\n        }\n        if (!included) {\n            return false;\n        }\n        boolean excluded = false;\n        if (excludes != null) {\n            for (String pattern : excludes) {\n                if (ArtifactUtils.compareDependency(pattern, artifact)) {\n                    excluded = true;\n                    break;\n                }\n            }\n        }\n        return !excluded;\n    }\n\n    private static List<String> formatPatterns(List<String> patterns) {\n        if (patterns == null) {\n            return null;\n        }\n        List<String> formattedPatterns = new ArrayList<>();\n        for (String pattern : patterns) {\n            String[] subStrings = pattern.split(\":\");\n            subStrings = StringUtils.stripAll(subStrings);\n            String formattedPattern = StringUtils.join(subStrings, \":\");\n            formattedPatterns.add(formattedPattern);\n        }\n        return formattedPatterns;\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.maven.plugins.enforcer.utils;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.shared.dependency.graph.DependencyNode;\nimport org.apache.maven.shared.dependency.graph.traversal.DependencyNodeVisitor;\n\n/**\n * @author Brian Fox\n *\n */\npublic class DependencyVersionMap implements DependencyNodeVisitor {\n    private boolean uniqueVersions;\n\n    private Map<String, List<DependencyNode>> idsToNode;\n\n    public DependencyVersionMap(Log log) {\n        idsToNode = new HashMap<>();\n    }\n\n    public void setUniqueVersions(boolean uniqueVersions) {\n        this.uniqueVersions = uniqueVersions;\n    }\n\n    @Override\n    public boolean visit(DependencyNode node) {\n        addDependency(node);\n        return !containsConflicts(node);\n    }\n\n    @Override\n    public boolean endVisit(DependencyNode node) {\n        return true;\n    }\n\n    private String constructKey(DependencyNode node) {\n        return constructKey(node.getArtifact());\n    }\n\n    private String constructKey(Artifact artifact) {\n        return artifact.getGroupId() + \":\" + artifact.getArtifactId();\n    }\n\n    public void addDependency(DependencyNode node) {\n        String key = constructKey(node);\n        List<DependencyNode> nodes = idsToNode.get(key);\n        if (nodes == null) {\n            nodes = new ArrayList<>();\n            idsToNode.put(key, nodes);\n        }\n        nodes.add(node);\n    }\n\n    private String getVersion(Artifact artifact) {\n        return uniqueVersions ? artifact.getVersion() : artifact.getBaseVersion();\n    }\n\n    private boolean containsConflicts(DependencyNode node) {\n        return containsConflicts(node.getArtifact());\n    }\n\n    private boolean containsConflicts(Artifact artifact) {\n        return containsConflicts(idsToNode.get(constructKey(artifact)));\n    }\n\n    private boolean containsConflicts(List<DependencyNode> nodes) {\n        String version = null;\n        for (DependencyNode node : nodes) {\n            if (version == null) {\n                version = getVersion(node.getArtifact());\n            } else {\n                if (version.compareTo(getVersion(node.getArtifact())) != 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public List<List<DependencyNode>> getConflictedVersionNumbers() {\n        List<List<DependencyNode>> output = new ArrayList<>();\n        for (List<DependencyNode> nodes : idsToNode.values()) {\n            if (containsConflicts(nodes)) {\n                output.add(nodes);\n            }\n        }\n        return output;\n    }\n}\n","lineNo":129}
{"Refactored Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.metadata.ArtifactMetadataSource;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactCollector;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.versioning.ArtifactVersion;\nimport org.apache.maven.artifact.versioning.DefaultArtifactVersion;\nimport org.apache.maven.artifact.versioning.OverConstrainedVersionException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.shared.dependency.tree.DependencyNode;\nimport org.apache.maven.shared.dependency.tree.DependencyTreeBuilder;\nimport org.apache.maven.shared.dependency.tree.DependencyTreeBuilderException;\nimport org.apache.maven.shared.dependency.tree.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.utils.logging.MessageUtils;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\nimport org.codehaus.plexus.component.repository.exception.ComponentLookupException;\n\n/**\n * Rule to enforce that the resolved dependency is also the most recent one of all transitive dependencies.\n *\n * @author Geoffrey De Smet\n * @since 1.1\n */\npublic class RequireUpperBoundDeps\n    extends AbstractNonCacheableEnforcerRule\n{\n    private static Log log;\n\n    /**\n     * @since 1.3\n     */\n    private boolean uniqueVersions;\n\n    /**\n     * Dependencies to ignore.\n     *\n     * @since TBD\n     */\n    private List<String> excludes = null;\n\n    /**\n     * Dependencies to include.\n     *\n     * @since 3.0.0\n     */\n    private List<String> includes = null;\n\n    /**\n     * Set to {@code true} if timestamped snapshots should be used.\n     *\n     * @param uniqueVersions\n     * @since 1.3\n     */\n    public void setUniqueVersions( boolean uniqueVersions )\n    {\n        this.uniqueVersions = uniqueVersions;\n    }\n\n    /**\n     * Sets dependencies to exclude.\n     * @param excludes a list of {@code groupId:artifactId} names\n     */\n    public void setExcludes( List<String> excludes )\n    {\n        this.excludes = excludes;\n    }\n\n    /**\n     * Sets dependencies to include.\n     *\n     * @param includes a list of {@code groupId:artifactId} names\n     */\n    public void setIncludes( List<String> includes )\n    {\n        this.includes = includes;\n    }\n\n    // CHECKSTYLE_OFF: LineLength\n    /**\n     * Uses the {@link EnforcerRuleHelper} to populate the values of the\n     * {@link DependencyTreeBuilder#buildDependencyTree(MavenProject, ArtifactRepository, ArtifactFactory, ArtifactMetadataSource, ArtifactFilter, ArtifactCollector)}\n     * factory method. <br/>\n     * This method simply exists to hide all the ugly lookup that the {@link EnforcerRuleHelper} has to do.\n     *\n     * @param helper\n     * @return a Dependency Node which is the root of the project's dependency tree\n     * @throws EnforcerRuleException when the build should fail\n     */\n    // CHECKSTYLE_ON: LineLength\n    private DependencyNode getNode( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        try\n        {\n            MavenProject project = (MavenProject) helper.evaluate( \"${project}\" );\n            DependencyTreeBuilder dependencyTreeBuilder = helper.getComponent( DependencyTreeBuilder.class );\n            ArtifactRepository repository = (ArtifactRepository) helper.evaluate( \"${localRepository}\" );\n            ArtifactFactory factory = helper.getComponent( ArtifactFactory.class );\n            ArtifactMetadataSource metadataSource = helper.getComponent( ArtifactMetadataSource.class );\n            ArtifactCollector collector = helper.getComponent( ArtifactCollector.class );\n            ArtifactFilter filter = null; // we need to evaluate all scopes\n            DependencyNode node =\n                dependencyTreeBuilder.buildDependencyTree( project, repository, factory, metadataSource, filter,\n                                                           collector );\n            return node;\n        }\n        catch ( ExpressionEvaluationException e )\n        {\n            throw new EnforcerRuleException( \"Unable to lookup an expression \" + e.getLocalizedMessage(), e );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new EnforcerRuleException( \"Unable to lookup a component \" + e.getLocalizedMessage(), e );\n        }\n        catch ( DependencyTreeBuilderException e )\n        {\n            throw new EnforcerRuleException( \"Could not build dependency tree \" + e.getLocalizedMessage(), e );\n        }\n    }\n\n    @Override\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        if ( log == null )\n        {\n            log = helper.getLog();\n        }\n        DependencyNode node = getNode( helper );\n        RequireUpperBoundDepsVisitor visitor = new RequireUpperBoundDepsVisitor();\n        visitor.setUniqueVersions( uniqueVersions );\n        visitor.setIncludes( includes );\n        node.accept( visitor );\n        List<String> errorMessages = buildErrorMessages( visitor.getConflicts() );\n        if ( errorMessages.size() > 0 )\n        {\n            throw new EnforcerRuleException( \"Failed while enforcing RequireUpperBoundDeps. The error(s) are \"\n                + errorMessages );\n        }\n    }\n\n    private List<String> buildErrorMessages( List<List<DependencyNode>> conflicts )\n    {\n        List<String> errorMessages = new ArrayList<>( conflicts.size() );\n        for ( List<DependencyNode> conflict : conflicts )\n        {\n            Artifact artifact = conflict.get( 0 ).getArtifact();\n            String groupArt = artifact.getGroupId() + \":\" + artifact.getArtifactId();\n            if ( excludes != null && excludes.contains( groupArt ) )\n            {\n                log.info( \"Ignoring requireUpperBoundDeps in \" + groupArt );\n            }\n            else\n            {\n                errorMessages.add( buildErrorMessage( conflict ) );\n            }\n        }\n        return errorMessages;\n    }\n\n    private String buildErrorMessage( List<DependencyNode> conflict )\n    {\n        StringBuilder errorMessage = new StringBuilder();\n        errorMessage.append(\n                System.lineSeparator() + \"Require upper bound dependencies error for \" + getFullArtifactName(\n                        conflict.get( 0 ), false ) + \" paths to dependency are:\" + System.lineSeparator() );\n        if ( conflict.size() > 0 )\n        {\n            errorMessage.append( buildTreeString( conflict.get( 0 ) ) );\n        }\n        for ( DependencyNode node : conflict.subList( 1, conflict.size() ) )\n        {\n            errorMessage.append( \"and\" + System.lineSeparator() );\n            errorMessage.append( buildTreeString( node ) );\n        }\n        return errorMessage.toString();\n    }\n\n    private StringBuilder buildTreeString( DependencyNode node )\n    {\n        List<String> loc = new ArrayList<>();\n        DependencyNode currentNode = node;\n        while ( currentNode != null )\n        {\n            StringBuilder line = new StringBuilder( getFullArtifactName( currentNode, false ) );\n\n            if ( currentNode.getPremanagedVersion() != null )\n            {\n                line.append( \" (managed) <-- \" );\n                line.append( getFullArtifactName( currentNode, true ) );\n            }\n\n            loc.add( line.toString() );\n            currentNode = currentNode.getParent();\n        }\n        Collections.reverse( loc );\n        StringBuilder builder = new StringBuilder();\n        for ( int i = 0; i < loc.size(); i++ )\n        {\n            for ( int j = 0; j < i; j++ )\n            {\n                builder.append( \"  \" );\n            }\n            builder.append( \"+-\" ).append( loc.get( i ) );\n            builder.append( System.lineSeparator() );\n        }\n        return builder;\n    }\n\n    private String getFullArtifactName( DependencyNode node, boolean usePremanaged )\n    {\n        Artifact artifact = node.getArtifact();\n\n        String version = node.getPremanagedVersion();\n        if ( !usePremanaged || version == null )\n        {\n            version = uniqueVersions ? artifact.getVersion() : artifact.getBaseVersion();\n        }\n        String result = artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\" + version;\n\n        String classifier = artifact.getClassifier();\n        if ( classifier != null && !classifier.isEmpty() )\n        {\n            result += \":\" + classifier;\n        }\n  \n        String scope = artifact.getScope();      \n        if ( \"compile\".equals( scope ) )\n        {\n            result = MessageUtils.buffer().strong( result ).toString();\n        }\n        else if ( scope != null )\n        {\n            result += \" [\" + scope + ']';\n        }\n        \n        return result;\n    }\n\n    private static class RequireUpperBoundDepsVisitor\n        implements DependencyNodeVisitor\n    {\n\n        private boolean uniqueVersions;\n\n        private List<String> includes = null;\n\n        public void setUniqueVersions( boolean uniqueVersions )\n        {\n            this.uniqueVersions = uniqueVersions;\n        }\n\n        public void setIncludes( List<String> includes )\n        {\n            this.includes = includes;\n        }\n\n        private Map<String, List<DependencyNodeHopCountPair>> keyToPairsMap = new LinkedHashMap<>();\n\n        public boolean visit( DependencyNode node )\n        {\n            DependencyNodeHopCountPair pair = new DependencyNodeHopCountPair( node );\n            String key = pair.constructKey();\n\n            if ( includes != null && !includes.isEmpty() && !includes.contains( key ) )\n            {\n                return true;\n            }\n\n            List<DependencyNodeHopCountPair> pairs = keyToPairsMap.get( key );\n            if ( pairs == null )\n            {\n                pairs = new ArrayList<>();\n                keyToPairsMap.put( key, pairs );\n            }\n            pairs.add( pair );\n            Collections.sort( pairs );\n            return true;\n        }\n\n        public boolean endVisit( DependencyNode node )\n        {\n            return true;\n        }\n\n        public List<List<DependencyNode>> getConflicts()\n        {\n            List<List<DependencyNode>> output = new ArrayList<>();\n            for ( List<DependencyNodeHopCountPair> pairs : keyToPairsMap.values() )\n            {\n                if ( containsConflicts( pairs ) )\n                {\n                    List<DependencyNode> outputSubList = new ArrayList<>( pairs.size() );\n                    for ( DependencyNodeHopCountPair pair : pairs )\n                    {\n                        outputSubList.add( pair.getNode() );\n                    }\n                    output.add( outputSubList );\n                }\n            }\n            return output;\n        }\n\n        @SuppressWarnings( \"unchecked\" )\n        private boolean containsConflicts( List<DependencyNodeHopCountPair> pairs )\n        {\n            DependencyNodeHopCountPair resolvedPair = pairs.get( 0 );\n\n            // search for artifact with lowest hopCount\n            for ( DependencyNodeHopCountPair hopPair : pairs.subList( 1, pairs.size() ) )\n            {\n                if ( hopPair.getHopCount() < resolvedPair.getHopCount() )\n                {\n                    resolvedPair = hopPair;\n                }\n            }\n\n            ArtifactVersion resolvedVersion = resolvedPair.extractArtifactVersion( uniqueVersions, false );\n\n            for ( DependencyNodeHopCountPair pair : pairs )\n            {\n                ArtifactVersion version = pair.extractArtifactVersion( uniqueVersions, true );\n                if ( resolvedVersion.compareTo( version ) < 0 )\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n    }\n\n    private static class DependencyNodeHopCountPair\n        implements Comparable<DependencyNodeHopCountPair>\n    {\n\n        private DependencyNode node;\n\n        private int hopCount;\n\n        private DependencyNodeHopCountPair( DependencyNode node )\n        {\n            this.node = node;\n            countHops();\n        }\n\n        private void countHops()\n        {\n            hopCount = 0;\n            DependencyNode parent = node.getParent();\n            while ( parent != null )\n            {\n                hopCount++;\n                parent = parent.getParent();\n            }\n        }\n\n        private String constructKey()\n        {\n            Artifact artifact = node.getArtifact();\n            return artifact.getGroupId() + \":\" + artifact.getArtifactId();\n        }\n\n        public DependencyNode getNode()\n        {\n            return node;\n        }\n\n        private ArtifactVersion extractArtifactVersion( boolean uniqueVersions, boolean usePremanagedVersion )\n        {\n            if ( usePremanagedVersion && node.getPremanagedVersion() != null )\n            {\n                return new DefaultArtifactVersion( node.getPremanagedVersion() );\n            }\n\n            Artifact artifact = node.getArtifact();\n            String version = uniqueVersions ? artifact.getVersion() : artifact.getBaseVersion();\n            if ( version != null )\n            {\n                return new DefaultArtifactVersion( version );\n            }\n            try\n            {\n                return artifact.getSelectedVersion();\n            }\n            catch ( OverConstrainedVersionException e )\n            {\n                throw new RuntimeException( \"Version ranges problem with \" + node.getArtifact(), e );\n            }\n        }\n\n        public int getHopCount()\n        {\n            return hopCount;\n        }\n\n        public int compareTo( DependencyNodeHopCountPair other )\n        {\n            return Integer.valueOf( hopCount ).compareTo( Integer.valueOf( other.getHopCount() ) );\n        }\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.metadata.ArtifactMetadataSource;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactCollector;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.versioning.ArtifactVersion;\nimport org.apache.maven.artifact.versioning.DefaultArtifactVersion;\nimport org.apache.maven.artifact.versioning.OverConstrainedVersionException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.shared.dependency.tree.DependencyNode;\nimport org.apache.maven.shared.dependency.tree.DependencyTreeBuilder;\nimport org.apache.maven.shared.dependency.tree.DependencyTreeBuilderException;\nimport org.apache.maven.shared.dependency.tree.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.utils.logging.MessageUtils;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\nimport org.codehaus.plexus.component.repository.exception.ComponentLookupException;\n\n/**\n * Rule to enforce that the resolved dependency is also the most recent one of all transitive dependencies.\n *\n * @author Geoffrey De Smet\n * @since 1.1\n */\npublic class RequireUpperBoundDeps\n    extends AbstractNonCacheableEnforcerRule\n{\n    private static Log log;\n\n    /**\n     * @since 1.3\n     */\n    private boolean uniqueVersions;\n\n    /**\n     * Dependencies to ignore.\n     *\n     * @since TBD\n     */\n    private List<String> excludes = null;\n\n    /**\n     * Dependencies to include.\n     *\n     * @since 3.0.0\n     */\n    private List<String> includes = null;\n\n    /**\n     * Set to {@code true} if timestamped snapshots should be used.\n     *\n     * @param uniqueVersions\n     * @since 1.3\n     */\n    public void setUniqueVersions( boolean uniqueVersions )\n    {\n        this.uniqueVersions = uniqueVersions;\n    }\n\n    /**\n     * Sets dependencies to exclude.\n     * @param excludes a list of {@code groupId:artifactId} names\n     */\n    public void setExcludes( List<String> excludes )\n    {\n        this.excludes = excludes;\n    }\n\n    /**\n     * Sets dependencies to include.\n     *\n     * @param includes a list of {@code groupId:artifactId} names\n     */\n    public void setIncludes( List<String> includes )\n    {\n        this.includes = includes;\n    }\n\n    // CHECKSTYLE_OFF: LineLength\n    /**\n     * Uses the {@link EnforcerRuleHelper} to populate the values of the\n     * {@link DependencyTreeBuilder#buildDependencyTree(MavenProject, ArtifactRepository, ArtifactFactory, ArtifactMetadataSource, ArtifactFilter, ArtifactCollector)}\n     * factory method. <br/>\n     * This method simply exists to hide all the ugly lookup that the {@link EnforcerRuleHelper} has to do.\n     *\n     * @param helper\n     * @return a Dependency Node which is the root of the project's dependency tree\n     * @throws EnforcerRuleException when the build should fail\n     */\n    // CHECKSTYLE_ON: LineLength\n    private DependencyNode getNode( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        try\n        {\n            MavenProject project = (MavenProject) helper.evaluate( \"${project}\" );\n            DependencyTreeBuilder dependencyTreeBuilder = helper.getComponent( DependencyTreeBuilder.class );\n            ArtifactRepository repository = (ArtifactRepository) helper.evaluate( \"${localRepository}\" );\n            ArtifactFactory factory = helper.getComponent( ArtifactFactory.class );\n            ArtifactMetadataSource metadataSource = helper.getComponent( ArtifactMetadataSource.class );\n            ArtifactCollector collector = helper.getComponent( ArtifactCollector.class );\n            ArtifactFilter filter = null; // we need to evaluate all scopes\n            DependencyNode node =\n                dependencyTreeBuilder.buildDependencyTree( project, repository, factory, metadataSource, filter,\n                                                           collector );\n            return node;\n        }\n        catch ( ExpressionEvaluationException e )\n        {\n            throw new EnforcerRuleException( \"Unable to lookup an expression \" + e.getLocalizedMessage(), e );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new EnforcerRuleException( \"Unable to lookup a component \" + e.getLocalizedMessage(), e );\n        }\n        catch ( DependencyTreeBuilderException e )\n        {\n            throw new EnforcerRuleException( \"Could not build dependency tree \" + e.getLocalizedMessage(), e );\n        }\n    }\n\n    @Override\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        if ( log == null )\n        {\n            log = helper.getLog();\n        }\n        try\n        {\n            DependencyNode node = getNode( helper );\n            RequireUpperBoundDepsVisitor visitor = new RequireUpperBoundDepsVisitor();\n            visitor.setUniqueVersions( uniqueVersions );\n            visitor.setIncludes( includes );\n            node.accept( visitor );\n            List<String> errorMessages = buildErrorMessages( visitor.getConflicts() );\n            if ( errorMessages.size() > 0 )\n            {\n                throw new EnforcerRuleException( \"Failed while enforcing RequireUpperBoundDeps. The error(s) are \"\n                    + errorMessages );\n            }\n        }\n        catch ( Exception e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage(), e );\n        }\n    }\n\n    private List<String> buildErrorMessages( List<List<DependencyNode>> conflicts )\n    {\n        List<String> errorMessages = new ArrayList<>( conflicts.size() );\n        for ( List<DependencyNode> conflict : conflicts )\n        {\n            Artifact artifact = conflict.get( 0 ).getArtifact();\n            String groupArt = artifact.getGroupId() + \":\" + artifact.getArtifactId();\n            if ( excludes != null && excludes.contains( groupArt ) )\n            {\n                log.info( \"Ignoring requireUpperBoundDeps in \" + groupArt );\n            }\n            else\n            {\n                errorMessages.add( buildErrorMessage( conflict ) );\n            }\n        }\n        return errorMessages;\n    }\n\n    private String buildErrorMessage( List<DependencyNode> conflict )\n    {\n        StringBuilder errorMessage = new StringBuilder();\n        errorMessage.append(\n                System.lineSeparator() + \"Require upper bound dependencies error for \" + getFullArtifactName(\n                        conflict.get( 0 ), false ) + \" paths to dependency are:\" + System.lineSeparator() );\n        if ( conflict.size() > 0 )\n        {\n            errorMessage.append( buildTreeString( conflict.get( 0 ) ) );\n        }\n        for ( DependencyNode node : conflict.subList( 1, conflict.size() ) )\n        {\n            errorMessage.append( \"and\" + System.lineSeparator() );\n            errorMessage.append( buildTreeString( node ) );\n        }\n        return errorMessage.toString();\n    }\n\n    private StringBuilder buildTreeString( DependencyNode node )\n    {\n        List<String> loc = new ArrayList<>();\n        DependencyNode currentNode = node;\n        while ( currentNode != null )\n        {\n            StringBuilder line = new StringBuilder( getFullArtifactName( currentNode, false ) );\n\n            if ( currentNode.getPremanagedVersion() != null )\n            {\n                line.append( \" (managed) <-- \" );\n                line.append( getFullArtifactName( currentNode, true ) );\n            }\n\n            loc.add( line.toString() );\n            currentNode = currentNode.getParent();\n        }\n        Collections.reverse( loc );\n        StringBuilder builder = new StringBuilder();\n        for ( int i = 0; i < loc.size(); i++ )\n        {\n            for ( int j = 0; j < i; j++ )\n            {\n                builder.append( \"  \" );\n            }\n            builder.append( \"+-\" ).append( loc.get( i ) );\n            builder.append( System.lineSeparator() );\n        }\n        return builder;\n    }\n\n    private String getFullArtifactName( DependencyNode node, boolean usePremanaged )\n    {\n        Artifact artifact = node.getArtifact();\n\n        String version = node.getPremanagedVersion();\n        if ( !usePremanaged || version == null )\n        {\n            version = uniqueVersions ? artifact.getVersion() : artifact.getBaseVersion();\n        }\n        String result = artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\" + version;\n\n        if ( \"compile\".equals( artifact.getScope() ) )\n        {\n            return MessageUtils.buffer().strong( result ).toString();\n        }\n        if ( artifact.getScope() != null )\n        {\n            return result + \" [\" + artifact.getScope() + ']';\n        }\n\n        return result;\n    }\n\n    private static class RequireUpperBoundDepsVisitor\n        implements DependencyNodeVisitor\n    {\n\n        private boolean uniqueVersions;\n\n        private List<String> includes = null;\n\n        public void setUniqueVersions( boolean uniqueVersions )\n        {\n            this.uniqueVersions = uniqueVersions;\n        }\n\n        public void setIncludes( List<String> includes )\n        {\n            this.includes = includes;\n        }\n\n        private Map<String, List<DependencyNodeHopCountPair>> keyToPairsMap = new LinkedHashMap<>();\n\n        public boolean visit( DependencyNode node )\n        {\n            DependencyNodeHopCountPair pair = new DependencyNodeHopCountPair( node );\n            String key = pair.constructKey();\n\n            if ( includes != null && !includes.isEmpty() && !includes.contains( key ) )\n            {\n                return true;\n            }\n\n            List<DependencyNodeHopCountPair> pairs = keyToPairsMap.get( key );\n            if ( pairs == null )\n            {\n                pairs = new ArrayList<>();\n                keyToPairsMap.put( key, pairs );\n            }\n            pairs.add( pair );\n            Collections.sort( pairs );\n            return true;\n        }\n\n        public boolean endVisit( DependencyNode node )\n        {\n            return true;\n        }\n\n        public List<List<DependencyNode>> getConflicts()\n        {\n            List<List<DependencyNode>> output = new ArrayList<>();\n            for ( List<DependencyNodeHopCountPair> pairs : keyToPairsMap.values() )\n            {\n                if ( containsConflicts( pairs ) )\n                {\n                    List<DependencyNode> outputSubList = new ArrayList<>( pairs.size() );\n                    for ( DependencyNodeHopCountPair pair : pairs )\n                    {\n                        outputSubList.add( pair.getNode() );\n                    }\n                    output.add( outputSubList );\n                }\n            }\n            return output;\n        }\n\n        @SuppressWarnings( \"unchecked\" )\n        private boolean containsConflicts( List<DependencyNodeHopCountPair> pairs )\n        {\n            DependencyNodeHopCountPair resolvedPair = pairs.get( 0 );\n\n            // search for artifact with lowest hopCount\n            for ( DependencyNodeHopCountPair hopPair : pairs.subList( 1, pairs.size() ) )\n            {\n                if ( hopPair.getHopCount() < resolvedPair.getHopCount() )\n                {\n                    resolvedPair = hopPair;\n                }\n            }\n\n            ArtifactVersion resolvedVersion = resolvedPair.extractArtifactVersion( uniqueVersions, false );\n\n            for ( DependencyNodeHopCountPair pair : pairs )\n            {\n                ArtifactVersion version = pair.extractArtifactVersion( uniqueVersions, true );\n                if ( resolvedVersion.compareTo( version ) < 0 )\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n    }\n\n    private static class DependencyNodeHopCountPair\n        implements Comparable<DependencyNodeHopCountPair>\n    {\n\n        private DependencyNode node;\n\n        private int hopCount;\n\n        private DependencyNodeHopCountPair( DependencyNode node )\n        {\n            this.node = node;\n            countHops();\n        }\n\n        private void countHops()\n        {\n            hopCount = 0;\n            DependencyNode parent = node.getParent();\n            while ( parent != null )\n            {\n                hopCount++;\n                parent = parent.getParent();\n            }\n        }\n\n        private String constructKey()\n        {\n            Artifact artifact = node.getArtifact();\n            return artifact.getGroupId() + \":\" + artifact.getArtifactId();\n        }\n\n        public DependencyNode getNode()\n        {\n            return node;\n        }\n\n        private ArtifactVersion extractArtifactVersion( boolean uniqueVersions, boolean usePremanagedVersion )\n        {\n            if ( usePremanagedVersion && node.getPremanagedVersion() != null )\n            {\n                return new DefaultArtifactVersion( node.getPremanagedVersion() );\n            }\n\n            Artifact artifact = node.getArtifact();\n            String version = uniqueVersions ? artifact.getVersion() : artifact.getBaseVersion();\n            if ( version != null )\n            {\n                return new DefaultArtifactVersion( version );\n            }\n            try\n            {\n                return artifact.getSelectedVersion();\n            }\n            catch ( OverConstrainedVersionException e )\n            {\n                throw new RuntimeException( \"Version ranges problem with \" + node.getArtifact(), e );\n            }\n        }\n\n        public int getHopCount()\n        {\n            return hopCount;\n        }\n\n        public int compareTo( DependencyNodeHopCountPair other )\n        {\n            return Integer.valueOf( hopCount ).compareTo( Integer.valueOf( other.getHopCount() ) );\n        }\n    }\n\n}\n","lineNo":258}
{"Refactored Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.project.MavenProject;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n\n/**\n * This rule checks that the current project is not a release.\n */\npublic class RequireSnapshotVersion\n    extends AbstractNonCacheableEnforcerRule\n{\n\n    /**\n     * Allows this rule to fail when the parent is defined as a release.\n     */\n    private boolean failWhenParentIsRelease = true;\n\n    @Override\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n\n        MavenProject project = getProject( false, helper );\n        Artifact artifact = project.getArtifact();\n\n        if ( !artifact.isSnapshot() )\n        {\n            String message = getMessage();\n            StringBuilder sb = new StringBuilder();\n            if ( message != null )\n            {\n                sb.append( message ).append( System.lineSeparator() );\n            }\n            sb.append( \"This project cannot be a release:\" ).append( artifact.getId() );\n            throw new EnforcerRuleException( sb.toString() );\n        }\n        if ( failWhenParentIsRelease && project.hasParent() )\n        {\n            // project.getParentArtifact() does not work here if a \"CI Friendly Version\" is used (e.g. ${revision})\n            Artifact parentArtifact = getProject( true, helper ).getArtifact();\n            if ( parentArtifact != null && !parentArtifact.isSnapshot() )\n            {\n                throw new EnforcerRuleException( \"Parent cannot be a release: \" + parentArtifact.getId() );\n            }\n        }\n\n    }\n\n    private MavenProject getProject( boolean parent, EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        String expression = parent ? \"${project.parent}\" : \"${project}\";\n        try\n        {\n            return (MavenProject) helper.evaluate( expression );\n        }\n        catch ( ExpressionEvaluationException eee )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", eee );\n        }\n    }\n\n    public boolean isFailWhenParentIsRelease()\n    {\n        return failWhenParentIsRelease;\n    }\n\n    public void setFailWhenParentIsRelease( boolean failWhenParentIsRelease )\n    {\n        this.failWhenParentIsRelease = failWhenParentIsRelease;\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.project.MavenProject;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n\n/**\n * This rule checks that the current project is not a release.\n */\npublic class RequireSnapshotVersion\n    extends AbstractNonCacheableEnforcerRule\n{\n\n    /**\n     * Allows this rule to fail when the parent is defined as a release.\n     */\n    private boolean failWhenParentIsRelease = true;\n\n    @Override\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n\n        MavenProject project = getProject( helper );\n        Artifact artifact = project.getArtifact();\n\n        if ( !artifact.isSnapshot() )\n        {\n            String message = getMessage();\n            StringBuilder sb = new StringBuilder();\n            if ( message != null )\n            {\n                sb.append( message ).append( System.lineSeparator() );\n            }\n            sb.append( \"This project cannot be a release:\" ).append( artifact.getId() );\n            throw new EnforcerRuleException( sb.toString() );\n        }\n        if ( failWhenParentIsRelease )\n        {\n            Artifact parentArtifact = project.getParentArtifact();\n            if ( parentArtifact != null && !parentArtifact.isSnapshot() )\n            {\n                throw new EnforcerRuleException( \"Parent cannot be a release: \" + parentArtifact.getId() );\n            }\n        }\n\n    }\n\n    private MavenProject getProject( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        try\n        {\n            return (MavenProject) helper.evaluate( \"${project}\" );\n        }\n        catch ( ExpressionEvaluationException eee )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", eee );\n        }\n    }\n\n    public boolean isFailWhenParentIsRelease()\n    {\n        return failWhenParentIsRelease;\n    }\n\n    public void setFailWhenParentIsRelease( boolean failWhenParentIsRelease )\n    {\n        this.failWhenParentIsRelease = failWhenParentIsRelease;\n    }\n\n}\n","lineNo":74}
{"Refactored Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.ArrayList;\nimport java.util.Hashtable;\nimport java.util.List;\n\nimport org.apache.maven.enforcer.rule.api.EnforcerLevel;\nimport org.apache.maven.enforcer.rule.api.EnforcerRule;\nimport org.apache.maven.enforcer.rule.api.EnforcerRule2;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecution;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.plugins.annotations.ResolutionScope;\nimport org.apache.maven.project.MavenProject;\nimport org.codehaus.plexus.PlexusConstants;\nimport org.codehaus.plexus.PlexusContainer;\nimport org.codehaus.plexus.context.Context;\nimport org.codehaus.plexus.context.ContextException;\nimport org.codehaus.plexus.personality.plexus.lifecycle.phase.Contextualizable;\n\n/**\n * This goal executes the defined enforcer-rules once per module.\n *\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n */\n// CHECKSTYLE_OFF: LineLength\n@Mojo( name = \"enforce\", defaultPhase = LifecyclePhase.VALIDATE, requiresDependencyCollection = ResolutionScope.TEST, threadSafe = true )\n//CHECKSTYLE_ON: LineLength\npublic class EnforceMojo\n    extends AbstractMojo\n    implements Contextualizable\n{\n    /**\n     * This is a static variable used to persist the cached results across plugin invocations.\n     */\n    protected static Hashtable<String, EnforcerRule> cache = new Hashtable<String, EnforcerRule>();\n\n    /**\n     * MojoExecution needed by the ExpressionEvaluator\n     */\n    @Parameter( defaultValue = \"${mojoExecution}\", readonly = true, required = true )\n    protected MojoExecution mojoExecution;\n\n    /**\n     * The MavenSession\n     */\n    @Parameter( defaultValue = \"${session}\", readonly = true, required = true )\n    protected MavenSession session;\n\n    /**\n     * POM\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true, required = true )\n    protected MavenProject project;\n\n    /**\n     * Flag to easily skip all checks\n     */\n    @Parameter( property = \"enforcer.skip\", defaultValue = \"false\" )\n    protected boolean skip = false;\n\n    /**\n     * Flag to fail the build if a version check fails.\n     */\n    @Parameter( property = \"enforcer.fail\", defaultValue = \"true\" )\n    private boolean fail = true;\n\n    /**\n     * Fail on the first rule that doesn't pass\n     */\n    @Parameter( property = \"enforcer.failFast\", defaultValue = \"false\" )\n    private boolean failFast = false;\n\n    /**\n     * Array of objects that implement the EnforcerRule interface to execute.\n     */\n    @Parameter( required = false )\n    private EnforcerRule[] rules;\n\n    /**\n     * Array of Strings that matches the EnforcerRules to execute.\n     */\n    @Parameter( required = false, property = \"rules\" )\n    private String[] commandLineRules;\n\n    /**\n     * Use this flag to disable rule result caching. This will cause all rules to execute on each project even if the\n     * rule indicates it can safely be cached.\n     */\n    @Parameter( property = \"enforcer.ignoreCache\", defaultValue = \"false\" )\n    protected boolean ignoreCache = false;\n\n    // set by the contextualize method. Only way to get the\n    // plugin's container in 2.0.x\n    protected PlexusContainer container;\n\n    @Override\n    public void contextualize( Context context )\n        throws ContextException\n    {\n        container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );\n    }\n\n    private boolean havingRules()\n    {\n        return rules != null && rules.length > 0;\n    }\n\n    /**\n     * Entry point to the mojo\n     * \n     * @throws MojoExecutionException\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        Log log = this.getLog();\n\n        EnforcerExpressionEvaluator evaluator =\n            new EnforcerExpressionEvaluator( session, mojoExecution );\n        if ( commandLineRules != null && commandLineRules.length > 0 )\n        {\n            this.rules = createRulesFromCommandLineOptions();\n        }\n        \n        if ( isSkip() )\n        {\n            log.info( \"Skipping Rule Enforcement.\" );\n            return;\n        }\n\n        if ( !havingRules() )\n        {\n            // CHECKSTYLE_OFF: LineLength\n            throw new MojoExecutionException( \"No rules are configured. Use the skip flag if you want to disable execution.\" );\n            // CHECKSTYLE_ON: LineLength\n        }\n\n        // list to store exceptions\n        List<String> list = new ArrayList<String>();\n\n        String currentRule = \"Unknown\";\n\n        // create my helper\n        EnforcerRuleHelper helper = new DefaultEnforcementRuleHelper( session, evaluator, log, container );\n\n        // if we are only warning, then disable\n        // failFast\n        if ( !fail )\n        {\n            failFast = false;\n        }\n\n        boolean hasErrors = false;\n\n        // go through each rule\n        for ( int i = 0; i < rules.length; i++ )\n        {\n\n            // prevent against empty rules\n            EnforcerRule rule = rules[i];\n            final EnforcerLevel level = getLevel( rule );\n            if ( rule != null )\n            {\n                // store the current rule for\n                // logging purposes\n                currentRule = rule.getClass().getName();\n                log.debug( \"Executing rule: \" + currentRule );\n                try\n                {\n                    if ( ignoreCache || shouldExecute( rule ) )\n                    {\n                        // execute the rule\n                        // noinspection\n                        // SynchronizationOnLocalVariableOrMethodParameter\n                        synchronized ( rule )\n                        {\n                            rule.execute( helper );\n                        }\n                    }\n                }\n                catch ( EnforcerRuleException e )\n                {\n                    // i can throw an exception\n                    // because failfast will be\n                    // false if fail is false.\n                    if ( failFast && level == EnforcerLevel.ERROR )\n                    {\n                        throw new MojoExecutionException( currentRule + \" failed with message:\"\n                            + System.lineSeparator() + e.getMessage(), e );\n                    }\n                    else\n                    {\n                        // log a warning in case the exception message is missing\n                        // so that the user can figure out what is going on\n                        final String exceptionMessage = e.getMessage();\n                        if ( exceptionMessage != null )\n                        {\n                            log.debug( \"Adding \" + level + \" message due to exception\", e );\n                        }\n                        else\n                        {\n                            log.warn( \"Rule \" + i + \": \" + currentRule + \" failed without a message\", e );\n                        }\n                        // add the 'failed/warned' message including exceptionMessage\n                        // which might be null in rare cases\n                        if ( level == EnforcerLevel.ERROR )\n                        {\n                            hasErrors = true;\n                            list.add( \"Rule \" + i + \": \" + currentRule + \" failed with message:\"\n                                 + System.lineSeparator() + exceptionMessage );\n                        }\n                        else\n                        {\n                            list.add( \"Rule \" + i + \": \" + currentRule + \" warned with message:\"\n                                 + System.lineSeparator() + exceptionMessage );\n                        }\n                    }\n                }\n            }\n        }\n\n        // if we found anything\n        // CHECKSTYLE_OFF: LineLength\n        if ( !list.isEmpty() )\n        {\n            for ( String failure : list )\n            {\n                log.warn( failure );\n            }\n            if ( fail && hasErrors )\n            {\n                throw new MojoExecutionException( \"Some Enforcer rules have failed. Look above for specific messages explaining why the rule failed.\" );\n            }\n        }\n        // CHECKSTYLE_ON: LineLength\n    }\n\n    private EnforcerRule[] createRulesFromCommandLineOptions() throws MojoExecutionException \n    {\n        EnforcerRule[] rules = new EnforcerRule[commandLineRules.length];\n        for ( int i = 0; i < commandLineRules.length; i++ ) \n        {\n            String rule = commandLineRules[i];\n            if ( !rule.contains( \".\" ) )\n            {\n                rule = getClass().getPackage().getName() \n                    + \".\" + Character.toUpperCase( rule.charAt( 0 ) ) + rule.substring( 1 ); \n            }\n            \n            try \n            {\n                rules[i] = ( EnforcerRule ) Class.forName( rule ).newInstance();\n            }\n            catch ( Exception e ) \n            {\n                throw new MojoExecutionException( \"Failed to create enforcer rules from command line argument\", e );\n            }\n        }\n        return rules;\n    }\n\n    /**\n     * This method determines if a rule should execute based on the cache\n     *\n     * @param rule the rule to verify\n     * @return {@code true} if rule should be executed, otherwise {@code false}\n     */\n    protected boolean shouldExecute( EnforcerRule rule )\n    {\n        if ( rule.isCacheable() )\n        {\n            Log log = this.getLog();\n            log.debug( \"Rule \" + rule.getClass().getName() + \" is cacheable.\" );\n            String key = rule.getClass().getName() + \" \" + rule.getCacheId();\n            if ( EnforceMojo.cache.containsKey( key ) )\n            {\n                log.debug( \"Key \" + key + \" was found in the cache\" );\n                if ( rule.isResultValid( cache.get( key ) ) )\n                {\n                    log.debug( \"The cached results are still valid. Skipping the rule: \" + rule.getClass().getName() );\n                    return false;\n                }\n            }\n\n            // add it to the cache of executed rules\n            EnforceMojo.cache.put( key, rule );\n        }\n        return true;\n    }\n\n    /**\n     * @return the fail\n     */\n    public boolean isFail()\n    {\n        return this.fail;\n    }\n\n    /**\n     * @param theFail the fail to set\n     */\n    public void setFail( boolean theFail )\n    {\n        this.fail = theFail;\n    }\n\n    /**\n     * @return the rules\n     */\n    public EnforcerRule[] getRules()\n    {\n        return this.rules;\n    }\n\n    /**\n     * @param theRules the rules to set\n     */\n    public void setRules( EnforcerRule[] theRules )\n    {\n        this.rules = theRules;\n    }\n\n    /**\n     * @param theFailFast the failFast to set\n     */\n    public void setFailFast( boolean theFailFast )\n    {\n        this.failFast = theFailFast;\n    }\n\n    public boolean isFailFast()\n    {\n        return failFast;\n    }\n\n    protected String createRuleMessage( int i, String currentRule, EnforcerRuleException e )\n    {\n        return \"Rule \" + i + \": \" + currentRule + \" failed with message:\" + System.lineSeparator() + e.getMessage();\n    }\n\n    /**\n     * Returns the level of the rule, defaults to {@link EnforcerLevel#ERROR} for backwards compatibility.\n     *\n     * @param rule might be of type {@link EnforcerRule2}.\n     * @return level of the rule.\n     */\n    private EnforcerLevel getLevel( EnforcerRule rule )\n    {\n        if ( rule instanceof EnforcerRule2 )\n        {\n            return ( (EnforcerRule2) rule ).getLevel();\n        }\n        else\n        {\n            return EnforcerLevel.ERROR;\n        }\n    }\n\n    /**\n     * @return the skip\n     */\n    public boolean isSkip()\n    {\n        return this.skip;\n    }\n\n    /**\n     * @param theSkip the skip to set\n     */\n    public void setSkip( boolean theSkip )\n    {\n        this.skip = theSkip;\n    }\n\n    /**\n     * @return the project\n     */\n    public MavenProject getProject()\n    {\n        return this.project;\n    }\n\n    /**\n     * @param theProject the project to set\n     */\n    public void setProject( MavenProject theProject )\n    {\n        this.project = theProject;\n    }\n\n    /**\n     * @return the session\n     */\n    public MavenSession getSession()\n    {\n        return this.session;\n    }\n\n    /**\n     * @param theSession the session to set\n     */\n    public void setSession( MavenSession theSession )\n    {\n        this.session = theSession;\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.ArrayList;\nimport java.util.Hashtable;\nimport java.util.List;\n\nimport org.apache.maven.enforcer.rule.api.EnforcerLevel;\nimport org.apache.maven.enforcer.rule.api.EnforcerRule;\nimport org.apache.maven.enforcer.rule.api.EnforcerRule2;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecution;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.plugins.annotations.ResolutionScope;\nimport org.apache.maven.project.MavenProject;\nimport org.codehaus.plexus.PlexusConstants;\nimport org.codehaus.plexus.PlexusContainer;\nimport org.codehaus.plexus.context.Context;\nimport org.codehaus.plexus.context.ContextException;\nimport org.codehaus.plexus.personality.plexus.lifecycle.phase.Contextualizable;\n\n/**\n * This goal executes the defined enforcer-rules once per module.\n *\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n */\n// CHECKSTYLE_OFF: LineLength\n@Mojo( name = \"enforce\", defaultPhase = LifecyclePhase.VALIDATE, requiresDependencyCollection = ResolutionScope.TEST, threadSafe = true )\n//CHECKSTYLE_ON: LineLength\npublic class EnforceMojo\n    extends AbstractMojo\n    implements Contextualizable\n{\n    /**\n     * This is a static variable used to persist the cached results across plugin invocations.\n     */\n    protected static Hashtable<String, EnforcerRule> cache = new Hashtable<String, EnforcerRule>();\n\n    /**\n     * MojoExecution needed by the ExpressionEvaluator\n     */\n    @Parameter( defaultValue = \"${mojoExecution}\", readonly = true, required = true )\n    protected MojoExecution mojoExecution;\n\n    /**\n     * The MavenSession\n     */\n    @Parameter( defaultValue = \"${session}\", readonly = true, required = true )\n    protected MavenSession session;\n\n    /**\n     * POM\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true, required = true )\n    protected MavenProject project;\n\n    /**\n     * Flag to easily skip all checks\n     */\n    @Parameter( property = \"enforcer.skip\", defaultValue = \"false\" )\n    protected boolean skip = false;\n\n    /**\n     * Flag to fail the build if a version check fails.\n     */\n    @Parameter( property = \"enforcer.fail\", defaultValue = \"true\" )\n    private boolean fail = true;\n\n    /**\n     * Fail on the first rule that doesn't pass\n     */\n    @Parameter( property = \"enforcer.failFast\", defaultValue = \"false\" )\n    private boolean failFast = false;\n\n    /**\n     * Array of objects that implement the EnforcerRule interface to execute.\n     */\n    @Parameter( required = false )\n    private EnforcerRule[] rules;\n\n    /**\n     * Array of Strings that matches the EnforcerRules to execute.\n     */\n    @Parameter( required = false, property = \"rules\" )\n    private String[] commandLineRules;\n\n    /**\n     * Use this flag to disable rule result caching. This will cause all rules to execute on each project even if the\n     * rule indicates it can safely be cached.\n     */\n    @Parameter( property = \"enforcer.ignoreCache\", defaultValue = \"false\" )\n    protected boolean ignoreCache = false;\n\n    // set by the contextualize method. Only way to get the\n    // plugin's container in 2.0.x\n    protected PlexusContainer container;\n\n    @Override\n    public void contextualize( Context context )\n        throws ContextException\n    {\n        container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );\n    }\n\n    private boolean havingRules()\n    {\n        return rules != null && rules.length > 0;\n    }\n\n    /**\n     * Entry point to the mojo\n     * \n     * @throws MojoExecutionException\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        Log log = this.getLog();\n\n        EnforcerExpressionEvaluator evaluator =\n            new EnforcerExpressionEvaluator( session, mojoExecution );\n        if ( commandLineRules != null && commandLineRules.length > 0 )\n        {\n            this.rules = createRulesFromCommandLineOptions();\n        }\n        \n        if ( isSkip() )\n        {\n            log.info( \"Skipping Rule Enforcement.\" );\n            return;\n        }\n\n        if ( !havingRules() )\n        {\n            // CHECKSTYLE_OFF: LineLength\n            throw new MojoExecutionException( \"No rules are configured. Use the skip flag if you want to disable execution.\" );\n            // CHECKSTYLE_ON: LineLength\n        }\n\n        // list to store exceptions\n        List<String> list = new ArrayList<String>();\n\n        String currentRule = \"Unknown\";\n\n        // create my helper\n        EnforcerRuleHelper helper = new DefaultEnforcementRuleHelper( session, evaluator, log, container );\n\n        // if we are only warning, then disable\n        // failFast\n        if ( !fail )\n        {\n            failFast = false;\n        }\n\n        boolean hasErrors = false;\n\n        // go through each rule\n        for ( int i = 0; i < rules.length; i++ )\n        {\n\n            // prevent against empty rules\n            EnforcerRule rule = rules[i];\n            final EnforcerLevel level = getLevel( rule );\n            if ( rule != null )\n            {\n                // store the current rule for\n                // logging purposes\n                currentRule = rule.getClass().getName();\n                log.debug( \"Executing rule: \" + currentRule );\n                try\n                {\n                    if ( ignoreCache || shouldExecute( rule ) )\n                    {\n                        // execute the rule\n                        // noinspection\n                        // SynchronizationOnLocalVariableOrMethodParameter\n                        synchronized ( rule )\n                        {\n                            rule.execute( helper );\n                        }\n                    }\n                }\n                catch ( EnforcerRuleException e )\n                {\n                    // i can throw an exception\n                    // because failfast will be\n                    // false if fail is false.\n                    if ( failFast && level == EnforcerLevel.ERROR )\n                    {\n                        throw new MojoExecutionException( currentRule + \" failed with message:\"\n                            + System.lineSeparator() + e.getMessage(), e );\n                    }\n                    else\n                    {\n                        if ( level == EnforcerLevel.ERROR )\n                        {\n                            hasErrors = true;\n                            list.add( \"Rule \" + i + \": \" + currentRule + \" failed with message:\"\n                                 + System.lineSeparator() + e.getMessage() );\n                            log.debug( \"Adding failure due to exception\", e );\n                        }\n                        else\n                        {\n                            list.add( \"Rule \" + i + \": \" + currentRule + \" warned with message:\"\n                                 + System.lineSeparator() + e.getMessage() );\n                            log.debug( \"Adding warning due to exception\", e );\n                        }\n                    }\n                }\n            }\n        }\n\n        // if we found anything\n        // CHECKSTYLE_OFF: LineLength\n        if ( !list.isEmpty() )\n        {\n            for ( String failure : list )\n            {\n                log.warn( failure );\n            }\n            if ( fail && hasErrors )\n            {\n                throw new MojoExecutionException( \"Some Enforcer rules have failed. Look above for specific messages explaining why the rule failed.\" );\n            }\n        }\n        // CHECKSTYLE_ON: LineLength\n    }\n\n    private EnforcerRule[] createRulesFromCommandLineOptions() throws MojoExecutionException \n    {\n        EnforcerRule[] rules = new EnforcerRule[commandLineRules.length];\n        for ( int i = 0; i < commandLineRules.length; i++ ) \n        {\n            String rule = commandLineRules[i];\n            if ( !rule.contains( \".\" ) )\n            {\n                rule = getClass().getPackage().getName() \n                    + \".\" + Character.toUpperCase( rule.charAt( 0 ) ) + rule.substring( 1 ); \n            }\n            \n            try \n            {\n                rules[i] = ( EnforcerRule ) Class.forName( rule ).newInstance();\n            }\n            catch ( Exception e ) \n            {\n                throw new MojoExecutionException( \"Failed to create enforcer rules from command line argument\", e );\n            }\n        }\n        return rules;\n    }\n\n    /**\n     * This method determines if a rule should execute based on the cache\n     *\n     * @param rule the rule to verify\n     * @return {@code true} if rule should be executed, otherwise {@code false}\n     */\n    protected boolean shouldExecute( EnforcerRule rule )\n    {\n        if ( rule.isCacheable() )\n        {\n            Log log = this.getLog();\n            log.debug( \"Rule \" + rule.getClass().getName() + \" is cacheable.\" );\n            String key = rule.getClass().getName() + \" \" + rule.getCacheId();\n            if ( EnforceMojo.cache.containsKey( key ) )\n            {\n                log.debug( \"Key \" + key + \" was found in the cache\" );\n                if ( rule.isResultValid( cache.get( key ) ) )\n                {\n                    log.debug( \"The cached results are still valid. Skipping the rule: \" + rule.getClass().getName() );\n                    return false;\n                }\n            }\n\n            // add it to the cache of executed rules\n            EnforceMojo.cache.put( key, rule );\n        }\n        return true;\n    }\n\n    /**\n     * @return the fail\n     */\n    public boolean isFail()\n    {\n        return this.fail;\n    }\n\n    /**\n     * @param theFail the fail to set\n     */\n    public void setFail( boolean theFail )\n    {\n        this.fail = theFail;\n    }\n\n    /**\n     * @return the rules\n     */\n    public EnforcerRule[] getRules()\n    {\n        return this.rules;\n    }\n\n    /**\n     * @param theRules the rules to set\n     */\n    public void setRules( EnforcerRule[] theRules )\n    {\n        this.rules = theRules;\n    }\n\n    /**\n     * @param theFailFast the failFast to set\n     */\n    public void setFailFast( boolean theFailFast )\n    {\n        this.failFast = theFailFast;\n    }\n\n    public boolean isFailFast()\n    {\n        return failFast;\n    }\n\n    protected String createRuleMessage( int i, String currentRule, EnforcerRuleException e )\n    {\n        return \"Rule \" + i + \": \" + currentRule + \" failed with message:\" + System.lineSeparator() + e.getMessage();\n    }\n\n    /**\n     * Returns the level of the rule, defaults to {@link EnforcerLevel#ERROR} for backwards compatibility.\n     *\n     * @param rule might be of type {@link EnforcerRule2}.\n     * @return level of the rule.\n     */\n    private EnforcerLevel getLevel( EnforcerRule rule )\n    {\n        if ( rule instanceof EnforcerRule2 )\n        {\n            return ( (EnforcerRule2) rule ).getLevel();\n        }\n        else\n        {\n            return EnforcerLevel.ERROR;\n        }\n    }\n\n    /**\n     * @return the skip\n     */\n    public boolean isSkip()\n    {\n        return this.skip;\n    }\n\n    /**\n     * @param theSkip the skip to set\n     */\n    public void setSkip( boolean theSkip )\n    {\n        this.skip = theSkip;\n    }\n\n    /**\n     * @return the project\n     */\n    public MavenProject getProject()\n    {\n        return this.project;\n    }\n\n    /**\n     * @param theProject the project to set\n     */\n    public void setProject( MavenProject theProject )\n    {\n        this.project = theProject;\n    }\n\n    /**\n     * @return the session\n     */\n    public MavenSession getSession()\n    {\n        return this.session;\n    }\n\n    /**\n     * @param theSession the session to set\n     */\n    public void setSession( MavenSession theSession )\n    {\n        this.session = theSession;\n    }\n\n}\n","lineNo":223}
{"Refactored Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.project.MavenProject;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * Ensure that all profiles mentioned on the commandline do exist. \n * \n * @author Robert Scholte\n * @author Gabriel Belingueres\n */\npublic class RequireProfileIdsExist extends AbstractNonCacheableEnforcerRule\n{\n    @Override\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        try\n        {\n            MavenSession session = (MavenSession) helper.evaluate( \"${session}\" );\n\n            List<String> profileIds = new ArrayList<String>();\n            profileIds.addAll( session.getProjectBuildingRequest().getActiveProfileIds() );\n            profileIds.addAll( session.getProjectBuildingRequest().getInactiveProfileIds() );\n\n            for ( MavenProject project : session.getProjects() )\n            {\n                // iterate over all parents\n                MavenProject currentProject = project;\n                do\n                {\n                    for ( org.apache.maven.model.Profile profile : currentProject.getModel().getProfiles() )\n                    {\n                        profileIds.remove( profile.getId() );\n\n                        if ( profileIds.isEmpty() )\n                        {\n                            return;\n                        }\n                    }\n\n                    currentProject = currentProject.getParent();\n                }\n                while ( currentProject != null );\n            }\n\n            for ( org.apache.maven.settings.Profile profile : session.getSettings().getProfiles() )\n            {\n                profileIds.remove( profile.getId() );\n            }\n\n            if ( profileIds.isEmpty() )\n            {\n                return;\n            }\n\n            StringBuilder sb = new StringBuilder();\n            if ( profileIds.size() > 1 )\n            {\n                sb.append( \"The requested profiles don't exist: \" );\n            }\n            else\n            {\n                sb.append( \"The requested profile doesn't exist: \" );\n            }\n            sb.append( StringUtils.join( profileIds.iterator(), \", \" ) );\n\n            throw new EnforcerRuleException( sb.toString() );\n        }\n        catch ( ExpressionEvaluationException e )\n        {\n            throw new EnforcerRuleException( e.getMessage() );\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.project.MavenProject;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * Ensure that all profiles mentioned on the commandline do exist. \n * \n * @author Robert Scholte\n */\npublic class RequireProfileIdsExist extends AbstractNonCacheableEnforcerRule\n{\n    @Override\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        try\n        {\n            MavenSession session = (MavenSession) helper.evaluate( \"${session}\" );\n            \n            List<String> profileIds = new ArrayList<String>();\n            profileIds.addAll( session.getProjectBuildingRequest().getActiveProfileIds() );\n            profileIds.addAll( session.getProjectBuildingRequest().getInactiveProfileIds() );\n            \n            for ( MavenProject project : session.getProjects() )\n            {\n                for ( org.apache.maven.model.Profile profile : project.getModel().getProfiles() )\n                {\n                    profileIds.remove( profile.getId() );\n                    \n                    if ( profileIds.isEmpty() )\n                    {\n                        return;\n                    }\n                }\n            }\n            \n            for ( org.apache.maven.settings.Profile profile : session.getSettings().getProfiles() )\n            {\n                profileIds.remove( profile.getId() );\n            }\n\n            if ( profileIds.isEmpty() )\n            {\n                return;\n            }\n\n            StringBuilder sb = new StringBuilder();\n            if ( profileIds.size() > 1 )\n            {\n                sb.append( \"The requested profiles don't exist: \" );\n            }\n            else\n            {\n                sb.append( \"The requested profile doesn't exist: \" );\n            }\n            sb.append( StringUtils.join( profileIds.iterator(), \", \" ) );\n            \n            throw new EnforcerRuleException( sb.toString() );\n        }\n        catch ( ExpressionEvaluationException e )\n        {\n            throw new EnforcerRuleException( e.getMessage() );\n        }\n    }\n}\n","lineNo":55}
{"Refactored Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.codehaus.plexus.util.IOUtil;\n\n/**\n * Rule to validate a file to match the specified checksum.\n *\n * @author Edward Samson\n * @author Lyubomyr Shaydariv\n */\npublic class RequireFileChecksum\n    extends AbstractNonCacheableEnforcerRule\n{\n\n    private File file;\n\n    private String checksum;\n\n    private String type;\n\n    private String nonexistentFileMessage;\n\n    @Override\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        if ( this.file == null )\n        {\n            throw new EnforcerRuleException( \"Input file unspecified\" );\n        }\n\n        if ( this.type == null )\n        {\n            throw new EnforcerRuleException( \"Hash type unspecified\" );\n        }\n\n        if ( this.checksum == null )\n        {\n            throw new EnforcerRuleException( \"Checksum unspecified\" );\n        }\n\n        if ( !this.file.exists() )\n        {\n            String message = nonexistentFileMessage;\n            if ( message == null )\n            {\n                message = \"File does not exist: \" + this.file.getAbsolutePath();\n            }\n            throw new EnforcerRuleException( message );\n        }\n\n        if ( this.file.isDirectory() )\n        {\n            throw new EnforcerRuleException( \"Cannot calculate the checksum of directory: \"\n                + this.file.getAbsolutePath() );\n        }\n\n        if ( !this.file.canRead() )\n        {\n            throw new EnforcerRuleException( \"Cannot read file: \" + this.file.getAbsolutePath() );\n        }\n\n        String checksum = calculateChecksum();\n\n        if ( !checksum.equalsIgnoreCase( this.checksum ) )\n        {\n            String exceptionMessage = getMessage();\n            if ( exceptionMessage == null )\n            {\n                exceptionMessage = this.type + \" hash of \" + this.file + \" was \" + checksum\n                    + \" but expected \" + this.checksum;\n            }\n            throw new EnforcerRuleException( exceptionMessage );\n        }\n    }\n\n    /**\n     * The file to check.\n     *\n     * @param file file\n     */\n    public void setFile( File file )\n    {\n        this.file = file;\n    }\n\n    /**\n     * The expected checksum value.\n     *\n     * @param checksum checksum\n     */\n    public void setChecksum( String checksum )\n    {\n        this.checksum = checksum;\n    }\n\n    /**\n     * The checksum algorithm to use. Possible values: \"md5\", \"sha1\", \"sha256\", \"sha384\", \"sha512\".\n     *\n     * @param type algorithm\n     */\n    public void setType( String type )\n    {\n        this.type = type;\n    }\n\n    /**\n     * The friendly message to use when the file does not exist.\n     *\n     * @param nonexistentFileMessage message\n     */\n    public void setNonexistentFileMessage( String nonexistentFileMessage )\n    {\n        this.nonexistentFileMessage = nonexistentFileMessage;\n    }\n\n    private String calculateChecksum()\n        throws EnforcerRuleException\n    {\n        InputStream inputStream = null;\n        try\n        {\n            inputStream = new FileInputStream( this.file );\n            String checksum;\n            if ( \"md5\".equals( this.type ) )\n            {\n                checksum = DigestUtils.md5Hex( inputStream );\n            }\n            else if ( \"sha1\".equals( this.type ) )\n            {\n                checksum = DigestUtils.shaHex( inputStream );\n            }\n            else if ( \"sha256\".equals( this.type ) )\n            {\n                checksum = DigestUtils.sha256Hex( inputStream );\n            }\n            else if ( \"sha384\".equals( this.type ) )\n            {\n                checksum = DigestUtils.sha384Hex( inputStream );\n            }\n            else if ( \"sha512\".equals( this.type ) )\n            {\n                checksum = DigestUtils.sha512Hex( inputStream );\n            }\n            else\n            {\n                throw new EnforcerRuleException( \"Unsupported hash type: \" + this.type );\n            }\n            return checksum;\n        }\n        catch ( IOException e )\n        {\n            throw new EnforcerRuleException( \"Unable to calculate checksum\", e );\n        }\n        finally\n        {\n            IOUtil.close( inputStream );\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.codehaus.plexus.util.IOUtil;\n\n/**\n * Rule to validate a file to match the specified checksum.\n *\n * @author Edward Samson\n * @author Lyubomyr Shaydariv\n */\npublic class RequireFileChecksum\n    extends AbstractNonCacheableEnforcerRule\n{\n\n    private File file;\n\n    private String checksum;\n\n    private String type;\n\n    @Override\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        if ( this.file == null )\n        {\n            throw new EnforcerRuleException( \"Input file unspecified\" );\n        }\n\n        if ( this.type == null )\n        {\n            throw new EnforcerRuleException( \"Hash type unspecified\" );\n        }\n\n        if ( this.checksum == null )\n        {\n            throw new EnforcerRuleException( \"Checksum unspecified\" );\n        }\n\n        InputStream inputStream = null;\n        try\n        {\n            if ( this.file.isDirectory() || !this.file.canRead() )\n            {\n                throw new EnforcerRuleException( \"Cannot read file: \" + this.file.getAbsolutePath() );\n            }\n\n            inputStream = new FileInputStream( this.file );\n            String checksum;\n            if ( \"md5\".equals( this.type ) )\n            {\n                checksum = DigestUtils.md5Hex( inputStream );\n            }\n            else if ( \"sha1\".equals( this.type ) )\n            {\n                checksum = DigestUtils.shaHex( inputStream );\n            }\n            else if ( \"sha256\".equals( this.type ) )\n            {\n                checksum = DigestUtils.sha256Hex( inputStream );\n            }\n            else if ( \"sha384\".equals( this.type ) )\n            {\n                checksum = DigestUtils.sha384Hex( inputStream );\n            }\n            else if ( \"sha512\".equals( this.type ) )\n            {\n                checksum = DigestUtils.sha512Hex( inputStream );\n            }\n            else\n            {\n                throw new EnforcerRuleException( \"Unsupported hash type: \" + this.type );\n            }\n            if ( !checksum.equalsIgnoreCase( this.checksum ) )\n            {\n                throw new EnforcerRuleException( this.type + \" hash of \" + this.file + \" was \" + checksum\n                    + \" but expected \" + this.checksum );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new EnforcerRuleException( \"Unable to calculate checksum\", e );\n        }\n        finally\n        {\n            IOUtil.close( inputStream );\n        }\n    }\n\n    /**\n     * The file to check.\n     *\n     * @param file file\n     */\n    public void setFile( File file )\n    {\n        this.file = file;\n    }\n\n    /**\n     * The expected checksum value.\n     *\n     * @param checksum checksum\n     */\n    public void setChecksum( String checksum )\n    {\n        this.checksum = checksum;\n    }\n\n    /**\n     * The checksum algorithm to use. Possible values: \"md5\", \"sha1\", \"sha256\", \"sha384\", \"sha512\".\n     *\n     * @param type algorithm\n     */\n    public void setType( String type )\n    {\n        this.type = type;\n    }\n\n}\n","lineNo":94}
{"Refactored Sample":"package org.apache.maven.plugins.enforcer;\n\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nimport java.util.ArrayList;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.execution.ProjectDependencyGraph;\nimport org.apache.maven.model.Model;\nimport org.apache.maven.model.Repository;\nimport org.apache.maven.model.RepositoryPolicy;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.project.MavenProject;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * Test the \"require no repositories\" rule.\n * \n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n * @author <a href=\"mailto:khmarbaise@apache.org\">Karl Heinz Marbaise<\/a>\n */\npublic class TestRequireNoRepositories\n{\n    private EnforcerRuleHelper helper;\n\n    private RequireNoRepositories rule;\n\n    private MavenSession session;\n\n    @Before\n    public void before()\n        throws ExpressionEvaluationException\n    {\n        session = mock( MavenSession.class );\n        helper = mock( EnforcerRuleHelper.class );\n\n        when( helper.evaluate( \"${session}\" ) ).thenReturn( session );\n\n        Log log = mock( Log.class );\n        when( helper.getLog() ).thenReturn( log );\n\n        rule = new RequireNoRepositories();\n        rule.setMessage( \"my message\" );\n    }\n\n    private MavenProject createMavenProject()\n    {\n        MavenProject mp = mock( MavenProject.class );\n        when( mp.getGroupId() ).thenReturn( \"org.apache.maven.plugins.enforcer.test\" );\n        when( mp.getArtifactId() ).thenReturn( \"no-repositories-child\" );\n        when( mp.getVersion() ).thenReturn( \"1.0-SNAPSHOT\" );\n\n        return mp;\n    }\n\n    private Model createOriginalModel()\n    {\n        Model m = mock( Model.class );\n        when( m.getGroupId() ).thenReturn( \"org.apache.maven.plugins.enforcer.test\" );\n        when( m.getArtifactId() ).thenReturn( \"no-repositories\" );\n        when( m.getVersion() ).thenReturn( \"1.0-SNAPSHOT\" );\n        return m;\n    }\n\n    private MavenProject createStandAloneProject()\n    {\n        MavenProject mp = createMavenProject();\n        Model originalModel = createOriginalModel();\n        // This means the interpolated model is the same\n        // as the non interpolated.\n        when( mp.getModel() ).thenReturn( originalModel );\n        when( mp.getOriginalModel() ).thenReturn( originalModel );\n        return mp;\n    }\n\n    private void setupSortedProjects( List<MavenProject> projectList )\n    {\n        ProjectDependencyGraph pdg = mock( ProjectDependencyGraph.class );\n        when( session.getProjectDependencyGraph() ).thenReturn( pdg );\n        when( pdg.getSortedProjects() ).thenReturn( projectList );\n    }\n\n    private Repository createRepository( String id, String url )\n    {\n        Repository r = new Repository();\n        r.setId( id );\n        r.setUrl( url );\n        RepositoryPolicy snapshotPolicy = new RepositoryPolicy();\n        snapshotPolicy.setEnabled( false );\n        snapshotPolicy.setUpdatePolicy( \"daily\" );\n        r.setSnapshots( snapshotPolicy );\n\n        RepositoryPolicy releasePolicy = new RepositoryPolicy();\n        releasePolicy.setEnabled( true );\n        releasePolicy.setUpdatePolicy( \"never\" );\n        r.setReleases( releasePolicy );\n\n        return r;\n    }\n\n    private Repository createSnapshotRepository( String id, String url )\n    {\n        Repository r = new Repository();\n        r.setId( id );\n        r.setUrl( url );\n\n        RepositoryPolicy snapshotPolicy = new RepositoryPolicy();\n        snapshotPolicy.setEnabled( true );\n        snapshotPolicy.setUpdatePolicy( \"daily\" );\n        r.setSnapshots( snapshotPolicy );\n\n        RepositoryPolicy releasePolicy = new RepositoryPolicy();\n        releasePolicy.setEnabled( false );\n        r.setReleases( releasePolicy );\n\n        return r;\n    }\n\n    private MavenProject addRepository( MavenProject project, Repository r )\n    {\n        Model originalModel = project.getOriginalModel();\n        List<Repository> repositories = new ArrayList<Repository>();\n        repositories.add( r );\n        when( originalModel.getRepositories() ).thenReturn( repositories );\n        return project;\n    }\n\n    private MavenProject addEmptyRepository( MavenProject project )\n    {\n        Model originalModel = project.getOriginalModel();\n        List<Repository> repositories = new ArrayList<Repository>();\n        when( originalModel.getRepositories() ).thenReturn( repositories );\n        return project;\n    }\n\n    private MavenProject addPluginRepository( MavenProject project, Repository r )\n    {\n        Model originalModel = project.getOriginalModel();\n        List<Repository> repositories = new ArrayList<Repository>();\n        repositories.add( r );\n        when( originalModel.getPluginRepositories() ).thenReturn( repositories );\n        return project;\n    }\n\n    private MavenProject addEmptyPluginRepository( MavenProject project )\n    {\n        Model originalModel = project.getOriginalModel();\n        List<Repository> repositories = new ArrayList<Repository>();\n        when( originalModel.getPluginRepositories() ).thenReturn( repositories );\n        return project;\n    }\n\n    /**\n     * This model contains a single module maven project without any repository.\n     */\n    @Test\n    public void testAllBannedNoRepositories()\n        throws EnforcerRuleException\n    {\n        MavenProject baseProject = createStandAloneProject();\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    /**\n     * The model contains a single repository which is is not allowed by the default rules.\n     */\n    @Test( expected = EnforcerRuleException.class )\n    public void testAllBannedWithRepository()\n        throws EnforcerRuleException\n    {\n        MavenProject baseProject = createStandAloneProject();\n        addRepository( baseProject, createRepository( \"repo\", \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    /**\n     * The model contains a single plugin repository which is is not allowed by the default rules.\n     */\n    @Test( expected = EnforcerRuleException.class )\n    public void testAllBannedWithPluginRepository()\n        throws EnforcerRuleException\n    {\n        MavenProject baseProject = createStandAloneProject();\n        addPluginRepository( baseProject, createRepository( \"repo\", \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    /**\n     * The model contains a single repository which is allowed by setting allowedRepositories to the id.\n     */\n    @Test\n    public void testAllBannedWithAllowedRepositories()\n        throws EnforcerRuleException\n    {\n        final String repositoryId = \"repo\";\n        rule.setAllowedRepositories( Collections.singletonList( repositoryId ) );\n\n        MavenProject baseProject = createStandAloneProject();\n        addRepository( baseProject, createRepository( repositoryId, \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    /**\n     * The model contains a single repository. Turned off ban repositories.\n     */\n    @Test\n    public void testRepositoriesNotBannedWithSingleRepository()\n        throws EnforcerRuleException\n    {\n        final String repositoryId = \"repo\";\n\n        rule.setBanRepositories( false );\n\n        MavenProject baseProject = createStandAloneProject();\n        addRepository( baseProject, createRepository( repositoryId, \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    /**\n     * The model contains no repository at all. Turned off ban repositories.\n     */\n    @Test\n    public void testRepositoriesNotBannedWithOutAnyRepository()\n        throws EnforcerRuleException\n    {\n        rule.setBanRepositories( false );\n\n        MavenProject baseProject = createStandAloneProject();\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    /**\n     * This model contains a single plugin repository. The given plugin repository is added to the list of allowed\n     * plugin repositories.\n     */\n    @Test\n    public void testAllBannedWithAllowedPluginRepositories()\n        throws EnforcerRuleException\n    {\n        final String repositoryId = \"repo\";\n        rule.setAllowedPluginRepositories( Collections.singletonList( repositoryId ) );\n\n        MavenProject baseProject = createStandAloneProject();\n        addPluginRepository( baseProject, createRepository( repositoryId, \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    /**\n     * The model contains a single plugin repository. Turned off ban plugin repositories.\n     */\n    @Test\n    public void testPluginRepositoriesNotBannedWithSinglePluginRepository()\n        throws EnforcerRuleException\n    {\n        final String repositoryId = \"repo\";\n\n        rule.setBanPluginRepositories( false );\n\n        MavenProject baseProject = createStandAloneProject();\n        addPluginRepository( baseProject, createRepository( repositoryId, \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    /**\n     * The model contains no repository at all. Turned off ban plugin repositories.\n     */\n    @Test\n    public void testPluginRepositoriesNotBannedWithOutAnyRepository()\n        throws EnforcerRuleException\n    {\n        rule.setBanPluginRepositories( false );\n\n        MavenProject baseProject = createStandAloneProject();\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    @Test( expected = EnforcerRuleException.class )\n    public void testAllBannedWithSnapshotRepository()\n        throws EnforcerRuleException\n    {\n        MavenProject baseProject = createStandAloneProject();\n        addRepository( baseProject, createSnapshotRepository( \"repo\", \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    @Test\n    public void testAllBannedWithSnapshotRepositoryAllowedRepositories()\n        throws EnforcerRuleException\n    {\n        final String repositoryId = \"repo\";\n        rule.setAllowedRepositories( Collections.singletonList( repositoryId ) );\n\n        MavenProject baseProject = createStandAloneProject();\n        addRepository( baseProject, createSnapshotRepository( repositoryId, \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    @Test\n    public void testAllBannedWithSnapshotRepositoryAndSetAllowSnapshotRepositories()\n        throws EnforcerRuleException\n    {\n        final String repositoryId = \"repo\";\n        rule.setAllowSnapshotRepositories( true );\n\n        MavenProject baseProject = createStandAloneProject();\n        addRepository( baseProject, createSnapshotRepository( repositoryId, \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    @Test\n    public void testAllBannedWithSnapshotPluginRepositoryAndSetAllowSnapshotPluginRepositories()\n        throws EnforcerRuleException\n    {\n        final String repositoryId = \"repo\";\n        rule.setAllowSnapshotPluginRepositories( true );\n\n        MavenProject baseProject = createStandAloneProject();\n        addPluginRepository( baseProject, createSnapshotRepository( repositoryId, \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    @Test\n    public void testAllBannedWithEmptyRepository()\n        throws EnforcerRuleException\n    {\n        MavenProject baseProject = createStandAloneProject();\n        addEmptyRepository( baseProject );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    @Test\n    public void testAllBannedWithEmptyPluginRepository()\n        throws EnforcerRuleException\n    {\n        MavenProject baseProject = createStandAloneProject();\n        addEmptyPluginRepository( baseProject );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.Collections;\n\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.codehaus.plexus.PlexusTestCase;\n\n/**\n * Test the \"require no repositories\" rule.\n * \n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n */\npublic class TestRequireNoRepositories\n    extends PlexusTestCase\n{\n    private EnforcerRuleHelper helper;\n\n    private RequireNoRepositories rule;\n\n    private MockProject project;\n\n    public void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        rule = new RequireNoRepositories();\n        rule.setMessage( \"my message\" );\n\n        project = new MockProject();\n        project.setGroupId( \"org.apache.maven.plugins.enforcer.test\" );\n        project.setVersion( \"1.0-SNAPSHOT\" );\n\n        helper = EnforcerTestUtils.getHelper( project );\n    }\n\n    public void testAllBannedNoRepositories()\n        throws EnforcerRuleException\n    {\n        project.setArtifactId( \"no-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/no-repositories/child\" ) );\n\n        rule.execute( helper );\n    }\n\n    public void testAllBannedWithRepositories()\n        throws EnforcerRuleException\n    {\n        project.setArtifactId( \"with-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/with-repositories/child\" ) );\n\n        try\n        {\n            rule.execute( helper );\n            fail( \"Should have exception\" );\n        }\n        catch ( EnforcerRuleException e )\n        {\n            assertTrue( true );\n        }\n    }\n\n    public void testAllBannedWithAllowedRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setAllowedRepositories( Collections.singletonList( \"repo\" ) );\n\n        project.setArtifactId( \"with-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/with-repositories/child\" ) );\n\n        rule.execute( helper );\n    }\n\n    public void testAllBannedWithAllowedPluginRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setAllowedPluginRepositories( Collections.singletonList( \"repo\" ) );\n\n        project.setArtifactId( \"with-plugin-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/with-plugin-repositories/child\" ) );\n\n        rule.execute( helper );\n    }\n\n    public void testReposNotBannedNoRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setBanRepositories( false );\n\n        project.setArtifactId( \"no-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/no-repositories/child\" ) );\n\n        rule.execute( helper );\n    }\n\n    public void testReposNotBannedWithRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setBanRepositories( false );\n\n        project.setArtifactId( \"with-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/with-repositories/child\" ) );\n\n        rule.execute( helper );\n    }\n\n    public void testReposNotBannedWithPluginRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setBanRepositories( false );\n\n        project.setArtifactId( \"with-plugin-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/with-plugin-repositories/child\" ) );\n\n        try\n        {\n            rule.execute( helper );\n            fail( \"Should have exception\" );\n        }\n        catch ( EnforcerRuleException e )\n        {\n            assertTrue( true );\n        }\n    }\n\n    public void testPluginReposNotBannedNoRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setBanPluginRepositories( false );\n\n        project.setArtifactId( \"no-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/no-repositories/child\" ) );\n\n        rule.execute( helper );\n    }\n\n    public void testPluginReposNotBannedWithRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setBanPluginRepositories( false );\n\n        project.setArtifactId( \"with-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/with-repositories/child\" ) );\n\n        try\n        {\n            rule.execute( helper );\n            fail( \"Should have exception\" );\n        }\n        catch ( EnforcerRuleException e )\n        {\n            assertTrue( true );\n        }\n    }\n\n    public void testPluginReposNotBannedWithPluginRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setBanPluginRepositories( false );\n\n        project.setArtifactId( \"with-plugin-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/with-plugin-repositories/child\" ) );\n\n        rule.execute( helper );\n    }\n\n    public void testReposNotAllowedWithSnapshotRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setAllowSnapshotRepositories( true );\n\n        project.setArtifactId( \"snapshot-plugin-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/snapshot-plugin-repositories/child\" ) );\n\n        try\n        {\n            rule.execute( helper );\n            fail( \"Should have exception\" );\n        }\n        catch ( EnforcerRuleException e )\n        {\n            assertTrue( true );\n        }\n    }\n\n    public void testReposAllowedWithSnapshotRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setAllowSnapshotRepositories( true );\n\n        project.setArtifactId( \"snapshot-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/snapshot-repositories/child\" ) );\n\n        rule.execute( helper );\n    }\n\n    public void testPluginReposNotAllowedWithSnapshotRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setAllowSnapshotPluginRepositories( true );\n\n        project.setArtifactId( \"snapshot-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/snapshot-repositories/child\" ) );\n\n        try\n        {\n            rule.execute( helper );\n            fail( \"Should have exception\" );\n        }\n        catch ( EnforcerRuleException e )\n        {\n            assertTrue( true );\n        }\n    }\n\n    public void testPluginReposAllowedWithSnapshotPluginRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setAllowSnapshotPluginRepositories( true );\n\n        project.setArtifactId( \"snapshot-plugin-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/snapshot-plugin-repositories/child\" ) );\n\n        rule.execute( helper );\n    }\n\n    /**\n     * Test id.\n     */\n    public void testId()\n    {\n        RequireNoRepositories rule = new RequireNoRepositories();\n        rule.getCacheId();\n    }\n}\n","lineNo":228}
{"Refactored Sample":"package org.apache.maven.plugins.enforcer;\n\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nimport java.util.ArrayList;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.execution.ProjectDependencyGraph;\nimport org.apache.maven.model.Model;\nimport org.apache.maven.model.Repository;\nimport org.apache.maven.model.RepositoryPolicy;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.project.MavenProject;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * Test the \"require no repositories\" rule.\n * \n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n * @author <a href=\"mailto:khmarbaise@apache.org\">Karl Heinz Marbaise<\/a>\n */\npublic class TestRequireNoRepositories\n{\n    private EnforcerRuleHelper helper;\n\n    private RequireNoRepositories rule;\n\n    private MavenSession session;\n\n    @Before\n    public void before()\n        throws ExpressionEvaluationException\n    {\n        session = mock( MavenSession.class );\n        helper = mock( EnforcerRuleHelper.class );\n\n        when( helper.evaluate( \"${session}\" ) ).thenReturn( session );\n\n        Log log = mock( Log.class );\n        when( helper.getLog() ).thenReturn( log );\n\n        rule = new RequireNoRepositories();\n        rule.setMessage( \"my message\" );\n    }\n\n    private MavenProject createMavenProject()\n    {\n        MavenProject mp = mock( MavenProject.class );\n        when( mp.getGroupId() ).thenReturn( \"org.apache.maven.plugins.enforcer.test\" );\n        when( mp.getArtifactId() ).thenReturn( \"no-repositories-child\" );\n        when( mp.getVersion() ).thenReturn( \"1.0-SNAPSHOT\" );\n\n        return mp;\n    }\n\n    private Model createOriginalModel()\n    {\n        Model m = mock( Model.class );\n        when( m.getGroupId() ).thenReturn( \"org.apache.maven.plugins.enforcer.test\" );\n        when( m.getArtifactId() ).thenReturn( \"no-repositories\" );\n        when( m.getVersion() ).thenReturn( \"1.0-SNAPSHOT\" );\n        return m;\n    }\n\n    private MavenProject createStandAloneProject()\n    {\n        MavenProject mp = createMavenProject();\n        Model originalModel = createOriginalModel();\n        // This means the interpolated model is the same\n        // as the non interpolated.\n        when( mp.getModel() ).thenReturn( originalModel );\n        when( mp.getOriginalModel() ).thenReturn( originalModel );\n        return mp;\n    }\n\n    private void setupSortedProjects( List<MavenProject> projectList )\n    {\n        ProjectDependencyGraph pdg = mock( ProjectDependencyGraph.class );\n        when( session.getProjectDependencyGraph() ).thenReturn( pdg );\n        when( pdg.getSortedProjects() ).thenReturn( projectList );\n    }\n\n    private Repository createRepository( String id, String url )\n    {\n        Repository r = new Repository();\n        r.setId( id );\n        r.setUrl( url );\n        RepositoryPolicy snapshotPolicy = new RepositoryPolicy();\n        snapshotPolicy.setEnabled( false );\n        snapshotPolicy.setUpdatePolicy( \"daily\" );\n        r.setSnapshots( snapshotPolicy );\n\n        RepositoryPolicy releasePolicy = new RepositoryPolicy();\n        releasePolicy.setEnabled( true );\n        releasePolicy.setUpdatePolicy( \"never\" );\n        r.setReleases( releasePolicy );\n\n        return r;\n    }\n\n    private Repository createSnapshotRepository( String id, String url )\n    {\n        Repository r = new Repository();\n        r.setId( id );\n        r.setUrl( url );\n\n        RepositoryPolicy snapshotPolicy = new RepositoryPolicy();\n        snapshotPolicy.setEnabled( true );\n        snapshotPolicy.setUpdatePolicy( \"daily\" );\n        r.setSnapshots( snapshotPolicy );\n\n        RepositoryPolicy releasePolicy = new RepositoryPolicy();\n        releasePolicy.setEnabled( false );\n        r.setReleases( releasePolicy );\n\n        return r;\n    }\n\n    private MavenProject addRepository( MavenProject project, Repository r )\n    {\n        Model originalModel = project.getOriginalModel();\n        List<Repository> repositories = new ArrayList<Repository>();\n        repositories.add( r );\n        when( originalModel.getRepositories() ).thenReturn( repositories );\n        return project;\n    }\n\n    private MavenProject addEmptyRepository( MavenProject project )\n    {\n        Model originalModel = project.getOriginalModel();\n        List<Repository> repositories = new ArrayList<Repository>();\n        when( originalModel.getRepositories() ).thenReturn( repositories );\n        return project;\n    }\n\n    private MavenProject addPluginRepository( MavenProject project, Repository r )\n    {\n        Model originalModel = project.getOriginalModel();\n        List<Repository> repositories = new ArrayList<Repository>();\n        repositories.add( r );\n        when( originalModel.getPluginRepositories() ).thenReturn( repositories );\n        return project;\n    }\n\n    private MavenProject addEmptyPluginRepository( MavenProject project )\n    {\n        Model originalModel = project.getOriginalModel();\n        List<Repository> repositories = new ArrayList<Repository>();\n        when( originalModel.getPluginRepositories() ).thenReturn( repositories );\n        return project;\n    }\n\n    /**\n     * This model contains a single module maven project without any repository.\n     */\n    @Test\n    public void testAllBannedNoRepositories()\n        throws EnforcerRuleException\n    {\n        MavenProject baseProject = createStandAloneProject();\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    /**\n     * The model contains a single repository which is is not allowed by the default rules.\n     */\n    @Test( expected = EnforcerRuleException.class )\n    public void testAllBannedWithRepository()\n        throws EnforcerRuleException\n    {\n        MavenProject baseProject = createStandAloneProject();\n        addRepository( baseProject, createRepository( \"repo\", \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    /**\n     * The model contains a single plugin repository which is is not allowed by the default rules.\n     */\n    @Test( expected = EnforcerRuleException.class )\n    public void testAllBannedWithPluginRepository()\n        throws EnforcerRuleException\n    {\n        MavenProject baseProject = createStandAloneProject();\n        addPluginRepository( baseProject, createRepository( \"repo\", \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    /**\n     * The model contains a single repository which is allowed by setting allowedRepositories to the id.\n     */\n    @Test\n    public void testAllBannedWithAllowedRepositories()\n        throws EnforcerRuleException\n    {\n        final String repositoryId = \"repo\";\n        rule.setAllowedRepositories( Collections.singletonList( repositoryId ) );\n\n        MavenProject baseProject = createStandAloneProject();\n        addRepository( baseProject, createRepository( repositoryId, \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    /**\n     * The model contains a single repository. Turned off ban repositories.\n     */\n    @Test\n    public void testRepositoriesNotBannedWithSingleRepository()\n        throws EnforcerRuleException\n    {\n        final String repositoryId = \"repo\";\n\n        rule.setBanRepositories( false );\n\n        MavenProject baseProject = createStandAloneProject();\n        addRepository( baseProject, createRepository( repositoryId, \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    /**\n     * The model contains no repository at all. Turned off ban repositories.\n     */\n    @Test\n    public void testRepositoriesNotBannedWithOutAnyRepository()\n        throws EnforcerRuleException\n    {\n        rule.setBanRepositories( false );\n\n        MavenProject baseProject = createStandAloneProject();\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    /**\n     * This model contains a single plugin repository. The given plugin repository is added to the list of allowed\n     * plugin repositories.\n     */\n    @Test\n    public void testAllBannedWithAllowedPluginRepositories()\n        throws EnforcerRuleException\n    {\n        final String repositoryId = \"repo\";\n        rule.setAllowedPluginRepositories( Collections.singletonList( repositoryId ) );\n\n        MavenProject baseProject = createStandAloneProject();\n        addPluginRepository( baseProject, createRepository( repositoryId, \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    /**\n     * The model contains a single plugin repository. Turned off ban plugin repositories.\n     */\n    @Test\n    public void testPluginRepositoriesNotBannedWithSinglePluginRepository()\n        throws EnforcerRuleException\n    {\n        final String repositoryId = \"repo\";\n\n        rule.setBanPluginRepositories( false );\n\n        MavenProject baseProject = createStandAloneProject();\n        addPluginRepository( baseProject, createRepository( repositoryId, \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    /**\n     * The model contains no repository at all. Turned off ban plugin repositories.\n     */\n    @Test\n    public void testPluginRepositoriesNotBannedWithOutAnyRepository()\n        throws EnforcerRuleException\n    {\n        rule.setBanPluginRepositories( false );\n\n        MavenProject baseProject = createStandAloneProject();\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    @Test( expected = EnforcerRuleException.class )\n    public void testAllBannedWithSnapshotRepository()\n        throws EnforcerRuleException\n    {\n        MavenProject baseProject = createStandAloneProject();\n        addRepository( baseProject, createSnapshotRepository( \"repo\", \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    @Test\n    public void testAllBannedWithSnapshotRepositoryAllowedRepositories()\n        throws EnforcerRuleException\n    {\n        final String repositoryId = \"repo\";\n        rule.setAllowedRepositories( Collections.singletonList( repositoryId ) );\n\n        MavenProject baseProject = createStandAloneProject();\n        addRepository( baseProject, createSnapshotRepository( repositoryId, \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    @Test\n    public void testAllBannedWithSnapshotRepositoryAndSetAllowSnapshotRepositories()\n        throws EnforcerRuleException\n    {\n        final String repositoryId = \"repo\";\n        rule.setAllowSnapshotRepositories( true );\n\n        MavenProject baseProject = createStandAloneProject();\n        addRepository( baseProject, createSnapshotRepository( repositoryId, \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    @Test\n    public void testAllBannedWithSnapshotPluginRepositoryAndSetAllowSnapshotPluginRepositories()\n        throws EnforcerRuleException\n    {\n        final String repositoryId = \"repo\";\n        rule.setAllowSnapshotPluginRepositories( true );\n\n        MavenProject baseProject = createStandAloneProject();\n        addPluginRepository( baseProject, createSnapshotRepository( repositoryId, \"http://example.com/repo\" ) );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    @Test\n    public void testAllBannedWithEmptyRepository()\n        throws EnforcerRuleException\n    {\n        MavenProject baseProject = createStandAloneProject();\n        addEmptyRepository( baseProject );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n    @Test\n    public void testAllBannedWithEmptyPluginRepository()\n        throws EnforcerRuleException\n    {\n        MavenProject baseProject = createStandAloneProject();\n        addEmptyPluginRepository( baseProject );\n        setupSortedProjects( Collections.singletonList( baseProject ) );\n\n        rule.execute( helper );\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.Collections;\n\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.codehaus.plexus.PlexusTestCase;\n\n/**\n * Test the \"require no repositories\" rule.\n * \n * @author <a href=\"mailto:brett@apache.org\">Brett Porter<\/a>\n */\npublic class TestRequireNoRepositories\n    extends PlexusTestCase\n{\n    private EnforcerRuleHelper helper;\n\n    private RequireNoRepositories rule;\n\n    private MockProject project;\n\n    public void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        rule = new RequireNoRepositories();\n        rule.setMessage( \"my message\" );\n\n        project = new MockProject();\n        project.setGroupId( \"org.apache.maven.plugins.enforcer.test\" );\n        project.setVersion( \"1.0-SNAPSHOT\" );\n\n        helper = EnforcerTestUtils.getHelper( project );\n    }\n\n    public void testAllBannedNoRepositories()\n        throws EnforcerRuleException\n    {\n        project.setArtifactId( \"no-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/no-repositories/child\" ) );\n\n        rule.execute( helper );\n    }\n\n    public void testAllBannedWithRepositories()\n        throws EnforcerRuleException\n    {\n        project.setArtifactId( \"with-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/with-repositories/child\" ) );\n\n        try\n        {\n            rule.execute( helper );\n            fail( \"Should have exception\" );\n        }\n        catch ( EnforcerRuleException e )\n        {\n            assertTrue( true );\n        }\n    }\n\n    public void testAllBannedWithAllowedRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setAllowedRepositories( Collections.singletonList( \"repo\" ) );\n\n        project.setArtifactId( \"with-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/with-repositories/child\" ) );\n\n        rule.execute( helper );\n    }\n\n    public void testAllBannedWithAllowedPluginRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setAllowedPluginRepositories( Collections.singletonList( \"repo\" ) );\n\n        project.setArtifactId( \"with-plugin-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/with-plugin-repositories/child\" ) );\n\n        rule.execute( helper );\n    }\n\n    public void testReposNotBannedNoRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setBanRepositories( false );\n\n        project.setArtifactId( \"no-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/no-repositories/child\" ) );\n\n        rule.execute( helper );\n    }\n\n    public void testReposNotBannedWithRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setBanRepositories( false );\n\n        project.setArtifactId( \"with-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/with-repositories/child\" ) );\n\n        rule.execute( helper );\n    }\n\n    public void testReposNotBannedWithPluginRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setBanRepositories( false );\n\n        project.setArtifactId( \"with-plugin-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/with-plugin-repositories/child\" ) );\n\n        try\n        {\n            rule.execute( helper );\n            fail( \"Should have exception\" );\n        }\n        catch ( EnforcerRuleException e )\n        {\n            assertTrue( true );\n        }\n    }\n\n    public void testPluginReposNotBannedNoRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setBanPluginRepositories( false );\n\n        project.setArtifactId( \"no-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/no-repositories/child\" ) );\n\n        rule.execute( helper );\n    }\n\n    public void testPluginReposNotBannedWithRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setBanPluginRepositories( false );\n\n        project.setArtifactId( \"with-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/with-repositories/child\" ) );\n\n        try\n        {\n            rule.execute( helper );\n            fail( \"Should have exception\" );\n        }\n        catch ( EnforcerRuleException e )\n        {\n            assertTrue( true );\n        }\n    }\n\n    public void testPluginReposNotBannedWithPluginRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setBanPluginRepositories( false );\n\n        project.setArtifactId( \"with-plugin-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/with-plugin-repositories/child\" ) );\n\n        rule.execute( helper );\n    }\n\n    public void testReposNotAllowedWithSnapshotRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setAllowSnapshotRepositories( true );\n\n        project.setArtifactId( \"snapshot-plugin-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/snapshot-plugin-repositories/child\" ) );\n\n        try\n        {\n            rule.execute( helper );\n            fail( \"Should have exception\" );\n        }\n        catch ( EnforcerRuleException e )\n        {\n            assertTrue( true );\n        }\n    }\n\n    public void testReposAllowedWithSnapshotRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setAllowSnapshotRepositories( true );\n\n        project.setArtifactId( \"snapshot-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/snapshot-repositories/child\" ) );\n\n        rule.execute( helper );\n    }\n\n    public void testPluginReposNotAllowedWithSnapshotRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setAllowSnapshotPluginRepositories( true );\n\n        project.setArtifactId( \"snapshot-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/snapshot-repositories/child\" ) );\n\n        try\n        {\n            rule.execute( helper );\n            fail( \"Should have exception\" );\n        }\n        catch ( EnforcerRuleException e )\n        {\n            assertTrue( true );\n        }\n    }\n\n    public void testPluginReposAllowedWithSnapshotPluginRepositories()\n        throws EnforcerRuleException\n    {\n        rule.setAllowSnapshotPluginRepositories( true );\n\n        project.setArtifactId( \"snapshot-plugin-repositories-child\" );\n        project.setBaseDir( getTestFile( \"target/test-classes/requireNoRepositories/snapshot-plugin-repositories/child\" ) );\n\n        rule.execute( helper );\n    }\n\n    /**\n     * Test id.\n     */\n    public void testId()\n    {\n        RequireNoRepositories rule = new RequireNoRepositories();\n        rule.getCacheId();\n    }\n}\n","lineNo":279}
{"Refactored Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.Iterator;\n\nimport org.apache.maven.enforcer.rule.api.EnforcerRule;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.model.Activation;\nimport org.apache.maven.model.ActivationOS;\nimport org.apache.maven.model.Profile;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.profiles.activation.OperatingSystemProfileActivator;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * This rule checks that the OS is allowed by combinations of family, name, version and cpu architecture. The behavior\n * is exactly the same as the Maven Os profile activation so the same values are allowed here.\n *\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n * @version $Id$\n */\npublic class RequireOS\n    extends AbstractStandardEnforcerRule\n{\n\n    /**\n     * The OS family type desired<br />\n     * Possible values:\n     * <ul>\n     * <li>dos<\/li>\n     * <li>mac<\/li>\n     * <li>netware<\/li>\n     * <li>os/2<\/li>\n     * <li>tandem<\/li>\n     * <li>unix<\/li>\n     * <li>windows<\/li>\n     * <li>win9x<\/li>\n     * <li>z/os<\/li>\n     * <li>os/400<\/li>\n     * <\/ul>\n     * \n     * @see {@link #setFamily(String)}\n     * @see {@link #getFamily()}\n     */\n    private String family = null;\n\n    /**\n     * The OS name desired.\n     *\n     * @see {@link #setName(String)}\n     * @see {@link #getName()}\n     */\n    private String name = null;\n\n    /**\n     * The OS version desired.\n     * \n     * @see {@link #setVersion(String)}\n     * @see {@link #getVersion()}\n     */\n    private String version = null;\n\n    /**\n     * The OS architecture desired.\n     * \n     * @see {@link #setArch(String)}\n     * @see {@link #getArch()}\n     */\n    private String arch = null;\n\n    /**\n     * Display detected OS information.\n     * \n     * @see {@link #setDisplay(boolean)}\n     * @see {@link #isDisplay()}\n     */\n    private boolean display = false;\n\n    /**\n     * Instantiates a new RequireOS.\n     */\n    public RequireOS()\n    {\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n\n        displayOSInfo( helper.getLog(), display );\n\n        if ( allParamsEmpty() )\n        {\n            throw new EnforcerRuleException( \"All parameters can not be empty. \"\n                + \"You must pick at least one of (family, name, version, arch) \"\n                + \"or use -Denforcer.os.display=true to see the current OS information.\" );\n        }\n\n        if ( isValidFamily( this.family ) )\n        {\n            if ( !isAllowed() )\n            {\n                String message = getMessage();\n                if ( StringUtils.isEmpty( message ) )\n                {\n                    //@formatter:off\n                    message =\n                        ( \"OS Arch: \" \n                            + Os.OS_ARCH + \" Family: \" \n                            + Os.OS_FAMILY + \" Name: \" \n                            + Os.OS_NAME + \" Version: \"\n                            + Os.OS_VERSION + \" is not allowed by\" + ( arch != null ? \" Arch=\" + arch : \"\" )\n                            + ( family != null ? \" Family=\" + family : \"\" ) \n                            + ( name != null ? \" Name=\" + name : \"\" ) \n                            + ( version != null ? \" Version=\" + version : \"\" ) );\n                    //@formatter:on\n                }\n                throw new EnforcerRuleException( message );\n            }\n        }\n        else\n        {\n            final int minimumBufferSize = 50;\n            StringBuilder buffer = new StringBuilder( minimumBufferSize );\n            Iterator<?> iter = Os.getValidFamilies().iterator();\n            while ( iter.hasNext() )\n            {\n                buffer.append( iter.next() );\n                buffer.append( \", \" );\n            }\n            String help = StringUtils.stripEnd( buffer.toString().trim(), \".\" );\n            throw new EnforcerRuleException( \"Invalid Family type used. Valid family types are: \" + help );\n        }\n    }\n\n    /**\n     * Log the current OS information.\n     *\n     * @param log the log\n     * @param info the info\n     */\n    public void displayOSInfo( Log log, boolean info )\n    {\n        String string =\n            \"OS Info: Arch: \" + Os.OS_ARCH + \" Family: \" + Os.OS_FAMILY + \" Name: \" + Os.OS_NAME + \" Version: \"\n                + Os.OS_VERSION;\n\n        if ( !info )\n        {\n            log.debug( string );\n        }\n        else\n        {\n            log.info( string );\n        }\n    }\n\n    /**\n     * Helper method to determine if the current OS is allowed based on the injected values for family, name, version\n     * and arch.\n     *\n     * @return true if the version is allowed.\n     */\n    public boolean isAllowed()\n    {\n        OperatingSystemProfileActivator activator = new OperatingSystemProfileActivator();\n\n        return activator.isActive( createProfile() );\n    }\n\n    /**\n     * Helper method to check that at least one of family, name, version or arch is set.\n     *\n     * @return true if all parameters are empty.\n     */\n    public boolean allParamsEmpty()\n    {\n        // CHECKSTYLE_OFF: LineLength\n        return ( StringUtils.isEmpty( family ) && StringUtils.isEmpty( arch ) && StringUtils.isEmpty( name ) && StringUtils.isEmpty( version ) );\n        // CHECKSTYLE_ON: LineLength\n    }\n\n    /**\n     * Creates a Profile object that contains the activation information.\n     *\n     * @return a properly populated profile to be used for OS validation.\n     */\n    private Profile createProfile()\n    {\n        Profile profile = new Profile();\n        profile.setActivation( createActivation() );\n        return profile;\n    }\n\n    /**\n     * Creates an Activation object that contains the ActivationOS information.\n     *\n     * @return a properly populated Activation object.\n     */\n    private Activation createActivation()\n    {\n        Activation activation = new Activation();\n        activation.setActiveByDefault( false );\n        activation.setOs( createOsBean() );\n        return activation;\n    }\n\n    /**\n     * Creates an ActivationOS object containing family, name, version and arch.\n     *\n     * @return a properly populated ActivationOS object.\n     */\n    private ActivationOS createOsBean()\n    {\n        ActivationOS os = new ActivationOS();\n\n        os.setArch( arch );\n        os.setFamily( family );\n        os.setName( name );\n        os.setVersion( version );\n\n        return os;\n    }\n\n    /**\n     * Helper method to check if the given family is in the following list:\n     * <ul>\n     * <li>dos<\/li>\n     * <li>mac<\/li>\n     * <li>netware<\/li>\n     * <li>os/2<\/li>\n     * <li>tandem<\/li>\n     * <li>unix<\/li>\n     * <li>windows<\/li>\n     * <li>win9x<\/li>\n     * <li>z/os<\/li>\n     * <li>os/400<\/li>\n     * <\/ul>\n     * Note: '!' is allowed at the beginning of the string and still considered valid.\n     *\n     * @param theFamily the family to check.\n     * @return true if one of the valid families.\n     */\n    public boolean isValidFamily( String theFamily )\n    {\n\n        // in case they are checking !family\n        theFamily = StringUtils.stripStart( theFamily, \"!\" );\n\n        return ( StringUtils.isEmpty( theFamily ) || Os.getValidFamilies().contains( theFamily ) );\n    }\n\n    /**\n     * Gets the arch.\n     *\n     * @return the arch\n     */\n    public String getArch()\n    {\n        return this.arch;\n    }\n\n    /**\n     * Sets the arch.\n     *\n     * @param theArch the arch to set\n     */\n    public void setArch( String theArch )\n    {\n        this.arch = theArch;\n    }\n\n    /**\n     * Gets the family.\n     *\n     * @return the family\n     */\n    public String getFamily()\n    {\n        return this.family;\n    }\n\n    /**\n     * Sets the family.\n     *\n     * @param theFamily the family to set\n     */\n    public void setFamily( String theFamily )\n    {\n        this.family = theFamily;\n    }\n\n    /**\n     * Gets the name.\n     *\n     * @return the name\n     */\n    public String getName()\n    {\n        return this.name;\n    }\n\n    /**\n     * Sets the name.\n     *\n     * @param theName the name to set\n     */\n    public void setName( String theName )\n    {\n        this.name = theName;\n    }\n\n    /**\n     * Gets the version.\n     *\n     * @return the version\n     */\n    public String getVersion()\n    {\n        return this.version;\n    }\n\n    /**\n     * Sets the version.\n     *\n     * @param theVersion the version to set\n     */\n    public void setVersion( String theVersion )\n    {\n        this.version = theVersion;\n    }\n\n    /**\n     * @param display The value for the display.\n     */\n    public final void setDisplay( boolean display )\n    {\n        this.display = display;\n    }\n\n    public final boolean isDisplay()\n    {\n        return display;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getCacheId()\n    {\n        // return the hashcodes of all the parameters\n        StringBuffer b = new StringBuffer();\n        if ( StringUtils.isNotEmpty( version ) )\n        {\n            b.append( version.hashCode() );\n        }\n        if ( StringUtils.isNotEmpty( name ) )\n        {\n            b.append( name.hashCode() );\n        }\n        if ( StringUtils.isNotEmpty( arch ) )\n        {\n            b.append( arch.hashCode() );\n        }\n        if ( StringUtils.isNotEmpty( family ) )\n        {\n            b.append( family.hashCode() );\n        }\n        return b.toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isCacheable()\n    {\n        // the os is not going to change between projects in the same build.\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isResultValid( EnforcerRule theCachedRule )\n    {\n        // i will always return the hash of the parameters as my id. If my parameters are the same, this\n        // rule must always have the same result.\n        return true;\n    }\n}\n","Smelly Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.Iterator;\n\nimport org.apache.maven.enforcer.rule.api.EnforcerRule;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.model.Activation;\nimport org.apache.maven.model.ActivationOS;\nimport org.apache.maven.model.Profile;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.profiles.activation.OperatingSystemProfileActivator;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * This rule checks that the OS is allowed by combinations of family, name, version and cpu architecture. The behavior\n * is exactly the same as the Maven Os profile activation so the same values are allowed here.\n *\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n * @version $Id$\n */\npublic class RequireOS\n    extends AbstractStandardEnforcerRule\n{\n\n    /**\n     * The OS family type desired<br />\n     * Possible values:\n     * <ul>\n     * <li>dos<\/li>\n     * <li>mac<\/li>\n     * <li>netware<\/li>\n     * <li>os/2<\/li>\n     * <li>tandem<\/li>\n     * <li>unix<\/li>\n     * <li>windows<\/li>\n     * <li>win9x<\/li>\n     * <li>z/os<\/li>\n     * <li>os/400<\/li>\n     * <\/ul>\n     * \n     * @deprecated the visibility will be reduced to private with the next major version\n     * @see {@link #setFamily(String)}\n     * @see {@link #getFamily()}\n     */\n    public String family = null;\n\n    /**\n     * The OS name desired.\n     *\n     * @deprecated the visibility will be reduced to private with the next major version\n     * @see {@link #setName(String)}\n     * @see {@link #getName()}\n     */\n    public String name = null;\n\n    /**\n     * The OS version desired.\n     * \n     * @deprecated the visibility will be reduced to private with the next major version\n     * @see {@link #setVersion(String)}\n     * @see {@link #getVersion()}\n     */\n    public String version = null;\n\n    /**\n     * The OS architecture desired.\n     * \n     * @deprecated the visibility will be reduced to private with the next major version\n     * @see {@link #setArch(String)}\n     * @see {@link #getArch()}\n     */\n    public String arch = null;\n\n    /**\n     * Display detected OS information.\n     * \n     * @deprecated the visibility will be reduced to private with the next major version\n     * @see {@link #setDisplay(boolean)}\n     * @see {@link #isDisplay()}\n     */\n    public boolean display = false;\n\n    /**\n     * Instantiates a new RequireOS.\n     */\n    public RequireOS()\n    {\n\n    }\n\n    /*\n     * (non-Javadoc)\n     * @see\n     * org.apache.maven.enforcer.rule.api.EnforcerRule#execute(org.apache.maven.enforcer.rule.api.EnforcerRuleHelper)\n     */\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n\n        displayOSInfo( helper.getLog(), display );\n\n        if ( allParamsEmpty() )\n        {\n            throw new EnforcerRuleException(\n                                             \"All parameters can not be empty. You must pick at least one of (family, name, version, arch) or use -Denforcer.os.display=true to see the current OS information.\" );\n        }\n\n        if ( isValidFamily( this.family ) )\n        {\n            if ( !isAllowed() )\n            {\n                String message = getMessage();\n                if ( StringUtils.isEmpty( message ) )\n                {\n                    message =\n                        ( \"OS Arch: \" + Os.OS_ARCH + \" Family: \" + Os.OS_FAMILY + \" Name: \" + Os.OS_NAME + \" Version: \"\n                            + Os.OS_VERSION + \" is not allowed by\" + ( arch != null ? \" Arch=\" + arch : \"\" )\n                            + ( family != null ? \" Family=\" + family : \"\" ) + ( name != null ? \" Name=\" + name : \"\" ) + ( version != null ? \" Version=\"\n                            + version\n                                        : \"\" ) );\n                }\n                throw new EnforcerRuleException( message );\n            }\n        }\n        else\n        {\n            StringBuilder buffer = new StringBuilder( 50 );\n            Iterator<?> iter = Os.getValidFamilies().iterator();\n            while ( iter.hasNext() )\n            {\n                buffer.append( iter.next() );\n                buffer.append( \", \" );\n            }\n            String help = StringUtils.stripEnd( buffer.toString().trim(), \".\" );\n            throw new EnforcerRuleException( \"Invalid Family type used. Valid family types are: \" + help );\n        }\n    }\n\n    /**\n     * Log the current OS information.\n     *\n     * @param log the log\n     * @param info the info\n     */\n    public void displayOSInfo( Log log, boolean info )\n    {\n        String string =\n            \"OS Info: Arch: \" + Os.OS_ARCH + \" Family: \" + Os.OS_FAMILY + \" Name: \" + Os.OS_NAME + \" Version: \"\n                + Os.OS_VERSION;\n\n        if ( !info )\n        {\n            log.debug( string );\n        }\n        else\n        {\n            log.info( string );\n        }\n    }\n\n    /**\n     * Helper method to determine if the current OS is allowed based on the injected values for family, name, version\n     * and arch.\n     *\n     * @return true if the version is allowed.\n     */\n    public boolean isAllowed()\n    {\n        OperatingSystemProfileActivator activator = new OperatingSystemProfileActivator();\n\n        return activator.isActive( createProfile() );\n    }\n\n    /**\n     * Helper method to check that at least one of family, name, version or arch is set.\n     *\n     * @return true if all parameters are empty.\n     */\n    public boolean allParamsEmpty()\n    {\n        return ( StringUtils.isEmpty( family ) && StringUtils.isEmpty( arch ) && StringUtils.isEmpty( name ) && StringUtils.isEmpty( version ) );\n\n    }\n\n    /**\n     * Creates a Profile object that contains the activation information.\n     *\n     * @return a properly populated profile to be used for OS validation.\n     */\n    private Profile createProfile()\n    {\n        Profile profile = new Profile();\n        profile.setActivation( createActivation() );\n        return profile;\n    }\n\n    /**\n     * Creates an Activation object that contains the ActivationOS information.\n     *\n     * @return a properly populated Activation object.\n     */\n    private Activation createActivation()\n    {\n        Activation activation = new Activation();\n        activation.setActiveByDefault( false );\n        activation.setOs( createOsBean() );\n        return activation;\n    }\n\n    /**\n     * Creates an ActivationOS object containing family, name, version and arch.\n     *\n     * @return a properly populated ActivationOS object.\n     */\n    private ActivationOS createOsBean()\n    {\n        ActivationOS os = new ActivationOS();\n\n        os.setArch( arch );\n        os.setFamily( family );\n        os.setName( name );\n        os.setVersion( version );\n\n        return os;\n    }\n\n    /**\n     * Helper method to check if the given family is in the following list:\n     * <ul>\n     * <li>dos<\/li>\n     * <li>mac<\/li>\n     * <li>netware<\/li>\n     * <li>os/2<\/li>\n     * <li>tandem<\/li>\n     * <li>unix<\/li>\n     * <li>windows<\/li>\n     * <li>win9x<\/li>\n     * <li>z/os<\/li>\n     * <li>os/400<\/li>\n     * <\/ul>\n     * Note: '!' is allowed at the beginning of the string and still considered valid.\n     *\n     * @param theFamily the family to check.\n     * @return true if one of the valid families.\n     */\n    public boolean isValidFamily( String theFamily )\n    {\n\n        // in case they are checking !family\n        theFamily = StringUtils.stripStart( theFamily, \"!\" );\n\n        return ( StringUtils.isEmpty( theFamily ) || Os.getValidFamilies().contains( theFamily ) );\n    }\n\n    /**\n     * Gets the arch.\n     *\n     * @return the arch\n     */\n    public String getArch()\n    {\n        return this.arch;\n    }\n\n    /**\n     * Sets the arch.\n     *\n     * @param theArch the arch to set\n     */\n    public void setArch( String theArch )\n    {\n        this.arch = theArch;\n    }\n\n    /**\n     * Gets the family.\n     *\n     * @return the family\n     */\n    public String getFamily()\n    {\n        return this.family;\n    }\n\n    /**\n     * Sets the family.\n     *\n     * @param theFamily the family to set\n     */\n    public void setFamily( String theFamily )\n    {\n        this.family = theFamily;\n    }\n\n    /**\n     * Gets the name.\n     *\n     * @return the name\n     */\n    public String getName()\n    {\n        return this.name;\n    }\n\n    /**\n     * Sets the name.\n     *\n     * @param theName the name to set\n     */\n    public void setName( String theName )\n    {\n        this.name = theName;\n    }\n\n    /**\n     * Gets the version.\n     *\n     * @return the version\n     */\n    public String getVersion()\n    {\n        return this.version;\n    }\n\n    /**\n     * Sets the version.\n     *\n     * @param theVersion the version to set\n     */\n    public void setVersion( String theVersion )\n    {\n        this.version = theVersion;\n    }\n\n    public final void setDisplay( boolean display )\n    {\n        this.display = display;\n    }\n\n    public final boolean isDisplay()\n    {\n        return display;\n    }\n\n    /*\n     * (non-Javadoc)\n     * @see org.apache.maven.enforcer.rule.api.EnforcerRule#getCacheId()\n     */\n    public String getCacheId()\n    {\n        // return the hashcodes of all the parameters\n        StringBuffer b = new StringBuffer();\n        if ( StringUtils.isNotEmpty( version ) )\n        {\n            b.append( version.hashCode() );\n        }\n        if ( StringUtils.isNotEmpty( name ) )\n        {\n            b.append( name.hashCode() );\n        }\n        if ( StringUtils.isNotEmpty( arch ) )\n        {\n            b.append( arch.hashCode() );\n        }\n        if ( StringUtils.isNotEmpty( family ) )\n        {\n            b.append( family.hashCode() );\n        }\n        return b.toString();\n    }\n\n    /*\n     * (non-Javadoc)\n     * @see org.apache.maven.enforcer.rule.api.EnforcerRule#isCacheable()\n     */\n    public boolean isCacheable()\n    {\n        // the os is not going to change between projects in the same build.\n        return true;\n    }\n\n    /*\n     * (non-Javadoc)\n     * @see\n     * org.apache.maven.enforcer.rule.api.EnforcerRule#isResultValid(org.apache.maven.enforcer.rule.api.EnforcerRule)\n     */\n    public boolean isResultValid( EnforcerRule theCachedRule )\n    {\n        // i will always return the hash of the parameters as my id. If my parameters are the same, this\n        // rule must always have the same result.\n        return true;\n    }\n}\n","lineNo":147}
{"Refactored Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.versioning.InvalidVersionSpecificationException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.plugins.enforcer.utils.ArtifactMatcher;\nimport org.apache.maven.plugins.enforcer.utils.ArtifactMatcher.Pattern;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * This rule checks that lists of dependencies are not included.\n * \n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n * @version $Id$\n */\npublic class BannedDependencies\n    extends AbstractBanDependencies\n{\n\n    /**\n     * Specify the banned dependencies. This can be a list of artifacts in the format\n     * <code>groupId[:artifactId][:version]<\/code>. Any of the sections can be a wildcard by using '*' (ie group:*:1.0) <br>\n     * The rule will fail if any dependency matches any exclude, unless it also matches an include rule.\n     * \n     * @see {@link #setExcludes(List)}\n     * @see {@link #getExcludes()}\n     * @deprecated the visibility will be reduced to private with the next major version\n     */\n    public List<String> excludes = null;\n\n    /**\n     * Specify the allowed dependencies. This can be a list of artifacts in the format\n     * <code>groupId[:artifactId][:version]<\/code>. Any of the sections can be a wildcard by using '*' (ie group:*:1.0) <br>\n     * Includes override the exclude rules. It is meant to allow wide exclusion rules with wildcards and still allow a\n     * smaller set of includes. <br>\n     * For example, to ban all xerces except xerces-api -> exclude \"xerces\", include \"xerces:xerces-api\"\n     * \n     * @see {@link #setIncludes(List)}\n     * @see {@link #getIncludes()}\n     * @deprecated the visibility will be reduced to private with the next major version\n     */\n    public List<String> includes = null;\n\n    /**\n     * {@inheritDoc}\n     */\n    protected Set<Artifact> checkDependencies( Set<Artifact> theDependencies, Log log )\n        throws EnforcerRuleException\n    {\n\n        Set<Artifact> excluded = checkDependencies( theDependencies, excludes );\n\n        // anything specifically included should be removed\n        // from the ban list.\n        if ( excluded != null )\n        {\n            Set<Artifact> included = checkDependencies( theDependencies, includes );\n\n            if ( included != null )\n            {\n                excluded.removeAll( included );\n            }\n        }\n        return excluded;\n\n    }\n\n    /**\n     * Checks the set of dependencies against the list of patterns.\n     * \n     * @param thePatterns the patterns\n     * @param dependencies the dependencies\n     * @return a set containing artifacts matching one of the patterns or <code>null<\/code>\n     * @throws EnforcerRuleException the enforcer rule exception\n     */\n    private Set<Artifact> checkDependencies( Set<Artifact> dependencies, List<String> thePatterns )\n        throws EnforcerRuleException\n    {\n        Set<Artifact> foundMatches = null;\n\n        if ( thePatterns != null && thePatterns.size() > 0 )\n        {\n\n            for ( String pattern : thePatterns )\n            {\n                String[] subStrings = pattern.split( \":\" );\n                subStrings = StringUtils.stripAll( subStrings );\n                String resultPattern = StringUtils.join( subStrings, \":\" );\n\n                for ( Artifact artifact : dependencies )\n                {\n                    if ( compareDependency( resultPattern, artifact ) )\n                    {\n                        // only create if needed\n                        if ( foundMatches == null )\n                        {\n                            foundMatches = new HashSet<Artifact>();\n                        }\n                        foundMatches.add( artifact );\n                    }\n                }\n            }\n        }\n        return foundMatches;\n    }\n\n    /**\n     * Compares the given pattern against the given artifact. The pattern should follow the format\n     * <code>groupId:artifactId:version:type:scope:classifier<\/code>.\n     * \n     * @param pattern The pattern to compare the artifact with.\n     * @param artifact the artifact\n     * @return <code>true<\/code> if the artifact matches one of the patterns\n     * @throws EnforcerRuleException the enforcer rule exception\n     */\n    protected boolean compareDependency( String pattern, Artifact artifact )\n        throws EnforcerRuleException\n    {\n\n        ArtifactMatcher.Pattern am = new Pattern( pattern );\n        boolean result;\n        try\n        {\n            result = am.match( artifact );\n        }\n        catch ( InvalidVersionSpecificationException e )\n        {\n            throw new EnforcerRuleException( \"Invalid Version Range: \", e );\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets the excludes.\n     * \n     * @return the excludes\n     */\n    public List<String> getExcludes()\n    {\n        return this.excludes;\n    }\n\n    /**\n     * Sets the excludes.\n     * \n     * @param theExcludes the excludes to set\n     */\n    public void setExcludes( List<String> theExcludes )\n    {\n        this.excludes = theExcludes;\n    }\n\n    /**\n     * Gets the includes.\n     * \n     * @return the includes\n     */\n    public List<String> getIncludes()\n    {\n        return this.includes;\n    }\n\n    /**\n     * Sets the includes.\n     * \n     * @param theIncludes the includes to set\n     */\n    public void setIncludes( List<String> theIncludes )\n    {\n        this.includes = theIncludes;\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.versioning.DefaultArtifactVersion;\nimport org.apache.maven.artifact.versioning.InvalidVersionSpecificationException;\nimport org.apache.maven.artifact.versioning.VersionRange;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.plugin.logging.Log;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * This rule checks that lists of dependencies are not included.\n *\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n * @version $Id$\n */\npublic class BannedDependencies\n    extends AbstractBanDependencies\n{\n\n    /**\n     * Specify the banned dependencies. This can be a list of artifacts in the format <code>groupId[:artifactId][:version]<\/code>.\n     * Any of the sections can be a wildcard by using '*' (ie group:*:1.0) <br>\n     * The rule will fail if any dependency matches any exclude, unless it also matches an include rule.\n     * \n     * @deprecated the visibility will be reduced to private with the next major version\n     * @see {@link #setExcludes(List)}\n     * @see {@link #getExcludes()}\n     */\n    public List<String> excludes = null;\n\n    /**\n     * Specify the allowed dependencies. This can be a list of artifacts in the format <code>groupId[:artifactId][:version]<\/code>.\n     * Any of the sections can be a wildcard by using '*' (ie group:*:1.0) <br>\n     * Includes override the exclude rules. It is meant to allow wide exclusion rules with wildcards and still allow a\n     * smaller set of includes. <br>\n     * For example, to ban all xerces except xerces-api -> exclude \"xerces\", include \"xerces:xerces-api\"\n     * \n     * @deprecated the visibility will be reduced to private with the next major version\n     * @see {@link #setIncludes(List)}\n     * @see {@link #getIncludes()}\n     */\n    public List<String> includes = null;\n\n\n    /**\n     * {@inheritDoc}\n     */\n    protected Set<Artifact> checkDependencies( Set<Artifact> theDependencies, Log log )\n        throws EnforcerRuleException\n    {\n        Set<Artifact> excluded = checkDependencies( theDependencies, excludes );\n\n        // anything specifically included should be removed\n        // from the ban list.\n        if ( excluded != null )\n        {\n            Set<Artifact> included = checkDependencies( theDependencies, includes );\n            if ( included != null )\n            {\n                excluded.removeAll( included );\n            }\n        }\n        return excluded;\n\n    }\n\n    /**\n     * Checks the set of dependencies against the list of patterns.\n     *\n     * @param thePatterns the patterns\n     * @param dependencies the dependencies\n     * @return a set containing artifacts matching one of the patterns or <code>null<\/code>\n     * @throws EnforcerRuleException the enforcer rule exception\n     */\n    private Set<Artifact> checkDependencies( Set<Artifact> dependencies, List<String> thePatterns )\n        throws EnforcerRuleException\n    {\n        Set<Artifact> foundMatches = null;\n\n        if ( thePatterns != null && thePatterns.size() > 0 )\n        {\n\n            for ( String pattern : thePatterns )\n            {\n\n                String[] subStrings = pattern.split( \":\" );\n                subStrings = StringUtils.stripAll( subStrings );\n\n                for ( Artifact artifact : dependencies )\n                {\n                    if ( compareDependency( subStrings, artifact ) )\n                    {\n                        // only create if needed\n                        if ( foundMatches == null )\n                        {\n                            foundMatches = new HashSet<Artifact>();\n                        }\n                        foundMatches.add( artifact );\n                    }\n                }\n            }\n        }\n        return foundMatches;\n    }\n\n    /**\n     * Compares the parsed array of substrings against the artifact.\n     * The pattern should follow the format \"groupId:artifactId:version:type:scope\"\n     *\n     * @param pattern the array of patterns\n     * @param artifact the artifact\n     * @return <code>true<\/code> if the artifact matches one of the patterns\n     * @throws EnforcerRuleException the enforcer rule exception\n     */\n    protected boolean compareDependency( String[] pattern, Artifact artifact )\n        throws EnforcerRuleException\n    {\n\n        boolean result = false;\n        if ( pattern.length > 0 )\n        {\n            result = pattern[0].equals( \"*\" ) || artifact.getGroupId().equals( pattern[0] );\n        }\n\n        if ( result && pattern.length > 1 )\n        {\n            result = pattern[1].equals( \"*\" ) || artifact.getArtifactId().equals( pattern[1] );\n        }\n\n        if ( result && pattern.length > 2 )\n        {\n            // short circuit if the versions are exactly the same\n            if ( pattern[2].equals( \"*\" ) || artifact.getVersion().equals( pattern[2] ) )\n            {\n                result = true;\n            }\n            else\n            {\n                try\n                {\n                    result =\n                        AbstractVersionEnforcer.containsVersion( VersionRange.createFromVersionSpec( pattern[2] ),\n                                                                 new DefaultArtifactVersion( artifact.getBaseVersion() ) );\n                }\n                catch ( InvalidVersionSpecificationException e )\n                {\n                    throw new EnforcerRuleException( \"Invalid Version Range: \", e );\n                }\n            }\n        }\n\n        if ( result && pattern.length > 3 )\n        {\n            String type = artifact.getType();\n            if ( type == null || type.equals( \"\" ) )\n            {\n                type = \"jar\";\n            }\n            result = pattern[3].equals( \"*\" ) || type.equals( pattern[3] );\n        }\n\n        if ( result && pattern.length > 4 )\n        {\n            String scope = artifact.getScope();\n            if ( scope == null || scope.equals( \"\" ) )\n            {\n                scope = \"compile\";\n            }\n            result = pattern[4].equals( \"*\" ) || scope.equals( pattern[4] );\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets the excludes.\n     *\n     * @return the excludes\n     */\n    public List<String> getExcludes()\n    {\n        return this.excludes;\n    }\n\n    /**\n     * Sets the excludes.\n     *\n     * @param theExcludes the excludes to set\n     */\n    public void setExcludes( List<String> theExcludes )\n    {\n        this.excludes = theExcludes;\n    }\n\n    /**\n     * Gets the includes.\n     *\n     * @return the includes\n     */\n    public List<String> getIncludes()\n    {\n        return this.includes;\n    }\n\n    /**\n     * Sets the includes.\n     *\n     * @param theIncludes the includes to set\n     */\n    public void setIncludes( List<String> theIncludes )\n    {\n        this.includes = theIncludes;\n    }\n\n}\n","lineNo":111}
{"Refactored Sample":"package org.apache.maven.plugins.enforcer.utils;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.model.Model;\nimport org.apache.maven.model.Parent;\nimport org.apache.maven.model.Plugin;\nimport org.apache.maven.model.ReportPlugin;\nimport org.apache.maven.model.io.xpp3.MavenXpp3Reader;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.project.MavenProject;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\nimport org.codehaus.plexus.component.repository.exception.ComponentLookupException;\nimport org.codehaus.plexus.util.ReaderFactory;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.pull.XmlPullParserException;\n\n// TODO: Auto-generated Javadoc\n/**\n * The Class EnforcerRuleUtils.\n *\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n */\npublic class EnforcerRuleUtils\n{\n\n    /** The factory. */\n    ArtifactFactory factory;\n\n    /** The resolver. */\n    ArtifactResolver resolver;\n\n    /** The local. */\n    ArtifactRepository local;\n\n    /** The remote repositories. */\n    List<ArtifactRepository> remoteRepositories;\n\n    /** The log. */\n    Log log;\n\n    /** The project. */\n    MavenProject project;\n\n    private EnforcerRuleHelper helper;\n\n    /**\n     * Instantiates a new enforcer rule utils.\n     *\n     * @param theFactory the the factory\n     * @param theResolver the the resolver\n     * @param theLocal the the local\n     * @param theRemoteRepositories the the remote repositories\n     * @param project the project\n     * @param theLog the the log\n     */\n    public EnforcerRuleUtils( ArtifactFactory theFactory, ArtifactResolver theResolver, ArtifactRepository theLocal,\n                              List<ArtifactRepository> theRemoteRepositories, MavenProject project, Log theLog )\n    {\n        super();\n        this.factory = theFactory;\n        this.resolver = theResolver;\n        this.local = theLocal;\n        this.remoteRepositories = theRemoteRepositories;\n        this.log = theLog;\n        this.project = project;\n    }\n\n    /**\n     * Instantiates a new enforcer rule utils.\n     *\n     * @param helper the helper\n     */\n    @SuppressWarnings( \"unchecked\" )\n    public EnforcerRuleUtils( EnforcerRuleHelper helper )\n    {\n\n        this.helper = helper;\n        // get the various expressions out of the\n        // helper.\n        try\n        {\n            factory = (ArtifactFactory) helper.getComponent( ArtifactFactory.class );\n            resolver = (ArtifactResolver) helper.getComponent( ArtifactResolver.class );\n            local = (ArtifactRepository) helper.evaluate( \"${localRepository}\" );\n            project = (MavenProject) helper.evaluate( \"${project}\" );\n            remoteRepositories = project.getRemoteArtifactRepositories();\n        }\n        catch ( ComponentLookupException e )\n        {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        catch ( ExpressionEvaluationException e )\n        {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Gets the pom model for this file.\n     *\n     * @param pom the pom\n     *\n     * @return the model\n     *\n     * @throws IOException Signals that an I/O exception has occurred.\n     * @throws XmlPullParserException the xml pull parser exception\n     */\n    private Model readModel ( File pom )\n        throws IOException, XmlPullParserException\n    {\n        Reader reader = ReaderFactory.newXmlReader( pom );\n        MavenXpp3Reader xpp3 = new MavenXpp3Reader();\n        Model model = null;\n        try\n        {\n            model = xpp3.read( reader );\n        }\n        finally\n        {\n            reader.close();\n            reader = null;\n        }\n        return model;\n    }\n\n    /**\n     * This method gets the model for the defined artifact.\n     * Looks first in the filesystem, then tries to get it\n     * from the repo.\n     *\n     * @param groupId the group id\n     * @param artifactId the artifact id\n     * @param version the version\n     * @param pom the pom\n     *\n     * @return the pom model\n     *\n     * @throws ArtifactResolutionException the artifact resolution exception\n     * @throws ArtifactNotFoundException the artifact not found exception\n     * @throws XmlPullParserException the xml pull parser exception\n     * @throws IOException Signals that an I/O exception has occurred.\n     */\n    private Model getPomModel ( String groupId, String artifactId, String version, File pom )\n        throws ArtifactResolutionException, ArtifactNotFoundException, IOException, XmlPullParserException\n    {\n        Model model = null;\n\n        // do we want to look in the reactor like the\n        // project builder? Would require @aggregator goal\n        // which causes problems in maven core right now\n        // because we also need dependency resolution in\n        // other\n        // rules. (MNG-2277)\n\n        // look in the location specified by pom first.\n        boolean found = false;\n        try\n        {\n            model = readModel( pom );\n\n            // i found a model, lets make sure it's the one\n            // I want\n            found = checkIfModelMatches( groupId, artifactId, version, model );\n        }\n        catch ( IOException e )\n        {\n            // nothing here, but lets look in the repo\n            // before giving up.\n        }\n        catch ( XmlPullParserException e )\n        {\n            // nothing here, but lets look in the repo\n            // before giving up.\n        }\n\n        // i didn't find it in the local file system, go\n        // look in the repo\n        if ( !found )\n        {\n            Artifact pomArtifact = factory.createArtifact( groupId, artifactId, version, null, \"pom\" );\n            resolver.resolve( pomArtifact, remoteRepositories, local );\n            model = readModel( pomArtifact.getFile() );\n        }\n\n        return model;\n    }\n\n    /**\n     * This method loops through all the parents, getting\n     * each pom model and then its parent.\n     *\n     * @param groupId the group id\n     * @param artifactId the artifact id\n     * @param version the version\n     * @param pom the pom\n     *\n     * @return the models recursively\n     *\n     * @throws ArtifactResolutionException the artifact resolution exception\n     * @throws ArtifactNotFoundException the artifact not found exception\n     * @throws IOException Signals that an I/O exception has occurred.\n     * @throws XmlPullParserException the xml pull parser exception\n     */\n    public List<Model> getModelsRecursively ( String groupId, String artifactId, String version, File pom )\n        throws ArtifactResolutionException, ArtifactNotFoundException, IOException, XmlPullParserException\n    {\n        List<Model> models = null;\n        Model model = getPomModel( groupId, artifactId, version, pom );\n\n        Parent parent = model.getParent();\n\n        // recurse into the parent\n        if ( parent != null )\n        {\n            // get the relative path\n            String relativePath = parent.getRelativePath();\n            if ( StringUtils.isEmpty( relativePath ) )\n            {\n                relativePath = \"../pom.xml\";\n            }\n            // calculate the recursive path\n            File parentPom = new File( pom.getParent(), relativePath );\n\n            // if relative path is a directory, append pom.xml\n            if ( parentPom.isDirectory() )\n            {\n                parentPom = new File( parentPom, \"pom.xml\" );\n            }\n\n            models = getModelsRecursively( parent.getGroupId(), parent.getArtifactId(), parent.getVersion(), parentPom );\n        }\n        else\n        {\n            // only create it here since I'm not at the top\n            models = new ArrayList<Model>();\n        }\n        models.add( model );\n\n        return models;\n    }\n\n    /**\n     * Make sure the model is the one I'm expecting.\n     *\n     * @param groupId the group id\n     * @param artifactId the artifact id\n     * @param version the version\n     * @param model Model being checked.\n     *\n     * @return true, if check if model matches\n     */\n    protected boolean checkIfModelMatches ( String groupId, String artifactId, String version, Model model )\n    {\n        // try these first.\n        String modelGroup = model.getGroupId();\n        String modelArtifactId = model.getArtifactId();\n        String modelVersion = model.getVersion();\n\n        try\n        {\n            if ( StringUtils.isEmpty( modelGroup ) )\n            {\n                modelGroup = model.getParent().getGroupId();\n            }\n            else\n            {\n                // MENFORCER-30, handle cases where the value is a property like ${project.parent.groupId}\n                modelGroup = (String) helper.evaluate( modelGroup );\n            }\n\n            if ( StringUtils.isEmpty( modelVersion ) )\n            {\n                modelVersion = model.getParent().getVersion();\n            }\n            else\n            {\n                // MENFORCER-30, handle cases where the value is a property like ${project.parent.version}\n                modelVersion = (String) helper.evaluate( modelVersion );\n            }\n            \n            // Is this only required for Maven2?\n            modelArtifactId = (String) helper.evaluate( modelArtifactId );\n        }\n        catch ( NullPointerException e )\n        {\n            // this is probably bad. I don't have a valid\n            // group or version and I can't find a\n            // parent????\n            // lets see if it's what we're looking for\n            // anyway.\n        }\n        catch ( ExpressionEvaluationException e )\n        {\n            // as above\n        }\n        return ( StringUtils.equals( groupId, modelGroup ) && StringUtils.equals( version, modelVersion ) && StringUtils\n            .equals( artifactId, modelArtifactId ) );\n    }\n    \n \n    private void resolve( Plugin plugin )\n    {\n        try\n        {\n            plugin.setGroupId( (String) helper.evaluate( plugin.getGroupId() ) );\n            plugin.setArtifactId( (String) helper.evaluate( plugin.getArtifactId() ) );\n            plugin.setVersion( (String) helper.evaluate( plugin.getVersion() ) );\n        }\n        catch ( ExpressionEvaluationException e )\n        {\n            // this should have gone already before\n        }\n    }\n    \n    private void resolve( ReportPlugin plugin )\n    {\n        try\n        {\n            plugin.setGroupId( (String) helper.evaluate( plugin.getGroupId() ) );\n            plugin.setArtifactId( (String) helper.evaluate( plugin.getArtifactId() ) );\n            plugin.setVersion( (String) helper.evaluate( plugin.getVersion() ) );\n        }\n        catch ( ExpressionEvaluationException e )\n        {\n            // this should have gone already before\n        }\n    }\n    \n    public List<Plugin> resolvePlugins( List<Plugin> plugins )\n    {\n        for ( Plugin plugin : plugins )\n        {\n            resolve( plugin );\n        }\n        return plugins;\n    }\n    \n    public List<ReportPlugin> resolveReportPlugins( List<ReportPlugin> reportPlugins )\n    {\n        for ( ReportPlugin plugin : reportPlugins )\n        {\n            resolve( plugin );\n        }\n        return reportPlugins;\n    }\n\n\n}\n","Smelly Sample":"package org.apache.maven.plugins.enforcer.utils;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.model.Model;\nimport org.apache.maven.model.Parent;\nimport org.apache.maven.model.Plugin;\nimport org.apache.maven.model.ReportPlugin;\nimport org.apache.maven.model.io.xpp3.MavenXpp3Reader;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.project.MavenProject;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\nimport org.codehaus.plexus.component.repository.exception.ComponentLookupException;\nimport org.codehaus.plexus.util.ReaderFactory;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.pull.XmlPullParserException;\n\n// TODO: Auto-generated Javadoc\n/**\n * The Class EnforcerRuleUtils.\n *\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n */\npublic class EnforcerRuleUtils\n{\n\n    /** The factory. */\n    ArtifactFactory factory;\n\n    /** The resolver. */\n    ArtifactResolver resolver;\n\n    /** The local. */\n    ArtifactRepository local;\n\n    /** The remote repositories. */\n    List<ArtifactRepository> remoteRepositories;\n\n    /** The log. */\n    Log log;\n\n    /** The project. */\n    MavenProject project;\n\n    private EnforcerRuleHelper helper;\n\n    /**\n     * Instantiates a new enforcer rule utils.\n     *\n     * @param theFactory the the factory\n     * @param theResolver the the resolver\n     * @param theLocal the the local\n     * @param theRemoteRepositories the the remote repositories\n     * @param project the project\n     * @param theLog the the log\n     */\n    public EnforcerRuleUtils( ArtifactFactory theFactory, ArtifactResolver theResolver, ArtifactRepository theLocal,\n                              List<ArtifactRepository> theRemoteRepositories, MavenProject project, Log theLog )\n    {\n        super();\n        this.factory = theFactory;\n        this.resolver = theResolver;\n        this.local = theLocal;\n        this.remoteRepositories = theRemoteRepositories;\n        this.log = theLog;\n        this.project = project;\n    }\n\n    /**\n     * Instantiates a new enforcer rule utils.\n     *\n     * @param helper the helper\n     */\n    @SuppressWarnings( \"unchecked\" )\n    public EnforcerRuleUtils( EnforcerRuleHelper helper )\n    {\n\n        this.helper = helper;\n        // get the various expressions out of the\n        // helper.\n        try\n        {\n            factory = (ArtifactFactory) helper.getComponent( ArtifactFactory.class );\n            resolver = (ArtifactResolver) helper.getComponent( ArtifactResolver.class );\n            local = (ArtifactRepository) helper.evaluate( \"${localRepository}\" );\n            project = (MavenProject) helper.evaluate( \"${project}\" );\n            remoteRepositories = project.getRemoteArtifactRepositories();\n        }\n        catch ( ComponentLookupException e )\n        {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        catch ( ExpressionEvaluationException e )\n        {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Gets the pom model for this file.\n     *\n     * @param pom the pom\n     *\n     * @return the model\n     *\n     * @throws IOException Signals that an I/O exception has occurred.\n     * @throws XmlPullParserException the xml pull parser exception\n     */\n    private Model readModel ( File pom )\n        throws IOException, XmlPullParserException\n    {\n        Reader reader = ReaderFactory.newXmlReader( pom );\n        MavenXpp3Reader xpp3 = new MavenXpp3Reader();\n        Model model = null;\n        try\n        {\n            model = xpp3.read( reader );\n        }\n        finally\n        {\n            reader.close();\n            reader = null;\n        }\n        return model;\n    }\n\n    /**\n     * This method gets the model for the defined artifact.\n     * Looks first in the filesystem, then tries to get it\n     * from the repo.\n     *\n     * @param groupId the group id\n     * @param artifactId the artifact id\n     * @param version the version\n     * @param pom the pom\n     *\n     * @return the pom model\n     *\n     * @throws ArtifactResolutionException the artifact resolution exception\n     * @throws ArtifactNotFoundException the artifact not found exception\n     * @throws XmlPullParserException the xml pull parser exception\n     * @throws IOException Signals that an I/O exception has occurred.\n     */\n    private Model getPomModel ( String groupId, String artifactId, String version, File pom )\n        throws ArtifactResolutionException, ArtifactNotFoundException, IOException, XmlPullParserException\n    {\n        Model model = null;\n\n        // do we want to look in the reactor like the\n        // project builder? Would require @aggregator goal\n        // which causes problems in maven core right now\n        // because we also need dependency resolution in\n        // other\n        // rules. (MNG-2277)\n\n        // look in the location specified by pom first.\n        boolean found = false;\n        try\n        {\n            model = readModel( pom );\n\n            // i found a model, lets make sure it's the one\n            // I want\n            found = checkIfModelMatches( groupId, artifactId, version, model );\n        }\n        catch ( IOException e )\n        {\n            // nothing here, but lets look in the repo\n            // before giving up.\n        }\n        catch ( XmlPullParserException e )\n        {\n            // nothing here, but lets look in the repo\n            // before giving up.\n        }\n\n        // i didn't find it in the local file system, go\n        // look in the repo\n        if ( !found )\n        {\n            Artifact pomArtifact = factory.createArtifact( groupId, artifactId, version, null, \"pom\" );\n            resolver.resolve( pomArtifact, remoteRepositories, local );\n            model = readModel( pomArtifact.getFile() );\n        }\n\n        return model;\n    }\n\n    /**\n     * This method loops through all the parents, getting\n     * each pom model and then its parent.\n     *\n     * @param groupId the group id\n     * @param artifactId the artifact id\n     * @param version the version\n     * @param pom the pom\n     *\n     * @return the models recursively\n     *\n     * @throws ArtifactResolutionException the artifact resolution exception\n     * @throws ArtifactNotFoundException the artifact not found exception\n     * @throws IOException Signals that an I/O exception has occurred.\n     * @throws XmlPullParserException the xml pull parser exception\n     */\n    public List<Model> getModelsRecursively ( String groupId, String artifactId, String version, File pom )\n        throws ArtifactResolutionException, ArtifactNotFoundException, IOException, XmlPullParserException\n    {\n        List<Model> models = null;\n        Model model = getPomModel( groupId, artifactId, version, pom );\n\n        Parent parent = model.getParent();\n\n        // recurse into the parent\n        if ( parent != null )\n        {\n            // get the relative path\n            String relativePath = parent.getRelativePath();\n            if ( StringUtils.isEmpty( relativePath ) )\n            {\n                relativePath = \"../pom.xml\";\n            }\n            // calculate the recursive path\n            File parentPom = new File( pom.getParent(), relativePath );\n\n            // if relative path is a directory, append pom.xml\n            if ( parentPom.isDirectory() )\n            {\n                parentPom = new File( parentPom, \"pom.xml\" );\n            }\n\n            models = getModelsRecursively( parent.getGroupId(), parent.getArtifactId(), parent.getVersion(), parentPom );\n        }\n        else\n        {\n            // only create it here since I'm not at the top\n            models = new ArrayList<Model>();\n        }\n        models.add( model );\n\n        return models;\n    }\n\n    /**\n     * Make sure the model is the one I'm expecting.\n     *\n     * @param groupId the group id\n     * @param artifactId the artifact id\n     * @param version the version\n     * @param model Model being checked.\n     *\n     * @return true, if check if model matches\n     */\n    protected boolean checkIfModelMatches ( String groupId, String artifactId, String version, Model model )\n    {\n        // try these first.\n        String modelGroup = model.getGroupId();\n        String modelVersion = model.getVersion();\n\n        try\n        {\n            if ( StringUtils.isEmpty( modelGroup ) )\n            {\n                modelGroup = model.getParent().getGroupId();\n            }\n            else\n            {\n                // MENFORCER-30, handle cases where the value is a property like ${project.parent.groupId}\n                modelGroup = (String) helper.evaluate( modelGroup );\n            }\n\n            if ( StringUtils.isEmpty( modelVersion ) )\n            {\n                modelVersion = model.getParent().getVersion();\n            }\n            else\n            {\n                // MENFORCER-30, handle cases where the value is a property like ${project.parent.version}\n                modelVersion = (String) helper.evaluate( modelVersion );\n            }\n        }\n        catch ( NullPointerException e )\n        {\n            // this is probably bad. I don't have a valid\n            // group or version and I can't find a\n            // parent????\n            // lets see if it's what we're looking for\n            // anyway.\n        }\n        catch ( ExpressionEvaluationException e )\n        {\n            // as above\n        }\n        return ( StringUtils.equals( groupId, modelGroup ) && StringUtils.equals( version, modelVersion ) && StringUtils\n            .equals( artifactId, model.getArtifactId() ) );\n    }\n    \n \n    private void resolve( Plugin plugin )\n    {\n        try\n        {\n            plugin.setGroupId( (String) helper.evaluate( plugin.getGroupId() ) );\n            plugin.setArtifactId( (String) helper.evaluate( plugin.getArtifactId() ) );\n            plugin.setVersion( (String) helper.evaluate( plugin.getVersion() ) );\n        }\n        catch ( ExpressionEvaluationException e )\n        {\n            // this should have gone already before\n        }\n    }\n    \n    private void resolve( ReportPlugin plugin )\n    {\n        try\n        {\n            plugin.setGroupId( (String) helper.evaluate( plugin.getGroupId() ) );\n            plugin.setArtifactId( (String) helper.evaluate( plugin.getArtifactId() ) );\n            plugin.setVersion( (String) helper.evaluate( plugin.getVersion() ) );\n        }\n        catch ( ExpressionEvaluationException e )\n        {\n            // this should have gone already before\n        }\n    }\n    \n    public List<Plugin> resolvePlugins( List<Plugin> plugins )\n    {\n        for ( Plugin plugin : plugins )\n        {\n            resolve( plugin );\n        }\n        return plugins;\n    }\n    \n    public List<ReportPlugin> resolveReportPlugins( List<ReportPlugin> reportPlugins )\n    {\n        for ( ReportPlugin plugin : reportPlugins )\n        {\n            resolve( plugin );\n        }\n        return reportPlugins;\n    }\n\n\n}\n","lineNo":289}
{"Refactored Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.metadata.ArtifactMetadataSource;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactCollector;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.versioning.ArtifactVersion;\nimport org.apache.maven.artifact.versioning.DefaultArtifactVersion;\nimport org.apache.maven.artifact.versioning.OverConstrainedVersionException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.shared.dependency.tree.DependencyNode;\nimport org.apache.maven.shared.dependency.tree.DependencyTreeBuilder;\nimport org.apache.maven.shared.dependency.tree.DependencyTreeBuilderException;\nimport org.apache.maven.shared.dependency.tree.traversal.DependencyNodeVisitor;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\nimport org.codehaus.plexus.component.repository.exception.ComponentLookupException;\nimport org.codehaus.plexus.i18n.I18N;\n\n/**\n * Rule to enforce that the resolved dependency is also the most recent one of all transitive dependencies.\n * \n * @author Geoffrey De Smet\n * @since 1.1\n */\npublic class RequireUpperBoundDeps\n    extends AbstractNonCacheableEnforcerRule\n{\n\n    private static Log log;\n\n    private static I18N i18n;\n\n    /**\n     * @since 1.3\n     */\n    private boolean uniqueVersions;\n    \n    /**\n     * \n     * @param uniqueVersions\n     * @since 1.3\n     */\n    public void setUniqueVersions( boolean uniqueVersions )\n    {\n        this.uniqueVersions = uniqueVersions;\n    }\n    \n    /**\n     * Uses the {@link EnforcerRuleHelper} to populate the values of the\n     * {@link DependencyTreeBuilder#buildDependencyTree(MavenProject, ArtifactRepository, ArtifactFactory, ArtifactMetadataSource, ArtifactFilter, ArtifactCollector)}\n     * factory method. <br/>\n     * This method simply exists to hide all the ugly lookup that the {@link EnforcerRuleHelper} has to do.\n     * \n     * @param helper\n     * @return a Dependency Node which is the root of the project's dependency tree\n     * @throws EnforcerRuleException when the build should fail\n     */\n    private DependencyNode getNode( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        try\n        {\n            MavenProject project = (MavenProject) helper.evaluate( \"${project}\" );\n            DependencyTreeBuilder dependencyTreeBuilder =\n                (DependencyTreeBuilder) helper.getComponent( DependencyTreeBuilder.class );\n            ArtifactRepository repository = (ArtifactRepository) helper.evaluate( \"${localRepository}\" );\n            ArtifactFactory factory = (ArtifactFactory) helper.getComponent( ArtifactFactory.class );\n            ArtifactMetadataSource metadataSource =\n                (ArtifactMetadataSource) helper.getComponent( ArtifactMetadataSource.class );\n            ArtifactCollector collector = (ArtifactCollector) helper.getComponent( ArtifactCollector.class );\n            ArtifactFilter filter = null; // we need to evaluate all scopes\n            DependencyNode node =\n                dependencyTreeBuilder.buildDependencyTree( project, repository, factory, metadataSource, filter,\n                                                           collector );\n            return node;\n        }\n        catch ( ExpressionEvaluationException e )\n        {\n            throw new EnforcerRuleException( \"Unable to lookup an expression \" + e.getLocalizedMessage(), e );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new EnforcerRuleException( \"Unable to lookup a component \" + e.getLocalizedMessage(), e );\n        }\n        catch ( DependencyTreeBuilderException e )\n        {\n            throw new EnforcerRuleException( \"Could not build dependency tree \" + e.getLocalizedMessage(), e );\n        }\n    }\n\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        if ( log == null )\n        {\n            log = helper.getLog();\n        }\n        try\n        {\n            if ( i18n == null )\n            {\n                i18n = (I18N) helper.getComponent( I18N.class );\n            }\n            DependencyNode node = getNode( helper );\n            RequireUpperBoundDepsVisitor visitor = new RequireUpperBoundDepsVisitor();\n            visitor.setUniqueVersions( uniqueVersions );\n            node.accept( visitor );\n            List<String> errorMessages = buildErrorMessages( visitor.getConflicts() );\n            if ( errorMessages.size() > 0 )\n            {\n                throw new EnforcerRuleException( \"Failed while enforcing RequireUpperBoundDeps. The error(s) are \"\n                    + errorMessages );\n            }\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new EnforcerRuleException( \"Unable to lookup a component \" + e.getLocalizedMessage(), e );\n        }\n        catch ( Exception e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage(), e );\n        }\n    }\n\n    private List<String> buildErrorMessages( List<List<DependencyNode>> conflicts )\n    {\n        List<String> errorMessages = new ArrayList<String>( conflicts.size() );\n        for ( List<DependencyNode> conflict : conflicts )\n        {\n            errorMessages.add( buildErrorMessage( conflict ) );\n        }\n        return errorMessages;\n    }\n\n    private String buildErrorMessage( List<DependencyNode> conflict )\n    {\n        StringBuilder errorMessage = new StringBuilder();\n        errorMessage.append( \"\\nRequire upper bound dependencies error for \"\n            + getFullArtifactName( conflict.get( 0 ).getArtifact() ) + \" paths to dependency are:\\n\" );\n        if ( conflict.size() > 0 )\n        {\n            errorMessage.append( buildTreeString( conflict.get( 0 ) ) );\n        }\n        for ( DependencyNode node : conflict.subList( 1, conflict.size() ) )\n        {\n            errorMessage.append( \"and\\n\" );\n            errorMessage.append( buildTreeString( node ) );\n        }\n        return errorMessage.toString();\n    }\n\n    private StringBuilder buildTreeString( DependencyNode node )\n    {\n        List<String> loc = new ArrayList<String>();\n        DependencyNode currentNode = node;\n        while ( currentNode != null )\n        {\n            loc.add( getFullArtifactName( currentNode.getArtifact() ) );\n            currentNode = currentNode.getParent();\n        }\n        Collections.reverse( loc );\n        StringBuilder builder = new StringBuilder();\n        for ( int i = 0; i < loc.size(); i++ )\n        {\n            for ( int j = 0; j < i; j++ )\n            {\n                builder.append( \"  \" );\n            }\n            builder.append( \"+-\" ).append( loc.get( i ) );\n            builder.append( \"\\n\" );\n        }\n        return builder;\n    }\n\n    private String getFullArtifactName( Artifact artifact )\n    {\n        return artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\" + artifact.getVersion();\n    }\n\n    private static class RequireUpperBoundDepsVisitor\n        implements DependencyNodeVisitor\n    {\n        \n        private boolean uniqueVersions;\n        \n        public void setUniqueVersions( boolean uniqueVersions )\n        {\n            this.uniqueVersions = uniqueVersions;\n        }\n\n        private Map<String, List<DependencyNodeHopCountPair>> keyToPairsMap =\n            new LinkedHashMap<String, List<DependencyNodeHopCountPair>>();\n\n        public boolean visit( DependencyNode node )\n        {\n            DependencyNodeHopCountPair pair = new DependencyNodeHopCountPair( node );\n            String key = pair.constructKey();\n            List<DependencyNodeHopCountPair> pairs = keyToPairsMap.get( key );\n            if ( pairs == null )\n            {\n                pairs = new ArrayList<DependencyNodeHopCountPair>();\n                keyToPairsMap.put( key, pairs );\n            }\n            pairs.add( pair );\n            Collections.sort( pairs );\n            return true;\n        }\n\n        public boolean endVisit( DependencyNode node )\n        {\n            return true;\n        }\n\n        public List<List<DependencyNode>> getConflicts()\n        {\n            List<List<DependencyNode>> output = new ArrayList<List<DependencyNode>>();\n            for ( List<DependencyNodeHopCountPair> pairs : keyToPairsMap.values() )\n            {\n                if ( containsConflicts( pairs ) )\n                {\n                    List<DependencyNode> outputSubList = new ArrayList<DependencyNode>( pairs.size() );\n                    for ( DependencyNodeHopCountPair pair : pairs )\n                    {\n                        outputSubList.add( pair.getNode() );\n                    }\n                    output.add( outputSubList );\n                }\n            }\n            return output;\n        }\n\n        @SuppressWarnings( \"unchecked\" )\n        private boolean containsConflicts( List<DependencyNodeHopCountPair> pairs )\n        {\n            if ( pairs.size() > 1 )\n            {\n                DependencyNodeHopCountPair resolvedPair = pairs.get( 0 );\n\n                // search for artifact with lowest hopCount\n                for ( DependencyNodeHopCountPair hopPair : pairs )\n                {\n                    if ( hopPair.getHopCount() < resolvedPair.getHopCount() )\n                    {\n                        resolvedPair = hopPair;\n                    }\n                }\n\n                ArtifactVersion resolvedVersion = resolvedPair.extractArtifactVersion( uniqueVersions );\n\n                for ( DependencyNodeHopCountPair pair : pairs )\n                {\n                    ArtifactVersion version = pair.extractArtifactVersion( uniqueVersions );\n                    if ( resolvedVersion.compareTo( version ) < 0 )\n                    {\n                        return true;\n                    }\n                }\n            } \n            return false;\n        }\n\n    }\n\n    private static class DependencyNodeHopCountPair\n        implements Comparable<DependencyNodeHopCountPair>\n    {\n\n        private DependencyNode node;\n\n        private int hopCount;\n\n        private DependencyNodeHopCountPair( DependencyNode node )\n        {\n            this.node = node;\n            countHops();\n        }\n\n        private void countHops()\n        {\n            hopCount = 0;\n            DependencyNode parent = node.getParent();\n            while ( parent != null )\n            {\n                hopCount++;\n                parent = parent.getParent();\n            }\n        }\n\n        private String constructKey()\n        {\n            Artifact artifact = node.getArtifact();\n            return artifact.getGroupId() + \":\" + artifact.getArtifactId();\n        }\n\n        public DependencyNode getNode()\n        {\n            return node;\n        }\n\n        private ArtifactVersion extractArtifactVersion( boolean uniqueVersions )\n        {\n            Artifact artifact = node.getArtifact();\n            String version = uniqueVersions ? artifact.getVersion() : artifact.getBaseVersion();\n            if ( version != null )\n            {\n                return new DefaultArtifactVersion( version );\n            }\n            try\n            {\n                return artifact.getSelectedVersion();\n            }\n            catch ( OverConstrainedVersionException e )\n            {\n                throw new RuntimeException( \"Version ranges problem with \" + node.getArtifact(), e );\n            }\n        }\n\n        public int getHopCount()\n        {\n            return hopCount;\n        }\n\n        public int compareTo( DependencyNodeHopCountPair other )\n        {\n            return Integer.valueOf( hopCount ).compareTo( Integer.valueOf( other.getHopCount() ) );\n        }\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.metadata.ArtifactMetadataSource;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactCollector;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.versioning.ArtifactVersion;\nimport org.apache.maven.artifact.versioning.DefaultArtifactVersion;\nimport org.apache.maven.artifact.versioning.OverConstrainedVersionException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.shared.dependency.tree.DependencyNode;\nimport org.apache.maven.shared.dependency.tree.DependencyTreeBuilder;\nimport org.apache.maven.shared.dependency.tree.DependencyTreeBuilderException;\nimport org.apache.maven.shared.dependency.tree.traversal.DependencyNodeVisitor;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\nimport org.codehaus.plexus.component.repository.exception.ComponentLookupException;\nimport org.codehaus.plexus.i18n.I18N;\n\n/**\n * Rule to enforce that the resolved dependency is also the most recent one of all transitive dependencies.\n * \n * @author Geoffrey De Smet\n * @since 1.1\n */\npublic class RequireUpperBoundDeps\n    extends AbstractNonCacheableEnforcerRule\n{\n\n    private static Log log;\n\n    private static I18N i18n;\n\n    /**\n     * @since 1.3\n     */\n    private boolean uniqueVersions;\n    \n    /**\n     * \n     * @param uniqueVersions\n     * @since 1.3\n     */\n    public void setUniqueVersions( boolean uniqueVersions )\n    {\n        this.uniqueVersions = uniqueVersions;\n    }\n    \n    /**\n     * Uses the {@link EnforcerRuleHelper} to populate the values of the\n     * {@link DependencyTreeBuilder#buildDependencyTree(MavenProject, ArtifactRepository, ArtifactFactory, ArtifactMetadataSource, ArtifactFilter, ArtifactCollector)}\n     * factory method. <br/>\n     * This method simply exists to hide all the ugly lookup that the {@link EnforcerRuleHelper} has to do.\n     * \n     * @param helper\n     * @return a Dependency Node which is the root of the project's dependency tree\n     * @throws EnforcerRuleException when the build should fail\n     */\n    private DependencyNode getNode( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        try\n        {\n            MavenProject project = (MavenProject) helper.evaluate( \"${project}\" );\n            DependencyTreeBuilder dependencyTreeBuilder =\n                (DependencyTreeBuilder) helper.getComponent( DependencyTreeBuilder.class );\n            ArtifactRepository repository = (ArtifactRepository) helper.evaluate( \"${localRepository}\" );\n            ArtifactFactory factory = (ArtifactFactory) helper.getComponent( ArtifactFactory.class );\n            ArtifactMetadataSource metadataSource =\n                (ArtifactMetadataSource) helper.getComponent( ArtifactMetadataSource.class );\n            ArtifactCollector collector = (ArtifactCollector) helper.getComponent( ArtifactCollector.class );\n            ArtifactFilter filter = null; // we need to evaluate all scopes\n            DependencyNode node =\n                dependencyTreeBuilder.buildDependencyTree( project, repository, factory, metadataSource, filter,\n                                                           collector );\n            return node;\n        }\n        catch ( ExpressionEvaluationException e )\n        {\n            throw new EnforcerRuleException( \"Unable to lookup an expression \" + e.getLocalizedMessage(), e );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new EnforcerRuleException( \"Unable to lookup a component \" + e.getLocalizedMessage(), e );\n        }\n        catch ( DependencyTreeBuilderException e )\n        {\n            throw new EnforcerRuleException( \"Could not build dependency tree \" + e.getLocalizedMessage(), e );\n        }\n    }\n\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        if ( log == null )\n        {\n            log = helper.getLog();\n        }\n        try\n        {\n            if ( i18n == null )\n            {\n                i18n = (I18N) helper.getComponent( I18N.class );\n            }\n            DependencyNode node = getNode( helper );\n            RequireUpperBoundDepsVisitor visitor = new RequireUpperBoundDepsVisitor();\n            visitor.setUniqueVersions( uniqueVersions );\n            node.accept( visitor );\n            List<String> errorMessages = buildErrorMessages( visitor.getConflicts() );\n            if ( errorMessages.size() > 0 )\n            {\n                throw new EnforcerRuleException( \"Failed while enforcing RequireUpperBoundDeps. The error(s) are \"\n                    + errorMessages );\n            }\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new EnforcerRuleException( \"Unable to lookup a component \" + e.getLocalizedMessage(), e );\n        }\n        catch ( Exception e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage(), e );\n        }\n    }\n\n    private List<String> buildErrorMessages( List<List<DependencyNode>> conflicts )\n    {\n        List<String> errorMessages = new ArrayList<String>( conflicts.size() );\n        for ( List<DependencyNode> conflict : conflicts )\n        {\n            errorMessages.add( buildErrorMessage( conflict ) );\n        }\n        return errorMessages;\n    }\n\n    private String buildErrorMessage( List<DependencyNode> conflict )\n    {\n        StringBuilder errorMessage = new StringBuilder();\n        errorMessage.append( \"\\nRequire upper bound dependencies error for \"\n            + getFullArtifactName( conflict.get( 0 ).getArtifact() ) + \" paths to dependency are:\\n\" );\n        if ( conflict.size() > 0 )\n        {\n            errorMessage.append( buildTreeString( conflict.get( 0 ) ) );\n        }\n        for ( DependencyNode node : conflict.subList( 1, conflict.size() ) )\n        {\n            errorMessage.append( \"and\\n\" );\n            errorMessage.append( buildTreeString( node ) );\n        }\n        return errorMessage.toString();\n    }\n\n    private StringBuilder buildTreeString( DependencyNode node )\n    {\n        List<String> loc = new ArrayList<String>();\n        DependencyNode currentNode = node;\n        while ( currentNode != null )\n        {\n            loc.add( getFullArtifactName( currentNode.getArtifact() ) );\n            currentNode = currentNode.getParent();\n        }\n        Collections.reverse( loc );\n        StringBuilder builder = new StringBuilder();\n        for ( int i = 0; i < loc.size(); i++ )\n        {\n            for ( int j = 0; j < i; j++ )\n            {\n                builder.append( \"  \" );\n            }\n            builder.append( \"+-\" ).append( loc.get( i ) );\n            builder.append( \"\\n\" );\n        }\n        return builder;\n    }\n\n    private String getFullArtifactName( Artifact artifact )\n    {\n        return artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\" + artifact.getVersion();\n    }\n\n    private static class RequireUpperBoundDepsVisitor\n        implements DependencyNodeVisitor\n    {\n        \n        private boolean uniqueVersions;\n        \n        public void setUniqueVersions( boolean uniqueVersions )\n        {\n            this.uniqueVersions = uniqueVersions;\n        }\n\n        private Map<String, List<DependencyNodeHopCountPair>> keyToPairsMap =\n            new LinkedHashMap<String, List<DependencyNodeHopCountPair>>();\n\n        public boolean visit( DependencyNode node )\n        {\n            DependencyNodeHopCountPair pair = new DependencyNodeHopCountPair( node );\n            String key = pair.constructKey();\n            List<DependencyNodeHopCountPair> pairs = keyToPairsMap.get( key );\n            if ( pairs == null )\n            {\n                pairs = new ArrayList<DependencyNodeHopCountPair>();\n                keyToPairsMap.put( key, pairs );\n            }\n            pairs.add( pair );\n            Collections.sort( pairs );\n            return true;\n        }\n\n        public boolean endVisit( DependencyNode node )\n        {\n            return true;\n        }\n\n        public List<List<DependencyNode>> getConflicts()\n        {\n            List<List<DependencyNode>> output = new ArrayList<List<DependencyNode>>();\n            for ( List<DependencyNodeHopCountPair> pairs : keyToPairsMap.values() )\n            {\n                if ( containsConflicts( pairs ) )\n                {\n                    List<DependencyNode> outputSubList = new ArrayList<DependencyNode>( pairs.size() );\n                    for ( DependencyNodeHopCountPair pair : pairs )\n                    {\n                        outputSubList.add( pair.getNode() );\n                    }\n                    output.add( outputSubList );\n                }\n            }\n            return output;\n        }\n\n        @SuppressWarnings( \"unchecked\" )\n        private boolean containsConflicts( List<DependencyNodeHopCountPair> pairs )\n        {\n            ArtifactVersion resolvedVersion = pairs.get( 0 ).extractArtifactVersion( uniqueVersions );\n            for ( DependencyNodeHopCountPair pair : pairs )\n            {\n                ArtifactVersion version = pair.extractArtifactVersion( uniqueVersions );\n                if ( resolvedVersion.compareTo( version ) < 0 )\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n    }\n\n    private static class DependencyNodeHopCountPair\n        implements Comparable<DependencyNodeHopCountPair>\n    {\n\n        private DependencyNode node;\n\n        private int hopCount;\n\n        private DependencyNodeHopCountPair( DependencyNode node )\n        {\n            this.node = node;\n            countHops();\n        }\n\n        private void countHops()\n        {\n            hopCount = 0;\n            DependencyNode parent = node.getParent();\n            while ( parent != null )\n            {\n                hopCount++;\n                parent = parent.getParent();\n            }\n        }\n\n        private String constructKey()\n        {\n            Artifact artifact = node.getArtifact();\n            return artifact.getGroupId() + \":\" + artifact.getArtifactId();\n        }\n\n        public DependencyNode getNode()\n        {\n            return node;\n        }\n\n        private ArtifactVersion extractArtifactVersion( boolean uniqueVersions )\n        {\n            Artifact artifact = node.getArtifact();\n            String version = uniqueVersions ? artifact.getVersion() : artifact.getBaseVersion();\n            if ( version != null )\n            {\n                return new DefaultArtifactVersion( version );\n            }\n            try\n            {\n                return artifact.getSelectedVersion();\n            }\n            catch ( OverConstrainedVersionException e )\n            {\n                throw new RuntimeException( \"Version ranges problem with \" + node.getArtifact(), e );\n            }\n        }\n\n        public int getHopCount()\n        {\n            return hopCount;\n        }\n\n        public int compareTo( DependencyNodeHopCountPair other )\n        {\n            return Integer.valueOf( hopCount ).compareTo( Integer.valueOf( other.getHopCount() ) );\n        }\n    }\n\n}\n","lineNo":266}
{"Refactored Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.model.Model;\nimport org.apache.maven.model.Profile;\nimport org.apache.maven.model.io.xpp3.MavenXpp3Reader;\nimport org.apache.maven.project.MavenProject;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.xml.pull.XmlPullParserException;\n\n/**\n * Since Maven 3 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique.\n * Early versions of Maven 3 already warn, this rule can force to break a build for this reason. \n * \n * @author Robert Scholte\n * @since 1.3\n *\n */\npublic class BanDuplicatePomDependencyVersions\n    extends AbstractNonCacheableEnforcerRule\n{\n\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        // get the project\n        MavenProject project;\n        try\n        {\n            project = (MavenProject) helper.evaluate( \"${project}\" );\n        }\n        catch ( ExpressionEvaluationException eee )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", eee );\n        }\n        \n        \n        // re-read model, because M3 uses optimized model\n        MavenXpp3Reader modelReader = new MavenXpp3Reader();\n        FileReader pomReader = null;\n        Model model;\n        try\n        {\n            pomReader = new FileReader( project.getFile() );\n\n            model = modelReader.read( pomReader );\n        }\n        catch ( FileNotFoundException e )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", e );\n        }\n        catch ( IOException e )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", e );\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", e );\n        }\n        finally\n        {\n            IOUtil.close( pomReader );\n        }\n\n        // @todo reuse ModelValidator when possible\n        \n//        Object modelValidator = null;\n//        try\n//        {\n//            modelValidator = helper.getComponent( \"org.apache.maven.model.validation.ModelValidator\" );\n//        }\n//        catch ( ComponentLookupException e1 )\n//        {\n//            // noop\n//        }\n\n\n//        if( modelValidator == null )\n//        {\n            maven2Validation( helper, model );            \n//        }\n//        else\n//        {\n//        }\n    }\n\n    private void maven2Validation( EnforcerRuleHelper helper, Model model )\n        throws EnforcerRuleException\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<Dependency> dependencies = model.getDependencies();\n        Map<String, Integer> duplicateDependencies = validateDependencies( dependencies );\n\n        int duplicates = duplicateDependencies.size();\n        \n        StringBuilder summary = new StringBuilder();\n        messageBuilder( duplicateDependencies, \"dependencies.dependency\", summary );\n\n        if( model.getDependencyManagement() != null )\n        {\n            @SuppressWarnings( \"unchecked\" )\n            List<Dependency> managementDependencies = model.getDependencies();\n            Map<String, Integer> duplicateManagementDependencies = validateDependencies( managementDependencies );\n            duplicates += duplicateManagementDependencies.size();\n\n            messageBuilder( duplicateManagementDependencies, \"dependencyManagement.dependencies.dependency\", summary );\n        }\n        \n        \n        @SuppressWarnings( \"unchecked\" )\n        List<Profile> profiles = model.getProfiles();\n        for( Profile profile : profiles )\n        {\n            @SuppressWarnings( \"unchecked\" )\n            List<Dependency> profileDependencies = profile.getDependencies();\n            Map<String, Integer> duplicateProfileDependencies = validateDependencies( profileDependencies );\n            duplicates += duplicateProfileDependencies.size();\n            \n            messageBuilder( duplicateProfileDependencies, \"profiles.profile[\" + profile.getId() + \"].dependencies.dependency\",  summary );\n\n            if( model.getDependencyManagement() != null )\n            {\n                @SuppressWarnings( \"unchecked\" )\n                List<Dependency> profileManagementDependencies = profile.getDependencies();\n                Map<String, Integer> duplicateProfileManagementDependencies = validateDependencies( profileManagementDependencies );\n                duplicates += duplicateProfileManagementDependencies.size();\n                \n                messageBuilder( duplicateProfileManagementDependencies, \"profiles.profile[\" + profile.getId() + \"].dependencyManagement.dependencies.dependency\", summary );\n            }\n        }\n            \n        if( summary.length() > 0 )\n        {\n            StringBuilder message = new StringBuilder();\n            message.append( \"Found \" ).append( duplicates ).append( \" duplicate dependency \" );\n            message.append( duplicateDependencies.size() == 1 ? \"declaration\" : \"declarations\" ).append( \" in this project:\\n\" );\n            message.append( summary );\n            throw new EnforcerRuleException( message.toString() );\n        }\n    }\n\n    private void messageBuilder( Map<String, Integer> duplicateDependencies, String prefix, StringBuilder message )\n    {\n        if ( !duplicateDependencies.isEmpty() )\n        {\n            for ( Map.Entry<String, Integer> entry : duplicateDependencies.entrySet() )\n            {\n                message.append( \" - \" ).append( prefix ).append( '[' ).append( entry.getKey() ).append( \"] ( \" ).append( entry.getValue() ).append( \" times )\\n\" );\n            }\n        }\n    }\n    \n\n    private Map<String, Integer> validateDependencies( List<Dependency> dependencies )\n        throws EnforcerRuleException\n    {\n        Map<String, Integer> duplicateDeps = new HashMap<String, Integer>();\n        Set<String> deps = new HashSet<String>();\n        for ( Dependency dependency : dependencies )\n        {\n            String key = dependency.getManagementKey();\n\n            if ( deps.contains( key ) )\n            {\n                int times = 1;\n                if( duplicateDeps.containsKey( key ) )\n                {\n                    times = duplicateDeps.get( key );\n                }\n                duplicateDeps.put( key, times + 1 );\n            }\n            else\n            {\n                deps.add( key );\n            }\n        }\n        return duplicateDeps;\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.model.Model;\nimport org.apache.maven.model.io.xpp3.MavenXpp3Reader;\nimport org.apache.maven.project.MavenProject;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.xml.pull.XmlPullParserException;\n\n/**\n * Since Maven 3 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique.\n * Early versions of Maven 3 already warn, this rule can force to break a build for this reason. \n * \n * @author Robert Scholte\n * @since 1.3\n *\n */\npublic class BanDuplicatePomDependencyVersions\n    extends AbstractNonCacheableEnforcerRule\n{\n\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        // get the project\n        MavenProject project;\n        try\n        {\n            project = (MavenProject) helper.evaluate( \"${project}\" );\n        }\n        catch ( ExpressionEvaluationException eee )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", eee );\n        }\n        \n        \n        // re-read model, because M3 uses optimized model\n        MavenXpp3Reader modelReader = new MavenXpp3Reader();\n        FileReader pomReader = null;\n        Model model;\n        try\n        {\n            pomReader = new FileReader( project.getFile() );\n\n            model = modelReader.read( pomReader );\n        }\n        catch ( FileNotFoundException e )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", e );\n        }\n        catch ( IOException e )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", e );\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", e );\n        }\n        finally\n        {\n            IOUtil.close( pomReader );\n        }\n\n        // @todo reuse ModelValidator when possible\n        \n//        Object modelValidator = null;\n//        try\n//        {\n//            modelValidator = helper.getComponent( \"org.apache.maven.model.validation.ModelValidator\" );\n//        }\n//        catch ( ComponentLookupException e1 )\n//        {\n//            // noop\n//        }\n\n\n//        if( modelValidator == null )\n//        {\n            maven2Validation( helper, model );            \n//        }\n//        else\n//        {\n//        }\n    }\n\n    private void maven2Validation( EnforcerRuleHelper helper, Model model )\n        throws EnforcerRuleException\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<Dependency> dependencies = model.getDependencies();\n\n        Map<String, Integer> duplicateDependencies = validateDependencies( dependencies );\n        \n        if ( !duplicateDependencies.isEmpty() )\n        {\n            StringBuilder message = new StringBuilder();\n            message.append( \"Found \" ).append( duplicateDependencies.size() ).append( \" duplicate \" );\n            message.append( duplicateDependencies.size() == 1 ? \"dependency\" : \"dependencies\" ).append( \" in this project:\\n\" );\n            for ( Map.Entry<String, Integer> entry : duplicateDependencies.entrySet() )\n            {\n                message.append( \" - \" ).append( entry.getKey() ).append( \" ( \" ).append( entry.getValue() ).append( \" times )\\n\" );\n            }\n            throw new EnforcerRuleException( message.toString() );\n        }\n\n    }\n\n    private Map<String, Integer> validateDependencies( List<Dependency> dependencies )\n        throws EnforcerRuleException\n    {\n        Map<String, Integer> duplicateDeps = new HashMap<String, Integer>();\n        Set<String> deps = new HashSet<String>();\n        for ( Dependency dependency : dependencies )\n        {\n            String key = dependency.getManagementKey();\n\n            if ( deps.contains( key ) )\n            {\n                int times = 1;\n                if( duplicateDeps.containsKey( key ) )\n                {\n                    times = duplicateDeps.get( key );\n                }\n                duplicateDeps.put( key, times + 1 );\n            }\n            else\n            {\n                deps.add( key );\n            }\n        }\n        return duplicateDeps;\n    }\n\n}\n","lineNo":125}
{"Refactored Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.model.Model;\nimport org.apache.maven.model.io.xpp3.MavenXpp3Reader;\nimport org.apache.maven.project.MavenProject;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.xml.pull.XmlPullParserException;\n\n/**\n * Since Maven 3 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique.\n * Early versions of Maven 3 already warn, this rule can force to break a build for this reason. \n * \n * @author Robert Scholte\n * @since 1.3\n *\n */\npublic class BanDuplicatePomDependencyVersions\n    extends AbstractNonCacheableEnforcerRule\n{\n\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        // get the project\n        MavenProject project;\n        try\n        {\n            project = (MavenProject) helper.evaluate( \"${project}\" );\n        }\n        catch ( ExpressionEvaluationException eee )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", eee );\n        }\n        \n        \n        // re-read model, because M3 uses optimized model\n        MavenXpp3Reader modelReader = new MavenXpp3Reader();\n        FileReader pomReader = null;\n        Model model;\n        try\n        {\n            pomReader = new FileReader( project.getFile() );\n\n            model = modelReader.read( pomReader );\n        }\n        catch ( FileNotFoundException e )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", e );\n        }\n        catch ( IOException e )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", e );\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", e );\n        }\n        finally\n        {\n            IOUtil.close( pomReader );\n        }\n\n        // @todo reuse ModelValidator when possible\n        \n//        Object modelValidator = null;\n//        try\n//        {\n//            modelValidator = helper.getComponent( \"org.apache.maven.model.validation.ModelValidator\" );\n//        }\n//        catch ( ComponentLookupException e1 )\n//        {\n//            // noop\n//        }\n\n\n//        if( modelValidator == null )\n//        {\n            maven2Validation( helper, model );            \n//        }\n//        else\n//        {\n//        }\n    }\n\n    private void maven2Validation( EnforcerRuleHelper helper, Model model )\n        throws EnforcerRuleException\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<Dependency> dependencies = model.getDependencies();\n\n        Map<String, Integer> duplicateDependencies = validateDependencies( dependencies );\n        \n        if ( !duplicateDependencies.isEmpty() )\n        {\n            StringBuilder message = new StringBuilder();\n            message.append( \"Found \" ).append( duplicateDependencies.size() ).append( \" duplicate \" );\n            message.append( duplicateDependencies.size() == 1 ? \"dependency\" : \"dependencies\" ).append( \" in this project:\\n\" );\n            for ( Map.Entry<String, Integer> entry : duplicateDependencies.entrySet() )\n            {\n                message.append( \" - \" ).append( entry.getKey() ).append( \" ( \" ).append( entry.getValue() ).append( \" times )\\n\" );\n            }\n            throw new EnforcerRuleException( message.toString() );\n        }\n\n    }\n\n    private Map<String, Integer> validateDependencies( List<Dependency> dependencies )\n        throws EnforcerRuleException\n    {\n        Map<String, Integer> duplicateDeps = new HashMap<String, Integer>();\n        Set<String> deps = new HashSet<String>();\n        for ( Dependency dependency : dependencies )\n        {\n            String key = dependency.getManagementKey();\n\n            if ( deps.contains( key ) )\n            {\n                int times = 1;\n                if( duplicateDeps.containsKey( key ) )\n                {\n                    times = duplicateDeps.get( key );\n                }\n                duplicateDeps.put( key, times + 1 );\n            }\n            else\n            {\n                deps.add( key );\n            }\n        }\n        return duplicateDeps;\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.model.Model;\nimport org.apache.maven.model.io.xpp3.MavenXpp3Reader;\nimport org.apache.maven.project.MavenProject;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.xml.pull.XmlPullParserException;\n\n/**\n * Since Maven 3 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique.\n * Early versions of Maven 3 already warn, this rule can force to break a build for this reason. \n * \n * @author Robert Scholte\n * @since 1.3\n *\n */\npublic class BanDuplicatePomDependencyVersions\n    extends AbstractNonCacheableEnforcerRule\n{\n\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        // get the project\n        MavenProject project;\n        try\n        {\n            project = (MavenProject) helper.evaluate( \"${project}\" );\n        }\n        catch ( ExpressionEvaluationException eee )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", eee );\n        }\n        \n        \n        // re-read model, because M3 uses optimized model\n        MavenXpp3Reader modelReader = new MavenXpp3Reader();\n        FileReader pomReader = null;\n        Model model;\n        try\n        {\n            pomReader = new FileReader( project.getFile() );\n\n            model = modelReader.read( pomReader );\n        }\n        catch ( FileNotFoundException e )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", e );\n        }\n        catch ( IOException e )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", e );\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", e );\n        }\n        finally\n        {\n            IOUtil.close( pomReader );\n        }\n\n        // @todo reuse ModelValidator when possible\n        \n//        Object modelValidator = null;\n//        try\n//        {\n//            modelValidator = helper.getComponent( \"org.apache.maven.model.validation.ModelValidator\" );\n//        }\n//        catch ( ComponentLookupException e1 )\n//        {\n//            // noop\n//        }\n\n\n//        if( modelValidator == null )\n//        {\n            maven2Validation( helper, model );            \n//        }\n//        else\n//        {\n//        }\n    }\n\n    private void maven2Validation( EnforcerRuleHelper helper, Model model )\n        throws EnforcerRuleException\n    {\n        Map<String, Integer> depMap = new HashMap<String, Integer>();\n        Set<String> duplicateDeps = new HashSet<String>();\n\n        @SuppressWarnings( \"unchecked\" )\n        List<Dependency> dependencies = model.getDependencies();\n        for ( Dependency dependency : dependencies )\n        {\n            String key = dependency.getManagementKey();\n\n            helper.getLog().debug( \"verify \" + key );\n\n            int times = 0;\n            if ( depMap.containsKey( key ) )\n            {\n                times = depMap.get( key );\n                duplicateDeps.add( key );\n            }\n            depMap.put( key, times + 1 );\n        }\n\n        if ( !duplicateDeps.isEmpty() )\n        {\n            StringBuilder message = new StringBuilder();\n            message.append( \"Found \" ).append( duplicateDeps.size() ).append( \" duplicate \" );\n            message.append( duplicateDeps.size() == 1 ? \"dependency\" : \"dependencies\" ).append( \" in this project:\\n\" );\n            for ( String key : duplicateDeps )\n            {\n                message.append( \" - \" ).append( key ).append( \" ( \" ).append( depMap.get( key ) ).append( \" times )\\n\" );\n            }\n            throw new EnforcerRuleException( message.toString() );\n        }\n    }\n\n}\n","lineNo":123}
{"Refactored Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.Map.Entry;\n\nimport org.apache.maven.BuildFailureException;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.artifact.versioning.InvalidVersionSpecificationException;\nimport org.apache.maven.artifact.versioning.VersionRange;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.lifecycle.Lifecycle;\nimport org.apache.maven.lifecycle.LifecycleExecutionException;\nimport org.apache.maven.lifecycle.LifecycleExecutor;\nimport org.apache.maven.lifecycle.mapping.LifecycleMapping;\nimport org.apache.maven.model.BuildBase;\nimport org.apache.maven.model.Model;\nimport org.apache.maven.model.Plugin;\nimport org.apache.maven.model.Profile;\nimport org.apache.maven.plugin.InvalidPluginException;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.PluginManager;\nimport org.apache.maven.plugin.PluginManagerException;\nimport org.apache.maven.plugin.PluginNotFoundException;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.plugin.version.PluginVersionNotFoundException;\nimport org.apache.maven.plugin.version.PluginVersionResolutionException;\nimport org.apache.maven.plugins.enforcer.utils.EnforcerRuleUtils;\nimport org.apache.maven.plugins.enforcer.utils.PluginWrapper;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.settings.Settings;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\nimport org.codehaus.plexus.component.repository.exception.ComponentLookupException;\nimport org.codehaus.plexus.util.ReflectionUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.pull.XmlPullParserException;\n\n/**\n * This rule will enforce that all plugins specified in the poms have a version declared.\n *\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n * @version $Id$\n */\npublic class RequirePluginVersions\n    extends AbstractNonCacheableEnforcerRule\n{\n\n    /** Don't allow the LATEST identifier. */\n    public boolean banLatest = true;\n\n    /** Don't allow the RELEASE identifier. */\n    public boolean banRelease = true;\n\n    /** Don't allow snapshot plugins. */\n    public boolean banSnapshots = true;\n\n    /** Don't allow timestamp snapshot plugins. */\n    public boolean banTimestamps = true;\n\n    /**\n     * The comma separated list of phases that should be used to find lifecycle plugin bindings. The default value is\n     * \"clean,deploy,site\".\n     */\n    public String phases = \"clean,deploy,site\";\n\n    /**\n     * Additional plugins to enforce have versions. These are plugins that may not be in the poms but are used anyway,\n     * like help, eclipse etc. <br>\n     * The plugins should be specified in the form: <code>group:artifactId<\/code>.\n     */\n    public List additionalPlugins;\n\n    /**\n     * Plugins to skip for version enforcement. The plugins should be specified in the form:\n     * <code>group:artifactId<\/code>. NOTE: This is deprecated, use unCheckedPluginList instead.\n     * @deprecated\n     */\n    public List unCheckedPlugins;\n\n    /**\n     * Same as unCheckedPlugins but as a comma list to better support properties. Sample form:\n     * <code>group:artifactId,group2:artifactId2<\/code>\n     * @since 1.0-beta-1\n     */\n    public String unCheckedPluginList;\n\n    /** The plugin manager. */\n    private PluginManager pluginManager;\n\n    /** The phase to lifecycle map. */\n    private Map phaseToLifecycleMap;\n\n    /** The lifecycles. */\n    private List lifecycles;\n\n    /** The factory. */\n    ArtifactFactory factory;\n\n    /** The resolver. */\n    ArtifactResolver resolver;\n\n    /** The local. */\n    ArtifactRepository local;\n\n    /** The remote repositories. */\n    List remoteRepositories;\n\n    /** The log. */\n    Log log;\n\n    /** The session. */\n    MavenSession session;\n\n    /** The utils. */\n    EnforcerRuleUtils utils;\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.apache.maven.enforcer.rule.api.EnforcerRule#execute(org.apache.maven.enforcer.rule.api.EnforcerRuleHelper)\n     */\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        log = helper.getLog();\n\n        MavenProject project;\n        try\n        {\n            // get the various expressions out of the helper.\n\n            project = (MavenProject) helper.evaluate( \"${project}\" );\n            LifecycleExecutor life;\n            life = (LifecycleExecutor) helper.getComponent( LifecycleExecutor.class );\n            try\n            {\n              lifecycles = (List) ReflectionUtils.getValueIncludingSuperclasses( \"lifecycles\", life );\n            }\n            catch (Exception e)\n            {\n                log.info( \"The requirePluginVersions rule is currently not compatible with Maven3.\");\n                /*\n                 *\n                 * NOTE: If this happens, we're bailing out right away.\n                 *\n                 *\n                 */\n                return;\n            }\n            session = (MavenSession) helper.evaluate( \"${session}\" );\n            pluginManager = (PluginManager) helper.getComponent( PluginManager.class );\n            factory = (ArtifactFactory) helper.getComponent( ArtifactFactory.class );\n            resolver = (ArtifactResolver) helper.getComponent( ArtifactResolver.class );\n            local = (ArtifactRepository) helper.evaluate( \"${localRepository}\" );\n            remoteRepositories = project.getRemoteArtifactRepositories();\n\n            utils = new EnforcerRuleUtils( helper );\n\n            // get all the plugins that are bound to the specified lifecycles\n            Set allPlugins = getBoundPlugins( life, project, phases );\n\n            // insert any additional plugins specified by the user.\n            allPlugins = addAdditionalPlugins( allPlugins, additionalPlugins );\n            allPlugins.addAll( getProfilePlugins( project ) );\n\n\n            // pull out any we should skip\n            allPlugins = (Set) removeUncheckedPlugins( combineUncheckedPlugins( unCheckedPlugins, unCheckedPluginList ), allPlugins );\n\n            // there's nothing to do here\n            if ( allPlugins.isEmpty() )\n            {\n                log.info( \"No plugin bindings found.\" );\n                return;\n            }\n            else\n            {\n                log.debug( \"All Plugins in use: \" + allPlugins );\n            }\n\n            // get all the plugins that are mentioned in the pom (and parents)\n            List pluginWrappers = getAllPluginEntries( project );\n\n            // now look for the versions that aren't valid and add to a list.\n            ArrayList failures = new ArrayList();\n            Iterator iter = allPlugins.iterator();\n            while ( iter.hasNext() )\n            {\n                Plugin plugin = (Plugin) iter.next();\n\n                if ( !hasValidVersionSpecified( helper, plugin, pluginWrappers ) )\n                {\n                    failures.add( plugin );\n                }\n            }\n\n            // if anything was found, log it then append the optional message.\n            if ( !failures.isEmpty() )\n            {\n                StringBuffer newMsg = new StringBuffer();\n                newMsg.append( \"Some plugins are missing valid versions:\" );\n                if ( banLatest || banRelease || banSnapshots || banTimestamps )\n                {\n                    newMsg.append( \"(\" );\n                    if ( banLatest )\n                    {\n                        newMsg.append( \"LATEST \" );\n                    }\n                    if ( banRelease )\n                    {\n                        newMsg.append( \"RELEASE \" );\n                    }\n                    if ( banSnapshots || banTimestamps )\n                    {\n                        newMsg.append( \"SNAPSHOT \" );\n                    }\n                    newMsg.append( \"are not allowed )\\n\" );\n                }\n                iter = failures.iterator();\n                while ( iter.hasNext() )\n                {\n                    Plugin plugin = (Plugin) iter.next();\n\n                    newMsg.append( plugin.getGroupId() );\n                    newMsg.append( \":\" );\n                    newMsg.append( plugin.getArtifactId() );\n\n                    try\n                    {\n                        newMsg.append( \". \\tThe version currently in use is \" );\n\n                        Plugin currentPlugin = findCurrentPlugin( plugin, project );\n\n                        if ( currentPlugin != null )\n                        {\n                            newMsg.append( currentPlugin.getVersion() );\n                        }\n                        else\n                        {\n                            newMsg.append( \"unknown\" );\n                        }\n                    }\n                    catch ( Exception e )\n                    {\n                        // lots can go wrong here. Don't allow any issues trying to\n                        // determine the issue stop me\n                        log.debug( \"Exception while determining plugin Version.\", e );\n                        newMsg.append( \". Unable to determine the plugin version.\" );\n                    }\n                    newMsg.append( \"\\n\" );\n                }\n                if ( StringUtils.isNotEmpty( message ) )\n                {\n                    newMsg.append( message );\n                }\n\n                throw new EnforcerRuleException( newMsg.toString() );\n            }\n        }\n        catch ( ExpressionEvaluationException e )\n        {\n            throw new EnforcerRuleException( \"Unable to Evaluate an Expression:\" + e.getLocalizedMessage() );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new EnforcerRuleException( \"Unable to lookup a component:\" + e.getLocalizedMessage() );\n        }\n        catch ( IllegalAccessException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( LifecycleExecutionException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( PluginNotFoundException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( IOException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( MojoExecutionException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n    }\n\n    /**\n     * Remove the plugins that the user doesn't want to check.\n     *\n     * @param uncheckedPlugins\n     * @param plugins\n     * @return\n     * @throws MojoExecutionException\n     */\n    public Collection removeUncheckedPlugins( Collection uncheckedPlugins, Collection plugins )\n        throws MojoExecutionException\n    {\n        if ( uncheckedPlugins != null && !uncheckedPlugins.isEmpty() )\n        {\n            Iterator iter = uncheckedPlugins.iterator();\n            while ( iter.hasNext() )\n            {\n                Plugin plugin = parsePluginString( (String) iter.next(), \"UncheckedPlugins\" );\n                plugins.remove( plugin );\n            }\n        }\n        return plugins;\n    }\n\n    /**\n     * Combines the old Collection with the new comma separated list.\n     * @param uncheckedPlugins\n     * @param uncheckedPluginsList\n     * @return\n     */\n    public Collection combineUncheckedPlugins( Collection uncheckedPlugins, String uncheckedPluginsList )\n    {\n        //if the comma list is empty, then there's nothing to do here.\n        if ( StringUtils.isNotEmpty( uncheckedPluginsList ) )\n        {\n            //make sure there is a collection to add to.\n            if ( uncheckedPlugins == null )\n            {\n                uncheckedPlugins = new HashSet();\n            }\n            else if (!uncheckedPlugins.isEmpty() && log != null)\n            {\n                log.warn( \"The parameter 'unCheckedPlugins' is deprecated. Use 'unCheckedPluginList' instead\" );\n            }\n\n            uncheckedPlugins.addAll( Arrays.asList( uncheckedPluginsList.split( \",\" ) ) );\n        }\n        return uncheckedPlugins;\n    }\n\n    /**\n     * Add the additional plugins if they don't exist yet.\n     *\n     * @param existing the existing\n     * @param additional the additional\n     * @return the sets the\n     * @throws MojoExecutionException the mojo execution exception\n     */\n    public Set addAdditionalPlugins( Set existing, List additional )\n        throws MojoExecutionException\n    {\n        if ( additional != null )\n        {\n            Iterator iter = additional.iterator();\n            while ( iter.hasNext() )\n            {\n                String pluginString = (String) iter.next();\n                Plugin plugin = parsePluginString( pluginString, \"AdditionalPlugins\" );\n\n                if ( existing == null )\n                {\n                    existing = new HashSet();\n                    existing.add( plugin );\n                }\n                else if ( !existing.contains( plugin ) )\n                {\n                    existing.add( plugin );\n                }\n            }\n        }\n        return existing;\n    }\n\n    /**\n     * Helper method to parse and inject a Plugin.\n     *\n     * @param pluginString\n     * @return\n     * @throws MojoExecutionException\n     */\n    protected Plugin parsePluginString( String pluginString, String field )\n        throws MojoExecutionException\n    {\n        if ( pluginString != null )\n        {\n            String[] pluginStrings = pluginString.split( \":\" );\n            if ( pluginStrings.length == 2 )\n            {\n                Plugin plugin = new Plugin();\n                plugin.setGroupId( StringUtils.strip( pluginStrings[0] ) );\n                plugin.setArtifactId( StringUtils.strip( pluginStrings[1] ) );\n\n                return plugin;\n            }\n            else\n            {\n                throw new MojoExecutionException( \"Invalid \" + field + \" string: \" + pluginString );\n            }\n        }\n        else\n        {\n            throw new MojoExecutionException( \"Invalid \" + field + \" string: \" + pluginString );\n        }\n\n    }\n\n    /**\n     * Finds the plugins that are listed in active profiles.\n     *\n     * @param project the project\n     * @return the profile plugins\n     */\n    public Set getProfilePlugins( MavenProject project )\n    {\n        Set result = new HashSet();\n        List profiles = project.getActiveProfiles();\n        if ( profiles != null && !profiles.isEmpty() )\n        {\n            Iterator iter = profiles.iterator();\n            while ( iter.hasNext() )\n            {\n                Profile p = (Profile) iter.next();\n                BuildBase b = p.getBuild();\n                if ( b != null )\n                {\n                    List plugins = b.getPlugins();\n                    if ( plugins != null )\n                    {\n                        result.addAll( plugins );\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Given a plugin, this will retrieve the matching plugin artifact from the model.\n     *\n     * @param plugin plugin to lookup\n     * @param project project to search\n     * @return matching plugin, <code>null<\/code> if not found.\n     */\n    protected Plugin findCurrentPlugin( Plugin plugin, MavenProject project )\n    {\n        Plugin found = null;\n        try\n        {\n            Model model = project.getModel();\n            Map plugins = model.getBuild().getPluginsAsMap();\n            found = (Plugin) plugins.get( plugin.getKey() );\n        }\n        catch ( NullPointerException e )\n        {\n            // nothing to do here\n        }\n\n        if ( found == null )\n        {\n            found = resolvePlugin( plugin, project );\n        }\n\n        return found;\n    }\n\n    /**\n     * Resolve plugin.\n     *\n     * @param plugin the plugin\n     * @param project the project\n     * @return the plugin\n     */\n    protected Plugin resolvePlugin( Plugin plugin, MavenProject project )\n    {\n\n        List pluginRepositories = project.getPluginArtifactRepositories();\n        Artifact artifact =\n            factory.createPluginArtifact( plugin.getGroupId(), plugin.getArtifactId(),\n                                          VersionRange.createFromVersion( \"LATEST\" ) );\n\n        try\n        {\n            this.resolver.resolve( artifact, pluginRepositories, this.local );\n            plugin.setVersion( artifact.getVersion() );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n        }\n\n        return plugin;\n    }\n\n    /**\n     * Gets the plugins that are bound to the defined phases. This does not find plugins bound in the pom to a phase\n     * later than the plugin is executing.\n     *\n     * @param life the life\n     * @param project the project\n     * @param thePhases the the phases\n     * @return the bound plugins\n     * @throws PluginNotFoundException the plugin not found exception\n     * @throws LifecycleExecutionException the lifecycle execution exception\n     * @throws IllegalAccessException the illegal access exception\n     */\n    protected Set getBoundPlugins( LifecycleExecutor life, MavenProject project, String thePhases )\n        throws PluginNotFoundException, LifecycleExecutionException, IllegalAccessException\n    {\n\n        Set allPlugins = new HashSet();\n\n        // lookup the bindings for all the passed in phases\n        String[] lifecyclePhases = thePhases.split( \",\" );\n        for ( int i = 0; i < lifecyclePhases.length; i++ )\n        {\n            String lifecyclePhase = lifecyclePhases[i];\n            if ( StringUtils.isNotEmpty( lifecyclePhase ) )\n            {\n                try\n                {\n                    Lifecycle lifecycle = getLifecycleForPhase( lifecyclePhase );\n                    allPlugins.addAll( getAllPlugins( project, lifecycle ) );\n                }\n                catch ( BuildFailureException e )\n                {\n                    // i'm going to swallow this because the\n                    // user may have declared a phase that\n                    // doesn't exist for every module.\n                }\n            }\n        }\n        return allPlugins;\n    }\n\n    /*\n     * Checks to see if the version is specified for the plugin. Can optionally ban \"RELEASE\" or \"LATEST\" even if\n     * specified.\n     */\n    /**\n     * Checks for valid version specified.\n     *\n     * @param helper the helper\n     * @param source the source\n     * @param pluginWrappers the plugins\n     * @return true, if successful\n     */\n    protected boolean hasValidVersionSpecified( EnforcerRuleHelper helper, Plugin source, List pluginWrappers )\n    {\n        boolean found = false;\n        boolean status = false;\n        Iterator iter = pluginWrappers.iterator();\n        while ( iter.hasNext() )\n        {\n            // find the matching plugin entry\n            PluginWrapper plugin = (PluginWrapper) iter.next();\n            if ( source.getArtifactId().equals( plugin.getArtifactId() )\n                && source.getGroupId().equals( plugin.getGroupId() ) )\n            {\n                found = true;\n                // found the entry. now see if the version is specified\n                String version = plugin.getVersion();\n                try\n                {\n                    version = (String) helper.evaluate( version );\n                }\n                catch ( ExpressionEvaluationException e )\n                {\n                    return false;\n                }\n\n                if ( StringUtils.isNotEmpty( version ) && !StringUtils.isWhitespace( version ) )\n                {\n\n                    if ( banRelease && version.equals( \"RELEASE\" ) )\n                    {\n                        return false;\n                    }\n\n                    if ( banLatest && version.equals( \"LATEST\" ) )\n                    {\n                        return false;\n                    }\n\n                    if ( banSnapshots && isSnapshot( version ) )\n                    {\n                        return false;\n                    }\n                    // the version was specified and not\n                    // banned. It's ok. Keep looking through the list to make\n                    // sure it's not using a banned version somewhere else.\n\n                    status = true;\n\n                    if ( !banRelease && !banLatest && !banSnapshots )\n                    {\n                        // no need to keep looking\n                        break;\n                    }\n                }\n            }\n        }\n        if ( !found )\n        {\n            log.debug( \"plugin \" + source.getGroupId() + \":\" + source.getArtifactId() + \" not found\" );\n        }\n        return status;\n    }\n\n    /**\n     * Checks if is snapshot.\n     *\n     * @param baseVersion the base version\n     * @return true, if is snapshot\n     */\n    protected boolean isSnapshot( String baseVersion )\n    {\n        if ( banTimestamps )\n        {\n            return Artifact.VERSION_FILE_PATTERN.matcher( baseVersion ).matches()\n                || baseVersion.endsWith( Artifact.SNAPSHOT_VERSION );\n        }\n        else\n        {\n            return baseVersion.endsWith( Artifact.SNAPSHOT_VERSION );\n        }\n    }\n\n    /*\n     * Uses borrowed lifecycle code to get a list of all plugins bound to the lifecycle.\n     */\n    /**\n     * Gets the all plugins.\n     *\n     * @param project the project\n     * @param lifecycle the lifecycle\n     * @return the all plugins\n     * @throws PluginNotFoundException the plugin not found exception\n     * @throws LifecycleExecutionException the lifecycle execution exception\n     */\n    private Set getAllPlugins( MavenProject project, Lifecycle lifecycle )\n        throws PluginNotFoundException, LifecycleExecutionException\n\n    {\n        HashSet plugins = new HashSet();\n        // first, bind those associated with the packaging\n        Map mappings = findMappingsForLifecycle( project, lifecycle );\n\n        Iterator iter = mappings.entrySet().iterator();\n        while ( iter.hasNext() )\n        {\n            Entry entry = (Entry) iter.next();\n            String value = (String) entry.getValue();\n            String tokens[] = value.split( \":\" );\n\n            Plugin plugin = new Plugin();\n            plugin.setGroupId( tokens[0] );\n            plugin.setArtifactId( tokens[1] );\n            plugins.add( plugin );\n        }\n\n        List mojos = findOptionalMojosForLifecycle( project, lifecycle );\n        iter = mojos.iterator();\n        while ( iter.hasNext() )\n        {\n            String value = (String) iter.next();\n            String tokens[] = value.split( \":\" );\n\n            Plugin plugin = new Plugin();\n            plugin.setGroupId( tokens[0] );\n            plugin.setArtifactId( tokens[1] );\n            plugins.add( plugin );\n        }\n\n        for ( Iterator i = project.getBuildPlugins().iterator(); i.hasNext(); )\n        {\n            plugins.add( i.next() );\n        }\n\n        return plugins;\n    }\n\n    /*\n     * NOTE: All the code following this point was scooped from the DefaultLifecycleExecutor. There must be a better way\n     * but for now it should work.\n     */\n    /**\n     * Gets the phase to lifecycle map.\n     *\n     * @return the phase to lifecycle map\n     * @throws LifecycleExecutionException the lifecycle execution exception\n     */\n    public Map getPhaseToLifecycleMap()\n        throws LifecycleExecutionException\n    {\n        if ( phaseToLifecycleMap == null )\n        {\n            phaseToLifecycleMap = new HashMap();\n\n            for ( Iterator i = lifecycles.iterator(); i.hasNext(); )\n            {\n                Lifecycle lifecycle = (Lifecycle) i.next();\n\n                for ( Iterator p = lifecycle.getPhases().iterator(); p.hasNext(); )\n                {\n                    String phase = (String) p.next();\n\n                    if ( phaseToLifecycleMap.containsKey( phase ) )\n                    {\n                        Lifecycle prevLifecycle = (Lifecycle) phaseToLifecycleMap.get( phase );\n                        throw new LifecycleExecutionException( \"Phase '\" + phase\n                            + \"' is defined in more than one lifecycle: '\" + lifecycle.getId() + \"' and '\"\n                            + prevLifecycle.getId() + \"'\" );\n                    }\n                    else\n                    {\n                        phaseToLifecycleMap.put( phase, lifecycle );\n                    }\n                }\n            }\n        }\n        return phaseToLifecycleMap;\n    }\n\n    /**\n     * Gets the lifecycle for phase.\n     *\n     * @param phase the phase\n     * @return the lifecycle for phase\n     * @throws BuildFailureException the build failure exception\n     * @throws LifecycleExecutionException the lifecycle execution exception\n     */\n    private Lifecycle getLifecycleForPhase( String phase )\n        throws BuildFailureException, LifecycleExecutionException\n    {\n        Lifecycle lifecycle = (Lifecycle) getPhaseToLifecycleMap().get( phase );\n\n        if ( lifecycle == null )\n        {\n            throw new BuildFailureException( \"Unable to find lifecycle for phase '\" + phase + \"'\" );\n        }\n        return lifecycle;\n    }\n\n    /**\n     * Find mappings for lifecycle.\n     *\n     * @param project the project\n     * @param lifecycle the lifecycle\n     * @return the map\n     * @throws LifecycleExecutionException the lifecycle execution exception\n     * @throws PluginNotFoundException the plugin not found exception\n     */\n    private Map findMappingsForLifecycle( MavenProject project, Lifecycle lifecycle )\n        throws LifecycleExecutionException, PluginNotFoundException\n    {\n        String packaging = project.getPackaging();\n        Map mappings = null;\n\n        LifecycleMapping m =\n            (LifecycleMapping) findExtension( project, LifecycleMapping.ROLE, packaging, session.getSettings(),\n                                              session.getLocalRepository() );\n        if ( m != null )\n        {\n            mappings = m.getPhases( lifecycle.getId() );\n        }\n\n        Map defaultMappings = lifecycle.getDefaultPhases();\n\n        if ( mappings == null )\n        {\n            try\n            {\n                m = (LifecycleMapping) session.lookup( LifecycleMapping.ROLE, packaging );\n                mappings = m.getPhases( lifecycle.getId() );\n            }\n            catch ( ComponentLookupException e )\n            {\n                if ( defaultMappings == null )\n                {\n                    throw new LifecycleExecutionException( \"Cannot find lifecycle mapping for packaging: \\'\"\n                        + packaging + \"\\'.\", e );\n                }\n            }\n        }\n\n        if ( mappings == null )\n        {\n            if ( defaultMappings == null )\n            {\n                throw new LifecycleExecutionException( \"Cannot find lifecycle mapping for packaging: \\'\" + packaging\n                    + \"\\', and there is no default\" );\n            }\n            else\n            {\n                mappings = defaultMappings;\n            }\n        }\n\n        return mappings;\n    }\n\n    /**\n     * Find optional mojos for lifecycle.\n     *\n     * @param project the project\n     * @param lifecycle the lifecycle\n     * @return the list\n     * @throws LifecycleExecutionException the lifecycle execution exception\n     * @throws PluginNotFoundException the plugin not found exception\n     */\n    private List findOptionalMojosForLifecycle( MavenProject project, Lifecycle lifecycle )\n        throws LifecycleExecutionException, PluginNotFoundException\n    {\n        String packaging = project.getPackaging();\n        List optionalMojos = null;\n\n        LifecycleMapping m =\n            (LifecycleMapping) findExtension( project, LifecycleMapping.ROLE, packaging, session.getSettings(),\n                                              session.getLocalRepository() );\n\n        if ( m != null )\n        {\n            optionalMojos = m.getOptionalMojos( lifecycle.getId() );\n        }\n\n        if ( optionalMojos == null )\n        {\n            try\n            {\n                m = (LifecycleMapping) session.lookup( LifecycleMapping.ROLE, packaging );\n                optionalMojos = m.getOptionalMojos( lifecycle.getId() );\n            }\n            catch ( ComponentLookupException e )\n            {\n                log.debug( \"Error looking up lifecycle mapping to retrieve optional mojos. Lifecycle ID: \"\n                    + lifecycle.getId() + \". Error: \" + e.getMessage(), e );\n            }\n        }\n\n        if ( optionalMojos == null )\n        {\n            optionalMojos = Collections.EMPTY_LIST;\n        }\n\n        return optionalMojos;\n    }\n\n    /**\n     * Find extension.\n     *\n     * @param project the project\n     * @param role the role\n     * @param roleHint the role hint\n     * @param settings the settings\n     * @param localRepository the local repository\n     * @return the object\n     * @throws LifecycleExecutionException the lifecycle execution exception\n     * @throws PluginNotFoundException the plugin not found exception\n     */\n    private Object findExtension( MavenProject project, String role, String roleHint, Settings settings,\n                                  ArtifactRepository localRepository )\n        throws LifecycleExecutionException, PluginNotFoundException\n    {\n        Object pluginComponent = null;\n\n        for ( Iterator i = project.getBuildPlugins().iterator(); i.hasNext() && pluginComponent == null; )\n        {\n            Plugin plugin = (Plugin) i.next();\n\n            if ( plugin.isExtensions() )\n            {\n                verifyPlugin( plugin, project, settings, localRepository );\n\n                // TODO: if moved to the plugin manager we\n                // already have the descriptor from above\n                // and so do can lookup the container\n                // directly\n                try\n                {\n                    pluginComponent = pluginManager.getPluginComponent( plugin, role, roleHint );\n                }\n                catch ( ComponentLookupException e )\n                {\n                    log.debug( \"Unable to find the lifecycle component in the extension\", e );\n                }\n                catch ( PluginManagerException e )\n                {\n                    throw new LifecycleExecutionException( \"Error getting extensions from the plugin '\"\n                        + plugin.getKey() + \"': \" + e.getMessage(), e );\n                }\n            }\n        }\n        return pluginComponent;\n    }\n\n    /**\n     * Verify plugin.\n     *\n     * @param plugin the plugin\n     * @param project the project\n     * @param settings the settings\n     * @param localRepository the local repository\n     * @return the plugin descriptor\n     * @throws LifecycleExecutionException the lifecycle execution exception\n     * @throws PluginNotFoundException the plugin not found exception\n     */\n    private PluginDescriptor verifyPlugin( Plugin plugin, MavenProject project, Settings settings,\n                                           ArtifactRepository localRepository )\n        throws LifecycleExecutionException, PluginNotFoundException\n    {\n        PluginDescriptor pluginDescriptor;\n        try\n        {\n            pluginDescriptor = pluginManager.verifyPlugin( plugin, project, settings, localRepository );\n        }\n        catch ( PluginManagerException e )\n        {\n            throw new LifecycleExecutionException( \"Internal error in the plugin manager getting plugin '\"\n                + plugin.getKey() + \"': \" + e.getMessage(), e );\n        }\n        catch ( PluginVersionResolutionException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( InvalidVersionSpecificationException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( InvalidPluginException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( PluginVersionNotFoundException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        return pluginDescriptor;\n    }\n\n    /**\n     * Gets all plugin entries in build.plugins, build.pluginManagement.plugins, profile.build.plugins, reporting and\n     * profile.reporting in this project and all parents\n     *\n     * @param project the project\n     * @return the all plugin entries wrapped in a PluginWrapper Object\n     * @throws ArtifactResolutionException the artifact resolution exception\n     * @throws ArtifactNotFoundException the artifact not found exception\n     * @throws IOException Signals that an I/O exception has occurred.\n     * @throws XmlPullParserException the xml pull parser exception\n     */\n    protected List getAllPluginEntries( MavenProject project )\n        throws ArtifactResolutionException, ArtifactNotFoundException, IOException, XmlPullParserException\n    {\n        List plugins = new ArrayList();\n        // get all the pom models\n        \n        String pomName = null;\n        try\n        {\n            pomName = project.getFile().getName();\n        }\n        catch (Exception e)\n        {\n            pomName = \"pom.xml\";\n        }\n        List models =\n            utils.getModelsRecursively( project.getGroupId(), project.getArtifactId(), project.getVersion(),\n                                        new File( project.getBasedir(), pomName ) );\n\n        // now find all the plugin entries, either in\n        // build.plugins or build.pluginManagement.plugins, profiles.plugins and reporting\n        Iterator iter = models.iterator();\n        while ( iter.hasNext() )\n        {\n            Model model = (Model) iter.next();\n            try\n            {\n                plugins.addAll( PluginWrapper.addAll( model.getBuild().getPlugins(), model.getId() + \".build.plugins\" ) );\n            }\n            catch ( NullPointerException e )\n            {\n                // guess there are no plugins here.\n            }\n\n            try\n            {\n                // add the reporting plugins\n                plugins.addAll( PluginWrapper.addAll( model.getReporting().getPlugins(), model.getId() + \".reporting\" ) );\n            }\n            catch ( NullPointerException e )\n            {\n                // guess there are no plugins here.\n            }\n\n            try\n            {\n                plugins.addAll( PluginWrapper.addAll( model.getBuild().getPluginManagement().getPlugins(),\n                                                      model.getId() + \".build.pluginManagement.plugins\" ) );\n            }\n            catch ( NullPointerException e )\n            {\n                // guess there are no plugins here.\n            }\n\n            // Add plugins in profiles\n            Iterator it = model.getProfiles().iterator();\n            while ( it.hasNext() )\n            {\n                Profile profile = (Profile) it.next();\n                try\n                {\n                    plugins.addAll( PluginWrapper.addAll( profile.getBuild().getPlugins(), model.getId()\n                        + \".profiles.profile[\" + profile.getId() + \"].build.plugins\" ) );\n                }\n                catch ( NullPointerException e )\n                {\n                    // guess there are no plugins here.\n                }\n\n                try\n                {\n                    // add the reporting plugins\n                    plugins.addAll( PluginWrapper.addAll( profile.getReporting().getPlugins(), model.getId()\n                        + \"profile[\" + profile.getId() + \"].reporting.plugins\" ) );\n                }\n                catch ( NullPointerException e )\n                {\n                    // guess there are no plugins here.\n                }\n                try\n                {\n                    // add the reporting plugins\n                    plugins.addAll( PluginWrapper.addAll( profile.getBuild().getPluginManagement().getPlugins(),\n                                                          model.getId() + \"profile[\" + profile.getId()\n                                                              + \"].build.pluginManagement.plugins\" ) );\n                }\n                catch ( NullPointerException e )\n                {\n                    // guess there are no plugins here.\n                }\n            }\n        }\n\n        return plugins;\n    }\n\n    /**\n     * Checks if is ban latest.\n     *\n     * @return the banLatest\n     */\n    protected boolean isBanLatest()\n    {\n        return this.banLatest;\n    }\n\n    /**\n     * Sets the ban latest.\n     *\n     * @param theBanLatest the banLatest to set\n     */\n    protected void setBanLatest( boolean theBanLatest )\n    {\n        this.banLatest = theBanLatest;\n    }\n\n    /**\n     * Checks if is ban release.\n     *\n     * @return the banRelease\n     */\n    protected boolean isBanRelease()\n    {\n        return this.banRelease;\n    }\n\n    /**\n     * Sets the ban release.\n     *\n     * @param theBanRelease the banRelease to set\n     */\n    protected void setBanRelease( boolean theBanRelease )\n    {\n        this.banRelease = theBanRelease;\n    }\n\n    /**\n     * Gets the message.\n     *\n     * @return the message\n     */\n    protected String getMessage()\n    {\n        return this.message;\n    }\n\n    /**\n     * Sets the message.\n     *\n     * @param theMessage the message to set\n     */\n    protected void setMessage( String theMessage )\n    {\n        this.message = theMessage;\n    }\n\n    /**\n     * Gets the utils.\n     *\n     * @return the utils\n     */\n    protected EnforcerRuleUtils getUtils()\n    {\n        return this.utils;\n    }\n\n    /**\n     * Sets the utils.\n     *\n     * @param theUtils the utils to set\n     */\n    protected void setUtils( EnforcerRuleUtils theUtils )\n    {\n        this.utils = theUtils;\n    }\n\n    /**\n     * Checks if is ban snapshots.\n     *\n     * @return the banSnapshots\n     */\n    public boolean isBanSnapshots()\n    {\n        return this.banSnapshots;\n    }\n\n    /**\n     * Sets the ban snapshots.\n     *\n     * @param theBanSnapshots the banSnapshots to set\n     */\n    public void setBanSnapshots( boolean theBanSnapshots )\n    {\n        this.banSnapshots = theBanSnapshots;\n    }\n\n    /**\n     * Checks if is ban timestamps.\n     *\n     * @return the banTimestamps\n     */\n    public boolean isBanTimestamps()\n    {\n        return this.banTimestamps;\n    }\n\n    /**\n     * Sets the ban timestamps.\n     *\n     * @param theBanTimestamps the banTimestamps to set\n     */\n    public void setBanTimestamps( boolean theBanTimestamps )\n    {\n        this.banTimestamps = theBanTimestamps;\n    }\n\n    public List getUnCheckedPlugins()\n    {\n        return unCheckedPlugins;\n    }\n\n    public void setUnCheckedPlugins( List unCheckedPlugins )\n    {\n        this.unCheckedPlugins = unCheckedPlugins;\n    }\n}\n","Smelly Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.Map.Entry;\n\nimport org.apache.maven.BuildFailureException;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.artifact.versioning.InvalidVersionSpecificationException;\nimport org.apache.maven.artifact.versioning.VersionRange;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.lifecycle.Lifecycle;\nimport org.apache.maven.lifecycle.LifecycleExecutionException;\nimport org.apache.maven.lifecycle.LifecycleExecutor;\nimport org.apache.maven.lifecycle.mapping.LifecycleMapping;\nimport org.apache.maven.model.BuildBase;\nimport org.apache.maven.model.Model;\nimport org.apache.maven.model.Plugin;\nimport org.apache.maven.model.Profile;\nimport org.apache.maven.plugin.InvalidPluginException;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.PluginManager;\nimport org.apache.maven.plugin.PluginManagerException;\nimport org.apache.maven.plugin.PluginNotFoundException;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.plugin.version.PluginVersionNotFoundException;\nimport org.apache.maven.plugin.version.PluginVersionResolutionException;\nimport org.apache.maven.plugins.enforcer.utils.EnforcerRuleUtils;\nimport org.apache.maven.plugins.enforcer.utils.PluginWrapper;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.settings.Settings;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\nimport org.codehaus.plexus.component.repository.exception.ComponentLookupException;\nimport org.codehaus.plexus.util.ReflectionUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.pull.XmlPullParserException;\n\n/**\n * This rule will enforce that all plugins specified in the poms have a version declared.\n *\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n * @version $Id$\n */\npublic class RequirePluginVersions\n    extends AbstractNonCacheableEnforcerRule\n{\n\n    /** Don't allow the LATEST identifier. */\n    public boolean banLatest = true;\n\n    /** Don't allow the RELEASE identifier. */\n    public boolean banRelease = true;\n\n    /** Don't allow snapshot plugins. */\n    public boolean banSnapshots = true;\n\n    /** Don't allow timestamp snapshot plugins. */\n    public boolean banTimestamps = true;\n\n    /**\n     * The comma separated list of phases that should be used to find lifecycle plugin bindings. The default value is\n     * \"clean,deploy,site\".\n     */\n    public String phases = \"clean,deploy,site\";\n\n    /**\n     * Additional plugins to enforce have versions. These are plugins that may not be in the poms but are used anyway,\n     * like help, eclipse etc. <br>\n     * The plugins should be specified in the form: <code>group:artifactId<\/code>.\n     */\n    public List additionalPlugins;\n\n    /**\n     * Plugins to skip for version enforcement. The plugins should be specified in the form:\n     * <code>group:artifactId<\/code>. NOTE: This is deprecated, use unCheckedPluginList instead.\n     * @deprecated\n     */\n    public List unCheckedPlugins;\n\n    /**\n     * Same as unCheckedPlugins but as a comma list to better support properties. Sample form:\n     * <code>group:artifactId,group2:artifactId2<\/code>\n     * @since 1.0-beta-1\n     */\n    public String unCheckedPluginList;\n\n    /** The plugin manager. */\n    private PluginManager pluginManager;\n\n    /** The phase to lifecycle map. */\n    private Map phaseToLifecycleMap;\n\n    /** The lifecycles. */\n    private List lifecycles;\n\n    /** The factory. */\n    ArtifactFactory factory;\n\n    /** The resolver. */\n    ArtifactResolver resolver;\n\n    /** The local. */\n    ArtifactRepository local;\n\n    /** The remote repositories. */\n    List remoteRepositories;\n\n    /** The log. */\n    Log log;\n\n    /** The session. */\n    MavenSession session;\n\n    /** The utils. */\n    EnforcerRuleUtils utils;\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.apache.maven.enforcer.rule.api.EnforcerRule#execute(org.apache.maven.enforcer.rule.api.EnforcerRuleHelper)\n     */\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        log = helper.getLog();\n\n        MavenProject project;\n        try\n        {\n            // get the various expressions out of the helper.\n\n            project = (MavenProject) helper.evaluate( \"${project}\" );\n            LifecycleExecutor life;\n            life = (LifecycleExecutor) helper.getComponent( LifecycleExecutor.class );\n            try\n            {\n              lifecycles = (List) ReflectionUtils.getValueIncludingSuperclasses( \"lifecycles\", life );\n            }\n            catch (Exception e)\n            {\n                log.info( \"The requirePluginVersions rule is currently not compatible with Maven3.\");\n                /*\n                 *\n                 * NOTE: If this happens, we're bailing out right away.\n                 *\n                 *\n                 */\n                return;\n            }\n            session = (MavenSession) helper.evaluate( \"${session}\" );\n            pluginManager = (PluginManager) helper.getComponent( PluginManager.class );\n            factory = (ArtifactFactory) helper.getComponent( ArtifactFactory.class );\n            resolver = (ArtifactResolver) helper.getComponent( ArtifactResolver.class );\n            local = (ArtifactRepository) helper.evaluate( \"${localRepository}\" );\n            remoteRepositories = project.getRemoteArtifactRepositories();\n\n            utils = new EnforcerRuleUtils( helper );\n\n            // get all the plugins that are bound to the specified lifecycles\n            Set allPlugins = getBoundPlugins( life, project, phases );\n\n            // insert any additional plugins specified by the user.\n            allPlugins = addAdditionalPlugins( allPlugins, additionalPlugins );\n            allPlugins.addAll( getProfilePlugins( project ) );\n\n\n            // pull out any we should skip\n            allPlugins = (Set) removeUncheckedPlugins( combineUncheckedPlugins( unCheckedPlugins, unCheckedPluginList ), allPlugins );\n\n            // there's nothing to do here\n            if ( allPlugins.isEmpty() )\n            {\n                log.info( \"No plugin bindings found.\" );\n                return;\n            }\n            else\n            {\n                log.debug( \"All Plugins in use: \" + allPlugins );\n            }\n\n            // get all the plugins that are mentioned in the pom (and parents)\n            List pluginWrappers = getAllPluginEntries( project );\n\n            // now look for the versions that aren't valid and add to a list.\n            ArrayList failures = new ArrayList();\n            Iterator iter = allPlugins.iterator();\n            while ( iter.hasNext() )\n            {\n                Plugin plugin = (Plugin) iter.next();\n\n                if ( !hasValidVersionSpecified( helper, plugin, pluginWrappers ) )\n                {\n                    failures.add( plugin );\n                }\n            }\n\n            // if anything was found, log it then append the optional message.\n            if ( !failures.isEmpty() )\n            {\n                StringBuffer newMsg = new StringBuffer();\n                newMsg.append( \"Some plugins are missing valid versions:\" );\n                if ( banLatest || banRelease || banSnapshots || banTimestamps )\n                {\n                    newMsg.append( \"(\" );\n                    if ( banLatest )\n                    {\n                        newMsg.append( \"LATEST \" );\n                    }\n                    if ( banRelease )\n                    {\n                        newMsg.append( \"RELEASE \" );\n                    }\n                    if ( banSnapshots || banTimestamps )\n                    {\n                        newMsg.append( \"SNAPSHOT \" );\n                    }\n                    newMsg.append( \"are not allowed )\\n\" );\n                }\n                iter = failures.iterator();\n                while ( iter.hasNext() )\n                {\n                    Plugin plugin = (Plugin) iter.next();\n\n                    newMsg.append( plugin.getGroupId() );\n                    newMsg.append( \":\" );\n                    newMsg.append( plugin.getArtifactId() );\n\n                    try\n                    {\n                        newMsg.append( \". \\tThe version currently in use is \" );\n\n                        Plugin currentPlugin = findCurrentPlugin( plugin, project );\n\n                        if ( currentPlugin != null )\n                        {\n                            newMsg.append( currentPlugin.getVersion() );\n                        }\n                        else\n                        {\n                            newMsg.append( \"unknown\" );\n                        }\n                    }\n                    catch ( Exception e )\n                    {\n                        // lots can go wrong here. Don't allow any issues trying to\n                        // determine the issue stop me\n                        log.debug( \"Exception while determining plugin Version.\", e );\n                        newMsg.append( \". Unable to determine the plugin version.\" );\n                    }\n                    newMsg.append( \"\\n\" );\n                }\n                if ( StringUtils.isNotEmpty( message ) )\n                {\n                    newMsg.append( message );\n                }\n\n                throw new EnforcerRuleException( newMsg.toString() );\n            }\n        }\n        catch ( ExpressionEvaluationException e )\n        {\n            throw new EnforcerRuleException( \"Unable to Evaluate an Expression:\" + e.getLocalizedMessage() );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new EnforcerRuleException( \"Unable to lookup a component:\" + e.getLocalizedMessage() );\n        }\n        catch ( IllegalAccessException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( LifecycleExecutionException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( PluginNotFoundException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( IOException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( MojoExecutionException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n    }\n\n    /**\n     * Remove the plugins that the user doesn't want to check.\n     *\n     * @param uncheckedPlugins\n     * @param plugins\n     * @return\n     * @throws MojoExecutionException\n     */\n    public Collection removeUncheckedPlugins( Collection uncheckedPlugins, Collection plugins )\n        throws MojoExecutionException\n    {\n        if ( uncheckedPlugins != null && !uncheckedPlugins.isEmpty() )\n        {\n            Iterator iter = uncheckedPlugins.iterator();\n            while ( iter.hasNext() )\n            {\n                Plugin plugin = parsePluginString( (String) iter.next(), \"UncheckedPlugins\" );\n                plugins.remove( plugin );\n            }\n        }\n        return plugins;\n    }\n\n    /**\n     * Combines the old Collection with the new comma separated list.\n     * @param uncheckedPlugins\n     * @param uncheckedPluginsList\n     * @return\n     */\n    public Collection combineUncheckedPlugins( Collection uncheckedPlugins, String uncheckedPluginsList )\n    {\n        //if the comma list is empty, then there's nothing to do here.\n        if ( StringUtils.isNotEmpty( uncheckedPluginsList ) )\n        {\n            //make sure there is a collection to add to.\n            if ( uncheckedPlugins == null )\n            {\n                uncheckedPlugins = new HashSet();\n            }\n            else if (!uncheckedPlugins.isEmpty() && log != null)\n            {\n                log.warn( \"The parameter 'unCheckedPlugins' is deprecated. Use 'unCheckedPluginList' instead\" );\n            }\n\n            uncheckedPlugins.addAll( Arrays.asList( uncheckedPluginsList.split( \",\" ) ) );\n        }\n        return uncheckedPlugins;\n    }\n\n    /**\n     * Add the additional plugins if they don't exist yet.\n     *\n     * @param existing the existing\n     * @param additional the additional\n     * @return the sets the\n     * @throws MojoExecutionException the mojo execution exception\n     */\n    public Set addAdditionalPlugins( Set existing, List additional )\n        throws MojoExecutionException\n    {\n        if ( additional != null )\n        {\n            Iterator iter = additional.iterator();\n            while ( iter.hasNext() )\n            {\n                String pluginString = (String) iter.next();\n                Plugin plugin = parsePluginString( pluginString, \"AdditionalPlugins\" );\n\n                if ( existing == null )\n                {\n                    existing = new HashSet();\n                    existing.add( plugin );\n                }\n                else if ( !existing.contains( plugin ) )\n                {\n                    existing.add( plugin );\n                }\n            }\n        }\n        return existing;\n    }\n\n    /**\n     * Helper method to parse and inject a Plugin.\n     *\n     * @param pluginString\n     * @return\n     * @throws MojoExecutionException\n     */\n    protected Plugin parsePluginString( String pluginString, String field )\n        throws MojoExecutionException\n    {\n        if ( pluginString != null )\n        {\n            String[] pluginStrings = pluginString.split( \":\" );\n            if ( pluginStrings.length == 2 )\n            {\n                Plugin plugin = new Plugin();\n                plugin.setGroupId( StringUtils.strip( pluginStrings[0] ) );\n                plugin.setArtifactId( StringUtils.strip( pluginStrings[1] ) );\n\n                return plugin;\n            }\n            else\n            {\n                throw new MojoExecutionException( \"Invalid \" + field + \" string: \" + pluginString );\n            }\n        }\n        else\n        {\n            throw new MojoExecutionException( \"Invalid \" + field + \" string: \" + pluginString );\n        }\n\n    }\n\n    /**\n     * Finds the plugins that are listed in active profiles.\n     *\n     * @param project the project\n     * @return the profile plugins\n     */\n    public Set getProfilePlugins( MavenProject project )\n    {\n        Set result = new HashSet();\n        List profiles = project.getActiveProfiles();\n        if ( profiles != null && !profiles.isEmpty() )\n        {\n            Iterator iter = profiles.iterator();\n            while ( iter.hasNext() )\n            {\n                Profile p = (Profile) iter.next();\n                BuildBase b = p.getBuild();\n                if ( b != null )\n                {\n                    List plugins = b.getPlugins();\n                    if ( plugins != null )\n                    {\n                        result.addAll( plugins );\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Given a plugin, this will retrieve the matching plugin artifact from the model.\n     *\n     * @param plugin plugin to lookup\n     * @param project project to search\n     * @return matching plugin, <code>null<\/code> if not found.\n     */\n    protected Plugin findCurrentPlugin( Plugin plugin, MavenProject project )\n    {\n        Plugin found = null;\n        try\n        {\n            Model model = project.getModel();\n            Map plugins = model.getBuild().getPluginsAsMap();\n            found = (Plugin) plugins.get( plugin.getKey() );\n        }\n        catch ( NullPointerException e )\n        {\n            // nothing to do here\n        }\n\n        if ( found == null )\n        {\n            found = resolvePlugin( plugin, project );\n        }\n\n        return found;\n    }\n\n    /**\n     * Resolve plugin.\n     *\n     * @param plugin the plugin\n     * @param project the project\n     * @return the plugin\n     */\n    protected Plugin resolvePlugin( Plugin plugin, MavenProject project )\n    {\n\n        List pluginRepositories = project.getPluginArtifactRepositories();\n        Artifact artifact =\n            factory.createPluginArtifact( plugin.getGroupId(), plugin.getArtifactId(),\n                                          VersionRange.createFromVersion( \"LATEST\" ) );\n\n        try\n        {\n            this.resolver.resolve( artifact, pluginRepositories, this.local );\n            plugin.setVersion( artifact.getVersion() );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n        }\n\n        return plugin;\n    }\n\n    /**\n     * Gets the plugins that are bound to the defined phases. This does not find plugins bound in the pom to a phase\n     * later than the plugin is executing.\n     *\n     * @param life the life\n     * @param project the project\n     * @param thePhases the the phases\n     * @return the bound plugins\n     * @throws PluginNotFoundException the plugin not found exception\n     * @throws LifecycleExecutionException the lifecycle execution exception\n     * @throws IllegalAccessException the illegal access exception\n     */\n    protected Set getBoundPlugins( LifecycleExecutor life, MavenProject project, String thePhases )\n        throws PluginNotFoundException, LifecycleExecutionException, IllegalAccessException\n    {\n\n        Set allPlugins = new HashSet();\n\n        // lookup the bindings for all the passed in phases\n        String[] lifecyclePhases = thePhases.split( \",\" );\n        for ( int i = 0; i < lifecyclePhases.length; i++ )\n        {\n            String lifecyclePhase = lifecyclePhases[i];\n            if ( StringUtils.isNotEmpty( lifecyclePhase ) )\n            {\n                try\n                {\n                    Lifecycle lifecycle = getLifecycleForPhase( lifecyclePhase );\n                    allPlugins.addAll( getAllPlugins( project, lifecycle ) );\n                }\n                catch ( BuildFailureException e )\n                {\n                    // i'm going to swallow this because the\n                    // user may have declared a phase that\n                    // doesn't exist for every module.\n                }\n            }\n        }\n        return allPlugins;\n    }\n\n    /*\n     * Checks to see if the version is specified for the plugin. Can optionally ban \"RELEASE\" or \"LATEST\" even if\n     * specified.\n     */\n    /**\n     * Checks for valid version specified.\n     *\n     * @param helper the helper\n     * @param source the source\n     * @param pluginWrappers the plugins\n     * @return true, if successful\n     */\n    protected boolean hasValidVersionSpecified( EnforcerRuleHelper helper, Plugin source, List pluginWrappers )\n    {\n        boolean found = false;\n        boolean status = false;\n        Iterator iter = pluginWrappers.iterator();\n        while ( iter.hasNext() )\n        {\n            // find the matching plugin entry\n            PluginWrapper plugin = (PluginWrapper) iter.next();\n            if ( source.getArtifactId().equals( plugin.getArtifactId() )\n                && source.getGroupId().equals( plugin.getGroupId() ) )\n            {\n                found = true;\n                // found the entry. now see if the version is specified\n                String version = plugin.getVersion();\n                try\n                {\n                    version = (String) helper.evaluate( version );\n                }\n                catch ( ExpressionEvaluationException e )\n                {\n                    return false;\n                }\n\n                if ( StringUtils.isNotEmpty( version ) && !StringUtils.isWhitespace( version ) )\n                {\n\n                    if ( banRelease && version.equals( \"RELEASE\" ) )\n                    {\n                        return false;\n                    }\n\n                    if ( banLatest && version.equals( \"LATEST\" ) )\n                    {\n                        return false;\n                    }\n\n                    if ( banSnapshots && isSnapshot( version ) )\n                    {\n                        return false;\n                    }\n                    // the version was specified and not\n                    // banned. It's ok. Keep looking through the list to make\n                    // sure it's not using a banned version somewhere else.\n\n                    status = true;\n\n                    if ( !banRelease && !banLatest && !banSnapshots )\n                    {\n                        // no need to keep looking\n                        break;\n                    }\n                }\n            }\n        }\n        if ( !found )\n        {\n            log.debug( \"plugin \" + source.getGroupId() + \":\" + source.getArtifactId() + \" not found\" );\n        }\n        return status;\n    }\n\n    /**\n     * Checks if is snapshot.\n     *\n     * @param baseVersion the base version\n     * @return true, if is snapshot\n     */\n    protected boolean isSnapshot( String baseVersion )\n    {\n        if ( banTimestamps )\n        {\n            return Artifact.VERSION_FILE_PATTERN.matcher( baseVersion ).matches()\n                || baseVersion.endsWith( Artifact.SNAPSHOT_VERSION );\n        }\n        else\n        {\n            return baseVersion.endsWith( Artifact.SNAPSHOT_VERSION );\n        }\n    }\n\n    /*\n     * Uses borrowed lifecycle code to get a list of all plugins bound to the lifecycle.\n     */\n    /**\n     * Gets the all plugins.\n     *\n     * @param project the project\n     * @param lifecycle the lifecycle\n     * @return the all plugins\n     * @throws PluginNotFoundException the plugin not found exception\n     * @throws LifecycleExecutionException the lifecycle execution exception\n     */\n    private Set getAllPlugins( MavenProject project, Lifecycle lifecycle )\n        throws PluginNotFoundException, LifecycleExecutionException\n\n    {\n        HashSet plugins = new HashSet();\n        // first, bind those associated with the packaging\n        Map mappings = findMappingsForLifecycle( project, lifecycle );\n\n        Iterator iter = mappings.entrySet().iterator();\n        while ( iter.hasNext() )\n        {\n            Entry entry = (Entry) iter.next();\n            String value = (String) entry.getValue();\n            String tokens[] = value.split( \":\" );\n\n            Plugin plugin = new Plugin();\n            plugin.setGroupId( tokens[0] );\n            plugin.setArtifactId( tokens[1] );\n            plugins.add( plugin );\n        }\n\n        List mojos = findOptionalMojosForLifecycle( project, lifecycle );\n        iter = mojos.iterator();\n        while ( iter.hasNext() )\n        {\n            String value = (String) iter.next();\n            String tokens[] = value.split( \":\" );\n\n            Plugin plugin = new Plugin();\n            plugin.setGroupId( tokens[0] );\n            plugin.setArtifactId( tokens[1] );\n            plugins.add( plugin );\n        }\n\n        for ( Iterator i = project.getBuildPlugins().iterator(); i.hasNext(); )\n        {\n            plugins.add( i.next() );\n        }\n\n        return plugins;\n    }\n\n    /*\n     * NOTE: All the code following this point was scooped from the DefaultLifecycleExecutor. There must be a better way\n     * but for now it should work.\n     */\n    /**\n     * Gets the phase to lifecycle map.\n     *\n     * @return the phase to lifecycle map\n     * @throws LifecycleExecutionException the lifecycle execution exception\n     */\n    public Map getPhaseToLifecycleMap()\n        throws LifecycleExecutionException\n    {\n        if ( phaseToLifecycleMap == null )\n        {\n            phaseToLifecycleMap = new HashMap();\n\n            for ( Iterator i = lifecycles.iterator(); i.hasNext(); )\n            {\n                Lifecycle lifecycle = (Lifecycle) i.next();\n\n                for ( Iterator p = lifecycle.getPhases().iterator(); p.hasNext(); )\n                {\n                    String phase = (String) p.next();\n\n                    if ( phaseToLifecycleMap.containsKey( phase ) )\n                    {\n                        Lifecycle prevLifecycle = (Lifecycle) phaseToLifecycleMap.get( phase );\n                        throw new LifecycleExecutionException( \"Phase '\" + phase\n                            + \"' is defined in more than one lifecycle: '\" + lifecycle.getId() + \"' and '\"\n                            + prevLifecycle.getId() + \"'\" );\n                    }\n                    else\n                    {\n                        phaseToLifecycleMap.put( phase, lifecycle );\n                    }\n                }\n            }\n        }\n        return phaseToLifecycleMap;\n    }\n\n    /**\n     * Gets the lifecycle for phase.\n     *\n     * @param phase the phase\n     * @return the lifecycle for phase\n     * @throws BuildFailureException the build failure exception\n     * @throws LifecycleExecutionException the lifecycle execution exception\n     */\n    private Lifecycle getLifecycleForPhase( String phase )\n        throws BuildFailureException, LifecycleExecutionException\n    {\n        Lifecycle lifecycle = (Lifecycle) getPhaseToLifecycleMap().get( phase );\n\n        if ( lifecycle == null )\n        {\n            throw new BuildFailureException( \"Unable to find lifecycle for phase '\" + phase + \"'\" );\n        }\n        return lifecycle;\n    }\n\n    /**\n     * Find mappings for lifecycle.\n     *\n     * @param project the project\n     * @param lifecycle the lifecycle\n     * @return the map\n     * @throws LifecycleExecutionException the lifecycle execution exception\n     * @throws PluginNotFoundException the plugin not found exception\n     */\n    private Map findMappingsForLifecycle( MavenProject project, Lifecycle lifecycle )\n        throws LifecycleExecutionException, PluginNotFoundException\n    {\n        String packaging = project.getPackaging();\n        Map mappings = null;\n\n        LifecycleMapping m =\n            (LifecycleMapping) findExtension( project, LifecycleMapping.ROLE, packaging, session.getSettings(),\n                                              session.getLocalRepository() );\n        if ( m != null )\n        {\n            mappings = m.getPhases( lifecycle.getId() );\n        }\n\n        Map defaultMappings = lifecycle.getDefaultPhases();\n\n        if ( mappings == null )\n        {\n            try\n            {\n                m = (LifecycleMapping) session.lookup( LifecycleMapping.ROLE, packaging );\n                mappings = m.getPhases( lifecycle.getId() );\n            }\n            catch ( ComponentLookupException e )\n            {\n                if ( defaultMappings == null )\n                {\n                    throw new LifecycleExecutionException( \"Cannot find lifecycle mapping for packaging: \\'\"\n                        + packaging + \"\\'.\", e );\n                }\n            }\n        }\n\n        if ( mappings == null )\n        {\n            if ( defaultMappings == null )\n            {\n                throw new LifecycleExecutionException( \"Cannot find lifecycle mapping for packaging: \\'\" + packaging\n                    + \"\\', and there is no default\" );\n            }\n            else\n            {\n                mappings = defaultMappings;\n            }\n        }\n\n        return mappings;\n    }\n\n    /**\n     * Find optional mojos for lifecycle.\n     *\n     * @param project the project\n     * @param lifecycle the lifecycle\n     * @return the list\n     * @throws LifecycleExecutionException the lifecycle execution exception\n     * @throws PluginNotFoundException the plugin not found exception\n     */\n    private List findOptionalMojosForLifecycle( MavenProject project, Lifecycle lifecycle )\n        throws LifecycleExecutionException, PluginNotFoundException\n    {\n        String packaging = project.getPackaging();\n        List optionalMojos = null;\n\n        LifecycleMapping m =\n            (LifecycleMapping) findExtension( project, LifecycleMapping.ROLE, packaging, session.getSettings(),\n                                              session.getLocalRepository() );\n\n        if ( m != null )\n        {\n            optionalMojos = m.getOptionalMojos( lifecycle.getId() );\n        }\n\n        if ( optionalMojos == null )\n        {\n            try\n            {\n                m = (LifecycleMapping) session.lookup( LifecycleMapping.ROLE, packaging );\n                optionalMojos = m.getOptionalMojos( lifecycle.getId() );\n            }\n            catch ( ComponentLookupException e )\n            {\n                log.debug( \"Error looking up lifecycle mapping to retrieve optional mojos. Lifecycle ID: \"\n                    + lifecycle.getId() + \". Error: \" + e.getMessage(), e );\n            }\n        }\n\n        if ( optionalMojos == null )\n        {\n            optionalMojos = Collections.EMPTY_LIST;\n        }\n\n        return optionalMojos;\n    }\n\n    /**\n     * Find extension.\n     *\n     * @param project the project\n     * @param role the role\n     * @param roleHint the role hint\n     * @param settings the settings\n     * @param localRepository the local repository\n     * @return the object\n     * @throws LifecycleExecutionException the lifecycle execution exception\n     * @throws PluginNotFoundException the plugin not found exception\n     */\n    private Object findExtension( MavenProject project, String role, String roleHint, Settings settings,\n                                  ArtifactRepository localRepository )\n        throws LifecycleExecutionException, PluginNotFoundException\n    {\n        Object pluginComponent = null;\n\n        for ( Iterator i = project.getBuildPlugins().iterator(); i.hasNext() && pluginComponent == null; )\n        {\n            Plugin plugin = (Plugin) i.next();\n\n            if ( plugin.isExtensions() )\n            {\n                verifyPlugin( plugin, project, settings, localRepository );\n\n                // TODO: if moved to the plugin manager we\n                // already have the descriptor from above\n                // and so do can lookup the container\n                // directly\n                try\n                {\n                    pluginComponent = pluginManager.getPluginComponent( plugin, role, roleHint );\n                }\n                catch ( ComponentLookupException e )\n                {\n                    log.debug( \"Unable to find the lifecycle component in the extension\", e );\n                }\n                catch ( PluginManagerException e )\n                {\n                    throw new LifecycleExecutionException( \"Error getting extensions from the plugin '\"\n                        + plugin.getKey() + \"': \" + e.getMessage(), e );\n                }\n            }\n        }\n        return pluginComponent;\n    }\n\n    /**\n     * Verify plugin.\n     *\n     * @param plugin the plugin\n     * @param project the project\n     * @param settings the settings\n     * @param localRepository the local repository\n     * @return the plugin descriptor\n     * @throws LifecycleExecutionException the lifecycle execution exception\n     * @throws PluginNotFoundException the plugin not found exception\n     */\n    private PluginDescriptor verifyPlugin( Plugin plugin, MavenProject project, Settings settings,\n                                           ArtifactRepository localRepository )\n        throws LifecycleExecutionException, PluginNotFoundException\n    {\n        PluginDescriptor pluginDescriptor;\n        try\n        {\n            pluginDescriptor = pluginManager.verifyPlugin( plugin, project, settings, localRepository );\n        }\n        catch ( PluginManagerException e )\n        {\n            throw new LifecycleExecutionException( \"Internal error in the plugin manager getting plugin '\"\n                + plugin.getKey() + \"': \" + e.getMessage(), e );\n        }\n        catch ( PluginVersionResolutionException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( InvalidVersionSpecificationException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( InvalidPluginException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( PluginVersionNotFoundException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        return pluginDescriptor;\n    }\n\n    /**\n     * Gets all plugin entries in build.plugins, build.pluginManagement.plugins, profile.build.plugins, reporting and\n     * profile.reporting in this project and all parents\n     *\n     * @param project the project\n     * @return the all plugin entries wrapped in a PluginWrapper Object\n     * @throws ArtifactResolutionException the artifact resolution exception\n     * @throws ArtifactNotFoundException the artifact not found exception\n     * @throws IOException Signals that an I/O exception has occurred.\n     * @throws XmlPullParserException the xml pull parser exception\n     */\n    protected List getAllPluginEntries( MavenProject project )\n        throws ArtifactResolutionException, ArtifactNotFoundException, IOException, XmlPullParserException\n    {\n        List plugins = new ArrayList();\n        // get all the pom models\n        List models =\n            utils.getModelsRecursively( project.getGroupId(), project.getArtifactId(), project.getVersion(),\n                                        new File( project.getBasedir(), project.getFile().getName() ) );\n\n        // now find all the plugin entries, either in\n        // build.plugins or build.pluginManagement.plugins, profiles.plugins and reporting\n        Iterator iter = models.iterator();\n        while ( iter.hasNext() )\n        {\n            Model model = (Model) iter.next();\n            try\n            {\n                plugins.addAll( PluginWrapper.addAll( model.getBuild().getPlugins(), model.getId() + \".build.plugins\" ) );\n            }\n            catch ( NullPointerException e )\n            {\n                // guess there are no plugins here.\n            }\n\n            try\n            {\n                // add the reporting plugins\n                plugins.addAll( PluginWrapper.addAll( model.getReporting().getPlugins(), model.getId() + \".reporting\" ) );\n            }\n            catch ( NullPointerException e )\n            {\n                // guess there are no plugins here.\n            }\n\n            try\n            {\n                plugins.addAll( PluginWrapper.addAll( model.getBuild().getPluginManagement().getPlugins(),\n                                                      model.getId() + \".build.pluginManagement.plugins\" ) );\n            }\n            catch ( NullPointerException e )\n            {\n                // guess there are no plugins here.\n            }\n\n            // Add plugins in profiles\n            Iterator it = model.getProfiles().iterator();\n            while ( it.hasNext() )\n            {\n                Profile profile = (Profile) it.next();\n                try\n                {\n                    plugins.addAll( PluginWrapper.addAll( profile.getBuild().getPlugins(), model.getId()\n                        + \".profiles.profile[\" + profile.getId() + \"].build.plugins\" ) );\n                }\n                catch ( NullPointerException e )\n                {\n                    // guess there are no plugins here.\n                }\n\n                try\n                {\n                    // add the reporting plugins\n                    plugins.addAll( PluginWrapper.addAll( profile.getReporting().getPlugins(), model.getId()\n                        + \"profile[\" + profile.getId() + \"].reporting.plugins\" ) );\n                }\n                catch ( NullPointerException e )\n                {\n                    // guess there are no plugins here.\n                }\n                try\n                {\n                    // add the reporting plugins\n                    plugins.addAll( PluginWrapper.addAll( profile.getBuild().getPluginManagement().getPlugins(),\n                                                          model.getId() + \"profile[\" + profile.getId()\n                                                              + \"].build.pluginManagement.plugins\" ) );\n                }\n                catch ( NullPointerException e )\n                {\n                    // guess there are no plugins here.\n                }\n            }\n        }\n\n        return plugins;\n    }\n\n    /**\n     * Checks if is ban latest.\n     *\n     * @return the banLatest\n     */\n    protected boolean isBanLatest()\n    {\n        return this.banLatest;\n    }\n\n    /**\n     * Sets the ban latest.\n     *\n     * @param theBanLatest the banLatest to set\n     */\n    protected void setBanLatest( boolean theBanLatest )\n    {\n        this.banLatest = theBanLatest;\n    }\n\n    /**\n     * Checks if is ban release.\n     *\n     * @return the banRelease\n     */\n    protected boolean isBanRelease()\n    {\n        return this.banRelease;\n    }\n\n    /**\n     * Sets the ban release.\n     *\n     * @param theBanRelease the banRelease to set\n     */\n    protected void setBanRelease( boolean theBanRelease )\n    {\n        this.banRelease = theBanRelease;\n    }\n\n    /**\n     * Gets the message.\n     *\n     * @return the message\n     */\n    protected String getMessage()\n    {\n        return this.message;\n    }\n\n    /**\n     * Sets the message.\n     *\n     * @param theMessage the message to set\n     */\n    protected void setMessage( String theMessage )\n    {\n        this.message = theMessage;\n    }\n\n    /**\n     * Gets the utils.\n     *\n     * @return the utils\n     */\n    protected EnforcerRuleUtils getUtils()\n    {\n        return this.utils;\n    }\n\n    /**\n     * Sets the utils.\n     *\n     * @param theUtils the utils to set\n     */\n    protected void setUtils( EnforcerRuleUtils theUtils )\n    {\n        this.utils = theUtils;\n    }\n\n    /**\n     * Checks if is ban snapshots.\n     *\n     * @return the banSnapshots\n     */\n    public boolean isBanSnapshots()\n    {\n        return this.banSnapshots;\n    }\n\n    /**\n     * Sets the ban snapshots.\n     *\n     * @param theBanSnapshots the banSnapshots to set\n     */\n    public void setBanSnapshots( boolean theBanSnapshots )\n    {\n        this.banSnapshots = theBanSnapshots;\n    }\n\n    /**\n     * Checks if is ban timestamps.\n     *\n     * @return the banTimestamps\n     */\n    public boolean isBanTimestamps()\n    {\n        return this.banTimestamps;\n    }\n\n    /**\n     * Sets the ban timestamps.\n     *\n     * @param theBanTimestamps the banTimestamps to set\n     */\n    public void setBanTimestamps( boolean theBanTimestamps )\n    {\n        this.banTimestamps = theBanTimestamps;\n    }\n\n    public List getUnCheckedPlugins()\n    {\n        return unCheckedPlugins;\n    }\n\n    public void setUnCheckedPlugins( List unCheckedPlugins )\n    {\n        this.unCheckedPlugins = unCheckedPlugins;\n    }\n}\n","lineNo":1014}
{"Refactored Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.resolver.filter.AndArtifactFilter;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.shared.artifact.filter.StrictPatternExcludesArtifactFilter;\nimport org.apache.maven.shared.artifact.filter.StrictPatternIncludesArtifactFilter;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n\n/**\n * This rule checks that no snapshots are included.\n *\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n * @version $Id$\n */\npublic class RequireReleaseDeps\n    extends AbstractBanDependencies\n{\n\n    /**\n     * Allows this rule to execute only when this project is a release.\n     *\n     * @parameter\n     */\n    public boolean onlyWhenRelease = false;\n\n    /**\n     * Allows this rule to fail when the parent is defined as a snapshot.\n     *\n     * @parameter\n     */\n    public boolean failWhenParentIsSnapshot = true;\n\n    /**\n     * Dependencies to ignore when checking for release versions.  For example, inter-module dependencies \n     * can be excluded from the check and therefore allowed to contain snapshot versions.\n     */\n    public List excludes = null;\n\n    /**\n     * Dependencies to include when checking for release versions.  If any of the included dependencies\n     * have snapshot versions, the rule will fail.\n     */\n    public List includes = null;\n\n    /**\n     * Override parent to allow optional ignore of this rule.\n     */\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        boolean callSuper;\n        MavenProject project = null;\n        if ( onlyWhenRelease )\n        {\n            // get the project\n            project = getProject( helper );\n\n            // only call super if this project is a release\n            callSuper = !project.getArtifact().isSnapshot();\n        }\n        else\n        {\n            callSuper = true;\n        }\n        if ( callSuper )\n        {\n            super.execute( helper );\n            if ( failWhenParentIsSnapshot )\n            {\n                if ( project == null )\n                {\n                    project = getProject( helper );\n                }\n                Artifact parentArtifact = project.getParentArtifact();\n                if ( parentArtifact != null && parentArtifact.isSnapshot() )\n                {\n                    throw new EnforcerRuleException( \"Parent Cannot be a snapshot: \" + parentArtifact.getId() );\n                }\n            }\n        }\n    }\n\n    /**\n     * @param helper\n     * @return\n     * @throws EnforcerRuleException\n     */\n    private MavenProject getProject( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        try\n        {\n            return (MavenProject) helper.evaluate( \"${project}\" );\n        }\n        catch ( ExpressionEvaluationException eee )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", eee );\n        }\n    }\n\n    /**\n     * Checks the set of dependencies to see if any snapshots are included\n     *\n     * @param dependencies the dependencies\n     * @param log the log\n     * @return the sets the\n     * @throws EnforcerRuleException the enforcer rule exception\n     */\n    protected Set checkDependencies( Set dependencies, Log log )\n        throws EnforcerRuleException\n    {\n        Set foundSnapshots = new HashSet();\n\n        Set filteredDependencies = this.filterArtifacts( dependencies );\n        \n        Iterator DependencyIter = filteredDependencies.iterator();\n        while ( DependencyIter.hasNext() )\n        {\n            Artifact artifact = (Artifact) DependencyIter.next();\n\n            if ( artifact.isSnapshot() )\n            {\n                foundSnapshots.add( artifact );\n            }\n        }\n\n        return foundSnapshots;\n    }\n    \n    /*\n     * Filter the dependency artifacts according to the includes and excludes\n     * If includes and excludes are both null, the original set is returned.\n     * \n     * @param dependencies the list of dependencies to filter\n     * @return the resulting set of dependencies\n     */\n    public Set filterArtifacts( Set dependencies )\n    {\n        if ( includes == null && excludes == null )\n        {\n            return dependencies;\n        }\n        \n        AndArtifactFilter filter = new AndArtifactFilter( );\n        if ( includes != null )\n        {\n            filter.add( new StrictPatternIncludesArtifactFilter( includes ) );\n        }\n        if ( excludes != null )\n        {\n            filter.add( new StrictPatternExcludesArtifactFilter( excludes ) );\n        }\n        \n        Set result = new HashSet();\n        Iterator iter = dependencies.iterator();\n        while ( iter.hasNext() )\n        {\n            Artifact artifact = (Artifact) iter.next();\n            if ( filter.include( artifact ) )\n            {\n                result.add( artifact );\n            }\n        }\n        return result;\n    }\n\n    public boolean isOnlyWhenRelease()\n    {\n        return onlyWhenRelease;\n    }\n\n    public void setOnlyWhenRelease( boolean onlyWhenRelease )\n    {\n        this.onlyWhenRelease = onlyWhenRelease;\n    }\n\n    public boolean isFailWhenParentIsSnapshot()\n    {\n        return failWhenParentIsSnapshot;\n    }\n\n    public void setFailWhenParentIsSnapshot( boolean failWhenParentIsSnapshot )\n    {\n        this.failWhenParentIsSnapshot = failWhenParentIsSnapshot;\n    }\n}\n","Smelly Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.project.MavenProject;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n\n/**\n * This rule checks that no snapshots are included.\n *\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n * @version $Id$\n */\npublic class RequireReleaseDeps\n    extends AbstractBanDependencies\n{\n\n    /**\n     * Allows this rule to execute only when this project is a release.\n     *\n     * @parameter\n     */\n    public boolean onlyWhenRelease = false;\n\n    /**\n     * Allows this rule to fail when the parent is defined as a snapshot.\n     *\n     * @parameter\n     */\n    public boolean failWhenParentIsSnapshot = true;\n\n    /**\n     * Override parent to allow optional ignore of this rule.\n     */\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        boolean callSuper;\n        MavenProject project = null;\n        if ( onlyWhenRelease )\n        {\n            // get the project\n            project = getProject( helper );\n\n            // only call super if this project is a release\n            callSuper = !project.getArtifact().isSnapshot();\n        }\n        else\n        {\n            callSuper = true;\n        }\n        if ( callSuper )\n        {\n            super.execute( helper );\n            if ( failWhenParentIsSnapshot )\n            {\n                if ( project == null )\n                {\n                    project = getProject( helper );\n                }\n                Artifact parentArtifact = project.getParentArtifact();\n                if ( parentArtifact != null && parentArtifact.isSnapshot() )\n                {\n                    throw new EnforcerRuleException( \"Parent Cannot be a snapshot: \" + parentArtifact.getId() );\n                }\n            }\n        }\n    }\n\n    /**\n     * @param helper\n     * @return\n     * @throws EnforcerRuleException\n     */\n    private MavenProject getProject( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        try\n        {\n            return (MavenProject) helper.evaluate( \"${project}\" );\n        }\n        catch ( ExpressionEvaluationException eee )\n        {\n            throw new EnforcerRuleException( \"Unable to retrieve the MavenProject: \", eee );\n        }\n    }\n\n    /**\n     * Checks the set of dependencies to see if any snapshots are included\n     *\n     * @param dependencies the dependencies\n     * @param log the log\n     * @return the sets the\n     * @throws EnforcerRuleException the enforcer rule exception\n     */\n    protected Set checkDependencies( Set dependencies, Log log )\n        throws EnforcerRuleException\n    {\n        Set foundExcludes = new HashSet();\n\n        Iterator DependencyIter = dependencies.iterator();\n        while ( DependencyIter.hasNext() )\n        {\n            Artifact artifact = (Artifact) DependencyIter.next();\n\n            if ( artifact.isSnapshot() )\n            {\n                foundExcludes.add( artifact );\n            }\n        }\n\n        return foundExcludes;\n    }\n\n    public boolean isOnlyWhenRelease()\n    {\n        return onlyWhenRelease;\n    }\n\n    public void setOnlyWhenRelease( boolean onlyWhenRelease )\n    {\n        this.onlyWhenRelease = onlyWhenRelease;\n    }\n\n    public boolean isFailWhenParentIsSnapshot()\n    {\n        return failWhenParentIsSnapshot;\n    }\n\n    public void setFailWhenParentIsSnapshot( boolean failWhenParentIsSnapshot )\n    {\n        this.failWhenParentIsSnapshot = failWhenParentIsSnapshot;\n    }\n}\n","lineNo":142}
{"Refactored Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.Map.Entry;\n\nimport org.apache.maven.BuildFailureException;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.artifact.versioning.InvalidVersionSpecificationException;\nimport org.apache.maven.artifact.versioning.VersionRange;\nimport org.apache.maven.enforcer.rule.api.EnforcerRule;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.lifecycle.Lifecycle;\nimport org.apache.maven.lifecycle.LifecycleExecutionException;\nimport org.apache.maven.lifecycle.LifecycleExecutor;\nimport org.apache.maven.lifecycle.mapping.LifecycleMapping;\nimport org.apache.maven.model.BuildBase;\nimport org.apache.maven.model.Model;\nimport org.apache.maven.model.Plugin;\nimport org.apache.maven.model.Profile;\nimport org.apache.maven.plugin.InvalidPluginException;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.PluginManager;\nimport org.apache.maven.plugin.PluginManagerException;\nimport org.apache.maven.plugin.PluginNotFoundException;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.plugin.version.PluginVersionNotFoundException;\nimport org.apache.maven.plugin.version.PluginVersionResolutionException;\nimport org.apache.maven.plugins.enforcer.utils.EnforcerRuleUtils;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.settings.Settings;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\nimport org.codehaus.plexus.component.repository.exception.ComponentLookupException;\nimport org.codehaus.plexus.util.ReflectionUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.pull.XmlPullParserException;\n\n/**\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n * @version $Id$ This rule will enforce that all plugins specified in the poms have a version declared.\n */\npublic class RequirePluginVersions\n    extends AbstractStandardEnforcerRule\n{\n\n    /**\n     * Don't allow the LATEST identifier\n     */\n    public boolean banLatest = true;\n\n    /**\n     * Don't allow the RELEASE identifier\n     * \n     * @required\n     * @parameter\n     */\n    public boolean banRelease = true;\n\n    /**\n     * Don't allow snapshot plugins.\n     */\n    public boolean banSnapshots = true;\n\n    /**\n     * The comma separated list of phases that should be used to find lifecycle plugin bindings. The default value is\n     * \"clean,deploy,site\".\n     * \n     * @parameter\n     */\n    public String phases = \"clean,deploy,site\";\n\n    /**\n     * Additional plugins to enforce have versions. These are plugins that may not be in the poms but are used anyway,\n     * like help, eclipse etc. <br>\n     * The plugins should be specified in the form: group:artifactId.\n     */\n    public List additionalPlugins;\n\n    private PluginManager pluginManager;\n\n    private Map phaseToLifecycleMap;\n\n    private List lifecycles;\n\n    ArtifactFactory factory;\n\n    ArtifactResolver resolver;\n\n    ArtifactRepository local;\n\n    List remoteRepositories;\n\n    Log log;\n\n    MavenSession session;\n\n    EnforcerRuleUtils utils;\n\n    public void execute( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        log = helper.getLog();\n\n        MavenProject project;\n        try\n        {\n            // get the various expressions out of the\n            // helper.\n            project = (MavenProject) helper.evaluate( \"${project}\" );\n            LifecycleExecutor life;\n            life = (LifecycleExecutor) helper.getComponent( LifecycleExecutor.class );\n            session = (MavenSession) helper.evaluate( \"${session}\" );\n            pluginManager = (PluginManager) helper.getComponent( PluginManager.class );\n            factory = (ArtifactFactory) helper.getComponent( ArtifactFactory.class );\n            resolver = (ArtifactResolver) helper.getComponent( ArtifactResolver.class );\n            local = (ArtifactRepository) helper.evaluate( \"${localRepository}\" );\n            remoteRepositories = project.getRemoteArtifactRepositories();\n\n            utils = new EnforcerRuleUtils( helper );\n\n            // get all the plugins that are bound to the\n            // specified lifecycles\n            Set allPlugins = getBoundPlugins( life, project, phases );\n\n            // insert any additional Plugins specified by\n            // the user.\n            allPlugins = addAdditionalPlugins( allPlugins, additionalPlugins );\n            allPlugins.addAll( getProfilePlugins( project ) );\n\n            // there's nothing to do here\n            if ( allPlugins.isEmpty() )\n            {\n                log.info( \"No plugin bindings found.\" );\n                return;\n            }\n            else\n            {\n                log.debug( \"All Plugins in use: \" + allPlugins );\n            }\n\n            // get all the plugins that are mentioned in the\n            // pom (and parents)\n            List plugins = getAllPluginEntries( project );\n\n            // now look for the versions that aren't valid\n            // and add to a list.\n            ArrayList failures = new ArrayList();\n            Iterator iter = allPlugins.iterator();\n            while ( iter.hasNext() )\n            {\n                Plugin plugin = (Plugin) iter.next();\n                if ( !hasValidVersionSpecified( helper, plugin, plugins ) )\n                {\n                    failures.add( plugin );\n                }\n            }\n\n            // if anything was found, log it then append the\n            // optional message.\n            if ( !failures.isEmpty() )\n            {\n                StringBuffer newMsg = new StringBuffer();\n                newMsg.append( \"Some plugins are missing valid versions:\" );\n                if ( banLatest || banRelease || banSnapshots )\n                {\n                    newMsg.append( \"(\" );\n                    if ( banLatest )\n                    {\n                        newMsg.append( \"LATEST \" );\n                    }\n                    if ( banRelease )\n                    {\n                        newMsg.append( \"RELEASE \" );\n                    }\n                    if ( banSnapshots )\n                    {\n                        newMsg.append( \"SNAPSHOT \" );\n                    }\n                    newMsg.append( \"are not allowed )\\n\" );\n                }\n                iter = failures.iterator();\n                while ( iter.hasNext() )\n                {\n                    Plugin plugin = (Plugin) iter.next();\n\n                    newMsg.append( plugin.getGroupId() );\n                    newMsg.append( \":\" );\n                    newMsg.append( plugin.getArtifactId() );\n\n                    try\n                    {\n                        newMsg.append( \". \\tThe version currently in use is \" );\n\n                        Plugin currentPlugin = findCurrentPlugin( plugin, project );\n\n                        if ( currentPlugin != null )\n                        {\n                            newMsg.append( currentPlugin.getVersion() );\n                        }\n                        else\n                        {\n                            newMsg.append( \"unknown\" );\n                        }\n                    }\n                    catch ( Exception e )\n                    {\n                        // lots can go wrong here. Don't\n                        // allow any issues trying to\n                        // determine the issue\n                        // stop me\n                        log.debug( \"Exception while determining plugin Version.\", e );\n                        newMsg.append( \". Unable to determine the plugin version.\" );\n                    }\n                    newMsg.append( \"\\n\" );\n                }\n                if ( StringUtils.isNotEmpty( message ) )\n                {\n                    newMsg.append( message );\n                }\n\n                throw new EnforcerRuleException( newMsg.toString() );\n            }\n        }\n        catch ( ExpressionEvaluationException e )\n        {\n            throw new EnforcerRuleException( \"Unable to Evaluate an Expression:\" + e.getLocalizedMessage() );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new EnforcerRuleException( \"Unable to lookup a component:\" + e.getLocalizedMessage() );\n        }\n        catch ( IllegalAccessException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( LifecycleExecutionException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( PluginNotFoundException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( IOException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( MojoExecutionException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n    }\n\n    /**\n     * Add the additional plugins if they don't exist yet\n     * \n     * @throws MojoExecutionException\n     */\n    public Set addAdditionalPlugins( Set existing, List additional )\n        throws MojoExecutionException\n    {\n        if ( additional != null )\n        {\n            Iterator iter = additional.iterator();\n            while ( iter.hasNext() )\n            {\n                String pluginString = (String) iter.next();\n                String[] pluginStrings = pluginString.split( \":\" );\n                if ( pluginStrings.length == 2 )\n                {\n                    Plugin plugin = new Plugin();\n                    plugin.setGroupId( pluginStrings[0] );\n                    plugin.setArtifactId( pluginStrings[1] );\n\n                    // only add this if it's not already\n                    // there.\n                    if ( existing == null )\n                    {\n                        existing = new HashSet();\n                        existing.add( plugin );\n                    }\n                    else if ( !existing.contains( plugin ) )\n                    {\n                        existing.add( plugin );\n                    }\n                }\n                else\n                {\n                    throw new MojoExecutionException( \"Invalid AdditionalPlugin string: \" + pluginString );\n                }\n            }\n\n        }\n        return existing;\n    }\n\n    /**\n     * Finds the plugins that are listed in active profiles\n     * \n     * @param project\n     * @return\n     */\n    public Set getProfilePlugins( MavenProject project )\n    {\n        Set result = new HashSet();\n        List profiles = project.getActiveProfiles();\n        if ( profiles != null && !profiles.isEmpty() )\n        {\n            Iterator iter = profiles.iterator();\n            while ( iter.hasNext() )\n            {\n                Profile p = (Profile) iter.next();\n                BuildBase b = p.getBuild();\n                if ( b != null )\n                {\n                    List plugins = b.getPlugins();\n                    if ( plugins != null )\n                    {\n                        result.addAll( plugins );\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Given a plugin, this will retrieve the matching plugin artifact from the model.\n     * \n     * @param plugin to lookup\n     * @param project to search\n     * @return matching plugin, null if not found.\n     */\n    protected Plugin findCurrentPlugin( Plugin plugin, MavenProject project )\n    {\n        Plugin found = null;\n        try\n        {\n            Model model = project.getModel();\n            Map plugins = model.getBuild().getPluginsAsMap();\n            found = (Plugin) plugins.get( plugin.getKey() );\n        }\n        catch ( NullPointerException e )\n        {\n            // nothing to do here\n        }\n\n        if ( found == null )\n        {\n            found = resolvePlugin( plugin, project );\n        }\n\n        return found;\n    }\n\n    protected Plugin resolvePlugin( Plugin plugin, MavenProject project )\n    {\n\n        List pluginRepositories = project.getPluginArtifactRepositories();\n        Artifact artifact =\n            factory.createPluginArtifact( plugin.getGroupId(), plugin.getArtifactId(),\n                                          VersionRange.createFromVersion( \"LATEST\" ) );\n\n        try\n        {\n            this.resolver.resolve( artifact, pluginRepositories, this.local );\n            plugin.setVersion( artifact.getVersion() );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n        }\n\n        return plugin;\n    }\n\n    /**\n     * Gets the plugins that are bound to the defined phases. This does not find plugins bound in the pom to a phase\n     * later than the plugin is executing.\n     * \n     * @param life\n     * @param project\n     * @return\n     * @throws PluginNotFoundException\n     * @throws LifecycleExecutionException\n     * @throws IllegalAccessException\n     */\n    protected Set getBoundPlugins( LifecycleExecutor life, MavenProject project, String thePhases )\n        throws PluginNotFoundException, LifecycleExecutionException, IllegalAccessException\n    {\n        // I couldn't find a direct way to get at the\n        // lifecycles list.\n        lifecycles = (List) ReflectionUtils.getValueIncludingSuperclasses( \"lifecycles\", life );\n\n        Set allPlugins = new HashSet();\n\n        // lookup the bindings for all the passed in phases\n        String[] lifecyclePhases = thePhases.split( \",\" );\n        for ( int i = 0; i < lifecyclePhases.length; i++ )\n        {\n            String lifecyclePhase = lifecyclePhases[i];\n            if ( StringUtils.isNotEmpty( lifecyclePhase ) )\n            {\n                try\n                {\n                    Lifecycle lifecycle = getLifecycleForPhase( lifecyclePhase );\n                    allPlugins.addAll( getAllPlugins( project, lifecycle ) );\n                }\n                catch ( BuildFailureException e )\n                {\n                    // i'm going to swallow this because the\n                    // user may have declared a phase that\n                    // doesn't\n                    // exist for every module.\n                }\n            }\n        }\n        return allPlugins;\n    }\n\n    /*\n     * Checks to see if the version is specified for the plugin. Can optionally ban \"RELEASE\" or \"LATEST\" even if\n     * specified.\n     */\n    protected boolean hasValidVersionSpecified( EnforcerRuleHelper helper, Plugin source, List plugins )\n    {\n        boolean status = false;\n        Iterator iter = plugins.iterator();\n        while ( iter.hasNext() )\n        {\n            // find the matching plugin entry\n            Plugin plugin = (Plugin) iter.next();\n            if ( source.getArtifactId().equals( plugin.getArtifactId() ) &&\n                source.getGroupId().equals( plugin.getGroupId() ) )\n            {\n                // found the entry. now see if the version\n                // is specified\n                String version = plugin.getVersion();\n                try\n                {\n                    version = (String) helper.evaluate( version );\n                }\n                catch ( ExpressionEvaluationException e )\n                {\n                    return false;\n                }\n\n                if ( StringUtils.isNotEmpty( version ) && !StringUtils.isWhitespace( version ) )\n                {\n\n                    if ( banRelease && version.equals( \"RELEASE\" ) )\n                    {\n                        return false;\n                    }\n\n                    if ( banLatest && version.equals( \"LATEST\" ) )\n                    {\n                        return false;\n                    }\n\n                    if ( banSnapshots && isSnapshot( version ) )\n                    {\n                        return false;\n                    }\n                    // the version was specified and not\n                    // banned. It's ok. Keep looking through the list to make\n                    // sure it's not using a banned version somewhere else.\n\n                    status = true;\n\n                    if ( !banRelease && !banLatest && !banSnapshots )\n                    {\n                        // no need to keep looking\n                        break;\n                    }\n                }\n            }\n        }\n        return status;\n    }\n\n    protected boolean isSnapshot( String baseVersion )\n    {\n        return Artifact.VERSION_FILE_PATTERN.matcher( baseVersion ).matches() ||\n            baseVersion.endsWith( Artifact.SNAPSHOT_VERSION );\n    }\n\n    /*\n     * Uses borrowed lifecycle code to get a list of all plugins bound to the lifecycle.\n     */\n    private Set getAllPlugins( MavenProject project, Lifecycle lifecycle )\n        throws PluginNotFoundException, LifecycleExecutionException\n\n    {\n        HashSet plugins = new HashSet();\n        // first, bind those associated with the packaging\n        Map mappings = findMappingsForLifecycle( project, lifecycle );\n\n        Iterator iter = mappings.entrySet().iterator();\n        while ( iter.hasNext() )\n        {\n            Entry entry = (Entry) iter.next();\n            String value = (String) entry.getValue();\n            String tokens[] = value.split( \":\" );\n\n            Plugin plugin = new Plugin();\n            plugin.setGroupId( tokens[0] );\n            plugin.setArtifactId( tokens[1] );\n            plugins.add( plugin );\n        }\n\n        List mojos = findOptionalMojosForLifecycle( project, lifecycle );\n        iter = mojos.iterator();\n        while ( iter.hasNext() )\n        {\n            String value = (String) iter.next();\n            String tokens[] = value.split( \":\" );\n\n            Plugin plugin = new Plugin();\n            plugin.setGroupId( tokens[0] );\n            plugin.setArtifactId( tokens[1] );\n            plugins.add( plugin );\n        }\n\n        for ( Iterator i = project.getBuildPlugins().iterator(); i.hasNext(); )\n        {\n            plugins.add( i.next() );\n        }\n\n        return plugins;\n    }\n\n    /*\n     * NOTE: All the code following this point was scooped from the DefaultLifecycleExecutor. There must be a better way\n     * but for now it should work.\n     */\n    public Map getPhaseToLifecycleMap()\n        throws LifecycleExecutionException\n    {\n        if ( phaseToLifecycleMap == null )\n        {\n            phaseToLifecycleMap = new HashMap();\n\n            for ( Iterator i = lifecycles.iterator(); i.hasNext(); )\n            {\n                Lifecycle lifecycle = (Lifecycle) i.next();\n\n                for ( Iterator p = lifecycle.getPhases().iterator(); p.hasNext(); )\n                {\n                    String phase = (String) p.next();\n\n                    if ( phaseToLifecycleMap.containsKey( phase ) )\n                    {\n                        Lifecycle prevLifecycle = (Lifecycle) phaseToLifecycleMap.get( phase );\n                        throw new LifecycleExecutionException( \"Phase '\" + phase +\n                            \"' is defined in more than one lifecycle: '\" + lifecycle.getId() + \"' and '\" +\n                            prevLifecycle.getId() + \"'\" );\n                    }\n                    else\n                    {\n                        phaseToLifecycleMap.put( phase, lifecycle );\n                    }\n                }\n            }\n        }\n        return phaseToLifecycleMap;\n    }\n\n    private Lifecycle getLifecycleForPhase( String phase )\n        throws BuildFailureException, LifecycleExecutionException\n    {\n        Lifecycle lifecycle = (Lifecycle) getPhaseToLifecycleMap().get( phase );\n\n        if ( lifecycle == null )\n        {\n            throw new BuildFailureException( \"Unable to find lifecycle for phase '\" + phase + \"'\" );\n        }\n        return lifecycle;\n    }\n\n    private Map findMappingsForLifecycle( MavenProject project, Lifecycle lifecycle )\n        throws LifecycleExecutionException, PluginNotFoundException\n    {\n        String packaging = project.getPackaging();\n        Map mappings = null;\n\n        LifecycleMapping m =\n            (LifecycleMapping) findExtension( project, LifecycleMapping.ROLE, packaging, session.getSettings(),\n                                              session.getLocalRepository() );\n        if ( m != null )\n        {\n            mappings = m.getPhases( lifecycle.getId() );\n        }\n\n        Map defaultMappings = lifecycle.getDefaultPhases();\n\n        if ( mappings == null )\n        {\n            try\n            {\n                m = (LifecycleMapping) session.lookup( LifecycleMapping.ROLE, packaging );\n                mappings = m.getPhases( lifecycle.getId() );\n            }\n            catch ( ComponentLookupException e )\n            {\n                if ( defaultMappings == null )\n                {\n                    throw new LifecycleExecutionException( \"Cannot find lifecycle mapping for packaging: \\'\" +\n                        packaging + \"\\'.\", e );\n                }\n            }\n        }\n\n        if ( mappings == null )\n        {\n            if ( defaultMappings == null )\n            {\n                throw new LifecycleExecutionException( \"Cannot find lifecycle mapping for packaging: \\'\" + packaging +\n                    \"\\', and there is no default\" );\n            }\n            else\n            {\n                mappings = defaultMappings;\n            }\n        }\n\n        return mappings;\n    }\n\n    private List findOptionalMojosForLifecycle( MavenProject project, Lifecycle lifecycle )\n        throws LifecycleExecutionException, PluginNotFoundException\n    {\n        String packaging = project.getPackaging();\n        List optionalMojos = null;\n\n        LifecycleMapping m =\n            (LifecycleMapping) findExtension( project, LifecycleMapping.ROLE, packaging, session.getSettings(),\n                                              session.getLocalRepository() );\n\n        if ( m != null )\n        {\n            optionalMojos = m.getOptionalMojos( lifecycle.getId() );\n        }\n\n        if ( optionalMojos == null )\n        {\n            try\n            {\n                m = (LifecycleMapping) session.lookup( LifecycleMapping.ROLE, packaging );\n                optionalMojos = m.getOptionalMojos( lifecycle.getId() );\n            }\n            catch ( ComponentLookupException e )\n            {\n                log.debug( \"Error looking up lifecycle mapping to retrieve optional mojos. Lifecycle ID: \" +\n                    lifecycle.getId() + \". Error: \" + e.getMessage(), e );\n            }\n        }\n\n        if ( optionalMojos == null )\n        {\n            optionalMojos = Collections.EMPTY_LIST;\n        }\n\n        return optionalMojos;\n    }\n\n    private Object findExtension( MavenProject project, String role, String roleHint, Settings settings,\n                                  ArtifactRepository localRepository )\n        throws LifecycleExecutionException, PluginNotFoundException\n    {\n        Object pluginComponent = null;\n\n        for ( Iterator i = project.getBuildPlugins().iterator(); i.hasNext() && pluginComponent == null; )\n        {\n            Plugin plugin = (Plugin) i.next();\n\n            if ( plugin.isExtensions() )\n            {\n                verifyPlugin( plugin, project, settings, localRepository );\n\n                // TODO: if moved to the plugin manager we\n                // already have the descriptor from above\n                // and so do can lookup the container\n                // directly\n                try\n                {\n                    pluginComponent = pluginManager.getPluginComponent( plugin, role, roleHint );\n                }\n                catch ( ComponentLookupException e )\n                {\n                    log.debug( \"Unable to find the lifecycle component in the extension\", e );\n                }\n                catch ( PluginManagerException e )\n                {\n                    throw new LifecycleExecutionException( \"Error getting extensions from the plugin '\" +\n                        plugin.getKey() + \"': \" + e.getMessage(), e );\n                }\n            }\n        }\n        return pluginComponent;\n    }\n\n    private PluginDescriptor verifyPlugin( Plugin plugin, MavenProject project, Settings settings,\n                                           ArtifactRepository localRepository )\n        throws LifecycleExecutionException, PluginNotFoundException\n    {\n        PluginDescriptor pluginDescriptor;\n        try\n        {\n            pluginDescriptor = pluginManager.verifyPlugin( plugin, project, settings, localRepository );\n        }\n        catch ( PluginManagerException e )\n        {\n            throw new LifecycleExecutionException( \"Internal error in the plugin manager getting plugin '\" +\n                plugin.getKey() + \"': \" + e.getMessage(), e );\n        }\n        catch ( PluginVersionResolutionException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( InvalidVersionSpecificationException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( InvalidPluginException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( PluginVersionNotFoundException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        return pluginDescriptor;\n    }\n\n    /**\n     * Gets all plugin entries in build.plugins or build.pluginManagement.plugins in this project and all parents\n     * \n     * @param project\n     * @return\n     * @throws ArtifactResolutionException\n     * @throws ArtifactNotFoundException\n     * @throws IOException\n     * @throws XmlPullParserException\n     */\n    protected List getAllPluginEntries( MavenProject project )\n        throws ArtifactResolutionException, ArtifactNotFoundException, IOException, XmlPullParserException\n    {\n        List plugins = new ArrayList();\n        // get all the pom models\n        List models =\n            utils.getModelsRecursively( project.getGroupId(), project.getArtifactId(), project.getVersion(),\n                                        new File( project.getBasedir(), \"pom.xml\" ) );\n\n        // now find all the plugin entries, either in\n        // build.plugins or build.pluginManagement.plugins\n        Iterator iter = models.iterator();\n        while ( iter.hasNext() )\n        {\n            Model model = (Model) iter.next();\n            try\n            {\n                plugins.addAll( model.getBuild().getPlugins() );\n            }\n            catch ( NullPointerException e )\n            {\n                // guess there are no plugins here.\n            }\n\n            try\n            {\n                plugins.addAll( model.getBuild().getPluginManagement().getPlugins() );\n            }\n            catch ( NullPointerException e )\n            {\n                // guess there are no plugins here.\n            }\n        }\n\n        return plugins;\n    }\n\n    /**\n     * @return the banLatest\n     */\n    protected boolean isBanLatest()\n    {\n        return this.banLatest;\n    }\n\n    /**\n     * @param theBanLatest the banLatest to set\n     */\n    protected void setBanLatest( boolean theBanLatest )\n    {\n        this.banLatest = theBanLatest;\n    }\n\n    /**\n     * @return the banRelease\n     */\n    protected boolean isBanRelease()\n    {\n        return this.banRelease;\n    }\n\n    /**\n     * @param theBanRelease the banRelease to set\n     */\n    protected void setBanRelease( boolean theBanRelease )\n    {\n        this.banRelease = theBanRelease;\n    }\n\n    /**\n     * @return the message\n     */\n    protected String getMessage()\n    {\n        return this.message;\n    }\n\n    /**\n     * @param theMessage the message to set\n     */\n    protected void setMessage( String theMessage )\n    {\n        this.message = theMessage;\n    }\n\n    /**\n     * @return the utils\n     */\n    protected EnforcerRuleUtils getUtils()\n    {\n        return this.utils;\n    }\n\n    /**\n     * @param theUtils the utils to set\n     */\n    protected void setUtils( EnforcerRuleUtils theUtils )\n    {\n        this.utils = theUtils;\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see org.apache.maven.enforcer.rule.api.EnforcerRule#getCacheId()\n     */\n    public String getCacheId()\n    {\n        return \"0\";\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see org.apache.maven.enforcer.rule.api.EnforcerRule#isCacheable()\n     */\n    public boolean isCacheable()\n    {\n        return false;\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see org.apache.maven.enforcer.rule.api.EnforcerRule#isResultValid(org.apache.maven.enforcer.rule.api.EnforcerRule)\n     */\n    public boolean isResultValid( EnforcerRule theCachedRule )\n    {\n        return false;\n    }\n\n    /**\n     * @return the banSnapshots\n     */\n    public boolean isBanSnapshots()\n    {\n        return this.banSnapshots;\n    }\n\n    /**\n     * @param theBanSnapshots the banSnapshots to set\n     */\n    public void setBanSnapshots( boolean theBanSnapshots )\n    {\n        this.banSnapshots = theBanSnapshots;\n    }\n}\n","Smelly Sample":"package org.apache.maven.plugins.enforcer;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.Map.Entry;\n\nimport org.apache.maven.BuildFailureException;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.artifact.versioning.InvalidVersionSpecificationException;\nimport org.apache.maven.artifact.versioning.VersionRange;\nimport org.apache.maven.enforcer.rule.api.EnforcerRule;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleException;\nimport org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.lifecycle.Lifecycle;\nimport org.apache.maven.lifecycle.LifecycleExecutionException;\nimport org.apache.maven.lifecycle.LifecycleExecutor;\nimport org.apache.maven.lifecycle.mapping.LifecycleMapping;\nimport org.apache.maven.model.Model;\nimport org.apache.maven.model.Plugin;\nimport org.apache.maven.plugin.InvalidPluginException;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.PluginManager;\nimport org.apache.maven.plugin.PluginManagerException;\nimport org.apache.maven.plugin.PluginNotFoundException;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.plugin.version.PluginVersionNotFoundException;\nimport org.apache.maven.plugin.version.PluginVersionResolutionException;\nimport org.apache.maven.plugins.enforcer.utils.EnforcerRuleUtils;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.settings.Settings;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\nimport org.codehaus.plexus.component.repository.exception.ComponentLookupException;\nimport org.codehaus.plexus.util.ReflectionUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.pull.XmlPullParserException;\n\n/**\n * @author <a href=\"mailto:brianf@apache.org\">Brian Fox<\/a>\n * @version $Id$\n * \n * This rule will enforce that all plugins specified in the\n * poms have a version declared.\n */\npublic class RequirePluginVersions\n    implements EnforcerRule\n{\n\n    /**\n     * The message to be printed in case the condition\n     * returns <b>true<\/b>\n     * \n     * @required\n     * @parameter\n     */\n    public String message;\n\n    /**\n     * Don't allow the LATEST identifier\n     */\n    public boolean banLatest = true;\n\n    /**\n     * Don't allow the RELEASE identifier\n     * \n     * @required\n     * @parameter\n     */\n    public boolean banRelease = true;\n\n    /**\n     * Don't allow snapshot plugins.\n     */\n    public boolean banSnapshots = true;\n\n    /**\n     * The comma separated list of phases that should be\n     * used to find lifecycle plugin bindings. The default\n     * value is \"clean,deploy,site\".\n     * \n     * @parameter\n     */\n    public String phases = \"clean,deploy,site\";\n\n    /**\n     * Additional plugins to enforce have versions. These\n     * are plugins that may not be in the poms but are used\n     * anyway, like help, eclipse etc. <br>\n     * The plugins should be specified in the form:\n     * group:artifactId.\n     */\n    public List additionalPlugins;\n\n    private PluginManager pluginManager;\n\n    private Map phaseToLifecycleMap;\n\n    private List lifecycles;\n\n    ArtifactFactory factory;\n\n    ArtifactResolver resolver;\n\n    ArtifactRepository local;\n\n    List remoteRepositories;\n\n    Log log;\n\n    MavenSession session;\n\n    EnforcerRuleUtils utils;\n\n    public void execute ( EnforcerRuleHelper helper )\n        throws EnforcerRuleException\n    {\n        log = helper.getLog();\n\n        MavenProject project;\n        try\n        {\n            // get the various expressions out of the\n            // helper.\n            project = (MavenProject) helper.evaluate( \"${project}\" );\n            LifecycleExecutor life;\n            life = (LifecycleExecutor) helper.getComponent( LifecycleExecutor.class );\n            session = (MavenSession) helper.evaluate( \"${session}\" );\n            pluginManager = (PluginManager) helper.getComponent( PluginManager.class );\n            factory = (ArtifactFactory) helper.getComponent( ArtifactFactory.class );\n            resolver = (ArtifactResolver) helper.getComponent( ArtifactResolver.class );\n            local = (ArtifactRepository) helper.evaluate( \"${localRepository}\" );\n            remoteRepositories = project.getRemoteArtifactRepositories();\n\n            utils = new EnforcerRuleUtils( helper );\n\n            // get all the plugins that are bound to the\n            // specified lifecycles\n            Set allPlugins = getBoundPlugins( life, project, phases );\n\n            // insert any additional Plugins specified by\n            // the user.\n            allPlugins = addAdditionalPlugins( allPlugins, additionalPlugins );\n\n            // there's nothing to do here\n            if ( allPlugins.isEmpty() )\n            {\n                log.info( \"No plugin bindings found.\" );\n                return;\n            }\n            else\n            {\n                log.debug( \"All Plugins in use: \" + allPlugins );\n            }\n\n            // get all the plugins that are mentioned in the\n            // pom (and parents)\n            List plugins = getAllPluginEntries( project );\n\n            // now look for the versions that aren't valid\n            // and add to a list.\n            ArrayList failures = new ArrayList();\n            Iterator iter = allPlugins.iterator();\n            while ( iter.hasNext() )\n            {\n                Plugin plugin = (Plugin) iter.next();\n                if ( !hasVersionSpecified( plugin, plugins ) )\n                {\n                    failures.add( plugin );\n                }\n            }\n\n            // if anything was found, log it then append the\n            // optional message.\n            if ( !failures.isEmpty() )\n            {\n                StringBuffer newMsg = new StringBuffer();\n                newMsg.append( \"Some plugins are missing valid versions:\" );\n                if (banLatest || banRelease || banSnapshots)\n                {\n                    newMsg.append (\"(\");\n                    if (banLatest)\n                    {\n                        newMsg.append (\"LATEST \");   \n                    }\n                    if (banRelease)\n                    {\n                        newMsg.append (\"RELEASE \");   \n                    }\n                    if (banSnapshots)\n                    {\n                        newMsg.append (\"SNAPSHOT \");   \n                    }\n                    newMsg.append( \"are not allowed )\\n\");\n                }\n                iter = failures.iterator();\n                while ( iter.hasNext() )\n                {\n                    Plugin plugin = (Plugin) iter.next();\n\n                    newMsg.append( plugin.getGroupId() );\n                    newMsg.append( \":\" );\n                    newMsg.append( plugin.getArtifactId() );\n\n                    try\n                    {\n                        newMsg.append( \". \\tThe version currently in use is \" );\n\n                        Plugin currentPlugin = findCurrentPlugin( plugin, project );\n\n                        if ( currentPlugin != null )\n                        {\n                            newMsg.append( currentPlugin.getVersion() );\n                        }\n                        else\n                        {\n                            newMsg.append( \"unknown\" );\n                        }\n                    }\n                    catch ( Exception e )\n                    {\n                        // lots can go wrong here. Don't\n                        // allow any issues trying to\n                        // determine the issue\n                        // stop me\n                        log.debug( \"Exception while determining plugin Version.\", e );\n                        newMsg.append( \". Unable to determine the plugin version.\" );\n                    }\n                    newMsg.append( \"\\n\" );\n                }\n                if ( StringUtils.isNotEmpty( message ) )\n                {\n                    newMsg.append( message );\n                }\n\n                throw new EnforcerRuleException( newMsg.toString() );\n            }\n        }\n        catch ( ExpressionEvaluationException e )\n        {\n            throw new EnforcerRuleException( \"Unable to Evaluate an Expression:\" + e.getLocalizedMessage() );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new EnforcerRuleException( \"Unable to lookup a component:\" + e.getLocalizedMessage() );\n        }\n        catch ( IllegalAccessException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( LifecycleExecutionException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( PluginNotFoundException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( IOException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n        catch ( MojoExecutionException e )\n        {\n            throw new EnforcerRuleException( e.getLocalizedMessage() );\n        }\n    }\n\n    /**\n     * Add the additional plugins if they don't exist yet\n     * \n     * @throws MojoExecutionException\n     */\n    public Set addAdditionalPlugins ( Set existing, List additional )\n        throws MojoExecutionException\n    {\n        if ( additional != null )\n        {\n            Iterator iter = additional.iterator();\n            while ( iter.hasNext() )\n            {\n                String pluginString = (String) iter.next();\n                String[] pluginStrings = pluginString.split( \":\" );\n                if ( pluginStrings.length == 2 )\n                {\n                    Plugin plugin = new Plugin();\n                    plugin.setGroupId( pluginStrings[0] );\n                    plugin.setArtifactId( pluginStrings[1] );\n\n                    // only add this if it's not already\n                    // there.\n                    if (existing == null)\n                    {\n                        existing = new HashSet();\n                        existing.add( plugin );\n                    }\n                    else if ( !existing.contains( plugin ) )\n                    {\n                        existing.add( plugin );\n                    }\n                }\n                else\n                {\n                    throw new MojoExecutionException( \"Invalid AdditionalPlugin string: \" + pluginString );\n                }\n            }\n\n        }\n        return existing;\n    }\n\n    /**\n     * Given a plugin, this will retrieve the matching\n     * plugin artifact from the model.\n     * \n     * @param plugin to lookup\n     * @param project to search\n     * @return matching plugin, null if not found.\n     */\n    protected Plugin findCurrentPlugin ( Plugin plugin, MavenProject project )\n    {\n        Plugin found = null;\n        try\n        {\n            Model model = project.getModel();\n            Map plugins = model.getBuild().getPluginsAsMap();\n            found = (Plugin) plugins.get( plugin.getKey() );\n        }\n        catch ( NullPointerException e )\n        {\n            // nothing to do here\n        }\n\n        if ( found == null )\n        {\n            found = resolvePlugin( plugin, project );\n        }\n\n        return found;\n    }\n\n    protected Plugin resolvePlugin ( Plugin plugin, MavenProject project )\n    {\n\n        List pluginRepositories = project.getPluginArtifactRepositories();\n        Artifact artifact = factory.createPluginArtifact( plugin.getGroupId(), plugin.getArtifactId(), VersionRange\n            .createFromVersion( \"LATEST\" ) );\n\n        try\n        {\n            this.resolver.resolve( artifact, pluginRepositories, this.local );\n            plugin.setVersion( artifact.getVersion() );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n        }\n\n        return plugin;\n    }\n\n    /**\n     * Gets the plugins that are bound to the defined phases\n     * \n     * @param life\n     * @param project\n     * @return\n     * @throws PluginNotFoundException\n     * @throws LifecycleExecutionException\n     * @throws IllegalAccessException\n     */\n    protected Set getBoundPlugins ( LifecycleExecutor life, MavenProject project, String thePhases )\n        throws PluginNotFoundException, LifecycleExecutionException, IllegalAccessException\n    {\n        // I couldn't find a direct way to get at the\n        // lifecycles list.\n        lifecycles = (List) ReflectionUtils.getValueIncludingSuperclasses( \"lifecycles\", life );\n\n        Set allPlugins = new HashSet();\n\n        // lookup the bindings for all the passed in phases\n        String[] lifecyclePhases = thePhases.split( \",\" );\n        for ( int i = 0; i < lifecyclePhases.length; i++ )\n        {\n            String lifecyclePhase = lifecyclePhases[i];\n            if ( StringUtils.isNotEmpty( lifecyclePhase ) )\n            {\n                try\n                {\n                    Lifecycle lifecycle = getLifecycleForPhase( lifecyclePhase );\n                    allPlugins.addAll( getAllPlugins( project, lifecycle ) );\n                }\n                catch ( BuildFailureException e )\n                {\n                    // i'm going to swallow this because the\n                    // user may have declared a phase that\n                    // doesn't\n                    // exist for every module.\n                }\n            }\n        }\n        return allPlugins;\n    }\n\n    /*\n     * Checks to see if the version is specified for the\n     * plugin. Can optionally ban \"RELEASE\" or \"LATEST\" even\n     * if specified.\n     */\n    protected boolean hasVersionSpecified ( Plugin source, List plugins )\n    {\n        boolean status = false;\n        Iterator iter = plugins.iterator();\n        while ( iter.hasNext() )\n        {\n            // find the matching plugin entry\n            Plugin plugin = (Plugin) iter.next();\n            if ( source.getArtifactId().equals( plugin.getArtifactId() )\n                && source.getGroupId().equals( plugin.getGroupId() ) )\n            {\n                // found the entry. now see if the version\n                // is specified\n                if ( StringUtils.isNotEmpty( plugin.getVersion() ) )\n                {\n                    if ( banRelease && plugin.getVersion().equals( \"RELEASE\" ) )\n                    {\n                        return false;\n                    }\n\n                    if ( banLatest && plugin.getVersion().equals( \"LATEST\" ) )\n                    {\n                        return false;\n                    }\n\n                    if ( banSnapshots && isSnapshot( plugin.getVersion() ) )\n                    {\n                        return false;\n                    }\n                    // the version was specified and not\n                    // banned. It's ok.\n\n                    status = true;\n\n                    if ( !banRelease && !banLatest && !banSnapshots )\n                    {\n                        // no need to keep looking\n                        break;\n                    }\n                }\n            }\n        }\n        return status;\n    }\n\n    protected boolean isSnapshot ( String baseVersion )\n    {\n        return Artifact.VERSION_FILE_PATTERN.matcher( baseVersion ).matches() || baseVersion.endsWith( Artifact.SNAPSHOT_VERSION );\n    }\n\n    /*\n     * Uses borrowed lifecycle code to get a list of all\n     * plugins bound to the lifecycle.\n     */\n    private Set getAllPlugins ( MavenProject project, Lifecycle lifecycle )\n        throws PluginNotFoundException, LifecycleExecutionException\n\n    {\n        HashSet plugins = new HashSet();\n        // first, bind those associated with the packaging\n        Map mappings = findMappingsForLifecycle( project, lifecycle );\n\n        Iterator iter = mappings.entrySet().iterator();\n        while ( iter.hasNext() )\n        {\n            Entry entry = (Entry) iter.next();\n            String value = (String) entry.getValue();\n            String tokens[] = value.split( \":\" );\n\n            Plugin plugin = new Plugin();\n            plugin.setGroupId( tokens[0] );\n            plugin.setArtifactId( tokens[1] );\n            plugins.add( plugin );\n        }\n\n        List mojos = findOptionalMojosForLifecycle( project, lifecycle );\n        iter = mojos.iterator();\n        while ( iter.hasNext() )\n        {\n            String value = (String) iter.next();\n            String tokens[] = value.split( \":\" );\n\n            Plugin plugin = new Plugin();\n            plugin.setGroupId( tokens[0] );\n            plugin.setArtifactId( tokens[1] );\n            plugins.add( plugin );\n        }\n\n        for ( Iterator i = project.getBuildPlugins().iterator(); i.hasNext(); )\n        {\n            plugins.add( i.next() );\n        }\n\n        return plugins;\n    }\n\n    /*\n     * NOTE: All the code following this point was scooped\n     * from the DefaultLifecycleExecutor. There must be a\n     * better way but for now it should work.\n     * \n     */\n    public Map getPhaseToLifecycleMap ()\n        throws LifecycleExecutionException\n    {\n        if ( phaseToLifecycleMap == null )\n        {\n            phaseToLifecycleMap = new HashMap();\n\n            for ( Iterator i = lifecycles.iterator(); i.hasNext(); )\n            {\n                Lifecycle lifecycle = (Lifecycle) i.next();\n\n                for ( Iterator p = lifecycle.getPhases().iterator(); p.hasNext(); )\n                {\n                    String phase = (String) p.next();\n\n                    if ( phaseToLifecycleMap.containsKey( phase ) )\n                    {\n                        Lifecycle prevLifecycle = (Lifecycle) phaseToLifecycleMap.get( phase );\n                        throw new LifecycleExecutionException( \"Phase '\" + phase\n                            + \"' is defined in more than one lifecycle: '\" + lifecycle.getId() + \"' and '\"\n                            + prevLifecycle.getId() + \"'\" );\n                    }\n                    else\n                    {\n                        phaseToLifecycleMap.put( phase, lifecycle );\n                    }\n                }\n            }\n        }\n        return phaseToLifecycleMap;\n    }\n\n    private Lifecycle getLifecycleForPhase ( String phase )\n        throws BuildFailureException, LifecycleExecutionException\n    {\n        Lifecycle lifecycle = (Lifecycle) getPhaseToLifecycleMap().get( phase );\n\n        if ( lifecycle == null )\n        {\n            throw new BuildFailureException( \"Unable to find lifecycle for phase '\" + phase + \"'\" );\n        }\n        return lifecycle;\n    }\n\n    private Map findMappingsForLifecycle ( MavenProject project, Lifecycle lifecycle )\n        throws LifecycleExecutionException, PluginNotFoundException\n    {\n        String packaging = project.getPackaging();\n        Map mappings = null;\n\n        LifecycleMapping m = (LifecycleMapping) findExtension( project, LifecycleMapping.ROLE, packaging, session\n            .getSettings(), session.getLocalRepository() );\n        if ( m != null )\n        {\n            mappings = m.getPhases( lifecycle.getId() );\n        }\n\n        Map defaultMappings = lifecycle.getDefaultPhases();\n\n        if ( mappings == null )\n        {\n            try\n            {\n                m = (LifecycleMapping) session.lookup( LifecycleMapping.ROLE, packaging );\n                mappings = m.getPhases( lifecycle.getId() );\n            }\n            catch ( ComponentLookupException e )\n            {\n                if ( defaultMappings == null )\n                {\n                    throw new LifecycleExecutionException( \"Cannot find lifecycle mapping for packaging: \\'\"\n                        + packaging + \"\\'.\", e );\n                }\n            }\n        }\n\n        if ( mappings == null )\n        {\n            if ( defaultMappings == null )\n            {\n                throw new LifecycleExecutionException( \"Cannot find lifecycle mapping for packaging: \\'\" + packaging\n                    + \"\\', and there is no default\" );\n            }\n            else\n            {\n                mappings = defaultMappings;\n            }\n        }\n\n        return mappings;\n    }\n\n    private List findOptionalMojosForLifecycle ( MavenProject project, Lifecycle lifecycle )\n        throws LifecycleExecutionException, PluginNotFoundException\n    {\n        String packaging = project.getPackaging();\n        List optionalMojos = null;\n\n        LifecycleMapping m = (LifecycleMapping) findExtension( project, LifecycleMapping.ROLE, packaging, session\n            .getSettings(), session.getLocalRepository() );\n\n        if ( m != null )\n        {\n            optionalMojos = m.getOptionalMojos( lifecycle.getId() );\n        }\n\n        if ( optionalMojos == null )\n        {\n            try\n            {\n                m = (LifecycleMapping) session.lookup( LifecycleMapping.ROLE, packaging );\n                optionalMojos = m.getOptionalMojos( lifecycle.getId() );\n            }\n            catch ( ComponentLookupException e )\n            {\n                log.debug( \"Error looking up lifecycle mapping to retrieve optional mojos. Lifecycle ID: \"\n                    + lifecycle.getId() + \". Error: \" + e.getMessage(), e );\n            }\n        }\n\n        if ( optionalMojos == null )\n        {\n            optionalMojos = Collections.EMPTY_LIST;\n        }\n\n        return optionalMojos;\n    }\n\n    private Object findExtension ( MavenProject project, String role, String roleHint, Settings settings,\n                                   ArtifactRepository localRepository )\n        throws LifecycleExecutionException, PluginNotFoundException\n    {\n        Object pluginComponent = null;\n\n        for ( Iterator i = project.getBuildPlugins().iterator(); i.hasNext() && pluginComponent == null; )\n        {\n            Plugin plugin = (Plugin) i.next();\n\n            if ( plugin.isExtensions() )\n            {\n                verifyPlugin( plugin, project, settings, localRepository );\n\n                // TODO: if moved to the plugin manager we\n                // already have the descriptor from above\n                // and so do can lookup the container\n                // directly\n                try\n                {\n                    pluginComponent = pluginManager.getPluginComponent( plugin, role, roleHint );\n                }\n                catch ( ComponentLookupException e )\n                {\n                    log.debug( \"Unable to find the lifecycle component in the extension\", e );\n                }\n                catch ( PluginManagerException e )\n                {\n                    throw new LifecycleExecutionException( \"Error getting extensions from the plugin '\"\n                        + plugin.getKey() + \"': \" + e.getMessage(), e );\n                }\n            }\n        }\n        return pluginComponent;\n    }\n\n    private PluginDescriptor verifyPlugin ( Plugin plugin, MavenProject project, Settings settings,\n                                            ArtifactRepository localRepository )\n        throws LifecycleExecutionException, PluginNotFoundException\n    {\n        PluginDescriptor pluginDescriptor;\n        try\n        {\n            pluginDescriptor = pluginManager.verifyPlugin( plugin, project, settings, localRepository );\n        }\n        catch ( PluginManagerException e )\n        {\n            throw new LifecycleExecutionException( \"Internal error in the plugin manager getting plugin '\"\n                + plugin.getKey() + \"': \" + e.getMessage(), e );\n        }\n        catch ( PluginVersionResolutionException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( InvalidVersionSpecificationException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( InvalidPluginException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        catch ( PluginVersionNotFoundException e )\n        {\n            throw new LifecycleExecutionException( e.getMessage(), e );\n        }\n        return pluginDescriptor;\n    }\n\n    /**\n     * Gets all plugin entries in build.plugins or\n     * build.pluginManagement.plugins in this project and\n     * all parents\n     * \n     * @param project\n     * @return\n     * @throws ArtifactResolutionException\n     * @throws ArtifactNotFoundException\n     * @throws IOException\n     * @throws XmlPullParserException\n     */\n    protected List getAllPluginEntries ( MavenProject project )\n        throws ArtifactResolutionException, ArtifactNotFoundException, IOException, XmlPullParserException\n    {\n        List plugins = new ArrayList();\n        // get all the pom models\n        List models = utils.getModelsRecursively( project.getGroupId(), project.getArtifactId(), project.getVersion(),\n                                                  new File( project.getBasedir(), \"pom.xml\" ) );\n\n        // now find all the plugin entries, either in\n        // build.plugins or build.pluginManagement.plugins\n        Iterator iter = models.iterator();\n        while ( iter.hasNext() )\n        {\n            Model model = (Model) iter.next();\n            try\n            {\n                plugins.addAll( model.getBuild().getPlugins() );\n            }\n            catch ( NullPointerException e )\n            {\n                // guess there are no plugins here.\n            }\n\n            try\n            {\n                plugins.addAll( model.getBuild().getPluginManagement().getPlugins() );\n            }\n            catch ( NullPointerException e )\n            {\n                // guess there are no plugins here.\n            }\n        }\n\n        return plugins;\n    }\n\n    /**\n     * @return the banLatest\n     */\n    protected boolean isBanLatest ()\n    {\n        return this.banLatest;\n    }\n\n    /**\n     * @param theBanLatest the banLatest to set\n     */\n    protected void setBanLatest ( boolean theBanLatest )\n    {\n        this.banLatest = theBanLatest;\n    }\n\n    /**\n     * @return the banRelease\n     */\n    protected boolean isBanRelease ()\n    {\n        return this.banRelease;\n    }\n\n    /**\n     * @param theBanRelease the banRelease to set\n     */\n    protected void setBanRelease ( boolean theBanRelease )\n    {\n        this.banRelease = theBanRelease;\n    }\n\n    /**\n     * @return the message\n     */\n    protected String getMessage ()\n    {\n        return this.message;\n    }\n\n    /**\n     * @param theMessage the message to set\n     */\n    protected void setMessage ( String theMessage )\n    {\n        this.message = theMessage;\n    }\n\n    /**\n     * @return the utils\n     */\n    protected EnforcerRuleUtils getUtils ()\n    {\n        return this.utils;\n    }\n\n    /**\n     * @param theUtils the utils to set\n     */\n    protected void setUtils ( EnforcerRuleUtils theUtils )\n    {\n        this.utils = theUtils;\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see org.apache.maven.enforcer.rule.api.EnforcerRule#getCacheId()\n     */\n    public String getCacheId ()\n    {\n        return \"0\";\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see org.apache.maven.enforcer.rule.api.EnforcerRule#isCacheable()\n     */\n    public boolean isCacheable ()\n    {\n        return false;\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see org.apache.maven.enforcer.rule.api.EnforcerRule#isResultValid(org.apache.maven.enforcer.rule.api.EnforcerRule)\n     */\n    public boolean isResultValid ( EnforcerRule theCachedRule )\n    {\n        return false;\n    }\n\n    /**\n     * @return the banSnapshots\n     */\n    public boolean isBanSnapshots ()\n    {\n        return this.banSnapshots;\n    }\n\n    /**\n     * @param theBanSnapshots the banSnapshots to set\n     */\n    public void setBanSnapshots ( boolean theBanSnapshots )\n    {\n        this.banSnapshots = theBanSnapshots;\n    }\n}\n","lineNo":487}
