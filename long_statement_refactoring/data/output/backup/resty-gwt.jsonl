{"Refactored Sample":"/**\n * Copyright (C) 2009-2011 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\nimport java.lang.annotation.Annotation;\n\nimport org.fusesource.restygwt.client.RestService;\nimport org.fusesource.restygwt.rebind.util.AnnotationCopyUtil;\nimport org.fusesource.restygwt.rebind.util.AnnotationUtils;\nimport org.fusesource.restygwt.rebind.util.OnceFirstIterator;\n\n/**\n * @author <a href=\"mailto:bogdan.mustiata@gmail.com\">Bogdan Mustiata<\/a>\n */\npublic class DirectRestServiceInterfaceClassCreator extends DirectRestBaseSourceCreator {\n    public static final String DIRECT_REST_SERVICE_SUFFIX = \"_DirectRestService\";\n\n    public DirectRestServiceInterfaceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, DIRECT_REST_SERVICE_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() throws UnableToCompleteException {\n        Annotation[] annotations = AnnotationUtils.getAnnotationsInTypeHierarchy(source);\n        return createClassSourceComposerFactory(JavaSourceCategory.INTERFACE, getAnnotationsAsStringArray(annotations),\n            new String[] { RestService.class.getCanonicalName() });\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n        super.generate();\n\n        for (JMethod method : source.getInheritableMethods()) {\n            Annotation[] supportedAnnotations = AnnotationUtils.findSupportedAnnotations(method.getAnnotations());\n            p(getAnnotationsAsString(supportedAnnotations));\n            p(\"void \" + method.getName() + \"(\" + getMethodParameters(method) + getMethodCallback(method) + \");\");\n        }\n    }\n\n    private String getMethodParameters(JMethod method) {\n        StringBuilder result = new StringBuilder(\"\");\n\n        for (JParameter parameter : method.getParameters()) {\n            Annotation[] supportedAnnotations = AnnotationUtils.findSupportedAnnotations(parameter.getAnnotations());\n            result.append(getAnnotationsAsString(supportedAnnotations)).append(\" \")\n                .append(parameter.getType().getParameterizedQualifiedSourceName()).append(\" \")\n                .append(parameter.getName()).append(\", \");\n        }\n\n        return result.toString();\n    }\n\n    private String getMethodCallback(JMethod method) {\n        if (method.getReturnType().isPrimitive() != null) {\n            JPrimitiveType primitiveType = method.getReturnType().isPrimitive();\n            return \"org.fusesource.restygwt.client.MethodCallback<\" + primitiveType.getQualifiedBoxedSourceName() +\n                \"> callback\";\n        }\n        String returnType = method.getReturnType().getParameterizedQualifiedSourceName();\n        if (isOverlayMethod(method)) {\n            return \"org.fusesource.restygwt.client.OverlayCallback<\" + returnType + \"> callback\";\n        }\n        return \"org.fusesource.restygwt.client.MethodCallback<\" + returnType + \"> callback\";\n    }\n\n    private String getAnnotationsAsString(Annotation[] annotations) {\n        StringBuilder result = new StringBuilder(\"\");\n        OnceFirstIterator<String> space = new OnceFirstIterator<String>(\"\", \" \");\n\n        for (String annotation : getAnnotationsAsStringArray(annotations)) {\n            result.append(space.next()).append(annotation);\n        }\n\n        return result.toString();\n    }\n\n    private String[] getAnnotationsAsStringArray(Annotation[] annotations) {\n        String[] result = new String[annotations.length];\n\n        for (int i = 0; i < annotations.length; i++) {\n            Annotation annotation = annotations[i];\n            result[i] = AnnotationCopyUtil.getAnnotationAsString(annotation);\n        }\n\n        return result;\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2011 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\nimport java.lang.annotation.Annotation;\n\nimport org.fusesource.restygwt.client.RestService;\nimport org.fusesource.restygwt.rebind.util.AnnotationCopyUtil;\nimport org.fusesource.restygwt.rebind.util.AnnotationUtils;\nimport org.fusesource.restygwt.rebind.util.OnceFirstIterator;\n\n/**\n * @author <a href=\"mailto:bogdan.mustiata@gmail.com\">Bogdan Mustiata<\/a>\n */\npublic class DirectRestServiceInterfaceClassCreator extends DirectRestBaseSourceCreator {\n    public static final String DIRECT_REST_SERVICE_SUFFIX = \"_DirectRestService\";\n\n    public DirectRestServiceInterfaceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, DIRECT_REST_SERVICE_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() throws UnableToCompleteException {\n        Annotation[] annotations = AnnotationUtils.getAnnotationsInTypeHierarchy(source);\n        return createClassSourceComposerFactory(JavaSourceCategory.INTERFACE, getAnnotationsAsStringArray(annotations),\n            new String[] { RestService.class.getCanonicalName() });\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n        super.generate();\n\n        for (JMethod method : source.getInheritableMethods()) {\n            p(getAnnotationsAsString(method.getAnnotations()));\n            p(\"void \" + method.getName() + \"(\" + getMethodParameters(method) + getMethodCallback(method) + \");\");\n        }\n    }\n\n    private String getMethodParameters(JMethod method) {\n        StringBuilder result = new StringBuilder(\"\");\n\n        for (JParameter parameter : method.getParameters()) {\n            result.append(getAnnotationsAsString(parameter.getAnnotations())).append(\" \")\n                .append(parameter.getType().getParameterizedQualifiedSourceName()).append(\" \")\n                .append(parameter.getName()).append(\", \");\n        }\n\n        return result.toString();\n    }\n\n    private String getMethodCallback(JMethod method) {\n        if (method.getReturnType().isPrimitive() != null) {\n            JPrimitiveType primitiveType = method.getReturnType().isPrimitive();\n            return \"org.fusesource.restygwt.client.MethodCallback<\" + primitiveType.getQualifiedBoxedSourceName() +\n                \"> callback\";\n        }\n        String returnType = method.getReturnType().getParameterizedQualifiedSourceName();\n        if (isOverlayMethod(method)) {\n            return \"org.fusesource.restygwt.client.OverlayCallback<\" + returnType + \"> callback\";\n        }\n        return \"org.fusesource.restygwt.client.MethodCallback<\" + returnType + \"> callback\";\n    }\n\n    private String getAnnotationsAsString(Annotation[] annotations) {\n        StringBuilder result = new StringBuilder(\"\");\n        OnceFirstIterator<String> space = new OnceFirstIterator<String>(\"\", \" \");\n\n        for (String annotation : getAnnotationsAsStringArray(annotations)) {\n            result.append(space.next()).append(annotation);\n        }\n\n        return result.toString();\n    }\n\n    private String[] getAnnotationsAsStringArray(Annotation[] annotations) {\n        String[] result = new String[annotations.length];\n\n        for (int i = 0; i < annotations.length; i++) {\n            Annotation annotation = annotations[i];\n            result[i] = AnnotationCopyUtil.getAnnotationAsString(annotation);\n        }\n\n        return result;\n    }\n}\n","lineNo":59}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2011 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\nimport java.lang.annotation.Annotation;\n\nimport org.fusesource.restygwt.client.RestService;\nimport org.fusesource.restygwt.rebind.util.AnnotationCopyUtil;\nimport org.fusesource.restygwt.rebind.util.AnnotationUtils;\nimport org.fusesource.restygwt.rebind.util.OnceFirstIterator;\n\n/**\n * @author <a href=\"mailto:bogdan.mustiata@gmail.com\">Bogdan Mustiata<\/a>\n */\npublic class DirectRestServiceInterfaceClassCreator extends DirectRestBaseSourceCreator {\n    public static final String DIRECT_REST_SERVICE_SUFFIX = \"_DirectRestService\";\n\n    public DirectRestServiceInterfaceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, DIRECT_REST_SERVICE_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() throws UnableToCompleteException {\n        Annotation[] annotations = AnnotationUtils.getAnnotationsInTypeHierarchy(source);\n        return createClassSourceComposerFactory(JavaSourceCategory.INTERFACE, getAnnotationsAsStringArray(annotations),\n            new String[] { RestService.class.getCanonicalName() });\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n        super.generate();\n\n        for (JMethod method : source.getInheritableMethods()) {\n            Annotation[] supportedAnnotations = AnnotationUtils.findSupportedAnnotations(method.getAnnotations());\n            p(getAnnotationsAsString(supportedAnnotations));\n            p(\"void \" + method.getName() + \"(\" + getMethodParameters(method) + getMethodCallback(method) + \");\");\n        }\n    }\n\n    private String getMethodParameters(JMethod method) {\n        StringBuilder result = new StringBuilder(\"\");\n\n        for (JParameter parameter : method.getParameters()) {\n            Annotation[] supportedAnnotations = AnnotationUtils.findSupportedAnnotations(parameter.getAnnotations());\n            result.append(getAnnotationsAsString(supportedAnnotations)).append(\" \")\n                .append(parameter.getType().getParameterizedQualifiedSourceName()).append(\" \")\n                .append(parameter.getName()).append(\", \");\n        }\n\n        return result.toString();\n    }\n\n    private String getMethodCallback(JMethod method) {\n        if (method.getReturnType().isPrimitive() != null) {\n            JPrimitiveType primitiveType = method.getReturnType().isPrimitive();\n            return \"org.fusesource.restygwt.client.MethodCallback<\" + primitiveType.getQualifiedBoxedSourceName() +\n                \"> callback\";\n        }\n        String returnType = method.getReturnType().getParameterizedQualifiedSourceName();\n        if (isOverlayMethod(method)) {\n            return \"org.fusesource.restygwt.client.OverlayCallback<\" + returnType + \"> callback\";\n        }\n        return \"org.fusesource.restygwt.client.MethodCallback<\" + returnType + \"> callback\";\n    }\n\n    private String getAnnotationsAsString(Annotation[] annotations) {\n        StringBuilder result = new StringBuilder(\"\");\n        OnceFirstIterator<String> space = new OnceFirstIterator<String>(\"\", \" \");\n\n        for (String annotation : getAnnotationsAsStringArray(annotations)) {\n            result.append(space.next()).append(annotation);\n        }\n\n        return result.toString();\n    }\n\n    private String[] getAnnotationsAsStringArray(Annotation[] annotations) {\n        String[] result = new String[annotations.length];\n\n        for (int i = 0; i < annotations.length; i++) {\n            Annotation annotation = annotations[i];\n            result[i] = AnnotationCopyUtil.getAnnotationAsString(annotation);\n        }\n\n        return result;\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2011 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\nimport java.lang.annotation.Annotation;\n\nimport org.fusesource.restygwt.client.RestService;\nimport org.fusesource.restygwt.rebind.util.AnnotationCopyUtil;\nimport org.fusesource.restygwt.rebind.util.AnnotationUtils;\nimport org.fusesource.restygwt.rebind.util.OnceFirstIterator;\n\n/**\n * @author <a href=\"mailto:bogdan.mustiata@gmail.com\">Bogdan Mustiata<\/a>\n */\npublic class DirectRestServiceInterfaceClassCreator extends DirectRestBaseSourceCreator {\n    public static final String DIRECT_REST_SERVICE_SUFFIX = \"_DirectRestService\";\n\n    public DirectRestServiceInterfaceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, DIRECT_REST_SERVICE_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() throws UnableToCompleteException {\n        Annotation[] annotations = AnnotationUtils.getAnnotationsInTypeHierarchy(source);\n        return createClassSourceComposerFactory(JavaSourceCategory.INTERFACE, getAnnotationsAsStringArray(annotations),\n            new String[] { RestService.class.getCanonicalName() });\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n        super.generate();\n\n        for (JMethod method : source.getInheritableMethods()) {\n            p(getAnnotationsAsString(method.getAnnotations()));\n            p(\"void \" + method.getName() + \"(\" + getMethodParameters(method) + getMethodCallback(method) + \");\");\n        }\n    }\n\n    private String getMethodParameters(JMethod method) {\n        StringBuilder result = new StringBuilder(\"\");\n\n        for (JParameter parameter : method.getParameters()) {\n            result.append(getAnnotationsAsString(parameter.getAnnotations())).append(\" \")\n                .append(parameter.getType().getParameterizedQualifiedSourceName()).append(\" \")\n                .append(parameter.getName()).append(\", \");\n        }\n\n        return result.toString();\n    }\n\n    private String getMethodCallback(JMethod method) {\n        if (method.getReturnType().isPrimitive() != null) {\n            JPrimitiveType primitiveType = method.getReturnType().isPrimitive();\n            return \"org.fusesource.restygwt.client.MethodCallback<\" + primitiveType.getQualifiedBoxedSourceName() +\n                \"> callback\";\n        }\n        String returnType = method.getReturnType().getParameterizedQualifiedSourceName();\n        if (isOverlayMethod(method)) {\n            return \"org.fusesource.restygwt.client.OverlayCallback<\" + returnType + \"> callback\";\n        }\n        return \"org.fusesource.restygwt.client.MethodCallback<\" + returnType + \"> callback\";\n    }\n\n    private String getAnnotationsAsString(Annotation[] annotations) {\n        StringBuilder result = new StringBuilder(\"\");\n        OnceFirstIterator<String> space = new OnceFirstIterator<String>(\"\", \" \");\n\n        for (String annotation : getAnnotationsAsStringArray(annotations)) {\n            result.append(space.next()).append(annotation);\n        }\n\n        return result.toString();\n    }\n\n    private String[] getAnnotationsAsStringArray(Annotation[] annotations) {\n        String[] result = new String[annotations.length];\n\n        for (int i = 0; i < annotations.length; i++) {\n            Annotation annotation = annotations[i];\n            result[i] = AnnotationCopyUtil.getAnnotationAsString(annotation);\n        }\n\n        return result;\n    }\n}\n","lineNo":69}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2011 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.fusesource.restygwt.rebind;\n\nimport java.lang.annotation.Annotation;\n\nimport org.fusesource.restygwt.client.RestService;\nimport org.fusesource.restygwt.client.TextCallback;\nimport org.fusesource.restygwt.rebind.util.AnnotationCopyUtil;\nimport org.fusesource.restygwt.rebind.util.AnnotationUtils;\nimport org.fusesource.restygwt.rebind.util.OnceFirstIterator;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n * @author <a href=\"mailto:bogdan.mustiata@gmail.com\">Bogdan Mustiata<\/a>\n */\npublic class DirectRestServiceInterfaceClassCreator extends DirectRestBaseSourceCreator {\n    public static final String DIRECT_REST_SERVICE_SUFFIX = \"_DirectRestService\";\n\n    public DirectRestServiceInterfaceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, DIRECT_REST_SERVICE_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() throws UnableToCompleteException {\n        Annotation[] annotations = AnnotationUtils.getAnnotationsInTypeHierarchy(source);\n        return createClassSourceComposerFactory(JavaSourceCategory.INTERFACE,\n                getAnnotationsAsStringArray(annotations),\n                new String[]{\n                        RestService.class.getCanonicalName()\n                }\n        );\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n        for (JMethod method : source.getInheritableMethods()) {\n            p(getAnnotationsAsString(method.getAnnotations()));\n            p(\"void \" + method.getName() + \"(\" + getMethodParameters(method) + getMethodCallback(method) + \");\");\n        }\n    }\n\n    private String getMethodParameters(JMethod method) {\n        StringBuilder result = new StringBuilder(\"\");\n\n        for (JParameter parameter : method.getParameters()) {\n            result.append(getAnnotationsAsString(parameter.getAnnotations()))\n                    .append(\" \")\n                    .append(parameter.getType().getParameterizedQualifiedSourceName())\n                    .append(\" \")\n                    .append(parameter.getName())\n                    .append(\", \");\n        }\n\n        return result.toString();\n    }\n\n    private String getMethodCallback(JMethod method) {\n        String callbackType;\n        JType returnType = method.getReturnType();\n        if (returnType.isPrimitive() != null) {\n            JPrimitiveType primitiveType = returnType.isPrimitive();\n            callbackType = \"org.fusesource.restygwt.client.MethodCallback<\" + primitiveType.getQualifiedBoxedSourceName() + \">\";\n        } else if (returnType.getQualifiedSourceName().equals(String.class.getName())) {\n            callbackType = TextCallback.class.getName();\n        } else {\n            callbackType = \"org.fusesource.restygwt.client.MethodCallback<\" + returnType.getParameterizedQualifiedSourceName() + \">\";\n        }\n        return callbackType + \" callback\";\n    }\n\n    private String getAnnotationsAsString(Annotation[] annotations) {\n        StringBuilder result = new StringBuilder(\"\");\n        OnceFirstIterator<String> space = new OnceFirstIterator<String>(\"\", \" \");\n\n        for (String annotation : getAnnotationsAsStringArray(annotations)) {\n            result.append(space.next()).append(annotation);\n        }\n\n        return result.toString();\n    }\n\n    private String[] getAnnotationsAsStringArray(Annotation[] annotations) {\n        String[] result = new String[annotations.length];\n\n        for (int i = 0; i < annotations.length; i++) {\n            Annotation annotation = annotations[i];\n            result[i] = AnnotationCopyUtil.getAnnotationAsString(annotation);\n        }\n\n        return result;\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2011 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.fusesource.restygwt.rebind;\n\nimport java.lang.annotation.Annotation;\n\nimport org.fusesource.restygwt.client.RestService;\nimport org.fusesource.restygwt.rebind.util.AnnotationCopyUtil;\nimport org.fusesource.restygwt.rebind.util.AnnotationUtils;\nimport org.fusesource.restygwt.rebind.util.OnceFirstIterator;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n * @author <a href=\"mailto:bogdan.mustiata@gmail.com\">Bogdan Mustiata<\/a>\n */\npublic class DirectRestServiceInterfaceClassCreator extends DirectRestBaseSourceCreator {\n    public static final String DIRECT_REST_SERVICE_SUFFIX = \"_DirectRestService\";\n\n    public DirectRestServiceInterfaceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, DIRECT_REST_SERVICE_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() throws UnableToCompleteException {\n        Annotation[] annotations = AnnotationUtils.getAnnotationsInTypeHierarchy(source);\n        return createClassSourceComposerFactory(JavaSourceCategory.INTERFACE,\n                getAnnotationsAsStringArray(annotations),\n                new String[]{\n                        RestService.class.getCanonicalName()\n                }\n        );\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n        for (JMethod method : source.getInheritableMethods()) {\n            p(getAnnotationsAsString(method.getAnnotations()));\n            p(\"void \" + method.getName() + \"(\" + getMethodParameters(method) + getMethodCallback(method) + \");\");\n        }\n    }\n\n    private String getMethodParameters(JMethod method) {\n        StringBuilder result = new StringBuilder(\"\");\n\n        for (JParameter parameter : method.getParameters()) {\n            result.append(getAnnotationsAsString(parameter.getAnnotations()))\n                    .append(\" \")\n                    .append(parameter.getType().getParameterizedQualifiedSourceName())\n                    .append(\" \")\n                    .append(parameter.getName())\n                    .append(\", \");\n        }\n\n        return result.toString();\n    }\n\n    private String getMethodCallback(JMethod method) {\n        if (method.getReturnType().isPrimitive() != null) {\n            JPrimitiveType primitiveType = method.getReturnType().isPrimitive();\n            return \"org.fusesource.restygwt.client.MethodCallback<\" + primitiveType.getQualifiedBoxedSourceName() + \"> callback\";\n        }\n        return \"org.fusesource.restygwt.client.MethodCallback<\" + method.getReturnType().getParameterizedQualifiedSourceName() + \"> callback\";\n    }\n\n    private String getAnnotationsAsString(Annotation[] annotations) {\n        StringBuilder result = new StringBuilder(\"\");\n        OnceFirstIterator<String> space = new OnceFirstIterator<String>(\"\", \" \");\n\n        for (String annotation : getAnnotationsAsStringArray(annotations)) {\n            result.append(space.next()).append(annotation);\n        }\n\n        return result.toString();\n    }\n\n    private String[] getAnnotationsAsStringArray(Annotation[] annotations) {\n        String[] result = new String[annotations.length];\n\n        for (int i = 0; i < annotations.length; i++) {\n            Annotation annotation = annotations[i];\n            result[i] = AnnotationCopyUtil.getAnnotationAsString(annotation);\n        }\n\n        return result;\n    }\n}\n","lineNo":84}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\nimport org.fusesource.restygwt.rebind.util.AnnotationUtils;\nimport static org.fusesource.restygwt.rebind.util.AnnotationUtils.*;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonSubTypes;\nimport com.fasterxml.jackson.annotation.JsonSubTypes.Type;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.As;\nimport com.fasterxml.jackson.annotation.JsonValue;\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.HasAnnotations;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JConstructor;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONNull;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONString;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.thirdparty.guava.common.collect.Lists;\nimport com.google.gwt.thirdparty.guava.common.collect.Maps;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport javax.xml.bind.annotation.XmlTransient;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added getter + setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n *\n *         added polymorphic support\n * @author <a href=\"http://charliemason.info\">Charlie Mason<\/a>\n *\n */\n\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private static final String USE_JAVA_BEANS_SPEC_NAMING_CONVENTION_CONFIGURATION_PROPERTY_NAME = \"restygwt.conventions.useJavaBeansSpecNaming\";\n\n    private String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n    protected static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_NULL_CLASS = JSONNull.class.getName();\n    protected static final String JSON_STRING_CLASS = JSONString.class.getName();\n\n    protected JsonEncoderDecoderInstanceLocator locator;\n\n    protected boolean javaBeansNamingConventionEnabled;\n\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n\n        // true, if the naming convention from JavaBeans API specification should be used\n        javaBeansNamingConventionEnabled = getBooleanProperty(getLogger(), context.getPropertyOracle(), USE_JAVA_BEANS_SPEC_NAMING_CONVENTION_CONFIGURATION_PROPERTY_NAME, true);\n    }\n\n    @Override\n    public void generate() throws UnableToCompleteException {\n        final JsonTypeInfo typeInfo = getClassAnnotation(source, JsonTypeInfo.class);\n        final boolean isLeaf = isLeaf(source);\n\n        final List<Subtype> possibleTypes = getPossibleTypes(typeInfo, isLeaf);\n        Collections.sort(possibleTypes);\n\n        final JClassType sourceClazz = source.isClass() == null ? source.isInterface() : source.isClass();\n        if (sourceClazz == null) {\n            getLogger().log(ERROR, \"Type is not a class\");\n            throw new UnableToCompleteException();\n        }\n\n\t\tif (sourceClazz.isEnum() == null && sourceClazz.isAbstract()) {\n            if (typeInfo == null) {\n                getLogger().log(ERROR, \"Abstract classes must be annotated with JsonTypeInfo\");\n                throw new UnableToCompleteException();\n            }\n        }\n        Json jsonAnnotation = getAnnotation(source, Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n        final String railsWrapperName = jsonAnnotation != null && jsonAnnotation.name().length() > 0 ? jsonAnnotation.name() : sourceClazz.getName().toLowerCase();\n        locator = new JsonEncoderDecoderInstanceLocator(context, getLogger());\n\n        generateSingleton(shortName);\n\n        generateEncodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n\n        generateDecodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n\tClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n\tcomposerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n\treturn composerFactory;\n    }\n\n    private List<Subtype> getPossibleTypes(final JsonTypeInfo typeInfo, final boolean isLeaf) throws UnableToCompleteException\n    {\n        if (typeInfo == null)\n            return Lists.newArrayList(new Subtype(null, source));\n        Collection<Type> subTypes = findJsonSubTypes(source);\n        if(subTypes.isEmpty()) {\n            JsonSubTypes foundAnnotation = getAnnotation(source, JsonSubTypes.class);\n            if(foundAnnotation != null) {\n                Type[] value = foundAnnotation.value();\n                subTypes = Arrays.asList(value);\n            }\n        }\n        PossibleTypesVisitor v = new PossibleTypesVisitor(context, source, isLeaf, getLogger(), subTypes);\n        return v.visit(typeInfo.use());\n    }\n\n    /**\n     * This method does NOT return the subtypes of the given class, but all the subtypes associated with the\n     * {@link com.fasterxml.jackson.annotation.JsonSubTypes} annotation, even if this annotation is assigned to\n     * a parent class or an interface.\n     */\n    private Collection<Type> findJsonSubTypes(JClassType clazz) {\n        return findJsonSubTypes(clazz, new HashSet<JsonSubTypes.Type>());\n    }\n    \n    private Collection<Type> findJsonSubTypes(JClassType clazz, Set<Type> types) {\n        if (clazz == null) {\n            return Collections.emptyList();\n        }\n        JsonSubTypes annotation = getClassAnnotation(clazz, JsonSubTypes.class);\n            \n        if (annotation == null) {\n            return Collections.emptyList();\n        }\n\n        for (Type type : annotation.value()) {\n            if (types.add(type)) {\n                Class<?> subclazz = type.value();\n                String newSubClassName = subclazz.getName().replaceAll(\"\\\\$\", \".\");\n                JClassType subJClazz = context.getTypeOracle().findType(newSubClassName);\n                findJsonSubTypes(subJClazz, types);\n            }\n        }\n\n        return types;\n    }\n\n    protected void generateSingleton(String shortName)\n    {\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n    }\n\n    private void generateEncodeMethod(JClassType classType,\n            final Style classStyle,\n            JsonTypeInfo typeInfo,\n            String railsWrapperName,\n            List<Subtype> possibleTypes,\n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {\n            generateEnumEncodeMethod(classType, JSON_VALUE_CLASS);\n            return;\n        }\n\n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return getNullType();\");\n            }\n            i(-1).p(\"}\");\n\n            boolean returnWrapper = false; // if set, return rrc\n\n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n            if (classStyle == Style.RAILS) {\n                returnWrapper = true;\n                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                p(\"rrc.put(\\\"\" + railsWrapperName + \"\\\" , rc);\");\n            }\n\n            for (Subtype possibleType : possibleTypes) {\n\n                if (!possibleType.clazz.isAssignableTo(classType)) {\n                    getLogger().log(DEBUG, \"Only assignable classes are allowed: \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" is not assignable to: \" + classType.getParameterizedQualifiedSourceName());\n                    continue;\n                }\n                \n                if (!isLeaf) {\n                    // Generate a decoder for each possible type\n                    p(\"if(value.getClass().getName().equals(\\\"\" + possibleType.clazz.getQualifiedBinaryName() + \"\\\"))\");\n                    p(\"{\");\n                }\n\n                if (possibleType.clazz.isEnum() != null) {\n                    generateEnumEncodeMethodBody(possibleType, typeInfo);\n                } else {\n\n                    // Try to find a constructor that is annotated as creator\n                    final JConstructor creator = findCreator(possibleType.clazz);\n                    final List<JField> fields = getFields(possibleType.clazz);\n\n                    List<JField> orderedFields = creator == null ? null : getOrderedFields(fields, creator);\n\n                    if (typeInfo != null) {\n                        switch (typeInfo.include()) {\n                            case PROPERTY:\n                                p(\"com.google.gwt.json.client.JSONValue className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\");\");\n                                p(\"if( className!=null ) { \").i(1);\n                                p(\"rc.put(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \", className);\");\n                                i(-1).p(\"}\");\n                                break;\n                            case WRAPPER_OBJECT:\n                                returnWrapper = true;\n                                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                                p(\"rrc.put(\\\"\" + possibleType.tag + \"\\\", rc);\");\n                                break;\n                            case WRAPPER_ARRAY:\n                                returnWrapper = true;\n                                p(JSON_ARRAY_CLASS + \" rrc = new \" + JSON_ARRAY_CLASS + \"();\");\n                                p(\"rrc.set(0, org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\"));\");\n                                p(\"rrc.set(1, rc);\");\n                                break;\n                            case EXISTING_PROPERTY:\n                                getLogger().log(WARN, classType + \" comes with not implemented type info 'as' \" + JsonTypeInfo.As.EXISTING_PROPERTY );\n                                // not implemented\n                                break;\n                            case EXTERNAL_PROPERTY:\n                                getLogger().log(WARN, classType + \" comes with not implemented type info 'as' \" + JsonTypeInfo.As.EXTERNAL_PROPERTY );\n                                // not implemented\n                                break;\n                            default:\n                        }\n                    }\n\n                    p(possibleType.clazz.getParameterizedQualifiedSourceName() + \" parseValue = (\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \")value;\");\n\n                    for (final JField field : fields) {\n\n                        final String getterName = getGetterName(possibleType.clazz, field);\n\n                        boolean ignoreField = false;\n                        if(getAnnotation(possibleType.clazz, JsonIgnoreProperties.class) != null) {\n                            for(String s : getAnnotation(possibleType.clazz, JsonIgnoreProperties.class).value()) {\n                                if(s.equals(field.getName())) {\n                                    ignoreField = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        // If can ignore some fields right off the back..\n                        // if there is a creator encode only final fields with JsonProperty annotation\n                        if (ignoreField || getterName == null && (field.isStatic() || (field.isFinal() && !(creator != null && orderedFields.contains(field))) || field.isTransient()\n\t\t\t\t\t\t\t\t|| isIgnored(field))) {\n                            continue;\n                        }\n\n                        branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                            @Override\n                            public Void execute() throws UnableToCompleteException {\n                                // TODO: try to get the field with a setter or\n                                // JSNI\n                                if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                                    Json jsonAnnotation = getAnnotation(field, Json.class);\n                                    JsonProperty jsonPropertyAnnotation = getAnnotation(field, JsonProperty.class);\n\n                                    String name = field.getName();\n                                    String jsonName = name;\n\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                                        jsonName = jsonPropertyAnnotation.value();\n                                    }\n\n                                    String fieldExpr = \"parseValue.\" + name;\n                                    if (getterName != null) {\n                                        fieldExpr = \"parseValue.\" + getterName + \"()\";\n                                    }\n\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    String expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n\n                                    \n                                    if (null != field.getType().isEnum()) {\n                                    \tp(\"if(isNotNullAndCheckDefaults(\" + fieldExpr+ \", rc, \"+ wrap(jsonName) + \")) {\").i(1);\n                                    }\n                                        \n                                    p(\"isNotNullValuePut(\" + expression + \", rc, \"+ wrap(jsonName) + \");\");\n\n                                    if (null != field.getType().isEnum()) {\n                                    \ti(-1).p(\"}\");\n                                    }\n                                    \n\n                                } else {\n                                    getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                                }\n                                return null;\n                            }\n                        });\n\n                    }\n\n                    if (returnWrapper) {\n                        p(\"return rrc;\");\n                    } else {\n                        p(\"return rc;\");\n                    }\n                }\n                if (!isLeaf) {\n                    p(\"}\");\n                }\n            }\n\n            if (!isLeaf) {\n                // Shouldn't get called\n                p(\"return null;\");\n            }\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n\n    private void generateEnumEncodeMethodBody(final Subtype possibleType, final JsonTypeInfo typeInfo) {\n        p(\"if( value==null ) {\").i(1);\n        {\n            p(\"return \" + JSON_NULL_CLASS + \".getInstance();\").i(-1);\n        }\n        p(\"}\");\n        p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n        p(JSON_VALUE_CLASS + \" className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\"\n                + possibleType.tag + \"\\\");\");\n        p(\"rrc.put(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \", className);\");\n        p(\"rrc.put(\\\"name\\\", new \" + JSON_STRING_CLASS + \"(value.\" + getValueMethod(possibleType.clazz) + \"()));\");\n        p(\"return rrc;\");\n    }\n\n    private void generateEnumEncodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + jsonValueClass + \" encode(\" + classType.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return \" + JSON_NULL_CLASS + \".getInstance();\").i(-1);\n            }\n            p(\"}\");\n            p(\"return new \" + JSON_STRING_CLASS + \"(value.\" + getValueMethod(classType) + \"());\");\n            i(-1).p(\"}\");\n        }\n        p();\n    }\n\n    protected String getValueMethod(JClassType classType) {\n        String method = \"name\";\n        for(JMethod jm : classType.isEnum().getMethods() ) {\n            if (jm.isAnnotationPresent(JsonValue.class)) {\n                method = jm.getName();\n                break;\n            }\n        }\n        return method;\n    }\n\n    private void generateDecodeMethod(JClassType classType,\n            final Style classStyle,\n            JsonTypeInfo typeInfo,\n            String railsWrapperName,\n            List<Subtype> possibleTypes,\n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {\n            generateEnumDecodeMethod(classType, JSON_VALUE_CLASS);\n            return;\n        }\n\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n            {\n                p(\"return null;\").i(-1);\n            }\n            p(\"}\");\n            if (classStyle == Style.RAILS) {\n                p(JSON_OBJECT_CLASS + \" object = toObjectFromWrapper(value, \\\"\" + railsWrapperName + \"\\\");\");\n            } else if (typeInfo != null && typeInfo.include() == As.WRAPPER_ARRAY) {\n                p(JSON_ARRAY_CLASS + \" array = (\" + JSON_ARRAY_CLASS + \")value;\");\n                if (!isLeaf)\n                    p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(array.get(0));\");\n                p(JSON_OBJECT_CLASS + \" object = toObject(array.get(1));\");\n            } else {\n                p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            }\n\n            if (!isLeaf && typeInfo != null && typeInfo.include() == As.PROPERTY) {\n                p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \"));\");\n            }\n\n            for (Subtype possibleType : possibleTypes) {\n\n                if (!possibleType.clazz.isAssignableTo(classType)) {\n                    getLogger().log(DEBUG, \"Only assignable classes are allowed: \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" is not assignable to: \" + classType.getParameterizedQualifiedSourceName());\n                    continue;\n                }\n\n                if (typeInfo != null) {\n                    if (typeInfo.include() == As.WRAPPER_OBJECT) {\n                        if (!isLeaf) {\n                            p(\"if(object.containsKey(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        }\n                        p(\"object = toObjectFromWrapper(value, \\\"\" + possibleType.tag + \"\\\");\");\n                    } else if (!isLeaf) {\n                        if (classType.equals(possibleType.clazz)) {\n                            p(\"if(sourceName == null || sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        } else {\n                            p(\"if(sourceName != null && sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        }\n                    }\n                }\n\n                if (possibleType.clazz.isEnum() != null) {\n                    generateEnumDecodeMethodBody(possibleType.clazz);\n                } else {\n                    // Try to find a constuctor that is annotated as creator\n                    final JConstructor creator = findCreator(possibleType.clazz);\n\n                    List<JField> orderedFields = null;\n                    if (creator != null) {\n                        p(\"// We found a creator so we use the annotated constructor\");\n                        p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"(\");\n                        i(1).p(\"// The arguments are placed in the order they appear within the annotated constructor\").i(-1);\n                        orderedFields = getOrderedFields(getFields(possibleType.clazz), creator);\n                        final JField lastField = orderedFields.get(orderedFields.size() - 1);\n                        for (final JField field : orderedFields) {\n                            branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                                @Override\n                                public Void execute() throws UnableToCompleteException {\n                                    Json jsonAnnotation = getAnnotation(field, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    String jsonName = field.getName();\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                    String defaultValue = getDefaultValue(field);\n                                    i(1).p(\"\" + (objectGetter + \" == null || \" + objectGetter + \" instanceof \" + JSON_NULL_CLASS + \" ? \" + defaultValue + \" : \" + expression + ((field != lastField) ? \", \" : \"\"))).i(-1);\n\n                                    return null;\n                                }\n                            });\n                        }\n                        p(\");\");\n                    }\n\n                    if (orderedFields == null){\n                        p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"();\");\n                    }\n\n                    for (final JField field : getFields(possibleType.clazz)) {\n\n                        boolean ignoreField = false;\n                        if(getAnnotation(possibleType.clazz, JsonIgnoreProperties.class) != null) {\n                            for(String s : getAnnotation(possibleType.clazz, JsonIgnoreProperties.class).value()) {\n                                if(s.equals(field.getName())) {\n                                    ignoreField = true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(ignoreField) {\n                            continue;\n                        }\n\n                        if (orderedFields != null && orderedFields.contains(field)){\n                            continue;\n                        }\n\n                        final String setterName = getSetterName(field);\n\n                        // If can ignore some fields right off the back..\n                        if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient()) || isIgnored(field)) {\n                            continue;\n                        }\n\n                        branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                            @Override\n                            public Void execute() throws UnableToCompleteException {\n\n                                // TODO: try to set the field with a setter\n                                // or JSNI\n                                if (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                                    Json jsonAnnotation = getAnnotation(field, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    JsonProperty jsonPropertyAnnotation = getAnnotation(field, JsonProperty.class);\n\n                                    String name = field.getName();\n                                    String jsonName = name;\n\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                                        jsonName = jsonPropertyAnnotation.value();\n                                    }\n\n                                    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                    boolean isShort = field.getType().isPrimitive() == JPrimitiveType.SHORT;\n                                    String defaultValue = getDefaultValue(field);\n\n                                    String methodName = isShort ? \"getValueToSetForShort\" : \"getValueToSet\";\n                                    \n                                    if (setterName != null) {\n                                    \tp(\"rc.\" + setterName + \"(\"  + methodName + \"(\" + expression + \", \" + defaultValue + \"));\");\n                                    } else {\n                                    \tp(\"rc.\" + name + \"= \" +  methodName + \"(\" + expression + \",\" + defaultValue + \");\");\n                                    }\n                                    \n                                } else {\n                                    getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                                }\n                                return null;\n                            }\n                        });\n                    }\n\n                    p(\"return rc;\");\n                }\n                if (typeInfo != null && !isLeaf) {\n                    p(\"}\");\n                }\n            }\n\n            if (typeInfo != null && !isLeaf) {\n                p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n            p();\n        }\n    }\n\n    private void generateEnumDecodeMethodBody(JClassType classType) {\n        p(JSON_VALUE_CLASS + \" str = object.get(\\\"name\\\");\");\n        p(\"if( null == str || str.isString() == null ) {\").i(1);\n        {\n            p(\"throw new DecodingException(\\\"Expected a string field called 'name' for enum; not found\\\");\").i(-1);\n        }\n        p(\"}\");\n        decodeEnum(classType, \"str.isString().stringValue()\");\n    }\n\n    private String getDefaultValue(JField field) {\n        return field.getType().isPrimitive() == null ? \"null\" : field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n    }\n\n    protected void generateEnumDecodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + classType.getName() + \" decode(\" + jsonValueClass + \" value) {\").i(1);\n        {\n        p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n        {\n            p(\"return null;\").i(-1);\n        }\n        p(\"}\");\n        p(JSON_STRING_CLASS + \" str = value.isString();\");\n        p(\"if( null == str ) {\").i(1);\n        {\n            p(\"throw new DecodingException(\\\"Expected a json string (for enum), but was given: \\\"+value);\").i(-1);\n        }\n        p(\"}\");\n\n        String value = \"str.stringValue()\";\n        decodeEnum(classType, value);\n        }\n        p(\"}\");\n        p();\n    }\n\n    protected void decodeEnum(JClassType classType, String value) {\n        String className = classType.getParameterizedQualifiedSourceName();\n        String method = getValueMethod(classType);\n        if ( method == null ) {\n            p(\"return Enum.valueOf(\" + className + \".class, \" + value + \");\").i(-1);\n        }\n        else {\n            p(\"for(\" + className + \" v: \" + className + \".values()) {\").i(1);\n            {\n                p(\"if(v.\" + method + \"().equals(\" + value + \")) {\").i(1);\n                {\n                    p(\"return v;\").i(-1);\n                }\n                p(\"}\").i(-1);\n            }\n            p(\"}\");\n            p(\"throw new DecodingException(\\\"can not find enum for given value: \\\"+\" + value + \");\").i(-1);\n        }\n    }\n\n    static public void clearRestyResolverClassMap() {\n    \tsTypeIdResolverMap = null;\n    }\n    \n    public static Map<Class<?>, RestyJsonTypeIdResolver> getRestyResolverClassMap(GeneratorContext context, TreeLogger logger) throws UnableToCompleteException {\n\tif (sTypeIdResolverMap == null) {\n\t    try {\n\t\tMap<Class<?>, RestyJsonTypeIdResolver> map = Maps.newHashMap();\n\t\tList<String> values = context.getPropertyOracle().getConfigurationProperty(\"org.fusesource.restygwt.jsontypeidresolver\").getValues();\n\t\tfor (String value : values)\n\t\t    try {\n\t\t\tClass<?> clazz = Class.forName(value);\n\t\t\tRestyJsonTypeIdResolver resolver = (RestyJsonTypeIdResolver) clazz.newInstance();\n\t\t\tmap.put(resolver.getTypeIdResolverClass(), resolver);\n\t\t    } catch (Exception e) {\n\t\t\tlogger.log(WARN, \"Could not access class: \" + values.get(0), e);\n\t\t    }\n\t\t    sTypeIdResolverMap = map;\n\t    } catch (BadPropertyValueException e) {\n\t\tlogger.log(ERROR, \"Could not acccess property: RestyJsonTypeIdResolver\", e);\n\t\tthrow new UnableToCompleteException();\n\t    }\n\t}\n\treturn sTypeIdResolverMap;\n    }\n\n    private List<JField> getOrderedFields(List<JField> fields, JConstructor creator) throws UnableToCompleteException {\n\tList<JField> orderedFields = new ArrayList<JField>();\n\tfor (JParameter param : creator.getParameters()) {\n\t    JsonProperty prop = getAnnotation(param, JsonProperty.class);\n\t    if (prop != null) {\n\t\tfor (JField field : fields) {\n\t\t    if (field.getName().equals(prop.value())) {\n\t\t\torderedFields.add(field);\n\t\t    }\n\t\t}\n\t    } else {\n\t\tgetLogger().log(ERROR, \"a constructor annotated with @JsonCreator requires that all paramaters are annotated with @JsonProperty.\");\n        throw new UnableToCompleteException();\n\t    }\n\t}\n\n\treturn orderedFields;\n    }\n\n    private JConstructor findCreator(JClassType sourceClazz) {\n\tfor (JConstructor constructor : sourceClazz.getConstructors()) {\n\t    if (getAnnotation(constructor, JsonCreator.class) != null) {\n\t\treturn constructor;\n\t    }\n\t}\n\n\treturn null;\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the setter for the specified field or null if a\n     *         setter can't be found.\n     */\n    private String getSetterName(JField field) {\n        String fieldName = \"set\" + getMiddleNameForPrefixingAsAccessorMutator(field.getName());\n        JClassType type = field.getEnclosingType();\n        if (exists(type, field, fieldName, true)) {\n            return fieldName;\n        }\n        return null;\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the getter for the specified field or null if a\n     *         getter can't be found.\n     */\n    private String getGetterName(JClassType type, JField field) {\n        final String methodBaseName = getMiddleNameForPrefixingAsAccessorMutator(field.getName());\n        String fieldName = null;\n        JType booleanType = null;\n        try {\n            booleanType = find(Boolean.class, getLogger(), context);\n        } catch (UnableToCompleteException e) {\n            // do nothing\n        }\n        if (field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)) {\n            if (field instanceof DummyJField) {\n                return ((DummyJField) field).getGetterMethod().getName();\n            }\n            fieldName = \"is\" + methodBaseName;\n            if (exists(type, field, fieldName, false)) {\n                return fieldName;\n            }\n            fieldName = \"has\" + methodBaseName;\n            if (exists(type, field, fieldName, false)) {\n                return fieldName;\n            }\n        }\n        fieldName = \"get\" + methodBaseName;\n        if (exists(type, field, fieldName, false)) {\n            return fieldName;\n        }\n        return null;\n    }\n\n    private String getMiddleNameForPrefixingAsAccessorMutator(String fieldName) {\n        if (javaBeansNamingConventionEnabled) {\n            return getMiddleNameForPrefixingAsAccessorMutatorJavaBeansSpecCompliance(fieldName);\n        }\n        return upperCaseFirstChar(fieldName);\n    }\n\n    /**\n     * Get the middle part of the method name in compliance with the naming convention in the JavaBeans API specification.\n     * \n     * @param fieldName\n     * @return\n     */\n    static String getMiddleNameForPrefixingAsAccessorMutatorJavaBeansSpecCompliance(String fieldName) {\n        if (fieldName.length() > 1 && Character.isUpperCase(fieldName.charAt(1))) {\n            return fieldName;\n        }\n        return fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);\n    }\n\n    private String upperCaseFirstChar(String in) {\n        if (in.length() == 1) {\n            return in.toUpperCase();\n        }\n        return in.substring(0, 1).toUpperCase() + in.substring(1);\n    }\n    \n    /**\n     * Checks if hasAnnotations should be ignored based on JsonIgnore and XmlTransient\n     *  \n     * @param hasAnnotations\n     * @return true if hasAnnotations should be ignored\n     * @see #isJsonIgnored(HasAnnotations)\n     * @see #isXmlTransient(HasAnnotations)\n     */\n    private boolean isIgnored(HasAnnotations hasAnnotations) {\n        return isJsonIgnored(hasAnnotations) || isXmlTransient(hasAnnotations);\n    }\n    \n    /**\n     * @param hasAnnotations\n     * @return true if hasAnnotations is annotated with @JsonIgnore and its value is true\n     * @see AnnotationUtils#getAnnotation(HasAnnotations, Class)\n     */\n    private boolean isJsonIgnored(HasAnnotations hasAnnotations) {\n        return isJsonIgnored(getAnnotation(hasAnnotations, JsonIgnore.class));\n    }\n    \n    /**\n     * @param jsonIgnore\n     * @return true if jsonIgnore.value() is true\n     */\n    private boolean isJsonIgnored(JsonIgnore jsonIgnore) {\n        return jsonIgnore != null && jsonIgnore.value();\n    }\n    \n    /**\n     * @param hasAnnotations\n     * @return true of hasAnnotations is annotated with XmlTransient\n     * @see AnnotationUtils#getAnnotation(HasAnnotations, Class)\n     */\n    private boolean isXmlTransient(HasAnnotations hasAnnotations) {\n        return getAnnotation(hasAnnotations, XmlTransient.class) != null;\n    }\n\n    /**\n     * checks whether a getter or setter exists on the specified type or any of\n     * its super classes excluding Object. respects JsonIgnore accordingly.\n     *\n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {\n        if ( field instanceof DummyJField ){\n               return true; \n        }\n\n\tJType[] args = null;\n\tif (isSetter) {\n\t    args = new JType[] { field.getType() };\n\t} else {\n\t    args = new JType[] {};\n\t}\n\tJMethod m = type.findMethod(fieldName, args);\n\tif (null != m) {\n\t    if (isIgnored(m))\n\t        return false;\n        if(isSetter)\n            return true;\n        JClassType returnType = m.getReturnType().isClassOrInterface();\n        JClassType fieldType = field.getType().isClassOrInterface();\n        if(returnType == null || fieldType == null) {\n            // at least one is a primitive type\n            return m.getReturnType().equals(field.getType());\n        }\n        // both are non-primitives\n        return returnType.isAssignableFrom(fieldType);\n\t}\n    try {\n    JType objectType = find(Object.class, getLogger(), context);\n    JClassType superType = type.getSuperclass();\n    if (!objectType.equals(superType)) {\n        return exists(superType, field, fieldName, isSetter);\n    }\n    } catch (UnableToCompleteException e) {\n    // do nothing\n    }\n\treturn false;\n    }\n\n    /**\n     * Get {@link JsonProperty} from getter or setter. Annotation from setter is preferred to getter.\n     *\n     * @param getter\n     * @param setter\n     * @return\n     */\n    private JsonProperty getJsonPropertyFromGetterSetter(JMethod getter, JMethod setter) {\n        JsonProperty setterProp = getAnnotation(setter, JsonProperty.class);\n        return (null != setterProp)?setterProp:getAnnotation(getter, JsonProperty.class);\n    }\n\n    /**\n     * Inspects the supplied type and all super classes up to but excluding\n     * Object and returns a list of all fields found in these classes.\n     *\n     * @param type\n     * @return\n     */\n    private List<JField> getFields(JClassType type) {\n        List<JField> allFields = getFields(new ArrayList<JField>(), type);\n        Map<String, JMethod> getters = new HashMap<String, JMethod>();\n        Map<String, JMethod> setters = new HashMap<String, JMethod>();\n\n        JType booleanType = null;\n        try {\n            booleanType = find(Boolean.class, getLogger(), context);\n        } catch (UnableToCompleteException e) {\n            // do nothing\n        }\n        for( JMethod m: type.getInheritableMethods() ){\n            if( m.getName().startsWith(\"set\") &&\n                    m.getParameterTypes().length == 1 &&\n                    m.getReturnType() == JPrimitiveType.VOID &&\n                    !isIgnored(m)) {\n                setters.put( m.getName().substring(\"set\".length()), m );\n            }\n            else if( m.getName().startsWith(\"get\") &&\n                    m.getParameterTypes().length == 0 &&\n                    m.getReturnType() != JPrimitiveType.VOID &&\n                    !isIgnored(m)) {\n                getters.put( m.getName().substring(\"get\".length()), m );\n            }\n            else if( m.getName().startsWith(\"is\") &&\n                    m.getParameterTypes().length == 0 &&\n                    ( m.getReturnType() == JPrimitiveType.BOOLEAN || m.getReturnType().equals(booleanType) ) &&\n                    !isIgnored(m)) {\n                getters.put( m.getName().substring(\"is\".length()), m );\n            }\n            else if( m.getName().startsWith(\"has\") &&\n                    m.getParameterTypes().length == 0 &&\n                    ( m.getReturnType() == JPrimitiveType.BOOLEAN || m.getReturnType().equals(booleanType) ) &&\n                    !isIgnored(m)) {\n                getters.put( m.getName().substring(\"has\".length()), m );\n            }\n        }\n        for (Map.Entry<String, JMethod> entry : getters.entrySet()) {\n            final JMethod getter = entry.getValue();\n            final JMethod setter = setters.get(entry.getKey());\n\n            if (null != setter && setter.getParameterTypes()[0].equals(getter.getReturnType())) {\n                String name = entry.getKey().substring(0, 1).toLowerCase() + entry.getKey().substring(1);\n                JField f = null;\n                for (JField field : allFields) {\n                    if (field.getName().equals(name)) {\n                        f = field;\n                        break;\n                    }\n                }\n\n                if (f != null && isJsonIgnored(f)) {\n                    continue;\n                }\n\n                JsonProperty propName = getJsonPropertyFromGetterSetter(getter, setter);\n\n                // if have a field and an annotation from the getter/setter then use that annotation\n                if (f != null) {\n                    if (propName != null && !f.getName().equals(propName.value())) {\n                        allFields.remove(f);\n                        DummyJField dummy = new DummyJField(name, getter.getReturnType(), getter);\n                        dummy.setAnnotation(propName);\n                        allFields.add(dummy);\n                    }\n                } else {\n                    DummyJField dummy = new DummyJField(name, getter.getReturnType(), getter);\n                    if (getter.isAnnotationPresent(JsonProperty.class)) {\n                        dummy.setAnnotation(getAnnotation(getter, JsonProperty.class));\n                    }\n                    allFields.add(dummy);\n                }\n            }\n        }\n\n        // remove fields annotated with JsonIgnore\n        for (Iterator<JField> iter = allFields.iterator(); iter.hasNext();) {\n            final JField field = iter.next();\n            if (isJsonIgnored(field)) {\n                iter.remove();\n            }\n        }\n\n        return allFields;\n    }\n\n    /**\n     * Returns a list of all fields (non {@code transient} and not annotated with {@link XmlTransient}) in the supplied type and all super classes.\n     * \n     * @param allFields\n     * @param type\n     * @return\n     */\n    private List<JField> getFields(List<JField> allFields, JClassType type) {\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n            if (!field.isTransient() && !isXmlTransient(field)) {\n                allFields.add(field);\n            }\n        }\n        try {\n            JType objectType = find(Object.class, getLogger(), context);\n            if (!objectType.equals(type)) {\n                JClassType superType = type.getSuperclass();\n                return getFields(allFields, superType);\n            }\n        }\n        catch (UnableToCompleteException e) {\n\t    // do nothing\n        }\n\n    \treturn allFields;\n    }\n\n    public static String getTypeInfoPropertyValue(final JsonTypeInfo typeInfo)\n    {\n        if (typeInfo.include() == JsonTypeInfo.As.PROPERTY)\n            if(typeInfo.property() == null || \"\".equals(typeInfo.property()))\n                return typeInfo.use().getDefaultPropertyName();\n\n        return typeInfo.property();\n    }\n\n    public static boolean isLeaf(JClassType source)\n    {\n        return !(source.getSubtypes() != null && source.getSubtypes().length > 0);\n    }\n\n    public static class Subtype implements Comparable<Subtype> {\n    final String tag;\n    final JClassType clazz;\n\n    public Subtype(String tag, JClassType clazz) {\n        this.tag = tag;\n        this.clazz = clazz;\n    }\n\n    @Override\n    public int compareTo(Subtype o) {\n        return tag.compareTo(o.tag);\n    }\n    }\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> sTypeIdResolverMap = null;\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\nimport static org.fusesource.restygwt.rebind.util.AnnotationUtils.*;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonSubTypes;\nimport com.fasterxml.jackson.annotation.JsonSubTypes.Type;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.As;\nimport com.fasterxml.jackson.annotation.JsonValue;\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JConstructor;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONNull;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONString;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.thirdparty.guava.common.collect.Lists;\nimport com.google.gwt.thirdparty.guava.common.collect.Maps;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport javax.xml.bind.annotation.XmlTransient;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added getter + setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n *\n *         added polymorphic support\n * @author <a href=\"http://charliemason.info\">Charlie Mason<\/a>\n *\n */\n\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private static final String USE_JAVA_BEANS_SPEC_NAMING_CONVENTION_CONFIGURATION_PROPERTY_NAME = \"restygwt.conventions.useJavaBeansSpecNaming\";\n\n    private String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n    protected static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_NULL_CLASS = JSONNull.class.getName();\n    protected static final String JSON_STRING_CLASS = JSONString.class.getName();\n\n    protected JsonEncoderDecoderInstanceLocator locator;\n\n    protected boolean javaBeansNamingConventionEnabled;\n\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n\n        // true, if the naming convention from JavaBeans API specification should be used\n        javaBeansNamingConventionEnabled = getBooleanProperty(getLogger(), context.getPropertyOracle(), USE_JAVA_BEANS_SPEC_NAMING_CONVENTION_CONFIGURATION_PROPERTY_NAME, true);\n    }\n\n    @Override\n    public void generate() throws UnableToCompleteException {\n        final JsonTypeInfo typeInfo = getClassAnnotation(source, JsonTypeInfo.class);\n        final boolean isLeaf = isLeaf(source);\n\n        final List<Subtype> possibleTypes = getPossibleTypes(typeInfo, isLeaf);\n        Collections.sort(possibleTypes);\n\n        final JClassType sourceClazz = source.isClass() == null ? source.isInterface() : source.isClass();\n        if (sourceClazz == null) {\n            getLogger().log(ERROR, \"Type is not a class\");\n            throw new UnableToCompleteException();\n        }\n\n\t\tif (sourceClazz.isEnum() == null && sourceClazz.isAbstract()) {\n            if (typeInfo == null) {\n                getLogger().log(ERROR, \"Abstract classes must be annotated with JsonTypeInfo\");\n                throw new UnableToCompleteException();\n            }\n        }\n        Json jsonAnnotation = getAnnotation(source, Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n        final String railsWrapperName = jsonAnnotation != null && jsonAnnotation.name().length() > 0 ? jsonAnnotation.name() : sourceClazz.getName().toLowerCase();\n        locator = new JsonEncoderDecoderInstanceLocator(context, getLogger());\n\n        generateSingleton(shortName);\n\n        generateEncodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n\n        generateDecodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n\tClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n\tcomposerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n\treturn composerFactory;\n    }\n\n    private List<Subtype> getPossibleTypes(final JsonTypeInfo typeInfo, final boolean isLeaf) throws UnableToCompleteException\n    {\n        if (typeInfo == null)\n            return Lists.newArrayList(new Subtype(null, source));\n        Collection<Type> subTypes = findJsonSubTypes(source);\n        if(subTypes.isEmpty()) {\n            JsonSubTypes foundAnnotation = getAnnotation(source, JsonSubTypes.class);\n            if(foundAnnotation != null) {\n                Type[] value = foundAnnotation.value();\n                subTypes = Arrays.asList(value);\n            }\n        }\n        PossibleTypesVisitor v = new PossibleTypesVisitor(context, source, isLeaf, getLogger(), subTypes);\n        return v.visit(typeInfo.use());\n    }\n\n    /**\n     * This method does NOT return the subtypes of the given class, but all the subtypes associated with the\n     * {@link com.fasterxml.jackson.annotation.JsonSubTypes} annotation, even if this annotation is assigned to\n     * a parent class or an interface.\n     */\n    private Collection<Type> findJsonSubTypes(JClassType clazz) {\n        return findJsonSubTypes(clazz, new HashSet<JsonSubTypes.Type>());\n    }\n    \n    private Collection<Type> findJsonSubTypes(JClassType clazz, Set<Type> types) {\n        if (clazz == null) {\n            return Collections.emptyList();\n        }\n        JsonSubTypes annotation = getClassAnnotation(clazz, JsonSubTypes.class);\n            \n        if (annotation == null) {\n            return Collections.emptyList();\n        }\n\n        for (Type type : annotation.value()) {\n            if (types.add(type)) {\n                Class<?> subclazz = type.value();\n                String newSubClassName = subclazz.getName().replaceAll(\"\\\\$\", \".\");\n                JClassType subJClazz = context.getTypeOracle().findType(newSubClassName);\n                findJsonSubTypes(subJClazz, types);\n            }\n        }\n\n        return types;\n    }\n\n    protected void generateSingleton(String shortName)\n    {\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n    }\n\n    private void generateEncodeMethod(JClassType classType,\n            final Style classStyle,\n            JsonTypeInfo typeInfo,\n            String railsWrapperName,\n            List<Subtype> possibleTypes,\n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {\n            generateEnumEncodeMethod(classType, JSON_VALUE_CLASS);\n            return;\n        }\n\n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return getNullType();\");\n            }\n            i(-1).p(\"}\");\n\n            boolean returnWrapper = false; // if set, return rrc\n\n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n            if (classStyle == Style.RAILS) {\n                returnWrapper = true;\n                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                p(\"rrc.put(\\\"\" + railsWrapperName + \"\\\" , rc);\");\n            }\n\n            for (Subtype possibleType : possibleTypes) {\n\n                if (!possibleType.clazz.isAssignableTo(classType)) {\n                    getLogger().log(DEBUG, \"Only assignable classes are allowed: \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" is not assignable to: \" + classType.getParameterizedQualifiedSourceName());\n                    continue;\n                }\n\n                if (!isLeaf) {\n                    // Generate a decoder for each possible type\n                    p(\"if(value.getClass().getName().equals(\\\"\" + possibleType.clazz.getQualifiedBinaryName() + \"\\\"))\");\n                    p(\"{\");\n                }\n\n                if (possibleType.clazz.isEnum() != null) {\n                    generateEnumEncodeMethodBody(possibleType, typeInfo);\n                } else {\n\n                    // Try to find a constructor that is annotated as creator\n                    final JConstructor creator = findCreator(possibleType.clazz);\n\n                    List<JField> orderedFields = creator == null ? null : getOrderedFields(getFields(possibleType.clazz), creator);\n\n                    if (typeInfo != null) {\n                        switch (typeInfo.include()) {\n                            case PROPERTY:\n                                p(\"com.google.gwt.json.client.JSONValue className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\");\");\n                                p(\"if( className!=null ) { \").i(1);\n                                p(\"rc.put(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \", className);\");\n                                i(-1).p(\"}\");\n                                break;\n                            case WRAPPER_OBJECT:\n                                returnWrapper = true;\n                                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                                p(\"rrc.put(\\\"\" + possibleType.tag + \"\\\", rc);\");\n                                break;\n                            case WRAPPER_ARRAY:\n                                returnWrapper = true;\n                                p(JSON_ARRAY_CLASS + \" rrc = new \" + JSON_ARRAY_CLASS + \"();\");\n                                p(\"rrc.set(0, org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\"));\");\n                                p(\"rrc.set(1, rc);\");\n                                break;\n                            case EXISTING_PROPERTY:\n                                getLogger().log(WARN, classType + \" comes with not implemented type info 'as' \" + JsonTypeInfo.As.EXISTING_PROPERTY );\n                                // not implemented\n                                break;\n                            case EXTERNAL_PROPERTY:\n                                getLogger().log(WARN, classType + \" comes with not implemented type info 'as' \" + JsonTypeInfo.As.EXTERNAL_PROPERTY );\n                                // not implemented\n                                break;\n                            default:\n                        }\n                    }\n\n                    p(possibleType.clazz.getParameterizedQualifiedSourceName() + \" parseValue = (\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \")value;\");\n\n                    for (final JField field : getFields(possibleType.clazz)) {\n\n                        final String getterName = getGetterName(field);\n\n                        boolean ignoreField = false;\n                        if(getAnnotation(possibleType.clazz, JsonIgnoreProperties.class) != null) {\n                            for(String s : getAnnotation(possibleType.clazz, JsonIgnoreProperties.class).value()) {\n                                if(s.equals(field.getName())) {\n                                    ignoreField = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        // If can ignore some fields right off the back..\n                        // if there is a creator encode only final fields with JsonProperty annotation\n                        if (ignoreField || getterName == null && (field.isStatic() || (field.isFinal() && !(creator != null && orderedFields.contains(field))) || field.isTransient()\n\t\t\t\t\t\t\t\t|| field.isAnnotationPresent(JsonIgnore.class) || field.isAnnotationPresent(XmlTransient.class))) {\n                            continue;\n                        }\n\n                        branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                            @Override\n                            public Void execute() throws UnableToCompleteException {\n                                // TODO: try to get the field with a setter or\n                                // JSNI\n                                if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                                    Json jsonAnnotation = getAnnotation(field, Json.class);\n                                    JsonProperty jsonPropertyAnnotation = getAnnotation(field, JsonProperty.class);\n\n                                    String name = field.getName();\n                                    String jsonName = name;\n\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                                        jsonName = jsonPropertyAnnotation.value();\n                                    }\n\n                                    String fieldExpr = \"parseValue.\" + name;\n                                    if (getterName != null) {\n                                        fieldExpr = \"parseValue.\" + getterName + \"()\";\n                                    }\n\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    String expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n\n                                    \n                                    if (null != field.getType().isEnum()) {\n                                    \tp(\"if(isNotNullAndCheckDefaults(\" + fieldExpr+ \", rc, \"+ wrap(jsonName) + \")) {\").i(1);\n                                    }\n                                        \n                                    p(\"isNotNullValuePut(\" + expression + \", rc, \"+ wrap(jsonName) + \");\");\n\n                                    if (null != field.getType().isEnum()) {\n                                    \ti(-1).p(\"}\");\n                                    }\n                                    \n\n                                } else {\n                                    getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                                }\n                                return null;\n                            }\n                        });\n\n                    }\n\n                    if (returnWrapper) {\n                        p(\"return rrc;\");\n                    } else {\n                        p(\"return rc;\");\n                    }\n                }\n                if (!isLeaf) {\n                    p(\"}\");\n                }\n            }\n\n            if (!isLeaf) {\n                // Shouldn't get called\n                p(\"return null;\");\n            }\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n\n    private void generateEnumEncodeMethodBody(final Subtype possibleType, final JsonTypeInfo typeInfo) {\n        p(\"if( value==null ) {\").i(1);\n        {\n            p(\"return \" + JSON_NULL_CLASS + \".getInstance();\").i(-1);\n        }\n        p(\"}\");\n        p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n        p(JSON_VALUE_CLASS + \" className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\"\n                + possibleType.tag + \"\\\");\");\n        p(\"rrc.put(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \", className);\");\n        p(\"rrc.put(\\\"name\\\", new \" + JSON_STRING_CLASS + \"(value.\" + getValueMethod(possibleType.clazz) + \"()));\");\n        p(\"return rrc;\");\n    }\n\n    private void generateEnumEncodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + jsonValueClass + \" encode(\" + classType.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return \" + JSON_NULL_CLASS + \".getInstance();\").i(-1);\n            }\n            p(\"}\");\n            p(\"return new \" + JSON_STRING_CLASS + \"(value.\" + getValueMethod(classType) + \"());\");\n            i(-1).p(\"}\");\n        }\n        p();\n    }\n\n    protected String getValueMethod(JClassType classType) {\n        String method = \"name\";\n        for(JMethod jm : classType.isEnum().getMethods() ) {\n            if (jm.isAnnotationPresent(JsonValue.class)) {\n                method = jm.getName();\n                break;\n            }\n        }\n        return method;\n    }\n\n    private void generateDecodeMethod(JClassType classType,\n            final Style classStyle,\n            JsonTypeInfo typeInfo,\n            String railsWrapperName,\n            List<Subtype> possibleTypes,\n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {\n            generateEnumDecodeMethod(classType, JSON_VALUE_CLASS);\n            return;\n        }\n\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n            {\n                p(\"return null;\").i(-1);\n            }\n            p(\"}\");\n            if (classStyle == Style.RAILS) {\n                p(JSON_OBJECT_CLASS + \" object = toObjectFromWrapper(value, \\\"\" + railsWrapperName + \"\\\");\");\n            } else if (typeInfo != null && typeInfo.include() == As.WRAPPER_ARRAY) {\n                p(JSON_ARRAY_CLASS + \" array = (\" + JSON_ARRAY_CLASS + \")value;\");\n                if (!isLeaf)\n                    p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(array.get(0));\");\n                p(JSON_OBJECT_CLASS + \" object = toObject(array.get(1));\");\n            } else {\n                p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            }\n\n            if (!isLeaf && typeInfo != null && typeInfo.include() == As.PROPERTY) {\n                p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \"));\");\n            }\n\n            for (Subtype possibleType : possibleTypes) {\n\n                if (!possibleType.clazz.isAssignableTo(classType)) {\n                    getLogger().log(DEBUG, \"Only assignable classes are allowed: \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" is not assignable to: \" + classType.getParameterizedQualifiedSourceName());\n                    continue;\n                }\n\n                if (typeInfo != null) {\n                    if (typeInfo.include() == As.WRAPPER_OBJECT) {\n                        if (!isLeaf) {\n                            p(\"if(object.containsKey(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        }\n                        p(\"object = toObjectFromWrapper(value, \\\"\" + possibleType.tag + \"\\\");\");\n                    } else if (!isLeaf) {\n                        if (classType.equals(possibleType.clazz)) {\n                            p(\"if(sourceName == null || sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        } else {\n                            p(\"if(sourceName != null && sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        }\n                    }\n                }\n\n                if (possibleType.clazz.isEnum() != null) {\n                    generateEnumDecodeMethodBody(possibleType.clazz);\n                } else {\n                    // Try to find a constuctor that is annotated as creator\n                    final JConstructor creator = findCreator(possibleType.clazz);\n\n                    List<JField> orderedFields = null;\n                    if (creator != null) {\n                        p(\"// We found a creator so we use the annotated constructor\");\n                        p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"(\");\n                        i(1).p(\"// The arguments are placed in the order they appear within the annotated constructor\").i(-1);\n                        orderedFields = getOrderedFields(getFields(possibleType.clazz), creator);\n                        final JField lastField = orderedFields.get(orderedFields.size() - 1);\n                        for (final JField field : orderedFields) {\n                            branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                                @Override\n                                public Void execute() throws UnableToCompleteException {\n                                    Json jsonAnnotation = getAnnotation(field, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    String jsonName = field.getName();\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                    String defaultValue = getDefaultValue(field);\n                                    i(1).p(\"\" + (objectGetter + \" == null || \" + objectGetter + \" instanceof \" + JSON_NULL_CLASS + \" ? \" + defaultValue + \" : \" + expression + ((field != lastField) ? \", \" : \"\"))).i(-1);\n\n                                    return null;\n                                }\n                            });\n                        }\n                        p(\");\");\n                    }\n\n                    if (orderedFields == null){\n                        p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"();\");\n                    }\n\n                    for (final JField field : getFields(possibleType.clazz)) {\n\n                        boolean ignoreField = false;\n                        if(getAnnotation(possibleType.clazz, JsonIgnoreProperties.class) != null) {\n                            for(String s : getAnnotation(possibleType.clazz, JsonIgnoreProperties.class).value()) {\n                                if(s.equals(field.getName())) {\n                                    ignoreField = true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(ignoreField) {\n                            continue;\n                        }\n\n                        if (orderedFields != null && orderedFields.contains(field)){\n                            continue;\n                        }\n\n                        final String setterName = getSetterName(field);\n\n                        // If can ignore some fields right off the back..\n                        if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient())\n\t\t\t\t\t\t\t\t|| field.isAnnotationPresent(JsonIgnore.class) || field.isAnnotationPresent(XmlTransient.class)) {\n                            continue;\n                        }\n\n                        branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                            @Override\n                            public Void execute() throws UnableToCompleteException {\n\n                                // TODO: try to set the field with a setter\n                                // or JSNI\n                                if (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                                    Json jsonAnnotation = getAnnotation(field, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    JsonProperty jsonPropertyAnnotation = getAnnotation(field, JsonProperty.class);\n\n                                    String name = field.getName();\n                                    String jsonName = name;\n\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                                        jsonName = jsonPropertyAnnotation.value();\n                                    }\n\n                                    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                    boolean isShort = field.getType().isPrimitive() == JPrimitiveType.SHORT;\n                                    String defaultValue = getDefaultValue(field);\n\n                                    String methodName = isShort ? \"getValueToSetForShort\" : \"getValueToSet\";\n                                    \n                                    if (setterName != null) {\n                                    \tp(\"rc.\" + setterName + \"(\"  + methodName + \"(\" + expression + \", \" + defaultValue + \"));\");\n                                    } else {\n                                    \tp(\"rc.\" + name + \"= \" +  methodName + \"(\" + expression + \",\" + defaultValue + \");\");\n                                    }\n                                    \n                                } else {\n                                    getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                                }\n                                return null;\n                            }\n                        });\n                    }\n\n                    p(\"return rc;\");\n                }\n                if (typeInfo != null && !isLeaf) {\n                    p(\"}\");\n                }\n            }\n\n            if (typeInfo != null && !isLeaf) {\n                p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n            p();\n        }\n    }\n\n    private void generateEnumDecodeMethodBody(JClassType classType) {\n        p(JSON_VALUE_CLASS + \" str = object.get(\\\"name\\\");\");\n        p(\"if( null == str || str.isString() == null ) {\").i(1);\n        {\n            p(\"throw new DecodingException(\\\"Expected a string field called 'name' for enum; not found\\\");\").i(-1);\n        }\n        p(\"}\");\n        decodeEnum(classType, \"str.isString().stringValue()\");\n    }\n\n    private String getDefaultValue(JField field) {\n        return field.getType().isPrimitive() == null ? \"null\" : field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n    }\n\n    protected void generateEnumDecodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + classType.getName() + \" decode(\" + jsonValueClass + \" value) {\").i(1);\n        {\n        p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n        {\n            p(\"return null;\").i(-1);\n        }\n        p(\"}\");\n        p(JSON_STRING_CLASS + \" str = value.isString();\");\n        p(\"if( null == str ) {\").i(1);\n        {\n            p(\"throw new DecodingException(\\\"Expected a json string (for enum), but was given: \\\"+value);\").i(-1);\n        }\n        p(\"}\");\n\n        String value = \"str.stringValue()\";\n        decodeEnum(classType, value);\n        }\n        p(\"}\");\n        p();\n    }\n\n    protected void decodeEnum(JClassType classType, String value) {\n        String className = classType.getParameterizedQualifiedSourceName();\n        String method = getValueMethod(classType);\n        if ( method == null ) {\n            p(\"return Enum.valueOf(\" + className + \".class, \" + value + \");\").i(-1);\n        }\n        else {\n            p(\"for(\" + className + \" v: \" + className + \".values()) {\").i(1);\n            {\n                p(\"if(v.\" + method + \"().equals(\" + value + \")) {\").i(1);\n                {\n                    p(\"return v;\").i(-1);\n                }\n                p(\"}\").i(-1);\n            }\n            p(\"}\");\n            p(\"throw new DecodingException(\\\"can not find enum for given value: \\\"+\" + value + \");\").i(-1);\n        }\n    }\n\n    static public void clearRestyResolverClassMap() {\n    \tsTypeIdResolverMap = null;\n    }\n    \n    public static Map<Class<?>, RestyJsonTypeIdResolver> getRestyResolverClassMap(GeneratorContext context, TreeLogger logger) throws UnableToCompleteException {\n\tif (sTypeIdResolverMap == null) {\n\t    try {\n\t\tMap<Class<?>, RestyJsonTypeIdResolver> map = Maps.newHashMap();\n\t\tList<String> values = context.getPropertyOracle().getConfigurationProperty(\"org.fusesource.restygwt.jsontypeidresolver\").getValues();\n\t\tfor (String value : values)\n\t\t    try {\n\t\t\tClass<?> clazz = Class.forName(value);\n\t\t\tRestyJsonTypeIdResolver resolver = (RestyJsonTypeIdResolver) clazz.newInstance();\n\t\t\tmap.put(resolver.getTypeIdResolverClass(), resolver);\n\t\t    } catch (Exception e) {\n\t\t\tlogger.log(WARN, \"Could not access class: \" + values.get(0), e);\n\t\t    }\n\t\t    sTypeIdResolverMap = map;\n\t    } catch (BadPropertyValueException e) {\n\t\tlogger.log(ERROR, \"Could not acccess property: RestyJsonTypeIdResolver\", e);\n\t\tthrow new UnableToCompleteException();\n\t    }\n\t}\n\treturn sTypeIdResolverMap;\n    }\n\n    private List<JField> getOrderedFields(List<JField> fields, JConstructor creator) throws UnableToCompleteException {\n\tList<JField> orderedFields = new ArrayList<JField>();\n\tfor (JParameter param : creator.getParameters()) {\n\t    JsonProperty prop = getAnnotation(param, JsonProperty.class);\n\t    if (prop != null) {\n\t\tfor (JField field : fields) {\n\t\t    if (field.getName().equals(prop.value())) {\n\t\t\torderedFields.add(field);\n\t\t    }\n\t\t}\n\t    } else {\n\t\tgetLogger().log(ERROR, \"a constructor annotated with @JsonCreator requires that all paramaters are annotated with @JsonProperty.\");\n        throw new UnableToCompleteException();\n\t    }\n\t}\n\n\treturn orderedFields;\n    }\n\n    private JConstructor findCreator(JClassType sourceClazz) {\n\tfor (JConstructor constructor : sourceClazz.getConstructors()) {\n\t    if (getAnnotation(constructor, JsonCreator.class) != null) {\n\t\treturn constructor;\n\t    }\n\t}\n\n\treturn null;\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the setter for the specified field or null if a\n     *         setter can't be found.\n     */\n    private String getSetterName(JField field) {\n        String fieldName = \"set\" + getMiddleNameForPrefixingAsAccessorMutator(field.getName());\n        JClassType type = field.getEnclosingType();\n        if (exists(type, field, fieldName, true)) {\n            return fieldName;\n        }\n        return null;\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the getter for the specified field or null if a\n     *         getter can't be found.\n     */\n    private String getGetterName(JField field) {\n        final String methodBaseName = getMiddleNameForPrefixingAsAccessorMutator(field.getName());\n        String fieldName = null;\n        JType booleanType = null;\n        try {\n            booleanType = find(Boolean.class, getLogger(), context);\n        } catch (UnableToCompleteException e) {\n            // do nothing\n        }\n        JClassType type = field.getEnclosingType();\n        if (field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)) {\n            if (field instanceof DummyJField) {\n                return ((DummyJField) field).getGetterMethod().getName();\n            }\n            fieldName = \"is\" + methodBaseName;\n            if (exists(type, field, fieldName, false)) {\n                return fieldName;\n            }\n            fieldName = \"has\" + methodBaseName;\n            if (exists(type, field, fieldName, false)) {\n                return fieldName;\n            }\n        }\n        fieldName = \"get\" + methodBaseName;\n        if (exists(type, field, fieldName, false)) {\n            return fieldName;\n        }\n        return null;\n    }\n\n    private String getMiddleNameForPrefixingAsAccessorMutator(String fieldName) {\n        if (javaBeansNamingConventionEnabled) {\n            return getMiddleNameForPrefixingAsAccessorMutatorJavaBeansSpecCompliance(fieldName);\n        }\n        return upperCaseFirstChar(fieldName);\n    }\n\n    /**\n     * Get the middle part of the method name in compliance with the naming convention in the JavaBeans API specification.\n     * \n     * @param fieldName\n     * @return\n     */\n    static String getMiddleNameForPrefixingAsAccessorMutatorJavaBeansSpecCompliance(String fieldName) {\n        if (fieldName.length() > 1 && Character.isUpperCase(fieldName.charAt(1))) {\n            return fieldName;\n        }\n        return fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);\n    }\n\n    private String upperCaseFirstChar(String in) {\n        if (in.length() == 1) {\n            return in.toUpperCase();\n        }\n        return in.substring(0, 1).toUpperCase() + in.substring(1);\n    }\n\n    /**\n     * checks whether a getter or setter exists on the specified type or any of\n     * its super classes excluding Object. respects JsonIgnore accordingly.\n     *\n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {\n        if ( field instanceof DummyJField ){\n               return true; \n        }\n\n\tJType[] args = null;\n\tif (isSetter) {\n\t    args = new JType[] { field.getType() };\n\t} else {\n\t    args = new JType[] {};\n\t}\n\tJMethod m = type.findMethod(fieldName, args);\n\tif (null != m) {\n        if(getAnnotation(m, JsonIgnore.class) != null)\n\t\t\treturn false;\n\t\tif (getAnnotation(m, XmlTransient.class) != null)\n\t\t\treturn false;\n        if(isSetter)\n            return true;\n        JClassType returnType = m.getReturnType().isClassOrInterface();\n        JClassType fieldType = field.getType().isClassOrInterface();\n        if(returnType == null || fieldType == null) {\n            // at least one is a primitive type\n            return m.getReturnType().equals(field.getType());\n        }\n        // both are non-primitives\n        return returnType.isAssignableFrom(fieldType);\n\t}\n    try {\n    JType objectType = find(Object.class, getLogger(), context);\n    JClassType superType = type.getSuperclass();\n    if (!objectType.equals(superType)) {\n        return exists(superType, field, fieldName, isSetter);\n    }\n    } catch (UnableToCompleteException e) {\n    // do nothing\n    }\n\treturn false;\n    }\n\n    /**\n     * Get {@link JsonProperty} from getter or setter. Annotation from setter is preferred to getter.\n     *\n     * @param getter\n     * @param setter\n     * @return\n     */\n    private JsonProperty getJsonPropertyFromGetterSetter(JMethod getter, JMethod setter) {\n        JsonProperty setterProp = getAnnotation(setter, JsonProperty.class);\n        return (null != setterProp)?setterProp:getAnnotation(getter, JsonProperty.class);\n    }\n\n    /**\n     * Inspects the supplied type and all super classes up to but excluding\n     * Object and returns a list of all fields found in these classes.\n     *\n     * @param type\n     * @return\n     */\n    private List<JField> getFields(JClassType type) {\n        List<JField> allFields = getFields(new ArrayList<JField>(), type);\n        Map<String, JMethod> getters = new HashMap<String, JMethod>();\n        Map<String, JMethod> setters = new HashMap<String, JMethod>();\n\n        JType booleanType = null;\n        try {\n            booleanType = find(Boolean.class, getLogger(), context);\n        } catch (UnableToCompleteException e) {\n            // do nothing\n        }\n        for( JMethod m: type.getInheritableMethods() ){\n            if( m.getName().startsWith(\"set\") &&\n                    m.getParameterTypes().length == 1 &&\n                    m.getReturnType() == JPrimitiveType.VOID &&\n                    getAnnotation(m, JsonIgnore.class) == null &&\n                    getAnnotation(m, XmlTransient.class) == null) {\n                setters.put( m.getName().substring(\"set\".length()), m );\n            }\n            else if( m.getName().startsWith(\"get\") &&\n                    m.getParameterTypes().length == 0 &&\n                    m.getReturnType() != JPrimitiveType.VOID &&\n                    getAnnotation(m, JsonIgnore.class) == null &&\n                    getAnnotation(m, XmlTransient.class) == null) {\n                getters.put( m.getName().substring(\"get\".length()), m );\n            }\n            else if( m.getName().startsWith(\"is\") &&\n                    m.getParameterTypes().length == 0 &&\n                    ( m.getReturnType() == JPrimitiveType.BOOLEAN || m.getReturnType().equals(booleanType) ) &&\n                    getAnnotation(m, JsonIgnore.class) == null &&\n                    getAnnotation(m, XmlTransient.class) == null) {\n                getters.put( m.getName().substring(\"is\".length()), m );\n            }\n            else if( m.getName().startsWith(\"has\") &&\n                    m.getParameterTypes().length == 0 &&\n                    ( m.getReturnType() == JPrimitiveType.BOOLEAN || m.getReturnType().equals(booleanType) ) &&\n                    getAnnotation(m, JsonIgnore.class) == null &&\n                    getAnnotation(m, XmlTransient.class) == null) {\n                getters.put( m.getName().substring(\"has\".length()), m );\n            }\n        }\n        for (Map.Entry<String, JMethod> entry : getters.entrySet()) {\n            final JMethod getter = entry.getValue();\n            final JMethod setter = setters.get(entry.getKey());\n\n            if (null != setter && setter.getParameterTypes()[0].equals(getter.getReturnType())) {\n                String name = entry.getKey().substring(0, 1).toLowerCase() + entry.getKey().substring(1);\n                JField f = null;\n                for (JField field : allFields) {\n                    if (field.getName().equals(name)) {\n                        f = field;\n                        break;\n                    }\n                }\n\n                if (f != null && null != getAnnotation(f, JsonIgnore.class)) {\n                    continue;\n                }\n\n                JsonProperty propName = getJsonPropertyFromGetterSetter(getter, setter);\n\n                // if have a field and an annotation from the getter/setter then use that annotation\n                if (f != null) {\n                    if (propName != null && !f.getName().equals(propName.value())) {\n                        allFields.remove(f);\n                        DummyJField dummy = new DummyJField(name, getter.getReturnType(), getter);\n                        dummy.setAnnotation(propName);\n                        allFields.add(dummy);\n                    }\n                } else {\n                    DummyJField dummy = new DummyJField(name, getter.getReturnType(), getter);\n                    if (getter.isAnnotationPresent(JsonProperty.class)) {\n                        dummy.setAnnotation(getAnnotation(getter, JsonProperty.class));\n                    }\n                    allFields.add(dummy);\n                }\n            }\n        }\n\n        // remove fields annotated with JsonIgnore\n        for (Iterator<JField> iter = allFields.iterator(); iter.hasNext();) {\n            final JField field = iter.next();\n            if (null != getAnnotation(field, JsonIgnore.class)) {\n                iter.remove();\n            }\n        }\n\n        return allFields;\n    }\n\n    /**\n     * Returns a list of all fields (non {@code transient} and not annotated with {@link XmlTransient}) in the supplied type and all super classes.\n     * \n     * @param allFields\n     * @param type\n     * @return\n     */\n    private List<JField> getFields(List<JField> allFields, JClassType type) {\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n            if (!field.isTransient() && !field.isAnnotationPresent(XmlTransient.class)) {\n                allFields.add(field);\n            }\n        }\n        try {\n            JType objectType = find(Object.class, getLogger(), context);\n            if (!objectType.equals(type)) {\n                JClassType superType = type.getSuperclass();\n                return getFields(allFields, superType);\n            }\n        }\n        catch (UnableToCompleteException e) {\n\t    // do nothing\n        }\n\n    \treturn allFields;\n    }\n\n    public static String getTypeInfoPropertyValue(final JsonTypeInfo typeInfo)\n    {\n        if (typeInfo.include() == JsonTypeInfo.As.PROPERTY)\n            if(typeInfo.property() == null || \"\".equals(typeInfo.property()))\n                return typeInfo.use().getDefaultPropertyName();\n\n        return typeInfo.property();\n    }\n\n    public static boolean isLeaf(JClassType source)\n    {\n        return !(source.getSubtypes() != null && source.getSubtypes().length > 0);\n    }\n\n    public static class Subtype implements Comparable<Subtype> {\n    final String tag;\n    final JClassType clazz;\n\n    public Subtype(String tag, JClassType clazz) {\n        this.tag = tag;\n        this.clazz = clazz;\n    }\n\n    @Override\n    public int compareTo(Subtype o) {\n        return tag.compareTo(o.tag);\n    }\n    }\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> sTypeIdResolverMap = null;\n}\n","lineNo":245}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\nimport static org.fusesource.restygwt.rebind.util.AnnotationUtils.*;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonSubTypes;\nimport com.fasterxml.jackson.annotation.JsonSubTypes.Type;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.As;\nimport com.fasterxml.jackson.annotation.JsonValue;\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JConstructor;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONNull;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONString;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.thirdparty.guava.common.collect.Lists;\nimport com.google.gwt.thirdparty.guava.common.collect.Maps;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport javax.xml.bind.annotation.XmlTransient;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added getter + setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n *\n *         added polymorphic support\n * @author <a href=\"http://charliemason.info\">Charlie Mason<\/a>\n *\n */\n\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n    protected static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_NULL_CLASS = JSONNull.class.getName();\n    protected static final String JSON_STRING_CLASS = JSONString.class.getName();\n\n    protected JsonEncoderDecoderInstanceLocator locator;\n\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    @Override\n    public void generate() throws UnableToCompleteException {\n        final JsonTypeInfo typeInfo = getClassAnnotation(source, JsonTypeInfo.class);\n        final boolean isLeaf = isLeaf(source);\n\n        final List<Subtype> possibleTypes = getPossibleTypes(typeInfo, isLeaf);\n        Collections.sort(possibleTypes);\n\n        final JClassType sourceClazz = source.isClass() == null ? source.isInterface() : source.isClass();\n        if (sourceClazz == null) {\n            getLogger().log(ERROR, \"Type is not a class\");\n            throw new UnableToCompleteException();\n        }\n\n\t\tif (sourceClazz.isEnum() == null && sourceClazz.isAbstract()) {\n            if (typeInfo == null) {\n                getLogger().log(ERROR, \"Abstract classes must be annotated with JsonTypeInfo\");\n                throw new UnableToCompleteException();\n            }\n        }\n        Json jsonAnnotation = getAnnotation(source, Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n        final String railsWrapperName = jsonAnnotation != null && jsonAnnotation.name().length() > 0 ? jsonAnnotation.name() : sourceClazz.getName().toLowerCase();\n        locator = new JsonEncoderDecoderInstanceLocator(context, getLogger());\n\n        generateSingleton(shortName);\n\n        generateEncodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n\n        generateDecodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n\tClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n\tcomposerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n\treturn composerFactory;\n    }\n\n    private List<Subtype> getPossibleTypes(final JsonTypeInfo typeInfo, final boolean isLeaf) throws UnableToCompleteException\n    {\n        if (typeInfo == null)\n            return Lists.newArrayList(new Subtype(null, source));\n        Collection<Type> subTypes = findJsonSubTypes(source);\n        if(subTypes.isEmpty()) {\n            JsonSubTypes foundAnnotation = getAnnotation(source, JsonSubTypes.class);\n            if(foundAnnotation != null) {\n                Type[] value = foundAnnotation.value();\n                subTypes = Arrays.asList(value);\n            }\n        }\n        PossibleTypesVisitor v = new PossibleTypesVisitor(context, source, isLeaf, getLogger(), subTypes);\n        return v.visit(typeInfo.use());\n    }\n\n    /**\n     * This method does NOT return the subtypes of the given class, but all the subtypes associated with the\n     * {@link com.fasterxml.jackson.annotation.JsonSubTypes} annotation, even if this annotation is assigned to\n     * a parent class or an interface.\n     */\n    private Collection<Type> findJsonSubTypes(JClassType clazz) {\n        return findJsonSubTypes(clazz, new HashSet<JsonSubTypes.Type>());\n    }\n    \n    private Collection<Type> findJsonSubTypes(JClassType clazz, Set<Type> types) {\n        if (clazz == null) {\n            return Collections.emptyList();\n        }\n        JsonSubTypes annotation = getClassAnnotation(clazz, JsonSubTypes.class);\n            \n        if (annotation == null) {\n            return Collections.emptyList();\n        }\n\n        for (Type type : annotation.value()) {\n            if (types.add(type)) {\n                Class<?> subclazz = type.value();\n                String newSubClassName = subclazz.getName().replaceAll(\"\\\\$\", \".\");\n                JClassType subJClazz = context.getTypeOracle().findType(newSubClassName);\n                findJsonSubTypes(subJClazz, types);\n            }\n        }\n\n        return types;\n    }\n\n    protected void generateSingleton(String shortName)\n    {\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n    }\n\n    private void generateEncodeMethod(JClassType classType,\n            final Style classStyle,\n            JsonTypeInfo typeInfo,\n            String railsWrapperName,\n            List<Subtype> possibleTypes,\n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {\n            generateEnumEncodeMethod(classType, JSON_VALUE_CLASS);\n            return;\n        }\n\n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return getNullType();\");\n            }\n            i(-1).p(\"}\");\n\n            boolean returnWrapper = false; // if set, return rrc\n\n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n            if (classStyle == Style.RAILS) {\n                returnWrapper = true;\n                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                p(\"rrc.put(\\\"\" + railsWrapperName + \"\\\" , rc);\");\n            }\n\n            for (Subtype possibleType : possibleTypes) {\n\n                if (!possibleType.clazz.isAssignableTo(classType)) {\n                    getLogger().log(DEBUG, \"Only assignable classes are allowed: \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" is not assignable to: \" + classType.getParameterizedQualifiedSourceName());\n                    continue;\n                }\n\n                if (!isLeaf) {\n                    // Generate a decoder for each possible type\n                    p(\"if(value.getClass().getName().equals(\\\"\" + possibleType.clazz.getQualifiedBinaryName() + \"\\\"))\");\n                    p(\"{\");\n                }\n\n                if (possibleType.clazz.isEnum() != null) {\n                    generateEnumEncodeMethodBody(possibleType, typeInfo);\n                } else {\n\n                    // Try to find a constructor that is annotated as creator\n                    final JConstructor creator = findCreator(possibleType.clazz);\n\n                    List<JField> orderedFields = creator == null ? null : getOrderedFields(getFields(possibleType.clazz), creator);\n\n                    if (typeInfo != null) {\n                        switch (typeInfo.include()) {\n                            case PROPERTY:\n                                p(\"com.google.gwt.json.client.JSONValue className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\");\");\n                                p(\"if( className!=null ) { \").i(1);\n                                p(\"rc.put(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \", className);\");\n                                i(-1).p(\"}\");\n                                break;\n                            case WRAPPER_OBJECT:\n                                returnWrapper = true;\n                                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                                p(\"rrc.put(\\\"\" + possibleType.tag + \"\\\", rc);\");\n                                break;\n                            case WRAPPER_ARRAY:\n                                returnWrapper = true;\n                                p(JSON_ARRAY_CLASS + \" rrc = new \" + JSON_ARRAY_CLASS + \"();\");\n                                p(\"rrc.set(0, org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\"));\");\n                                p(\"rrc.set(1, rc);\");\n                                break;\n                            case EXISTING_PROPERTY:\n                                getLogger().log(WARN, classType + \" comes with not implemented type info 'as' \" + JsonTypeInfo.As.EXISTING_PROPERTY );\n                                // not implemented\n                                break;\n                            case EXTERNAL_PROPERTY:\n                                getLogger().log(WARN, classType + \" comes with not implemented type info 'as' \" + JsonTypeInfo.As.EXTERNAL_PROPERTY );\n                                // not implemented\n                                break;\n                            default:\n                        }\n                    }\n\n                    p(possibleType.clazz.getParameterizedQualifiedSourceName() + \" parseValue = (\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \")value;\");\n\n                    for (final JField field : getFields(possibleType.clazz)) {\n\n                        final String getterName = getGetterName(field);\n\n                        boolean ignoreField = false;\n                        if(getAnnotation(possibleType.clazz, JsonIgnoreProperties.class) != null) {\n                            for(String s : getAnnotation(possibleType.clazz, JsonIgnoreProperties.class).value()) {\n                                if(s.equals(field.getName())) {\n                                    ignoreField = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        // If can ignore some fields right off the back..\n                        // if there is a creator encode only final fields with JsonProperty annotation\n                        if (ignoreField || getterName == null && (field.isStatic() || (field.isFinal() && !(creator != null && orderedFields.contains(field))) || field.isTransient()\n\t\t\t\t\t\t\t\t|| field.isAnnotationPresent(JsonIgnore.class) || field.isAnnotationPresent(XmlTransient.class))) {\n                            continue;\n                        }\n\n                        branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                            @Override\n                            public Void execute() throws UnableToCompleteException {\n                                // TODO: try to get the field with a setter or\n                                // JSNI\n                                if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                                    Json jsonAnnotation = getAnnotation(field, Json.class);\n                                    JsonProperty jsonPropertyAnnotation = getAnnotation(field, JsonProperty.class);\n\n                                    String name = field.getName();\n                                    String jsonName = name;\n\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                                        jsonName = jsonPropertyAnnotation.value();\n                                    }\n\n                                    String fieldExpr = \"parseValue.\" + name;\n                                    if (getterName != null) {\n                                        fieldExpr = \"parseValue.\" + getterName + \"()\";\n                                    }\n\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    String expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n\n                                    \n                                    if (null != field.getType().isEnum()) {\n                                    \tp(\"if(isNotNullAndCheckDefaults(\" + fieldExpr+ \", rc, \"+ wrap(jsonName) + \")) {\").i(1);\n                                    }\n                                        \n                                    p(\"isNotNullValuePut(\" + expression + \", rc, \"+ wrap(jsonName) + \");\");\n\n                                    if (null != field.getType().isEnum()) {\n                                    \ti(-1).p(\"}\");\n                                    }\n                                    \n\n                                } else {\n                                    getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                                }\n                                return null;\n                            }\n                        });\n\n                    }\n\n                    if (returnWrapper) {\n                        p(\"return rrc;\");\n                    } else {\n                        p(\"return rc;\");\n                    }\n                }\n                if (!isLeaf) {\n                    p(\"}\");\n                }\n            }\n\n            if (!isLeaf) {\n                // Shouldn't get called\n                p(\"return null;\");\n            }\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n\n    private void generateEnumEncodeMethodBody(final Subtype possibleType, final JsonTypeInfo typeInfo) {\n        p(\"if( value==null ) {\").i(1);\n        {\n            p(\"return \" + JSON_NULL_CLASS + \".getInstance();\").i(-1);\n        }\n        p(\"}\");\n        p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n        p(JSON_VALUE_CLASS + \" className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\"\n                + possibleType.tag + \"\\\");\");\n        p(\"rrc.put(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \", className);\");\n        p(\"rrc.put(\\\"name\\\", new \" + JSON_STRING_CLASS + \"(value.\" + getValueMethod(possibleType.clazz) + \"()));\");\n        p(\"return rrc;\");\n    }\n\n    private void generateEnumEncodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + jsonValueClass + \" encode(\" + classType.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return \" + JSON_NULL_CLASS + \".getInstance();\").i(-1);\n            }\n            p(\"}\");\n            p(\"return new \" + JSON_STRING_CLASS + \"(value.\" + getValueMethod(classType) + \"());\");\n            i(-1).p(\"}\");\n        }\n        p();\n    }\n\n    protected String getValueMethod(JClassType classType) {\n        String method = \"name\";\n        for(JMethod jm : classType.isEnum().getMethods() ) {\n            if (jm.isAnnotationPresent(JsonValue.class)) {\n                method = jm.getName();\n                break;\n            }\n        }\n        return method;\n    }\n\n    private void generateDecodeMethod(JClassType classType,\n            final Style classStyle,\n            JsonTypeInfo typeInfo,\n            String railsWrapperName,\n            List<Subtype> possibleTypes,\n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {\n            generateEnumDecodeMethod(classType, JSON_VALUE_CLASS);\n            return;\n        }\n\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n            {\n                p(\"return null;\").i(-1);\n            }\n            p(\"}\");\n            if (classStyle == Style.RAILS) {\n                p(JSON_OBJECT_CLASS + \" object = toObjectFromWrapper(value, \\\"\" + railsWrapperName + \"\\\");\");\n            } else if (typeInfo != null && typeInfo.include() == As.WRAPPER_ARRAY) {\n                p(JSON_ARRAY_CLASS + \" array = (\" + JSON_ARRAY_CLASS + \")value;\");\n                if (!isLeaf)\n                    p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(array.get(0));\");\n                p(JSON_OBJECT_CLASS + \" object = toObject(array.get(1));\");\n            } else {\n                p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            }\n\n            if (!isLeaf && typeInfo != null && typeInfo.include() == As.PROPERTY) {\n                p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \"));\");\n            }\n\n            for (Subtype possibleType : possibleTypes) {\n\n                if (!possibleType.clazz.isAssignableTo(classType)) {\n                    getLogger().log(DEBUG, \"Only assignable classes are allowed: \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" is not assignable to: \" + classType.getParameterizedQualifiedSourceName());\n                    continue;\n                }\n\n                if (typeInfo != null) {\n                    if (typeInfo.include() == As.WRAPPER_OBJECT) {\n                        if (!isLeaf) {\n                            p(\"if(object.containsKey(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        }\n                        p(\"object = toObjectFromWrapper(value, \\\"\" + possibleType.tag + \"\\\");\");\n                    } else if (!isLeaf) {\n                        if (classType.equals(possibleType.clazz)) {\n                            p(\"if(sourceName == null || sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        } else {\n                            p(\"if(sourceName != null && sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        }\n                    }\n                }\n\n                if (possibleType.clazz.isEnum() != null) {\n                    generateEnumDecodeMethodBody(possibleType.clazz);\n                } else {\n                    // Try to find a constuctor that is annotated as creator\n                    final JConstructor creator = findCreator(possibleType.clazz);\n\n                    List<JField> orderedFields = null;\n                    if (creator != null) {\n                        p(\"// We found a creator so we use the annotated constructor\");\n                        p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"(\");\n                        i(1).p(\"// The arguments are placed in the order they appear within the annotated constructor\").i(-1);\n                        orderedFields = getOrderedFields(getFields(possibleType.clazz), creator);\n                        final JField lastField = orderedFields.get(orderedFields.size() - 1);\n                        for (final JField field : orderedFields) {\n                            branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                                @Override\n                                public Void execute() throws UnableToCompleteException {\n                                    Json jsonAnnotation = getAnnotation(field, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    String jsonName = field.getName();\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                    String defaultValue = getDefaultValue(field);\n                                    i(1).p(\"\" + (objectGetter + \" == null || \" + objectGetter + \" instanceof \" + JSON_NULL_CLASS + \" ? \" + defaultValue + \" : \" + expression + ((field != lastField) ? \", \" : \"\"))).i(-1);\n\n                                    return null;\n                                }\n                            });\n                        }\n                        p(\");\");\n                    }\n\n                    if (orderedFields == null){\n                        p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"();\");\n                    }\n\n                    for (final JField field : getFields(possibleType.clazz)) {\n\n                        boolean ignoreField = false;\n                        if(getAnnotation(possibleType.clazz, JsonIgnoreProperties.class) != null) {\n                            for(String s : getAnnotation(possibleType.clazz, JsonIgnoreProperties.class).value()) {\n                                if(s.equals(field.getName())) {\n                                    ignoreField = true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(ignoreField) {\n                            continue;\n                        }\n\n                        if (orderedFields != null && orderedFields.contains(field)){\n                            continue;\n                        }\n\n                        final String setterName = getSetterName(field);\n\n                        // If can ignore some fields right off the back..\n                        if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient())\n\t\t\t\t\t\t\t\t|| field.isAnnotationPresent(JsonIgnore.class) || field.isAnnotationPresent(XmlTransient.class)) {\n                            continue;\n                        }\n\n                        branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                            @Override\n                            public Void execute() throws UnableToCompleteException {\n\n                                // TODO: try to set the field with a setter\n                                // or JSNI\n                                if (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                                    Json jsonAnnotation = getAnnotation(field, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    JsonProperty jsonPropertyAnnotation = getAnnotation(field, JsonProperty.class);\n\n                                    String name = field.getName();\n                                    String jsonName = name;\n\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                                        jsonName = jsonPropertyAnnotation.value();\n                                    }\n\n                                    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                    boolean isShort = field.getType().isPrimitive() == JPrimitiveType.SHORT;\n                                    String defaultValue = getDefaultValue(field);\n\n                                    String methodName = isShort ? \"getValueToSetForShort\" : \"getValueToSet\";\n                                    \n                                    if (setterName != null) {\n                                    \tp(\"rc.\" + setterName + \"(\"  + methodName + \"(\" + expression + \", \" + defaultValue + \"));\");\n                                    } else {\n                                    \tp(\"rc.\" + name + \"= \" +  methodName + \"(\" + expression + \",\" + defaultValue + \");\");\n                                    }\n                                    \n                                } else {\n                                    getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                                }\n                                return null;\n                            }\n                        });\n                    }\n\n                    p(\"return rc;\");\n                }\n                if (typeInfo != null && !isLeaf) {\n                    p(\"}\");\n                }\n            }\n\n            if (typeInfo != null && !isLeaf) {\n                p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n            p();\n        }\n    }\n\n    private void generateEnumDecodeMethodBody(JClassType classType) {\n        p(JSON_VALUE_CLASS + \" str = object.get(\\\"name\\\");\");\n        p(\"if( null == str || str.isString() == null ) {\").i(1);\n        {\n            p(\"throw new DecodingException(\\\"Expected a string field called 'name' for enum; not found\\\");\").i(-1);\n        }\n        p(\"}\");\n        decodeEnum(classType, \"str.isString().stringValue()\");\n    }\n\n    private String getDefaultValue(JField field) {\n        return field.getType().isPrimitive() == null ? \"null\" : field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n    }\n\n    protected void generateEnumDecodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + classType.getName() + \" decode(\" + jsonValueClass + \" value) {\").i(1);\n        {\n        p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n        {\n            p(\"return null;\").i(-1);\n        }\n        p(\"}\");\n        p(JSON_STRING_CLASS + \" str = value.isString();\");\n        p(\"if( null == str ) {\").i(1);\n        {\n            p(\"throw new DecodingException(\\\"Expected a json string (for enum), but was given: \\\"+value);\").i(-1);\n        }\n        p(\"}\");\n\n        String value = \"str.stringValue()\";\n        decodeEnum(classType, value);\n        }\n        p(\"}\");\n        p();\n    }\n\n    protected void decodeEnum(JClassType classType, String value) {\n        String className = classType.getParameterizedQualifiedSourceName();\n        String method = getValueMethod(classType);\n        if ( method == null ) {\n            p(\"return Enum.valueOf(\" + className + \".class, \" + value + \");\").i(-1);\n        }\n        else {\n            p(\"for(\" + className + \" v: \" + className + \".values()) {\").i(1);\n            {\n                p(\"if(v.\" + method + \"().equals(\" + value + \")) {\").i(1);\n                {\n                    p(\"return v;\").i(-1);\n                }\n                p(\"}\").i(-1);\n            }\n            p(\"}\");\n            p(\"throw new DecodingException(\\\"can not find enum for given value: \\\"+\" + value + \");\").i(-1);\n        }\n    }\n\n    static public void clearRestyResolverClassMap() {\n    \tsTypeIdResolverMap = null;\n    }\n    \n    public static Map<Class<?>, RestyJsonTypeIdResolver> getRestyResolverClassMap(GeneratorContext context, TreeLogger logger) throws UnableToCompleteException {\n\tif (sTypeIdResolverMap == null) {\n\t    try {\n\t\tMap<Class<?>, RestyJsonTypeIdResolver> map = Maps.newHashMap();\n\t\tList<String> values = context.getPropertyOracle().getConfigurationProperty(\"org.fusesource.restygwt.jsontypeidresolver\").getValues();\n\t\tfor (String value : values)\n\t\t    try {\n\t\t\tClass<?> clazz = Class.forName(value);\n\t\t\tRestyJsonTypeIdResolver resolver = (RestyJsonTypeIdResolver) clazz.newInstance();\n\t\t\tmap.put(resolver.getTypeIdResolverClass(), resolver);\n\t\t    } catch (Exception e) {\n\t\t\tlogger.log(WARN, \"Could not access class: \" + values.get(0), e);\n\t\t    }\n\t\t    sTypeIdResolverMap = map;\n\t    } catch (BadPropertyValueException e) {\n\t\tlogger.log(ERROR, \"Could not acccess property: RestyJsonTypeIdResolver\", e);\n\t\tthrow new UnableToCompleteException();\n\t    }\n\t}\n\treturn sTypeIdResolverMap;\n    }\n\n    private List<JField> getOrderedFields(List<JField> fields, JConstructor creator) throws UnableToCompleteException {\n\tList<JField> orderedFields = new ArrayList<JField>();\n\tfor (JParameter param : creator.getParameters()) {\n\t    JsonProperty prop = getAnnotation(param, JsonProperty.class);\n\t    if (prop != null) {\n\t\tfor (JField field : fields) {\n\t\t    if (field.getName().equals(prop.value())) {\n\t\t\torderedFields.add(field);\n\t\t    }\n\t\t}\n\t    } else {\n\t\tgetLogger().log(ERROR, \"a constructor annotated with @JsonCreator requires that all paramaters are annotated with @JsonProperty.\");\n        throw new UnableToCompleteException();\n\t    }\n\t}\n\n\treturn orderedFields;\n    }\n\n    private JConstructor findCreator(JClassType sourceClazz) {\n\tfor (JConstructor constructor : sourceClazz.getConstructors()) {\n\t    if (getAnnotation(constructor, JsonCreator.class) != null) {\n\t\treturn constructor;\n\t    }\n\t}\n\n\treturn null;\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the setter for the specified field or null if a\n     *         setter can't be found.\n     */\n    private String getSetterName(JField field) {\n\tString fieldName = field.getName();\n\tfieldName = \"set\" + upperCaseFirstChar(fieldName);\n\tJClassType type = field.getEnclosingType();\n\tif (exists(type, field, fieldName, true)) {\n\t    return fieldName;\n\t}\n    return null;\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the getter for the specified field or null if a\n     *         getter can't be found.\n     */\n    private String getGetterName(JField field) {\n\tString fieldName = field.getName();\n\tJType booleanType = null;\n\ttry {\n\t    booleanType = find(Boolean.class, getLogger(), context);\n\t} catch (UnableToCompleteException e) {\n\t    // do nothing\n\t}\n\tJClassType type = field.getEnclosingType();\n\tif (field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)) {\n\t    if ( field instanceof DummyJField ) {\n\t        return ((DummyJField )field).getGetterMethod().getName();\n\t    }\n\t    fieldName = \"is\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t        return fieldName;\n\t    }\n\t    fieldName = \"has\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t        return fieldName;\n\t    }\n\t}\n\tfieldName = \"get\" + upperCaseFirstChar(field.getName());\n\tif (exists(type, field, fieldName, false)) {\n\t    return fieldName;\n\t}\n    return null;\n    }\n\n    private String upperCaseFirstChar(String in) {\n\tif (in.length() == 1) {\n\t    return in.toUpperCase();\n\t}\n    return in.substring(0, 1).toUpperCase() + in.substring(1);\n    }\n\n    /**\n     * checks whether a getter or setter exists on the specified type or any of\n     * its super classes excluding Object. respects JsonIgnore accordingly.\n     *\n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {\n        if ( field instanceof DummyJField ){\n               return true; \n        }\n\n\tJType[] args = null;\n\tif (isSetter) {\n\t    args = new JType[] { field.getType() };\n\t} else {\n\t    args = new JType[] {};\n\t}\n\tJMethod m = type.findMethod(fieldName, args);\n\tif (null != m) {\n        if(getAnnotation(m, JsonIgnore.class) != null)\n\t\t\treturn false;\n\t\tif (getAnnotation(m, XmlTransient.class) != null)\n\t\t\treturn false;\n        if(isSetter)\n            return true;\n        JClassType returnType = m.getReturnType().isClassOrInterface();\n        JClassType fieldType = field.getType().isClassOrInterface();\n        if(returnType == null || fieldType == null) {\n            // at least one is a primitive type\n            return m.getReturnType().equals(field.getType());\n        }\n        // both are non-primitives\n        return returnType.isAssignableFrom(fieldType);\n\t}\n    try {\n    JType objectType = find(Object.class, getLogger(), context);\n    JClassType superType = type.getSuperclass();\n    if (!objectType.equals(superType)) {\n        return exists(superType, field, fieldName, isSetter);\n    }\n    } catch (UnableToCompleteException e) {\n    // do nothing\n    }\n\treturn false;\n    }\n\n    /**\n     * Inspects the supplied type and all super classes up to but excluding\n     * Object and returns a list of all fields found in these classes.\n     *\n     * @param type\n     * @return\n     */\n    private List<JField> getFields(JClassType type) {\n        List<JField> allFields = getFields(new ArrayList<JField>(), type);\n        Map<String, JMethod> getters = new HashMap<String, JMethod>();\n        Map<String, JType> setters = new HashMap<String, JType>();\n\n        JType booleanType = null;\n        try {\n            booleanType = find(Boolean.class, getLogger(), context);\n        } catch (UnableToCompleteException e) {\n            // do nothing\n        }\n        for( JMethod m: type.getInheritableMethods() ){\n            if( m.getName().startsWith(\"set\") &&\n                    m.getParameterTypes().length == 1 &&\n                    m.getReturnType() == JPrimitiveType.VOID &&\n\t\t\t\t\tgetAnnotation(m, JsonIgnore.class) == null && \n\t\t\t\t\tgetAnnotation(m, XmlTransient.class) == null) {\n                setters.put( m.getName().replaceFirst(\"^set\", \"\"), m.getParameterTypes()[0] );\n            }\n            else if( m.getName().startsWith(\"get\") &&\n                    m.getParameterTypes().length == 0 &&\n                    m.getReturnType() != JPrimitiveType.VOID &&\n\t\t\t\t\tgetAnnotation(m, JsonIgnore.class) == null && \n\t\t\t\t\tgetAnnotation(m, XmlTransient.class) == null) {\n                getters.put( m.getName().replaceFirst(\"^get\", \"\"), m );\n            }\n            else if( m.getName().startsWith(\"is\") &&\n                    m.getParameterTypes().length == 0 &&\n                    ( m.getReturnType() == JPrimitiveType.BOOLEAN || m.getReturnType().equals(booleanType) ) &&\n                    getAnnotation(m, JsonIgnore.class) == null && \n                    getAnnotation(m, XmlTransient.class) == null) {\n                getters.put( m.getName().replaceFirst(\"^is\", \"\"), m );\n            }\n            else if( m.getName().startsWith(\"has\") &&\n                    m.getParameterTypes().length == 0 &&\n                    ( m.getReturnType() == JPrimitiveType.BOOLEAN || m.getReturnType().equals(booleanType) ) &&\n                    getAnnotation(m, JsonIgnore.class) == null && \n                    getAnnotation(m, XmlTransient.class) == null) {\n                getters.put( m.getName().replaceFirst(\"^has\", \"\"), m );\n            }\n        }\n        for( Map.Entry<String, JMethod> entry: getters.entrySet() ){\n            final JMethod getter = entry.getValue();\n\n            if ( setters.containsKey( entry.getKey() ) && setters.get( entry.getKey() ).equals( getter.getReturnType() ) ) {\n                String name = entry.getKey().substring(0, 1).toLowerCase() + entry.getKey().substring(1);\n                boolean found = false;\n                for( JField f : allFields ){\n                    if( f.getName().equals( name ) ){\n                        found = true;\n                        break;\n                    }\n                }\n                JField f = type.findField( name );\n                // is getter annotated, if yes use this annotation for the field\n                JsonProperty propName = null;\n                if ( getter.isAnnotationPresent(JsonProperty.class) ) {\n                    propName = getAnnotation(getter, JsonProperty.class);\n                }\n                // is setter annotated, if yes use this annotation for the field\n                JMethod m = type.findMethod(\"s\" + getter.getName().substring(1),\n                        new JType[]{ getter.getReturnType() });\n                if ( m != null && m.isAnnotationPresent(JsonProperty.class) ) {\n                    propName = getAnnotation(m, JsonProperty.class);\n                }\n                // if have a field and an annotation from the getter/setter then use that annotation \n                if ( propName != null && found && !f.getName().equals(propName.value())) {\n                    allFields.remove(f);\n                    DummyJField dummy = new DummyJField( name, getter.getReturnType(), getter );\n                    dummy.setAnnotation( propName );\n                    allFields.add(dummy);\n                }\n                if ( ! found && !( f != null && f.isAnnotationPresent( JsonIgnore.class ) ) ){\n                    DummyJField dummy = new DummyJField( name, getter.getReturnType(), getter );\n                    if ( getter.isAnnotationPresent(JsonProperty.class) ) {\n                        dummy.setAnnotation( getAnnotation(getter, JsonProperty.class) );\n                    }\n                    allFields.add( dummy );\n                }\n            }\n        }\n        return allFields;\n    }\n\n    private List<JField> getFields(List<JField> allFields, JClassType type) {\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n\t\t\tif (!field.isTransient() && !field.isAnnotationPresent(JsonIgnore.class) &&\n\t\t\t\t\t!field.isAnnotationPresent(XmlTransient.class)) {\n                allFields.add(field);\n            }\n        }\n        try {\n            JType objectType = find(Object.class, getLogger(), context);\n            if (!objectType.equals(type)) {\n                JClassType superType = type.getSuperclass();\n                return getFields(allFields, superType);\n            }\n        }\n        catch (UnableToCompleteException e) {\n\t    // do nothing\n        }\n\n    \treturn allFields;\n    }\n\n    public static String getTypeInfoPropertyValue(final JsonTypeInfo typeInfo)\n    {\n        if (typeInfo.include() == JsonTypeInfo.As.PROPERTY)\n            if(typeInfo.property() == null || \"\".equals(typeInfo.property()))\n                return typeInfo.use().getDefaultPropertyName();\n\n        return typeInfo.property();\n    }\n\n    public static boolean isLeaf(JClassType source)\n    {\n        return !(source.getSubtypes() != null && source.getSubtypes().length > 0);\n    }\n\n    public static class Subtype implements Comparable<Subtype> {\n    final String tag;\n    final JClassType clazz;\n\n    public Subtype(String tag, JClassType clazz) {\n        this.tag = tag;\n        this.clazz = clazz;\n    }\n\n    @Override\n    public int compareTo(Subtype o) {\n        return tag.compareTo(o.tag);\n    }\n    }\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> sTypeIdResolverMap = null;\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\nimport static org.fusesource.restygwt.rebind.util.AnnotationUtils.*;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonSubTypes;\nimport com.fasterxml.jackson.annotation.JsonSubTypes.Type;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.As;\nimport com.fasterxml.jackson.annotation.JsonValue;\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JConstructor;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONNull;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONString;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.thirdparty.guava.common.collect.Lists;\nimport com.google.gwt.thirdparty.guava.common.collect.Maps;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport javax.xml.bind.annotation.XmlTransient;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added getter + setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n *\n *         added polymorphic support\n * @author <a href=\"http://charliemason.info\">Charlie Mason<\/a>\n *\n */\n\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n    protected static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_NULL_CLASS = JSONNull.class.getName();\n    protected static final String JSON_STRING_CLASS = JSONString.class.getName();\n\n    protected JsonEncoderDecoderInstanceLocator locator;\n\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    @Override\n    public void generate() throws UnableToCompleteException {\n        final JsonTypeInfo typeInfo = getClassAnnotation(source, JsonTypeInfo.class);\n        final boolean isLeaf = isLeaf(source);\n\n        final List<Subtype> possibleTypes = getPossibleTypes(typeInfo, isLeaf);\n        Collections.sort(possibleTypes);\n\n        final JClassType sourceClazz = source.isClass() == null ? source.isInterface() : source.isClass();\n        if (sourceClazz == null) {\n            getLogger().log(ERROR, \"Type is not a class\");\n            throw new UnableToCompleteException();\n        }\n\n\t\tif (sourceClazz.isEnum() == null && sourceClazz.isAbstract()) {\n            if (typeInfo == null) {\n                getLogger().log(ERROR, \"Abstract classes must be annotated with JsonTypeInfo\");\n                throw new UnableToCompleteException();\n            }\n        }\n        Json jsonAnnotation = getAnnotation(source, Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n        final String railsWrapperName = jsonAnnotation != null && jsonAnnotation.name().length() > 0 ? jsonAnnotation.name() : sourceClazz.getName().toLowerCase();\n        locator = new JsonEncoderDecoderInstanceLocator(context, getLogger());\n\n        generateSingleton(shortName);\n\n        generateEncodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n\n        generateDecodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n\tClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n\tcomposerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n\treturn composerFactory;\n    }\n\n    private List<Subtype> getPossibleTypes(final JsonTypeInfo typeInfo, final boolean isLeaf) throws UnableToCompleteException\n    {\n        if (typeInfo == null)\n            return Lists.newArrayList(new Subtype(null, source));\n        Collection<Type> subTypes = findJsonSubTypes(source);\n        if(subTypes.isEmpty()) {\n            JsonSubTypes foundAnnotation = getAnnotation(source, JsonSubTypes.class);\n            if(foundAnnotation != null) {\n                Type[] value = foundAnnotation.value();\n                subTypes = Arrays.asList(value);\n            }\n        }\n        PossibleTypesVisitor v = new PossibleTypesVisitor(context, source, isLeaf, getLogger(), subTypes);\n        return v.visit(typeInfo.use());\n    }\n\n    /**\n     * This method does NOT return the subtypes of the given class, but all the subtypes associated with the\n     * {@link com.fasterxml.jackson.annotation.JsonSubTypes} annotation, even if this annotation is assigned to\n     * a parent class or an interface.\n     */\n    private Collection<Type> findJsonSubTypes(JClassType clazz) {\n        return findJsonSubTypes(clazz, new HashSet<JsonSubTypes.Type>());\n    }\n    \n    private Collection<Type> findJsonSubTypes(JClassType clazz, Set<Type> types) {\n        if (clazz == null) {\n            return Collections.emptyList();\n        }\n        JsonSubTypes annotation = getClassAnnotation(clazz, JsonSubTypes.class);\n            \n        if (annotation == null) {\n            return Collections.emptyList();\n        }\n\n        for (Type type : annotation.value()) {\n            if (types.add(type)) {\n                Class<?> subclazz = type.value();\n                String newSubClassName = subclazz.getName().replaceAll(\"\\\\$\", \".\");\n                JClassType subJClazz = context.getTypeOracle().findType(newSubClassName);\n                findJsonSubTypes(subJClazz, types);\n            }\n        }\n\n        return types;\n    }\n\n    protected void generateSingleton(String shortName)\n    {\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n    }\n\n    private void generateEncodeMethod(JClassType classType,\n            final Style classStyle,\n            JsonTypeInfo typeInfo,\n            String railsWrapperName,\n            List<Subtype> possibleTypes,\n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {\n            generateEnumEncodeMethod(classType, JSON_VALUE_CLASS);\n            return;\n        }\n\n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return getNullType();\");\n            }\n            i(-1).p(\"}\");\n\n            boolean returnWrapper = false; // if set, return rrc\n\n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n            if (classStyle == Style.RAILS) {\n                returnWrapper = true;\n                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                p(\"rrc.put(\\\"\" + railsWrapperName + \"\\\" , rc);\");\n            }\n\n            for (Subtype possibleType : possibleTypes) {\n\n                if (!possibleType.clazz.isAssignableTo(classType)) {\n                    getLogger().log(DEBUG, \"Only assignable classes are allowed: \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" is not assignable to: \" + classType.getParameterizedQualifiedSourceName());\n                    continue;\n                }\n\n                if (!isLeaf) {\n                    // Generate a decoder for each possible type\n                    p(\"if(value.getClass().getName().equals(\\\"\" + possibleType.clazz.getQualifiedBinaryName() + \"\\\"))\");\n                    p(\"{\");\n                }\n\n                if (possibleType.clazz.isEnum() != null) {\n                    generateEnumEncodeMethodBody(possibleType, typeInfo);\n                } else {\n\n                    // Try to find a constructor that is annotated as creator\n                    final JConstructor creator = findCreator(possibleType.clazz);\n\n                    List<JField> orderedFields = creator == null ? null : getOrderedFields(getFields(possibleType.clazz), creator);\n\n                    if (typeInfo != null) {\n                        switch (typeInfo.include()) {\n                            case PROPERTY:\n                                p(\"com.google.gwt.json.client.JSONValue className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\");\");\n                                p(\"if( className!=null ) { \").i(1);\n                                p(\"rc.put(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \", className);\");\n                                i(-1).p(\"}\");\n                                break;\n                            case WRAPPER_OBJECT:\n                                returnWrapper = true;\n                                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                                p(\"rrc.put(\\\"\" + possibleType.tag + \"\\\", rc);\");\n                                break;\n                            case WRAPPER_ARRAY:\n                                returnWrapper = true;\n                                p(JSON_ARRAY_CLASS + \" rrc = new \" + JSON_ARRAY_CLASS + \"();\");\n                                p(\"rrc.set(0, org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\"));\");\n                                p(\"rrc.set(1, rc);\");\n                                break;\n                            case EXISTING_PROPERTY:\n                                getLogger().log(WARN, classType + \" comes with not implemented type info 'as' \" + JsonTypeInfo.As.EXISTING_PROPERTY );\n                                // not implemented\n                                break;\n                            case EXTERNAL_PROPERTY:\n                                getLogger().log(WARN, classType + \" comes with not implemented type info 'as' \" + JsonTypeInfo.As.EXTERNAL_PROPERTY );\n                                // not implemented\n                                break;\n                            default:\n                        }\n                    }\n\n                    p(possibleType.clazz.getParameterizedQualifiedSourceName() + \" parseValue = (\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \")value;\");\n\n                    for (final JField field : getFields(possibleType.clazz)) {\n\n                        final String getterName = getGetterName(field);\n\n                        boolean ignoreField = false;\n                        if(getAnnotation(possibleType.clazz, JsonIgnoreProperties.class) != null) {\n                            for(String s : getAnnotation(possibleType.clazz, JsonIgnoreProperties.class).value()) {\n                                if(s.equals(field.getName())) {\n                                    ignoreField = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        // If can ignore some fields right off the back..\n                        // if there is a creator encode only final fields with JsonProperty annotation\n                        if (ignoreField || getterName == null && (field.isStatic() || (field.isFinal() && !(creator != null && orderedFields.contains(field))) || field.isTransient()\n\t\t\t\t\t\t\t\t|| field.isAnnotationPresent(JsonIgnore.class) || field.isAnnotationPresent(XmlTransient.class))) {\n                            continue;\n                        }\n\n                        branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                            @Override\n                            public Void execute() throws UnableToCompleteException {\n                                // TODO: try to get the field with a setter or\n                                // JSNI\n                                if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                                    Json jsonAnnotation = getAnnotation(field, Json.class);\n                                    JsonProperty jsonPropertyAnnotation = getAnnotation(field, JsonProperty.class);\n\n                                    String name = field.getName();\n                                    String jsonName = name;\n\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                                        jsonName = jsonPropertyAnnotation.value();\n                                    }\n\n                                    String fieldExpr = \"parseValue.\" + name;\n                                    if (getterName != null) {\n                                        fieldExpr = \"parseValue.\" + getterName + \"()\";\n                                    }\n\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    String expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n\n                                    \n                                    if (null != field.getType().isEnum()) {\n                                    \tp(\"if(isNotNullAndCheckDefaults(\" + fieldExpr+ \", rc, \"+ wrap(jsonName) + \")) {\").i(1);\n                                    }\n                                        \n                                    p(\"isNotNullValuePut(\" + expression + \", rc, \"+ wrap(jsonName) + \");\");\n\n                                    if (null != field.getType().isEnum()) {\n                                    \ti(-1).p(\"}\");\n                                    }\n                                    \n\n                                } else {\n                                    getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                                }\n                                return null;\n                            }\n                        });\n\n                    }\n\n                    if (returnWrapper) {\n                        p(\"return rrc;\");\n                    } else {\n                        p(\"return rc;\");\n                    }\n                }\n                if (!isLeaf) {\n                    p(\"}\");\n                }\n            }\n\n            if (!isLeaf) {\n                // Shouldn't get called\n                p(\"return null;\");\n            }\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n\n    private void generateEnumEncodeMethodBody(final Subtype possibleType, final JsonTypeInfo typeInfo) {\n        p(\"if( value==null ) {\").i(1);\n        {\n            p(\"return \" + JSON_NULL_CLASS + \".getInstance();\").i(-1);\n        }\n        p(\"}\");\n        p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n        p(JSON_VALUE_CLASS + \" className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\"\n                + possibleType.tag + \"\\\");\");\n        p(\"rrc.put(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \", className);\");\n        p(\"rrc.put(\\\"name\\\", new \" + JSON_STRING_CLASS + \"(value.\" + getValueMethod(possibleType.clazz) + \"()));\");\n        p(\"return rrc;\");\n    }\n\n    private void generateEnumEncodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + jsonValueClass + \" encode(\" + classType.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return \" + JSON_NULL_CLASS + \".getInstance();\").i(-1);\n            }\n            p(\"}\");\n            p(\"return new \" + JSON_STRING_CLASS + \"(value.\" + getValueMethod(classType) + \"());\");\n            i(-1).p(\"}\");\n        }\n        p();\n    }\n\n    protected String getValueMethod(JClassType classType) {\n        String method = \"name\";\n        for(JMethod jm : classType.isEnum().getMethods() ) {\n            if (jm.isAnnotationPresent(JsonValue.class)) {\n                method = jm.getName();\n                break;\n            }\n        }\n        return method;\n    }\n\n    private void generateDecodeMethod(JClassType classType,\n            final Style classStyle,\n            JsonTypeInfo typeInfo,\n            String railsWrapperName,\n            List<Subtype> possibleTypes,\n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {\n            generateEnumDecodeMethod(classType, JSON_VALUE_CLASS);\n            return;\n        }\n\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n            {\n                p(\"return null;\").i(-1);\n            }\n            p(\"}\");\n            if (classStyle == Style.RAILS) {\n                p(JSON_OBJECT_CLASS + \" object = toObjectFromWrapper(value, \\\"\" + railsWrapperName + \"\\\");\");\n            } else if (typeInfo != null && typeInfo.include() == As.WRAPPER_ARRAY) {\n                p(JSON_ARRAY_CLASS + \" array = (\" + JSON_ARRAY_CLASS + \")value;\");\n                if (!isLeaf)\n                    p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(array.get(0));\");\n                p(JSON_OBJECT_CLASS + \" object = toObject(array.get(1));\");\n            } else {\n                p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            }\n\n            if (!isLeaf && typeInfo != null && typeInfo.include() == As.PROPERTY) {\n                p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \"));\");\n            }\n\n            for (Subtype possibleType : possibleTypes) {\n\n                if (!possibleType.clazz.isAssignableTo(classType)) {\n                    getLogger().log(DEBUG, \"Only assignable classes are allowed: \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" is not assignable to: \" + classType.getParameterizedQualifiedSourceName());\n                    continue;\n                }\n\n                if (typeInfo != null) {\n                    if (typeInfo.include() == As.WRAPPER_OBJECT) {\n                        if (!isLeaf) {\n                            p(\"if(object.containsKey(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        }\n                        p(\"object = toObjectFromWrapper(value, \\\"\" + possibleType.tag + \"\\\");\");\n                    } else if (!isLeaf) {\n                        if (classType.equals(possibleType.clazz)) {\n                            p(\"if(sourceName == null || sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        } else {\n                            p(\"if(sourceName != null && sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        }\n                    }\n                }\n\n                if (possibleType.clazz.isEnum() != null) {\n                    generateEnumDecodeMethodBody(possibleType.clazz);\n                } else {\n                    // Try to find a constuctor that is annotated as creator\n                    final JConstructor creator = findCreator(possibleType.clazz);\n\n                    List<JField> orderedFields = null;\n                    if (creator != null) {\n                        p(\"// We found a creator so we use the annotated constructor\");\n                        p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"(\");\n                        i(1).p(\"// The arguments are placed in the order they appear within the annotated constructor\").i(-1);\n                        orderedFields = getOrderedFields(getFields(possibleType.clazz), creator);\n                        final JField lastField = orderedFields.get(orderedFields.size() - 1);\n                        for (final JField field : orderedFields) {\n                            branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                                @Override\n                                public Void execute() throws UnableToCompleteException {\n                                    Json jsonAnnotation = getAnnotation(field, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    String jsonName = field.getName();\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                    String defaultValue = getDefaultValue(field);\n                                    i(1).p(\"\" + (objectGetter + \" == null || \" + objectGetter + \" instanceof \" + JSON_NULL_CLASS + \" ? \" + defaultValue + \" : \" + expression + ((field != lastField) ? \", \" : \"\"))).i(-1);\n\n                                    return null;\n                                }\n                            });\n                        }\n                        p(\");\");\n                    }\n\n                    if (orderedFields == null){\n                        p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"();\");\n                    }\n\n                    for (final JField field : getFields(possibleType.clazz)) {\n\n                        boolean ignoreField = false;\n                        if(getAnnotation(possibleType.clazz, JsonIgnoreProperties.class) != null) {\n                            for(String s : getAnnotation(possibleType.clazz, JsonIgnoreProperties.class).value()) {\n                                if(s.equals(field.getName())) {\n                                    ignoreField = true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(ignoreField) {\n                            continue;\n                        }\n\n                        if (orderedFields != null && orderedFields.contains(field)){\n                            continue;\n                        }\n\n                        final String setterName = getSetterName(field);\n\n                        // If can ignore some fields right off the back..\n                        if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient())\n\t\t\t\t\t\t\t\t|| field.isAnnotationPresent(JsonIgnore.class) || field.isAnnotationPresent(XmlTransient.class)) {\n                            continue;\n                        }\n\n                        branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                            @Override\n                            public Void execute() throws UnableToCompleteException {\n\n                                // TODO: try to set the field with a setter\n                                // or JSNI\n                                if (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                                    Json jsonAnnotation = getAnnotation(field, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    JsonProperty jsonPropertyAnnotation = getAnnotation(field, JsonProperty.class);\n\n                                    String name = field.getName();\n                                    String jsonName = name;\n\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                                        jsonName = jsonPropertyAnnotation.value();\n                                    }\n\n                                    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                    boolean isShort = field.getType().isPrimitive() == JPrimitiveType.SHORT;\n                                    String defaultValue = getDefaultValue(field);\n\n                                    String methodName = isShort ? \"getValueToSetForShort\" : \"getValueToSet\";\n                                    \n                                    if (setterName != null) {\n                                    \tp(\"rc.\" + setterName + \"(\"  + methodName + \"(\" + expression + \", \" + defaultValue + \"));\");\n                                    } else {\n                                    \tp(\"rc.\" + name + \"= \" +  methodName + \"(\" + expression + \",\" + defaultValue + \");\");\n                                    }\n                                    \n                                } else {\n                                    getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                                }\n                                return null;\n                            }\n                        });\n                    }\n\n                    p(\"return rc;\");\n                }\n                if (typeInfo != null && !isLeaf) {\n                    p(\"}\");\n                }\n            }\n\n            if (typeInfo != null && !isLeaf) {\n                p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n            p();\n        }\n    }\n\n    private void generateEnumDecodeMethodBody(JClassType classType) {\n        p(JSON_VALUE_CLASS + \" str = object.get(\\\"name\\\");\");\n        p(\"if( null == str || str.isString() == null ) {\").i(1);\n        {\n            p(\"throw new DecodingException(\\\"Expected a string field called 'name' for enum; not found\\\");\").i(-1);\n        }\n        p(\"}\");\n        decodeEnum(classType, \"str.isString().stringValue()\");\n    }\n\n    private String getDefaultValue(JField field) {\n        return field.getType().isPrimitive() == null ? \"null\" : field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n    }\n\n    protected void generateEnumDecodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + classType.getName() + \" decode(\" + jsonValueClass + \" value) {\").i(1);\n        {\n        p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n        {\n            p(\"return null;\").i(-1);\n        }\n        p(\"}\");\n        p(JSON_STRING_CLASS + \" str = value.isString();\");\n        p(\"if( null == str ) {\").i(1);\n        {\n            p(\"throw new DecodingException(\\\"Expected a json string (for enum), but was given: \\\"+value);\").i(-1);\n        }\n        p(\"}\");\n\n        String value = \"str.stringValue()\";\n        decodeEnum(classType, value);\n        }\n        p(\"}\");\n        p();\n    }\n\n    protected void decodeEnum(JClassType classType, String value) {\n        String className = classType.getParameterizedQualifiedSourceName();\n        String method = getValueMethod(classType);\n        if ( method == null ) {\n            p(\"return Enum.valueOf(\" + className + \".class, \" + value + \");\").i(-1);\n        }\n        else {\n            p(\"for(\" + className + \" v: \" + className + \".values()) {\").i(1);\n            {\n                p(\"if(v.\" + method + \"().equals(\" + value + \")) {\").i(1);\n                {\n                    p(\"return v;\").i(-1);\n                }\n                p(\"}\").i(-1);\n            }\n            p(\"}\");\n            p(\"throw new DecodingException(\\\"can not find enum for given value: \\\"+\" + value + \");\").i(-1);\n        }\n    }\n\n    static public void clearRestyResolverClassMap() {\n    \tsTypeIdResolverMap = null;\n    }\n    \n    public static Map<Class<?>, RestyJsonTypeIdResolver> getRestyResolverClassMap(GeneratorContext context, TreeLogger logger) throws UnableToCompleteException {\n\tif (sTypeIdResolverMap == null) {\n\t    try {\n\t\tMap<Class<?>, RestyJsonTypeIdResolver> map = Maps.newHashMap();\n\t\tList<String> values = context.getPropertyOracle().getConfigurationProperty(\"org.fusesource.restygwt.jsontypeidresolver\").getValues();\n\t\tfor (String value : values)\n\t\t    try {\n\t\t\tClass<?> clazz = Class.forName(value);\n\t\t\tRestyJsonTypeIdResolver resolver = (RestyJsonTypeIdResolver) clazz.newInstance();\n\t\t\tmap.put(resolver.getTypeIdResolverClass(), resolver);\n\t\t    } catch (Exception e) {\n\t\t\tlogger.log(WARN, \"Could not access class: \" + values.get(0), e);\n\t\t    }\n\t\t    sTypeIdResolverMap = map;\n\t    } catch (BadPropertyValueException e) {\n\t\tlogger.log(ERROR, \"Could not acccess property: RestyJsonTypeIdResolver\", e);\n\t\tthrow new UnableToCompleteException();\n\t    }\n\t}\n\treturn sTypeIdResolverMap;\n    }\n\n    private List<JField> getOrderedFields(List<JField> fields, JConstructor creator) throws UnableToCompleteException {\n\tList<JField> orderedFields = new ArrayList<JField>();\n\tfor (JParameter param : creator.getParameters()) {\n\t    JsonProperty prop = getAnnotation(param, JsonProperty.class);\n\t    if (prop != null) {\n\t\tfor (JField field : fields) {\n\t\t    if (field.getName().equals(prop.value())) {\n\t\t\torderedFields.add(field);\n\t\t    }\n\t\t}\n\t    } else {\n\t\tgetLogger().log(ERROR, \"a constructor annotated with @JsonCreator requires that all paramaters are annotated with @JsonProperty.\");\n        throw new UnableToCompleteException();\n\t    }\n\t}\n\n\treturn orderedFields;\n    }\n\n    private JConstructor findCreator(JClassType sourceClazz) {\n\tfor (JConstructor constructor : sourceClazz.getConstructors()) {\n\t    if (getAnnotation(constructor, JsonCreator.class) != null) {\n\t\treturn constructor;\n\t    }\n\t}\n\n\treturn null;\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the setter for the specified field or null if a\n     *         setter can't be found.\n     */\n    private String getSetterName(JField field) {\n\tString fieldName = field.getName();\n\tfieldName = \"set\" + upperCaseFirstChar(fieldName);\n\tJClassType type = field.getEnclosingType();\n\tif (exists(type, field, fieldName, true)) {\n\t    return fieldName;\n\t}\n    return null;\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the getter for the specified field or null if a\n     *         getter can't be found.\n     */\n    private String getGetterName(JField field) {\n\tString fieldName = field.getName();\n\tJType booleanType = null;\n\ttry {\n\t    booleanType = find(Boolean.class, getLogger(), context);\n\t} catch (UnableToCompleteException e) {\n\t    // do nothing\n\t}\n\tJClassType type = field.getEnclosingType();\n\tif (field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)) {\n\t    if ( field instanceof DummyJField ) {\n\t        return ((DummyJField )field).getGetterMethod().getName();\n\t    }\n\t    fieldName = \"is\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t        return fieldName;\n\t    }\n\t    fieldName = \"has\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t        return fieldName;\n\t    }\n\t}\n\tfieldName = \"get\" + upperCaseFirstChar(field.getName());\n\tif (exists(type, field, fieldName, false)) {\n\t    return fieldName;\n\t}\n    return null;\n    }\n\n    private String upperCaseFirstChar(String in) {\n\tif (in.length() == 1) {\n\t    return in.toUpperCase();\n\t}\n    return in.substring(0, 1).toUpperCase() + in.substring(1);\n    }\n\n    /**\n     * checks whether a getter or setter exists on the specified type or any of\n     * its super classes excluding Object. respects JsonIgnore accordingly.\n     *\n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {\n        if ( field instanceof DummyJField ){\n               return true; \n        }\n\n\tJType[] args = null;\n\tif (isSetter) {\n\t    args = new JType[] { field.getType() };\n\t} else {\n\t    args = new JType[] {};\n\t}\n\tJMethod m = type.findMethod(fieldName, args);\n\tif (null != m) {\n        if(getAnnotation(m, JsonIgnore.class) != null)\n\t\t\treturn false;\n\t\tif (getAnnotation(m, XmlTransient.class) != null)\n\t\t\treturn false;\n        if(isSetter)\n            return true;\n        JClassType returnType = m.getReturnType().isClassOrInterface();\n        JClassType fieldType = field.getType().isClassOrInterface();\n        if(returnType == null || fieldType == null) {\n            // at least one is a primitive type\n            return m.getReturnType().equals(field.getType());\n        }\n        // both are non-primitives\n        return returnType.isAssignableFrom(fieldType);\n\t}\n    try {\n    JType objectType = find(Object.class, getLogger(), context);\n    JClassType superType = type.getSuperclass();\n    if (!objectType.equals(superType)) {\n        return exists(superType, field, fieldName, isSetter);\n    }\n    } catch (UnableToCompleteException e) {\n    // do nothing\n    }\n\treturn false;\n    }\n\n    /**\n     * Inspects the supplied type and all super classes up to but excluding\n     * Object and returns a list of all fields found in these classes.\n     *\n     * @param type\n     * @return\n     */\n    private List<JField> getFields(JClassType type) {\n        List<JField> allFields = getFields(new ArrayList<JField>(), type);\n        Map<String, JMethod> getters = new HashMap<String, JMethod>();\n        Map<String, JType> setters = new HashMap<String, JType>();\n\n        JType booleanType = null;\n        try {\n            booleanType = find(Boolean.class, getLogger(), context);\n        } catch (UnableToCompleteException e) {\n            // do nothing\n        }\n        for( JMethod m: type.getInheritableMethods() ){\n            if( m.getName().startsWith(\"set\") &&\n                    m.getParameterTypes().length == 1 &&\n                    m.getReturnType() == JPrimitiveType.VOID &&\n\t\t\t\t\tgetAnnotation(m, JsonIgnore.class) == null && \n\t\t\t\t\tgetAnnotation(m, XmlTransient.class) == null) {\n                setters.put( m.getName().replaceFirst(\"^set\", \"\"), m.getParameterTypes()[0] );\n            }\n            else if( m.getName().startsWith(\"get\") &&\n                    m.getParameterTypes().length == 0 &&\n                    m.getReturnType() != JPrimitiveType.VOID &&\n\t\t\t\t\tgetAnnotation(m, JsonIgnore.class) == null && \n\t\t\t\t\tgetAnnotation(m, XmlTransient.class) == null) {\n                getters.put( m.getName().replaceFirst(\"^get\", \"\"), m );\n            }\n            else if( m.getName().startsWith(\"is\") &&\n                    m.getParameterTypes().length == 0 &&\n                    ( m.getReturnType() == JPrimitiveType.BOOLEAN || m.getReturnType().equals(booleanType) ) &&\n                    getAnnotation(m, JsonIgnore.class) == null && \n                    getAnnotation(m, XmlTransient.class) == null) {\n                getters.put( m.getName().replaceFirst(\"^is\", \"\"), m );\n            }\n            else if( m.getName().startsWith(\"has\") &&\n                    m.getParameterTypes().length == 0 &&\n                    ( m.getReturnType() == JPrimitiveType.BOOLEAN || m.getReturnType().equals(booleanType) ) &&\n                    getAnnotation(m, JsonIgnore.class) == null && \n                    getAnnotation(m, XmlTransient.class) == null) {\n                getters.put( m.getName().replaceFirst(\"^has\", \"\"), m );\n            }\n        }\n        for( Map.Entry<String, JMethod> entry: getters.entrySet() ){\n            if ( setters.containsKey( entry.getKey() ) && setters.get( entry.getKey() ).equals( entry.getValue().getReturnType() ) ) {\n                String name = entry.getKey().substring(0, 1).toLowerCase() + entry.getKey().substring(1);\n                boolean found = false;\n                for( JField f : allFields ){\n                    if( f.getName().equals( name ) ){\n                        found = true;\n                        break;\n                    }\n                }\n                JField f = type.findField( name );\n                // is getter annotated, if yes use this annotation for the field\n                JsonProperty propName = null;\n                if ( entry.getValue().isAnnotationPresent(JsonProperty.class) ) {\n                    propName = getAnnotation(entry.getValue(), JsonProperty.class);\n                }\n                // is setter annotated, if yes use this annotation for the field\n                JMethod m = type.findMethod(\"s\" + entry.getValue().getName().substring(1),\n                        new JType[]{ entry.getValue().getReturnType() });\n                if ( m != null && m.isAnnotationPresent(JsonProperty.class) ) {\n                    propName = getAnnotation(m, JsonProperty.class);\n                }\n                // if have a field and an annotation from the getter/setter then use that annotation \n                if ( propName != null && found && !f.getName().equals(propName.value())) {\n                    allFields.remove(f);\n                    DummyJField dummy = new DummyJField( name, entry.getValue().getReturnType(), entry.getValue() );\n                    dummy.setAnnotation( propName );\n                    allFields.add(dummy);\n                }\n                if ( ! found && !( f != null && f.isAnnotationPresent( JsonIgnore.class ) ) ){\n                    DummyJField dummy = new DummyJField( name, entry.getValue().getReturnType(), entry.getValue() );\n                    if ( entry.getValue().isAnnotationPresent(JsonProperty.class) ) {\n                        dummy.setAnnotation( getAnnotation(entry.getValue(), JsonProperty.class) );\n                    }\n                    allFields.add( dummy );\n                }\n            }\n        }\n        return allFields;\n    }\n\n    private List<JField> getFields(List<JField> allFields, JClassType type) {\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n\t\t\tif (!field.isTransient() && !field.isAnnotationPresent(JsonIgnore.class) &&\n\t\t\t\t\t!field.isAnnotationPresent(XmlTransient.class)) {\n                allFields.add(field);\n            }\n        }\n        try {\n            JType objectType = find(Object.class, getLogger(), context);\n            if (!objectType.equals(type)) {\n                JClassType superType = type.getSuperclass();\n                return getFields(allFields, superType);\n            }\n        }\n        catch (UnableToCompleteException e) {\n\t    // do nothing\n        }\n\n    \treturn allFields;\n    }\n\n    public static String getTypeInfoPropertyValue(final JsonTypeInfo typeInfo)\n    {\n        if (typeInfo.include() == JsonTypeInfo.As.PROPERTY)\n            if(typeInfo.property() == null || \"\".equals(typeInfo.property()))\n                return typeInfo.use().getDefaultPropertyName();\n\n        return typeInfo.property();\n    }\n\n    public static boolean isLeaf(JClassType source)\n    {\n        return !(source.getSubtypes() != null && source.getSubtypes().length > 0);\n    }\n\n    public static class Subtype implements Comparable<Subtype> {\n    final String tag;\n    final JClassType clazz;\n\n    public Subtype(String tag, JClassType clazz) {\n        this.tag = tag;\n        this.clazz = clazz;\n    }\n\n    @Override\n    public int compareTo(Subtype o) {\n        return tag.compareTo(o.tag);\n    }\n    }\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> sTypeIdResolverMap = null;\n}\n","lineNo":858}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2011 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.fusesource.restygwt.rebind;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport org.fusesource.restygwt.client.RestService;\nimport org.fusesource.restygwt.rebind.util.AnnotationCopyUtil;\nimport org.fusesource.restygwt.rebind.util.AnnotationUtils;\nimport org.fusesource.restygwt.rebind.util.OnceFirstIterator;\n\nimport java.lang.annotation.Annotation;\n\nimport static org.fusesource.restygwt.rebind.DirectRestServiceClassCreator.isVoidMethod;\n\n/**\n * @author <a href=\"mailto:bogdan.mustiata@gmail.com\">Bogdan Mustiata<\/a>\n */\npublic class DirectRestServiceInterfaceClassCreator extends DirectRestBaseSourceCreator {\n    public static final String DIRECT_REST_SERVICE_SUFFIX = \"_DirectRestService\";\n\n    public DirectRestServiceInterfaceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, DIRECT_REST_SERVICE_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() throws UnableToCompleteException {\n        Annotation[] annotations = AnnotationUtils.getAnnotationsInTypeHierarchy(source);\n        return createClassSourceComposerFactory(JavaSourceCategory.INTERFACE,\n                getAnnotationsAsStringArray(annotations),\n                new String[]{\n                        RestService.class.getCanonicalName()\n                }\n        );\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n        super.generate();\n\n        for (JMethod method : source.getInheritableMethods()) {\n            p(getAnnotationsAsString(method.getAnnotations()));\n            p(\"void \" + method.getName() + \"(\" + getMethodParameters(method) + getMethodCallback(method) + \");\");\n        }\n    }\n\n    private String getMethodParameters(JMethod method) {\n        StringBuilder result = new StringBuilder(\"\");\n\n        for (JParameter parameter : method.getParameters()) {\n            result.append(getAnnotationsAsString(parameter.getAnnotations()))\n                    .append(\" \")\n                    .append(parameter.getType().getParameterizedQualifiedSourceName())\n                    .append(\" \")\n                    .append(parameter.getName())\n                    .append(\", \");\n        }\n\n        return result.toString();\n    }\n\n    private String getMethodCallback(JMethod method) {\n        if (isVoidMethod(method)) {\n            return \"org.fusesource.restygwt.client.MethodCallback<java.lang.Void> callback\";\n        }\n        final String returnType = method.getReturnType().getParameterizedQualifiedSourceName();\n        if (isOverlayMethod(method)) {\n            return \"org.fusesource.restygwt.client.OverlayCallback<\" + returnType + \"> callback\";\n        } else {\n            return \"org.fusesource.restygwt.client.MethodCallback<\" + returnType + \"> callback\";\n        }\n    }\n\n    private String getAnnotationsAsString(Annotation[] annotations) {\n        StringBuilder result = new StringBuilder(\"\");\n        OnceFirstIterator<String> space = new OnceFirstIterator<String>(\"\", \" \");\n\n        for (String annotation : getAnnotationsAsStringArray(annotations)) {\n            result.append(space.next()).append(annotation);\n        }\n\n        return result.toString();\n    }\n\n    private String[] getAnnotationsAsStringArray(Annotation[] annotations) {\n        String[] result = new String[annotations.length];\n\n        for (int i = 0; i < annotations.length; i++) {\n            Annotation annotation = annotations[i];\n            result[i] = AnnotationCopyUtil.getAnnotationAsString(annotation);\n        }\n\n        return result;\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2011 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.fusesource.restygwt.rebind;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport org.fusesource.restygwt.client.RestService;\nimport org.fusesource.restygwt.rebind.util.AnnotationCopyUtil;\nimport org.fusesource.restygwt.rebind.util.AnnotationUtils;\nimport org.fusesource.restygwt.rebind.util.OnceFirstIterator;\n\nimport java.lang.annotation.Annotation;\n\nimport static org.fusesource.restygwt.rebind.DirectRestServiceClassCreator.isVoidMethod;\n\n/**\n * @author <a href=\"mailto:bogdan.mustiata@gmail.com\">Bogdan Mustiata<\/a>\n */\npublic class DirectRestServiceInterfaceClassCreator extends DirectRestBaseSourceCreator {\n    public static final String DIRECT_REST_SERVICE_SUFFIX = \"_DirectRestService\";\n\n    public DirectRestServiceInterfaceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, DIRECT_REST_SERVICE_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() throws UnableToCompleteException {\n        Annotation[] annotations = AnnotationUtils.getAnnotationsInTypeHierarchy(source);\n        return createClassSourceComposerFactory(JavaSourceCategory.INTERFACE,\n                getAnnotationsAsStringArray(annotations),\n                new String[]{\n                        RestService.class.getCanonicalName()\n                }\n        );\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n        for (JMethod method : source.getInheritableMethods()) {\n            p(getAnnotationsAsString(method.getAnnotations()));\n            p(\"void \" + method.getName() + \"(\" + getMethodParameters(method) + getMethodCallback(method) + \");\");\n        }\n    }\n\n    private String getMethodParameters(JMethod method) {\n        StringBuilder result = new StringBuilder(\"\");\n\n        for (JParameter parameter : method.getParameters()) {\n            result.append(getAnnotationsAsString(parameter.getAnnotations()))\n                    .append(\" \")\n                    .append(parameter.getType().getParameterizedQualifiedSourceName())\n                    .append(\" \")\n                    .append(parameter.getName())\n                    .append(\", \");\n        }\n\n        return result.toString();\n    }\n\n    private String getMethodCallback(JMethod method) {\n        if (isVoidMethod(method)) {\n            return \"org.fusesource.restygwt.client.MethodCallback<java.lang.Void> callback\";\n        }\n        return \"org.fusesource.restygwt.client.MethodCallback<\" + method.getReturnType().getParameterizedQualifiedSourceName() + \"> callback\";\n    }\n\n    private String getAnnotationsAsString(Annotation[] annotations) {\n        StringBuilder result = new StringBuilder(\"\");\n        OnceFirstIterator<String> space = new OnceFirstIterator<String>(\"\", \" \");\n\n        for (String annotation : getAnnotationsAsStringArray(annotations)) {\n            result.append(space.next()).append(annotation);\n        }\n\n        return result.toString();\n    }\n\n    private String[] getAnnotationsAsStringArray(Annotation[] annotations) {\n        String[] result = new String[annotations.length];\n\n        for (int i = 0; i < annotations.length; i++) {\n            Annotation annotation = annotations[i];\n            result[i] = AnnotationCopyUtil.getAnnotationAsString(annotation);\n        }\n\n        return result;\n    }\n}\n","lineNo":86}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2015 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport static org.fusesource.restygwt.rebind.util.AnnotationUtils.getAnnotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.DELETE;\nimport javax.ws.rs.FormParam;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.HEAD;\nimport javax.ws.rs.HeaderParam;\nimport javax.ws.rs.OPTIONS;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.PUT;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.QueryParam;\nimport javax.ws.rs.core.MediaType;\n\nimport org.fusesource.restygwt.client.AbstractAsyncCallback;\nimport org.fusesource.restygwt.client.AbstractRequestCallback;\nimport org.fusesource.restygwt.client.Attribute;\nimport org.fusesource.restygwt.client.Defaults;\nimport org.fusesource.restygwt.client.Dispatcher;\nimport org.fusesource.restygwt.client.FormPostContent;\nimport org.fusesource.restygwt.client.JSONP;\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\nimport org.fusesource.restygwt.client.JsonCallback;\nimport org.fusesource.restygwt.client.JsonpMethod;\nimport org.fusesource.restygwt.client.Method;\nimport org.fusesource.restygwt.client.MethodCallback;\nimport org.fusesource.restygwt.client.Options;\nimport org.fusesource.restygwt.client.OverlayCallback;\nimport org.fusesource.restygwt.client.Resource;\nimport org.fusesource.restygwt.client.ResponseFormatException;\nimport org.fusesource.restygwt.client.RestService;\nimport org.fusesource.restygwt.client.RestServiceProxy;\nimport org.fusesource.restygwt.client.ServiceRoots;\nimport org.fusesource.restygwt.client.TextCallback;\nimport org.fusesource.restygwt.client.XmlCallback;\n\nimport com.google.gwt.core.client.JavaScriptObject;\nimport com.google.gwt.core.client.JsArray;\nimport com.google.gwt.core.client.JsArrayBoolean;\nimport com.google.gwt.core.client.JsArrayInteger;\nimport com.google.gwt.core.client.JsArrayNumber;\nimport com.google.gwt.core.client.JsArrayString;\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.PropertyOracle;\nimport com.google.gwt.core.ext.SelectionProperty;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.HasAnnotations;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JGenericType;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.core.ext.typeinfo.JTypeParameter;\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONString;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.jsonp.client.JsonpRequest;\nimport com.google.gwt.user.client.rpc.RemoteServiceRelativePath;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport com.google.gwt.xml.client.Document;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added automatically create resource from Path annotation,\n *         enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\npublic class RestServiceClassCreator extends BaseSourceCreator {\n\n    private static final String REST_SERVICE_PROXY_SUFFIX = \"_Generated_RestServiceProxy_\";\n\n    private static final String PLAIN_TEXT_AUTODETECTION_CONFIGURATION_PROPERTY_NAME = \"restygwt.autodetect.plaintText\";\n\n    private static final String METHOD_CLASS = Method.class.getName();\n    private static final String RESOURCE_CLASS = Resource.class.getName();\n    private static final String DISPATCHER_CLASS = Dispatcher.class.getName();\n    private static final String DEFAULTS_CLASS = Defaults.class.getName();\n    private static final String ABSTRACT_REQUEST_CALLBACK_CLASS = AbstractRequestCallback.class.getName();\n    private static final String ABSTRACT_ASYNC_CALLBACK_CLASS = AbstractAsyncCallback.class.getName();\n    private static final String JSON_PARSER_CLASS = JSONParser.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_STRING_CLASS = JSONString.class.getName();\n    private static final String REQUEST_EXCEPTION_CLASS = RequestException.class.getName();\n    private static final String RESPONSE_FORMAT_EXCEPTION_CLASS = ResponseFormatException.class.getName();\n    private static final String JSONP_METHOD_CLASS = JsonpMethod.class.getName();\n    private static final String FORM_POST_CONTENT_CLASS = FormPostContent.class.getName();\n    private static final String SERVICE_ROOTS_CLASS = ServiceRoots.class.getName();\n\n    /*\n     * static class in which are some compile-time relevant infos.\n     *\n     * TODO (andi): too much flexibility and overhead with reflection here?\n     */\n    private static final Class<BindingDefaults> BINDING_DEFAULTS = BindingDefaults.class;\n\n    private static final String METHOD_JSONP = \"jsonp\";\n    private static final String METHOD_PUT = \"put\";\n    private static final String METHOD_POST = \"post\";\n    private static final String METHOD_OPTIONS = \"options\";\n    private static final String METHOD_HEAD = \"head\";\n    private static final String METHOD_GET = \"get\";\n    private static final String METHOD_DELETE = \"delete\";\n\n    private static final HashSet<String> REST_METHODS = new HashSet<String>(8);\n    static {\n        REST_METHODS.add(METHOD_DELETE);\n        REST_METHODS.add(METHOD_GET);\n        REST_METHODS.add(METHOD_HEAD);\n        REST_METHODS.add(METHOD_OPTIONS);\n        REST_METHODS.add(METHOD_POST);\n        REST_METHODS.add(METHOD_PUT);\n        REST_METHODS.add(METHOD_JSONP);\n    }\n\n    private JClassType XML_CALLBACK_TYPE;\n    private JClassType METHOD_CALLBACK_TYPE;\n    private JClassType TEXT_CALLBACK_TYPE;\n    private JClassType JSON_CALLBACK_TYPE;\n    private JClassType OVERLAY_CALLBACK_TYPE;\n    private JClassType DOCUMENT_TYPE;\n    private JClassType METHOD_TYPE;\n    private JClassType STRING_TYPE;\n    private JClassType JSON_VALUE_TYPE;\n    private JClassType OVERLAY_VALUE_TYPE;\n    private Set<JClassType> OVERLAY_ARRAY_TYPES;\n    private Set<JClassType> QUERY_PARAM_LIST_TYPES;\n    private JClassType REST_SERVICE_TYPE;\n    private JsonEncoderDecoderInstanceLocator locator;\n\n    private boolean autodetectTypeForStrings;\n\n    public RestServiceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, REST_SERVICE_PROXY_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n    \tString parameters = \"\";\n    \tif(source instanceof JGenericType)\n    \t{\n    \t\tJGenericType gtype = (JGenericType)source;\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tbuilder.append(\"<\");\n\t\t\tboolean first = true;\n   \t\t\tfor(JTypeParameter arg : gtype.getTypeParameters())\n   \t\t\t{\n   \t\t\t\tif(!first)\n   \t\t\t\t\tbuilder.append(\",\");\n   \t\t\t\tbuilder.append(arg.getName());\n   \t\t\t\tbuilder.append(\" extends \");\n\t   \t\t\tbuilder.append(arg.getFirstBound().getParameterizedQualifiedSourceName());\n\t   \t\t\tfirst = false;\n   \t\t\t}\n   \t\t\tbuilder.append(\">\");\n   \t\t\tparameters = builder.toString();\n     \t}\n\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName + parameters);\n        composerFactory.addImplementedInterface(source.getParameterizedQualifiedSourceName());\n        composerFactory.addImplementedInterface(RestServiceProxy.class.getName());\n        return composerFactory;\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n\n        if (source.isInterface() == null) {\n            getLogger().log(ERROR, \"Type is not an interface.\");\n            throw new UnableToCompleteException();\n        }\n\n        autodetectTypeForStrings = shouldAutodetectPlainTextForStrings(getLogger(), context.getPropertyOracle());\n\n        locator = new JsonEncoderDecoderInstanceLocator(context, getLogger());\n\n        this.XML_CALLBACK_TYPE = find(XmlCallback.class, getLogger(), context);\n        this.METHOD_CALLBACK_TYPE = find(MethodCallback.class, getLogger(), context);\n        this.TEXT_CALLBACK_TYPE = find(TextCallback.class, getLogger(), context);\n        this.JSON_CALLBACK_TYPE = find(JsonCallback.class, getLogger(), context);\n        this.OVERLAY_CALLBACK_TYPE = find(OverlayCallback.class, getLogger(), context);\n        this.DOCUMENT_TYPE = find(Document.class, getLogger(), context);\n        this.METHOD_TYPE = find(Method.class, getLogger(), context);\n        this.STRING_TYPE = find(String.class, getLogger(), context);\n        this.JSON_VALUE_TYPE = find(JSONValue.class, getLogger(), context);\n        this.OVERLAY_VALUE_TYPE = find(JavaScriptObject.class, getLogger(), context);\n        this.OVERLAY_ARRAY_TYPES = new HashSet<JClassType>();\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArray.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayBoolean.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayInteger.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayNumber.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayString.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES = new HashSet<JClassType>();\n        this.QUERY_PARAM_LIST_TYPES.add(find(Collection.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES.add(find(List.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES.add(find(Set.class, getLogger(), context));\n\t\tthis.REST_SERVICE_TYPE = find(RestService.class, getLogger(), context);\n\n        String path = getPathFromSource(source);\n\n        p(\"private \" + RESOURCE_CLASS + \" resource = null;\");\n        p();\n\n        p(\"public void setResource(\" + RESOURCE_CLASS + \" resource) {\").i(1);\n        {\n            p(\"this.resource = resource;\");\n        }\n        i(-1).p(\"}\");\n\n        Options options = getAnnotation(source, Options.class);\n\n        p(\"public \" + RESOURCE_CLASS + \" getResource() {\").i(1);\n        {\n            p(\"if (this.resource == null) {\").i(1);\n\n            if (options != null && options.serviceRootKey() != null && !options.serviceRootKey().isEmpty()) {\n            \tp(\"String serviceRoot = \" + SERVICE_ROOTS_CLASS + \".get(\\\"\" + options.serviceRootKey() + \"\\\");\");\n            } else {\n            \tp(\"String serviceRoot = \" + DEFAULTS_CLASS + \".getServiceRoot();\");\n            }\n\n            if (path == null) {\n                p(\"this.resource = new \" + RESOURCE_CLASS + \"(serviceRoot);\");\n            } else {\n                p(\"this.resource = new \" + RESOURCE_CLASS + \"(serviceRoot).resolve(\"+quote(path)+\");\");\n            }\n\n            i(-1).p(\"}\");\n            p(\"return this.resource;\");\n        }\n        i(-1).p(\"}\");\n\n\n        if( options!=null && options.dispatcher()!=Dispatcher.class ) {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = \"+options.dispatcher().getName()+\".INSTANCE;\");\n        } else {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = null;\");\n        }\n\n        p();\n        p(\"public void setDispatcher(\" + DISPATCHER_CLASS + \" dispatcher) {\").i(1);\n        {\n            p(\"this.dispatcher = dispatcher;\");\n        }\n        i(-1).p(\"}\");\n\n        p();\n        p(\"public \" + DISPATCHER_CLASS + \" getDispatcher() {\").i(1);\n        {\n            p(\"return this.dispatcher;\");\n        }\n        i(-1).p(\"}\");\n\n        for (JMethod method : source.getInheritableMethods()) {\n        \tJClassType iface = method.getReturnType().isInterface();\n        \tif(iface != null && REST_SERVICE_TYPE.isAssignableFrom(iface))\n        \t\twriteSubresourceLocatorImpl(method);\n        \telse\n                writeMethodImpl(method, options);\n        }\n    }\n\n    /**\n     * Returns {@code true} if plain text autodetection for strings should be used.\n     */\n    static boolean shouldAutodetectPlainTextForStrings(TreeLogger logger, PropertyOracle propertyOracle) {\n        try {\n            SelectionProperty prop = propertyOracle.getSelectionProperty(logger, PLAIN_TEXT_AUTODETECTION_CONFIGURATION_PROPERTY_NAME);\n            String propVal = prop.getCurrentValue();\n            return Boolean.parseBoolean(propVal);\n        } catch (BadPropertyValueException e) {\n            // use default \"false\"\n        }\n        return false;\n    }\n\n    private static String getPathFromSource(HasAnnotations annotatedType) {\n        String path = null;\n\n        Path pathAnnotation = getAnnotation(annotatedType, Path.class);\n        if (pathAnnotation != null) {\n            path = pathAnnotation.value();\n        }\n\n        RemoteServiceRelativePath relativePath = getAnnotation(annotatedType, RemoteServiceRelativePath.class);\n        if (relativePath != null) {\n            path = relativePath.value();\n        }\n\n        return path;\n    }\n\n    private String quote(String path) {\n        // TODO: unlikely to occur. but we should escape chars like newlines..\n        return \"\\\"\" + path + \"\\\"\";\n    }\n\n    private boolean isOverlayArrayType(JClassType type) {\n        for (JClassType arrayType : OVERLAY_ARRAY_TYPES) {\n            if (type.isAssignableTo(arrayType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isQueryParamListType(JClassType type) {\n        if (type.isParameterized() == null) {\n            return false;\n        }\n        for (JClassType listType : QUERY_PARAM_LIST_TYPES) {\n            if (type.isAssignableTo(listType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void writeSubresourceLocatorImpl(JMethod method) throws UnableToCompleteException\n    {\n    \tJClassType iface = method.getReturnType().isInterface();\n    \tif(iface == null || !REST_SERVICE_TYPE.isAssignableFrom(iface)) {\n    \t\tgetLogger().log(ERROR, \"Invalid subresource locator method. Method must have return type of an interface that extends RestService: \" + method.getReadableDeclaration());\n            throw new UnableToCompleteException();\n    \t}\n\n        Path pathAnnotation = getAnnotation(method, Path.class);\n        if (pathAnnotation == null) {\n        \tgetLogger().log(ERROR, \"Invalid subresource locator method. Method must have @Path annotation: \" + method.getReadableDeclaration());\n            throw new UnableToCompleteException();\n        }\n        String pathExpression = wrap(pathAnnotation.value());\n\n        for (JParameter arg : method.getParameters()) {\n            PathParam paramPath = getAnnotation(arg, PathParam.class);\n            if (paramPath != null) {\n                pathExpression = pathExpression(pathExpression, arg, paramPath);\n            }\n        }\n\n\n        p(method.getReadableDeclaration(false, false, false, false, true) + \" {\").i(1);\n        {\n        \tJType type = method.getReturnType();\n        \tString name;\n        \tif(type instanceof JClassType)\n        \t{\n                JClassType restService = (JClassType)type;\n                RestServiceClassCreator generator = new RestServiceClassCreator(getLogger(), context, restService);\n                name = generator.create();\n        \t}\n        \telse\n        \t{\n        \t\tthrow new UnsupportedOperationException(\"Subresource method may not return: \" + type);\n        \t}\n        \tp(method.getReturnType().getQualifiedSourceName() + \" __subresource = new \" + name + \"();\");\n                p(\"((\" + RestServiceProxy.class.getName() + \")__subresource).setResource(getResource().resolve(\" + pathExpression + \"));\");\n                p(\"((\" + RestServiceProxy.class.getName() + \")__subresource).setDispatcher(getDispatcher());\");\n        \tp(\"return __subresource;\");\n        }\n        i(-1).p(\"}\");\n    }\n\n    private String pathExpression(String pathExpression, JParameter arg, PathParam paramPath) {\n        String expr = toStringExpression(arg);\n        return pathExpression.replaceAll(Pattern.quote(\"{\" + paramPath.value()) + \"(\\\\s*:\\\\s*(.)+)?\\\\}\",\n               \"\\\"+(\" + expr + \"== null? null : ((\\\"\\\" + \" + expr +\").startsWith(\\\"http\\\") ? \" + expr +\n               \" : com.google.gwt.http.client.URL.encodePathSegment(\" + expr + \")))+\\\"\");\n    }\n\n    void writeOptions(Options options, Options classOptions) {\n        // configure the dispatcher\n        if (options != null && options.dispatcher() != Dispatcher.class) {\n            // use the dispatcher configured for the method.\n            p(\"__method.setDispatcher(\" + options.dispatcher().getName() + \".INSTANCE);\");\n        } else {\n            // use the default dispatcher configured for the service..\n            p(\"__method.setDispatcher(this.dispatcher);\");\n        }\n\n        // configure the expected statuses..\n        if (options != null && options.expect().length != 0) {\n            // Using method level defined expected status\n            p(\"__method.expect(\" + join(options.expect(), \", \") + \");\");\n        } else if (classOptions != null && classOptions.expect().length != 0) {\n            // Using class level defined expected status\n            p(\"__method.expect(\" + join(classOptions.expect(), \", \") + \");\");\n        }\n\n        // configure the timeout\n        if (options != null && options.timeout() >= 0) {\n            // Using method level defined value\n            p(\"__method.timeout(\" + options.timeout() + \");\");\n        } else if (classOptions != null && classOptions.timeout() >= 0) {\n            // Using class level defined value\n            p(\"__method.timeout(\" + classOptions.timeout() + \");\");\n        }\n    }\n\n    private void writeMethodImpl(JMethod method, Options classOptions) throws UnableToCompleteException {\n        boolean returnRequest = false;\n        if (method.getReturnType() != JPrimitiveType.VOID) {\n            if (!method.getReturnType().getQualifiedSourceName().equals(Request.class.getName()) &&\n                !method.getReturnType().getQualifiedSourceName().equals(JsonpRequest.class.getName())) {\n                getLogger().log(ERROR, \"Invalid rest method. Method must have void, Request or JsonpRequest return types: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            returnRequest = true;\n        }\n\n        Json jsonAnnotation = getAnnotation(source, Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n\n        Options options = getAnnotation(method, Options.class);\n\n        p(method.getReadableDeclaration(false, false, false, false, true) + \" {\").i(1);\n        {\n            String restMethod = getRestMethod(method);\n            LinkedList<JParameter> args = new LinkedList<JParameter>(Arrays.asList(method.getParameters()));\n            for (final JParameter arg : args.subList(0, args.size() - 1)) {\n                p(\"final \"\n                        + arg.getType().getParameterizedQualifiedSourceName()\n                        + \" final_\" + arg.getName() + \" = \" + arg.getName()\n                        + \";\");\n            }\n\n            // the last arg should be the callback.\n            if (args.isEmpty()) {\n                getLogger().log(ERROR, \"Invalid rest method. Method must declare at least a callback argument: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            JParameter callbackArg = args.removeLast();\n            JClassType callbackType = callbackArg.getType().isClassOrInterface();\n            JClassType methodCallbackType = METHOD_CALLBACK_TYPE;\n            if (callbackType == null || !callbackType.isAssignableTo(methodCallbackType)) {\n                getLogger().log(ERROR, \"Invalid rest method. Last argument must be a \" + methodCallbackType.getName() + \" type: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            JClassType resultType = getCallbackTypeGenericClass(callbackType);\n\n            String pathExpression = null;\n            Path pathAnnotation = getAnnotation(method, Path.class);\n            if (pathAnnotation != null) {\n                pathExpression = wrap(pathAnnotation.value());\n            }\n\n            JParameter contentArg = null;\n            HashMap<String, JParameter> queryParams = new HashMap<String, JParameter>();\n            HashMap<String, JParameter> formParams = new HashMap<String, JParameter>();\n            HashMap<String, JParameter> headerParams = new HashMap<String, JParameter>();\n\n            for (JParameter arg : args) {\n                PathParam paramPath = getAnnotation(arg, PathParam.class);\n                if (paramPath != null) {\n                    if (pathExpression == null) {\n                        getLogger().log(ERROR, \"Invalid rest method.  Invalid @PathParam annotation. Method is missing the @Path annotation: \" + method.getReadableDeclaration());\n                        throw new UnableToCompleteException();\n                    }\n                    pathExpression = pathExpression(pathExpression, arg, paramPath);\n                    //.replaceAll(Pattern.quote(\"{\" + paramPath.value() + \"}\"), \"\\\"+com.google.gwt.http.client.URL.encodePathSegment(\" + toStringExpression(arg) + \")+\\\"\");\n                    if (getAnnotation(arg, Attribute.class) != null) {\n                        // allow part of the arg-object participate in as PathParam and the object goes over the wire\n                        contentArg = arg;\n                    }\n                    continue;\n                }\n\n                QueryParam queryParam = getAnnotation(arg, QueryParam.class);\n                if (queryParam != null) {\n                    queryParams.put(queryParam.value(), arg);\n                    continue;\n                }\n\n                FormParam formParam = getAnnotation(arg, FormParam.class);\n                if (formParam != null) {\n                    formParams.put(formParam.value(), arg);\n                    continue;\n                }\n\n                HeaderParam headerParam = getAnnotation(arg, HeaderParam.class);\n                if (headerParam != null) {\n                    headerParams.put(headerParam.value(), arg);\n                    continue;\n                }\n\n                if (!formParams.isEmpty()) {\n                    getLogger().log(ERROR, \"You can not have both @FormParam parameters and a content parameter: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n\n                if (contentArg != null) {\n                    getLogger().log(ERROR, \"Invalid rest method. Only one content parameter is supported: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n                contentArg = arg;\n            }\n\n            String acceptTypeBuiltIn = null;\n            if (callbackType.equals(TEXT_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_TEXT\";\n            } else if (callbackType.equals(JSON_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.isAssignableTo(OVERLAY_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.equals(XML_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_XML\";\n            }\n\n            // Handle JSONP specific configuration...\n            JSONP jsonpAnnotation = getAnnotation(method, JSONP.class);\n\n            final boolean isJsonp = restMethod.equals(METHOD_JSONP) && jsonpAnnotation != null;\n\n            p(\"final \" + (isJsonp ? JSONP_METHOD_CLASS : METHOD_CLASS) + \" __method =\");\n\n            p(\"getResource()\");\n            if (pathExpression != null) {\n                p(\".resolve(\" + pathExpression + \")\");\n            }\n            for (Map.Entry<String, JParameter> entry : queryParams.entrySet()) {\n                String expr = entry.getValue().getName();\n                JClassType type = entry.getValue().getType().isClassOrInterface();\n                if (type != null && isQueryParamListType(type)) {\n                    p(\".addQueryParams(\" + wrap(entry.getKey()) + \", \" +\n                      toIteratedStringExpression(entry.getValue()) + \")\");\n                } else {\n                    p(\".addQueryParam(\" + wrap(entry.getKey()) + \", \" +\n                      toStringExpression(entry.getValue().getType(), expr) + \")\");\n                }\n            }\n            // example: .get()\n            p(\".\" + restMethod + \"();\");\n\n            if( isJsonp ) {\n                if (returnRequest && !method.getReturnType().getQualifiedSourceName().equals(JsonpRequest.class.getName())) {\n                    getLogger().log(ERROR, \"Invalid rest method. JSONP method must have void or JsonpRequest return types: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n                if( jsonpAnnotation.callbackParam().length() > 0 ) {\n                    p(\"__method.callbackParam(\"+wrap(jsonpAnnotation.callbackParam())+\");\");\n                }\n                if( jsonpAnnotation.failureCallbackParam().length() > 0 ) {\n                    p(\"__method.failureCallbackParam(\"+wrap(jsonpAnnotation.failureCallbackParam())+\");\");\n                }\n            } else {\n                if (returnRequest && !method.getReturnType().getQualifiedSourceName().equals(Request.class.getName())) {\n                    getLogger().log(ERROR, \"Invalid rest method. Non JSONP method must have void or Request return types: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n            }\n\n            writeOptions(options, classOptions);\n\n            String contentTypeHeaderValue = null;\n\n            if(jsonpAnnotation == null) {\n                final String acceptHeader; \n                Produces producesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Produces.class);\n                if (producesAnnotation != null) {\n                    // Do not use autodetection, if accept type already set\n                    if (acceptTypeBuiltIn == null && autodetectTypeForStrings && producesAnnotation.value()[0].startsWith(\"text/\")) {\n                        acceptTypeBuiltIn = \"CONTENT_TYPE_TEXT\";\n                    }\n                    acceptHeader = wrap(producesAnnotation.value()[0]);\n                } else {\n                    // set the default accept header value ...\n                    if (acceptTypeBuiltIn != null) {\n                        acceptHeader = RESOURCE_CLASS + \".\" + acceptTypeBuiltIn;\n                    } else {\n                        acceptHeader = RESOURCE_CLASS + \".CONTENT_TYPE_JSON\";\n                    }\n                }\n                p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \" + acceptHeader + \");\");\n\n                Consumes consumesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Consumes.class);\n                if (consumesAnnotation != null) {\n                    contentTypeHeaderValue = consumesAnnotation.value()[0];\n                    p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_CONTENT_TYPE, \" + wrap(contentTypeHeaderValue) + \");\");\n               }\n\n                // and set the explicit headers now (could override the accept header)\n                for (Map.Entry<String, JParameter> entry : headerParams.entrySet()) {\n                    String expr = entry.getValue().getName();\n                    p(\"__method.header(\" + wrap(entry.getKey()) + \", \" + toStringExpression(entry.getValue().getType(), expr) + \");\");\n                }\n            }\n\n            if (! formParams.isEmpty()) {\n                p(FORM_POST_CONTENT_CLASS + \" __formPostContent = new \" + FORM_POST_CONTENT_CLASS + \"();\");\n\n                for (Map.Entry<String, JParameter> entry : formParams.entrySet()) {\n                    JClassType type = entry.getValue().getType()\n                            .isClassOrInterface();\n                    if (type != null && isQueryParamListType(type)) {\n                        p(\"__formPostContent.addParameters(\" +\n                                wrap(entry.getKey()) + \", \" +\n                                toIteratedFormStringExpression(entry.getValue(), classStyle) +\n                                \");\");\n                    } else {\n                        p(\"__formPostContent.addParameter(\" +\n                                wrap(entry.getKey()) + \", \" +\n                                toFormStringExpression(entry.getValue(), classStyle) +\n                                \");\");\n                    }\n                }\n\n                p(\"__method.form(__formPostContent.getTextContent());\");\n            }\n\n            if (contentArg != null) {\n                if (contentArg.getType() == STRING_TYPE) {\n                    if (autodetectTypeForStrings && MediaType.APPLICATION_JSON.equals(contentTypeHeaderValue)) {\n                        p(\"__method.json(new \" + JSON_STRING_CLASS + \"(\" + contentArg.getName() + \"));\");\n                    } else {\n                        p(\"__method.text(\" + contentArg.getName() + \");\");\n                    }\n                } else if (contentArg.getType() == JSON_VALUE_TYPE) {\n                    p(\"__method.json(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType().isClass() != null &&\n                           isOverlayArrayType(contentArg.getType().isClass())) {\n                    p(\"__method.json(new \" + JSON_ARRAY_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType().isClass() != null &&\n                           contentArg.getType().isClass().isAssignableTo(OVERLAY_VALUE_TYPE)) {\n                    p(\"__method.json(new \" + JSON_OBJECT_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType() == DOCUMENT_TYPE) {\n                    p(\"__method.xml(\" + contentArg.getName() + \");\");\n                } else {\n                    JClassType contentClass = contentArg.getType().isClass();\n                    if (contentClass == null) {\n                        contentClass = contentArg.getType().isClassOrInterface();\n                        if (!locator.isCollectionType(contentClass)) {\n                            getLogger().log(ERROR, \"Content argument must be a class.\");\n                            throw new UnableToCompleteException();\n                        }\n                    }\n\n                    jsonAnnotation = getAnnotation(contentArg, Json.class);\n                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n                    // example:\n                    // .json(Listings$_Generated_JsonEncoder_$.INSTANCE.encode(arg0)\n                    // )\n                    p(\"__method.json(\" + locator.encodeExpression(contentClass, contentArg.getName(), style) + \");\");\n                }\n            }\n\n\n            List<AnnotationResolver> annotationResolvers = getAnnotationResolvers(context, getLogger());\n            getLogger().log(TreeLogger.DEBUG, \"found \" + annotationResolvers.size() + \" additional AnnotationResolvers\");\n\n            for (AnnotationResolver a : annotationResolvers) {\n                getLogger().log(TreeLogger.DEBUG, \"(\" + a.getClass().getName() + \") resolve `\" + source.getName()\n                        + \"#\" + method.getName() + \" ...\");\n                final Map<String, String[]> addDataParams = a.resolveAnnotation(getLogger(), source, method, restMethod);\n\n                if (addDataParams != null) {\n                    for (String s : addDataParams.keySet()) {\n                        final StringBuilder sb = new StringBuilder();\n                        final List<String> classList = Arrays.asList(addDataParams.get(s));\n\n                        sb.append(\"[\");\n                        for (int i = 0; i < classList.size(); ++i) {\n                            sb.append(\"\\\\\\\"\").append(classList.get(i)).append(\"\\\\\\\"\");\n\n                            if ((i+1) <  classList.size()) {\n                                sb.append(\",\");\n                            }\n                        }\n                        sb.append(\"]\");\n\n                        getLogger().log(TreeLogger.DEBUG, \"add call with (\\\"\" + s + \"\\\", \\\"\" +\n                                sb.toString() + \"\\\")\");\n                        p(\"__method.addData(\\\"\" + s + \"\\\", \\\"\" + sb.toString() + \"\\\");\");\n                    }\n                }\n            }\n\n\n            if (acceptTypeBuiltIn != null) {\n                // TODO: shouldn't we also have a cach in here?\n                p(returnRequest(returnRequest,isJsonp) + \"__method.send(\" + callbackArg.getName() + \");\");\n            } else if ( isJsonp ){\n                    p(returnRequest(returnRequest,isJsonp) + \"__method.send(new \" + ABSTRACT_ASYNC_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">(__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult(\" + JSON_VALUE_CLASS + \" result) throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) null;\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    if(resultType.isAssignableTo(locator.LIST_TYPE)){\n                                        p(\"result = new \" + JSON_ARRAY_CLASS + \"(((\" + JSON_OBJECT_CLASS + \")result).getJavaScriptObject());\");\n                                    }\n                                    jsonAnnotation = getAnnotation(method, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, \"result\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n            } else {\n                p(\"try {\").i(1);\n                {\n                    p(returnRequest(returnRequest,isJsonp) + \"__method.send(new \" + ABSTRACT_REQUEST_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">(__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult() throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) null;\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    jsonAnnotation = getAnnotation(method, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, JSON_PARSER_CLASS + \".parse(__method.getResponse().getText())\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n                }\n                i(-1).p(\"} catch (\" + REQUEST_EXCEPTION_CLASS + \" __e) {\").i(1);\n                {\n                    p(callbackArg.getName() + \".onFailure(__method,__e);\");\n                    if (returnRequest) {\n                        p(\"return null;\");\n                    }\n                }\n                i(-1).p(\"}\");\n            }\n        }\n        i(-1).p(\"}\");\n    }\n\n    private <T extends Annotation> T findAnnotationOnMethodOrEnclosingType(final JMethod method, final Class<T> annotationType) {\n        T annotation = getAnnotation(method, annotationType);\n        if (annotation == null) {\n            annotation = getAnnotation(method.getEnclosingType(), annotationType);\n        }\n        return annotation;\n    }\n\n    protected String toStringExpression(JParameter arg) {\n        Attribute attribute = getAnnotation(arg, Attribute.class);\n        if(attribute != null){\n            return \"(\" + arg.getName() + \".\" + attribute.value() + \"+ \\\"\\\")\";\n        }\n        return toStringExpression(arg.getType(), arg.getName());\n    }\n\n    protected String toFormStringExpression(JParameter argument, Style classStyle) throws UnableToCompleteException {\n        JType type = argument.getType();\n        String expr = argument.getName();\n\n        if (type.isPrimitive() != null) {\n            return \"\\\"\\\"+\" + expr;\n        }\n        if (STRING_TYPE == type) {\n            return expr;\n        }\n        if (type.isClass() != null &&\n                isOverlayArrayType(type.isClass())) {\n            return \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.isClass() != null &&\n                OVERLAY_VALUE_TYPE.isAssignableFrom(type.isClass())) {\n            return \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.getQualifiedBinaryName().startsWith(\"java.lang.\") || type.isEnum() != null) {\n            return String.format(\"(%s != null ? %s.toString() : null)\", expr, expr);\n        }\n\n        Json jsonAnnotation = getAnnotation(argument, Json.class);\n        final Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n        return locator.encodeExpression(type, expr, style) + \".toString()\";\n    }\n\n    protected String toIteratedFormStringExpression(JParameter argument, Style classStyle) throws UnableToCompleteException {\n        assert isQueryParamListType(argument.getType().isClassOrInterface());\n        final JClassType[] type_args = argument.getType().isParameterized().getTypeArgs();\n        assert (type_args.length == 1);\n        final JClassType class_type = type_args[0];\n        final String argument_expr = \"final_\"\n                + argument.getName();\n\n        final StringBuilder result = new StringBuilder();\n        result.append(argument_expr + \" == null ? null : \");\n        result.append(\"new java.lang.Iterable<String> () {\\n\");\n        result.append(\" @Override\\n\");\n        result.append(\" public java.util.Iterator<String> iterator() {\\n\");\n        result.append(\"     final java.util.Iterator<\"\n                + class_type.getParameterizedQualifiedSourceName()\n                + \"> baseIterator =  \" + argument_expr + \".iterator();\\n\");\n        result.append(\"     return new java.util.Iterator<String>() {\\n\");\n        result.append(\"         @Override\\n\");\n        result.append(\"         public boolean hasNext() {\\n\");\n        result.append(\"           return baseIterator.hasNext();\\n\");\n        result.append(\"         }\\n\");\n        result.append(\"         @Override\\n\");\n        result.append(\"         public String next() {\\n\");\n        final String expr = \"baseIterator.next()\";\n        String returnExpr;\n        if (class_type.isPrimitive() != null) {\n            returnExpr = \"\\\"\\\"+\" + expr;\n        } else if (STRING_TYPE == class_type) {\n            returnExpr = expr;\n        } else if (class_type.isClass() != null &&\n            isOverlayArrayType(class_type.isClass())) {\n            returnExpr = \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        } else if (class_type.isClass() != null &&\n            OVERLAY_VALUE_TYPE.isAssignableFrom(class_type.isClass())) {\n            returnExpr = \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        } else if (class_type.getQualifiedBinaryName().startsWith(\"java.lang.\")) {\n            result.append(\"             Object obj = \" + expr + \";\");\n            returnExpr = \"obj != null ? obj.toString() : null\";\n        } else {\n            Json jsonAnnotation = getAnnotation(argument, Json.class);\n            final Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n            returnExpr = locator.encodeExpression(class_type, expr, style) + \".toString()\";\n        }\n        result.append(\"             return \" + returnExpr + \";\\n\");\n        result.append(\"         }\\n\");\n        result.append(\"         @Override\\n\");\n        result.append(\"         public void remove() {\\n\");\n        result.append(\"             throw new UnsupportedOperationException();\\n\");\n        result.append(\"         }\\n\");\n        result.append(\"     };\\n\");\n        result.append(\" }\\n\");\n        result.append(\"}\\n\");\n\n        return result.toString();\n    }\n\n    protected String toStringExpression(JType type, String expr) {\n        if (type.isPrimitive() != null) {\n            return \"\\\"\\\"+\" + expr;\n        }\n        if (STRING_TYPE == type) {\n            return expr;\n        }\n        if (type.isClass() != null &&\n            isOverlayArrayType(type.isClass())) {\n          return \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.isClass() != null &&\n            OVERLAY_VALUE_TYPE.isAssignableFrom(type.isClass())) {\n          return \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        }\n\n        return String.format(\"(%s != null ? %s.toString() : null)\", expr, expr);\n    }\n\n    protected String toIteratedStringExpression(JParameter arg) {\n        StringBuilder result = new StringBuilder();\n        result.append(\"new org.fusesource.restygwt.client.StringIterable (\")\n            .append(arg.getName()).append(\")\");\n\n        return result.toString();\n    }\n\n    private JClassType getCallbackTypeGenericClass(final JClassType callbackType) throws UnableToCompleteException {\n        return branch(\"getCallbackTypeGenericClass()\", new Branch<JClassType>() {\n            @Override\n            public JClassType execute() throws UnableToCompleteException {\n\n                for (JMethod method : callbackType.getOverridableMethods()) {\n                    getLogger().log(DEBUG, \"checking method: \" + method.getName());\n                    if (method.getName().equals(\"onSuccess\")) {\n                        JParameter[] parameters = method.getParameters();\n                        getLogger().log(DEBUG, \"checking method params: \" + parameters.length);\n                        if (parameters.length == 2) {\n                            getLogger().log(DEBUG, \"checking first param: \" + parameters[0].getType());\n                            if (parameters[0].getType() == METHOD_TYPE) {\n                                getLogger().log(DEBUG, \"checking 2nd param: \" + parameters[1].getType());\n                                JType param2Type = parameters[1].getType();\n                                JClassType type = param2Type.isClassOrInterface();\n                                if (type == null) {\n                                    getLogger().log(ERROR, \"The type of the callback not supported: \" + param2Type.getJNISignature());\n                                    throw new UnableToCompleteException();\n                                }\n                                getLogger().log(DEBUG, \"match: \" + type);\n                                return type;\n                            }\n                        }\n                    }\n                }\n                getLogger().log(ERROR, \"The type of the callback could not be determined: \" + callbackType.getParameterizedQualifiedSourceName());\n                throw new UnableToCompleteException();\n            }\n        });\n    }\n\n    private String getRestMethod(JMethod method) throws UnableToCompleteException {\n        String restMethod = null;\n        if (getAnnotation(method, DELETE.class) != null) {\n            restMethod = METHOD_DELETE;\n        } else if (getAnnotation(method, GET.class) != null) {\n            restMethod = METHOD_GET;\n        } else if (getAnnotation(method, HEAD.class) != null) {\n            restMethod = METHOD_HEAD;\n        } else if (getAnnotation(method, OPTIONS.class) != null) {\n            restMethod = METHOD_OPTIONS;\n        } else if (getAnnotation(method, POST.class) != null) {\n            restMethod = METHOD_POST;\n        } else if (getAnnotation(method, PUT.class) != null) {\n            restMethod = METHOD_PUT;\n        } else if (getAnnotation(method, JSONP.class) != null) {\n            restMethod = METHOD_JSONP;\n        } else {\n            restMethod = method.getName();\n            if (!REST_METHODS.contains(restMethod)) {\n                getLogger().log(ERROR, \"Invalid rest method. It must either have a lower case rest method name or have a javax rs method annotation: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n        }\n        return restMethod;\n    }\n\n    /**\n     * access additional AnnotationResolvers possibly added by\n     *\n     * {@link BindingDefaults#addAnnotationResolver(AnnotationResolver)}\n     * @return\n     */\n    // TODO remove suppression\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private List<AnnotationResolver> getAnnotationResolvers(final GeneratorContext context, final TreeLogger logger) {\n        java.lang.reflect.Method m = null;\n        ArrayList args = new ArrayList();\n        ArrayList types = new ArrayList();\n\n        types.add(GeneratorContext.class);\n        args.add(context);\n        types.add(TreeLogger.class);\n        args.add(logger);\n\n        Object[] argValues = args.toArray();\n        Class[] argtypes = (Class[]) types.toArray(new Class[argValues.length]);\n\n        try {\n             m = BINDING_DEFAULTS.getMethod(\"getAnnotationResolvers\", argtypes);\n        } catch (SecurityException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"could not resolve method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        List<AnnotationResolver> l = new ArrayList<AnnotationResolver>();\n        try {\n            l = (List<AnnotationResolver>) m.invoke(null, context, logger);\n        } catch (IllegalArgumentException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (InvocationTargetException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        return l;\n    }\n\n    private String returnRequest(boolean returnRequest, boolean isJsonp) {\n        String type = isJsonp ? JsonpRequest.class.getName() : Request.class.getName();\n        return returnRequest ? \"return (\"+type+\")\" : \"\";\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2015 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport static org.fusesource.restygwt.rebind.util.AnnotationUtils.getAnnotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.DELETE;\nimport javax.ws.rs.FormParam;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.HEAD;\nimport javax.ws.rs.HeaderParam;\nimport javax.ws.rs.OPTIONS;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.PUT;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.QueryParam;\n\nimport org.fusesource.restygwt.client.AbstractAsyncCallback;\nimport org.fusesource.restygwt.client.AbstractRequestCallback;\nimport org.fusesource.restygwt.client.Attribute;\nimport org.fusesource.restygwt.client.Defaults;\nimport org.fusesource.restygwt.client.Dispatcher;\nimport org.fusesource.restygwt.client.FormPostContent;\nimport org.fusesource.restygwt.client.JSONP;\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\nimport org.fusesource.restygwt.client.JsonCallback;\nimport org.fusesource.restygwt.client.JsonpMethod;\nimport org.fusesource.restygwt.client.Method;\nimport org.fusesource.restygwt.client.MethodCallback;\nimport org.fusesource.restygwt.client.Options;\nimport org.fusesource.restygwt.client.OverlayCallback;\nimport org.fusesource.restygwt.client.Resource;\nimport org.fusesource.restygwt.client.ResponseFormatException;\nimport org.fusesource.restygwt.client.RestService;\nimport org.fusesource.restygwt.client.RestServiceProxy;\nimport org.fusesource.restygwt.client.ServiceRoots;\nimport org.fusesource.restygwt.client.TextCallback;\nimport org.fusesource.restygwt.client.XmlCallback;\n\nimport com.google.gwt.core.client.JavaScriptObject;\nimport com.google.gwt.core.client.JsArray;\nimport com.google.gwt.core.client.JsArrayBoolean;\nimport com.google.gwt.core.client.JsArrayInteger;\nimport com.google.gwt.core.client.JsArrayNumber;\nimport com.google.gwt.core.client.JsArrayString;\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.PropertyOracle;\nimport com.google.gwt.core.ext.SelectionProperty;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.HasAnnotations;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JGenericType;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.core.ext.typeinfo.JTypeParameter;\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.jsonp.client.JsonpRequest;\nimport com.google.gwt.user.client.rpc.RemoteServiceRelativePath;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport com.google.gwt.xml.client.Document;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added automatically create resource from Path annotation,\n *         enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\npublic class RestServiceClassCreator extends BaseSourceCreator {\n\n    private static final String REST_SERVICE_PROXY_SUFFIX = \"_Generated_RestServiceProxy_\";\n\n    private static final String PLAIN_TEXT_AUTODETECTION_CONFIGURATION_PROPERTY_NAME = \"restygwt.autodetect.plaintText\";\n\n    private static final String METHOD_CLASS = Method.class.getName();\n    private static final String RESOURCE_CLASS = Resource.class.getName();\n    private static final String DISPATCHER_CLASS = Dispatcher.class.getName();\n    private static final String DEFAULTS_CLASS = Defaults.class.getName();\n    private static final String ABSTRACT_REQUEST_CALLBACK_CLASS = AbstractRequestCallback.class.getName();\n    private static final String ABSTRACT_ASYNC_CALLBACK_CLASS = AbstractAsyncCallback.class.getName();\n    private static final String JSON_PARSER_CLASS = JSONParser.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String REQUEST_EXCEPTION_CLASS = RequestException.class.getName();\n    private static final String RESPONSE_FORMAT_EXCEPTION_CLASS = ResponseFormatException.class.getName();\n    private static final String JSONP_METHOD_CLASS = JsonpMethod.class.getName();\n    private static final String FORM_POST_CONTENT_CLASS = FormPostContent.class.getName();\n    private static final String SERVICE_ROOTS_CLASS = ServiceRoots.class.getName();\n\n    /*\n     * static class in which are some compile-time relevant infos.\n     *\n     * TODO (andi): too much flexibility and overhead with reflection here?\n     */\n    private static final Class<BindingDefaults> BINDING_DEFAULTS = BindingDefaults.class;\n\n    private static final String METHOD_JSONP = \"jsonp\";\n    private static final String METHOD_PUT = \"put\";\n    private static final String METHOD_POST = \"post\";\n    private static final String METHOD_OPTIONS = \"options\";\n    private static final String METHOD_HEAD = \"head\";\n    private static final String METHOD_GET = \"get\";\n    private static final String METHOD_DELETE = \"delete\";\n\n    private static final HashSet<String> REST_METHODS = new HashSet<String>(8);\n    static {\n        REST_METHODS.add(METHOD_DELETE);\n        REST_METHODS.add(METHOD_GET);\n        REST_METHODS.add(METHOD_HEAD);\n        REST_METHODS.add(METHOD_OPTIONS);\n        REST_METHODS.add(METHOD_POST);\n        REST_METHODS.add(METHOD_PUT);\n        REST_METHODS.add(METHOD_JSONP);\n    }\n\n    private JClassType XML_CALLBACK_TYPE;\n    private JClassType METHOD_CALLBACK_TYPE;\n    private JClassType TEXT_CALLBACK_TYPE;\n    private JClassType JSON_CALLBACK_TYPE;\n    private JClassType OVERLAY_CALLBACK_TYPE;\n    private JClassType DOCUMENT_TYPE;\n    private JClassType METHOD_TYPE;\n    private JClassType STRING_TYPE;\n    private JClassType JSON_VALUE_TYPE;\n    private JClassType OVERLAY_VALUE_TYPE;\n    private Set<JClassType> OVERLAY_ARRAY_TYPES;\n    private Set<JClassType> QUERY_PARAM_LIST_TYPES;\n    private JClassType REST_SERVICE_TYPE;\n    private JsonEncoderDecoderInstanceLocator locator;\n\n    private boolean autodetectTypeForStrings;\n\n    public RestServiceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, REST_SERVICE_PROXY_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n    \tString parameters = \"\";\n    \tif(source instanceof JGenericType)\n    \t{\n    \t\tJGenericType gtype = (JGenericType)source;\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tbuilder.append(\"<\");\n\t\t\tboolean first = true;\n   \t\t\tfor(JTypeParameter arg : gtype.getTypeParameters())\n   \t\t\t{\n   \t\t\t\tif(!first)\n   \t\t\t\t\tbuilder.append(\",\");\n   \t\t\t\tbuilder.append(arg.getName());\n   \t\t\t\tbuilder.append(\" extends \");\n\t   \t\t\tbuilder.append(arg.getFirstBound().getParameterizedQualifiedSourceName());\n\t   \t\t\tfirst = false;\n   \t\t\t}\n   \t\t\tbuilder.append(\">\");\n   \t\t\tparameters = builder.toString();\n     \t}\n\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName + parameters);\n        composerFactory.addImplementedInterface(source.getParameterizedQualifiedSourceName());\n        composerFactory.addImplementedInterface(RestServiceProxy.class.getName());\n        return composerFactory;\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n\n        if (source.isInterface() == null) {\n            getLogger().log(ERROR, \"Type is not an interface.\");\n            throw new UnableToCompleteException();\n        }\n\n        autodetectTypeForStrings = shouldAutodetectPlainTextForStrings(getLogger(), context.getPropertyOracle());\n\n        locator = new JsonEncoderDecoderInstanceLocator(context, getLogger());\n\n        this.XML_CALLBACK_TYPE = find(XmlCallback.class, getLogger(), context);\n        this.METHOD_CALLBACK_TYPE = find(MethodCallback.class, getLogger(), context);\n        this.TEXT_CALLBACK_TYPE = find(TextCallback.class, getLogger(), context);\n        this.JSON_CALLBACK_TYPE = find(JsonCallback.class, getLogger(), context);\n        this.OVERLAY_CALLBACK_TYPE = find(OverlayCallback.class, getLogger(), context);\n        this.DOCUMENT_TYPE = find(Document.class, getLogger(), context);\n        this.METHOD_TYPE = find(Method.class, getLogger(), context);\n        this.STRING_TYPE = find(String.class, getLogger(), context);\n        this.JSON_VALUE_TYPE = find(JSONValue.class, getLogger(), context);\n        this.OVERLAY_VALUE_TYPE = find(JavaScriptObject.class, getLogger(), context);\n        this.OVERLAY_ARRAY_TYPES = new HashSet<JClassType>();\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArray.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayBoolean.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayInteger.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayNumber.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayString.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES = new HashSet<JClassType>();\n        this.QUERY_PARAM_LIST_TYPES.add(find(Collection.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES.add(find(List.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES.add(find(Set.class, getLogger(), context));\n\t\tthis.REST_SERVICE_TYPE = find(RestService.class, getLogger(), context);\n\n        String path = getPathFromSource(source);\n\n        p(\"private \" + RESOURCE_CLASS + \" resource = null;\");\n        p();\n\n        p(\"public void setResource(\" + RESOURCE_CLASS + \" resource) {\").i(1);\n        {\n            p(\"this.resource = resource;\");\n        }\n        i(-1).p(\"}\");\n\n        Options options = getAnnotation(source, Options.class);\n\n        p(\"public \" + RESOURCE_CLASS + \" getResource() {\").i(1);\n        {\n            p(\"if (this.resource == null) {\").i(1);\n\n            if (options != null && options.serviceRootKey() != null && !options.serviceRootKey().isEmpty()) {\n            \tp(\"String serviceRoot = \" + SERVICE_ROOTS_CLASS + \".get(\\\"\" + options.serviceRootKey() + \"\\\");\");\n            } else {\n            \tp(\"String serviceRoot = \" + DEFAULTS_CLASS + \".getServiceRoot();\");\n            }\n\n            if (path == null) {\n                p(\"this.resource = new \" + RESOURCE_CLASS + \"(serviceRoot);\");\n            } else {\n                p(\"this.resource = new \" + RESOURCE_CLASS + \"(serviceRoot).resolve(\"+quote(path)+\");\");\n            }\n\n            i(-1).p(\"}\");\n            p(\"return this.resource;\");\n        }\n        i(-1).p(\"}\");\n\n\n        if( options!=null && options.dispatcher()!=Dispatcher.class ) {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = \"+options.dispatcher().getName()+\".INSTANCE;\");\n        } else {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = null;\");\n        }\n\n        p();\n        p(\"public void setDispatcher(\" + DISPATCHER_CLASS + \" dispatcher) {\").i(1);\n        {\n            p(\"this.dispatcher = dispatcher;\");\n        }\n        i(-1).p(\"}\");\n\n        p();\n        p(\"public \" + DISPATCHER_CLASS + \" getDispatcher() {\").i(1);\n        {\n            p(\"return this.dispatcher;\");\n        }\n        i(-1).p(\"}\");\n\n        for (JMethod method : source.getInheritableMethods()) {\n        \tJClassType iface = method.getReturnType().isInterface();\n        \tif(iface != null && REST_SERVICE_TYPE.isAssignableFrom(iface))\n        \t\twriteSubresourceLocatorImpl(method);\n        \telse\n                writeMethodImpl(method, options);\n        }\n    }\n\n    /**\n     * Returns {@code true} if plain text autodetection for strings should be used.\n     */\n    static boolean shouldAutodetectPlainTextForStrings(TreeLogger logger, PropertyOracle propertyOracle) {\n        try {\n            SelectionProperty prop = propertyOracle.getSelectionProperty(logger, PLAIN_TEXT_AUTODETECTION_CONFIGURATION_PROPERTY_NAME);\n            String propVal = prop.getCurrentValue();\n            return Boolean.parseBoolean(propVal);\n        } catch (BadPropertyValueException e) {\n            // use default \"false\"\n        }\n        return false;\n    }\n\n    private static String getPathFromSource(HasAnnotations annotatedType) {\n        String path = null;\n\n        Path pathAnnotation = getAnnotation(annotatedType, Path.class);\n        if (pathAnnotation != null) {\n            path = pathAnnotation.value();\n        }\n\n        RemoteServiceRelativePath relativePath = getAnnotation(annotatedType, RemoteServiceRelativePath.class);\n        if (relativePath != null) {\n            path = relativePath.value();\n        }\n\n        return path;\n    }\n\n    private String quote(String path) {\n        // TODO: unlikely to occur. but we should escape chars like newlines..\n        return \"\\\"\" + path + \"\\\"\";\n    }\n\n    private boolean isOverlayArrayType(JClassType type) {\n        for (JClassType arrayType : OVERLAY_ARRAY_TYPES) {\n            if (type.isAssignableTo(arrayType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isQueryParamListType(JClassType type) {\n        if (type.isParameterized() == null) {\n            return false;\n        }\n        for (JClassType listType : QUERY_PARAM_LIST_TYPES) {\n            if (type.isAssignableTo(listType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void writeSubresourceLocatorImpl(JMethod method) throws UnableToCompleteException\n    {\n    \tJClassType iface = method.getReturnType().isInterface();\n    \tif(iface == null || !REST_SERVICE_TYPE.isAssignableFrom(iface)) {\n    \t\tgetLogger().log(ERROR, \"Invalid subresource locator method. Method must have return type of an interface that extends RestService: \" + method.getReadableDeclaration());\n            throw new UnableToCompleteException();\n    \t}\n\n        Path pathAnnotation = getAnnotation(method, Path.class);\n        if (pathAnnotation == null) {\n        \tgetLogger().log(ERROR, \"Invalid subresource locator method. Method must have @Path annotation: \" + method.getReadableDeclaration());\n            throw new UnableToCompleteException();\n        }\n        String pathExpression = wrap(pathAnnotation.value());\n\n        for (JParameter arg : method.getParameters()) {\n            PathParam paramPath = getAnnotation(arg, PathParam.class);\n            if (paramPath != null) {\n                pathExpression = pathExpression(pathExpression, arg, paramPath);\n            }\n        }\n\n\n        p(method.getReadableDeclaration(false, false, false, false, true) + \" {\").i(1);\n        {\n        \tJType type = method.getReturnType();\n        \tString name;\n        \tif(type instanceof JClassType)\n        \t{\n                JClassType restService = (JClassType)type;\n                RestServiceClassCreator generator = new RestServiceClassCreator(getLogger(), context, restService);\n                name = generator.create();\n        \t}\n        \telse\n        \t{\n        \t\tthrow new UnsupportedOperationException(\"Subresource method may not return: \" + type);\n        \t}\n        \tp(method.getReturnType().getQualifiedSourceName() + \" __subresource = new \" + name + \"();\");\n                p(\"((\" + RestServiceProxy.class.getName() + \")__subresource).setResource(getResource().resolve(\" + pathExpression + \"));\");\n                p(\"((\" + RestServiceProxy.class.getName() + \")__subresource).setDispatcher(getDispatcher());\");\n        \tp(\"return __subresource;\");\n        }\n        i(-1).p(\"}\");\n    }\n\n    private String pathExpression(String pathExpression, JParameter arg, PathParam paramPath) {\n        String expr = toStringExpression(arg);\n        return pathExpression.replaceAll(Pattern.quote(\"{\" + paramPath.value()) + \"(\\\\s*:\\\\s*(.)+)?\\\\}\",\n               \"\\\"+(\" + expr + \"== null? null : ((\\\"\\\" + \" + expr +\").startsWith(\\\"http\\\") ? \" + expr +\n               \" : com.google.gwt.http.client.URL.encodePathSegment(\" + expr + \")))+\\\"\");\n    }\n\n    void writeOptions(Options options, Options classOptions) {\n        // configure the dispatcher\n        if (options != null && options.dispatcher() != Dispatcher.class) {\n            // use the dispatcher configured for the method.\n            p(\"__method.setDispatcher(\" + options.dispatcher().getName() + \".INSTANCE);\");\n        } else {\n            // use the default dispatcher configured for the service..\n            p(\"__method.setDispatcher(this.dispatcher);\");\n        }\n\n        // configure the expected statuses..\n        if (options != null && options.expect().length != 0) {\n            // Using method level defined expected status\n            p(\"__method.expect(\" + join(options.expect(), \", \") + \");\");\n        } else if (classOptions != null && classOptions.expect().length != 0) {\n            // Using class level defined expected status\n            p(\"__method.expect(\" + join(classOptions.expect(), \", \") + \");\");\n        }\n\n        // configure the timeout\n        if (options != null && options.timeout() >= 0) {\n            // Using method level defined value\n            p(\"__method.timeout(\" + options.timeout() + \");\");\n        } else if (classOptions != null && classOptions.timeout() >= 0) {\n            // Using class level defined value\n            p(\"__method.timeout(\" + classOptions.timeout() + \");\");\n        }\n    }\n\n    private void writeMethodImpl(JMethod method, Options classOptions) throws UnableToCompleteException {\n        boolean returnRequest = false;\n        if (method.getReturnType() != JPrimitiveType.VOID) {\n            if (!method.getReturnType().getQualifiedSourceName().equals(Request.class.getName()) &&\n                !method.getReturnType().getQualifiedSourceName().equals(JsonpRequest.class.getName())) {\n                getLogger().log(ERROR, \"Invalid rest method. Method must have void, Request or JsonpRequest return types: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            returnRequest = true;\n        }\n\n        Json jsonAnnotation = getAnnotation(source, Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n\n        Options options = getAnnotation(method, Options.class);\n\n        p(method.getReadableDeclaration(false, false, false, false, true) + \" {\").i(1);\n        {\n            String restMethod = getRestMethod(method);\n            LinkedList<JParameter> args = new LinkedList<JParameter>(Arrays.asList(method.getParameters()));\n            for (final JParameter arg : args.subList(0, args.size() - 1)) {\n                p(\"final \"\n                        + arg.getType().getParameterizedQualifiedSourceName()\n                        + \" final_\" + arg.getName() + \" = \" + arg.getName()\n                        + \";\");\n            }\n\n            // the last arg should be the callback.\n            if (args.isEmpty()) {\n                getLogger().log(ERROR, \"Invalid rest method. Method must declare at least a callback argument: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            JParameter callbackArg = args.removeLast();\n            JClassType callbackType = callbackArg.getType().isClassOrInterface();\n            JClassType methodCallbackType = METHOD_CALLBACK_TYPE;\n            if (callbackType == null || !callbackType.isAssignableTo(methodCallbackType)) {\n                getLogger().log(ERROR, \"Invalid rest method. Last argument must be a \" + methodCallbackType.getName() + \" type: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            JClassType resultType = getCallbackTypeGenericClass(callbackType);\n\n            String pathExpression = null;\n            Path pathAnnotation = getAnnotation(method, Path.class);\n            if (pathAnnotation != null) {\n                pathExpression = wrap(pathAnnotation.value());\n            }\n\n            JParameter contentArg = null;\n            HashMap<String, JParameter> queryParams = new HashMap<String, JParameter>();\n            HashMap<String, JParameter> formParams = new HashMap<String, JParameter>();\n            HashMap<String, JParameter> headerParams = new HashMap<String, JParameter>();\n\n            for (JParameter arg : args) {\n                PathParam paramPath = getAnnotation(arg, PathParam.class);\n                if (paramPath != null) {\n                    if (pathExpression == null) {\n                        getLogger().log(ERROR, \"Invalid rest method.  Invalid @PathParam annotation. Method is missing the @Path annotation: \" + method.getReadableDeclaration());\n                        throw new UnableToCompleteException();\n                    }\n                    pathExpression = pathExpression(pathExpression, arg, paramPath);\n                    //.replaceAll(Pattern.quote(\"{\" + paramPath.value() + \"}\"), \"\\\"+com.google.gwt.http.client.URL.encodePathSegment(\" + toStringExpression(arg) + \")+\\\"\");\n                    if (getAnnotation(arg, Attribute.class) != null) {\n                        // allow part of the arg-object participate in as PathParam and the object goes over the wire\n                        contentArg = arg;\n                    }\n                    continue;\n                }\n\n                QueryParam queryParam = getAnnotation(arg, QueryParam.class);\n                if (queryParam != null) {\n                    queryParams.put(queryParam.value(), arg);\n                    continue;\n                }\n\n                FormParam formParam = getAnnotation(arg, FormParam.class);\n                if (formParam != null) {\n                    formParams.put(formParam.value(), arg);\n                    continue;\n                }\n\n                HeaderParam headerParam = getAnnotation(arg, HeaderParam.class);\n                if (headerParam != null) {\n                    headerParams.put(headerParam.value(), arg);\n                    continue;\n                }\n\n                if (!formParams.isEmpty()) {\n                    getLogger().log(ERROR, \"You can not have both @FormParam parameters and a content parameter: \" +\n                                                method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n\n                if (contentArg != null) {\n                    getLogger().log(ERROR, \"Invalid rest method. Only one content parameter is supported: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n                contentArg = arg;\n            }\n\n            String acceptTypeBuiltIn = null;\n            if (callbackType.equals(TEXT_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_TEXT\";\n            } else if (callbackType.equals(JSON_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.isAssignableTo(OVERLAY_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.equals(XML_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_XML\";\n            }\n\n            // Handle JSONP specific configuration...\n            JSONP jsonpAnnotation = getAnnotation(method, JSONP.class);\n\n            final boolean isJsonp = restMethod.equals(METHOD_JSONP) && jsonpAnnotation != null;\n\n            p(\"final \" + (isJsonp ? JSONP_METHOD_CLASS : METHOD_CLASS) + \" __method =\");\n\n            p(\"getResource()\");\n            if (pathExpression != null) {\n                p(\".resolve(\" + pathExpression + \")\");\n            }\n            for (Map.Entry<String, JParameter> entry : queryParams.entrySet()) {\n                String expr = entry.getValue().getName();\n                JClassType type = entry.getValue().getType().isClassOrInterface();\n                if (type != null && isQueryParamListType(type)) {\n                    p(\".addQueryParams(\" + wrap(entry.getKey()) + \", \" +\n                      toIteratedStringExpression(entry.getValue()) + \")\");\n                } else {\n                    p(\".addQueryParam(\" + wrap(entry.getKey()) + \", \" +\n                      toStringExpression(entry.getValue().getType(), expr) + \")\");\n                }\n            }\n            // example: .get()\n            p(\".\" + restMethod + \"();\");\n\n            if( isJsonp ) {\n                if (returnRequest && !method.getReturnType().getQualifiedSourceName().equals(JsonpRequest.class.getName())) {\n                    getLogger().log(ERROR, \"Invalid rest method. JSONP method must have void or JsonpRequest return types: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n                if( jsonpAnnotation.callbackParam().length() > 0 ) {\n                    p(\"__method.callbackParam(\"+wrap(jsonpAnnotation.callbackParam())+\");\");\n                }\n                if( jsonpAnnotation.failureCallbackParam().length() > 0 ) {\n                    p(\"__method.failureCallbackParam(\"+wrap(jsonpAnnotation.failureCallbackParam())+\");\");\n                }\n            } else {\n                if (returnRequest && !method.getReturnType().getQualifiedSourceName().equals(Request.class.getName())) {\n                    getLogger().log(ERROR, \"Invalid rest method. Non JSONP method must have void or Request return types: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n            }\n\n            writeOptions(options, classOptions);\n\n            if (jsonpAnnotation == null) {\n                final String acceptHeader;\n                Produces producesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Produces.class);\n                if (producesAnnotation != null) {\n                    // Do not use autodetection, if accept type already set\n                    if (acceptTypeBuiltIn == null && autodetectTypeForStrings && producesAnnotation.value()[0].startsWith(\"text/\")) {\n                        acceptTypeBuiltIn = \"CONTENT_TYPE_TEXT\";\n                    }\n                    acceptHeader = wrap(producesAnnotation.value()[0]);\n                } else {\n                    // set the default accept header value ...\n                    if (acceptTypeBuiltIn != null) {\n                        acceptHeader = RESOURCE_CLASS + \".\" + acceptTypeBuiltIn;\n                    } else {\n                        acceptHeader = RESOURCE_CLASS + \".CONTENT_TYPE_JSON\";\n                    }\n                }\n                p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \" + acceptHeader + \");\");\n\n                Consumes consumesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Consumes.class);\n                if (consumesAnnotation != null) {\n                    p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_CONTENT_TYPE, \" + wrap(consumesAnnotation.value()[0]) + \");\");\n                }\n\n                // and set the explicit headers now (could override the accept header)\n                for (Map.Entry<String, JParameter> entry : headerParams.entrySet()) {\n                    String expr = entry.getValue().getName();\n                    p(\"__method.header(\" + wrap(entry.getKey()) + \", \" + toStringExpression(entry.getValue().getType(), expr) + \");\");\n                }\n            }\n\n            if (! formParams.isEmpty()) {\n                p(FORM_POST_CONTENT_CLASS + \" __formPostContent = new \" + FORM_POST_CONTENT_CLASS + \"();\");\n\n                for (Map.Entry<String, JParameter> entry : formParams.entrySet()) {\n                    JClassType type = entry.getValue().getType()\n                            .isClassOrInterface();\n                    if (type != null && isQueryParamListType(type)) {\n                        p(\"__formPostContent.addParameters(\" +\n                                wrap(entry.getKey()) + \", \" +\n                                toIteratedFormStringExpression(entry.getValue(), classStyle) +\n                                \");\");\n                    } else {\n                        p(\"__formPostContent.addParameter(\" +\n                                wrap(entry.getKey()) + \", \" +\n                                toFormStringExpression(entry.getValue(), classStyle) +\n                                \");\");\n                    }\n                }\n\n                p(\"__method.form(__formPostContent.getTextContent());\");\n            }\n\n            if (contentArg != null) {\n                if (contentArg.getType() == STRING_TYPE) {\n                    p(\"__method.text(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType() == JSON_VALUE_TYPE) {\n                    p(\"__method.json(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType().isClass() != null &&\n                           isOverlayArrayType(contentArg.getType().isClass())) {\n                    p(\"__method.json(new \" + JSON_ARRAY_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType().isClass() != null &&\n                           contentArg.getType().isClass().isAssignableTo(OVERLAY_VALUE_TYPE)) {\n                    p(\"__method.json(new \" + JSON_OBJECT_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType() == DOCUMENT_TYPE) {\n                    p(\"__method.xml(\" + contentArg.getName() + \");\");\n                } else {\n                    JClassType contentClass = contentArg.getType().isClass();\n                    if (contentClass == null) {\n                        contentClass = contentArg.getType().isClassOrInterface();\n                        if (!locator.isCollectionType(contentClass)) {\n                            getLogger().log(ERROR, \"Content argument must be a class.\");\n                            throw new UnableToCompleteException();\n                        }\n                    }\n\n                    jsonAnnotation = getAnnotation(contentArg, Json.class);\n                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n                    // example:\n                    // .json(Listings$_Generated_JsonEncoder_$.INSTANCE.encode(arg0)\n                    // )\n                    p(\"__method.json(\" + locator.encodeExpression(contentClass, contentArg.getName(), style) + \");\");\n                }\n            }\n\n\n            List<AnnotationResolver> annotationResolvers = getAnnotationResolvers(context, getLogger());\n            getLogger().log(TreeLogger.DEBUG, \"found \" + annotationResolvers.size() + \" additional AnnotationResolvers\");\n\n            for (AnnotationResolver a : annotationResolvers) {\n                getLogger().log(TreeLogger.DEBUG, \"(\" + a.getClass().getName() + \") resolve `\" + source.getName()\n                        + \"#\" + method.getName() + \" ...\");\n                final Map<String, String[]> addDataParams = a.resolveAnnotation(getLogger(), source, method, restMethod);\n\n                if (addDataParams != null) {\n                    for (String s : addDataParams.keySet()) {\n                        final StringBuilder sb = new StringBuilder();\n                        final List<String> classList = Arrays.asList(addDataParams.get(s));\n\n                        sb.append(\"[\");\n                        for (int i = 0; i < classList.size(); ++i) {\n                            sb.append(\"\\\\\\\"\").append(classList.get(i)).append(\"\\\\\\\"\");\n\n                            if ((i+1) <  classList.size()) {\n                                sb.append(\",\");\n                            }\n                        }\n                        sb.append(\"]\");\n\n                        getLogger().log(TreeLogger.DEBUG, \"add call with (\\\"\" + s + \"\\\", \\\"\" +\n                                sb.toString() + \"\\\")\");\n                        p(\"__method.addData(\\\"\" + s + \"\\\", \\\"\" + sb.toString() + \"\\\");\");\n                    }\n                }\n            }\n\n\n            if (acceptTypeBuiltIn != null) {\n                // TODO: shouldn't we also have a cach in here?\n                p(returnRequest(returnRequest,isJsonp) + \"__method.send(\" + callbackArg.getName() + \");\");\n            } else if ( isJsonp ){\n                    p(returnRequest(returnRequest,isJsonp) + \"__method.send(new \" + ABSTRACT_ASYNC_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">(__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult(\" + JSON_VALUE_CLASS + \" result) throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) null;\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    if(resultType.isAssignableTo(locator.LIST_TYPE)){\n                                        p(\"result = new \" + JSON_ARRAY_CLASS + \"(((\" + JSON_OBJECT_CLASS + \")result).getJavaScriptObject());\");\n                                    }\n                                    jsonAnnotation = getAnnotation(method, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, \"result\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n            } else {\n                p(\"try {\").i(1);\n                {\n                    p(returnRequest(returnRequest,isJsonp) + \"__method.send(new \" + ABSTRACT_REQUEST_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">(__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult() throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) null;\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    jsonAnnotation = getAnnotation(method, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, JSON_PARSER_CLASS + \".parse(__method.getResponse().getText())\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n                }\n                i(-1).p(\"} catch (\" + REQUEST_EXCEPTION_CLASS + \" __e) {\").i(1);\n                {\n                    p(callbackArg.getName() + \".onFailure(__method,__e);\");\n                    if (returnRequest) {\n                        p(\"return null;\");\n                    }\n                }\n                i(-1).p(\"}\");\n            }\n        }\n        i(-1).p(\"}\");\n    }\n\n    private <T extends Annotation> T findAnnotationOnMethodOrEnclosingType(final JMethod method, final Class<T> annotationType) {\n        T annotation = getAnnotation(method, annotationType);\n        if (annotation == null) {\n            annotation = getAnnotation(method.getEnclosingType(), annotationType);\n        }\n        return annotation;\n    }\n\n    protected String toStringExpression(JParameter arg) {\n        Attribute attribute = getAnnotation(arg, Attribute.class);\n        if(attribute != null){\n            return \"(\" + arg.getName() + \".\" + attribute.value() + \"+ \\\"\\\")\";\n        }\n        return toStringExpression(arg.getType(), arg.getName());\n    }\n\n    protected String toFormStringExpression(JParameter argument, Style classStyle) throws UnableToCompleteException {\n        JType type = argument.getType();\n        String expr = argument.getName();\n\n        if (type.isPrimitive() != null) {\n            return \"\\\"\\\"+\" + expr;\n        }\n        if (STRING_TYPE == type) {\n            return expr;\n        }\n        if (type.isClass() != null &&\n                isOverlayArrayType(type.isClass())) {\n            return \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.isClass() != null &&\n                OVERLAY_VALUE_TYPE.isAssignableFrom(type.isClass())) {\n            return \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.getQualifiedBinaryName().startsWith(\"java.lang.\") || type.isEnum() != null) {\n            return String.format(\"(%s != null ? %s.toString() : null)\", expr, expr);\n        }\n\n        Json jsonAnnotation = getAnnotation(argument, Json.class);\n        final Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n        return locator.encodeExpression(type, expr, style) + \".toString()\";\n    }\n\n    protected String toIteratedFormStringExpression(JParameter argument, Style classStyle) throws UnableToCompleteException {\n        assert isQueryParamListType(argument.getType().isClassOrInterface());\n        final JClassType[] type_args = argument.getType().isParameterized().getTypeArgs();\n        assert (type_args.length == 1);\n        final JClassType class_type = type_args[0];\n        final String argument_expr = \"final_\"\n                + argument.getName();\n\n        final StringBuilder result = new StringBuilder();\n        result.append(argument_expr + \" == null ? null : \");\n        result.append(\"new java.lang.Iterable<String> () {\\n\");\n        result.append(\" @Override\\n\");\n        result.append(\" public java.util.Iterator<String> iterator() {\\n\");\n        result.append(\"     final java.util.Iterator<\"\n                + class_type.getParameterizedQualifiedSourceName()\n                + \"> baseIterator =  \" + argument_expr + \".iterator();\\n\");\n        result.append(\"     return new java.util.Iterator<String>() {\\n\");\n        result.append(\"         @Override\\n\");\n        result.append(\"         public boolean hasNext() {\\n\");\n        result.append(\"           return baseIterator.hasNext();\\n\");\n        result.append(\"         }\\n\");\n        result.append(\"         @Override\\n\");\n        result.append(\"         public String next() {\\n\");\n        final String expr = \"baseIterator.next()\";\n        String returnExpr;\n        if (class_type.isPrimitive() != null) {\n            returnExpr = \"\\\"\\\"+\" + expr;\n        } else if (STRING_TYPE == class_type) {\n            returnExpr = expr;\n        } else if (class_type.isClass() != null &&\n            isOverlayArrayType(class_type.isClass())) {\n            returnExpr = \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        } else if (class_type.isClass() != null &&\n            OVERLAY_VALUE_TYPE.isAssignableFrom(class_type.isClass())) {\n            returnExpr = \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        } else if (class_type.getQualifiedBinaryName().startsWith(\"java.lang.\")) {\n            result.append(\"             Object obj = \" + expr + \";\");\n            returnExpr = \"obj != null ? obj.toString() : null\";\n        } else {\n            Json jsonAnnotation = getAnnotation(argument, Json.class);\n            final Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n            returnExpr = locator.encodeExpression(class_type, expr, style) + \".toString()\";\n        }\n        result.append(\"             return \" + returnExpr + \";\\n\");\n        result.append(\"         }\\n\");\n        result.append(\"         @Override\\n\");\n        result.append(\"         public void remove() {\\n\");\n        result.append(\"             throw new UnsupportedOperationException();\\n\");\n        result.append(\"         }\\n\");\n        result.append(\"     };\\n\");\n        result.append(\" }\\n\");\n        result.append(\"}\\n\");\n\n        return result.toString();\n    }\n\n    protected String toStringExpression(JType type, String expr) {\n        if (type.isPrimitive() != null) {\n            return \"\\\"\\\"+\" + expr;\n        }\n        if (STRING_TYPE == type) {\n            return expr;\n        }\n        if (type.isClass() != null &&\n            isOverlayArrayType(type.isClass())) {\n          return \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.isClass() != null &&\n            OVERLAY_VALUE_TYPE.isAssignableFrom(type.isClass())) {\n          return \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        }\n\n        return String.format(\"(%s != null ? %s.toString() : null)\", expr, expr);\n    }\n\n    protected String toIteratedStringExpression(JParameter arg) {\n        StringBuilder result = new StringBuilder();\n        result.append(\"new org.fusesource.restygwt.client.StringIterable (\")\n            .append(arg.getName()).append(\")\");\n\n        return result.toString();\n    }\n\n    private JClassType getCallbackTypeGenericClass(final JClassType callbackType) throws UnableToCompleteException {\n        return branch(\"getCallbackTypeGenericClass()\", new Branch<JClassType>() {\n            @Override\n            public JClassType execute() throws UnableToCompleteException {\n\n                for (JMethod method : callbackType.getOverridableMethods()) {\n                    getLogger().log(DEBUG, \"checking method: \" + method.getName());\n                    if (method.getName().equals(\"onSuccess\")) {\n                        JParameter[] parameters = method.getParameters();\n                        getLogger().log(DEBUG, \"checking method params: \" + parameters.length);\n                        if (parameters.length == 2) {\n                            getLogger().log(DEBUG, \"checking first param: \" + parameters[0].getType());\n                            if (parameters[0].getType() == METHOD_TYPE) {\n                                getLogger().log(DEBUG, \"checking 2nd param: \" + parameters[1].getType());\n                                JType param2Type = parameters[1].getType();\n                                JClassType type = param2Type.isClassOrInterface();\n                                if (type == null) {\n                                    getLogger().log(ERROR, \"The type of the callback not supported: \" + param2Type.getJNISignature());\n                                    throw new UnableToCompleteException();\n                                }\n                                getLogger().log(DEBUG, \"match: \" + type);\n                                return type;\n                            }\n                        }\n                    }\n                }\n                getLogger().log(ERROR, \"The type of the callback could not be determined: \" + callbackType.getParameterizedQualifiedSourceName());\n                throw new UnableToCompleteException();\n            }\n        });\n    }\n\n    private String getRestMethod(JMethod method) throws UnableToCompleteException {\n        String restMethod = null;\n        if (getAnnotation(method, DELETE.class) != null) {\n            restMethod = METHOD_DELETE;\n        } else if (getAnnotation(method, GET.class) != null) {\n            restMethod = METHOD_GET;\n        } else if (getAnnotation(method, HEAD.class) != null) {\n            restMethod = METHOD_HEAD;\n        } else if (getAnnotation(method, OPTIONS.class) != null) {\n            restMethod = METHOD_OPTIONS;\n        } else if (getAnnotation(method, POST.class) != null) {\n            restMethod = METHOD_POST;\n        } else if (getAnnotation(method, PUT.class) != null) {\n            restMethod = METHOD_PUT;\n        } else if (getAnnotation(method, JSONP.class) != null) {\n            restMethod = METHOD_JSONP;\n        } else {\n            restMethod = method.getName();\n            if (!REST_METHODS.contains(restMethod)) {\n                getLogger().log(ERROR, \"Invalid rest method. It must either have a lower case rest method name or have a javax rs method annotation: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n        }\n        return restMethod;\n    }\n\n    /**\n     * access additional AnnotationResolvers possibly added by\n     *\n     * {@link BindingDefaults#addAnnotationResolver(AnnotationResolver)}\n     * @return\n     */\n    // TODO remove suppression\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private List<AnnotationResolver> getAnnotationResolvers(final GeneratorContext context, final TreeLogger logger) {\n        java.lang.reflect.Method m = null;\n        ArrayList args = new ArrayList();\n        ArrayList types = new ArrayList();\n\n        types.add(GeneratorContext.class);\n        args.add(context);\n        types.add(TreeLogger.class);\n        args.add(logger);\n\n        Object[] argValues = args.toArray();\n        Class[] argtypes = (Class[]) types.toArray(new Class[argValues.length]);\n\n        try {\n             m = BINDING_DEFAULTS.getMethod(\"getAnnotationResolvers\", argtypes);\n        } catch (SecurityException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"could not resolve method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        List<AnnotationResolver> l = new ArrayList<AnnotationResolver>();\n        try {\n            l = (List<AnnotationResolver>) m.invoke(null, context, logger);\n        } catch (IllegalArgumentException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (InvocationTargetException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        return l;\n    }\n\n    private String returnRequest(boolean returnRequest, boolean isJsonp) {\n        String type = isJsonp ? JsonpRequest.class.getName() : Request.class.getName();\n        return returnRequest ? \"return (\"+type+\")\" : \"\";\n    }\n}\n","lineNo":601}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2015 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport static org.fusesource.restygwt.rebind.util.AnnotationUtils.getAnnotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.DELETE;\nimport javax.ws.rs.FormParam;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.HEAD;\nimport javax.ws.rs.HeaderParam;\nimport javax.ws.rs.OPTIONS;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.PUT;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.QueryParam;\n\nimport org.fusesource.restygwt.client.AbstractAsyncCallback;\nimport org.fusesource.restygwt.client.AbstractRequestCallback;\nimport org.fusesource.restygwt.client.Attribute;\nimport org.fusesource.restygwt.client.Defaults;\nimport org.fusesource.restygwt.client.Dispatcher;\nimport org.fusesource.restygwt.client.FormPostContent;\nimport org.fusesource.restygwt.client.JSONP;\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\nimport org.fusesource.restygwt.client.JsonCallback;\nimport org.fusesource.restygwt.client.JsonpMethod;\nimport org.fusesource.restygwt.client.Method;\nimport org.fusesource.restygwt.client.MethodCallback;\nimport org.fusesource.restygwt.client.Options;\nimport org.fusesource.restygwt.client.OverlayCallback;\nimport org.fusesource.restygwt.client.Resource;\nimport org.fusesource.restygwt.client.ResponseFormatException;\nimport org.fusesource.restygwt.client.RestService;\nimport org.fusesource.restygwt.client.RestServiceProxy;\nimport org.fusesource.restygwt.client.ServiceRoots;\nimport org.fusesource.restygwt.client.TextCallback;\nimport org.fusesource.restygwt.client.XmlCallback;\n\nimport com.google.gwt.core.client.JavaScriptObject;\nimport com.google.gwt.core.client.JsArray;\nimport com.google.gwt.core.client.JsArrayBoolean;\nimport com.google.gwt.core.client.JsArrayInteger;\nimport com.google.gwt.core.client.JsArrayNumber;\nimport com.google.gwt.core.client.JsArrayString;\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.PropertyOracle;\nimport com.google.gwt.core.ext.SelectionProperty;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.HasAnnotations;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JGenericType;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.core.ext.typeinfo.JTypeParameter;\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.jsonp.client.JsonpRequest;\nimport com.google.gwt.user.client.rpc.RemoteServiceRelativePath;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport com.google.gwt.xml.client.Document;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added automatically create resource from Path annotation,\n *         enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\npublic class RestServiceClassCreator extends BaseSourceCreator {\n\n    private static final String REST_SERVICE_PROXY_SUFFIX = \"_Generated_RestServiceProxy_\";\n\n    private static final String PLAIN_TEXT_AUTODETECTION_CONFIGURATION_PROPERTY_NAME = \"restygwt.autodetect.plaintText\";\n\n    private static final String METHOD_CLASS = Method.class.getName();\n    private static final String RESOURCE_CLASS = Resource.class.getName();\n    private static final String DISPATCHER_CLASS = Dispatcher.class.getName();\n    private static final String DEFAULTS_CLASS = Defaults.class.getName();\n    private static final String ABSTRACT_REQUEST_CALLBACK_CLASS = AbstractRequestCallback.class.getName();\n    private static final String ABSTRACT_ASYNC_CALLBACK_CLASS = AbstractAsyncCallback.class.getName();\n    private static final String JSON_PARSER_CLASS = JSONParser.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String REQUEST_EXCEPTION_CLASS = RequestException.class.getName();\n    private static final String RESPONSE_FORMAT_EXCEPTION_CLASS = ResponseFormatException.class.getName();\n    private static final String JSONP_METHOD_CLASS = JsonpMethod.class.getName();\n    private static final String FORM_POST_CONTENT_CLASS = FormPostContent.class.getName();\n    private static final String SERVICE_ROOTS_CLASS = ServiceRoots.class.getName();\n\n    /*\n     * static class in which are some compile-time relevant infos.\n     *\n     * TODO (andi): too much flexibility and overhead with reflection here?\n     */\n    private static final Class<BindingDefaults> BINDING_DEFAULTS = BindingDefaults.class;\n\n    private static final String METHOD_JSONP = \"jsonp\";\n    private static final String METHOD_PUT = \"put\";\n    private static final String METHOD_POST = \"post\";\n    private static final String METHOD_OPTIONS = \"options\";\n    private static final String METHOD_HEAD = \"head\";\n    private static final String METHOD_GET = \"get\";\n    private static final String METHOD_DELETE = \"delete\";\n\n    private static final HashSet<String> REST_METHODS = new HashSet<String>(8);\n    static {\n        REST_METHODS.add(METHOD_DELETE);\n        REST_METHODS.add(METHOD_GET);\n        REST_METHODS.add(METHOD_HEAD);\n        REST_METHODS.add(METHOD_OPTIONS);\n        REST_METHODS.add(METHOD_POST);\n        REST_METHODS.add(METHOD_PUT);\n        REST_METHODS.add(METHOD_JSONP);\n    }\n\n    private JClassType XML_CALLBACK_TYPE;\n    private JClassType METHOD_CALLBACK_TYPE;\n    private JClassType TEXT_CALLBACK_TYPE;\n    private JClassType JSON_CALLBACK_TYPE;\n    private JClassType OVERLAY_CALLBACK_TYPE;\n    private JClassType DOCUMENT_TYPE;\n    private JClassType METHOD_TYPE;\n    private JClassType STRING_TYPE;\n    private JClassType JSON_VALUE_TYPE;\n    private JClassType OVERLAY_VALUE_TYPE;\n    private Set<JClassType> OVERLAY_ARRAY_TYPES;\n    private Set<JClassType> QUERY_PARAM_LIST_TYPES;\n    private JClassType REST_SERVICE_TYPE;\n    private JsonEncoderDecoderInstanceLocator locator;\n\n    private boolean autodetectTypeForStrings;\n\n    public RestServiceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, REST_SERVICE_PROXY_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n    \tString parameters = \"\";\n    \tif(source instanceof JGenericType)\n    \t{\n    \t\tJGenericType gtype = (JGenericType)source;\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tbuilder.append(\"<\");\n\t\t\tboolean first = true;\n   \t\t\tfor(JTypeParameter arg : gtype.getTypeParameters())\n   \t\t\t{\n   \t\t\t\tif(!first)\n   \t\t\t\t\tbuilder.append(\",\");\n   \t\t\t\tbuilder.append(arg.getName());\n   \t\t\t\tbuilder.append(\" extends \");\n\t   \t\t\tbuilder.append(arg.getFirstBound().getParameterizedQualifiedSourceName());\n\t   \t\t\tfirst = false;\n   \t\t\t}\n   \t\t\tbuilder.append(\">\");\n   \t\t\tparameters = builder.toString();\n     \t}\n\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName + parameters);\n        composerFactory.addImplementedInterface(source.getParameterizedQualifiedSourceName());\n        composerFactory.addImplementedInterface(RestServiceProxy.class.getName());\n        return composerFactory;\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n\n        if (source.isInterface() == null) {\n            getLogger().log(ERROR, \"Type is not an interface.\");\n            throw new UnableToCompleteException();\n        }\n\n        autodetectTypeForStrings = shouldAutodetectPlainTextForStrings(getLogger(), context.getPropertyOracle());\n\n        locator = new JsonEncoderDecoderInstanceLocator(context, getLogger());\n\n        this.XML_CALLBACK_TYPE = find(XmlCallback.class, getLogger(), context);\n        this.METHOD_CALLBACK_TYPE = find(MethodCallback.class, getLogger(), context);\n        this.TEXT_CALLBACK_TYPE = find(TextCallback.class, getLogger(), context);\n        this.JSON_CALLBACK_TYPE = find(JsonCallback.class, getLogger(), context);\n        this.OVERLAY_CALLBACK_TYPE = find(OverlayCallback.class, getLogger(), context);\n        this.DOCUMENT_TYPE = find(Document.class, getLogger(), context);\n        this.METHOD_TYPE = find(Method.class, getLogger(), context);\n        this.STRING_TYPE = find(String.class, getLogger(), context);\n        this.JSON_VALUE_TYPE = find(JSONValue.class, getLogger(), context);\n        this.OVERLAY_VALUE_TYPE = find(JavaScriptObject.class, getLogger(), context);\n        this.OVERLAY_ARRAY_TYPES = new HashSet<JClassType>();\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArray.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayBoolean.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayInteger.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayNumber.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayString.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES = new HashSet<JClassType>();\n        this.QUERY_PARAM_LIST_TYPES.add(find(Collection.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES.add(find(List.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES.add(find(Set.class, getLogger(), context));\n\t\tthis.REST_SERVICE_TYPE = find(RestService.class, getLogger(), context);\n\n        String path = getPathFromSource(source);\n\n        p(\"private \" + RESOURCE_CLASS + \" resource = null;\");\n        p();\n\n        p(\"public void setResource(\" + RESOURCE_CLASS + \" resource) {\").i(1);\n        {\n            p(\"this.resource = resource;\");\n        }\n        i(-1).p(\"}\");\n\n        Options options = getAnnotation(source, Options.class);\n\n        p(\"public \" + RESOURCE_CLASS + \" getResource() {\").i(1);\n        {\n            p(\"if (this.resource == null) {\").i(1);\n\n            if (options != null && options.serviceRootKey() != null && !options.serviceRootKey().isEmpty()) {\n            \tp(\"String serviceRoot = \" + SERVICE_ROOTS_CLASS + \".get(\\\"\" + options.serviceRootKey() + \"\\\");\");\n            } else {\n            \tp(\"String serviceRoot = \" + DEFAULTS_CLASS + \".getServiceRoot();\");\n            }\n\n            if (path == null) {\n                p(\"this.resource = new \" + RESOURCE_CLASS + \"(serviceRoot);\");\n            } else {\n                p(\"this.resource = new \" + RESOURCE_CLASS + \"(serviceRoot).resolve(\"+quote(path)+\");\");\n            }\n\n            i(-1).p(\"}\");\n            p(\"return this.resource;\");\n        }\n        i(-1).p(\"}\");\n\n\n        if( options!=null && options.dispatcher()!=Dispatcher.class ) {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = \"+options.dispatcher().getName()+\".INSTANCE;\");\n        } else {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = null;\");\n        }\n\n        p();\n        p(\"public void setDispatcher(\" + DISPATCHER_CLASS + \" dispatcher) {\").i(1);\n        {\n            p(\"this.dispatcher = dispatcher;\");\n        }\n        i(-1).p(\"}\");\n\n        p();\n        p(\"public \" + DISPATCHER_CLASS + \" getDispatcher() {\").i(1);\n        {\n            p(\"return this.dispatcher;\");\n        }\n        i(-1).p(\"}\");\n\n        for (JMethod method : source.getInheritableMethods()) {\n        \tJClassType iface = method.getReturnType().isInterface();\n        \tif(iface != null && REST_SERVICE_TYPE.isAssignableFrom(iface))\n        \t\twriteSubresourceLocatorImpl(method);\n        \telse\n                writeMethodImpl(method, options);\n        }\n    }\n\n    /**\n     * Returns {@code true} if plain text autodetection for strings should be used.\n     */\n    static boolean shouldAutodetectPlainTextForStrings(TreeLogger logger, PropertyOracle propertyOracle) {\n        try {\n            SelectionProperty prop = propertyOracle.getSelectionProperty(logger, PLAIN_TEXT_AUTODETECTION_CONFIGURATION_PROPERTY_NAME);\n            String propVal = prop.getCurrentValue();\n            return Boolean.parseBoolean(propVal);\n        } catch (BadPropertyValueException e) {\n            // use default \"false\"\n        }\n        return false;\n    }\n\n    private static String getPathFromSource(HasAnnotations annotatedType) {\n        String path = null;\n\n        Path pathAnnotation = getAnnotation(annotatedType, Path.class);\n        if (pathAnnotation != null) {\n            path = pathAnnotation.value();\n        }\n\n        RemoteServiceRelativePath relativePath = getAnnotation(annotatedType, RemoteServiceRelativePath.class);\n        if (relativePath != null) {\n            path = relativePath.value();\n        }\n\n        return path;\n    }\n\n    private String quote(String path) {\n        // TODO: unlikely to occur. but we should escape chars like newlines..\n        return \"\\\"\" + path + \"\\\"\";\n    }\n\n    private boolean isOverlayArrayType(JClassType type) {\n        for (JClassType arrayType : OVERLAY_ARRAY_TYPES) {\n            if (type.isAssignableTo(arrayType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isQueryParamListType(JClassType type) {\n        if (type.isParameterized() == null) {\n            return false;\n        }\n        for (JClassType listType : QUERY_PARAM_LIST_TYPES) {\n            if (type.isAssignableTo(listType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void writeSubresourceLocatorImpl(JMethod method) throws UnableToCompleteException\n    {\n    \tJClassType iface = method.getReturnType().isInterface();\n    \tif(iface == null || !REST_SERVICE_TYPE.isAssignableFrom(iface)) {\n    \t\tgetLogger().log(ERROR, \"Invalid subresource locator method. Method must have return type of an interface that extends RestService: \" + method.getReadableDeclaration());\n            throw new UnableToCompleteException();\n    \t}\n\n        Path pathAnnotation = getAnnotation(method, Path.class);\n        if (pathAnnotation == null) {\n        \tgetLogger().log(ERROR, \"Invalid subresource locator method. Method must have @Path annotation: \" + method.getReadableDeclaration());\n            throw new UnableToCompleteException();\n        }\n        String pathExpression = wrap(pathAnnotation.value());\n\n        for (JParameter arg : method.getParameters()) {\n            PathParam paramPath = getAnnotation(arg, PathParam.class);\n            if (paramPath != null) {\n                pathExpression = pathExpression(pathExpression, arg, paramPath);\n            }\n        }\n\n\n        p(method.getReadableDeclaration(false, false, false, false, true) + \" {\").i(1);\n        {\n        \tJType type = method.getReturnType();\n        \tString name;\n        \tif(type instanceof JClassType)\n        \t{\n                JClassType restService = (JClassType)type;\n                RestServiceClassCreator generator = new RestServiceClassCreator(getLogger(), context, restService);\n                name = generator.create();\n        \t}\n        \telse\n        \t{\n        \t\tthrow new UnsupportedOperationException(\"Subresource method may not return: \" + type);\n        \t}\n        \tp(method.getReturnType().getQualifiedSourceName() + \" __subresource = new \" + name + \"();\");\n                p(\"((\" + RestServiceProxy.class.getName() + \")__subresource).setResource(getResource().resolve(\" + pathExpression + \"));\");\n                p(\"((\" + RestServiceProxy.class.getName() + \")__subresource).setDispatcher(getDispatcher());\");\n        \tp(\"return __subresource;\");\n        }\n        i(-1).p(\"}\");\n    }\n\n    private String pathExpression(String pathExpression, JParameter arg, PathParam paramPath) {\n        String expr = toStringExpression(arg);\n        return pathExpression.replaceAll(Pattern.quote(\"{\" + paramPath.value()) + \"(\\\\s*:\\\\s*(.)+)?\\\\}\",\n               \"\\\"+(\" + expr + \"== null? null : ((\\\"\\\" + \" + expr +\").startsWith(\\\"http\\\") ? \" + expr +\n               \" : com.google.gwt.http.client.URL.encodePathSegment(\" + expr + \")))+\\\"\");\n    }\n\n    void writeOptions(Options options, Options classOptions) {\n        // configure the dispatcher\n        if (options != null && options.dispatcher() != Dispatcher.class) {\n            // use the dispatcher configured for the method.\n            p(\"__method.setDispatcher(\" + options.dispatcher().getName() + \".INSTANCE);\");\n        } else {\n            // use the default dispatcher configured for the service..\n            p(\"__method.setDispatcher(this.dispatcher);\");\n        }\n\n        // configure the expected statuses..\n        if (options != null && options.expect().length != 0) {\n            // Using method level defined expected status\n            p(\"__method.expect(\" + join(options.expect(), \", \") + \");\");\n        } else if (classOptions != null && classOptions.expect().length != 0) {\n            // Using class level defined expected status\n            p(\"__method.expect(\" + join(classOptions.expect(), \", \") + \");\");\n        }\n\n        // configure the timeout\n        if (options != null && options.timeout() >= 0) {\n            // Using method level defined value\n            p(\"__method.timeout(\" + options.timeout() + \");\");\n        } else if (classOptions != null && classOptions.timeout() >= 0) {\n            // Using class level defined value\n            p(\"__method.timeout(\" + classOptions.timeout() + \");\");\n        }\n    }\n\n    private void writeMethodImpl(JMethod method, Options classOptions) throws UnableToCompleteException {\n        boolean returnRequest = false;\n        if (method.getReturnType() != JPrimitiveType.VOID) {\n            if (!method.getReturnType().getQualifiedSourceName().equals(Request.class.getName()) &&\n                !method.getReturnType().getQualifiedSourceName().equals(JsonpRequest.class.getName())) {\n                getLogger().log(ERROR, \"Invalid rest method. Method must have void, Request or JsonpRequest return types: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            returnRequest = true;\n        }\n\n        Json jsonAnnotation = getAnnotation(source, Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n\n        Options options = getAnnotation(method, Options.class);\n\n        p(method.getReadableDeclaration(false, false, false, false, true) + \" {\").i(1);\n        {\n            String restMethod = getRestMethod(method);\n            LinkedList<JParameter> args = new LinkedList<JParameter>(Arrays.asList(method.getParameters()));\n            for (final JParameter arg : args.subList(0, args.size() - 1)) {\n                p(\"final \"\n                        + arg.getType().getParameterizedQualifiedSourceName()\n                        + \" final_\" + arg.getName() + \" = \" + arg.getName()\n                        + \";\");\n            }\n\n            // the last arg should be the callback.\n            if (args.isEmpty()) {\n                getLogger().log(ERROR, \"Invalid rest method. Method must declare at least a callback argument: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            JParameter callbackArg = args.removeLast();\n            JClassType callbackType = callbackArg.getType().isClassOrInterface();\n            JClassType methodCallbackType = METHOD_CALLBACK_TYPE;\n            if (callbackType == null || !callbackType.isAssignableTo(methodCallbackType)) {\n                getLogger().log(ERROR, \"Invalid rest method. Last argument must be a \" + methodCallbackType.getName() + \" type: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            JClassType resultType = getCallbackTypeGenericClass(callbackType);\n\n            String pathExpression = null;\n            Path pathAnnotation = getAnnotation(method, Path.class);\n            if (pathAnnotation != null) {\n                pathExpression = wrap(pathAnnotation.value());\n            }\n\n            JParameter contentArg = null;\n            HashMap<String, JParameter> queryParams = new HashMap<String, JParameter>();\n            HashMap<String, JParameter> formParams = new HashMap<String, JParameter>();\n            HashMap<String, JParameter> headerParams = new HashMap<String, JParameter>();\n\n            for (JParameter arg : args) {\n                PathParam paramPath = getAnnotation(arg, PathParam.class);\n                if (paramPath != null) {\n                    if (pathExpression == null) {\n                        getLogger().log(ERROR, \"Invalid rest method.  Invalid @PathParam annotation. Method is missing the @Path annotation: \" + method.getReadableDeclaration());\n                        throw new UnableToCompleteException();\n                    }\n                    pathExpression = pathExpression(pathExpression, arg, paramPath);\n                    //.replaceAll(Pattern.quote(\"{\" + paramPath.value() + \"}\"), \"\\\"+com.google.gwt.http.client.URL.encodePathSegment(\" + toStringExpression(arg) + \")+\\\"\");\n                    if (getAnnotation(arg, Attribute.class) != null) {\n                        // allow part of the arg-object participate in as PathParam and the object goes over the wire\n                        contentArg = arg;\n                    }\n                    continue;\n                }\n\n                QueryParam queryParam = getAnnotation(arg, QueryParam.class);\n                if (queryParam != null) {\n                    queryParams.put(queryParam.value(), arg);\n                    continue;\n                }\n\n                FormParam formParam = getAnnotation(arg, FormParam.class);\n                if (formParam != null) {\n                    formParams.put(formParam.value(), arg);\n                    continue;\n                }\n\n                HeaderParam headerParam = getAnnotation(arg, HeaderParam.class);\n                if (headerParam != null) {\n                    headerParams.put(headerParam.value(), arg);\n                    continue;\n                }\n\n                if (!formParams.isEmpty()) {\n                    getLogger().log(ERROR, \"You can not have both @FormParam parameters and a content parameter: \" +\n                                                method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n\n                if (contentArg != null) {\n                    getLogger().log(ERROR, \"Invalid rest method. Only one content parameter is supported: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n                contentArg = arg;\n            }\n\n            String acceptTypeBuiltIn = null;\n            if (callbackType.equals(TEXT_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_TEXT\";\n            } else if (callbackType.equals(JSON_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.isAssignableTo(OVERLAY_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.equals(XML_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_XML\";\n            }\n\n            // Handle JSONP specific configuration...\n            JSONP jsonpAnnotation = getAnnotation(method, JSONP.class);\n\n            final boolean isJsonp = restMethod.equals(METHOD_JSONP) && jsonpAnnotation != null;\n\n            p(\"final \" + (isJsonp ? JSONP_METHOD_CLASS : METHOD_CLASS) + \" __method =\");\n\n            p(\"getResource()\");\n            if (pathExpression != null) {\n                p(\".resolve(\" + pathExpression + \")\");\n            }\n            for (Map.Entry<String, JParameter> entry : queryParams.entrySet()) {\n                String expr = entry.getValue().getName();\n                JClassType type = entry.getValue().getType().isClassOrInterface();\n                if (type != null && isQueryParamListType(type)) {\n                    p(\".addQueryParams(\" + wrap(entry.getKey()) + \", \" +\n                      toIteratedStringExpression(entry.getValue()) + \")\");\n                } else {\n                    p(\".addQueryParam(\" + wrap(entry.getKey()) + \", \" +\n                      toStringExpression(entry.getValue().getType(), expr) + \")\");\n                }\n            }\n            // example: .get()\n            p(\".\" + restMethod + \"();\");\n\n            if( isJsonp ) {\n                if (returnRequest && !method.getReturnType().getQualifiedSourceName().equals(JsonpRequest.class.getName())) {\n                    getLogger().log(ERROR, \"Invalid rest method. JSONP method must have void or JsonpRequest return types: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n                if( jsonpAnnotation.callbackParam().length() > 0 ) {\n                    p(\"__method.callbackParam(\"+wrap(jsonpAnnotation.callbackParam())+\");\");\n                }\n                if( jsonpAnnotation.failureCallbackParam().length() > 0 ) {\n                    p(\"__method.failureCallbackParam(\"+wrap(jsonpAnnotation.failureCallbackParam())+\");\");\n                }\n            } else {\n                if (returnRequest && !method.getReturnType().getQualifiedSourceName().equals(Request.class.getName())) {\n                    getLogger().log(ERROR, \"Invalid rest method. Non JSONP method must have void or Request return types: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n            }\n\n            writeOptions(options, classOptions);\n\n            if (jsonpAnnotation == null) {\n                final String acceptHeader;\n                Produces producesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Produces.class);\n                if (producesAnnotation != null) {\n                    // Do not use autodetection, if accept type already set\n                    if (acceptTypeBuiltIn == null && autodetectTypeForStrings && producesAnnotation.value()[0].startsWith(\"text/\")) {\n                        acceptTypeBuiltIn = \"CONTENT_TYPE_TEXT\";\n                    }\n                    acceptHeader = wrap(producesAnnotation.value()[0]);\n                } else {\n                    // set the default accept header value ...\n                    if (acceptTypeBuiltIn != null) {\n                        acceptHeader = RESOURCE_CLASS + \".\" + acceptTypeBuiltIn;\n                    } else {\n                        acceptHeader = RESOURCE_CLASS + \".CONTENT_TYPE_JSON\";\n                    }\n                }\n                p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \" + acceptHeader + \");\");\n\n                Consumes consumesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Consumes.class);\n                if (consumesAnnotation != null) {\n                    p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_CONTENT_TYPE, \" + wrap(consumesAnnotation.value()[0]) + \");\");\n                }\n\n                // and set the explicit headers now (could override the accept header)\n                for (Map.Entry<String, JParameter> entry : headerParams.entrySet()) {\n                    String expr = entry.getValue().getName();\n                    p(\"__method.header(\" + wrap(entry.getKey()) + \", \" + toStringExpression(entry.getValue().getType(), expr) + \");\");\n                }\n            }\n\n            if (! formParams.isEmpty()) {\n                p(FORM_POST_CONTENT_CLASS + \" __formPostContent = new \" + FORM_POST_CONTENT_CLASS + \"();\");\n\n                for (Map.Entry<String, JParameter> entry : formParams.entrySet()) {\n                    JClassType type = entry.getValue().getType()\n                            .isClassOrInterface();\n                    if (type != null && isQueryParamListType(type)) {\n                        p(\"__formPostContent.addParameters(\" +\n                                wrap(entry.getKey()) + \", \" +\n                                toIteratedFormStringExpression(entry.getValue(), classStyle) +\n                                \");\");\n                    } else {\n                        p(\"__formPostContent.addParameter(\" +\n                                wrap(entry.getKey()) + \", \" +\n                                toFormStringExpression(entry.getValue(), classStyle) +\n                                \");\");\n                    }\n                }\n\n                p(\"__method.form(__formPostContent.getTextContent());\");\n            }\n\n            if (contentArg != null) {\n                if (contentArg.getType() == STRING_TYPE) {\n                    p(\"__method.text(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType() == JSON_VALUE_TYPE) {\n                    p(\"__method.json(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType().isClass() != null &&\n                           isOverlayArrayType(contentArg.getType().isClass())) {\n                    p(\"__method.json(new \" + JSON_ARRAY_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType().isClass() != null &&\n                           contentArg.getType().isClass().isAssignableTo(OVERLAY_VALUE_TYPE)) {\n                    p(\"__method.json(new \" + JSON_OBJECT_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType() == DOCUMENT_TYPE) {\n                    p(\"__method.xml(\" + contentArg.getName() + \");\");\n                } else {\n                    JClassType contentClass = contentArg.getType().isClass();\n                    if (contentClass == null) {\n                        contentClass = contentArg.getType().isClassOrInterface();\n                        if (!locator.isCollectionType(contentClass)) {\n                            getLogger().log(ERROR, \"Content argument must be a class.\");\n                            throw new UnableToCompleteException();\n                        }\n                    }\n\n                    jsonAnnotation = getAnnotation(contentArg, Json.class);\n                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n                    // example:\n                    // .json(Listings$_Generated_JsonEncoder_$.INSTANCE.encode(arg0)\n                    // )\n                    p(\"__method.json(\" + locator.encodeExpression(contentClass, contentArg.getName(), style) + \");\");\n                }\n            }\n\n\n            List<AnnotationResolver> annotationResolvers = getAnnotationResolvers(context, getLogger());\n            getLogger().log(TreeLogger.DEBUG, \"found \" + annotationResolvers.size() + \" additional AnnotationResolvers\");\n\n            for (AnnotationResolver a : annotationResolvers) {\n                getLogger().log(TreeLogger.DEBUG, \"(\" + a.getClass().getName() + \") resolve `\" + source.getName()\n                        + \"#\" + method.getName() + \" ...\");\n                final Map<String, String[]> addDataParams = a.resolveAnnotation(getLogger(), source, method, restMethod);\n\n                if (addDataParams != null) {\n                    for (String s : addDataParams.keySet()) {\n                        final StringBuilder sb = new StringBuilder();\n                        final List<String> classList = Arrays.asList(addDataParams.get(s));\n\n                        sb.append(\"[\");\n                        for (int i = 0; i < classList.size(); ++i) {\n                            sb.append(\"\\\\\\\"\").append(classList.get(i)).append(\"\\\\\\\"\");\n\n                            if ((i+1) <  classList.size()) {\n                                sb.append(\",\");\n                            }\n                        }\n                        sb.append(\"]\");\n\n                        getLogger().log(TreeLogger.DEBUG, \"add call with (\\\"\" + s + \"\\\", \\\"\" +\n                                sb.toString() + \"\\\")\");\n                        p(\"__method.addData(\\\"\" + s + \"\\\", \\\"\" + sb.toString() + \"\\\");\");\n                    }\n                }\n            }\n\n\n            if (acceptTypeBuiltIn != null) {\n                // TODO: shouldn't we also have a cach in here?\n                p(returnRequest(returnRequest,isJsonp) + \"__method.send(\" + callbackArg.getName() + \");\");\n            } else if ( isJsonp ){\n                    p(returnRequest(returnRequest,isJsonp) + \"__method.send(new \" + ABSTRACT_ASYNC_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">(__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult(\" + JSON_VALUE_CLASS + \" result) throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) null;\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    if(resultType.isAssignableTo(locator.LIST_TYPE)){\n                                        p(\"result = new \" + JSON_ARRAY_CLASS + \"(((\" + JSON_OBJECT_CLASS + \")result).getJavaScriptObject());\");\n                                    }\n                                    jsonAnnotation = getAnnotation(method, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, \"result\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n            } else {\n                p(\"try {\").i(1);\n                {\n                    p(returnRequest(returnRequest,isJsonp) + \"__method.send(new \" + ABSTRACT_REQUEST_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">(__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult() throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) null;\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    jsonAnnotation = getAnnotation(method, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, JSON_PARSER_CLASS + \".parse(__method.getResponse().getText())\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n                }\n                i(-1).p(\"} catch (\" + REQUEST_EXCEPTION_CLASS + \" __e) {\").i(1);\n                {\n                    p(callbackArg.getName() + \".onFailure(__method,__e);\");\n                    if (returnRequest) {\n                        p(\"return null;\");\n                    }\n                }\n                i(-1).p(\"}\");\n            }\n        }\n        i(-1).p(\"}\");\n    }\n\n    private <T extends Annotation> T findAnnotationOnMethodOrEnclosingType(final JMethod method, final Class<T> annotationType) {\n        T annotation = getAnnotation(method, annotationType);\n        if (annotation == null) {\n            annotation = getAnnotation(method.getEnclosingType(), annotationType);\n        }\n        return annotation;\n    }\n\n    protected String toStringExpression(JParameter arg) {\n        Attribute attribute = getAnnotation(arg, Attribute.class);\n        if(attribute != null){\n            return \"(\" + arg.getName() + \".\" + attribute.value() + \"+ \\\"\\\")\";\n        }\n        return toStringExpression(arg.getType(), arg.getName());\n    }\n\n    protected String toFormStringExpression(JParameter argument, Style classStyle) throws UnableToCompleteException {\n        JType type = argument.getType();\n        String expr = argument.getName();\n\n        if (type.isPrimitive() != null) {\n            return \"\\\"\\\"+\" + expr;\n        }\n        if (STRING_TYPE == type) {\n            return expr;\n        }\n        if (type.isClass() != null &&\n                isOverlayArrayType(type.isClass())) {\n            return \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.isClass() != null &&\n                OVERLAY_VALUE_TYPE.isAssignableFrom(type.isClass())) {\n            return \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.getQualifiedBinaryName().startsWith(\"java.lang.\") || type.isEnum() != null) {\n            return String.format(\"(%s != null ? %s.toString() : null)\", expr, expr);\n        }\n\n        Json jsonAnnotation = getAnnotation(argument, Json.class);\n        final Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n        return locator.encodeExpression(type, expr, style) + \".toString()\";\n    }\n\n    protected String toIteratedFormStringExpression(JParameter argument, Style classStyle) throws UnableToCompleteException {\n        assert isQueryParamListType(argument.getType().isClassOrInterface());\n        final JClassType[] type_args = argument.getType().isParameterized().getTypeArgs();\n        assert (type_args.length == 1);\n        final JClassType class_type = type_args[0];\n        final String argument_expr = \"final_\"\n                + argument.getName();\n\n        final StringBuilder result = new StringBuilder();\n        result.append(argument_expr + \" == null ? null : \");\n        result.append(\"new java.lang.Iterable<String> () {\\n\");\n        result.append(\" @Override\\n\");\n        result.append(\" public java.util.Iterator<String> iterator() {\\n\");\n        result.append(\"     final java.util.Iterator<\"\n                + class_type.getParameterizedQualifiedSourceName()\n                + \"> baseIterator =  \" + argument_expr + \".iterator();\\n\");\n        result.append(\"     return new java.util.Iterator<String>() {\\n\");\n        result.append(\"         @Override\\n\");\n        result.append(\"         public boolean hasNext() {\\n\");\n        result.append(\"           return baseIterator.hasNext();\\n\");\n        result.append(\"         }\\n\");\n        result.append(\"         @Override\\n\");\n        result.append(\"         public String next() {\\n\");\n        final String expr = \"baseIterator.next()\";\n        String returnExpr;\n        if (class_type.isPrimitive() != null) {\n            returnExpr = \"\\\"\\\"+\" + expr;\n        } else if (STRING_TYPE == class_type) {\n            returnExpr = expr;\n        } else if (class_type.isClass() != null &&\n            isOverlayArrayType(class_type.isClass())) {\n            returnExpr = \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        } else if (class_type.isClass() != null &&\n            OVERLAY_VALUE_TYPE.isAssignableFrom(class_type.isClass())) {\n            returnExpr = \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        } else if (class_type.getQualifiedBinaryName().startsWith(\"java.lang.\")) {\n            result.append(\"             Object obj = \" + expr + \";\");\n            returnExpr = \"obj != null ? obj.toString() : null\";\n        } else {\n            Json jsonAnnotation = getAnnotation(argument, Json.class);\n            final Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n            returnExpr = locator.encodeExpression(class_type, expr, style) + \".toString()\";\n        }\n        result.append(\"             return \" + returnExpr + \";\\n\");\n        result.append(\"         }\\n\");\n        result.append(\"         @Override\\n\");\n        result.append(\"         public void remove() {\\n\");\n        result.append(\"             throw new UnsupportedOperationException();\\n\");\n        result.append(\"         }\\n\");\n        result.append(\"     };\\n\");\n        result.append(\" }\\n\");\n        result.append(\"}\\n\");\n\n        return result.toString();\n    }\n\n    protected String toStringExpression(JType type, String expr) {\n        if (type.isPrimitive() != null) {\n            return \"\\\"\\\"+\" + expr;\n        }\n        if (STRING_TYPE == type) {\n            return expr;\n        }\n        if (type.isClass() != null &&\n            isOverlayArrayType(type.isClass())) {\n          return \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.isClass() != null &&\n            OVERLAY_VALUE_TYPE.isAssignableFrom(type.isClass())) {\n          return \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        }\n\n        return String.format(\"(%s != null ? %s.toString() : null)\", expr, expr);\n    }\n\n    protected String toIteratedStringExpression(JParameter arg) {\n        StringBuilder result = new StringBuilder();\n        result.append(\"new org.fusesource.restygwt.client.StringIterable (\")\n            .append(arg.getName()).append(\")\");\n\n        return result.toString();\n    }\n\n    private JClassType getCallbackTypeGenericClass(final JClassType callbackType) throws UnableToCompleteException {\n        return branch(\"getCallbackTypeGenericClass()\", new Branch<JClassType>() {\n            @Override\n            public JClassType execute() throws UnableToCompleteException {\n\n                for (JMethod method : callbackType.getOverridableMethods()) {\n                    getLogger().log(DEBUG, \"checking method: \" + method.getName());\n                    if (method.getName().equals(\"onSuccess\")) {\n                        JParameter[] parameters = method.getParameters();\n                        getLogger().log(DEBUG, \"checking method params: \" + parameters.length);\n                        if (parameters.length == 2) {\n                            getLogger().log(DEBUG, \"checking first param: \" + parameters[0].getType());\n                            if (parameters[0].getType() == METHOD_TYPE) {\n                                getLogger().log(DEBUG, \"checking 2nd param: \" + parameters[1].getType());\n                                JType param2Type = parameters[1].getType();\n                                JClassType type = param2Type.isClassOrInterface();\n                                if (type == null) {\n                                    getLogger().log(ERROR, \"The type of the callback not supported: \" + param2Type.getJNISignature());\n                                    throw new UnableToCompleteException();\n                                }\n                                getLogger().log(DEBUG, \"match: \" + type);\n                                return type;\n                            }\n                        }\n                    }\n                }\n                getLogger().log(ERROR, \"The type of the callback could not be determined: \" + callbackType.getParameterizedQualifiedSourceName());\n                throw new UnableToCompleteException();\n            }\n        });\n    }\n\n    private String getRestMethod(JMethod method) throws UnableToCompleteException {\n        String restMethod = null;\n        if (getAnnotation(method, DELETE.class) != null) {\n            restMethod = METHOD_DELETE;\n        } else if (getAnnotation(method, GET.class) != null) {\n            restMethod = METHOD_GET;\n        } else if (getAnnotation(method, HEAD.class) != null) {\n            restMethod = METHOD_HEAD;\n        } else if (getAnnotation(method, OPTIONS.class) != null) {\n            restMethod = METHOD_OPTIONS;\n        } else if (getAnnotation(method, POST.class) != null) {\n            restMethod = METHOD_POST;\n        } else if (getAnnotation(method, PUT.class) != null) {\n            restMethod = METHOD_PUT;\n        } else if (getAnnotation(method, JSONP.class) != null) {\n            restMethod = METHOD_JSONP;\n        } else {\n            restMethod = method.getName();\n            if (!REST_METHODS.contains(restMethod)) {\n                getLogger().log(ERROR, \"Invalid rest method. It must either have a lower case rest method name or have a javax rs method annotation: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n        }\n        return restMethod;\n    }\n\n    /**\n     * access additional AnnotationResolvers possibly added by\n     *\n     * {@link BindingDefaults#addAnnotationResolver(AnnotationResolver)}\n     * @return\n     */\n    // TODO remove suppression\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private List<AnnotationResolver> getAnnotationResolvers(final GeneratorContext context, final TreeLogger logger) {\n        java.lang.reflect.Method m = null;\n        ArrayList args = new ArrayList();\n        ArrayList types = new ArrayList();\n\n        types.add(GeneratorContext.class);\n        args.add(context);\n        types.add(TreeLogger.class);\n        args.add(logger);\n\n        Object[] argValues = args.toArray();\n        Class[] argtypes = (Class[]) types.toArray(new Class[argValues.length]);\n\n        try {\n             m = BINDING_DEFAULTS.getMethod(\"getAnnotationResolvers\", argtypes);\n        } catch (SecurityException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"could not resolve method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        List<AnnotationResolver> l = new ArrayList<AnnotationResolver>();\n        try {\n            l = (List<AnnotationResolver>) m.invoke(null, context, logger);\n        } catch (IllegalArgumentException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (InvocationTargetException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        return l;\n    }\n\n    private String returnRequest(boolean returnRequest, boolean isJsonp) {\n        String type = isJsonp ? JsonpRequest.class.getName() : Request.class.getName();\n        return returnRequest ? \"return (\"+type+\")\" : \"\";\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2015 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport static org.fusesource.restygwt.rebind.util.AnnotationUtils.getAnnotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.DELETE;\nimport javax.ws.rs.FormParam;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.HEAD;\nimport javax.ws.rs.HeaderParam;\nimport javax.ws.rs.OPTIONS;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.PUT;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.QueryParam;\n\nimport org.fusesource.restygwt.client.AbstractAsyncCallback;\nimport org.fusesource.restygwt.client.AbstractRequestCallback;\nimport org.fusesource.restygwt.client.Attribute;\nimport org.fusesource.restygwt.client.Defaults;\nimport org.fusesource.restygwt.client.Dispatcher;\nimport org.fusesource.restygwt.client.FormPostContent;\nimport org.fusesource.restygwt.client.JSONP;\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\nimport org.fusesource.restygwt.client.JsonCallback;\nimport org.fusesource.restygwt.client.JsonpMethod;\nimport org.fusesource.restygwt.client.Method;\nimport org.fusesource.restygwt.client.MethodCallback;\nimport org.fusesource.restygwt.client.Options;\nimport org.fusesource.restygwt.client.OverlayCallback;\nimport org.fusesource.restygwt.client.Resource;\nimport org.fusesource.restygwt.client.ResponseFormatException;\nimport org.fusesource.restygwt.client.RestService;\nimport org.fusesource.restygwt.client.RestServiceProxy;\nimport org.fusesource.restygwt.client.ServiceRoots;\nimport org.fusesource.restygwt.client.TextCallback;\nimport org.fusesource.restygwt.client.XmlCallback;\n\nimport com.google.gwt.core.client.JavaScriptObject;\nimport com.google.gwt.core.client.JsArray;\nimport com.google.gwt.core.client.JsArrayBoolean;\nimport com.google.gwt.core.client.JsArrayInteger;\nimport com.google.gwt.core.client.JsArrayNumber;\nimport com.google.gwt.core.client.JsArrayString;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.HasAnnotations;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JGenericType;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.core.ext.typeinfo.JTypeParameter;\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.jsonp.client.JsonpRequest;\nimport com.google.gwt.user.client.rpc.RemoteServiceRelativePath;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport com.google.gwt.xml.client.Document;\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added automatically create resource from Path annotation,\n *         enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\npublic class RestServiceClassCreator extends BaseSourceCreator {\n\n    private static final String REST_SERVICE_PROXY_SUFFIX = \"_Generated_RestServiceProxy_\";\n\n    private static final String METHOD_CLASS = Method.class.getName();\n    private static final String RESOURCE_CLASS = Resource.class.getName();\n    private static final String DISPATCHER_CLASS = Dispatcher.class.getName();\n    private static final String DEFAULTS_CLASS = Defaults.class.getName();\n    private static final String ABSTRACT_REQUEST_CALLBACK_CLASS = AbstractRequestCallback.class.getName();\n    private static final String ABSTRACT_ASYNC_CALLBACK_CLASS = AbstractAsyncCallback.class.getName();\n    private static final String JSON_PARSER_CLASS = JSONParser.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String REQUEST_EXCEPTION_CLASS = RequestException.class.getName();\n    private static final String RESPONSE_FORMAT_EXCEPTION_CLASS = ResponseFormatException.class.getName();\n    private static final String JSONP_METHOD_CLASS = JsonpMethod.class.getName();\n    private static final String FORM_POST_CONTENT_CLASS = FormPostContent.class.getName();\n    private static final String SERVICE_ROOTS_CLASS = ServiceRoots.class.getName();\n\n    /*\n     * static class in which are some compile-time relevant infos.\n     *\n     * TODO (andi): too much flexibility and overhead with reflection here?\n     */\n    private static final Class<BindingDefaults> BINDING_DEFAULTS = BindingDefaults.class;\n\n    private static final String METHOD_JSONP = \"jsonp\";\n    private static final String METHOD_PUT = \"put\";\n    private static final String METHOD_POST = \"post\";\n    private static final String METHOD_OPTIONS = \"options\";\n    private static final String METHOD_HEAD = \"head\";\n    private static final String METHOD_GET = \"get\";\n    private static final String METHOD_DELETE = \"delete\";\n\n    private static final HashSet<String> REST_METHODS = new HashSet<String>(8);\n    static {\n        REST_METHODS.add(METHOD_DELETE);\n        REST_METHODS.add(METHOD_GET);\n        REST_METHODS.add(METHOD_HEAD);\n        REST_METHODS.add(METHOD_OPTIONS);\n        REST_METHODS.add(METHOD_POST);\n        REST_METHODS.add(METHOD_PUT);\n        REST_METHODS.add(METHOD_JSONP);\n    }\n\n    private JClassType XML_CALLBACK_TYPE;\n    private JClassType METHOD_CALLBACK_TYPE;\n    private JClassType TEXT_CALLBACK_TYPE;\n    private JClassType JSON_CALLBACK_TYPE;\n    private JClassType OVERLAY_CALLBACK_TYPE;\n    private JClassType DOCUMENT_TYPE;\n    private JClassType METHOD_TYPE;\n    private JClassType STRING_TYPE;\n    private JClassType JSON_VALUE_TYPE;\n    private JClassType OVERLAY_VALUE_TYPE;\n    private Set<JClassType> OVERLAY_ARRAY_TYPES;\n    private Set<JClassType> QUERY_PARAM_LIST_TYPES;\n    private JClassType REST_SERVICE_TYPE;\n    private JsonEncoderDecoderInstanceLocator locator;\n\n    public RestServiceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, REST_SERVICE_PROXY_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n    \tString parameters = \"\";\n    \tif(source instanceof JGenericType)\n    \t{\n    \t\tJGenericType gtype = (JGenericType)source;\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tbuilder.append(\"<\");\n\t\t\tboolean first = true;\n   \t\t\tfor(JTypeParameter arg : gtype.getTypeParameters())\n   \t\t\t{\n   \t\t\t\tif(!first)\n   \t\t\t\t\tbuilder.append(\",\");\n   \t\t\t\tbuilder.append(arg.getName());\n   \t\t\t\tbuilder.append(\" extends \");\n\t   \t\t\tbuilder.append(arg.getFirstBound().getParameterizedQualifiedSourceName());\n\t   \t\t\tfirst = false;\n   \t\t\t}\n   \t\t\tbuilder.append(\">\");\n   \t\t\tparameters = builder.toString();\n     \t}\n\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName + parameters);\n        composerFactory.addImplementedInterface(source.getParameterizedQualifiedSourceName());\n        composerFactory.addImplementedInterface(RestServiceProxy.class.getName());\n        return composerFactory;\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n\n        if (source.isInterface() == null) {\n            getLogger().log(ERROR, \"Type is not an interface.\");\n            throw new UnableToCompleteException();\n        }\n\n        locator = new JsonEncoderDecoderInstanceLocator(context, getLogger());\n\n        this.XML_CALLBACK_TYPE = find(XmlCallback.class, getLogger(), context);\n        this.METHOD_CALLBACK_TYPE = find(MethodCallback.class, getLogger(), context);\n        this.TEXT_CALLBACK_TYPE = find(TextCallback.class, getLogger(), context);\n        this.JSON_CALLBACK_TYPE = find(JsonCallback.class, getLogger(), context);\n        this.OVERLAY_CALLBACK_TYPE = find(OverlayCallback.class, getLogger(), context);\n        this.DOCUMENT_TYPE = find(Document.class, getLogger(), context);\n        this.METHOD_TYPE = find(Method.class, getLogger(), context);\n        this.STRING_TYPE = find(String.class, getLogger(), context);\n        this.JSON_VALUE_TYPE = find(JSONValue.class, getLogger(), context);\n        this.OVERLAY_VALUE_TYPE = find(JavaScriptObject.class, getLogger(), context);\n        this.OVERLAY_ARRAY_TYPES = new HashSet<JClassType>();\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArray.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayBoolean.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayInteger.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayNumber.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayString.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES = new HashSet<JClassType>();\n        this.QUERY_PARAM_LIST_TYPES.add(find(Collection.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES.add(find(List.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES.add(find(Set.class, getLogger(), context));\n\t\tthis.REST_SERVICE_TYPE = find(RestService.class, getLogger(), context);\n\n        String path = getPathFromSource(source);\n\n        p(\"private \" + RESOURCE_CLASS + \" resource = null;\");\n        p();\n\n        p(\"public void setResource(\" + RESOURCE_CLASS + \" resource) {\").i(1);\n        {\n            p(\"this.resource = resource;\");\n        }\n        i(-1).p(\"}\");\n\n        Options options = getAnnotation(source, Options.class);\n\n        p(\"public \" + RESOURCE_CLASS + \" getResource() {\").i(1);\n        {\n            p(\"if (this.resource == null) {\").i(1);\n\n            if (options != null && options.serviceRootKey() != null && !options.serviceRootKey().isEmpty()) {\n            \tp(\"String serviceRoot = \" + SERVICE_ROOTS_CLASS + \".get(\\\"\" + options.serviceRootKey() + \"\\\");\");\n            } else {\n            \tp(\"String serviceRoot = \" + DEFAULTS_CLASS + \".getServiceRoot();\");\n            }\n\n            if (path == null) {\n                p(\"this.resource = new \" + RESOURCE_CLASS + \"(serviceRoot);\");\n            } else {\n                p(\"this.resource = new \" + RESOURCE_CLASS + \"(serviceRoot).resolve(\"+quote(path)+\");\");\n            }\n\n            i(-1).p(\"}\");\n            p(\"return this.resource;\");\n        }\n        i(-1).p(\"}\");\n\n\n        if( options!=null && options.dispatcher()!=Dispatcher.class ) {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = \"+options.dispatcher().getName()+\".INSTANCE;\");\n        } else {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = null;\");\n        }\n\n        p();\n        p(\"public void setDispatcher(\" + DISPATCHER_CLASS + \" dispatcher) {\").i(1);\n        {\n            p(\"this.dispatcher = dispatcher;\");\n        }\n        i(-1).p(\"}\");\n\n        p();\n        p(\"public \" + DISPATCHER_CLASS + \" getDispatcher() {\").i(1);\n        {\n            p(\"return this.dispatcher;\");\n        }\n        i(-1).p(\"}\");\n\n        for (JMethod method : source.getInheritableMethods()) {\n        \tJClassType iface = method.getReturnType().isInterface();\n        \tif(iface != null && REST_SERVICE_TYPE.isAssignableFrom(iface))\n        \t\twriteSubresourceLocatorImpl(method);\n        \telse\n                writeMethodImpl(method, options);\n        }\n    }\n\n    private static String getPathFromSource(HasAnnotations annotatedType) {\n        String path = null;\n\n        Path pathAnnotation = getAnnotation(annotatedType, Path.class);\n        if (pathAnnotation != null) {\n            path = pathAnnotation.value();\n        }\n\n        RemoteServiceRelativePath relativePath = getAnnotation(annotatedType, RemoteServiceRelativePath.class);\n        if (relativePath != null) {\n            path = relativePath.value();\n        }\n\n        return path;\n    }\n\n    private String quote(String path) {\n        // TODO: unlikely to occur. but we should escape chars like newlines..\n        return \"\\\"\" + path + \"\\\"\";\n    }\n\n    private boolean isOverlayArrayType(JClassType type) {\n        for (JClassType arrayType : OVERLAY_ARRAY_TYPES) {\n            if (type.isAssignableTo(arrayType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isQueryParamListType(JClassType type) {\n        if (type.isParameterized() == null) {\n            return false;\n        }\n        for (JClassType listType : QUERY_PARAM_LIST_TYPES) {\n            if (type.isAssignableTo(listType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void writeSubresourceLocatorImpl(JMethod method) throws UnableToCompleteException\n    {\n    \tJClassType iface = method.getReturnType().isInterface();\n    \tif(iface == null || !REST_SERVICE_TYPE.isAssignableFrom(iface)) {\n    \t\tgetLogger().log(ERROR, \"Invalid subresource locator method. Method must have return type of an interface that extends RestService: \" + method.getReadableDeclaration());\n            throw new UnableToCompleteException();\n    \t}\n\n        Path pathAnnotation = getAnnotation(method, Path.class);\n        if (pathAnnotation == null) {\n        \tgetLogger().log(ERROR, \"Invalid subresource locator method. Method must have @Path annotation: \" + method.getReadableDeclaration());\n            throw new UnableToCompleteException();\n        }\n        String pathExpression = wrap(pathAnnotation.value());\n\n        for (JParameter arg : method.getParameters()) {\n            PathParam paramPath = getAnnotation(arg, PathParam.class);\n            if (paramPath != null) {\n                pathExpression = pathExpression(pathExpression, arg, paramPath);\n            }\n        }\n\n\n        p(method.getReadableDeclaration(false, false, false, false, true) + \" {\").i(1);\n        {\n        \tJType type = method.getReturnType();\n        \tString name;\n        \tif(type instanceof JClassType)\n        \t{\n                JClassType restService = (JClassType)type;\n                RestServiceClassCreator generator = new RestServiceClassCreator(getLogger(), context, restService);\n                name = generator.create();\n        \t}\n        \telse\n        \t{\n        \t\tthrow new UnsupportedOperationException(\"Subresource method may not return: \" + type);\n        \t}\n        \tp(method.getReturnType().getQualifiedSourceName() + \" __subresource = new \" + name + \"();\");\n                p(\"((\" + RestServiceProxy.class.getName() + \")__subresource).setResource(getResource().resolve(\" + pathExpression + \"));\");\n                p(\"((\" + RestServiceProxy.class.getName() + \")__subresource).setDispatcher(getDispatcher());\");\n        \tp(\"return __subresource;\");\n        }\n        i(-1).p(\"}\");\n    }\n\n    private String pathExpression(String pathExpression, JParameter arg, PathParam paramPath) {\n        String expr = toStringExpression(arg);\n        return pathExpression.replaceAll(Pattern.quote(\"{\" + paramPath.value()) + \"(\\\\s*:\\\\s*(.)+)?\\\\}\",\n               \"\\\"+(\" + expr + \"== null? null : ((\\\"\\\" + \" + expr +\").startsWith(\\\"http\\\") ? \" + expr +\n               \" : com.google.gwt.http.client.URL.encodePathSegment(\" + expr + \")))+\\\"\");\n    }\n\n    void writeOptions(Options options, Options classOptions) {\n        // configure the dispatcher\n        if (options != null && options.dispatcher() != Dispatcher.class) {\n            // use the dispatcher configured for the method.\n            p(\"__method.setDispatcher(\" + options.dispatcher().getName() + \".INSTANCE);\");\n        } else {\n            // use the default dispatcher configured for the service..\n            p(\"__method.setDispatcher(this.dispatcher);\");\n        }\n\n        // configure the expected statuses..\n        if (options != null && options.expect().length != 0) {\n            // Using method level defined expected status\n            p(\"__method.expect(\" + join(options.expect(), \", \") + \");\");\n        } else if (classOptions != null && classOptions.expect().length != 0) {\n            // Using class level defined expected status\n            p(\"__method.expect(\" + join(classOptions.expect(), \", \") + \");\");\n        }\n\n        // configure the timeout\n        if (options != null && options.timeout() >= 0) {\n            // Using method level defined value\n            p(\"__method.timeout(\" + options.timeout() + \");\");\n        } else if (classOptions != null && classOptions.timeout() >= 0) {\n            // Using class level defined value\n            p(\"__method.timeout(\" + classOptions.timeout() + \");\");\n        }\n    }\n\n    private void writeMethodImpl(JMethod method, Options classOptions) throws UnableToCompleteException {\n        boolean returnRequest = false;\n        if (method.getReturnType() != JPrimitiveType.VOID) {\n            if (!method.getReturnType().getQualifiedSourceName().equals(Request.class.getName()) &&\n                !method.getReturnType().getQualifiedSourceName().equals(JsonpRequest.class.getName())) {\n                getLogger().log(ERROR, \"Invalid rest method. Method must have void, Request or JsonpRequest return types: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            returnRequest = true;\n        }\n\n        Json jsonAnnotation = getAnnotation(source, Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n\n        Options options = getAnnotation(method, Options.class);\n\n        p(method.getReadableDeclaration(false, false, false, false, true) + \" {\").i(1);\n        {\n            String restMethod = getRestMethod(method);\n            LinkedList<JParameter> args = new LinkedList<JParameter>(Arrays.asList(method.getParameters()));\n            for (final JParameter arg : args.subList(0, args.size() - 1)) {\n                p(\"final \"\n                        + arg.getType().getParameterizedQualifiedSourceName()\n                        + \" final_\" + arg.getName() + \" = \" + arg.getName()\n                        + \";\");\n            }\n\n            // the last arg should be the callback.\n            if (args.isEmpty()) {\n                getLogger().log(ERROR, \"Invalid rest method. Method must declare at least a callback argument: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            JParameter callbackArg = args.removeLast();\n            JClassType callbackType = callbackArg.getType().isClassOrInterface();\n            JClassType methodCallbackType = METHOD_CALLBACK_TYPE;\n            if (callbackType == null || !callbackType.isAssignableTo(methodCallbackType)) {\n                getLogger().log(ERROR, \"Invalid rest method. Last argument must be a \" + methodCallbackType.getName() + \" type: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            JClassType resultType = getCallbackTypeGenericClass(callbackType);\n\n            String pathExpression = null;\n            Path pathAnnotation = getAnnotation(method, Path.class);\n            if (pathAnnotation != null) {\n                pathExpression = wrap(pathAnnotation.value());\n            }\n\n            JParameter contentArg = null;\n            HashMap<String, JParameter> queryParams = new HashMap<String, JParameter>();\n            HashMap<String, JParameter> formParams = new HashMap<String, JParameter>();\n            HashMap<String, JParameter> headerParams = new HashMap<String, JParameter>();\n\n            for (JParameter arg : args) {\n                PathParam paramPath = getAnnotation(arg, PathParam.class);\n                if (paramPath != null) {\n                    if (pathExpression == null) {\n                        getLogger().log(ERROR, \"Invalid rest method.  Invalid @PathParam annotation. Method is missing the @Path annotation: \" + method.getReadableDeclaration());\n                        throw new UnableToCompleteException();\n                    }\n                    pathExpression = pathExpression(pathExpression, arg, paramPath);\n                    //.replaceAll(Pattern.quote(\"{\" + paramPath.value() + \"}\"), \"\\\"+com.google.gwt.http.client.URL.encodePathSegment(\" + toStringExpression(arg) + \")+\\\"\");\n                    if (getAnnotation(arg, Attribute.class) != null) {\n                        // allow part of the arg-object participate in as PathParam and the object goes over the wire\n                        contentArg = arg;\n                    }\n                    continue;\n                }\n\n                QueryParam queryParam = getAnnotation(arg, QueryParam.class);\n                if (queryParam != null) {\n                    queryParams.put(queryParam.value(), arg);\n                    continue;\n                }\n\n                FormParam formParam = getAnnotation(arg, FormParam.class);\n                if (formParam != null) {\n                    formParams.put(formParam.value(), arg);\n                    continue;\n                }\n\n                HeaderParam headerParam = getAnnotation(arg, HeaderParam.class);\n                if (headerParam != null) {\n                    headerParams.put(headerParam.value(), arg);\n                    continue;\n                }\n\n                if (!formParams.isEmpty()) {\n                    getLogger().log(ERROR, \"You can not have both @FormParam parameters and a content parameter: \" +\n                                                method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n\n                if (contentArg != null) {\n                    getLogger().log(ERROR, \"Invalid rest method. Only one content parameter is supported: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n                contentArg = arg;\n            }\n\n            String acceptTypeBuiltIn = null;\n            if (callbackType.equals(TEXT_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_TEXT\";\n            } else if (callbackType.equals(JSON_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.isAssignableTo(OVERLAY_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.equals(XML_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_XML\";\n            }\n\n            // Handle JSONP specific configuration...\n            JSONP jsonpAnnotation = getAnnotation(method, JSONP.class);\n\n            final boolean isJsonp = restMethod.equals(METHOD_JSONP) && jsonpAnnotation != null;\n\n            p(\"final \" + (isJsonp ? JSONP_METHOD_CLASS : METHOD_CLASS) + \" __method =\");\n\n            p(\"getResource()\");\n            if (pathExpression != null) {\n                p(\".resolve(\" + pathExpression + \")\");\n            }\n            for (Map.Entry<String, JParameter> entry : queryParams.entrySet()) {\n                String expr = entry.getValue().getName();\n                JClassType type = entry.getValue().getType().isClassOrInterface();\n                if (type != null && isQueryParamListType(type)) {\n                    p(\".addQueryParams(\" + wrap(entry.getKey()) + \", \" +\n                      toIteratedStringExpression(entry.getValue()) + \")\");\n                } else {\n                    p(\".addQueryParam(\" + wrap(entry.getKey()) + \", \" +\n                      toStringExpression(entry.getValue().getType(), expr) + \")\");\n                }\n            }\n            // example: .get()\n            p(\".\" + restMethod + \"();\");\n\n            if( isJsonp ) {\n                if (returnRequest && !method.getReturnType().getQualifiedSourceName().equals(JsonpRequest.class.getName())) {\n                    getLogger().log(ERROR, \"Invalid rest method. JSONP method must have void or JsonpRequest return types: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n                if( jsonpAnnotation.callbackParam().length() > 0 ) {\n                    p(\"__method.callbackParam(\"+wrap(jsonpAnnotation.callbackParam())+\");\");\n                }\n                if( jsonpAnnotation.failureCallbackParam().length() > 0 ) {\n                    p(\"__method.failureCallbackParam(\"+wrap(jsonpAnnotation.failureCallbackParam())+\");\");\n                }\n            } else {\n                if (returnRequest && !method.getReturnType().getQualifiedSourceName().equals(Request.class.getName())) {\n                    getLogger().log(ERROR, \"Invalid rest method. Non JSONP method must have void or Request return types: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n            }\n\n            writeOptions(options, classOptions);\n\n            if(jsonpAnnotation == null) {\n                Produces producesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Produces.class);\n                if (producesAnnotation != null) {\n                    p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \"+wrap(producesAnnotation.value()[0])+\");\");\n                } else {\n                    // set the default accept header....\n                    if (acceptTypeBuiltIn != null) {\n                        p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \" + RESOURCE_CLASS + \".\" + acceptTypeBuiltIn + \");\");\n                    } else {\n                        p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \" + RESOURCE_CLASS + \".CONTENT_TYPE_JSON);\");\n                    }\n                }\n\n                Consumes consumesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Consumes.class);\n                if (consumesAnnotation != null) {\n                    p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_CONTENT_TYPE, \"+wrap(consumesAnnotation.value()[0])+\");\");\n                }\n\n                // and set the explicit headers now (could override the accept header)\n                for (Map.Entry<String, JParameter> entry : headerParams.entrySet()) {\n                    String expr = entry.getValue().getName();\n                    p(\"__method.header(\" + wrap(entry.getKey()) + \", \" + toStringExpression(entry.getValue().getType(), expr) + \");\");\n                }\n            }\n\n            if (! formParams.isEmpty()) {\n                p(FORM_POST_CONTENT_CLASS + \" __formPostContent = new \" + FORM_POST_CONTENT_CLASS + \"();\");\n\n                for (Map.Entry<String, JParameter> entry : formParams.entrySet()) {\n                    JClassType type = entry.getValue().getType()\n                            .isClassOrInterface();\n                    if (type != null && isQueryParamListType(type)) {\n                        p(\"__formPostContent.addParameters(\" +\n                                wrap(entry.getKey()) + \", \" +\n                                toIteratedFormStringExpression(entry.getValue(), classStyle) +\n                                \");\");\n                    } else {\n                        p(\"__formPostContent.addParameter(\" +\n                                wrap(entry.getKey()) + \", \" +\n                                toFormStringExpression(entry.getValue(), classStyle) +\n                                \");\");\n                    }\n                }\n\n                p(\"__method.form(__formPostContent.getTextContent());\");\n            }\n\n            if (contentArg != null) {\n                if (contentArg.getType() == STRING_TYPE) {\n                    p(\"__method.text(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType() == JSON_VALUE_TYPE) {\n                    p(\"__method.json(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType().isClass() != null &&\n                           isOverlayArrayType(contentArg.getType().isClass())) {\n                    p(\"__method.json(new \" + JSON_ARRAY_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType().isClass() != null &&\n                           contentArg.getType().isClass().isAssignableTo(OVERLAY_VALUE_TYPE)) {\n                    p(\"__method.json(new \" + JSON_OBJECT_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType() == DOCUMENT_TYPE) {\n                    p(\"__method.xml(\" + contentArg.getName() + \");\");\n                } else {\n                    JClassType contentClass = contentArg.getType().isClass();\n                    if (contentClass == null) {\n                        contentClass = contentArg.getType().isClassOrInterface();\n                        if (!locator.isCollectionType(contentClass)) {\n                            getLogger().log(ERROR, \"Content argument must be a class.\");\n                            throw new UnableToCompleteException();\n                        }\n                    }\n\n                    jsonAnnotation = getAnnotation(contentArg, Json.class);\n                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n                    // example:\n                    // .json(Listings$_Generated_JsonEncoder_$.INSTANCE.encode(arg0)\n                    // )\n                    p(\"__method.json(\" + locator.encodeExpression(contentClass, contentArg.getName(), style) + \");\");\n                }\n            }\n\n\n            List<AnnotationResolver> annotationResolvers = getAnnotationResolvers(context, getLogger());\n            getLogger().log(TreeLogger.DEBUG, \"found \" + annotationResolvers.size() + \" additional AnnotationResolvers\");\n\n            for (AnnotationResolver a : annotationResolvers) {\n                getLogger().log(TreeLogger.DEBUG, \"(\" + a.getClass().getName() + \") resolve `\" + source.getName()\n                        + \"#\" + method.getName() + \" ...\");\n                final Map<String, String[]> addDataParams = a.resolveAnnotation(getLogger(), source, method, restMethod);\n\n                if (addDataParams != null) {\n                    for (String s : addDataParams.keySet()) {\n                        final StringBuilder sb = new StringBuilder();\n                        final List<String> classList = Arrays.asList(addDataParams.get(s));\n\n                        sb.append(\"[\");\n                        for (int i = 0; i < classList.size(); ++i) {\n                            sb.append(\"\\\\\\\"\").append(classList.get(i)).append(\"\\\\\\\"\");\n\n                            if ((i+1) <  classList.size()) {\n                                sb.append(\",\");\n                            }\n                        }\n                        sb.append(\"]\");\n\n                        getLogger().log(TreeLogger.DEBUG, \"add call with (\\\"\" + s + \"\\\", \\\"\" +\n                                sb.toString() + \"\\\")\");\n                        p(\"__method.addData(\\\"\" + s + \"\\\", \\\"\" + sb.toString() + \"\\\");\");\n                    }\n                }\n            }\n\n\n            if (acceptTypeBuiltIn != null) {\n                // TODO: shouldn't we also have a cach in here?\n                p(returnRequest(returnRequest,isJsonp) + \"__method.send(\" + callbackArg.getName() + \");\");\n            } else if ( isJsonp ){\n                    p(returnRequest(returnRequest,isJsonp) + \"__method.send(new \" + ABSTRACT_ASYNC_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">(__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult(\" + JSON_VALUE_CLASS + \" result) throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) null;\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    if(resultType.isAssignableTo(locator.LIST_TYPE)){\n                                        p(\"result = new \" + JSON_ARRAY_CLASS + \"(((\" + JSON_OBJECT_CLASS + \")result).getJavaScriptObject());\");\n                                    }\n                                    jsonAnnotation = getAnnotation(method, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, \"result\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n            } else {\n                p(\"try {\").i(1);\n                {\n                    p(returnRequest(returnRequest,isJsonp) + \"__method.send(new \" + ABSTRACT_REQUEST_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">(__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult() throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) null;\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    jsonAnnotation = getAnnotation(method, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, JSON_PARSER_CLASS + \".parse(__method.getResponse().getText())\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n                }\n                i(-1).p(\"} catch (\" + REQUEST_EXCEPTION_CLASS + \" __e) {\").i(1);\n                {\n                    p(callbackArg.getName() + \".onFailure(__method,__e);\");\n                    if (returnRequest) {\n                        p(\"return null;\");\n                    }\n                }\n                i(-1).p(\"}\");\n            }\n        }\n        i(-1).p(\"}\");\n    }\n\n    private <T extends Annotation> T findAnnotationOnMethodOrEnclosingType(final JMethod method, final Class<T> annotationType) {\n        T annotation = getAnnotation(method, annotationType);\n        if (annotation == null) {\n            annotation = getAnnotation(method.getEnclosingType(), annotationType);\n        }\n        return annotation;\n    }\n\n    protected String toStringExpression(JParameter arg) {\n        Attribute attribute = getAnnotation(arg, Attribute.class);\n        if(attribute != null){\n            return \"(\" + arg.getName() + \".\" + attribute.value() + \"+ \\\"\\\")\";\n        }\n        return toStringExpression(arg.getType(), arg.getName());\n    }\n\n    protected String toFormStringExpression(JParameter argument, Style classStyle) throws UnableToCompleteException {\n        JType type = argument.getType();\n        String expr = argument.getName();\n\n        if (type.isPrimitive() != null) {\n            return \"\\\"\\\"+\" + expr;\n        }\n        if (STRING_TYPE == type) {\n            return expr;\n        }\n        if (type.isClass() != null &&\n                isOverlayArrayType(type.isClass())) {\n            return \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.isClass() != null &&\n                OVERLAY_VALUE_TYPE.isAssignableFrom(type.isClass())) {\n            return \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.getQualifiedBinaryName().startsWith(\"java.lang.\") || type.isEnum() != null) {\n            return String.format(\"(%s != null ? %s.toString() : null)\", expr, expr);\n        }\n\n        Json jsonAnnotation = getAnnotation(argument, Json.class);\n        final Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n        return locator.encodeExpression(type, expr, style) + \".toString()\";\n    }\n\n    protected String toIteratedFormStringExpression(JParameter argument, Style classStyle) throws UnableToCompleteException {\n        assert isQueryParamListType(argument.getType().isClassOrInterface());\n        final JClassType[] type_args = argument.getType().isParameterized().getTypeArgs();\n        assert (type_args.length == 1);\n        final JClassType class_type = type_args[0];\n        final String argument_expr = \"final_\"\n                + argument.getName();\n\n        final StringBuilder result = new StringBuilder();\n        result.append(argument_expr + \" == null ? null : \");\n        result.append(\"new java.lang.Iterable<String> () {\\n\");\n        result.append(\" @Override\\n\");\n        result.append(\" public java.util.Iterator<String> iterator() {\\n\");\n        result.append(\"     final java.util.Iterator<\"\n                + class_type.getParameterizedQualifiedSourceName()\n                + \"> baseIterator =  \" + argument_expr + \".iterator();\\n\");\n        result.append(\"     return new java.util.Iterator<String>() {\\n\");\n        result.append(\"         @Override\\n\");\n        result.append(\"         public boolean hasNext() {\\n\");\n        result.append(\"           return baseIterator.hasNext();\\n\");\n        result.append(\"         }\\n\");\n        result.append(\"         @Override\\n\");\n        result.append(\"         public String next() {\\n\");\n        final String expr = \"baseIterator.next()\";\n        String returnExpr;\n        if (class_type.isPrimitive() != null) {\n            returnExpr = \"\\\"\\\"+\" + expr;\n        } else if (STRING_TYPE == class_type) {\n            returnExpr = expr;\n        } else if (class_type.isClass() != null &&\n            isOverlayArrayType(class_type.isClass())) {\n            returnExpr = \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        } else if (class_type.isClass() != null &&\n            OVERLAY_VALUE_TYPE.isAssignableFrom(class_type.isClass())) {\n            returnExpr = \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        } else if (class_type.getQualifiedBinaryName().startsWith(\"java.lang.\")) {\n            result.append(\"             Object obj = \" + expr + \";\");\n            returnExpr = \"obj != null ? obj.toString() : null\";\n        } else {\n            Json jsonAnnotation = getAnnotation(argument, Json.class);\n            final Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n            returnExpr = locator.encodeExpression(class_type, expr, style) + \".toString()\";\n        }\n        result.append(\"             return \" + returnExpr + \";\\n\");\n        result.append(\"         }\\n\");\n        result.append(\"         @Override\\n\");\n        result.append(\"         public void remove() {\\n\");\n        result.append(\"             throw new UnsupportedOperationException();\\n\");\n        result.append(\"         }\\n\");\n        result.append(\"     };\\n\");\n        result.append(\" }\\n\");\n        result.append(\"}\\n\");\n\n        return result.toString();\n    }\n\n    protected String toStringExpression(JType type, String expr) {\n        if (type.isPrimitive() != null) {\n            return \"\\\"\\\"+\" + expr;\n        }\n        if (STRING_TYPE == type) {\n            return expr;\n        }\n        if (type.isClass() != null &&\n            isOverlayArrayType(type.isClass())) {\n          return \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.isClass() != null &&\n            OVERLAY_VALUE_TYPE.isAssignableFrom(type.isClass())) {\n          return \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        }\n\n        return String.format(\"(%s != null ? %s.toString() : null)\", expr, expr);\n    }\n\n    protected String toIteratedStringExpression(JParameter arg) {\n        StringBuilder result = new StringBuilder();\n        result.append(\"new org.fusesource.restygwt.client.StringIterable (\")\n            .append(arg.getName()).append(\")\");\n\n        return result.toString();\n    }\n\n    private JClassType getCallbackTypeGenericClass(final JClassType callbackType) throws UnableToCompleteException {\n        return branch(\"getCallbackTypeGenericClass()\", new Branch<JClassType>() {\n            @Override\n            public JClassType execute() throws UnableToCompleteException {\n\n                for (JMethod method : callbackType.getOverridableMethods()) {\n                    getLogger().log(DEBUG, \"checking method: \" + method.getName());\n                    if (method.getName().equals(\"onSuccess\")) {\n                        JParameter[] parameters = method.getParameters();\n                        getLogger().log(DEBUG, \"checking method params: \" + parameters.length);\n                        if (parameters.length == 2) {\n                            getLogger().log(DEBUG, \"checking first param: \" + parameters[0].getType());\n                            if (parameters[0].getType() == METHOD_TYPE) {\n                                getLogger().log(DEBUG, \"checking 2nd param: \" + parameters[1].getType());\n                                JType param2Type = parameters[1].getType();\n                                JClassType type = param2Type.isClassOrInterface();\n                                if (type == null) {\n                                    getLogger().log(ERROR, \"The type of the callback not supported: \" + param2Type.getJNISignature());\n                                    throw new UnableToCompleteException();\n                                }\n                                getLogger().log(DEBUG, \"match: \" + type);\n                                return type;\n                            }\n                        }\n                    }\n                }\n                getLogger().log(ERROR, \"The type of the callback could not be determined: \" + callbackType.getParameterizedQualifiedSourceName());\n                throw new UnableToCompleteException();\n            }\n        });\n    }\n\n    private String getRestMethod(JMethod method) throws UnableToCompleteException {\n        String restMethod = null;\n        if (getAnnotation(method, DELETE.class) != null) {\n            restMethod = METHOD_DELETE;\n        } else if (getAnnotation(method, GET.class) != null) {\n            restMethod = METHOD_GET;\n        } else if (getAnnotation(method, HEAD.class) != null) {\n            restMethod = METHOD_HEAD;\n        } else if (getAnnotation(method, OPTIONS.class) != null) {\n            restMethod = METHOD_OPTIONS;\n        } else if (getAnnotation(method, POST.class) != null) {\n            restMethod = METHOD_POST;\n        } else if (getAnnotation(method, PUT.class) != null) {\n            restMethod = METHOD_PUT;\n        } else if (getAnnotation(method, JSONP.class) != null) {\n            restMethod = METHOD_JSONP;\n        } else {\n            restMethod = method.getName();\n            if (!REST_METHODS.contains(restMethod)) {\n                getLogger().log(ERROR, \"Invalid rest method. It must either have a lower case rest method name or have a javax rs method annotation: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n        }\n        return restMethod;\n    }\n\n    /**\n     * access additional AnnotationResolvers possibly added by\n     *\n     * {@link BindingDefaults#addAnnotationResolver(AnnotationResolver)}\n     * @return\n     */\n    // TODO remove suppression\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private List<AnnotationResolver> getAnnotationResolvers(final GeneratorContext context, final TreeLogger logger) {\n        java.lang.reflect.Method m = null;\n        ArrayList args = new ArrayList();\n        ArrayList types = new ArrayList();\n\n        types.add(GeneratorContext.class);\n        args.add(context);\n        types.add(TreeLogger.class);\n        args.add(logger);\n\n        Object[] argValues = args.toArray();\n        Class[] argtypes = (Class[]) types.toArray(new Class[argValues.length]);\n\n        try {\n             m = BINDING_DEFAULTS.getMethod(\"getAnnotationResolvers\", argtypes);\n        } catch (SecurityException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"could not resolve method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        List<AnnotationResolver> l = new ArrayList<AnnotationResolver>();\n        try {\n            l = (List<AnnotationResolver>) m.invoke(null, context, logger);\n        } catch (IllegalArgumentException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (InvocationTargetException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        return l;\n    }\n\n    private String returnRequest(boolean returnRequest, boolean isJsonp) {\n        String type = isJsonp ? JsonpRequest.class.getName() : Request.class.getName();\n        return returnRequest ? \"return (\"+type+\")\" : \"\";\n    }\n}\n","lineNo":600}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\nimport static org.fusesource.restygwt.rebind.util.AnnotationUtils.*;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonSubTypes;\nimport com.fasterxml.jackson.annotation.JsonSubTypes.Type;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.As;\nimport com.fasterxml.jackson.annotation.JsonValue;\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JConstructor;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONNull;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONString;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.thirdparty.guava.common.collect.Lists;\nimport com.google.gwt.thirdparty.guava.common.collect.Maps;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport javax.xml.bind.annotation.XmlTransient;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added getter + setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n *\n *         added polymorphic support\n * @author <a href=\"http://charliemason.info\">Charlie Mason<\/a>\n *\n */\n\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n    protected static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_NULL_CLASS = JSONNull.class.getName();\n    protected static final String JSON_STRING_CLASS = JSONString.class.getName();\n\n    protected JsonEncoderDecoderInstanceLocator locator;\n\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    @Override\n    public void generate() throws UnableToCompleteException {\n        final JsonTypeInfo typeInfo = getClassAnnotation(source, JsonTypeInfo.class);\n        final boolean isLeaf = isLeaf(source);\n\n        final List<Subtype> possibleTypes = getPossibleTypes(typeInfo, isLeaf);\n        Collections.sort(possibleTypes);\n\n        final JClassType sourceClazz = source.isClass() == null ? source.isInterface() : source.isClass();\n        if (sourceClazz == null) {\n            getLogger().log(ERROR, \"Type is not a class\");\n            throw new UnableToCompleteException();\n        }\n\n\t\tif (sourceClazz.isEnum() == null && sourceClazz.isAbstract()) {\n            if (typeInfo == null) {\n                getLogger().log(ERROR, \"Abstract classes must be annotated with JsonTypeInfo\");\n                throw new UnableToCompleteException();\n            }\n        }\n        Json jsonAnnotation = getAnnotation(source, Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n        final String railsWrapperName = jsonAnnotation != null && jsonAnnotation.name().length() > 0 ? jsonAnnotation.name() : sourceClazz.getName().toLowerCase();\n        locator = new JsonEncoderDecoderInstanceLocator(context, getLogger());\n\n        generateSingleton(shortName);\n\n        generateEncodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n\n        generateDecodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n\tClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n\tcomposerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n\treturn composerFactory;\n    }\n\n    private List<Subtype> getPossibleTypes(final JsonTypeInfo typeInfo, final boolean isLeaf) throws UnableToCompleteException\n    {\n        if (typeInfo == null)\n            return Lists.newArrayList(new Subtype(null, source));\n        Collection<Type> subTypes = findJsonSubTypes(source);\n        if(subTypes.isEmpty()) {\n            JsonSubTypes foundAnnotation = getAnnotation(source, JsonSubTypes.class);\n            if(foundAnnotation != null) {\n                Type[] value = foundAnnotation.value();\n                subTypes = Arrays.asList(value);\n            }\n        }\n        PossibleTypesVisitor v = new PossibleTypesVisitor(context, source, isLeaf, getLogger(), subTypes);\n        return v.visit(typeInfo.use());\n    }\n\n    /**\n     * This method does NOT return the subtypes of the given class, but all the subtypes associated with the\n     * {@link com.fasterxml.jackson.annotation.JsonSubTypes} annotation, even if this annotation is assigned to\n     * a parent class or an interface.\n     */\n    private Collection<Type> findJsonSubTypes(JClassType clazz) {\n        return findJsonSubTypes(clazz, new HashSet<JsonSubTypes.Type>());\n    }\n    \n    private Collection<Type> findJsonSubTypes(JClassType clazz, Set<Type> types) {\n        if (clazz == null) {\n            return Collections.emptyList();\n            \n        } else {\n            JsonSubTypes annotation = getClassAnnotation(clazz, JsonSubTypes.class);\n            \n            if (annotation == null) {\n                return Collections.emptyList();\n            }\n\n            for (Type type : annotation.value()) {\n                if (types.add(type)) {\n                    Class<?> subclazz = type.value();\n                    String newSubClassName = subclazz.getName().replaceAll(\"\\\\$\", \".\");\n                    JClassType subJClazz = context.getTypeOracle().findType(newSubClassName);\n                    findJsonSubTypes(subJClazz, types);\n                }\n            }\n\n            return types;\n        }\n    }\n\n    protected void generateSingleton(String shortName)\n    {\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n    }\n\n    private void generateEncodeMethod(JClassType classType,\n            final Style classStyle,\n            JsonTypeInfo typeInfo,\n            String railsWrapperName,\n            List<Subtype> possibleTypes,\n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {\n            generateEnumEncodeMethod(classType, JSON_VALUE_CLASS);\n            return;\n        }\n\n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n\n            boolean returnWrapper = false; // if set, return rrc\n\n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n            if (classStyle == Style.RAILS) {\n                returnWrapper = true;\n                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                p(\"rrc.put(\\\"\" + railsWrapperName + \"\\\" , rc);\");\n            }\n\n            for (Subtype possibleType : possibleTypes) {\n\n                if (!possibleType.clazz.isAssignableTo(classType)) {\n                    getLogger().log(DEBUG, \"Only assignable classes are allowed: \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" is not assignable to: \" + classType.getParameterizedQualifiedSourceName());\n                    continue;\n                }\n\n                if (!isLeaf) {\n                    // Generate a decoder for each possible type\n                    p(\"if(value.getClass().getName().equals(\\\"\" + possibleType.clazz.getQualifiedBinaryName() + \"\\\"))\");\n                    p(\"{\");\n                }\n\n                if (possibleType.clazz.isEnum() != null) {\n                    generateEnumEncodeMethodBody(possibleType, typeInfo);\n                } else {\n\n                    // Try to find a constuctor that is annotated as creator\n                    final JConstructor creator = findCreator(possibleType.clazz);\n\n                    List<JField> orderedFields = creator == null ? null : getOrderedFields(getFields(possibleType.clazz), creator);\n\n                    if (typeInfo != null) {\n                        switch (typeInfo.include()) {\n                            case PROPERTY:\n                                p(\"com.google.gwt.json.client.JSONValue className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\");\");\n                                p(\"if( className!=null ) { \").i(1);\n                                p(\"rc.put(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \", className);\");\n                                i(-1).p(\"}\");\n                                break;\n                            case WRAPPER_OBJECT:\n                                returnWrapper = true;\n                                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                                p(\"rrc.put(\\\"\" + possibleType.tag + \"\\\", rc);\");\n                                break;\n                            case WRAPPER_ARRAY:\n                                returnWrapper = true;\n                                p(JSON_ARRAY_CLASS + \" rrc = new \" + JSON_ARRAY_CLASS + \"();\");\n                                p(\"rrc.set(0, org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\"));\");\n                                p(\"rrc.set(1, rc);\");\n                        }\n                    }\n\n                    p(possibleType.clazz.getParameterizedQualifiedSourceName() + \" parseValue = (\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \")value;\");\n\n                    for (final JField field : getFields(possibleType.clazz)) {\n\n                        final String getterName = getGetterName(field);\n\n                        boolean ignoreField = false;\n                        if(getAnnotation(possibleType.clazz, JsonIgnoreProperties.class) != null) {\n                            for(String s : getAnnotation(possibleType.clazz, JsonIgnoreProperties.class).value()) {\n                                if(s.equals(field.getName())) {\n                                    ignoreField = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        // If can ignore some fields right off the back..\n                        // if there is a creator encode only final fields with JsonProperty annotation\n                        if (ignoreField || getterName == null && (field.isStatic() || (field.isFinal() && !(creator != null && orderedFields.contains(field))) || field.isTransient()\n\t\t\t\t\t\t\t\t|| field.isAnnotationPresent(JsonIgnore.class) || field.isAnnotationPresent(XmlTransient.class))) {\n                            continue;\n                        }\n\n                        branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                            @Override\n                            public Void execute() throws UnableToCompleteException {\n                                // TODO: try to get the field with a setter or\n                                // JSNI\n                                if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                                    Json jsonAnnotation = getAnnotation(field, Json.class);\n                                    JsonProperty jsonPropertyAnnotation = getAnnotation(field, JsonProperty.class);\n\n                                    String name = field.getName();\n                                    String jsonName = name;\n\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                                        jsonName = jsonPropertyAnnotation.value();\n                                    }\n\n                                    String fieldExpr = \"parseValue.\" + name;\n                                    if (getterName != null) {\n                                        fieldExpr = \"parseValue.\" + getterName + \"()\";\n                                    }\n\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    String expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n\n                                    \n                                    if (null != field.getType().isEnum()) {\n                                    \tp(\"if(isNotNullAndCheckDefaults(\" + fieldExpr+ \", rc, \"+ wrap(jsonName) + \")) {\").i(1);\n                                    }\n                                        \n                                    p(\"isNotNullValuePut(\" + expression + \", rc, \"+ wrap(jsonName) + \");\");\n\n                                    if (null != field.getType().isEnum()) {\n                                    \ti(-1).p(\"}\");\n                                    }\n                                    \n\n                                } else {\n                                    getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                                }\n                                return null;\n                            }\n                        });\n\n                    }\n\n                    if (returnWrapper) {\n                        p(\"return rrc;\");\n                    } else {\n                        p(\"return rc;\");\n                    }\n                }\n                if (!isLeaf) {\n                    p(\"}\");\n                }\n            }\n\n            if (!isLeaf) {\n                // Shouldn't get called\n                p(\"return null;\");\n            }\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n\n    private void generateEnumEncodeMethodBody(final Subtype possibleType, final JsonTypeInfo typeInfo) {\n        p(\"if( value==null ) {\").i(1);\n        {\n            p(\"return \" + JSON_NULL_CLASS + \".getInstance();\").i(-1);\n        }\n        p(\"}\");\n        p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n        p(JSON_VALUE_CLASS + \" className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\"\n                + possibleType.tag + \"\\\");\");\n        p(\"rrc.put(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \", className);\");\n        p(\"rrc.put(\\\"name\\\", new \" + JSON_STRING_CLASS + \"(value.\" + getValueMethod(possibleType.clazz) + \"()));\");\n        p(\"return rrc;\");\n    }\n\n    private void generateEnumEncodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + jsonValueClass + \" encode(\" + classType.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return \" + JSON_NULL_CLASS + \".getInstance();\").i(-1);\n            }\n            p(\"}\");\n            p(\"return new \" + JSON_STRING_CLASS + \"(value.\" + getValueMethod(classType) + \"());\");\n            i(-1).p(\"}\");\n        }\n        p();\n    }\n\n    protected String getValueMethod(JClassType classType) {\n        String method = \"name\";\n        for(JMethod jm : classType.isEnum().getMethods() ) {\n            if (jm.isAnnotationPresent(JsonValue.class)) {\n                method = jm.getName();\n                break;\n            }\n        }\n        return method;\n    }\n\n    private void generateDecodeMethod(JClassType classType,\n            final Style classStyle,\n            JsonTypeInfo typeInfo,\n            String railsWrapperName,\n            List<Subtype> possibleTypes,\n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {\n            generateEnumDecodeMethod(classType, JSON_VALUE_CLASS);\n            return;\n        }\n\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n            {\n                p(\"return null;\").i(-1);\n            }\n            p(\"}\");\n            if (classStyle == Style.RAILS) {\n                p(JSON_OBJECT_CLASS + \" object = toObjectFromWrapper(value, \\\"\" + railsWrapperName + \"\\\");\");\n            } else if (typeInfo != null && typeInfo.include() == As.WRAPPER_ARRAY) {\n                p(JSON_ARRAY_CLASS + \" array = (\" + JSON_ARRAY_CLASS + \")value;\");\n                if (!isLeaf)\n                    p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(array.get(0));\");\n                p(JSON_OBJECT_CLASS + \" object = toObject(array.get(1));\");\n            } else {\n                p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            }\n\n            if (!isLeaf && typeInfo != null && typeInfo.include() == As.PROPERTY) {\n                p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \"));\");\n            }\n\n            for (Subtype possibleType : possibleTypes) {\n\n                if (!possibleType.clazz.isAssignableTo(classType)) {\n                    getLogger().log(DEBUG, \"Only assignable classes are allowed: \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" is not assignable to: \" + classType.getParameterizedQualifiedSourceName());\n                    continue;\n                }\n\n                if (typeInfo != null) {\n                    if (typeInfo.include() == As.WRAPPER_OBJECT) {\n                        if (!isLeaf) {\n                            p(\"if(object.containsKey(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        }\n                        p(\"object = toObjectFromWrapper(value, \\\"\" + possibleType.tag + \"\\\");\");\n                    } else if (!isLeaf) {\n                        if (classType.equals(possibleType.clazz)) {\n                            p(\"if(sourceName == null || sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        } else {\n                            p(\"if(sourceName != null && sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        }\n                    }\n                }\n\n                if (possibleType.clazz.isEnum() != null) {\n                    generateEnumDecodeMethodBody(possibleType.clazz);\n                } else {\n                    // Try to find a constuctor that is annotated as creator\n                    final JConstructor creator = findCreator(possibleType.clazz);\n\n                    List<JField> orderedFields = null;\n                    if (creator != null) {\n                        p(\"// We found a creator so we use the annotated constructor\");\n                        p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"(\");\n                        i(1).p(\"// The arguments are placed in the order they appear within the annotated constructor\").i(-1);\n                        orderedFields = getOrderedFields(getFields(possibleType.clazz), creator);\n                        final JField lastField = orderedFields.get(orderedFields.size() - 1);\n                        for (final JField field : orderedFields) {\n                            branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                                @Override\n                                public Void execute() throws UnableToCompleteException {\n                                    Json jsonAnnotation = getAnnotation(field, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    String jsonName = field.getName();\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                    String defaultValue = getDefaultValue(field);\n                                    i(1).p(\"\" + (objectGetter + \" == null || \" + objectGetter + \" instanceof \" + JSON_NULL_CLASS + \" ? \" + defaultValue + \" : \" + expression + ((field != lastField) ? \", \" : \"\"))).i(-1);\n\n                                    return null;\n                                }\n                            });\n                        }\n                        p(\");\");\n                    }\n\n                    if (orderedFields == null){\n                        p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"();\");\n                    }\n\n                    for (final JField field : getFields(possibleType.clazz)) {\n\n                        boolean ignoreField = false;\n                        if(getAnnotation(possibleType.clazz, JsonIgnoreProperties.class) != null) {\n                            for(String s : getAnnotation(possibleType.clazz, JsonIgnoreProperties.class).value()) {\n                                if(s.equals(field.getName())) {\n                                    ignoreField = true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(ignoreField) {\n                            continue;\n                        }\n\n                        if (orderedFields != null && orderedFields.contains(field)){\n                            continue;\n                        }\n\n                        final String setterName = getSetterName(field);\n\n                        // If can ignore some fields right off the back..\n                        if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient())\n\t\t\t\t\t\t\t\t|| field.isAnnotationPresent(JsonIgnore.class) || field.isAnnotationPresent(XmlTransient.class)) {\n                            continue;\n                        }\n\n                        branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                            @Override\n                            public Void execute() throws UnableToCompleteException {\n\n                                // TODO: try to set the field with a setter\n                                // or JSNI\n                                if (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                                    Json jsonAnnotation = getAnnotation(field, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    JsonProperty jsonPropertyAnnotation = getAnnotation(field, JsonProperty.class);\n\n                                    String name = field.getName();\n                                    String jsonName = name;\n\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                                        jsonName = jsonPropertyAnnotation.value();\n                                    }\n\n                                    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                    boolean needNullHandling = !locator.hasCustomEncoderDecoder(field.getType());\n\n                                    boolean isShort = field.getType().isPrimitive() == JPrimitiveType.SHORT;\n                                    String defaultValue = getDefaultValue(field);\n\n                                    String methodName = isShort ? \"getValueToSetForShort\" : \"getValueToSet\";\n                                    \n                                    if (setterName != null) {\n                                    \tp(\"rc.\" + setterName + \"(\"  + methodName + \"(\" + expression + \", \" + defaultValue + \",\" + needNullHandling + \"));\");\n                                    } else {\n                                    \tp(\"rc.\" + name + \"= \" +  methodName + \"(\" + expression + \",\" + defaultValue + \",\" + needNullHandling+ \");\");\n                                    }\n                                    \n                                } else {\n                                    getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                                }\n                                return null;\n                            }\n                        });\n                    }\n\n                    p(\"return rc;\");\n                }\n                if (typeInfo != null && !isLeaf) {\n                    p(\"}\");\n                }\n            }\n\n            if (typeInfo != null && !isLeaf) {\n                p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n            p();\n        }\n    }\n\n    private void generateEnumDecodeMethodBody(JClassType classType) {\n        p(JSON_VALUE_CLASS + \" str = object.get(\\\"name\\\");\");\n        p(\"if( null == str || str.isString() == null ) {\").i(1);\n        {\n            p(\"throw new DecodingException(\\\"Expected a string field called 'name' for enum; not found\\\");\").i(-1);\n        }\n        p(\"}\");\n        decodeEnum(classType, \"str.isString().stringValue()\");\n    }\n\n    private String getDefaultValue(JField field) {\n        return field.getType().isPrimitive() == null ? \"null\" : field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n    }\n\n    protected void generateEnumDecodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + classType.getName() + \" decode(\" + jsonValueClass + \" value) {\").i(1);\n        {\n        p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n        {\n            p(\"return null;\").i(-1);\n        }\n        p(\"}\");\n        p(JSON_STRING_CLASS + \" str = value.isString();\");\n        p(\"if( null == str ) {\").i(1);\n        {\n            p(\"throw new DecodingException(\\\"Expected a json string (for enum), but was given: \\\"+value);\").i(-1);\n        }\n        p(\"}\");\n\n        String value = \"str.stringValue()\";\n        decodeEnum(classType, value);\n        }\n        p(\"}\");\n        p();\n    }\n\n    protected void decodeEnum(JClassType classType, String value) {\n        String className = classType.getParameterizedQualifiedSourceName();\n        String method = getValueMethod(classType);\n        if ( method == null ) {\n            p(\"return Enum.valueOf(\" + className + \".class, \" + value + \");\").i(-1);\n        }\n        else {\n            p(\"for(\" + className + \" v: \" + className + \".values()) {\").i(1);\n            {\n                p(\"if(v.\" + method + \"().equals(\" + value + \")) {\").i(1);\n                {\n                    p(\"return v;\").i(-1);\n                }\n                p(\"}\").i(-1);\n            }\n            p(\"}\");\n            p(\"throw new DecodingException(\\\"can not find enum for given value: \\\"+\" + value + \");\").i(-1);\n        }\n    }\n\n    static public void clearRestyResolverClassMap() {\n    \tsTypeIdResolverMap = null;\n    }\n    \n    public static Map<Class<?>, RestyJsonTypeIdResolver> getRestyResolverClassMap(GeneratorContext context, TreeLogger logger) throws UnableToCompleteException {\n\tif (sTypeIdResolverMap == null) {\n\t    try {\n\t\tMap<Class<?>, RestyJsonTypeIdResolver> map = Maps.newHashMap();\n\t\tList<String> values = context.getPropertyOracle().getConfigurationProperty(\"org.fusesource.restygwt.jsontypeidresolver\").getValues();\n\t\tfor (String value : values)\n\t\t    try {\n\t\t\tClass<?> clazz = Class.forName(value);\n\t\t\tRestyJsonTypeIdResolver resolver = (RestyJsonTypeIdResolver) clazz.newInstance();\n\t\t\tmap.put(resolver.getTypeIdResolverClass(), resolver);\n\t\t    } catch (Exception e) {\n\t\t\tlogger.log(WARN, \"Could not access class: \" + values.get(0), e);\n\t\t    }\n\t\t    sTypeIdResolverMap = map;\n\t    } catch (BadPropertyValueException e) {\n\t\tlogger.log(ERROR, \"Could not acccess property: RestyJsonTypeIdResolver\", e);\n\t\tthrow new UnableToCompleteException();\n\t    }\n\t}\n\treturn sTypeIdResolverMap;\n    }\n\n    private List<JField> getOrderedFields(List<JField> fields, JConstructor creator) throws UnableToCompleteException {\n\tList<JField> orderedFields = new ArrayList<JField>();\n\tfor (JParameter param : creator.getParameters()) {\n\t    JsonProperty prop = getAnnotation(param, JsonProperty.class);\n\t    if (prop != null) {\n\t\tfor (JField field : fields) {\n\t\t    if (field.getName().equals(prop.value())) {\n\t\t\torderedFields.add(field);\n\t\t    }\n\t\t}\n\t    } else {\n\t\tgetLogger().log(ERROR, \"a constructor annotated with @JsonCreator requires that all paramaters are annotated with @JsonProperty.\");\n        throw new UnableToCompleteException();\n\t    }\n\t}\n\n\treturn orderedFields;\n    }\n\n    private JConstructor findCreator(JClassType sourceClazz) {\n\tfor (JConstructor constructor : sourceClazz.getConstructors()) {\n\t    if (getAnnotation(constructor, JsonCreator.class) != null) {\n\t\treturn constructor;\n\t    }\n\t}\n\n\treturn null;\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the setter for the specified field or null if a\n     *         setter can't be found.\n     */\n    private String getSetterName(JField field) {\n\tString fieldName = field.getName();\n\tfieldName = \"set\" + upperCaseFirstChar(fieldName);\n\tJClassType type = field.getEnclosingType();\n\tif (exists(type, field, fieldName, true)) {\n\t    return fieldName;\n\t}\n    return null;\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the getter for the specified field or null if a\n     *         getter can't be found.\n     */\n    private String getGetterName(JField field) {\n\tString fieldName = field.getName();\n\tJType booleanType = null;\n\ttry {\n\t    booleanType = find(Boolean.class, getLogger(), context);\n\t} catch (UnableToCompleteException e) {\n\t    // do nothing\n\t}\n\tJClassType type = field.getEnclosingType();\n\tif (field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)) {\n\t    fieldName = \"is\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t    fieldName = \"has\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t}\n\tfieldName = \"get\" + upperCaseFirstChar(field.getName());\n\tif (exists(type, field, fieldName, false)) {\n\t    return fieldName;\n\t}\n    return null;\n    }\n\n    private String upperCaseFirstChar(String in) {\n\tif (in.length() == 1) {\n\t    return in.toUpperCase();\n\t}\n    return in.substring(0, 1).toUpperCase() + in.substring(1);\n    }\n\n    /**\n     * checks whether a getter or setter exists on the specified type or any of\n     * its super classes excluding Object. respects JsonIgnore accordingly.\n     *\n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {\n        if ( field instanceof DummyJField ){\n            return true;\n        }\n\n\tJType[] args = null;\n\tif (isSetter) {\n\t    args = new JType[] { field.getType() };\n\t} else {\n\t    args = new JType[] {};\n\t}\n\tJMethod m = type.findMethod(fieldName, args);\n\tif (null != m) {\n        if(getAnnotation(m, JsonIgnore.class) != null)\n\t\t\treturn false;\n\t\tif (getAnnotation(m, XmlTransient.class) != null)\n\t\t\treturn false;\n        if(isSetter)\n            return true;\n        JClassType returnType = m.getReturnType().isClassOrInterface();\n        JClassType fieldType = field.getType().isClassOrInterface();\n        if(returnType == null || fieldType == null) {\n            // at least one is a primitive type\n            return m.getReturnType().equals(field.getType());\n        }\n        // both are non-primitives\n        return returnType.isAssignableFrom(fieldType);\n\t}\n    try {\n    JType objectType = find(Object.class, getLogger(), context);\n    JClassType superType = type.getSuperclass();\n    if (!objectType.equals(superType)) {\n        return exists(superType, field, fieldName, isSetter);\n    }\n    } catch (UnableToCompleteException e) {\n    // do nothing\n    }\n\treturn false;\n    }\n\n    /**\n     * Inspects the supplied type and all super classes up to but excluding\n     * Object and returns a list of all fields found in these classes.\n     *\n     * @param type\n     * @return\n     */\n    private List<JField> getFields(JClassType type) {\n        List<JField> allFields = getFields(new ArrayList<JField>(), type);\n        Map<String, JMethod> getters = new HashMap<String, JMethod>();\n        Map<String, JType> setters = new HashMap<String, JType>();\n        for( JMethod m: type.getInheritableMethods() ){\n            if( m.getName().startsWith(\"set\") &&\n                    m.getParameterTypes().length == 1 &&\n                    m.getReturnType() == JPrimitiveType.VOID &&\n\t\t\t\t\tgetAnnotation(m, JsonIgnore.class) == null && \n\t\t\t\t\tgetAnnotation(m, XmlTransient.class) == null) {\n                setters.put( m.getName().replaceFirst(\"^set\", \"\"), m.getParameterTypes()[0] );\n            }\n            else if( m.getName().startsWith(\"get\") &&\n                    m.getParameterTypes().length == 0 &&\n                    m.getReturnType() != JPrimitiveType.VOID &&\n\t\t\t\t\tgetAnnotation(m, JsonIgnore.class) == null && \n\t\t\t\t\tgetAnnotation(m, XmlTransient.class) == null) {\n                getters.put( m.getName().replaceFirst(\"^get\", \"\"), m );\n            }\n        }\n        for( Map.Entry<String, JMethod> entry: getters.entrySet() ){\n            if ( setters.containsKey( entry.getKey() ) && setters.get( entry.getKey() ).equals( entry.getValue().getReturnType() ) ) {\n                String name = entry.getKey().substring(0, 1).toLowerCase() + entry.getKey().substring(1);\n                boolean found = false;\n                for( JField f : allFields ){\n                    if( f.getName().equals( name ) ){\n                        found = true;\n                        break;\n                    }\n                }\n                JField f = type.findField( name );\n                // is getter annotated, if yes use this annotation for the field\n                JsonProperty propName = null;\n                if ( entry.getValue().isAnnotationPresent(JsonProperty.class) ) {\n                    propName = getAnnotation(entry.getValue(), JsonProperty.class);\n                }\n                // is setter annotated, if yes use this annotation for the field\n                JMethod m = type.findMethod(\"s\" + entry.getValue().getName().substring(1),\n                        new JType[]{ entry.getValue().getReturnType() });\n                if ( m != null && m.isAnnotationPresent(JsonProperty.class) ) {\n                    propName = getAnnotation(m, JsonProperty.class);\n                }\n                // if have a field and an annotation from the getter/setter then use that annotation \n                if ( propName != null && found && !f.getName().equals(propName.value())) {\n                    allFields.remove(f);\n                    DummyJField dummy = new DummyJField( name, entry.getValue().getReturnType() );\n                    dummy.setAnnotation( propName );\n                    allFields.add(dummy);\n                }\n                if ( ! found && !( f != null && f.isAnnotationPresent( JsonIgnore.class ) ) ){\n                    DummyJField dummy = new DummyJField( name, entry.getValue().getReturnType() );\n                    if ( entry.getValue().isAnnotationPresent(JsonProperty.class) ) {\n                        dummy.setAnnotation( getAnnotation(entry.getValue(), JsonProperty.class) );\n                    }\n                    allFields.add( dummy );\n                }\n            }\n        }\n        return allFields;\n    }\n\n    private List<JField> getFields(List<JField> allFields, JClassType type) {\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n\t\t\tif (!field.isTransient() && !field.isAnnotationPresent(JsonIgnore.class) &&\n\t\t\t\t\t!field.isAnnotationPresent(XmlTransient.class)) {\n                allFields.add(field);\n            }\n        }\n        try {\n            JType objectType = find(Object.class, getLogger(), context);\n            if (!objectType.equals(type)) {\n                JClassType superType = type.getSuperclass();\n                return getFields(allFields, superType);\n            }\n        }\n        catch (UnableToCompleteException e) {\n\t    // do nothing\n        }\n\n    \treturn allFields;\n    }\n\n    public static String getTypeInfoPropertyValue(final JsonTypeInfo typeInfo)\n    {\n        if (typeInfo.include() == JsonTypeInfo.As.PROPERTY)\n            if(typeInfo.property() == null || \"\".equals(typeInfo.property()))\n                return typeInfo.use().getDefaultPropertyName();\n\n        return typeInfo.property();\n    }\n\n    public static boolean isLeaf(JClassType source)\n    {\n        return !(source.getSubtypes() != null && source.getSubtypes().length > 0);\n    }\n\n    public static class Subtype implements Comparable<Subtype> {\n    final String tag;\n    final JClassType clazz;\n\n    public Subtype(String tag, JClassType clazz) {\n        this.tag = tag;\n        this.clazz = clazz;\n    }\n\n    @Override\n    public int compareTo(Subtype o) {\n        return tag.compareTo(o.tag);\n    }\n    }\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> sTypeIdResolverMap = null;\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\nimport static org.fusesource.restygwt.rebind.util.AnnotationUtils.*;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonSubTypes;\nimport com.fasterxml.jackson.annotation.JsonSubTypes.Type;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.As;\nimport com.fasterxml.jackson.annotation.JsonValue;\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JConstructor;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONNull;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONString;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.thirdparty.guava.common.collect.Lists;\nimport com.google.gwt.thirdparty.guava.common.collect.Maps;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport javax.xml.bind.annotation.XmlTransient;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added getter + setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n *\n *         added polymorphic support\n * @author <a href=\"http://charliemason.info\">Charlie Mason<\/a>\n *\n */\n\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n    protected static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_NULL_CLASS = JSONNull.class.getName();\n    protected static final String JSON_STRING_CLASS = JSONString.class.getName();\n\n    protected JsonEncoderDecoderInstanceLocator locator;\n\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    @Override\n    public void generate() throws UnableToCompleteException {\n        final JsonTypeInfo typeInfo = getClassAnnotation(source, JsonTypeInfo.class);\n        final boolean isLeaf = isLeaf(source);\n\n        final List<Subtype> possibleTypes = getPossibleTypes(typeInfo, isLeaf);\n        Collections.sort(possibleTypes);\n\n        final JClassType sourceClazz = source.isClass() == null ? source.isInterface() : source.isClass();\n        if (sourceClazz == null) {\n            getLogger().log(ERROR, \"Type is not a class\");\n            throw new UnableToCompleteException();\n        }\n\n\t\tif (sourceClazz.isEnum() == null && sourceClazz.isAbstract()) {\n            if (typeInfo == null) {\n                getLogger().log(ERROR, \"Abstract classes must be annotated with JsonTypeInfo\");\n                throw new UnableToCompleteException();\n            }\n        }\n        Json jsonAnnotation = getAnnotation(source, Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n        final String railsWrapperName = jsonAnnotation != null && jsonAnnotation.name().length() > 0 ? jsonAnnotation.name() : sourceClazz.getName().toLowerCase();\n        locator = new JsonEncoderDecoderInstanceLocator(context, getLogger());\n\n        generateSingleton(shortName);\n\n        generateEncodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n\n        generateDecodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n\tClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n\tcomposerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n\treturn composerFactory;\n    }\n\n    private List<Subtype> getPossibleTypes(final JsonTypeInfo typeInfo, final boolean isLeaf) throws UnableToCompleteException\n    {\n        if (typeInfo == null)\n            return Lists.newArrayList(new Subtype(null, source));\n        Collection<Type> subTypes = findJsonSubTypes(source);\n        if(subTypes.isEmpty()) {\n            JsonSubTypes foundAnnotation = getAnnotation(source, JsonSubTypes.class);\n            if(foundAnnotation != null) {\n                Type[] value = foundAnnotation.value();\n                subTypes = Arrays.asList(value);\n            }\n        }\n        PossibleTypesVisitor v = new PossibleTypesVisitor(context, source, isLeaf, getLogger(), subTypes);\n        return v.visit(typeInfo.use());\n    }\n\n    /**\n     * This method does NOT return the subtypes of the given class, but all the subtypes associated with the\n     * {@link com.fasterxml.jackson.annotation.JsonSubTypes} annotation, even if this annotation is assigned to\n     * a parent class or an interface.\n     */\n    private Collection<Type> findJsonSubTypes(JClassType clazz) {\n        return findJsonSubTypes(clazz, new HashSet<JsonSubTypes.Type>());\n    }\n    \n    private Collection<Type> findJsonSubTypes(JClassType clazz, Set<Type> types) {\n        if (clazz == null) {\n            return Collections.emptyList();\n            \n        } else {\n            JsonSubTypes annotation = getClassAnnotation(clazz, JsonSubTypes.class);\n            \n            if (annotation == null) {\n                return Collections.emptyList();\n            }\n\n            for (Type type : annotation.value()) {\n                if (types.add(type)) {\n                    Class<?> subclazz = type.value();\n                    String newSubClassName = subclazz.getName().replaceAll(\"\\\\$\", \".\");\n                    JClassType subJClazz = context.getTypeOracle().findType(newSubClassName);\n                    findJsonSubTypes(subJClazz, types);\n                }\n            }\n\n            return types;\n        }\n    }\n\n    protected void generateSingleton(String shortName)\n    {\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n    }\n\n    private void generateEncodeMethod(JClassType classType,\n            final Style classStyle,\n            JsonTypeInfo typeInfo,\n            String railsWrapperName,\n            List<Subtype> possibleTypes,\n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {\n            generateEnumEncodeMethod(classType, JSON_VALUE_CLASS);\n            return;\n        }\n\n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n\n            boolean returnWrapper = false; // if set, return rrc\n\n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n            if (classStyle == Style.RAILS) {\n                returnWrapper = true;\n                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                p(\"rrc.put(\\\"\" + railsWrapperName + \"\\\" , rc);\");\n            }\n\n            for (Subtype possibleType : possibleTypes) {\n\n                if (!possibleType.clazz.isAssignableTo(classType)) {\n                    getLogger().log(DEBUG, \"Only assignable classes are allowed: \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" is not assignable to: \" + classType.getParameterizedQualifiedSourceName());\n                    continue;\n                }\n\n                if (!isLeaf) {\n                    // Generate a decoder for each possible type\n                    p(\"if(value.getClass().getName().equals(\\\"\" + possibleType.clazz.getQualifiedBinaryName() + \"\\\"))\");\n                    p(\"{\");\n                }\n\n                if (possibleType.clazz.isEnum() != null) {\n                    generateEnumEncodeMethodBody(possibleType, typeInfo);\n                } else {\n\n                    // Try to find a constuctor that is annotated as creator\n                    final JConstructor creator = findCreator(possibleType.clazz);\n\n                    List<JField> orderedFields = creator == null ? null : getOrderedFields(getFields(possibleType.clazz), creator);\n\n                    if (typeInfo != null) {\n                        switch (typeInfo.include()) {\n                            case PROPERTY:\n                                p(\"com.google.gwt.json.client.JSONValue className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\");\");\n                                p(\"if( className!=null ) { \").i(1);\n                                p(\"rc.put(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \", className);\");\n                                i(-1).p(\"}\");\n                                break;\n                            case WRAPPER_OBJECT:\n                                returnWrapper = true;\n                                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                                p(\"rrc.put(\\\"\" + possibleType.tag + \"\\\", rc);\");\n                                break;\n                            case WRAPPER_ARRAY:\n                                returnWrapper = true;\n                                p(JSON_ARRAY_CLASS + \" rrc = new \" + JSON_ARRAY_CLASS + \"();\");\n                                p(\"rrc.set(0, org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\"));\");\n                                p(\"rrc.set(1, rc);\");\n                        }\n                    }\n\n                    p(possibleType.clazz.getParameterizedQualifiedSourceName() + \" parseValue = (\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \")value;\");\n\n                    for (final JField field : getFields(possibleType.clazz)) {\n\n                        final String getterName = getGetterName(field);\n\n                        boolean ignoreField = false;\n                        if(getAnnotation(possibleType.clazz, JsonIgnoreProperties.class) != null) {\n                            for(String s : getAnnotation(possibleType.clazz, JsonIgnoreProperties.class).value()) {\n                                if(s.equals(field.getName())) {\n                                    ignoreField = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        // If can ignore some fields right off the back..\n                        // if there is a creator encode only final fields with JsonProperty annotation\n                        if (ignoreField || getterName == null && (field.isStatic() || (field.isFinal() && !(creator != null && orderedFields.contains(field))) || field.isTransient()\n\t\t\t\t\t\t\t\t|| field.isAnnotationPresent(JsonIgnore.class) || field.isAnnotationPresent(XmlTransient.class))) {\n                            continue;\n                        }\n\n                        branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                            @Override\n                            public Void execute() throws UnableToCompleteException {\n                                // TODO: try to get the field with a setter or\n                                // JSNI\n                                if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                                    Json jsonAnnotation = getAnnotation(field, Json.class);\n                                    JsonProperty jsonPropertyAnnotation = getAnnotation(field, JsonProperty.class);\n\n                                    String name = field.getName();\n                                    String jsonName = name;\n\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                                        jsonName = jsonPropertyAnnotation.value();\n                                    }\n\n                                    String fieldExpr = \"parseValue.\" + name;\n                                    if (getterName != null) {\n                                        fieldExpr = \"parseValue.\" + getterName + \"()\";\n                                    }\n\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    String expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n\n                                    \n                                    if (null != field.getType().isEnum()) {\n                                    \tp(\"if(isNotNullAndCheckDefaults(\" + fieldExpr+ \", rc, \"+ wrap(jsonName) + \")) {\").i(1);\n                                    }\n                                        \n                                    p(\"isNotNullValuePut(\" + expression + \", rc, \"+ wrap(jsonName) + \");\");\n\n                                    if (null != field.getType().isEnum()) {\n                                    \ti(-1).p(\"}\");\n                                    }\n                                    \n\n                                } else {\n                                    getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                                }\n                                return null;\n                            }\n                        });\n\n                    }\n\n                    if (returnWrapper) {\n                        p(\"return rrc;\");\n                    } else {\n                        p(\"return rc;\");\n                    }\n                }\n                if (!isLeaf) {\n                    p(\"}\");\n                }\n            }\n\n            if (!isLeaf) {\n                // Shouldn't get called\n                p(\"return null;\");\n            }\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n\n    private void generateEnumEncodeMethodBody(final Subtype possibleType, final JsonTypeInfo typeInfo) {\n        p(\"if( value==null ) {\").i(1);\n        {\n            p(\"return \" + JSON_NULL_CLASS + \".getInstance();\").i(-1);\n        }\n        p(\"}\");\n        p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n        p(JSON_VALUE_CLASS + \" className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\"\n                + possibleType.tag + \"\\\");\");\n        p(\"rrc.put(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \", className);\");\n        p(\"rrc.put(\\\"name\\\", new \" + JSON_STRING_CLASS + \"(value.\" + getValueMethod(possibleType.clazz) + \"()));\");\n        p(\"return rrc;\");\n    }\n\n    private void generateEnumEncodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + jsonValueClass + \" encode(\" + classType.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return \" + JSON_NULL_CLASS + \".getInstance();\").i(-1);\n            }\n            p(\"}\");\n            p(\"return new \" + JSON_STRING_CLASS + \"(value.\" + getValueMethod(classType) + \"());\");\n            i(-1).p(\"}\");\n        }\n        p();\n    }\n\n    protected String getValueMethod(JClassType classType) {\n        String method = \"name\";\n        for(JMethod jm : classType.isEnum().getMethods() ) {\n            if (jm.isAnnotationPresent(JsonValue.class)) {\n                method = jm.getName();\n                break;\n            }\n        }\n        return method;\n    }\n\n    private void generateDecodeMethod(JClassType classType,\n            final Style classStyle,\n            JsonTypeInfo typeInfo,\n            String railsWrapperName,\n            List<Subtype> possibleTypes,\n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {\n            generateEnumDecodeMethod(classType, JSON_VALUE_CLASS);\n            return;\n        }\n\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n            {\n                p(\"return null;\").i(-1);\n            }\n            p(\"}\");\n            if (classStyle == Style.RAILS) {\n                p(JSON_OBJECT_CLASS + \" object = toObjectFromWrapper(value, \\\"\" + railsWrapperName + \"\\\");\");\n            } else if (typeInfo != null && typeInfo.include() == As.WRAPPER_ARRAY) {\n                p(JSON_ARRAY_CLASS + \" array = (\" + JSON_ARRAY_CLASS + \")value;\");\n                if (!isLeaf)\n                    p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(array.get(0));\");\n                p(JSON_OBJECT_CLASS + \" object = toObject(array.get(1));\");\n            } else {\n                p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            }\n\n            if (!isLeaf && typeInfo != null && typeInfo.include() == As.PROPERTY) {\n                p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \"));\");\n            }\n\n            for (Subtype possibleType : possibleTypes) {\n\n                if (!possibleType.clazz.isAssignableTo(classType)) {\n                    getLogger().log(DEBUG, \"Only assignable classes are allowed: \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" is not assignable to: \" + classType.getParameterizedQualifiedSourceName());\n                    continue;\n                }\n\n                if (typeInfo != null) {\n                    if (typeInfo.include() == As.WRAPPER_OBJECT) {\n                        if (!isLeaf) {\n                            p(\"if(object.containsKey(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        }\n                        p(\"object = toObjectFromWrapper(value, \\\"\" + possibleType.tag + \"\\\");\");\n                    } else if (!isLeaf) {\n                        if (classType.equals(possibleType.clazz)) {\n                            p(\"if(sourceName == null || sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        } else {\n                            p(\"if(sourceName != null && sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        }\n                    }\n                }\n\n                if (possibleType.clazz.isEnum() != null) {\n                    generateEnumDecodeMethodBody(possibleType.clazz);\n                } else {\n                    // Try to find a constuctor that is annotated as creator\n                    final JConstructor creator = findCreator(possibleType.clazz);\n\n                    List<JField> orderedFields = null;\n                    if (creator != null) {\n                        p(\"// We found a creator so we use the annotated constructor\");\n                        p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"(\");\n                        i(1).p(\"// The arguments are placed in the order they appear within the annotated constructor\").i(-1);\n                        orderedFields = getOrderedFields(getFields(possibleType.clazz), creator);\n                        final JField lastField = orderedFields.get(orderedFields.size() - 1);\n                        for (final JField field : orderedFields) {\n                            branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                                @Override\n                                public Void execute() throws UnableToCompleteException {\n                                    Json jsonAnnotation = getAnnotation(field, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    String jsonName = field.getName();\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                    String defaultValue = getDefaultValue(field);\n                                    i(1).p(\"\" + (objectGetter + \" == null || \" + objectGetter + \" instanceof \" + JSON_NULL_CLASS + \" ? \" + defaultValue + \" : \" + expression + ((field != lastField) ? \", \" : \"\"))).i(-1);\n\n                                    return null;\n                                }\n                            });\n                        }\n                        p(\");\");\n                    }\n\n                    if (orderedFields == null){\n                        p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"();\");\n                    }\n\n                    for (final JField field : getFields(possibleType.clazz)) {\n\n                        boolean ignoreField = false;\n                        if(getAnnotation(possibleType.clazz, JsonIgnoreProperties.class) != null) {\n                            for(String s : getAnnotation(possibleType.clazz, JsonIgnoreProperties.class).value()) {\n                                if(s.equals(field.getName())) {\n                                    ignoreField = true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(ignoreField) {\n                            continue;\n                        }\n\n                        if (orderedFields != null && orderedFields.contains(field)){\n                            continue;\n                        }\n\n                        final String setterName = getSetterName(field);\n\n                        // If can ignore some fields right off the back..\n                        if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient())\n\t\t\t\t\t\t\t\t|| field.isAnnotationPresent(JsonIgnore.class) || field.isAnnotationPresent(XmlTransient.class)) {\n                            continue;\n                        }\n\n                        branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                            @Override\n                            public Void execute() throws UnableToCompleteException {\n\n                                // TODO: try to set the field with a setter\n                                // or JSNI\n                                if (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                                    Json jsonAnnotation = getAnnotation(field, Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    JsonProperty jsonPropertyAnnotation = getAnnotation(field, JsonProperty.class);\n\n                                    String name = field.getName();\n                                    String jsonName = name;\n\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                                        jsonName = jsonPropertyAnnotation.value();\n                                    }\n\n                                    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                    boolean needNullHandling = !locator.hasCustomEncoderDecoder(field.getType());\n\n                                    String cast = field.getType().isPrimitive() == JPrimitiveType.SHORT ? \"(short) \" : \"\";\n\n                                    if (needNullHandling) {\n                                        p(\"if(\" + objectGetter + \" != null) {\").i(1);\n                                        p(\"if(\" + objectGetter + \" instanceof \" + JSON_NULL_CLASS + \") {\").i(1);\n                                        String defaultValue = getDefaultValue(field);\n\n                                        assignFieldValue(name, defaultValue, cast, setterName);\n                                        i(-1);\n                                        p(\"} else {\").i(1);\n                                    }\n\n                                    assignFieldValue(name, expression, cast, setterName);\n\n                                    if (needNullHandling) {\n                                        i(-1);\n                                        p(\"}\").i(-1);\n                                        p(\"}\");\n                                    }\n\n                                } else {\n                                    getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                                }\n                                return null;\n                            }\n                        });\n                    }\n\n                    p(\"return rc;\");\n                }\n                if (typeInfo != null && !isLeaf) {\n                    p(\"}\");\n                }\n            }\n\n            if (typeInfo != null && !isLeaf) {\n                p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n            p();\n        }\n    }\n\n    private void generateEnumDecodeMethodBody(JClassType classType) {\n        p(JSON_VALUE_CLASS + \" str = object.get(\\\"name\\\");\");\n        p(\"if( null == str || str.isString() == null ) {\").i(1);\n        {\n            p(\"throw new DecodingException(\\\"Expected a string field called 'name' for enum; not found\\\");\").i(-1);\n        }\n        p(\"}\");\n        decodeEnum(classType, \"str.isString().stringValue()\");\n    }\n\n    private String getDefaultValue(JField field) {\n        return field.getType().isPrimitive() == null ? \"null\" : field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n    }\n\n    private void assignFieldValue(String name, String expression, String cast, String setterName) {\n        if (setterName != null) {\n            p(\"rc.\" + setterName + \"(\" + cast + expression + \");\");\n        } else {\n            p(\"rc.\" + name + \"=\" + cast + expression + \";\");\n        }\n    }\n\n    protected void generateEnumDecodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + classType.getName() + \" decode(\" + jsonValueClass + \" value) {\").i(1);\n        {\n        p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n        {\n            p(\"return null;\").i(-1);\n        }\n        p(\"}\");\n        p(JSON_STRING_CLASS + \" str = value.isString();\");\n        p(\"if( null == str ) {\").i(1);\n        {\n            p(\"throw new DecodingException(\\\"Expected a json string (for enum), but was given: \\\"+value);\").i(-1);\n        }\n        p(\"}\");\n\n        String value = \"str.stringValue()\";\n        decodeEnum(classType, value);\n        }\n        p(\"}\");\n        p();\n    }\n\n    protected void decodeEnum(JClassType classType, String value) {\n        String className = classType.getParameterizedQualifiedSourceName();\n        String method = getValueMethod(classType);\n        if ( method == null ) {\n            p(\"return Enum.valueOf(\" + className + \".class, \" + value + \");\").i(-1);\n        }\n        else {\n            p(\"for(\" + className + \" v: \" + className + \".values()) {\").i(1);\n            {\n                p(\"if(v.\" + method + \"().equals(\" + value + \")) {\").i(1);\n                {\n                    p(\"return v;\").i(-1);\n                }\n                p(\"}\").i(-1);\n            }\n            p(\"}\");\n            p(\"throw new DecodingException(\\\"can not find enum for given value: \\\"+\" + value + \");\").i(-1);\n        }\n    }\n\n    static public void clearRestyResolverClassMap() {\n    \tsTypeIdResolverMap = null;\n    }\n    \n    public static Map<Class<?>, RestyJsonTypeIdResolver> getRestyResolverClassMap(GeneratorContext context, TreeLogger logger) throws UnableToCompleteException {\n\tif (sTypeIdResolverMap == null) {\n\t    try {\n\t\tMap<Class<?>, RestyJsonTypeIdResolver> map = Maps.newHashMap();\n\t\tList<String> values = context.getPropertyOracle().getConfigurationProperty(\"org.fusesource.restygwt.jsontypeidresolver\").getValues();\n\t\tfor (String value : values)\n\t\t    try {\n\t\t\tClass<?> clazz = Class.forName(value);\n\t\t\tRestyJsonTypeIdResolver resolver = (RestyJsonTypeIdResolver) clazz.newInstance();\n\t\t\tmap.put(resolver.getTypeIdResolverClass(), resolver);\n\t\t    } catch (Exception e) {\n\t\t\tlogger.log(WARN, \"Could not access class: \" + values.get(0), e);\n\t\t    }\n\t\t    sTypeIdResolverMap = map;\n\t    } catch (BadPropertyValueException e) {\n\t\tlogger.log(ERROR, \"Could not acccess property: RestyJsonTypeIdResolver\", e);\n\t\tthrow new UnableToCompleteException();\n\t    }\n\t}\n\treturn sTypeIdResolverMap;\n    }\n\n    private List<JField> getOrderedFields(List<JField> fields, JConstructor creator) throws UnableToCompleteException {\n\tList<JField> orderedFields = new ArrayList<JField>();\n\tfor (JParameter param : creator.getParameters()) {\n\t    JsonProperty prop = getAnnotation(param, JsonProperty.class);\n\t    if (prop != null) {\n\t\tfor (JField field : fields) {\n\t\t    if (field.getName().equals(prop.value())) {\n\t\t\torderedFields.add(field);\n\t\t    }\n\t\t}\n\t    } else {\n\t\tgetLogger().log(ERROR, \"a constructor annotated with @JsonCreator requires that all paramaters are annotated with @JsonProperty.\");\n        throw new UnableToCompleteException();\n\t    }\n\t}\n\n\treturn orderedFields;\n    }\n\n    private JConstructor findCreator(JClassType sourceClazz) {\n\tfor (JConstructor constructor : sourceClazz.getConstructors()) {\n\t    if (getAnnotation(constructor, JsonCreator.class) != null) {\n\t\treturn constructor;\n\t    }\n\t}\n\n\treturn null;\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the setter for the specified field or null if a\n     *         setter can't be found.\n     */\n    private String getSetterName(JField field) {\n\tString fieldName = field.getName();\n\tfieldName = \"set\" + upperCaseFirstChar(fieldName);\n\tJClassType type = field.getEnclosingType();\n\tif (exists(type, field, fieldName, true)) {\n\t    return fieldName;\n\t}\n    return null;\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the getter for the specified field or null if a\n     *         getter can't be found.\n     */\n    private String getGetterName(JField field) {\n\tString fieldName = field.getName();\n\tJType booleanType = null;\n\ttry {\n\t    booleanType = find(Boolean.class, getLogger(), context);\n\t} catch (UnableToCompleteException e) {\n\t    // do nothing\n\t}\n\tJClassType type = field.getEnclosingType();\n\tif (field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)) {\n\t    fieldName = \"is\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t    fieldName = \"has\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t}\n\tfieldName = \"get\" + upperCaseFirstChar(field.getName());\n\tif (exists(type, field, fieldName, false)) {\n\t    return fieldName;\n\t}\n    return null;\n    }\n\n    private String upperCaseFirstChar(String in) {\n\tif (in.length() == 1) {\n\t    return in.toUpperCase();\n\t}\n    return in.substring(0, 1).toUpperCase() + in.substring(1);\n    }\n\n    /**\n     * checks whether a getter or setter exists on the specified type or any of\n     * its super classes excluding Object. respects JsonIgnore accordingly.\n     *\n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {\n        if ( field instanceof DummyJField ){\n            return true;\n        }\n\n\tJType[] args = null;\n\tif (isSetter) {\n\t    args = new JType[] { field.getType() };\n\t} else {\n\t    args = new JType[] {};\n\t}\n\tJMethod m = type.findMethod(fieldName, args);\n\tif (null != m) {\n        if(getAnnotation(m, JsonIgnore.class) != null)\n\t\t\treturn false;\n\t\tif (getAnnotation(m, XmlTransient.class) != null)\n\t\t\treturn false;\n        if(isSetter)\n            return true;\n        JClassType returnType = m.getReturnType().isClassOrInterface();\n        JClassType fieldType = field.getType().isClassOrInterface();\n        if(returnType == null || fieldType == null) {\n            // at least one is a primitive type\n            return m.getReturnType().equals(field.getType());\n        }\n        // both are non-primitives\n        return returnType.isAssignableFrom(fieldType);\n\t}\n    try {\n    JType objectType = find(Object.class, getLogger(), context);\n    JClassType superType = type.getSuperclass();\n    if (!objectType.equals(superType)) {\n        return exists(superType, field, fieldName, isSetter);\n    }\n    } catch (UnableToCompleteException e) {\n    // do nothing\n    }\n\treturn false;\n    }\n\n    /**\n     * Inspects the supplied type and all super classes up to but excluding\n     * Object and returns a list of all fields found in these classes.\n     *\n     * @param type\n     * @return\n     */\n    private List<JField> getFields(JClassType type) {\n        List<JField> allFields = getFields(new ArrayList<JField>(), type);\n        Map<String, JMethod> getters = new HashMap<String, JMethod>();\n        Map<String, JType> setters = new HashMap<String, JType>();\n        for( JMethod m: type.getInheritableMethods() ){\n            if( m.getName().startsWith(\"set\") &&\n                    m.getParameterTypes().length == 1 &&\n                    m.getReturnType() == JPrimitiveType.VOID &&\n\t\t\t\t\tgetAnnotation(m, JsonIgnore.class) == null && \n\t\t\t\t\tgetAnnotation(m, XmlTransient.class) == null) {\n                setters.put( m.getName().replaceFirst(\"^set\", \"\"), m.getParameterTypes()[0] );\n            }\n            else if( m.getName().startsWith(\"get\") &&\n                    m.getParameterTypes().length == 0 &&\n                    m.getReturnType() != JPrimitiveType.VOID &&\n\t\t\t\t\tgetAnnotation(m, JsonIgnore.class) == null && \n\t\t\t\t\tgetAnnotation(m, XmlTransient.class) == null) {\n                getters.put( m.getName().replaceFirst(\"^get\", \"\"), m );\n            }\n        }\n        for( Map.Entry<String, JMethod> entry: getters.entrySet() ){\n            if ( setters.containsKey( entry.getKey() ) && setters.get( entry.getKey() ).equals( entry.getValue().getReturnType() ) ) {\n                String name = entry.getKey().substring(0, 1).toLowerCase() + entry.getKey().substring(1);\n                boolean found = false;\n                for( JField f : allFields ){\n                    if( f.getName().equals( name ) ){\n                        found = true;\n                        break;\n                    }\n                }\n                JField f = type.findField( name );\n                // is getter annotated, if yes use this annotation for the field\n                JsonProperty propName = null;\n                if ( entry.getValue().isAnnotationPresent(JsonProperty.class) ) {\n                    propName = getAnnotation(entry.getValue(), JsonProperty.class);\n                }\n                // is setter annotated, if yes use this annotation for the field\n                JMethod m = type.findMethod(\"s\" + entry.getValue().getName().substring(1),\n                        new JType[]{ entry.getValue().getReturnType() });\n                if ( m != null && m.isAnnotationPresent(JsonProperty.class) ) {\n                    propName = getAnnotation(m, JsonProperty.class);\n                }\n                // if have a field and an annotation from the getter/setter then use that annotation \n                if ( propName != null && found && !f.getName().equals(propName.value())) {\n                    allFields.remove(f);\n                    DummyJField dummy = new DummyJField( name, entry.getValue().getReturnType() );\n                    dummy.setAnnotation( propName );\n                    allFields.add(dummy);\n                }\n                if ( ! found && !( f != null && f.isAnnotationPresent( JsonIgnore.class ) ) ){\n                    DummyJField dummy = new DummyJField( name, entry.getValue().getReturnType() );\n                    if ( entry.getValue().isAnnotationPresent(JsonProperty.class) ) {\n                        dummy.setAnnotation( getAnnotation(entry.getValue(), JsonProperty.class) );\n                    }\n                    allFields.add( dummy );\n                }\n            }\n        }\n        return allFields;\n    }\n\n    private List<JField> getFields(List<JField> allFields, JClassType type) {\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n\t\t\tif (!field.isTransient() && !field.isAnnotationPresent(JsonIgnore.class) &&\n\t\t\t\t\t!field.isAnnotationPresent(XmlTransient.class)) {\n                allFields.add(field);\n            }\n        }\n        try {\n            JType objectType = find(Object.class, getLogger(), context);\n            if (!objectType.equals(type)) {\n                JClassType superType = type.getSuperclass();\n                return getFields(allFields, superType);\n            }\n        }\n        catch (UnableToCompleteException e) {\n\t    // do nothing\n        }\n\n    \treturn allFields;\n    }\n\n    public static String getTypeInfoPropertyValue(final JsonTypeInfo typeInfo)\n    {\n        if (typeInfo.include() == JsonTypeInfo.As.PROPERTY)\n            if(typeInfo.property() == null || \"\".equals(typeInfo.property()))\n                return typeInfo.use().getDefaultPropertyName();\n\n        return typeInfo.property();\n    }\n\n    public static boolean isLeaf(JClassType source)\n    {\n        return !(source.getSubtypes() != null && source.getSubtypes().length > 0);\n    }\n\n    public static class Subtype implements Comparable<Subtype> {\n    final String tag;\n    final JClassType clazz;\n\n    public Subtype(String tag, JClassType clazz) {\n        this.tag = tag;\n        this.clazz = clazz;\n    }\n\n    @Override\n    public int compareTo(Subtype o) {\n        return tag.compareTo(o.tag);\n    }\n    }\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> sTypeIdResolverMap = null;\n}\n","lineNo":548}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2011 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.fusesource.restygwt.rebind.util;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Method;\n\n/**\n * An utility class that gets a String representation of an annotation.\n *\n * @author <a href=\"mailto:bogdan.mustiata@gmail.com\">Bogdan Mustiata<\/a>\n */\npublic class AnnotationCopyUtil {\n    public static String getAnnotationAsString(Annotation annotation) {\n        StringBuilder result = encodeAnnotationName(annotation);\n\n        if (hasAnnotationAttributes(annotation)) {\n            encodeAnnotationAttributes(annotation, result);\n        }\n\n        return result.toString();\n    }\n\n    private static StringBuilder encodeAnnotationName(Annotation annotation) {\n        return new StringBuilder( \"@\" )\n                .append(annotation.annotationType().getCanonicalName());\n    }\n\n    private static boolean hasAnnotationAttributes(Annotation annotation) {\n        return annotation.annotationType().getDeclaredMethods().length != 0;\n    }\n\n    private static void encodeAnnotationAttributes(Annotation annotation, StringBuilder result) {\n        result.append(\"(\");\n\n        OnceFirstIterator<String> comma = new OnceFirstIterator<String>(\"\", \", \");\n        for (Method method : annotation.annotationType().getDeclaredMethods()) {\n            Object value = readAnnotationAttribute(annotation, method);\n\n            String encodedValue = encodeAnnotationValue(value);\n            if(encodedValue != null) {\n                result.append( comma.next() )\n                      .append( method.getName() )\n                      .append( \" = \" )\n                      .append( encodedValue );\n            }\n        }\n\n        result.append(\")\");\n    }\n\n    private static Object readAnnotationAttribute(Annotation annotation, Method annotationAttribute) {\n        try {\n            return annotationAttribute.invoke(annotation);\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Unable to read attribute \" + annotationAttribute + \" from \" + annotation, e);\n        }\n    }\n\n    /**\n     * Returns the string representation of {@code value} or {@code null}, if the element should not be added.\n     * \n     * @param value\n     * @return \n     * @throws IllegalArgumentException Wrong value type\n     */\n    private static String encodeAnnotationValue(Object value) {\n        // Values of annotation elements must not be \"null\"\n        if(null != value) {\n            if (value instanceof String) {\n                return readStringValue(value);\n            } else if (value instanceof Number) {\n                return readNumberValue(value);\n            } else if (value.getClass().isArray()) {\n                // workaround for ClassCastException: [Ljava.lang.Object; cannot be cast to [I\n                // ignore empty arrays, because it becomes Object[]\n                if(Array.getLength(value) > 0) {\n                    return readArrayValue(value);\n                }\n                return null;\n            } else if (value instanceof Annotation) {\n                return getAnnotationAsString((Annotation) value);\n            } else if (value instanceof Boolean) {\n                return readBooleanValue((Boolean) value);\n            } else if (value instanceof Class) {\n                return readClassValue((Class) value);\n            }\n        }\n\n        throw new IllegalArgumentException(\"Unsupported value for encodeAnnotationValue: \" + value);\n    }\n\n    private static String readBooleanValue(Boolean value) {\n        return Boolean.toString(value);\n    }\n\n    private static String readArrayValue(Object value) {\n        StringBuilder result = new StringBuilder();\n        OnceFirstIterator<String> comma = new OnceFirstIterator<String>(\"\", \", \");\n\n        result.append(\"{\");\n        for (int i = 0; i < Array.getLength(value); i++) {\n            Object arrayValue = Array.get(value, i);\n\n            result.append(comma.next())\n                  .append(encodeAnnotationValue(arrayValue));\n        }\n        result.append(\"}\");\n\n        return result.toString();\n    }\n\n    private static String readNumberValue(Object value) {\n        return value.toString();\n    }\n\n    private static String readStringValue(Object value) {\n        return \"\\\"\" + value.toString().replace(\"\\\"\", \"\\\\\\\"\").replace(\"\\n\", \"\\\\n\") + \"\\\"\";\n    }\n\n    private static String readClassValue(Class value) {\n        return value.getCanonicalName() + \".class\";\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2011 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.fusesource.restygwt.rebind.util;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Method;\n\n/**\n * An utility class that gets a String representation of an annotation.\n *\n * @author <a href=\"mailto:bogdan.mustiata@gmail.com\">Bogdan Mustiata<\/a>\n */\npublic class AnnotationCopyUtil {\n    public static String getAnnotationAsString(Annotation annotation) {\n        StringBuilder result = encodeAnnotationName(annotation);\n\n        if (hasAnnotationAttributes(annotation)) {\n            encodeAnnotationAttributes(annotation, result);\n        }\n\n        return result.toString();\n    }\n\n    private static StringBuilder encodeAnnotationName(Annotation annotation) {\n        return new StringBuilder( \"@\" )\n                .append(annotation.annotationType().getCanonicalName());\n    }\n\n    private static boolean hasAnnotationAttributes(Annotation annotation) {\n        return annotation.annotationType().getDeclaredMethods().length != 0;\n    }\n\n    private static void encodeAnnotationAttributes(Annotation annotation, StringBuilder result) {\n        result.append(\"(\");\n\n        OnceFirstIterator<String> comma = new OnceFirstIterator<String>(\"\", \", \");\n        for (Method method : annotation.annotationType().getDeclaredMethods()) {\n            Object value = readAnnotationAttribute(annotation, method);\n\n            result.append( comma.next() )\n                  .append(method.getName())\n                  .append( \" = \" )\n                  .append( encodeAnnotationValue(value) );\n        }\n\n        result.append(\")\");\n    }\n\n    private static Object readAnnotationAttribute(Annotation annotation, Method annotationAttribute) {\n        try {\n            return annotationAttribute.invoke(annotation);\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Unable to read attribute \" + annotationAttribute + \" from \" + annotation, e);\n        }\n    }\n\n    private static String encodeAnnotationValue(Object value) {\n        if (value instanceof String) {\n            return readStringValue(value);\n        } else if (value instanceof Number) {\n            return readNumberValue(value);\n        } else if (value == null) {\n            return \"null\";\n        } else if (value.getClass().isArray()) {\n            return readArrayValue(value);\n        } else if (value instanceof Annotation) {\n            return getAnnotationAsString((Annotation) value);\n        } else if (value instanceof Boolean) {\n            return readBooleanValue((Boolean) value);\n        } else if (value instanceof Class) {\n            return readClassValue((Class) value);\n        }\n\n        throw new RuntimeException(\"Unsupported value for encodeAnnotationValue: \" + value);\n    }\n\n    private static String readBooleanValue(Boolean value) {\n        return Boolean.toString(value);\n    }\n\n    private static String readArrayValue(Object value) {\n        StringBuilder result = new StringBuilder();\n        OnceFirstIterator<String> comma = new OnceFirstIterator<String>(\"\", \", \");\n\n        result.append(\"{\");\n        for (int i = 0; i < Array.getLength(value); i++) {\n            Object arrayValue = Array.get(value, i);\n\n            result.append(comma.next())\n                  .append(encodeAnnotationValue(arrayValue));\n        }\n        result.append(\"}\");\n\n        return result.toString();\n    }\n\n    private static String readNumberValue(Object value) {\n        return value.toString();\n    }\n\n    private static String readStringValue(Object value) {\n        return \"\\\"\" + value.toString().replace(\"\\\"\", \"\\\\\\\"\").replace(\"\\n\", \"\\\\n\") + \"\\\"\";\n    }\n\n    private static String readClassValue(Class value) {\n        return value.getCanonicalName() + \".class\";\n    }\n}\n","lineNo":56}
{"Refactored Sample":"package org.fusesource.restygwt.rebind;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport org.fusesource.restygwt.client.Dispatcher;\nimport org.fusesource.restygwt.client.MethodCallback;\nimport org.fusesource.restygwt.client.Resource;\nimport org.fusesource.restygwt.client.RestServiceProxy;\nimport org.fusesource.restygwt.client.callback.CallbackAware;\nimport org.fusesource.restygwt.rebind.util.OnceFirstIterator;\n\nimport static org.fusesource.restygwt.rebind.DirectRestServiceInterfaceClassCreator.DIRECT_REST_SERVICE_SUFFIX;\n\npublic class DirectRestServiceClassCreator extends DirectRestBaseSourceCreator {\n    public static final String DIRECT_REST_IMPL_SUFFIX = DIRECT_REST_SERVICE_SUFFIX + \"Impl\";\n    public static final String VOID_QUALIFIED_NAME = \"void\";\n\n    public DirectRestServiceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, DIRECT_REST_IMPL_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() throws UnableToCompleteException {\n        return createClassSourceComposerFactory(JavaSourceCategory.CLASS,\n                null,\n                new String[]{\n                        source.getParameterizedQualifiedSourceName(),\n                        CallbackAware.class.getCanonicalName(),\n                        RestServiceProxy.class.getCanonicalName()\n                }\n        );\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n        createRestyServiceField();\n        createDelegateRestServiceProxyMethods();\n        createCallbackSupportMethodsAndField();\n        createServiceMethods();\n    }\n\n    private void createRestyServiceField() {\n        String sourceName = getName(source) + DIRECT_REST_SERVICE_SUFFIX;\n        p(\"private \" + sourceName + \" service = com.google.gwt.core.client.GWT.create(\" + sourceName + \".class);\");\n    }\n\n    private void createDelegateRestServiceProxyMethods() {\n        String resourceClass = Resource.class.getCanonicalName();\n        String dispatcherClass = Dispatcher.class.getCanonicalName();\n        String restServiceProxyClass = RestServiceProxy.class.getCanonicalName();\n\n        p(\"public final void setResource(\" + resourceClass + \" resource) {\").i(1)\n            .p(\"((\" + restServiceProxyClass + \")service).setResource(resource);\").i(-1)\n        .p(\"}\");\n\n        p(\"public final \" + resourceClass + \" getResource() {\").i(1)\n            .p(\"return ((\" + restServiceProxyClass + \")service).getResource();\").i(-1)\n        .p(\"}\");\n\n        p(\"public final void setDispatcher(\" + dispatcherClass + \" resource) {\").i(1)\n            .p(\"((\" + restServiceProxyClass + \")service).setDispatcher(resource);\").i(-1)\n        .p(\"}\");\n\n        p(\"public final \" + dispatcherClass + \" getDispatcher() {\").i(1)\n            .p(\"return ((\" + restServiceProxyClass + \")service).getDispatcher();\").i(-1)\n        .p(\"}\");\n    }\n\n    private void createCallbackSupportMethodsAndField() {\n        createCallbackField();\n        createCallbackSetter();\n        createVerifyCallbackMethod();\n    }\n\n    private void createServiceMethods() {\n        for (JMethod method : source.getInheritableMethods()) {\n            generateMethod(method);\n        }\n    }\n\n    private void generateMethod(JMethod method) {\n        p( getMethodDeclaration(method) + \" {\").i(1);\n            generateCallVerifyCallback(method);\n            generateCallServiceMethod(method);\n            generateReturnNull(method);\n        i(-1).p(\"}\");\n    }\n\n    private String getMethodDeclaration(JMethod method) {\n        return method.getReadableDeclaration(false, true, false, false, true);\n    }\n\n    private void generateCallVerifyCallback(JMethod method) {\n        p(\"verifyCallback(\\\"\" + method.getName() + \"\\\");\");\n    }\n\n    private void generateCallServiceMethod(JMethod method) {\n        StringBuilder stringBuilder = new StringBuilder();\n        OnceFirstIterator<String> comma = new OnceFirstIterator<String>(\"\", \", \");\n\n        stringBuilder.append(\"service.\")\n                .append(method.getName())\n                .append(\"(\");\n\n        for (JParameter parameter : method.getParameters()) {\n            stringBuilder.append(comma.next())\n                    .append(parameter.getName());\n        }\n\n        stringBuilder.append(comma.next())\n                .append(\"this.callback\");\n\n        stringBuilder.append(\");\");\n\n        p(stringBuilder.toString());\n    }\n\n    private void generateReturnNull(JMethod method) {\n        // FIXME: check for primitives, void.\n        if (!isVoidMethod(method)) {\n            p(\"return null;\");\n        }\n    }\n\n    public static boolean isVoidMethod(JMethod method) {\n        return VOID_QUALIFIED_NAME.equals(method.getReturnType().getQualifiedBinaryName());\n    }\n\n    private void createCallbackField() {\n        p(\"private \" + MethodCallback.class.getCanonicalName() + \" callback;\");\n    }\n    private void createCallbackSetter() {\n        p( \"public void setCallback(\" + MethodCallback.class.getCanonicalName() + \" callback) {\").i(1)\n            .p(\"this.callback = callback;\").i(-1)\n        .p(\"}\");\n    }\n\n    private void createVerifyCallbackMethod() {\n        p( \"public void verifyCallback(String methodName) {\").i(1)\n           .p(\"if (this.callback == null) {\").i(1)\n               .p(\"throw new IllegalArgumentException(\" +\n                       \"\\\"You need to call this service with REST.withCallback(new MethodCallback<..>(){..}).call(service).\\\" + \" +\n                       \"methodName + \" +\n                       \"\\\"(..) and not try to access the service directly\\\");\").i(-1)\n           .p(\"}\").i(-1)\n        .p(\"}\");\n    }\n\n}\n","Smelly Sample":"package org.fusesource.restygwt.rebind;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport org.fusesource.restygwt.client.Dispatcher;\nimport org.fusesource.restygwt.client.MethodCallback;\nimport org.fusesource.restygwt.client.Resource;\nimport org.fusesource.restygwt.client.RestServiceProxy;\nimport org.fusesource.restygwt.client.callback.CallbackAware;\nimport org.fusesource.restygwt.rebind.util.OnceFirstIterator;\n\nimport static org.fusesource.restygwt.rebind.DirectRestServiceInterfaceClassCreator.DIRECT_REST_SERVICE_SUFFIX;\n\npublic class DirectRestServiceClassCreator extends DirectRestBaseSourceCreator {\n    public static final String DIRECT_REST_IMPL_SUFFIX = DIRECT_REST_SERVICE_SUFFIX + \"Impl\";\n    public static final String VOID_QUALIFIED_NAME = \"void\";\n\n    public DirectRestServiceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, DIRECT_REST_IMPL_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() throws UnableToCompleteException {\n        return createClassSourceComposerFactory(JavaSourceCategory.CLASS,\n                null,\n                new String[]{\n                        source.getParameterizedQualifiedSourceName(),\n                        CallbackAware.class.getCanonicalName(),\n                        RestServiceProxy.class.getCanonicalName()\n                }\n        );\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n        createRestyServiceField();\n        createDelegateRestServiceProxyMethods();\n        createCallbackSupportMethodsAndField();\n        createServiceMethods();\n    }\n\n    private void createRestyServiceField() {\n        p(\"private \" + source.getName() + DIRECT_REST_SERVICE_SUFFIX + \" service = com.google.gwt.core.client.GWT.create(\" +\n                source.getName() + DIRECT_REST_SERVICE_SUFFIX + \".class);\");\n    }\n\n    private void createDelegateRestServiceProxyMethods() {\n        String resourceClass = Resource.class.getCanonicalName();\n        String dispatcherClass = Dispatcher.class.getCanonicalName();\n        String restServiceProxyClass = RestServiceProxy.class.getCanonicalName();\n\n        p(\"public final void setResource(\" + resourceClass + \" resource) {\").i(1)\n            .p(\"((\" + restServiceProxyClass + \")service).setResource(resource);\").i(-1)\n        .p(\"}\");\n\n        p(\"public final \" + resourceClass + \" getResource() {\").i(1)\n            .p(\"return ((\" + restServiceProxyClass + \")service).getResource();\").i(-1)\n        .p(\"}\");\n\n        p(\"public final void setDispatcher(\" + dispatcherClass + \" resource) {\").i(1)\n            .p(\"((\" + restServiceProxyClass + \")service).setDispatcher(resource);\").i(-1)\n        .p(\"}\");\n\n        p(\"public final \" + dispatcherClass + \" getDispatcher() {\").i(1)\n            .p(\"return ((\" + restServiceProxyClass + \")service).getDispatcher();\").i(-1)\n        .p(\"}\");\n    }\n\n    private void createCallbackSupportMethodsAndField() {\n        createCallbackField();\n        createCallbackSetter();\n        createVerifyCallbackMethod();\n    }\n\n    private void createServiceMethods() {\n        for (JMethod method : source.getInheritableMethods()) {\n            generateMethod(method);\n        }\n    }\n\n    private void generateMethod(JMethod method) {\n        p( getMethodDeclaration(method) + \" {\").i(1);\n            generateCallVerifyCallback(method);\n            generateCallServiceMethod(method);\n            generateReturnNull(method);\n        i(-1).p(\"}\");\n    }\n\n    private String getMethodDeclaration(JMethod method) {\n        return method.getReadableDeclaration(false, true, false, false, true);\n    }\n\n    private void generateCallVerifyCallback(JMethod method) {\n        p(\"verifyCallback(\\\"\" + method.getName() + \"\\\");\");\n    }\n\n    private void generateCallServiceMethod(JMethod method) {\n        StringBuilder stringBuilder = new StringBuilder();\n        OnceFirstIterator<String> comma = new OnceFirstIterator<String>(\"\", \", \");\n\n        stringBuilder.append(\"service.\")\n                .append(method.getName())\n                .append(\"(\");\n\n        for (JParameter parameter : method.getParameters()) {\n            stringBuilder.append(comma.next())\n                    .append(parameter.getName());\n        }\n\n        stringBuilder.append(comma.next())\n                .append(\"this.callback\");\n\n        stringBuilder.append(\");\");\n\n        p(stringBuilder.toString());\n    }\n\n    private void generateReturnNull(JMethod method) {\n        // FIXME: check for primitives, void.\n        if (!isVoidMethod(method)) {\n            p(\"return null;\");\n        }\n    }\n\n    public static boolean isVoidMethod(JMethod method) {\n        return VOID_QUALIFIED_NAME.equals(method.getReturnType().getQualifiedBinaryName());\n    }\n\n    private void createCallbackField() {\n        p(\"private \" + MethodCallback.class.getCanonicalName() + \" callback;\");\n    }\n    private void createCallbackSetter() {\n        p( \"public void setCallback(\" + MethodCallback.class.getCanonicalName() + \" callback) {\").i(1)\n            .p(\"this.callback = callback;\").i(-1)\n        .p(\"}\");\n    }\n\n    private void createVerifyCallbackMethod() {\n        p( \"public void verifyCallback(String methodName) {\").i(1)\n           .p(\"if (this.callback == null) {\").i(1)\n               .p(\"throw new IllegalArgumentException(\" +\n                       \"\\\"You need to call this service with REST.withCallback(new MethodCallback<..>(){..}).call(service).\\\" + \" +\n                       \"methodName + \" +\n                       \"\\\"(..) and not try to access the service directly\\\");\").i(-1)\n           .p(\"}\").i(-1)\n        .p(\"}\");\n    }\n\n}\n","lineNo":48}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.codehaus.jackson.annotate.JsonCreator;\nimport org.codehaus.jackson.annotate.JsonIgnore;\nimport org.codehaus.jackson.annotate.JsonIgnoreProperties;\nimport org.codehaus.jackson.annotate.JsonProperty;\nimport org.codehaus.jackson.annotate.JsonSubTypes;\nimport org.codehaus.jackson.annotate.JsonSubTypes.Type;\nimport org.codehaus.jackson.annotate.JsonTypeInfo;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.As;\nimport org.codehaus.jackson.annotate.JsonValue;\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JConstructor;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONNull;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONString;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.thirdparty.guava.common.collect.Lists;\nimport com.google.gwt.thirdparty.guava.common.collect.Maps;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added getter & setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n *\n *         added polymorphic support\n * @author <a href=\"http://charliemason.info\">Charlie Mason<\/a>\n *\n */\n\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n    protected static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_NULL_CLASS = JSONNull.class.getName();\n    protected static final String JSON_STRING_CLASS = JSONString.class.getName();\n\n    protected JsonEncoderDecoderInstanceLocator locator;\n\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    @Override\n    public void generate() throws UnableToCompleteException {\n        final JsonTypeInfo typeInfo = findAnnotation(source, JsonTypeInfo.class);\n        final boolean isLeaf = isLeaf(source);\n\n        final List<Subtype> possibleTypes = getPossibleTypes(typeInfo, isLeaf);\n\n        final JClassType sourceClazz = source.isClass() == null ? source.isInterface() : source.isClass();\n        if (sourceClazz == null) {\n            getLogger().log(ERROR, \"Type is not a class\");\n            throw new UnableToCompleteException();\n        }\n\n        if (sourceClazz.isAbstract()) {\n            if (typeInfo == null) {\n                getLogger().log(ERROR, \"Abstract classes must be annotated with JsonTypeInfo\");\n                throw new UnableToCompleteException();\n            }\n        }\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n        final String railsWrapperName = jsonAnnotation != null && jsonAnnotation.name().length() > 0 ? jsonAnnotation.name() : sourceClazz.getName().toLowerCase();\n        locator = new JsonEncoderDecoderInstanceLocator(context, getLogger());\n\n        generateSingleton(shortName);\n\n        generateEncodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n\n        generateDecodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n\tClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n\tcomposerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n\treturn composerFactory;\n    }\n\n    public static <T extends Annotation> T findAnnotation(JClassType clazz, Class<T> annotation) {\n\tif (clazz == null)\n\t    return null;\n\telse if (clazz.isAnnotationPresent(annotation))\n\t    return clazz.getAnnotation(annotation);\n\telse\n\t    return findAnnotation(clazz.getSuperclass(), annotation);\n    }\n\n    private List<Subtype> getPossibleTypes(final JsonTypeInfo typeInfo, final boolean isLeaf) throws UnableToCompleteException\n    {\n        if (typeInfo == null)\n            return Lists.newArrayList(new Subtype(null, source));\n        Collection<Type> subTypes = findJsonSubTypes(source);\n        if(subTypes.isEmpty()) {\n            JsonSubTypes foundAnnotation = findAnnotation(source, JsonSubTypes.class);\n            if(foundAnnotation != null) {\n                Type[] value = foundAnnotation.value();\n                subTypes = Arrays.asList(value);\n            }\n        }\n        PossibleTypesVisitor v = new PossibleTypesVisitor(context, source, isLeaf, getLogger(), subTypes);\n        return v.visit(typeInfo.use());\n    }\n\n    private Collection<Type> findJsonSubTypes(JClassType clazz) {\n        if (clazz == null)\n            return Collections.emptyList();\n        else if (clazz.isAnnotationPresent(JsonSubTypes.class)) {\n            JsonSubTypes annotation = clazz.getAnnotation(JsonSubTypes.class);\n            Set<Type> result = new HashSet<JsonSubTypes.Type>();\n            Type[] value = annotation.value();\n            for (Type type : value) {\n                result.add(type);\n                Class<?> subclazz = type.value();\n                String newSubClassName = subclazz.getName().replaceAll(\"\\\\$\", \".\");\n                JClassType subJClazz = context.getTypeOracle().findType(newSubClassName);\n                if(!isSame(clazz, subclazz)) {\n                    result.addAll(findJsonSubTypes(subJClazz));\n                }\n            }\n            return result;\n        } else\n            return Collections.emptyList();\n        }\n\n    private boolean isSame(JClassType clazz, Class<?> subclazz) {\n        return (clazz.getPackage().getName()+\".\"+clazz.getName()).equals(subclazz.getName());\n    }\n\n    protected void generateSingleton(String shortName)\n    {\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n    }\n\n    private void generateEncodeMethod(JClassType classType,\n            final Style classStyle,\n            JsonTypeInfo typeInfo,\n            String railsWrapperName,\n            List<Subtype> possibleTypes,\n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {\n            generateEnumEncodeMethod(classType, JSON_VALUE_CLASS);\n            return;\n        }\n\n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n\n            boolean returnWrapper = false; // if set, return rrc\n\n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n            if (classStyle == Style.RAILS) {\n                returnWrapper = true;\n                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                p(\"rrc.put(\\\"\" + railsWrapperName + \"\\\" , rc);\");\n            }\n\n            for (Subtype possibleType : possibleTypes) {\n\n                if (!possibleType.clazz.isAssignableTo(classType)) {\n                    getLogger().log(DEBUG, \"Only assignable classes are allowed: \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" is not assignable to: \" + classType.getParameterizedQualifiedSourceName());\n                    continue;\n                }\n\n                if (!isLeaf) {\n                    // Generate a decoder for each possible type\n                    p(\"if(value.getClass().getName().equals(\\\"\" + possibleType.clazz.getQualifiedBinaryName() + \"\\\"))\");\n                    p(\"{\");\n                }\n\n                if (possibleType.clazz.isEnum() != null) {\n                    generateEnumEncodeMethodBody(possibleType, typeInfo);\n                } else {\n\n                    // Try to find a constuctor that is annotated as creator\n                    final JConstructor creator = findCreator(possibleType.clazz);\n\n                    List<JField> orderedFields = creator == null ? null : getOrderedFields(getFields(possibleType.clazz), creator);\n\n                    if (typeInfo != null) {\n                        switch (typeInfo.include()) {\n                            case PROPERTY:\n                                p(\"com.google.gwt.json.client.JSONValue className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\");\");\n                                p(\"if( className!=null ) { \").i(1);\n                                p(\"rc.put(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \", className);\");\n                                i(-1).p(\"}\");\n                                break;\n                            case WRAPPER_OBJECT:\n                                returnWrapper = true;\n                                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                                p(\"rrc.put(\\\"\" + possibleType.tag + \"\\\", rc);\");\n                                break;\n                            case WRAPPER_ARRAY:\n                                returnWrapper = true;\n                                p(JSON_ARRAY_CLASS + \" rrc = new \" + JSON_ARRAY_CLASS + \"();\");\n                                p(\"rrc.set(0, org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\"));\");\n                                p(\"rrc.set(1, rc);\");\n                        }\n                    }\n\n                    p(possibleType.clazz.getParameterizedQualifiedSourceName() + \" parseValue = (\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \")value;\");\n\n                    for (final JField field : getFields(possibleType.clazz)) {\n\n                        final String getterName = getGetterName(field);\n\n                        boolean ignoreField = false;\n                        if(possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null) {\n                            for(String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value()) {\n                                if(s.equals(field.getName())) {\n                                    ignoreField = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        // If can ignore some fields right off the back..\n                        // if there is a creator encode only final fields with JsonProperty annotation\n                        if (ignoreField || getterName == null && (field.isStatic() || (field.isFinal() && !(creator != null && orderedFields.contains(field))) || field.isTransient()\n                                || field.isAnnotationPresent(JsonIgnore.class))) {\n                            continue;\n                        }\n\n                        branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                            @Override\n                            public Void execute() throws UnableToCompleteException {\n                                // TODO: try to get the field with a setter or\n                                // JSNI\n                                if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                                    Json jsonAnnotation = field.getAnnotation(Json.class);\n                                    JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n\n                                    String name = field.getName();\n                                    String jsonName = name;\n\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                                        jsonName = jsonPropertyAnnotation.value();\n                                    }\n\n                                    String fieldExpr = \"parseValue.\" + name;\n                                    if (getterName != null) {\n                                        fieldExpr = \"parseValue.\" + getterName + \"()\";\n                                    }\n\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    String expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n\n                                    p(\"{\").i(1);\n                                    {\n                                        if (null != field.getType().isEnum()) {\n                                            p(\"if(\" + fieldExpr + \" == null) {\").i(1);\n                                            p(\"rc.put(\" + wrap(jsonName) + \", \" + JSON_NULL_CLASS + \".getInstance());\");\n                                            i(-1).p(\"} else {\").i(1);\n                                        }\n\n                                        p(JSON_VALUE_CLASS + \" v=\" + expression + \";\");\n                                        p(\"if( v!=null ) {\").i(1);\n                                        {\n                                            p(\"rc.put(\" + wrap(jsonName) + \", v);\");\n                                        }\n                                        i(-1).p(\"}\");\n\n                                        if (null != field.getType().isEnum()) {\n                                            i(-1).p(\"}\");\n                                        }\n\n                                    }\n                                    i(-1).p(\"}\");\n\n                                } else {\n                                    getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                                }\n                                return null;\n                            }\n                        });\n\n                    }\n\n                    if (returnWrapper) {\n                        p(\"return rrc;\");\n                    } else {\n                        p(\"return rc;\");\n                    }\n                }\n                if (!isLeaf) {\n                    p(\"}\");\n                }\n            }\n\n            if (!isLeaf) {\n                // Shouldn't get called\n                p(\"return null;\");\n            }\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n\n    private void generateEnumEncodeMethodBody(final Subtype possibleType, final JsonTypeInfo typeInfo) {\n        p(\"if( value==null ) {\").i(1);\n        {\n            p(\"return \" + JSON_NULL_CLASS + \".getInstance();\").i(-1);\n        }\n        p(\"}\");\n        p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n        p(JSON_VALUE_CLASS + \" className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\"\n                + possibleType.tag + \"\\\");\");\n        p(\"rrc.put(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \", className);\");\n        p(\"rrc.put(\\\"name\\\", new \" + JSON_STRING_CLASS + \"(value.\" + getValueMethod(possibleType.clazz) + \"()));\");\n        p(\"return rrc;\");\n    }\n\n    private void generateEnumEncodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + jsonValueClass + \" encode(\" + classType.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return \" + JSON_NULL_CLASS + \".getInstance();\").i(-1);\n            }\n            p(\"}\");\n            p(\"return new \" + JSON_STRING_CLASS + \"(value.\" + getValueMethod(classType) + \"());\");\n            i(-1).p(\"}\");\n        }\n        p();\n    }\n\n    protected String getValueMethod(JClassType classType) {\n        String method = \"name\";\n        for(JMethod jm : classType.isEnum().getMethods() ) {\n            if (jm.isAnnotationPresent(JsonValue.class)) {\n                method = jm.getName();\n                break;\n            }\n        }\n        return method;\n    }\n\n    private void generateDecodeMethod(JClassType classType,\n            final Style classStyle,\n            JsonTypeInfo typeInfo,\n            String railsWrapperName,\n            List<Subtype> possibleTypes,\n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {\n            generateEnumDecodeMethod(classType, JSON_VALUE_CLASS);\n            return;\n        }\n\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n            {\n                p(\"return null;\").i(-1);\n            }\n            p(\"}\");\n            if (classStyle == Style.RAILS) {\n                p(JSON_OBJECT_CLASS + \" object = toObjectFromWrapper(value, \\\"\" + railsWrapperName + \"\\\");\");\n            } else if (typeInfo != null && typeInfo.include() == As.WRAPPER_ARRAY) {\n                p(JSON_ARRAY_CLASS + \" array = (\" + JSON_ARRAY_CLASS + \")value;\");\n                if (!isLeaf)\n                    p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(array.get(0));\");\n                p(JSON_OBJECT_CLASS + \" object = toObject(array.get(1));\");\n            } else {\n                p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            }\n\n            if (!isLeaf && typeInfo != null && typeInfo.include() == As.PROPERTY) {\n                p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \"));\");\n            }\n\n            for (Subtype possibleType : possibleTypes) {\n\n                if (!possibleType.clazz.isAssignableTo(classType)) {\n                    getLogger().log(DEBUG, \"Only assignable classes are allowed: \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" is not assignable to: \" + classType.getParameterizedQualifiedSourceName());\n                    continue;\n                }\n\n                if (typeInfo != null) {\n                    if (typeInfo.include() == As.WRAPPER_OBJECT) {\n                        if (!isLeaf) {\n                            p(\"if(object.containsKey(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        }\n                        p(\"object = toObjectFromWrapper(value, \\\"\" + possibleType.tag + \"\\\");\");\n                    } else if (!isLeaf) {\n                        p(\"if(sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n                        p(\"{\");\n                    }\n                }\n\n                if (possibleType.clazz.isEnum() != null) {\n                    generateEnumDecodeMethodBody(possibleType.clazz);\n                } else {\n                    // Try to find a constuctor that is annotated as creator\n                    final JConstructor creator = findCreator(possibleType.clazz);\n\n                    List<JField> orderedFields = null;\n                    if (creator != null) {\n                        p(\"// We found a creator so we use the annotated constructor\");\n                        p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"(\");\n                        i(1).p(\"// The arguments are placed in the order they appear within the annotated constructor\").i(-1);\n                        orderedFields = getOrderedFields(getFields(possibleType.clazz), creator);\n                        final JField lastField = orderedFields.get(orderedFields.size() - 1);\n                        for (final JField field : orderedFields) {\n                            branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                                @Override\n                                public Void execute() throws UnableToCompleteException {\n                                    Json jsonAnnotation = field.getAnnotation(Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    String jsonName = field.getName();\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                    String defaultValue = getDefaultValue(field);\n                                    i(1).p(\"\" + (objectGetter + \" == null || \" + objectGetter + \" instanceof \" + JSON_NULL_CLASS + \" ? \" + defaultValue + \" : \" + expression + ((field != lastField) ? \", \" : \"\"))).i(-1);\n\n                                    return null;\n                                }\n                            });\n                        }\n                        p(\");\");\n                    }\n\n                    if (orderedFields == null){\n                        p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"();\");\n                    }\n\n                    for (final JField field : getFields(possibleType.clazz)) {\n\n                        boolean ignoreField = false;\n                        if(possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null) {\n                            for(String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value()) {\n                                if(s.equals(field.getName())) {\n                                    ignoreField = true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(ignoreField) {\n                            continue;\n                        }\n\n                        if (orderedFields != null && orderedFields.contains(field)){\n                            continue;\n                        }\n\n                        final String setterName = getSetterName(field);\n\n                        // If can ignore some fields right off the back..\n                        if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient()) ||\n                                field.isAnnotationPresent(JsonIgnore.class)) {\n                            continue;\n                        }\n\n                        branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                            @Override\n                            public Void execute() throws UnableToCompleteException {\n\n                                // TODO: try to set the field with a setter\n                                // or JSNI\n                                if (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                                    Json jsonAnnotation = field.getAnnotation(Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n\n                                    String name = field.getName();\n                                    String jsonName = name;\n\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                                        jsonName = jsonPropertyAnnotation.value();\n                                    }\n\n                                    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                    boolean needNullHandling = !locator.hasCustomEncoderDecoder(field.getType());\n\n                                    String cast = field.getType().isPrimitive() == JPrimitiveType.SHORT ? \"(short) \" : \"\";\n\n                                    if (needNullHandling) {\n                                        p(\"if(\" + objectGetter + \" != null) {\").i(1);\n                                        p(\"if(\" + objectGetter + \" instanceof \" + JSON_NULL_CLASS + \") {\").i(1);\n                                        String defaultValue = getDefaultValue(field);\n\n                                        assignFieldValue(name, defaultValue, cast, setterName);\n                                        i(-1);\n                                        p(\"} else {\").i(1);\n                                    }\n\n                                    assignFieldValue(name, expression, cast, setterName);\n\n                                    if (needNullHandling) {\n                                        i(-1);\n                                        p(\"}\").i(-1);\n                                        p(\"}\");\n                                    }\n\n                                } else {\n                                    getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                                }\n                                return null;\n                            }\n                        });\n                    }\n\n                    p(\"return rc;\");\n                }\n                if (typeInfo != null && !isLeaf) {\n                    p(\"}\");\n                }\n            }\n\n            if (typeInfo != null && !isLeaf) {\n                p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n            p();\n        }\n    }\n\n    private void generateEnumDecodeMethodBody(JClassType classType) {\n        p(JSON_VALUE_CLASS + \" str = object.get(\\\"name\\\");\");\n        p(\"if( null == str || str.isString() == null ) {\").i(1);\n        {\n            p(\"throw new DecodingException(\\\"Expected a string field called 'name' for enum; not found\\\");\").i(-1);\n        }\n        p(\"}\");\n        decodeEnum(classType, \"str.isString().stringValue()\");\n    }\n\n    private String getDefaultValue(JField field) {\n        return field.getType().isPrimitive() == null ? \"null\" : field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n    }\n\n    private void assignFieldValue(String name, String expression, String cast, String setterName) {\n        if (setterName != null) {\n            p(\"rc.\" + setterName + \"(\" + cast + expression + \");\");\n        } else {\n            p(\"rc.\" + name + \"=\" + cast + expression + \";\");\n        }\n    }\n\n    protected void generateEnumDecodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + classType.getName() + \" decode(\" + jsonValueClass + \" value) {\").i(1);\n        {\n        p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n        {\n            p(\"return null;\").i(-1);\n        }\n        p(\"}\");\n        p(JSON_STRING_CLASS + \" str = value.isString();\");\n        p(\"if( null == str ) {\").i(1);\n        {\n            p(\"throw new DecodingException(\\\"Expected a json string (for enum), but was given: \\\"+value);\").i(-1);\n        }\n        p(\"}\");\n\n        String value = \"str.stringValue()\";\n        decodeEnum(classType, value);\n        }\n        p(\"}\");\n        p();\n    }\n\n    protected void decodeEnum(JClassType classType, String value) {\n        String className = classType.getParameterizedQualifiedSourceName();\n        String method = getValueMethod(classType);\n        if ( method == null ) {\n            p(\"return Enum.valueOf(\" + className + \".class, \" + value + \");\").i(-1);\n        }\n        else {\n            p(\"for(\" + className + \" v: \" + className + \".values()) {\").i(1);\n            {\n                p(\"if(v.\" + method + \"().equals(\" + value + \")) {\").i(1);\n                {\n                    p(\"return v;\").i(-1);\n                }\n                p(\"}\").i(-1);\n            }\n            p(\"}\");\n            p(\"throw new DecodingException(\\\"can not find enum for given value: \\\"+\" + value + \");\").i(-1);\n        }\n    }\n\n    public static Map<Class<?>, RestyJsonTypeIdResolver> getRestyResolverClassMap(GeneratorContext context, TreeLogger logger) throws UnableToCompleteException {\n\tif (sTypeIdResolverMap == null) {\n\t    try {\n\t\tMap<Class<?>, RestyJsonTypeIdResolver> map = Maps.newHashMap();\n\t\tList<String> values = context.getPropertyOracle().getConfigurationProperty(\"org.fusesource.restygwt.jsontypeidresolver\").getValues();\n\t\tfor (String value : values)\n\t\t    try {\n\t\t\tClass<?> clazz = Class.forName(value);\n\t\t\tRestyJsonTypeIdResolver resolver = (RestyJsonTypeIdResolver) clazz.newInstance();\n\t\t\tmap.put(resolver.getTypeIdResolverClass(), resolver);\n\t\t    } catch (Exception e) {\n\t\t\tlogger.log(WARN, \"Could not access class: \" + values.get(0), e);\n\t\t    }\n\t\t    sTypeIdResolverMap = map;\n\t    } catch (BadPropertyValueException e) {\n\t\tlogger.log(ERROR, \"Could not acccess property: RestyJsonTypeIdResolver\", e);\n\t\tthrow new UnableToCompleteException();\n\t    }\n\t}\n\treturn sTypeIdResolverMap;\n    }\n\n    private List<JField> getOrderedFields(List<JField> fields, JConstructor creator) throws UnableToCompleteException {\n\tList<JField> orderedFields = new ArrayList<JField>();\n\tfor (JParameter param : creator.getParameters()) {\n\t    JsonProperty prop = param.getAnnotation(JsonProperty.class);\n\t    if (prop != null) {\n\t\tfor (JField field : fields) {\n\t\t    if (field.getName().equals(prop.value())) {\n\t\t\torderedFields.add(field);\n\t\t    }\n\t\t}\n\t    } else {\n\t\tgetLogger().log(ERROR, \"a constructor annotated with @JsonCreator requires that all paramaters are annotated with @JsonProperty.\");\n        throw new UnableToCompleteException();\n\t    }\n\t}\n\n\treturn orderedFields;\n    }\n\n    private JConstructor findCreator(JClassType sourceClazz) {\n\tfor (JConstructor constructor : sourceClazz.getConstructors()) {\n\t    if (constructor.getAnnotation(JsonCreator.class) != null) {\n\t\treturn constructor;\n\t    }\n\t}\n\n\treturn null;\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the setter for the specified field or null if a\n     *         setter can't be found.\n     */\n    private String getSetterName(JField field) {\n\tString fieldName = field.getName();\n\tfieldName = \"set\" + upperCaseFirstChar(fieldName);\n\tJClassType type = field.getEnclosingType();\n\tif (exists(type, field, fieldName, true)) {\n\t    return fieldName;\n\t}\n    return null;\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the getter for the specified field or null if a\n     *         getter can't be found.\n     */\n    private String getGetterName(JField field) {\n\tString fieldName = field.getName();\n\tJType booleanType = null;\n\ttry {\n\t    booleanType = find(Boolean.class, getLogger(), context);\n\t} catch (UnableToCompleteException e) {\n\t    // do nothing\n\t}\n\tJClassType type = field.getEnclosingType();\n\tif (field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)) {\n\t    fieldName = \"is\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t    fieldName = \"has\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t}\n\tfieldName = \"get\" + upperCaseFirstChar(field.getName());\n\tif (exists(type, field, fieldName, false)) {\n\t    return fieldName;\n\t}\n    return null;\n    }\n\n    private String upperCaseFirstChar(String in) {\n\tif (in.length() == 1) {\n\t    return in.toUpperCase();\n\t}\n    return in.substring(0, 1).toUpperCase() + in.substring(1);\n    }\n\n    /**\n     * checks whether a getter or setter exists on the specified type or any of\n     * its super classes excluding Object. respects JsonIgnore accordingly.\n     *\n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {\n        if ( field instanceof DummyJField ){\n            return true;\n        }\n\n\tJType[] args = null;\n\tif (isSetter) {\n\t    args = new JType[] { field.getType() };\n\t} else {\n\t    args = new JType[] {};\n\t}\n\tJMethod m = type.findMethod(fieldName, args);\n\tif (null != m) {\n        if(m.getAnnotation(JsonIgnore.class) != null)\n            return false;\n        if(isSetter)\n            return true;\n        JClassType returnType = m.getReturnType().isClassOrInterface();\n        JClassType fieldType = field.getType().isClassOrInterface();\n        if(returnType == null || fieldType == null) {\n            // at least one is a primitive type\n            return m.getReturnType().equals(field.getType());\n        }\n        // both are non-primitives\n        return returnType.isAssignableFrom(fieldType);\n\t}\n    try {\n    JType objectType = find(Object.class, getLogger(), context);\n    JClassType superType = type.getSuperclass();\n    if (!objectType.equals(superType)) {\n        return exists(superType, field, fieldName, isSetter);\n    }\n    } catch (UnableToCompleteException e) {\n    // do nothing\n    }\n\treturn false;\n    }\n\n    /**\n     * Inspects the supplied type and all super classes up to but excluding\n     * Object and returns a list of all fields found in these classes.\n     *\n     * @param type\n     * @return\n     */\n    private List<JField> getFields(JClassType type) {\n        List<JField> allFields = getFields(new ArrayList<JField>(), type);\n        Map<String, JMethod> getters = new HashMap<String, JMethod>();\n        Map<String, JType> setters = new HashMap<String, JType>();\n        for( JMethod m: type.getInheritableMethods() ){\n            if( m.getName().startsWith(\"set\") &&\n                    m.getParameterTypes().length == 1 &&\n                    m.getReturnType() == JPrimitiveType.VOID &&\n                    m.getAnnotation(JsonIgnore.class) == null){\n                setters.put( m.getName().replaceFirst(\"^set\", \"\"), m.getParameterTypes()[0] );\n            }\n            else if( m.getName().startsWith(\"get\") &&\n                    m.getParameterTypes().length == 0 &&\n                    m.getReturnType() != JPrimitiveType.VOID &&\n                    m.getAnnotation(JsonIgnore.class) == null){\n                getters.put( m.getName().replaceFirst(\"^get\", \"\"), m );\n            }\n        }\n        for( Map.Entry<String, JMethod> entry: getters.entrySet() ){\n            if ( setters.containsKey( entry.getKey() ) && setters.get( entry.getKey() ).equals( entry.getValue().getReturnType() ) ) {\n                String name = entry.getKey().substring(0, 1).toLowerCase() + entry.getKey().substring(1);\n                boolean found = false;\n                for( JField f : allFields ){\n                    if( f.getName().equals( name ) ){\n                        found = true;\n                        break;\n                    }\n                }\n                JField f = type.findField( name );\n                // is getter annotated, if yes use this annotation for the field\n                JsonProperty propName = null;\n                if ( entry.getValue().isAnnotationPresent(JsonProperty.class) ) {\n                    propName = entry.getValue().getAnnotation(JsonProperty.class);\n                }\n                // is setter annotated, if yes use this annotation for the field\n                JMethod m = type.findMethod(\"s\" + entry.getValue().getName().substring(1),\n                        new JType[]{ entry.getValue().getReturnType() });\n                if ( m != null && m.isAnnotationPresent(JsonProperty.class) ) {\n                    propName = m.getAnnotation(JsonProperty.class);\n                }\n                // if have a field and an annotation from the getter/setter then use that annotation \n                if ( propName != null && found && !f.getName().equals(propName.value())) {\n                    allFields.remove(f);\n                    DummyJField dummy = new DummyJField( name, entry.getValue().getReturnType() );\n                    dummy.setAnnotation( propName );\n                    allFields.add(dummy);\n                }\n                if ( ! found && !( f != null && f.isAnnotationPresent( JsonIgnore.class ) ) ){\n                    DummyJField dummy = new DummyJField( name, entry.getValue().getReturnType() );\n                    if ( entry.getValue().isAnnotationPresent(JsonProperty.class) ) {\n                        dummy.setAnnotation( entry.getValue().getAnnotation(JsonProperty.class) );\n                    }\n                    allFields.add( dummy );\n                }\n            }\n        }\n        return allFields;\n    }\n\n    private List<JField> getFields(List<JField> allFields, JClassType type) {\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n            if (!field.isTransient() && !field.isAnnotationPresent(JsonIgnore.class)) {\n                allFields.add(field);\n            }\n        }\n        try {\n            JType objectType = find(Object.class, getLogger(), context);\n            if (!objectType.equals(type)) {\n                JClassType superType = type.getSuperclass();\n                return getFields(allFields, superType);\n            }\n        }\n        catch (UnableToCompleteException e) {\n\t    // do nothing\n        }\n\n    \treturn allFields;\n    }\n\n    public static String getTypeInfoPropertyValue(final JsonTypeInfo typeInfo)\n    {\n        if (typeInfo.include() == JsonTypeInfo.As.PROPERTY)\n            if(typeInfo.property() == null || \"\".equals(typeInfo.property()))\n                return typeInfo.use().getDefaultPropertyName();\n\n        return typeInfo.property();\n    }\n\n    public static boolean isLeaf(JClassType source)\n    {\n        return !(source.getSubtypes() != null && source.getSubtypes().length > 0);\n    }\n\n    public static class Subtype {\n    final String tag;\n    final JClassType clazz;\n\n    public Subtype(String tag, JClassType clazz) {\n        this.tag = tag;\n        this.clazz = clazz;\n    }\n    }\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> sTypeIdResolverMap = null;\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.codehaus.jackson.annotate.JsonCreator;\nimport org.codehaus.jackson.annotate.JsonIgnore;\nimport org.codehaus.jackson.annotate.JsonIgnoreProperties;\nimport org.codehaus.jackson.annotate.JsonProperty;\nimport org.codehaus.jackson.annotate.JsonSubTypes;\nimport org.codehaus.jackson.annotate.JsonSubTypes.Type;\nimport org.codehaus.jackson.annotate.JsonTypeInfo;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.As;\nimport org.codehaus.jackson.annotate.JsonValue;\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JConstructor;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONNull;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONString;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.thirdparty.guava.common.collect.Lists;\nimport com.google.gwt.thirdparty.guava.common.collect.Maps;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added getter & setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n *\n *         added polymorphic support\n * @author <a href=\"http://charliemason.info\">Charlie Mason<\/a>\n *\n */\n\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n    protected static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_NULL_CLASS = JSONNull.class.getName();\n    protected static final String JSON_STRING_CLASS = JSONString.class.getName();\n\n    protected JsonEncoderDecoderInstanceLocator locator;\n\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    @Override\n    public void generate() throws UnableToCompleteException {\n        final JsonTypeInfo typeInfo = findAnnotation(source, JsonTypeInfo.class);\n        final boolean isLeaf = isLeaf(source);\n\n        final List<Subtype> possibleTypes = getPossibleTypes(typeInfo, isLeaf);\n\n        final JClassType sourceClazz = source.isClass() == null ? source.isInterface() : source.isClass();\n        if (sourceClazz == null) {\n            getLogger().log(ERROR, \"Type is not a class\");\n            throw new UnableToCompleteException();\n        }\n\n        if (sourceClazz.isAbstract()) {\n            if (typeInfo == null) {\n                getLogger().log(ERROR, \"Abstract classes must be annotated with JsonTypeInfo\");\n                throw new UnableToCompleteException();\n            }\n        }\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n        final String railsWrapperName = jsonAnnotation != null && jsonAnnotation.name().length() > 0 ? jsonAnnotation.name() : sourceClazz.getName().toLowerCase();\n        locator = new JsonEncoderDecoderInstanceLocator(context, getLogger());\n\n        generateSingleton(shortName);\n\n        generateEncodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n\n        generateDecodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n\tClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n\tcomposerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n\treturn composerFactory;\n    }\n\n    public static <T extends Annotation> T findAnnotation(JClassType clazz, Class<T> annotation) {\n\tif (clazz == null)\n\t    return null;\n\telse if (clazz.isAnnotationPresent(annotation))\n\t    return clazz.getAnnotation(annotation);\n\telse\n\t    return findAnnotation(clazz.getSuperclass(), annotation);\n    }\n\n    private List<Subtype> getPossibleTypes(final JsonTypeInfo typeInfo, final boolean isLeaf) throws UnableToCompleteException\n    {\n        if (typeInfo == null)\n            return Lists.newArrayList(new Subtype(null, source));\n        Collection<Type> subTypes = findJsonSubTypes(source);\n        if(subTypes.isEmpty()) {\n            JsonSubTypes foundAnnotation = findAnnotation(source, JsonSubTypes.class);\n            if(foundAnnotation != null) {\n                Type[] value = foundAnnotation.value();\n                subTypes = Arrays.asList(value);\n            }\n        }\n        PossibleTypesVisitor v = new PossibleTypesVisitor(context, source, isLeaf, getLogger(), subTypes);\n        return v.visit(typeInfo.use());\n    }\n\n    private Collection<Type> findJsonSubTypes(JClassType clazz) {\n        if (clazz == null)\n            return Collections.emptyList();\n        else if (clazz.isAnnotationPresent(JsonSubTypes.class)) {\n            JsonSubTypes annotation = clazz.getAnnotation(JsonSubTypes.class);\n            Set<Type> result = new HashSet<JsonSubTypes.Type>();\n            Type[] value = annotation.value();\n            for (Type type : value) {\n                result.add(type);\n                Class<?> subclazz = type.value();\n                String newSubClassName = subclazz.getName().replaceAll(\"\\\\$\", \".\");\n                JClassType subJClazz = context.getTypeOracle().findType(newSubClassName);\n                if(!isSame(clazz, subclazz)) {\n                    result.addAll(findJsonSubTypes(subJClazz));\n                }\n            }\n            return result;\n        } else\n            return Collections.emptyList();\n        }\n\n    private boolean isSame(JClassType clazz, Class<?> subclazz) {\n        return (clazz.getPackage().getName()+\".\"+clazz.getName()).equals(subclazz.getName());\n    }\n\n    protected void generateSingleton(String shortName)\n    {\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n    }\n\n    private void generateEncodeMethod(JClassType classType,\n            final Style classStyle,\n            JsonTypeInfo typeInfo,\n            String railsWrapperName,\n            List<Subtype> possibleTypes,\n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {\n            generateEnumEncodeMethod(classType, JSON_VALUE_CLASS);\n            return;\n        }\n\n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n\n            boolean returnWrapper = false; // if set, return rrc\n\n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n            if (classStyle == Style.RAILS) {\n                returnWrapper = true;\n                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                p(\"rrc.put(\\\"\" + railsWrapperName + \"\\\" , rc);\");\n            }\n\n            for (Subtype possibleType : possibleTypes) {\n\n                if (!possibleType.clazz.isAssignableTo(classType)) {\n                    getLogger().log(DEBUG, \"Only assignable classes are allowed: \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" is not assignable to: \" + classType.getParameterizedQualifiedSourceName());\n                    continue;\n                }\n\n                if (!isLeaf) {\n                    // Generate a decoder for each possible type\n                    p(\"if(value.getClass().getName().equals(\\\"\" + possibleType.clazz.getQualifiedBinaryName() + \"\\\"))\");\n                    p(\"{\");\n                }\n\n                if (possibleType.clazz.isEnum() != null) {\n                    generateEnumEncodeMethodBody(possibleType, typeInfo);\n                } else {\n\n                    // Try to find a constuctor that is annotated as creator\n                    final JConstructor creator = findCreator(possibleType.clazz);\n\n                    List<JField> orderedFields = creator == null ? null : getOrderedFields(getFields(possibleType.clazz), creator);\n\n                    if (typeInfo != null) {\n                        switch (typeInfo.include()) {\n                            case PROPERTY:\n                                p(\"com.google.gwt.json.client.JSONValue className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\");\");\n                                p(\"if( className!=null ) { \").i(1);\n                                p(\"rc.put(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \", className);\");\n                                i(-1).p(\"}\");\n                                break;\n                            case WRAPPER_OBJECT:\n                                returnWrapper = true;\n                                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                                p(\"rrc.put(\\\"\" + possibleType.tag + \"\\\", rc);\");\n                                break;\n                            case WRAPPER_ARRAY:\n                                returnWrapper = true;\n                                p(JSON_ARRAY_CLASS + \" rrc = new \" + JSON_ARRAY_CLASS + \"();\");\n                                p(\"rrc.set(0, org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\"));\");\n                                p(\"rrc.set(1, rc);\");\n                        }\n                    }\n\n                    p(possibleType.clazz.getParameterizedQualifiedSourceName() + \" parseValue = (\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \")value;\");\n\n                    for (final JField field : getFields(possibleType.clazz)) {\n\n                        final String getterName = getGetterName(field);\n\n                        boolean ignoreField = false;\n                        if(possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null) {\n                            for(String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value()) {\n                                if(s.equals(field.getName())) {\n                                    ignoreField = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        // If can ignore some fields right off the back..\n                        // if there is a creator encode only final fields with JsonProperty annotation\n                        if (ignoreField || getterName == null && (field.isStatic() || (field.isFinal() && !(creator != null && orderedFields.contains(field))) || field.isTransient()\n                                || field.isAnnotationPresent(JsonIgnore.class))) {\n                            continue;\n                        }\n\n                        branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                            @Override\n                            public Void execute() throws UnableToCompleteException {\n                                // TODO: try to get the field with a setter or\n                                // JSNI\n                                if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                                    Json jsonAnnotation = field.getAnnotation(Json.class);\n                                    JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n\n                                    String name = field.getName();\n                                    String jsonName = name;\n\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                                        jsonName = jsonPropertyAnnotation.value();\n                                    }\n\n                                    String fieldExpr = \"parseValue.\" + name;\n                                    if (getterName != null) {\n                                        fieldExpr = \"parseValue.\" + getterName + \"()\";\n                                    }\n\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    String expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n\n                                    p(\"{\").i(1);\n                                    {\n                                        if (null != field.getType().isEnum()) {\n                                            p(\"if(\" + fieldExpr + \" == null) {\").i(1);\n                                            p(\"rc.put(\" + wrap(jsonName) + \", \" + JSON_NULL_CLASS + \".getInstance());\");\n                                            i(-1).p(\"} else {\").i(1);\n                                        }\n\n                                        p(JSON_VALUE_CLASS + \" v=\" + expression + \";\");\n                                        p(\"if( v!=null ) {\").i(1);\n                                        {\n                                            p(\"rc.put(\" + wrap(jsonName) + \", v);\");\n                                        }\n                                        i(-1).p(\"}\");\n\n                                        if (null != field.getType().isEnum()) {\n                                            i(-1).p(\"}\");\n                                        }\n\n                                    }\n                                    i(-1).p(\"}\");\n\n                                } else {\n                                    getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                                }\n                                return null;\n                            }\n                        });\n\n                    }\n\n                    if (returnWrapper) {\n                        p(\"return rrc;\");\n                    } else {\n                        p(\"return rc;\");\n                    }\n                }\n                if (!isLeaf) {\n                    p(\"}\");\n                }\n            }\n\n            if (!isLeaf) {\n                // Shouldn't get called\n                p(\"return null;\");\n            }\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n\n    private void generateEnumEncodeMethodBody(final Subtype possibleType, final JsonTypeInfo typeInfo) {\n        p(\"if( value==null ) {\").i(1);\n        {\n            p(\"return \" + JSON_NULL_CLASS + \".getInstance();\").i(-1);\n        }\n        p(\"}\");\n        p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n        p(JSON_VALUE_CLASS + \" className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\"\n                + possibleType.tag + \"\\\");\");\n        p(\"rrc.put(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \", className);\");\n        p(\"rrc.put(\\\"name\\\", new \" + JSON_STRING_CLASS + \"(value.name()));\");\n        p(\"return rrc;\");\n    }\n\n    private void generateEnumEncodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + jsonValueClass + \" encode(\" + classType.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return \" + JSON_NULL_CLASS + \".getInstance();\").i(-1);\n            }\n            p(\"}\");\n            p(\"return new \" + JSON_STRING_CLASS + \"(value.name());\");\n            i(-1).p(\"}\");\n        }\n        p();\n    }\n\n    private void generateDecodeMethod(JClassType classType,\n            final Style classStyle,\n            JsonTypeInfo typeInfo,\n            String railsWrapperName,\n            List<Subtype> possibleTypes,\n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {\n            generateEnumDecodeMethod(classType, JSON_VALUE_CLASS);\n            return;\n        }\n\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n            {\n                p(\"return null;\").i(-1);\n            }\n            p(\"}\");\n            if (classStyle == Style.RAILS) {\n                p(JSON_OBJECT_CLASS + \" object = toObjectFromWrapper(value, \\\"\" + railsWrapperName + \"\\\");\");\n            } else if (typeInfo != null && typeInfo.include() == As.WRAPPER_ARRAY) {\n                p(JSON_ARRAY_CLASS + \" array = (\" + JSON_ARRAY_CLASS + \")value;\");\n                if (!isLeaf)\n                    p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(array.get(0));\");\n                p(JSON_OBJECT_CLASS + \" object = toObject(array.get(1));\");\n            } else {\n                p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            }\n\n            if (!isLeaf && typeInfo != null && typeInfo.include() == As.PROPERTY) {\n                p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \"));\");\n            }\n\n            for (Subtype possibleType : possibleTypes) {\n\n                if (!possibleType.clazz.isAssignableTo(classType)) {\n                    getLogger().log(DEBUG, \"Only assignable classes are allowed: \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" is not assignable to: \" + classType.getParameterizedQualifiedSourceName());\n                    continue;\n                }\n\n                if (typeInfo != null) {\n                    if (typeInfo.include() == As.WRAPPER_OBJECT) {\n                        if (!isLeaf) {\n                            p(\"if(object.containsKey(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        }\n                        p(\"object = toObjectFromWrapper(value, \\\"\" + possibleType.tag + \"\\\");\");\n                    } else if (!isLeaf) {\n                        p(\"if(sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n                        p(\"{\");\n                    }\n                }\n\n                if (possibleType.clazz.isEnum() != null) {\n                    generateEnumDecodeMethodBody(possibleType.clazz);\n                } else {\n                    // Try to find a constuctor that is annotated as creator\n                    final JConstructor creator = findCreator(possibleType.clazz);\n\n                    List<JField> orderedFields = null;\n                    if (creator != null) {\n                        p(\"// We found a creator so we use the annotated constructor\");\n                        p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"(\");\n                        i(1).p(\"// The arguments are placed in the order they appear within the annotated constructor\").i(-1);\n                        orderedFields = getOrderedFields(getFields(possibleType.clazz), creator);\n                        final JField lastField = orderedFields.get(orderedFields.size() - 1);\n                        for (final JField field : orderedFields) {\n                            branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                                @Override\n                                public Void execute() throws UnableToCompleteException {\n                                    Json jsonAnnotation = field.getAnnotation(Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    String jsonName = field.getName();\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                    String defaultValue = getDefaultValue(field);\n                                    i(1).p(\"\" + (objectGetter + \" == null || \" + objectGetter + \" instanceof \" + JSON_NULL_CLASS + \" ? \" + defaultValue + \" : \" + expression + ((field != lastField) ? \", \" : \"\"))).i(-1);\n\n                                    return null;\n                                }\n                            });\n                        }\n                        p(\");\");\n                    }\n\n                    if (orderedFields == null){\n                        p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"();\");\n                    }\n\n                    for (final JField field : getFields(possibleType.clazz)) {\n\n                        boolean ignoreField = false;\n                        if(possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null) {\n                            for(String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value()) {\n                                if(s.equals(field.getName())) {\n                                    ignoreField = true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(ignoreField) {\n                            continue;\n                        }\n\n                        if (orderedFields != null && orderedFields.contains(field)){\n                            continue;\n                        }\n\n                        final String setterName = getSetterName(field);\n\n                        // If can ignore some fields right off the back..\n                        if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient()) ||\n                                field.isAnnotationPresent(JsonIgnore.class)) {\n                            continue;\n                        }\n\n                        branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                            @Override\n                            public Void execute() throws UnableToCompleteException {\n\n                                // TODO: try to set the field with a setter\n                                // or JSNI\n                                if (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                                    Json jsonAnnotation = field.getAnnotation(Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n\n                                    String name = field.getName();\n                                    String jsonName = name;\n\n                                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                                        jsonName = jsonAnnotation.name();\n                                    }\n                                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                                        jsonName = jsonPropertyAnnotation.value();\n                                    }\n\n                                    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                    boolean needNullHandling = !locator.hasCustomEncoderDecoder(field.getType());\n\n                                    String cast = field.getType().isPrimitive() == JPrimitiveType.SHORT ? \"(short) \" : \"\";\n\n                                    if (needNullHandling) {\n                                        p(\"if(\" + objectGetter + \" != null) {\").i(1);\n                                        p(\"if(\" + objectGetter + \" instanceof \" + JSON_NULL_CLASS + \") {\").i(1);\n                                        String defaultValue = getDefaultValue(field);\n\n                                        assignFieldValue(name, defaultValue, cast, setterName);\n                                        i(-1);\n                                        p(\"} else {\").i(1);\n                                    }\n\n                                    assignFieldValue(name, expression, cast, setterName);\n\n                                    if (needNullHandling) {\n                                        i(-1);\n                                        p(\"}\").i(-1);\n                                        p(\"}\");\n                                    }\n\n                                } else {\n                                    getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                                }\n                                return null;\n                            }\n                        });\n                    }\n\n                    p(\"return rc;\");\n                }\n                if (typeInfo != null && !isLeaf) {\n                    p(\"}\");\n                }\n            }\n\n            if (typeInfo != null && !isLeaf) {\n                p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n            p();\n        }\n    }\n\n    private void generateEnumDecodeMethodBody(JClassType classType) {\n        p(JSON_VALUE_CLASS + \" str = object.get(\\\"name\\\");\");\n        p(\"if( null == str || str.isString() == null ) {\").i(1);\n        {\n            p(\"throw new DecodingException(\\\"Expected a string field called 'name' for enum; not found\\\");\").i(-1);\n        }\n        p(\"}\");\n        final String className = classType.getParameterizedQualifiedSourceName();\n        p(\"return Enum.valueOf(\" + className + \".class, str.isString().stringValue());\").i(-1);\n    }\n\n    private String getDefaultValue(JField field) {\n        return field.getType().isPrimitive() == null ? \"null\" : field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n    }\n\n    private void assignFieldValue(String name, String expression, String cast, String setterName) {\n        if (setterName != null) {\n            p(\"rc.\" + setterName + \"(\" + cast + expression + \");\");\n        } else {\n            p(\"rc.\" + name + \"=\" + cast + expression + \";\");\n        }\n    }\n\n    protected void generateEnumDecodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + classType.getName() + \" decode(\" + jsonValueClass + \" value) {\").i(1);\n        {\n        p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n        {\n            p(\"return null;\").i(-1);\n        }\n        p(\"}\");\n        p(JSON_STRING_CLASS + \" str = value.isString();\");\n        p(\"if( null == str ) {\").i(1);\n        {\n            p(\"throw new DecodingException(\\\"Expected a json string (for enum), but was given: \\\"+value);\").i(-1);\n        }\n        p(\"}\");\n        p(\"return Enum.valueOf(\" + classType.getParameterizedQualifiedSourceName() + \".class, str.stringValue());\").i(-1);\n        }\n        p(\"}\");\n        p();\n    }\n\n    public static Map<Class<?>, RestyJsonTypeIdResolver> getRestyResolverClassMap(GeneratorContext context, TreeLogger logger) throws UnableToCompleteException {\n\tif (sTypeIdResolverMap == null) {\n\t    try {\n\t\tMap<Class<?>, RestyJsonTypeIdResolver> map = Maps.newHashMap();\n\t\tList<String> values = context.getPropertyOracle().getConfigurationProperty(\"org.fusesource.restygwt.jsontypeidresolver\").getValues();\n\t\tfor (String value : values)\n\t\t    try {\n\t\t\tClass<?> clazz = Class.forName(value);\n\t\t\tRestyJsonTypeIdResolver resolver = (RestyJsonTypeIdResolver) clazz.newInstance();\n\t\t\tmap.put(resolver.getTypeIdResolverClass(), resolver);\n\t\t    } catch (Exception e) {\n\t\t\tlogger.log(WARN, \"Could not access class: \" + values.get(0), e);\n\t\t    }\n\t\t    sTypeIdResolverMap = map;\n\t    } catch (BadPropertyValueException e) {\n\t\tlogger.log(ERROR, \"Could not acccess property: RestyJsonTypeIdResolver\", e);\n\t\tthrow new UnableToCompleteException();\n\t    }\n\t}\n\treturn sTypeIdResolverMap;\n    }\n\n    private List<JField> getOrderedFields(List<JField> fields, JConstructor creator) throws UnableToCompleteException {\n\tList<JField> orderedFields = new ArrayList<JField>();\n\tfor (JParameter param : creator.getParameters()) {\n\t    JsonProperty prop = param.getAnnotation(JsonProperty.class);\n\t    if (prop != null) {\n\t\tfor (JField field : fields) {\n\t\t    if (field.getName().equals(prop.value())) {\n\t\t\torderedFields.add(field);\n\t\t    }\n\t\t}\n\t    } else {\n\t\tgetLogger().log(ERROR, \"a constructor annotated with @JsonCreator requires that all paramaters are annotated with @JsonProperty.\");\n        throw new UnableToCompleteException();\n\t    }\n\t}\n\n\treturn orderedFields;\n    }\n\n    private JConstructor findCreator(JClassType sourceClazz) {\n\tfor (JConstructor constructor : sourceClazz.getConstructors()) {\n\t    if (constructor.getAnnotation(JsonCreator.class) != null) {\n\t\treturn constructor;\n\t    }\n\t}\n\n\treturn null;\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the setter for the specified field or null if a\n     *         setter can't be found.\n     */\n    private String getSetterName(JField field) {\n\tString fieldName = field.getName();\n\tfieldName = \"set\" + upperCaseFirstChar(fieldName);\n\tJClassType type = field.getEnclosingType();\n\tif (exists(type, field, fieldName, true)) {\n\t    return fieldName;\n\t}\n    return null;\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the getter for the specified field or null if a\n     *         getter can't be found.\n     */\n    private String getGetterName(JField field) {\n\tString fieldName = field.getName();\n\tJType booleanType = null;\n\ttry {\n\t    booleanType = find(Boolean.class, getLogger(), context);\n\t} catch (UnableToCompleteException e) {\n\t    // do nothing\n\t}\n\tJClassType type = field.getEnclosingType();\n\tif (field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)) {\n\t    fieldName = \"is\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t    fieldName = \"has\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t}\n\tfieldName = \"get\" + upperCaseFirstChar(field.getName());\n\tif (exists(type, field, fieldName, false)) {\n\t    return fieldName;\n\t}\n    return null;\n    }\n\n    private String upperCaseFirstChar(String in) {\n\tif (in.length() == 1) {\n\t    return in.toUpperCase();\n\t}\n    return in.substring(0, 1).toUpperCase() + in.substring(1);\n    }\n\n    /**\n     * checks whether a getter or setter exists on the specified type or any of\n     * its super classes excluding Object. respects JsonIgnore accordingly.\n     *\n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {\n        if ( field instanceof DummyJField ){\n            return true;\n        }\n\n\tJType[] args = null;\n\tif (isSetter) {\n\t    args = new JType[] { field.getType() };\n\t} else {\n\t    args = new JType[] {};\n\t}\n\tJMethod m = type.findMethod(fieldName, args);\n\tif (null != m) {\n        if(m.getAnnotation(JsonIgnore.class) != null)\n            return false;\n        if(isSetter)\n            return true;\n        JClassType returnType = m.getReturnType().isClassOrInterface();\n        JClassType fieldType = field.getType().isClassOrInterface();\n        if(returnType == null || fieldType == null) {\n            // at least one is a primitive type\n            return m.getReturnType().equals(field.getType());\n        }\n        // both are non-primitives\n        return returnType.isAssignableFrom(fieldType);\n\t}\n    try {\n    JType objectType = find(Object.class, getLogger(), context);\n    JClassType superType = type.getSuperclass();\n    if (!objectType.equals(superType)) {\n        return exists(superType, field, fieldName, isSetter);\n    }\n    } catch (UnableToCompleteException e) {\n    // do nothing\n    }\n\treturn false;\n    }\n\n    /**\n     * Inspects the supplied type and all super classes up to but excluding\n     * Object and returns a list of all fields found in these classes.\n     *\n     * @param type\n     * @return\n     */\n    private List<JField> getFields(JClassType type) {\n        List<JField> allFields = getFields(new ArrayList<JField>(), type);\n        Map<String, JMethod> getters = new HashMap<String, JMethod>();\n        Map<String, JType> setters = new HashMap<String, JType>();\n        for( JMethod m: type.getInheritableMethods() ){\n            if( m.getName().startsWith(\"set\") &&\n                    m.getParameterTypes().length == 1 &&\n                    m.getReturnType() == JPrimitiveType.VOID &&\n                    m.getAnnotation(JsonIgnore.class) == null){\n                setters.put( m.getName().replaceFirst(\"^set\", \"\"), m.getParameterTypes()[0] );\n            }\n            else if( m.getName().startsWith(\"get\") &&\n                    m.getParameterTypes().length == 0 &&\n                    m.getReturnType() != JPrimitiveType.VOID &&\n                    m.getAnnotation(JsonIgnore.class) == null){\n                getters.put( m.getName().replaceFirst(\"^get\", \"\"), m );\n            }\n        }\n        for( Map.Entry<String, JMethod> entry: getters.entrySet() ){\n            if ( setters.containsKey( entry.getKey() ) && setters.get( entry.getKey() ).equals( entry.getValue().getReturnType() ) ) {\n                String name = entry.getKey().substring(0, 1).toLowerCase() + entry.getKey().substring(1);\n                boolean found = false;\n                for( JField f : allFields ){\n                    if( f.getName().equals( name ) ){\n                        found = true;\n                        break;\n                    }\n                }\n                JField f = type.findField( name );\n                // is getter annotated, if yes use this annotation for the field\n                JsonProperty propName = null;\n                if ( entry.getValue().isAnnotationPresent(JsonProperty.class) ) {\n                    propName = entry.getValue().getAnnotation(JsonProperty.class);\n                }\n                // is setter annotated, if yes use this annotation for the field\n                JMethod m = type.findMethod(\"s\" + entry.getValue().getName().substring(1),\n                        new JType[]{ entry.getValue().getReturnType() });\n                if ( m != null && m.isAnnotationPresent(JsonProperty.class) ) {\n                    propName = m.getAnnotation(JsonProperty.class);\n                }\n                // if have a field and an annotation from the getter/setter then use that annotation \n                if ( propName != null && found && !f.getName().equals(propName.value())) {\n                    allFields.remove(f);\n                    DummyJField dummy = new DummyJField( name, entry.getValue().getReturnType() );\n                    dummy.setAnnotation( propName );\n                    allFields.add(dummy);\n                }\n                if ( ! found && !( f != null && f.isAnnotationPresent( JsonIgnore.class ) ) ){\n                    DummyJField dummy = new DummyJField( name, entry.getValue().getReturnType() );\n                    if ( entry.getValue().isAnnotationPresent(JsonProperty.class) ) {\n                        dummy.setAnnotation( entry.getValue().getAnnotation(JsonProperty.class) );\n                    }\n                    allFields.add( dummy );\n                }\n            }\n        }\n        return allFields;\n    }\n\n    private List<JField> getFields(List<JField> allFields, JClassType type) {\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n            if (!field.isTransient() && !field.isAnnotationPresent(JsonIgnore.class)) {\n                allFields.add(field);\n            }\n        }\n        try {\n            JType objectType = find(Object.class, getLogger(), context);\n            if (!objectType.equals(type)) {\n                JClassType superType = type.getSuperclass();\n                return getFields(allFields, superType);\n            }\n        }\n        catch (UnableToCompleteException e) {\n\t    // do nothing\n        }\n\n    \treturn allFields;\n    }\n\n    public static String getTypeInfoPropertyValue(final JsonTypeInfo typeInfo)\n    {\n        if (typeInfo.include() == JsonTypeInfo.As.PROPERTY)\n            if(typeInfo.property() == null || \"\".equals(typeInfo.property()))\n                return typeInfo.use().getDefaultPropertyName();\n\n        return typeInfo.property();\n    }\n\n    public static boolean isLeaf(JClassType source)\n    {\n        return !(source.getSubtypes() != null && source.getSubtypes().length > 0);\n    }\n\n    public static class Subtype {\n    final String tag;\n    final JClassType clazz;\n\n    public Subtype(String tag, JClassType clazz) {\n        this.tag = tag;\n        this.clazz = clazz;\n    }\n    }\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> sTypeIdResolverMap = null;\n}\n","lineNo":642}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.client.basic;\n\nimport com.google.gwt.core.client.GWT;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.junit.client.GWTTestCase;\nimport org.fusesource.restygwt.client.*;\n\nimport javax.ws.rs.FormParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport java.util.*;\n\n/**\n *\n *\n * @author mkristian\n * @author Bogdan Mustiata &lt;bogdan.mustiata@gmail.com&gt;\n *\n */\npublic class FormParamTestGwt extends GWTTestCase {\n\n    private FormParamTestRestService service;\n\n    @Override\n    public String getModuleName() {\n        return \"org.fusesource.restygwt.EchoTestGwt\";\n    }\n\n    @Path(\"/get\")\n    static interface FormParamTestRestService extends RestService {\n\n        @POST\n        void get(@FormParam(value = \"id\") int id, MethodCallback<Echo> callback);\n\n        @POST\n        void get(@FormParam(value = \"id\") Integer id, MethodCallback<Echo> callback);\n\n        @POST\n        void twoParams(@FormParam(value = \"id\") int id, @FormParam(value = \"dto\") ExampleDto exampleDto, MethodCallback<Echo> callback);\n\n        @POST\n        void listParams(@FormParam(value = \"dtoList\") List<ExampleDto> exampleDtoList, MethodCallback<Echo> callback);\n\n        @POST\n        void arrayParams(@FormParam(value = \"dtoArray\") ExampleDto[] exampleDtoArray, MethodCallback<Echo> callback);\n    }\n    \n    class EchoMethodCallback implements MethodCallback<Echo> {\n        \n        private final String id;\n\n        EchoMethodCallback(String id){\n            this.id = id;\n        }\n        \n        @Override\n        public void onSuccess(Method method, Echo response) {\n            GWT.log(\"method was called: \" + response.params.get(\"id\"));\n\n            assertEquals(response.params.get(\"id\"), id);\n            assertEquals(response.params.size(), 1);\n\n            finishTest();\n\n        }\n\n        @Override\n        public void onFailure(Method method, Throwable exception) {\n            System.out.println(\"test failed\");\n            fail();\n        }\n    }\n    \n    @Override\n    protected void gwtSetUp() throws Exception {\n        super.gwtSetUp();        \n        service = GWT.create(FormParamTestRestService.class);\n        Resource resource = new Resource(GWT.getModuleBaseURL() + \"echo\");\n        ((RestServiceProxy) service).setResource(resource);\n\n        delayTestFinish(10000);\n    }\n\n    public void testGetWithInt() {\n        service.get(123, new EchoMethodCallback(\"123\"));\n    }\n\n    public void testGetWithInteger() {\n        service.get(new Integer(2), new EchoMethodCallback(\"2\"));\n    }\n\n    public void testGetWithNull() {\n        service.get(null, new MethodCallback<Echo>(){\n            @Override\n            public void onFailure(Method method, Throwable exception) {\n                fail();\n            }\n\n            @Override\n            public void onSuccess(Method method, Echo response) {\n                assertFalse(response.params.containsKey(\"id\"));\n                assertEquals(response.params.size(), 0);\n\n                finishTest();\n            }\n        });\n    }\n\n    public interface ExampleDtoDecoder extends JsonEncoderDecoder<ExampleDto> {\n    }\n\n    public void testPostWithDto() {\n        final ExampleDtoDecoder dtoDecoder = GWT.create(ExampleDtoDecoder.class);\n        final ExampleDto dto = createDtoObject();\n\n        service.twoParams(3, dto, new MethodCallback<Echo>() {\n            @Override\n            public void onFailure(Method method, Throwable exception) {\n                fail();\n            }\n\n            @Override\n            public void onSuccess(Method method, Echo response) {\n                assertEquals(2, response.params.size());\n                assertEquals(\"3\", response.params.get(\"id\"));\n\n                JSONValue jsonDto = JSONParser.parseStrict(response.params.get(\"dto\"));\n                assertEquals(dto, dtoDecoder.decode(jsonDto));\n\n                finishTest();\n            }\n        });\n    }\n\n    public void testPostWithDtoList() {\n        final ObjectEncoderDecoder objectEncoderDecoder = new ObjectEncoderDecoder();\n        final List<ExampleDto> dtoList = Collections.singletonList( createDtoObject() );\n\n        service.listParams(dtoList, new MethodCallback<Echo>() {\n            @Override\n            public void onFailure(Method method, Throwable exception) {\n                fail();\n            }\n\n            @Override\n            public void onSuccess(Method method, Echo response) {\n                assertEquals(1, response.params.size());\n\n                JSONValue jsonDto = JSONParser.parseStrict(response.params.get(\"dtoList\"));\n                final Object decoded_object = objectEncoderDecoder.decode(jsonDto);\n                if (decoded_object instanceof Collection) {\n                    final Collection<String> decoded_list = (Collection<String>) decoded_object;\n                    final List decoded_elem_list = new ArrayList();\n                    for (final String json_elem : decoded_list) {\n                        decoded_elem_list.add(objectEncoderDecoder.decode(json_elem));\n                    }\n                    assertEquals(createDtoObjectAsList(), decoded_elem_list);\n                } else {\n                    assertEquals(createDtoObjectAsList(), Arrays.asList(decoded_object));\n                }\n\n                finishTest();\n            }\n        });\n    }\n\n    public void testPostWithDtoArray() {\n        final ObjectEncoderDecoder objectEncoderDecoder = new ObjectEncoderDecoder();\n        final ExampleDto[] dtoList = new ExampleDto[] { createDtoObject() };\n\n        service.arrayParams(dtoList, new MethodCallback<Echo>() {\n            @Override\n            public void onFailure(Method method, Throwable exception) {\n                fail();\n            }\n\n            @Override\n            public void onSuccess(Method method, Echo response) {\n                assertEquals(1, response.params.size());\n\n                JSONValue jsonDto = JSONParser.parseStrict(response.params.get(\"dtoArray\"));\n                assertEquals(createDtoObjectAsList(), objectEncoderDecoder.decode(jsonDto));\n\n                finishTest();\n            }\n        });\n    }\n\n\n    private List createDtoObjectAsList() {\n        ArrayList result = new ArrayList();\n\n        result.add(\n            map(\"name\", \"dtoName\",\n                \"complexMap1\", map(\n                    \"1\", \"one\",\n                    \"2\", \"two\",\n                    \"3\", \"three\"\n                ),\n                \"complexMap2\", null,\n                \"complexMap3\", null,\n                \"complexMap4\", null,\n                \"complexMap5\", null,\n                \"complexMap7\", null,\n                \"complexMap8\", null,\n                \"complexMap9\", null,\n                \"complexMap10\", null,\n                \"complexMap11\", null\n            )\n        );\n\n        return result;\n    }\n\n    public HashMap map(Object... keyValues) {\n        HashMap result = new HashMap();\n\n        for (int i = 0; i < keyValues.length; i += 2 ) {\n            result.put(keyValues[i], keyValues[i + 1]);\n        }\n\n        return result;\n    }\n\n    private ExampleDto createDtoObject() {\n        final ExampleDto dto = new ExampleDto();\n        dto.name = \"dtoName\";\n        dto.complexMap1 = new HashMap<Integer, String>();\n        dto.complexMap1.put(1, \"one\");\n        dto.complexMap1.put(2, \"two\");\n        dto.complexMap1.put(3, \"three\");\n        return dto;\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.client.basic;\n\nimport com.google.gwt.core.client.GWT;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.junit.client.GWTTestCase;\nimport org.fusesource.restygwt.client.*;\n\nimport javax.ws.rs.FormParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport java.util.*;\n\n/**\n *\n *\n * @author mkristian\n * @author Bogdan Mustiata &lt;bogdan.mustiata@gmail.com&gt;\n *\n */\npublic class FormParamTestGwt extends GWTTestCase {\n\n    private FormParamTestRestService service;\n\n    @Override\n    public String getModuleName() {\n        return \"org.fusesource.restygwt.EchoTestGwt\";\n    }\n\n    @Path(\"/get\")\n    static interface FormParamTestRestService extends RestService {\n\n        @POST\n        void get(@FormParam(value = \"id\") int id, MethodCallback<Echo> callback);\n\n        @POST\n        void get(@FormParam(value = \"id\") Integer id, MethodCallback<Echo> callback);\n\n        @POST\n        void twoParams(@FormParam(value = \"id\") int id, @FormParam(value = \"dto\") ExampleDto exampleDto, MethodCallback<Echo> callback);\n\n        @POST\n        void listParams(@FormParam(value = \"dtoList\") List<ExampleDto> exampleDtoList, MethodCallback<Echo> callback);\n\n        @POST\n        void arrayParams(@FormParam(value = \"dtoArray\") ExampleDto[] exampleDtoArray, MethodCallback<Echo> callback);\n    }\n    \n    class EchoMethodCallback implements MethodCallback<Echo> {\n        \n        private final String id;\n\n        EchoMethodCallback(String id){\n            this.id = id;\n        }\n        \n        @Override\n        public void onSuccess(Method method, Echo response) {\n            GWT.log(\"method was called: \" + response.params.get(\"id\"));\n\n            assertEquals(response.params.get(\"id\"), id);\n            assertEquals(response.params.size(), 1);\n\n            finishTest();\n\n        }\n\n        @Override\n        public void onFailure(Method method, Throwable exception) {\n            System.out.println(\"test failed\");\n            fail();\n        }\n    }\n    \n    @Override\n    protected void gwtSetUp() throws Exception {\n        super.gwtSetUp();        \n        service = GWT.create(FormParamTestRestService.class);\n        Resource resource = new Resource(GWT.getModuleBaseURL() + \"echo\");\n        ((RestServiceProxy) service).setResource(resource);\n\n        delayTestFinish(10000);\n    }\n\n    public void testGetWithInt() {\n        service.get(123, new EchoMethodCallback(\"123\"));\n    }\n\n    public void testGetWithInteger() {\n        service.get(new Integer(2), new EchoMethodCallback(\"2\"));\n    }\n\n    public void testGetWithNull() {\n        service.get(null, new MethodCallback<Echo>(){\n            @Override\n            public void onFailure(Method method, Throwable exception) {\n                fail();\n            }\n\n            @Override\n            public void onSuccess(Method method, Echo response) {\n                assertFalse(response.params.containsKey(\"id\"));\n                assertEquals(response.params.size(), 0);\n\n                finishTest();\n            }\n        });\n    }\n\n    public interface ExampleDtoDecoder extends JsonEncoderDecoder<ExampleDto> {\n    }\n\n    public void testPostWithDto() {\n        final ExampleDtoDecoder dtoDecoder = GWT.create(ExampleDtoDecoder.class);\n        final ExampleDto dto = createDtoObject();\n\n        service.twoParams(3, dto, new MethodCallback<Echo>() {\n            @Override\n            public void onFailure(Method method, Throwable exception) {\n                fail();\n            }\n\n            @Override\n            public void onSuccess(Method method, Echo response) {\n                assertEquals(2, response.params.size());\n                assertEquals(\"3\", response.params.get(\"id\"));\n\n                JSONValue jsonDto = JSONParser.parseStrict(response.params.get(\"dto\"));\n                assertEquals(dto, dtoDecoder.decode(jsonDto));\n\n                finishTest();\n            }\n        });\n    }\n\n    public void testPostWithDtoList() {\n        final ObjectEncoderDecoder objectEncoderDecoder = new ObjectEncoderDecoder();\n        final List<ExampleDto> dtoList = Collections.singletonList( createDtoObject() );\n\n        service.listParams(dtoList, new MethodCallback<Echo>() {\n            @Override\n            public void onFailure(Method method, Throwable exception) {\n                fail();\n            }\n\n            @Override\n            public void onSuccess(Method method, Echo response) {\n                assertEquals(1, response.params.size());\n\n                JSONValue jsonDto = JSONParser.parseStrict(response.params.get(\"dtoList\"));\n                assertEquals(createDtoObjectAsList(), objectEncoderDecoder.decode(jsonDto));\n\n                finishTest();\n            }\n        });\n    }\n\n    public void testPostWithDtoArray() {\n        final ObjectEncoderDecoder objectEncoderDecoder = new ObjectEncoderDecoder();\n        final ExampleDto[] dtoList = new ExampleDto[] { createDtoObject() };\n\n        service.arrayParams(dtoList, new MethodCallback<Echo>() {\n            @Override\n            public void onFailure(Method method, Throwable exception) {\n                fail();\n            }\n\n            @Override\n            public void onSuccess(Method method, Echo response) {\n                assertEquals(1, response.params.size());\n\n                JSONValue jsonDto = JSONParser.parseStrict(response.params.get(\"dtoArray\"));\n                assertEquals(createDtoObjectAsList(), objectEncoderDecoder.decode(jsonDto));\n\n                finishTest();\n            }\n        });\n    }\n\n\n    private List createDtoObjectAsList() {\n        ArrayList result = new ArrayList();\n\n        result.add(\n            map(\"name\", \"dtoName\",\n                \"complexMap1\", map(\n                    \"1\", \"one\",\n                    \"2\", \"two\",\n                    \"3\", \"three\"\n                ),\n                \"complexMap2\", null,\n                \"complexMap3\", null,\n                \"complexMap4\", null,\n                \"complexMap5\", null,\n                \"complexMap7\", null,\n                \"complexMap8\", null,\n                \"complexMap9\", null,\n                \"complexMap10\", null,\n                \"complexMap11\", null\n            )\n        );\n\n        return result;\n    }\n\n    public HashMap map(Object... keyValues) {\n        HashMap result = new HashMap();\n\n        for (int i = 0; i < keyValues.length; i += 2 ) {\n            result.put(keyValues[i], keyValues[i + 1]);\n        }\n\n        return result;\n    }\n\n    private ExampleDto createDtoObject() {\n        final ExampleDto dto = new ExampleDto();\n        dto.name = \"dtoName\";\n        dto.complexMap1 = new HashMap<Integer, String>();\n        dto.complexMap1.put(1, \"one\");\n        dto.complexMap1.put(2, \"two\");\n        dto.complexMap1.put(3, \"three\");\n        return dto;\n    }\n}\n","lineNo":169}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.server.basic;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.codehaus.jackson.map.ObjectMapper;\nimport org.fusesource.restygwt.client.basic.Echo;\n\n/**\n *\n * just echos back the request path and the request parameters.\n *\n * @author mkristian\n * @author <a href=\"mailto:bogdan.mustiata@gmail.com\">Bogdan Mustiata<\/<a>\n */\npublic class EchoTestGwtServlet extends HttpServlet {\n\n    private static final long serialVersionUID = -746275386378921292L;\n\n    @Override\n    protected void doGet(HttpServletRequest request,\n                         HttpServletResponse response) throws IOException {\n        doEchoRequest(request, response);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request,\n                         HttpServletResponse response) throws IOException {\n        doEchoRequest(request, response);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void doEchoRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        Echo echo = new Echo();\n        echo.path = request.getPathInfo();\n\n        echo.params = new HashMap<String, String>();\n        ObjectMapper mapper = new ObjectMapper();\n        for ( Map.Entry<String, String[]> entry:  (Set<Map.Entry<String, String[]>>) request.getParameterMap().entrySet() ){\n            if (entry.getValue().length == 1) {\n                echo.params.put(entry.getKey(), entry.getValue()[0]);\n            } else {\n                echo.params.put(entry.getKey(), mapper.writeValueAsString(entry.getValue()));\n            }\n        }\n        response.setContentType(\"application/json\");\n        mapper.writeValue(response.getOutputStream(), echo);\n    }\n\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.server.basic;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.codehaus.jackson.map.ObjectMapper;\nimport org.fusesource.restygwt.client.basic.Echo;\n\n/**\n *\n * just echos back the request path and the request parameters.\n *\n * @author mkristian\n * @author <a href=\"mailto:bogdan.mustiata@gmail.com\">Bogdan Mustiata<\/<a>\n */\npublic class EchoTestGwtServlet extends HttpServlet {\n\n    private static final long serialVersionUID = -746275386378921292L;\n\n    @Override\n    protected void doGet(HttpServletRequest request,\n                         HttpServletResponse response) throws IOException {\n        doEchoRequest(request, response);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request,\n                         HttpServletResponse response) throws IOException {\n        doEchoRequest(request, response);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void doEchoRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        Echo echo = new Echo();\n        echo.path = request.getPathInfo();\n\n        echo.params = new HashMap<String, String>();\n        for ( Map.Entry<String, String[]> entry:  (Set<Map.Entry<String, String[]>>) request.getParameterMap().entrySet() ){\n            echo.params.put(entry.getKey(), entry.getValue()[0]);\n        }\n        response.setContentType(\"application/json\");\n        new ObjectMapper().writeValue(response.getOutputStream(), echo);\n    }\n\n}\n","lineNo":62}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport org.fusesource.restygwt.client.JsonEncoderDecoder;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JParameterizedType;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n */\npublic class ExtendedJsonEncoderDecoderClassCreator extends BaseSourceCreator {\n\n    private static final String JSON_ENCODER_DECODER = JsonEncoderDecoder.class.getName();\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_ExtendedJsonEncoderDecoder_\";\n\n    public ExtendedJsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    protected ClassSourceFileComposerFactory createComposerFactory() throws UnableToCompleteException {\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n        JClassType encodedType = getEncodedType(getLogger(), context, source);\n        JsonEncoderDecoderClassCreator generator = new JsonEncoderDecoderClassCreator(getLogger(), context, encodedType);\n        composerFactory.setSuperclass(generator.create());\n        composerFactory.addImplementedInterface(source.getQualifiedSourceName());\n        return composerFactory;\n    }\n\n    private JClassType getEncodedType(TreeLogger logger, GeneratorContext context, JClassType type) throws UnableToCompleteException {\n        JClassType intf = type.isInterface();\n        if (intf == null) {\n            getLogger().log(ERROR, \"Expected \" + type + \" to be an interface.\");\n            throw new UnableToCompleteException();\n        }\n\n        JClassType[] intfs = intf.getImplementedInterfaces();\n        for (JClassType t : intfs) {\n            getLogger().log(INFO, \"checking: \" + t.getQualifiedSourceName() + \", type: \" + t.getClass());\n            if (t.getQualifiedSourceName().equals(JSON_ENCODER_DECODER)) {\n\n                JParameterizedType genericType = t.isParameterized();\n                if (genericType == null) {\n                    getLogger().log(ERROR, \"Expected the \" + JSON_ENCODER_DECODER + \" declaration to specify a parameterized type.\");\n                    throw new UnableToCompleteException();\n                }\n                JClassType[] typeParameters = genericType.getTypeArgs();\n                if (typeParameters == null || typeParameters.length != 1) {\n                    getLogger().log(ERROR, \"Expected the \" + JSON_ENCODER_DECODER + \" declaration to specify 1 parameterized type.\");\n                    throw new UnableToCompleteException();\n                }\n                final JClassType jClassType = typeParameters[0];\n                return jClassType.isClass() == null ? jClassType.isInterface() : jClassType.isClass();\n            }\n        }\n        getLogger().log(ERROR, \"Expected  \" + type + \" to extend the \" + JSON_ENCODER_DECODER + \" interface.\");\n        throw new UnableToCompleteException();\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n    }\n\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport org.fusesource.restygwt.client.JsonEncoderDecoder;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JParameterizedType;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n */\npublic class ExtendedJsonEncoderDecoderClassCreator extends BaseSourceCreator {\n\n    private static final String JSON_ENCODER_DECODER = JsonEncoderDecoder.class.getName();\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_ExtendedJsonEncoderDecoder_\";\n\n    public ExtendedJsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    protected ClassSourceFileComposerFactory createComposerFactory() throws UnableToCompleteException {\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n        JClassType encodedType = getEncodedType(getLogger(), context, source);\n        JsonEncoderDecoderClassCreator generator = new JsonEncoderDecoderClassCreator(getLogger(), context, encodedType);\n        composerFactory.setSuperclass(generator.create());\n        composerFactory.addImplementedInterface(source.getQualifiedSourceName());\n        return composerFactory;\n    }\n\n    private JClassType getEncodedType(TreeLogger logger, GeneratorContext context, JClassType type) throws UnableToCompleteException {\n        JClassType intf = type.isInterface();\n        if (intf == null) {\n            getLogger().log(ERROR, \"Expected \" + type + \" to be an interface.\");\n            throw new UnableToCompleteException();\n        }\n\n        JClassType[] intfs = intf.getImplementedInterfaces();\n        for (JClassType t : intfs) {\n            getLogger().log(INFO, \"checking: \" + t.getQualifiedSourceName() + \", type: \" + t.getClass());\n            if (t.getQualifiedSourceName().equals(JSON_ENCODER_DECODER)) {\n\n                JParameterizedType genericType = t.isParameterized();\n                if (genericType == null) {\n                    getLogger().log(ERROR, \"Expected the \" + JSON_ENCODER_DECODER + \" declaration to specify a parameterized type.\");\n                    throw new UnableToCompleteException();\n                }\n                JClassType[] typeParameters = genericType.getTypeArgs();\n                if (typeParameters == null || typeParameters.length != 1) {\n                    getLogger().log(ERROR, \"Expected the \" + JSON_ENCODER_DECODER + \" declaration to specify 1 parameterized type.\");\n                    throw new UnableToCompleteException();\n                }\n                return typeParameters[0].isClass();\n            }\n        }\n        getLogger().log(ERROR, \"Expected  \" + type + \" to extend the \" + JSON_ENCODER_DECODER + \" interface.\");\n        throw new UnableToCompleteException();\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n    }\n\n}\n","lineNo":74}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.codehaus.jackson.annotate.JsonCreator;\nimport org.codehaus.jackson.annotate.JsonIgnore;\nimport org.codehaus.jackson.annotate.JsonIgnoreProperties;\nimport org.codehaus.jackson.annotate.JsonProperty;\nimport org.codehaus.jackson.annotate.JsonSubTypes;\nimport org.codehaus.jackson.annotate.JsonTypeInfo;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.As;\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JConstructor;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONNull;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONString;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.thirdparty.guava.common.collect.Lists;\nimport com.google.gwt.thirdparty.guava.common.collect.Maps;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * \n *         Updates: added getter & setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n * \n *         added polymorphic support\n * @author <a href=\"http://charliemason.info\">Charlie Mason<\/a>\n * \n */\n\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_NULL_CLASS = JSONNull.class.getName();\n    private static final String JSON_STRING_CLASS = JSONString.class.getName();\n\n    JsonEncoderDecoderInstanceLocator locator;\n\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n\tsuper(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    @Override\n    public void generate() throws UnableToCompleteException {\n        final JsonTypeInfo typeInfo = findAnnotation(source, JsonTypeInfo.class);\n        final boolean isLeaf = isLeaf(source);\n        \n        final List<Subtype> possibleTypes = getPossibleTypes(typeInfo, isLeaf);\n    \n        JClassType sourceClazz = source.isClass();\n        if (sourceClazz == null) {\n            getLogger().log(ERROR, \"Type is not a class\");\n            throw new UnableToCompleteException();\n        }   \n    \n        if (sourceClazz.isAbstract()) {\n            if (typeInfo == null) {\n                getLogger().log(ERROR, \"Abstract classes must be annotated with JsonTypeInfo\");\n                throw new UnableToCompleteException();\n            }\n        }\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n        final String railsWrapperName = jsonAnnotation != null && jsonAnnotation.name().length() > 0 ? jsonAnnotation.name() : sourceClazz.getName().toLowerCase();\n        locator = new JsonEncoderDecoderInstanceLocator(context, getLogger());\n    \n        generateSingleton(shortName);\n        \n        generateEncodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n        \n        generateDecodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n\tClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n\tcomposerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n\treturn composerFactory;\n    }\n\n    public static <T extends Annotation> T findAnnotation(JClassType clazz, Class<T> annotation) {\n\tif (clazz == null)\n\t    return null;\n\telse if (clazz.isAnnotationPresent(annotation))\n\t    return clazz.getAnnotation(annotation);\n\telse\n\t    return findAnnotation(clazz.getSuperclass(), annotation);\n    }\n\n    private List<Subtype> getPossibleTypes(final JsonTypeInfo typeInfo, final boolean isLeaf) throws UnableToCompleteException\n    {\n        if (typeInfo == null)\n            return Lists.newArrayList(new Subtype(null, source));\n        else {\n            PossibleTypesVisitor v = new PossibleTypesVisitor(context, source, isLeaf, getLogger(), findAnnotation(source, JsonSubTypes.class));\n            return v.visit(typeInfo.use());\n        }\n    }\n\n    private void generateSingleton(String shortName)\n    {\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n    }\n\n    private void generateEncodeMethod(JClassType classType, \n            final Style classStyle, \n            JsonTypeInfo typeInfo, \n            String railsWrapperName, \n            List<Subtype> possibleTypes, \n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {\n            generateEnumEncodeMethod(classType, JSON_VALUE_CLASS);        \n            return;\n        }\n        \n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n            p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n    \n            boolean returnWrapper = false; // if set, return rrc\n    \n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n            if (classStyle == Style.RAILS) {\n            returnWrapper = true;\n            p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n            p(\"rrc.put(\\\"\" + railsWrapperName + \"\\\" , rc);\");\n            }\n    \n            for (Subtype possibleType : possibleTypes) {\n            // Try to find a constuctor that is annotated as creator\n            final JConstructor creator = findCreator(possibleType.clazz);\n            \n                List<JField> orderedFields = creator == null ? null : getOrderedFields(getFields(possibleType.clazz), creator);\n    \n            if (!isLeaf) {\n                // Generate a decoder for each possible type\n                p(\"if(value.getClass().getName().equals(\\\"\" + possibleType.clazz.getQualifiedBinaryName() + \"\\\"))\");\n                p(\"{\");\n            }\n    \n            if (typeInfo != null) {\n                switch (typeInfo.include()) {\n                case PROPERTY:\n                p(\"com.google.gwt.json.client.JSONValue className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\");\");\n                p(\"if( className!=null ) { \").i(1);\n                p(\"rc.put(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \", className);\");\n                i(-1).p(\"}\");\n                break;\n                case WRAPPER_OBJECT:\n                returnWrapper = true;\n                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                p(\"rrc.put(\\\"\" + possibleType.tag + \"\\\", rc);\");\n                break;\n                case WRAPPER_ARRAY:\n                returnWrapper = true;\n                p(JSON_ARRAY_CLASS + \" rrc = new \" + JSON_ARRAY_CLASS + \"();\");\n                p(\"rrc.set(0, org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\"));\");\n                p(\"rrc.set(1, rc);\");\n                }\n            }\n    \n            p(possibleType.clazz.getParameterizedQualifiedSourceName() + \" parseValue = (\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \")value;\");\n    \n            for (final JField field : getFields(possibleType.clazz)) {\n    \n                final String getterName = getGetterName(field);\n\n                boolean ignoreField = false;\n                if(possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null) {\n                    for(String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value()) {\n                        if(s.equals(field.getName())) {\n                            ignoreField = true;\n                            break;\n                        }\n                    }\n                }\n    \n                // If can ignore some fields right off the back..\n                // if there is a creator encode only final fields with JsonProperty annotation\n                if (ignoreField || getterName == null && (field.isStatic() || (field.isFinal() && !(creator != null && orderedFields.contains(field))) || field.isTransient() \n                        || field.isAnnotationPresent(JsonIgnore.class))) {\n                    continue;\n                }\n\n                branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                public Void execute() throws UnableToCompleteException {\n                    // TODO: try to get the field with a setter or\n                    // JSNI\n                    if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n    \n                    Json jsonAnnotation = field.getAnnotation(Json.class);\n                    JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n    \n                    String name = field.getName();\n                    String jsonName = name;\n    \n                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                        jsonName = jsonAnnotation.name();\n                    }\n                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                        jsonName = jsonPropertyAnnotation.value();\n                    }\n    \n                    String fieldExpr = \"parseValue.\" + name;\n                    if (getterName != null) {\n                        fieldExpr = \"parseValue.\" + getterName + \"()\";\n                    }\n    \n                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                    String expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n    \n                    p(\"{\").i(1);\n                    {\n                        if (null != field.getType().isEnum()) {\n                            p(\"if(\" + fieldExpr + \" == null) {\").i(1);\n                            p(\"rc.put(\" + wrap(jsonName) + \", \" + JSON_NULL_CLASS + \".getInstance());\");\n                            i(-1).p(\"} else {\").i(1);\n                        }\n    \n                        p(JSON_VALUE_CLASS + \" v=\" + expression + \";\");\n                        p(\"if( v!=null ) {\").i(1);\n                        {\n                        p(\"rc.put(\" + wrap(jsonName) + \", v);\");\n                        }\n                        i(-1).p(\"}\");\n    \n                        if (null != field.getType().isEnum()) {\n                            i(-1).p(\"}\");\n                        }\n    \n                    }\n                    i(-1).p(\"}\");\n    \n                    } else {\n                        getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                    }\n                    return null;\n                }\n                });\n    \n            }\n    \n            if (returnWrapper) {\n                p(\"return rrc;\");\n            } else {\n                p(\"return rc;\");\n            }\n    \n            if (!isLeaf) {\n                p(\"}\");\n            }\n            }\n    \n            if (!isLeaf) {\n            // Shouldn't get called\n            p(\"return null;\");\n            }\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n\n    private void generateEnumEncodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + jsonValueClass + \" encode(\" + classType.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n        p(\"if( value==null ) {\").i(1);\n        {\n            p(\"return \" + JSON_NULL_CLASS + \".getInstance();\").i(-1);\n        }\n        p(\"}\");\n        p(\"return new \" + JSON_STRING_CLASS + \"(value.name());\");\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n    \n    private void generateDecodeMethod(JClassType classType, \n            final Style classStyle, \n            JsonTypeInfo typeInfo,\n            String railsWrapperName, \n            List<Subtype> possibleTypes, \n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {         \n            generateEnumDecodeMethod(classType, JSON_VALUE_CLASS);\n            return;\n        }\n        \n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n            {\n                p(\"return null;\").i(-1);\n            }\n            p(\"}\");\n            if (classStyle == Style.RAILS) {\n            p(JSON_OBJECT_CLASS + \" object = toObjectFromWrapper(value, \\\"\" + railsWrapperName + \"\\\");\");\n            } else if (typeInfo != null && typeInfo.include() == As.WRAPPER_ARRAY) {\n            p(JSON_ARRAY_CLASS + \" array = (\" + JSON_ARRAY_CLASS + \")value;\");\n            if (!isLeaf)\n                p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(array.get(0));\");\n            p(JSON_OBJECT_CLASS + \" object = toObject(array.get(1));\");\n            } else {\n            p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            }\n    \n            if (!isLeaf && typeInfo != null && typeInfo.include() == As.PROPERTY) {\n            p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \"));\");\n            }\n    \n            for (Subtype possibleType : possibleTypes) {\n            // Try to find a constuctor that is annotated as creator\n            final JConstructor creator = findCreator(possibleType.clazz);\n            if (typeInfo != null) {\n                if (typeInfo.include() == As.WRAPPER_OBJECT) {\n                if (!isLeaf) {\n                    p(\"if(object.containsKey(\\\"\" + possibleType.tag + \"\\\"))\");\n                    p(\"{\");\n                }\n                p(\"object = toObjectFromWrapper(value, \\\"\" + possibleType.tag + \"\\\");\");\n                } else if (!isLeaf) {\n                p(\"if(sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n                p(\"{\");\n                }\n            }\n    \n            List<JField> orderedFields = null;\n            if (creator != null) {\n                p(\"// We found a creator so we use the annotated constructor\");\n                p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"(\");\n                i(1).p(\"// The arguments are placed in the order they appear within the annotated constructor\").i(-1);\n                orderedFields = getOrderedFields(getFields(possibleType.clazz), creator);\n                final JField lastField = orderedFields.get(orderedFields.size() - 1);\n                for (final JField field : orderedFields) {\n                branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                    public Void execute() throws UnableToCompleteException {\n                    Json jsonAnnotation = field.getAnnotation(Json.class);\n                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                    String jsonName = field.getName();\n                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                        jsonName = jsonAnnotation.name();\n                    }\n                    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                    String defaultValue = field.getType().isPrimitive() == null ? \"null\": field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n                    i(1).p(\"\" + (objectGetter + \" == null || \" + objectGetter + \" instanceof \" + JSON_NULL_CLASS + \" ? \" + defaultValue + \" : \" + expression + ((field != lastField) ? \", \" : \"\"))).i(-1);\n                    \n                    return null;\n                    }\n                });\n                }\n                p(\");\");\n            }\n            \n            if (orderedFields == null){\n                p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"();\");\n            }\n            \n                for (final JField field : getFields(possibleType.clazz)) {\n\n                    boolean ignoreField = false;\n                    if(possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null) {\n                        for(String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value()) {\n                            if(s.equals(field.getName())) {\n                                ignoreField = true;\n                                break;\n                            }\n                        }\n                    }\n                    if(ignoreField) {\n                        continue;\n                    }\n\n                if (orderedFields != null && orderedFields.contains(field)){\n                    continue;\n                }\n    \n                final String setterName = getSetterName(field);\n    \n                // If can ignore some fields right off the back..\n                if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient()) || \n                        field.isAnnotationPresent(JsonIgnore.class)) {\n                    continue;\n                }\n    \n                branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                    public Void execute() throws UnableToCompleteException {\n    \n                    // TODO: try to set the field with a setter\n                    // or JSNI\n                    if (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n    \n                        Json jsonAnnotation = field.getAnnotation(Json.class);\n                        Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                        JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n                        \n                        String name = field.getName();\n                        String jsonName = name;\n        \n                        if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                            jsonName = jsonAnnotation.name();\n                        }\n                        if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                            jsonName = jsonPropertyAnnotation.value();\n                        }\n         \n                        String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                        String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n    \n                        String cast = field.getType().isPrimitive() == JPrimitiveType.SHORT ? \"(short) \" : \"\";\n                        p(\"if(\" + objectGetter + \" != null) {\").i(1);\n    \n                        p(\"if(\" + objectGetter + \" instanceof \" + JSON_NULL_CLASS + \") {\").i(1);\n                        String defaultValue = field.getType().isPrimitive() == null ? \"null\": field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n                        \n                        if (setterName != null) {\n                            p(\"rc.\" + setterName + \"(\" + cast + defaultValue + \");\");\n                        } else {\n                            p(\"rc.\" + name + \"=\" + cast + defaultValue + \";\");\n                        }\n    \n                        i(-1).p(\"} else {\").i(1);\n                        \n                        if (setterName != null) {\n                            p(\"rc.\" + setterName + \"(\" + cast + expression + \");\");\n                        } else {\n                            p(\"rc.\" + name + \"=\" + cast + expression + \";\");\n                        }\n                        i(-1).p(\"}\");    \n                        i(-1).p(\"}\");    \n\n                    } else {\n                        getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                    }\n                    return null;\n                    }\n                });\n            }\n            \n            p(\"return rc;\");\n    \n            if (typeInfo != null && !isLeaf) {\n                p(\"}\");\n            }\n            }\n    \n            if (typeInfo != null && !isLeaf) {\n            p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n            p();\n        }\n    }\n\n    private void generateEnumDecodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + classType.getName() + \" decode(\" + jsonValueClass + \" value) {\").i(1);\n        {\n        p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n        {\n            p(\"return null;\").i(-1);\n        }\n        p(\"}\");\n        p(JSON_STRING_CLASS + \" str = value.isString();\");\n        p(\"if( null == str ) {\").i(1);\n        {\n            p(\"throw new DecodingException(\\\"Expected a json string (for enum), but was given: \\\"+value);\").i(-1);\n        }\n        p(\"}\");\n        p(\"return Enum.valueOf(\" + classType.getParameterizedQualifiedSourceName() + \".class, str.stringValue());\").i(-1);\n        }\n        p(\"}\");\n        p();\n    }\n    \n    public static Map<Class<?>, RestyJsonTypeIdResolver> getRestyResolverClassMap(GeneratorContext context, TreeLogger logger) throws UnableToCompleteException {\n\tif (sTypeIdResolverMap == null) {\n\t    try {\n\t\tMap<Class<?>, RestyJsonTypeIdResolver> map = Maps.newHashMap();\n\t\tList<String> values = context.getPropertyOracle().getConfigurationProperty(\"org.fusesource.restygwt.jsontypeidresolver\").getValues();\n\t\tfor (String value : values)\n\t\t    try {\n\t\t\tClass<?> clazz = Class.forName(value);\n\t\t\tRestyJsonTypeIdResolver resolver = (RestyJsonTypeIdResolver) clazz.newInstance();\n\t\t\tmap.put(resolver.getTypeIdResolverClass(), resolver);\n\t\t    } catch (Exception e) {\n\t\t\tlogger.log(WARN, \"Could not access class: \" + values.get(0), e);\n\t\t    }\n\t\t    sTypeIdResolverMap = map;\n\t    } catch (BadPropertyValueException e) {\n\t\tlogger.log(ERROR, \"Could not acccess property: RestyJsonTypeIdResolver\", e);\n\t\tthrow new UnableToCompleteException();\n\t    }\n\t}\n\treturn sTypeIdResolverMap;\n    }\n\n    private List<JField> getOrderedFields(List<JField> fields, JConstructor creator) throws UnableToCompleteException {\n\tList<JField> orderedFields = new ArrayList<JField>();\n\tfor (JParameter param : creator.getParameters()) {\n\t    JsonProperty prop = param.getAnnotation(JsonProperty.class);\n\t    if (prop != null) {\n\t\tfor (JField field : fields) {\n\t\t    if (field.getName().equals(prop.value())) {\n\t\t\torderedFields.add(field);\n\t\t    }\n\t\t}\n\t    } else {\n\t\tgetLogger().log(ERROR, \"a constructor annotated with @JsonCreator requires that all paramaters are annotated with @JsonProperty.\");\n        throw new UnableToCompleteException();\n\t    }\n\t}\n\n\treturn orderedFields;\n    }\n\n    private JConstructor findCreator(JClassType sourceClazz) {\n\tfor (JConstructor constructor : sourceClazz.getConstructors()) {\n\t    if (constructor.getAnnotation(JsonCreator.class) != null) {\n\t\treturn constructor;\n\t    }\n\t}\n\n\treturn null;\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the setter for the specified field or null if a\n     *         setter can't be found.\n     */\n    private String getSetterName(JField field) {\n\tString fieldName = field.getName();\n\tfieldName = \"set\" + upperCaseFirstChar(fieldName);\n\tJClassType type = field.getEnclosingType();\n\tif (exists(type, field, fieldName, true)) {\n\t    return fieldName;\n\t} else {\n\t    return null;\n\t}\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the getter for the specified field or null if a\n     *         getter can't be found.\n     */\n    private String getGetterName(JField field) {\n\tString fieldName = field.getName();\n\tJType booleanType = null;\n\ttry {\n\t    booleanType = find(Boolean.class, getLogger(), context);\n\t} catch (UnableToCompleteException e) {\n\t    // do nothing\n\t}\n\tJClassType type = field.getEnclosingType();\n\tif (field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)) {\n\t    fieldName = \"is\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t    fieldName = \"has\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t}\n\tfieldName = \"get\" + upperCaseFirstChar(field.getName());\n\tif (exists(type, field, fieldName, false)) {\n\t    return fieldName;\n\t} else {\n\t    return null;\n\t}\n    }\n\n    private String upperCaseFirstChar(String in) {\n\tif (in.length() == 1) {\n\t    return in.toUpperCase();\n\t} else {\n\t    return in.substring(0, 1).toUpperCase() + in.substring(1);\n\t}\n    }\n\n    /**\n     * checks whether a getter or setter exists on the specified type or any of\n     * its super classes excluding Object. respects JsonIgnore accordingly. \n     * \n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {\n        if ( field instanceof DummyJField ){\n            return true;\n        }\n        \n\tJType[] args = null;\n\tif (isSetter) {\n\t    args = new JType[] { field.getType() };\n\t} else {\n\t    args = new JType[] {};\n\t}\n\tJMethod m = type.findMethod(fieldName, args);\n\tif (null != m) {\n\t    return m.getAnnotation( JsonIgnore.class ) == null && (isSetter || m.getReturnType().equals( field.getType() ) );\n\t} else {\n\t    try {\n\t\tJType objectType = find(Object.class, getLogger(), context);\n\t\tJClassType superType = type.getSuperclass();\n\t\tif (!objectType.equals(superType)) {\n\t\t    return exists(superType, field, fieldName, isSetter);\n\t\t}\n\t    } catch (UnableToCompleteException e) {\n\t\t// do nothing\n\t    }\n\t}\n\treturn false;\n    }\n\n    /**\n     * Inspects the supplied type and all super classes up to but excluding\n     * Object and returns a list of all fields found in these classes.\n     * \n     * @param type\n     * @return\n     */\n    private List<JField> getFields(JClassType type) {\n        List<JField> allFields = getFields(new ArrayList<JField>(), type);\n        Map<String, JMethod> getters = new HashMap<String, JMethod>();\n        Map<String, JType> setters = new HashMap<String, JType>();\n        for( JMethod m: type.getInheritableMethods() ){\n            if( m.getName().startsWith(\"set\") && \n                    m.getParameterTypes().length == 1 && \n                    m.getReturnType() == JPrimitiveType.VOID && \n                    m.getAnnotation(JsonIgnore.class) == null){\n                setters.put( m.getName().replaceFirst(\"^set\", \"\"), m.getParameterTypes()[0] );\n            }\n            else if( m.getName().startsWith(\"get\") && \n                    m.getParameterTypes().length == 0 &&\n                    m.getReturnType() != JPrimitiveType.VOID && \n                    m.getAnnotation(JsonIgnore.class) == null){\n                getters.put( m.getName().replaceFirst(\"^get\", \"\"), m );\n            }\n        }\n        for( Map.Entry<String, JMethod> entry: getters.entrySet() ){\n            if ( setters.containsKey( entry.getKey() ) && setters.get( entry.getKey() ).equals( entry.getValue().getReturnType() ) ) {\n                String name = entry.getKey().substring(0, 1).toLowerCase() + entry.getKey().substring(1);\n\n                boolean found = false;\n                for( JField f : allFields ){\n                    if( f.getName().equals( name ) ){\n                        found = true;\n                        break;\n                    }\n                }\n                JField f = type.getField( name );\n                if ( ! found && !( f != null && f.isAnnotationPresent( JsonIgnore.class ) ) ){\n                    DummyJField dummy = new DummyJField( name, entry.getValue().getReturnType() );\n                    if ( entry.getValue().isAnnotationPresent(JsonProperty.class) ) { \n                        dummy.setAnnotation( entry.getValue().getAnnotation(JsonProperty.class) );\n                    }\n                    allFields.add( dummy );\n                }\n            }\n        }\n        return allFields;\n    }\n\n    private List<JField> getFields(List<JField> allFields, JClassType type) {\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n            if (!field.isTransient() && !field.isAnnotationPresent(JsonIgnore.class)) {\n                allFields.add(field);\n            }\n        }\n        try {\n            JType objectType = find(Object.class, getLogger(), context);\n            if (!objectType.equals(type)) {\n                JClassType superType = type.getSuperclass();\n                return getFields(allFields, superType);\n            }\n        }\n        catch (UnableToCompleteException e) {\n\t    // do nothing\n        }\n        \n    \treturn allFields;\n    }\n    \n    public static String getTypeInfoPropertyValue(final JsonTypeInfo typeInfo)\n    {\n        if (typeInfo.include() == JsonTypeInfo.As.PROPERTY)\n            if(typeInfo.property() == null || \"\".equals(typeInfo.property()))\n                return typeInfo.use().getDefaultPropertyName();\n        \n        return typeInfo.property();\n    }\n    \n    public static boolean isLeaf(JClassType source)\n    {\n        return !(source.getSubtypes() != null && source.getSubtypes().length > 0);\n    }\n\n    public static class Subtype {\n    final String tag;\n    final JClassType clazz;\n    \n    public Subtype(String tag, JClassType clazz) {\n        this.tag = tag;\n        this.clazz = clazz;\n    }\n    }\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> sTypeIdResolverMap = null;\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.codehaus.jackson.annotate.JsonCreator;\nimport org.codehaus.jackson.annotate.JsonIgnore;\nimport org.codehaus.jackson.annotate.JsonIgnoreProperties;\nimport org.codehaus.jackson.annotate.JsonProperty;\nimport org.codehaus.jackson.annotate.JsonSubTypes;\nimport org.codehaus.jackson.annotate.JsonTypeInfo;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.As;\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JConstructor;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONNull;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONString;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.thirdparty.guava.common.collect.Lists;\nimport com.google.gwt.thirdparty.guava.common.collect.Maps;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * \n *         Updates: added getter & setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n * \n *         added polymorphic support\n * @author <a href=\"http://charliemason.info\">Charlie Mason<\/a>\n * \n */\n\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_NULL_CLASS = JSONNull.class.getName();\n    private static final String JSON_STRING_CLASS = JSONString.class.getName();\n\n    JsonEncoderDecoderInstanceLocator locator;\n\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n\tsuper(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    @Override\n    public void generate() throws UnableToCompleteException {\n        final JsonTypeInfo typeInfo = findAnnotation(source, JsonTypeInfo.class);\n        final boolean isLeaf = isLeaf(source);\n        \n        final List<Subtype> possibleTypes = getPossibleTypes(typeInfo, isLeaf);\n    \n        JClassType sourceClazz = source.isClass();\n        if (sourceClazz == null) {\n            getLogger().log(ERROR, \"Type is not a class\");\n            throw new UnableToCompleteException();\n        }   \n    \n        if (sourceClazz.isAbstract()) {\n            if (typeInfo == null) {\n                getLogger().log(ERROR, \"Abstract classes must be annotated with JsonTypeInfo\");\n                throw new UnableToCompleteException();\n            }\n        }\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n        final String railsWrapperName = jsonAnnotation != null && jsonAnnotation.name().length() > 0 ? jsonAnnotation.name() : sourceClazz.getName().toLowerCase();\n        locator = new JsonEncoderDecoderInstanceLocator(context, getLogger());\n    \n        generateSingleton(shortName);\n        \n        generateEncodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n        \n        generateDecodeMethod(source, classStyle, typeInfo, railsWrapperName, possibleTypes, isLeaf, locator);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n\tClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n\tcomposerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n\treturn composerFactory;\n    }\n\n    public static <T extends Annotation> T findAnnotation(JClassType clazz, Class<T> annotation) {\n\tif (clazz == null)\n\t    return null;\n\telse if (clazz.isAnnotationPresent(annotation))\n\t    return clazz.getAnnotation(annotation);\n\telse\n\t    return findAnnotation(clazz.getSuperclass(), annotation);\n    }\n\n    private List<Subtype> getPossibleTypes(final JsonTypeInfo typeInfo, final boolean isLeaf) throws UnableToCompleteException\n    {\n        if (typeInfo == null)\n            return Lists.newArrayList(new Subtype(null, source));\n        else {\n            PossibleTypesVisitor v = new PossibleTypesVisitor(context, source, isLeaf, getLogger(), findAnnotation(source, JsonSubTypes.class));\n            return v.visit(typeInfo.use());\n        }\n    }\n\n    private void generateSingleton(String shortName)\n    {\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n    }\n\n    private void generateEncodeMethod(JClassType classType, \n            final Style classStyle, \n            JsonTypeInfo typeInfo, \n            String railsWrapperName, \n            List<Subtype> possibleTypes, \n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {\n            generateEnumEncodeMethod(classType, JSON_VALUE_CLASS);        \n            return;\n        }\n        \n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n            p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n    \n            boolean returnWrapper = false; // if set, return rrc\n    \n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n            if (classStyle == Style.RAILS) {\n            returnWrapper = true;\n            p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n            p(\"rrc.put(\\\"\" + railsWrapperName + \"\\\" , rc);\");\n            }\n    \n            for (Subtype possibleType : possibleTypes) {\n            // Try to find a constuctor that is annotated as creator\n            final JConstructor creator = findCreator(possibleType.clazz);\n            \n                List<JField> orderedFields = creator == null ? null : getOrderedFields(getFields(possibleType.clazz), creator);\n    \n            if (!isLeaf) {\n                // Generate a decoder for each possible type\n                p(\"if(value.getClass().getName().equals(\\\"\" + possibleType.clazz.getQualifiedBinaryName() + \"\\\"))\");\n                p(\"{\");\n            }\n    \n            if (typeInfo != null) {\n                switch (typeInfo.include()) {\n                case PROPERTY:\n                p(\"com.google.gwt.json.client.JSONValue className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\");\");\n                p(\"if( className!=null ) { \").i(1);\n                p(\"rc.put(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \", className);\");\n                i(-1).p(\"}\");\n                break;\n                case WRAPPER_OBJECT:\n                returnWrapper = true;\n                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                p(\"rrc.put(\\\"\" + possibleType.tag + \"\\\", rc);\");\n                break;\n                case WRAPPER_ARRAY:\n                returnWrapper = true;\n                p(JSON_ARRAY_CLASS + \" rrc = new \" + JSON_ARRAY_CLASS + \"();\");\n                p(\"rrc.set(0, org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\"));\");\n                p(\"rrc.set(1, rc);\");\n                }\n            }\n    \n            p(possibleType.clazz.getParameterizedQualifiedSourceName() + \" parseValue = (\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \")value;\");\n    \n            for (final JField field : getFields(possibleType.clazz)) {\n    \n                final String getterName = getGetterName(field);\n\n                boolean ignoreField = false;\n                if(possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null) {\n                    for(String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value()) {\n                        if(s.equals(field.getName())) {\n                            ignoreField = true;\n                            break;\n                        }\n                    }\n                }\n    \n                // If can ignore some fields right off the back..\n                // if there is a creator encode only final fields with JsonProperty annotation\n                if (ignoreField || getterName == null && (field.isStatic() || (field.isFinal() && !(creator != null && orderedFields.contains(field))) || field.isTransient() \n                        || field.isAnnotationPresent(JsonIgnore.class))) {\n                    continue;\n                }\n\n                branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                public Void execute() throws UnableToCompleteException {\n                    // TODO: try to get the field with a setter or\n                    // JSNI\n                    if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n    \n                    Json jsonAnnotation = field.getAnnotation(Json.class);\n                    JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n    \n                    String name = field.getName();\n                    String jsonName = name;\n    \n                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                        jsonName = jsonAnnotation.name();\n                    }\n                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                        jsonName = jsonPropertyAnnotation.value();\n                    }\n    \n                    String fieldExpr = \"parseValue.\" + name;\n                    if (getterName != null) {\n                        fieldExpr = \"parseValue.\" + getterName + \"()\";\n                    }\n    \n                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                    String expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n    \n                    p(\"{\").i(1);\n                    {\n                        if (null != field.getType().isEnum()) {\n                            p(\"if(\" + fieldExpr + \" == null) {\").i(1);\n                            p(\"rc.put(\" + wrap(jsonName) + \", \" + JSON_NULL_CLASS + \".getInstance());\");\n                            i(-1).p(\"} else {\").i(1);\n                        }\n    \n                        p(JSON_VALUE_CLASS + \" v=\" + expression + \";\");\n                        p(\"if( v!=null ) {\").i(1);\n                        {\n                        p(\"rc.put(\" + wrap(jsonName) + \", v);\");\n                        }\n                        i(-1).p(\"}\");\n    \n                        if (null != field.getType().isEnum()) {\n                            i(-1).p(\"}\");\n                        }\n    \n                    }\n                    i(-1).p(\"}\");\n    \n                    } else {\n                        getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                    }\n                    return null;\n                }\n                });\n    \n            }\n    \n            if (returnWrapper) {\n                p(\"return rrc;\");\n            } else {\n                p(\"return rc;\");\n            }\n    \n            if (!isLeaf) {\n                p(\"}\");\n            }\n            }\n    \n            if (!isLeaf) {\n            // Shouldn't get called\n            p(\"return null;\");\n            }\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n\n    private void generateEnumEncodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + jsonValueClass + \" encode(\" + classType.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n        p(\"if( value==null ) {\").i(1);\n        {\n            p(\"return \" + JSON_NULL_CLASS + \".getInstance();\").i(-1);\n        }\n        p(\"}\");\n        p(\"return new \" + JSON_STRING_CLASS + \"(value.name());\");\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n    \n    private void generateDecodeMethod(JClassType classType, \n            final Style classStyle, \n            JsonTypeInfo typeInfo,\n            String railsWrapperName, \n            List<Subtype> possibleTypes, \n            boolean isLeaf,\n            final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != classType.isEnum()) {         \n            generateEnumDecodeMethod(classType, JSON_VALUE_CLASS);\n            return;\n        }\n        \n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n            {\n                p(\"return null;\").i(-1);\n            }\n            p(\"}\");\n            if (classStyle == Style.RAILS) {\n            p(JSON_OBJECT_CLASS + \" object = toObjectFromWrapper(value, \\\"\" + railsWrapperName + \"\\\");\");\n            } else if (typeInfo != null && typeInfo.include() == As.WRAPPER_ARRAY) {\n            p(JSON_ARRAY_CLASS + \" array = (\" + JSON_ARRAY_CLASS + \")value;\");\n            if (!isLeaf)\n                p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(array.get(0));\");\n            p(JSON_OBJECT_CLASS + \" object = toObject(array.get(1));\");\n            } else {\n            p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            }\n    \n            if (!isLeaf && typeInfo != null && typeInfo.include() == As.PROPERTY) {\n            p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" + wrap(getTypeInfoPropertyValue(typeInfo)) + \"));\");\n            }\n    \n            for (Subtype possibleType : possibleTypes) {\n            // Try to find a constuctor that is annotated as creator\n            final JConstructor creator = findCreator(possibleType.clazz);\n            if (typeInfo != null) {\n                if (typeInfo.include() == As.WRAPPER_OBJECT) {\n                if (!isLeaf) {\n                    p(\"if(object.containsKey(\\\"\" + possibleType.tag + \"\\\"))\");\n                    p(\"{\");\n                }\n                p(\"object = toObjectFromWrapper(value, \\\"\" + possibleType.tag + \"\\\");\");\n                } else if (!isLeaf) {\n                p(\"if(sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n                p(\"{\");\n                }\n            }\n    \n            List<JField> orderedFields = null;\n            if (creator != null) {\n                p(\"// We found a creator so we use the annotated constructor\");\n                p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"(\");\n                i(1).p(\"// The arguments are placed in the order they appear within the annotated constructor\").i(-1);\n                orderedFields = getOrderedFields(getFields(possibleType.clazz), creator);\n                final JField lastField = orderedFields.get(orderedFields.size() - 1);\n                for (final JField field : orderedFields) {\n                branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                    public Void execute() throws UnableToCompleteException {\n                    Json jsonAnnotation = field.getAnnotation(Json.class);\n                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                    String jsonName = field.getName();\n                    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                        jsonName = jsonAnnotation.name();\n                    }\n                    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                    String defaultValue = field.getType().isPrimitive() == null ? \"null\": field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n                    i(1).p(\"\" + (objectGetter + \" == null || \" + objectGetter + \" instanceof \" + JSON_NULL_CLASS + \" ? \" + defaultValue + \" : \" + expression + ((field != lastField) ? \", \" : \"\"))).i(-1);\n                    \n                    return null;\n                    }\n                });\n                }\n                p(\");\");\n            }\n            \n            if (orderedFields == null){\n                p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"();\");\n            }\n            \n                for (final JField field : getFields(possibleType.clazz)) {\n\n                    boolean ignoreField = false;\n                    if(possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null) {\n                        for(String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value()) {\n                            if(s.equals(field.getName())) {\n                                ignoreField = true;\n                                break;\n                            }\n                        }\n                    }\n                    if(ignoreField) {\n                        continue;\n                    }\n\n                if (orderedFields != null && orderedFields.contains(field)){\n                    continue;\n                }\n    \n                final String setterName = getSetterName(field);\n    \n                // If can ignore some fields right off the back..\n                if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient()) || \n                        field.isAnnotationPresent(JsonIgnore.class)) {\n                    continue;\n                }\n    \n                branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                    public Void execute() throws UnableToCompleteException {\n    \n                    // TODO: try to set the field with a setter\n                    // or JSNI\n                    if (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n    \n                        Json jsonAnnotation = field.getAnnotation(Json.class);\n                        Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                        JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n                        \n                        String name = field.getName();\n                        String jsonName = name;\n        \n                        if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                            jsonName = jsonAnnotation.name();\n                        }\n                        if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                            jsonName = jsonPropertyAnnotation.value();\n                        }\n         \n                        String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                        String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n    \n                        String cast = field.getType().isPrimitive() == JPrimitiveType.SHORT ? \"(short) \" : \"\";\n                        p(\"if(\" + objectGetter + \" != null) {\").i(1);\n    \n                        p(\"if(\" + objectGetter + \" instanceof \" + JSON_NULL_CLASS + \") {\").i(1);\n                        String defaultValue = field.getType().isPrimitive() == null ? \"null\": field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n                        \n                        if (setterName != null) {\n                            p(\"rc.\" + setterName + \"(\" + cast + defaultValue + \");\");\n                        } else {\n                            p(\"rc.\" + name + \"=\" + cast + defaultValue + \";\");\n                        }\n    \n                        i(-1).p(\"} else {\").i(1);\n                        \n                        if (setterName != null) {\n                            p(\"rc.\" + setterName + \"(\" + cast + expression + \");\");\n                        } else {\n                            p(\"rc.\" + name + \"=\" + cast + expression + \";\");\n                        }\n                        i(-1).p(\"}\");    \n                        i(-1).p(\"}\");    \n\n                    } else {\n                        getLogger().log(DEBUG, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                    }\n                    return null;\n                    }\n                });\n            }\n            \n            p(\"return rc;\");\n    \n            if (typeInfo != null && !isLeaf) {\n                p(\"}\");\n            }\n            }\n    \n            if (typeInfo != null && !isLeaf) {\n            p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n            p();\n        }\n    }\n\n    private void generateEnumDecodeMethod(JClassType classType, String jsonValueClass)\n    {\n        p();\n        p(\"public \" + classType.getName() + \" decode(\" + jsonValueClass + \" value) {\").i(1);\n        {\n        p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n        {\n            p(\"return null;\").i(-1);\n        }\n        p(\"}\");\n        p(JSON_STRING_CLASS + \" str = value.isString();\");\n        p(\"if( null == str ) {\").i(1);\n        {\n            p(\"throw new DecodingException(\\\"Expected a json string (for enum), but was given: \\\"+value);\").i(-1);\n        }\n        p(\"}\");\n        p(\"return Enum.valueOf(\" + classType.getParameterizedQualifiedSourceName() + \".class, str.stringValue());\").i(-1);\n        }\n        p(\"}\");\n        p();\n    }\n    \n    public static Map<Class<?>, RestyJsonTypeIdResolver> getRestyResolverClassMap(GeneratorContext context, TreeLogger logger) throws UnableToCompleteException {\n\tif (sTypeIdResolverMap == null) {\n\t    try {\n\t\tMap<Class<?>, RestyJsonTypeIdResolver> map = Maps.newHashMap();\n\t\tList<String> values = context.getPropertyOracle().getConfigurationProperty(\"org.fusesource.restygwt.jsontypeidresolver\").getValues();\n\t\tfor (String value : values)\n\t\t    try {\n\t\t\tClass<?> clazz = Class.forName(value);\n\t\t\tRestyJsonTypeIdResolver resolver = (RestyJsonTypeIdResolver) clazz.newInstance();\n\t\t\tmap.put(resolver.getTypeIdResolverClass(), resolver);\n\t\t    } catch (Exception e) {\n\t\t\tlogger.log(WARN, \"Could not access class: \" + values.get(0), e);\n\t\t    }\n\t\t    sTypeIdResolverMap = map;\n\t    } catch (BadPropertyValueException e) {\n\t\tlogger.log(ERROR, \"Could not acccess property: RestyJsonTypeIdResolver\", e);\n\t\tthrow new UnableToCompleteException();\n\t    }\n\t}\n\treturn sTypeIdResolverMap;\n    }\n\n    private List<JField> getOrderedFields(List<JField> fields, JConstructor creator) throws UnableToCompleteException {\n\tList<JField> orderedFields = new ArrayList<JField>();\n\tfor (JParameter param : creator.getParameters()) {\n\t    JsonProperty prop = param.getAnnotation(JsonProperty.class);\n\t    if (prop != null) {\n\t\tfor (JField field : fields) {\n\t\t    if (field.getName().equals(prop.value())) {\n\t\t\torderedFields.add(field);\n\t\t    }\n\t\t}\n\t    } else {\n\t\tgetLogger().log(ERROR, \"a constructor annotated with @JsonCreator requires that all paramaters are annotated with @JsonProperty.\");\n        throw new UnableToCompleteException();\n\t    }\n\t}\n\n\treturn orderedFields;\n    }\n\n    private JConstructor findCreator(JClassType sourceClazz) {\n\tfor (JConstructor constructor : sourceClazz.getConstructors()) {\n\t    if (constructor.getAnnotation(JsonCreator.class) != null) {\n\t\treturn constructor;\n\t    }\n\t}\n\n\treturn null;\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the setter for the specified field or null if a\n     *         setter can't be found.\n     */\n    private String getSetterName(JField field) {\n\tString fieldName = field.getName();\n\tfieldName = \"set\" + upperCaseFirstChar(fieldName);\n\tJClassType type = field.getEnclosingType();\n\tif (exists(type, field, fieldName, true)) {\n\t    return fieldName;\n\t} else {\n\t    return null;\n\t}\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the getter for the specified field or null if a\n     *         getter can't be found.\n     */\n    private String getGetterName(JField field) {\n\tString fieldName = field.getName();\n\tJType booleanType = null;\n\ttry {\n\t    booleanType = find(Boolean.class, getLogger(), context);\n\t} catch (UnableToCompleteException e) {\n\t    // do nothing\n\t}\n\tJClassType type = field.getEnclosingType();\n\tif (field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)) {\n\t    fieldName = \"is\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t    fieldName = \"has\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t}\n\tfieldName = \"get\" + upperCaseFirstChar(field.getName());\n\tif (exists(type, field, fieldName, false)) {\n\t    return fieldName;\n\t} else {\n\t    return null;\n\t}\n    }\n\n    private String upperCaseFirstChar(String in) {\n\tif (in.length() == 1) {\n\t    return in.toUpperCase();\n\t} else {\n\t    return in.substring(0, 1).toUpperCase() + in.substring(1);\n\t}\n    }\n\n    /**\n     * checks whether a getter or setter exists on the specified type or any of\n     * its super classes excluding Object.\n     * \n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {\n        if ( field instanceof DummyJField ){\n            return true;\n        }\n        \n\tJType[] args = null;\n\tif (isSetter) {\n\t    args = new JType[] { field.getType() };\n\t} else {\n\t    args = new JType[] {};\n\t}\n\n\tif (null != type.findMethod(fieldName, args)) {\n\t    return true;\n\t} else {\n\t    try {\n\t\tJType objectType = find(Object.class, getLogger(), context);\n\t\tJClassType superType = type.getSuperclass();\n\t\tif (!objectType.equals(superType)) {\n\t\t    return exists(superType, field, fieldName, isSetter);\n\t\t}\n\t    } catch (UnableToCompleteException e) {\n\t\t// do nothing\n\t    }\n\t}\n\treturn false;\n    }\n\n    /**\n     * Inspects the supplied type and all super classes up to but excluding\n     * Object and returns a list of all fields found in these classes.\n     * \n     * @param type\n     * @return\n     */\n    private List<JField> getFields(JClassType type) {\n        List<JField> allFields = getFields(new ArrayList<JField>(), type);\n        Map<String, JMethod> getters = new HashMap<String, JMethod>();\n        Map<String, JType> setters = new HashMap<String, JType>();\n        for( JMethod m: type.getInheritableMethods() ){\n            if( m.getName().startsWith(\"set\") && m.getParameterTypes().length == 1 && m.getReturnType() == JPrimitiveType.VOID){\n                setters.put( m.getName().replaceFirst(\"^set\", \"\"), m.getParameterTypes()[0] );\n            }\n            else if( m.getName().startsWith(\"get\") && m.getParameterTypes().length == 0 &&  m.getReturnType() != JPrimitiveType.VOID){\n                getters.put( m.getName().replaceFirst(\"^get\", \"\"), m );\n            }\n        }\n        for( Map.Entry<String, JMethod> entry: getters.entrySet() ){\n            if ( setters.containsKey( entry.getKey() ) && setters.get( entry.getKey() ).equals( entry.getValue().getReturnType() ) ) {\n                String name = entry.getKey().substring(0, 1).toLowerCase() + entry.getKey().substring(1);\n\n                boolean found = false;\n                for( JField f : allFields ){\n                    if( f.getName().equals( name ) ){\n                        found = true;\n                        break;\n                    }\n                }\n                JField f = type.getField( name );\n                if ( ! found && !( f != null && f.isAnnotationPresent( JsonIgnore.class ) ) ){\n                    DummyJField dummy = new DummyJField( name, entry.getValue().getReturnType() );\n                    if ( entry.getValue().isAnnotationPresent(JsonProperty.class) ) { \n                        dummy.setAnnotation( entry.getValue().getAnnotation(JsonProperty.class) );\n                    }\n                    allFields.add( dummy );\n                }\n            }\n        }\n        return allFields;\n    }\n\n    private List<JField> getFields(List<JField> allFields, JClassType type) {\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n            if (!field.isTransient() && !field.isAnnotationPresent(JsonIgnore.class)) {\n                allFields.add(field);\n            }\n        }\n        try {\n            JType objectType = find(Object.class, getLogger(), context);\n            if (!objectType.equals(type)) {\n                JClassType superType = type.getSuperclass();\n                return getFields(allFields, superType);\n            }\n        }\n        catch (UnableToCompleteException e) {\n\t    // do nothing\n        }\n        \n    \treturn allFields;\n    }\n    \n    public static String getTypeInfoPropertyValue(final JsonTypeInfo typeInfo)\n    {\n        if (typeInfo.include() == JsonTypeInfo.As.PROPERTY)\n            if(typeInfo.property() == null || \"\".equals(typeInfo.property()))\n                return typeInfo.use().getDefaultPropertyName();\n        \n        return typeInfo.property();\n    }\n    \n    public static boolean isLeaf(JClassType source)\n    {\n        return !(source.getSubtypes() != null && source.getSubtypes().length > 0);\n    }\n\n    public static class Subtype {\n    final String tag;\n    final JClassType clazz;\n    \n    public Subtype(String tag, JClassType clazz) {\n        this.tag = tag;\n        this.clazz = clazz;\n    }\n    }\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> sTypeIdResolverMap = null;\n}\n","lineNo":661}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport com.google.gwt.core.client.*;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.*;\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.jsonp.client.JsonpRequest;\nimport com.google.gwt.user.client.rpc.RemoteServiceRelativePath;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport com.google.gwt.xml.client.Document;\nimport org.fusesource.restygwt.client.*;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport javax.ws.rs.*;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\nimport java.util.regex.Pattern;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added automatically create resource from Path annotation,\n *         enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\npublic class RestServiceClassCreator extends BaseSourceCreator {\n\n    private static final String REST_SERVICE_PROXY_SUFFIX = \"_Generated_RestServiceProxy_\";\n\n    private static final String METHOD_CLASS = Method.class.getName();\n    private static final String RESOURCE_CLASS = Resource.class.getName();\n    private static final String DISPATCHER_CLASS = Dispatcher.class.getName();\n    private static final String DEFAULTS_CLASS = Defaults.class.getName();\n    private static final String ABSTRACT_REQUEST_CALLBACK_CLASS = AbstractRequestCallback.class.getName();\n    private static final String ABSTRACT_ASYNC_CALLBACK_CLASS = AbstractAsyncCallback.class.getName();\n    private static final String JSON_PARSER_CLASS = JSONParser.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String REQUEST_EXCEPTION_CLASS = RequestException.class.getName();\n    private static final String RESPONSE_FORMAT_EXCEPTION_CLASS = ResponseFormatException.class.getName();\n    private static final String JSONP_METHOD_CLASS = JsonpMethod.class.getName();\n    private static final String FORM_POST_CONTENT_CLASS = FormPostContent.class.getName();\n\n    /*\n     * static class in which are some compile-time relevant infos.\n     *\n     * TODO (andi): too much flexibility and overhead with reflection here?\n     */\n    private static final Class<BindingDefaults> BINDING_DEFAULTS = BindingDefaults.class;\n\n    private static final String METHOD_JSONP = \"jsonp\";\n    private static final String METHOD_PUT = \"put\";\n    private static final String METHOD_POST = \"post\";\n    private static final String METHOD_OPTIONS = \"options\";\n    private static final String METHOD_HEAD = \"head\";\n    private static final String METHOD_GET = \"get\";\n    private static final String METHOD_DELETE = \"delete\";\n\n    private static final HashSet<String> REST_METHODS = new HashSet<String>(8);\n    static {\n        REST_METHODS.add(METHOD_DELETE);\n        REST_METHODS.add(METHOD_GET);\n        REST_METHODS.add(METHOD_HEAD);\n        REST_METHODS.add(METHOD_OPTIONS);\n        REST_METHODS.add(METHOD_POST);\n        REST_METHODS.add(METHOD_PUT);\n        REST_METHODS.add(METHOD_JSONP);\n    }\n\n    private JClassType XML_CALLBACK_TYPE;\n    private JClassType METHOD_CALLBACK_TYPE;\n    private JClassType TEXT_CALLBACK_TYPE;\n    private JClassType JSON_CALLBACK_TYPE;\n    private JClassType OVERLAY_CALLBACK_TYPE;\n    private JClassType DOCUMENT_TYPE;\n    private JClassType METHOD_TYPE;\n    private JClassType STRING_TYPE;\n    private JClassType JSON_VALUE_TYPE;\n    private JClassType OVERLAY_VALUE_TYPE;\n    private Set<JClassType> OVERLAY_ARRAY_TYPES;\n    private Set<JClassType> QUERY_PARAM_LIST_TYPES;\n    private JClassType REST_SERVICE_TYPE;\n    private JsonEncoderDecoderInstanceLocator locator;\n\n    public RestServiceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n        super(logger, context, source, REST_SERVICE_PROXY_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n    \tString parameters = \"\";\n    \tif(source instanceof JGenericType)\n    \t{\n    \t\tJGenericType gtype = (JGenericType)source;\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tbuilder.append(\"<\");\n\t\t\tboolean first = true;\n   \t\t\tfor(JTypeParameter arg : gtype.getTypeParameters())\n   \t\t\t{\n   \t\t\t\tif(!first)\n   \t\t\t\t\tbuilder.append(\",\");\n   \t\t\t\tbuilder.append(arg.getName());\n   \t\t\t\tbuilder.append(\" extends \");\n\t   \t\t\tbuilder.append(arg.getFirstBound().getParameterizedQualifiedSourceName());\n\t   \t\t\tfirst = false;\n   \t\t\t}\n   \t\t\tbuilder.append(\">\");\n   \t\t\tparameters = builder.toString();\n     \t}\n    \t\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName + parameters);\n        composerFactory.addImplementedInterface(source.getParameterizedQualifiedSourceName());\n        composerFactory.addImplementedInterface(RestServiceProxy.class.getName());\n        return composerFactory;\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n\n        if (source.isInterface() == null) {\n            getLogger().log(ERROR, \"Type is not an interface.\");\n            throw new UnableToCompleteException();\n        }\n\n        locator = new JsonEncoderDecoderInstanceLocator(context, getLogger());\n\n        this.XML_CALLBACK_TYPE = find(XmlCallback.class, getLogger(), context);\n        this.METHOD_CALLBACK_TYPE = find(MethodCallback.class, getLogger(), context);\n        this.TEXT_CALLBACK_TYPE = find(TextCallback.class, getLogger(), context);\n        this.JSON_CALLBACK_TYPE = find(JsonCallback.class, getLogger(), context);\n        this.OVERLAY_CALLBACK_TYPE = find(OverlayCallback.class, getLogger(), context);\n        this.DOCUMENT_TYPE = find(Document.class, getLogger(), context);\n        this.METHOD_TYPE = find(Method.class, getLogger(), context);\n        this.STRING_TYPE = find(String.class, getLogger(), context);\n        this.JSON_VALUE_TYPE = find(JSONValue.class, getLogger(), context);\n        this.OVERLAY_VALUE_TYPE = find(JavaScriptObject.class, getLogger(), context);\n        this.OVERLAY_ARRAY_TYPES = new HashSet<JClassType>();\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArray.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayBoolean.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayInteger.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayNumber.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayString.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES = new HashSet<JClassType>();\n        this.QUERY_PARAM_LIST_TYPES.add(find(List.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES.add(find(Set.class, getLogger(), context));\n\t\tthis.REST_SERVICE_TYPE = find(RestService.class, getLogger(), context);\n\t\t\n        String path = null;\n        Path pathAnnotation = source.getAnnotation(Path.class);\n        if (pathAnnotation != null) {\n            path = pathAnnotation.value();\n        }\n\n        RemoteServiceRelativePath relativePath = source.getAnnotation(RemoteServiceRelativePath.class);\n        if (relativePath != null) {\n            path = relativePath.value();\n        }\n\n        p(\"private \" + RESOURCE_CLASS + \" resource = null;\");\n        p();\n\n        p(\"public void setResource(\" + RESOURCE_CLASS + \" resource) {\").i(1);\n        {\n            p(\"this.resource = resource;\");\n        }\n        i(-1).p(\"}\");\n\n        p(\"public \" + RESOURCE_CLASS + \" getResource() {\").i(1);\n        {\n            p(\"if (this.resource == null) {\").i(1);\n            if (path == null) {\n                p(\"this.resource = new \" + RESOURCE_CLASS + \"(\" + DEFAULTS_CLASS + \".getServiceRoot());\");\n            } else {\n                p(\"this.resource = new \" + RESOURCE_CLASS + \"(\" + DEFAULTS_CLASS + \".getServiceRoot()).resolve(\"+quote(path)+\");\");\n            }\n            i(-1).p(\"}\");\n            p(\"return this.resource;\");\n        }\n        i(-1).p(\"}\");\n\n\n        Options options = source.getAnnotation(Options.class);\n        if( options!=null && options.dispatcher()!=Dispatcher.class ) {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = \"+options.dispatcher().getName()+\".INSTANCE;\");\n        } else {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = null;\");\n        }\n\n        p();\n        p(\"public void setDispatcher(\" + DISPATCHER_CLASS + \" dispatcher) {\").i(1);\n        {\n            p(\"this.dispatcher = dispatcher;\");\n        }\n        i(-1).p(\"}\");\n\n        p();\n        p(\"public \" + DISPATCHER_CLASS + \" getDispatcher() {\").i(1);\n        {\n            p(\"return this.dispatcher;\");\n        }\n        i(-1).p(\"}\");\n\n        for (JMethod method : source.getInheritableMethods()) {\n        \tJClassType iface = method.getReturnType().isInterface();\n        \tif(iface != null && REST_SERVICE_TYPE.isAssignableFrom(iface))\n        \t\twriteSubresourceLocatorImpl(method);\n        \telse\n            \twriteMethodImpl(method);\n        }\n    }\n\n    private String quote(String path) {\n        // TODO: unlikely to occur. but we should escape chars like newlines..\n        return \"\\\"\" + path + \"\\\"\";\n    }\n\n    private boolean isOverlayArrayType(JClassType type) {\n        for (JClassType arrayType : OVERLAY_ARRAY_TYPES) {\n            if (type.isAssignableTo(arrayType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isQueryParamListType(JClassType type) {\n        if (type.isParameterized() == null) {\n            return false;\n        }\n        for (JClassType listType : QUERY_PARAM_LIST_TYPES) {\n            if (type.isAssignableTo(listType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\t\n    private void writeSubresourceLocatorImpl(JMethod method) throws UnableToCompleteException\n    {\n    \tJClassType iface = method.getReturnType().isInterface();\n    \tif(iface == null || !REST_SERVICE_TYPE.isAssignableFrom(iface)) {\n    \t\tgetLogger().log(ERROR, \"Invalid subresource locator method. Method must have return type of an interface that extends RestService: \" + method.getReadableDeclaration());\n            throw new UnableToCompleteException();\n    \t}\n    \t\n        Path pathAnnotation = method.getAnnotation(Path.class);\n        if (pathAnnotation == null) {\n        \tgetLogger().log(ERROR, \"Invalid subresource locator method. Method must have @Path annotation: \" + method.getReadableDeclaration());\n            throw new UnableToCompleteException();\n        }\n        String pathExpression = wrap(pathAnnotation.value());\n\n        for (JParameter arg : method.getParameters()) {\n            PathParam paramPath = arg.getAnnotation(PathParam.class);\n            if (paramPath != null) {\n                pathExpression = pathExpression(pathExpression, arg, paramPath);\n            }\n        }\n\n\n        p(method.getReadableDeclaration(false, false, false, false, true) + \" {\").i(1);\n        {\n        \tJType type = method.getReturnType();\n        \tString name;\n        \tif(type instanceof JClassType)\n        \t{\n                JClassType restService = (JClassType)type;\n                RestServiceClassCreator generator = new RestServiceClassCreator(getLogger(), context, restService);\n                name = generator.create();\n        \t}\n        \telse\n        \t{\n        \t\tthrow new UnsupportedOperationException(\"Subresource method may not return: \" + type);\n        \t}\n        \tp(method.getReturnType().getQualifiedSourceName() + \" __subresource = new \" + name + \"();\");\n        \tp(\"((\" + RestServiceProxy.class.getName() + \")__subresource).setResource(getResource().resolve(\" + pathExpression + \"));\");\n        \tp(\"return __subresource;\");\n        }\n        i(-1).p(\"}\");\n    }\n\n    private String pathExpression(String pathExpression, JParameter arg, PathParam paramPath) {\n        String expr = toStringExpression(arg);\n        return pathExpression.replaceAll(Pattern.quote(\"{\" + paramPath.value() + \"}\"), \n               \"\\\"+(\" + expr + \"== null? null : com.google.gwt.http.client.URL.encodePathSegment(\" + expr + \"))+\\\"\");\n    }\n    \n    private void writeMethodImpl(JMethod method) throws UnableToCompleteException {\n        boolean returnRequest = false;\n        if (method.getReturnType() != JPrimitiveType.VOID) {\n            if (!method.getReturnType().getQualifiedSourceName().equals(Request.class.getName()) && \n                !method.getReturnType().getQualifiedSourceName().equals(JsonpRequest.class.getName())) {\n                getLogger().log(ERROR, \"Invalid rest method. Method must have void, Request or JsonpRequest return types: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            } else {\n                returnRequest = true;\n            }\n        }\n\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n\n        Options classOptions = source.getAnnotation(Options.class);\n        Options options = method.getAnnotation(Options.class);\n\n        p(method.getReadableDeclaration(false, false, false, false, true) + \" {\").i(1);\n        {\n            String restMethod = getRestMethod(method);\n            LinkedList<JParameter> args = new LinkedList<JParameter>(Arrays.asList(method.getParameters()));\n\n            // the last arg should be the callback.\n            if (args.isEmpty()) {\n                getLogger().log(ERROR, \"Invalid rest method. Method must declare at least a callback argument: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            JParameter callbackArg = args.removeLast();\n            JClassType callbackType = callbackArg.getType().isClassOrInterface();\n            JClassType methodCallbackType = METHOD_CALLBACK_TYPE;\n            if (callbackType == null || !callbackType.isAssignableTo(methodCallbackType)) {\n                getLogger().log(ERROR, \"Invalid rest method. Last argument must be a \" + methodCallbackType.getName() + \" type: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            JClassType resultType = getCallbackTypeGenericClass(callbackType);\n\n            String pathExpression = null;\n            Path pathAnnotation = method.getAnnotation(Path.class);\n            if (pathAnnotation != null) {\n                pathExpression = wrap(pathAnnotation.value());\n            }\n\n            JParameter contentArg = null;\n            HashMap<String, JParameter> queryParams = new HashMap<String, JParameter>();\n            HashMap<String, JParameter> formParams = new HashMap<String, JParameter>();\n            HashMap<String, JParameter> headerParams = new HashMap<String, JParameter>();\n\n            for (JParameter arg : args) {\n                PathParam paramPath = arg.getAnnotation(PathParam.class);\n                if (paramPath != null) {\n                    if (pathExpression == null) {\n                        getLogger().log(ERROR, \"Invalid rest method.  Invalid @PathParam annotation. Method is missing the @Path annotation: \" + method.getReadableDeclaration());\n                        throw new UnableToCompleteException();\n                    }\n                    pathExpression = pathExpression(pathExpression, arg, paramPath);\n                    //.replaceAll(Pattern.quote(\"{\" + paramPath.value() + \"}\"), \"\\\"+com.google.gwt.http.client.URL.encodePathSegment(\" + toStringExpression(arg) + \")+\\\"\");\n                    if (arg.getAnnotation(Attribute.class) != null) {\n                        // allow part of the arg-object participate in as PathParam and the object goes over the wire\n                        contentArg = arg;\n                    }\n                    continue;\n                }\n\n                QueryParam queryParam = arg.getAnnotation(QueryParam.class);\n                if (queryParam != null) {\n                    queryParams.put(queryParam.value(), arg);\n                    continue;\n                }\n\n                FormParam formParam = arg.getAnnotation(FormParam.class);\n                if (formParam != null) {\n                    formParams.put(formParam.value(), arg);\n                    continue;\n                }\n\n                HeaderParam headerParam = arg.getAnnotation(HeaderParam.class);\n                if (headerParam != null) {\n                    headerParams.put(headerParam.value(), arg);\n                    continue;\n                }\n\n                if (!formParams.isEmpty()) {\n                    getLogger().log(ERROR, \"You can not have both @FormParam parameters and a content parameter: \" +\n                                                method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n\n                if (contentArg != null) {\n                    getLogger().log(ERROR, \"Invalid rest method. Only one content parameter is supported: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n                contentArg = arg;\n            }\n\n            String acceptTypeBuiltIn = null;\n            if (callbackType.equals(TEXT_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_TEXT\";\n            } else if (callbackType.equals(JSON_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.isAssignableTo(OVERLAY_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.equals(XML_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_XML\";\n            }\n\n            p(\"final \" + METHOD_CLASS + \" __method =\");\n\n            p(\"getResource()\");\n            if (pathExpression != null) {\n                p(\".resolve(\" + pathExpression + \")\");\n            }\n            for (Map.Entry<String, JParameter> entry : queryParams.entrySet()) {\n                String expr = entry.getValue().getName();\n                JClassType type = entry.getValue().getType().isClassOrInterface();\n                if (type != null && isQueryParamListType(type)) {\n                    p(\".addQueryParams(\" + wrap(entry.getKey()) + \", \" +\n                      toIteratedStringExpression(entry.getValue()) + \")\");\n                } else {\n                    p(\".addQueryParam(\" + wrap(entry.getKey()) + \", \" +\n                      toStringExpression(entry.getValue().getType(), expr) + \")\");\n                }\n            }\n            // example: .get()\n            p(\".\" + restMethod + \"();\");\n\n            // Handle JSONP specific configuration...\n            JSONP jsonpAnnotation = method.getAnnotation(JSONP.class);\n\n            final boolean isJsonp = restMethod.equals(METHOD_JSONP) && jsonpAnnotation!=null;\n            if( isJsonp ) {\n                if (returnRequest && !method.getReturnType().getQualifiedSourceName().equals(JsonpRequest.class.getName())) {\n                    getLogger().log(ERROR, \"Invalid rest method. JSONP method must have void or JsonpRequest return types: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n                if( jsonpAnnotation.callbackParam().length() > 0 ) {\n                    p(\"((\"+JSONP_METHOD_CLASS+\")__method).callbackParam(\"+wrap(jsonpAnnotation.callbackParam())+\");\");\n                }\n                if( jsonpAnnotation.failureCallbackParam().length() > 0 ) {\n                    p(\"((\"+JSONP_METHOD_CLASS+\")__method).failureCallbackParam(\"+wrap(jsonpAnnotation.failureCallbackParam())+\");\");\n                }\n            } else {\n                if (returnRequest && !method.getReturnType().getQualifiedSourceName().equals(Request.class.getName())) {\n                    getLogger().log(ERROR, \"Invalid rest method. Non JSONP method must have void or Request return types: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n            }\n\n            // configure the dispatcher\n            if( options!=null && options.dispatcher()!=Dispatcher.class ) {\n                // use the dispatcher configured for the method.\n                p(\"__method.setDispatcher(\"+options.dispatcher().getName()+\".INSTANCE);\");\n            } else {\n                // use the default dispatcher configured for the service..\n                p(\"__method.setDispatcher(this.dispatcher);\");\n            }\n\n            // configure the expected statuses..\n            if( options!=null && options.expect().length!=0 ) {\n                // Using method level defined expected status\n                p(\"__method.expect(\"+join(options.expect(), \", \")+\");\");\n            } else if( classOptions!=null && classOptions.expect().length!=0 ) {\n                // Using class level defined expected status\n                p(\"__method.expect(\"+join(classOptions.expect(), \", \")+\");\");\n            }\n\n            // configure the timeout\n            if( options!=null && options.timeout() >= 0 ) {\n                // Using method level defined value\n                p(\"__method.timeout(\"+options.timeout()+\");\");\n            } else if( classOptions!=null && classOptions.timeout() >= 0 ) {\n                // Using class level defined value\n                p(\"__method.timeout(\"+classOptions.timeout()+\");\");\n            }\n\n            if(jsonpAnnotation == null) {\n                Produces producesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Produces.class);\n                if (producesAnnotation != null) {\n                    p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \"+wrap(producesAnnotation.value()[0])+\");\");\n                } else {\n                    // set the default accept header....\n                    if (acceptTypeBuiltIn != null) {\n                        p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \" + RESOURCE_CLASS + \".\" + acceptTypeBuiltIn + \");\");\n                    } else {\n                        p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \" + RESOURCE_CLASS + \".CONTENT_TYPE_JSON);\");\n                    }\n                }\n\n                Consumes consumesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Consumes.class);\n                if (consumesAnnotation != null) {\n                    p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_CONTENT_TYPE, \"+wrap(consumesAnnotation.value()[0])+\");\");\n                }\n\n                // and set the explicit headers now (could override the accept header)\n                for (Map.Entry<String, JParameter> entry : headerParams.entrySet()) {\n                    String expr = entry.getValue().getName();\n                    p(\"__method.header(\" + wrap(entry.getKey()) + \", \" + toStringExpression(entry.getValue().getType(), expr) + \");\");\n                }\n            }\n\n            if (! formParams.isEmpty()) {\n                p(FORM_POST_CONTENT_CLASS + \" __formPostContent = new \" + FORM_POST_CONTENT_CLASS + \"();\");\n\n                for (Map.Entry<String, JParameter> entry : formParams.entrySet()) {\n                    p(\"__formPostContent.addParameter(\" +\n                        wrap(entry.getKey()) + \", \" +\n                        toFormStringExpression(entry.getValue(), classStyle) +\n                        \");\");\n                }\n\n                p(\"__method.form(__formPostContent.getTextContent());\");\n            }\n\n            if (contentArg != null) {\n                if (contentArg.getType() == STRING_TYPE) {\n                    p(\"__method.text(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType() == JSON_VALUE_TYPE) {\n                    p(\"__method.json(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType().isClass() != null &&\n                           isOverlayArrayType(contentArg.getType().isClass())) {\n                    p(\"__method.json(new \" + JSON_ARRAY_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType().isClass() != null &&\n                           contentArg.getType().isClass().isAssignableTo(OVERLAY_VALUE_TYPE)) {\n                    p(\"__method.json(new \" + JSON_OBJECT_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType() == DOCUMENT_TYPE) {\n                    p(\"__method.xml(\" + contentArg.getName() + \");\");\n                } else {\n                    JClassType contentClass = contentArg.getType().isClass();\n                    if (contentClass == null) {\n                        contentClass = contentArg.getType().isClassOrInterface();\n                        if (!locator.isCollectionType(contentClass)) {\n                            getLogger().log(ERROR, \"Content argument must be a class.\");\n                            throw new UnableToCompleteException();\n                        }\n                    }\n\n                    jsonAnnotation = contentArg.getAnnotation(Json.class);\n                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n                    // example:\n                    // .json(Listings$_Generated_JsonEncoder_$.INSTANCE.encode(arg0)\n                    // )\n                    p(\"__method.json(\" + locator.encodeExpression(contentClass, contentArg.getName(), style) + \");\");\n                }\n            }\n\n\n            List<AnnotationResolver> annotationResolvers = getAnnotationResolvers(context, getLogger());\n            getLogger().log(TreeLogger.DEBUG, \"found \" + annotationResolvers.size() + \" additional AnnotationResolvers\");\n\n            for (AnnotationResolver a : annotationResolvers) {\n                getLogger().log(TreeLogger.DEBUG, \"(\" + a.getClass().getName() + \") resolve `\" + source.getName()\n                        + \"#\" + method.getName() + \" ...\");\n                final Map<String, String[]> addDataParams = a.resolveAnnotation(getLogger(), source, method, restMethod);\n\n                if (addDataParams != null) {\n                    for (String s : addDataParams.keySet()) {\n                        final StringBuilder sb = new StringBuilder();\n                        final List<String> classList = Arrays.asList(addDataParams.get(s));\n\n                        sb.append(\"[\");\n                        for (int i = 0; i < classList.size(); ++i) {\n                            sb.append(\"\\\\\\\"\").append(classList.get(i)).append(\"\\\\\\\"\");\n\n                            if ((i+1) <  classList.size()) {\n                                sb.append(\",\");\n                            }\n                        }\n                        sb.append(\"]\");\n\n                        getLogger().log(TreeLogger.DEBUG, \"add call with (\\\"\" + s + \"\\\", \\\"\" +\n                                sb.toString() + \"\\\")\");\n                        p(\"__method.addData(\\\"\" + s + \"\\\", \\\"\" + sb.toString() + \"\\\");\");\n                    }\n                }\n            }\n\n\n            if (acceptTypeBuiltIn != null) {\n                // TODO: shouldn't we also have a cach in here?\n                p(returnRequest(returnRequest,isJsonp) + \"__method.send(\" + callbackArg.getName() + \");\");\n            } else if ( isJsonp ){\n                    p(returnRequest(returnRequest,isJsonp) + \"((\" + JSONP_METHOD_CLASS + \")__method).send(new \" + ABSTRACT_ASYNC_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">((\" + JSONP_METHOD_CLASS + \")__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult(\" + JSON_VALUE_CLASS + \" result) throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) null;\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    if(resultType.isAssignableTo(locator.LIST_TYPE)){\n                                        p(\"result = new \" + JSON_ARRAY_CLASS + \"(result.getJavaScriptObject());\");\n                                    }\n                                    jsonAnnotation = method.getAnnotation(Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, \"result\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n            } else {\n                p(\"try {\").i(1);\n                {\n                    p(returnRequest(returnRequest,isJsonp) + \"__method.send(new \" + ABSTRACT_REQUEST_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">(__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult() throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) null;\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    jsonAnnotation = method.getAnnotation(Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, JSON_PARSER_CLASS + \".parse(__method.getResponse().getText())\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n                }\n                i(-1).p(\"} catch (\" + REQUEST_EXCEPTION_CLASS + \" __e) {\").i(1);\n                {\n                    p(callbackArg.getName() + \".onFailure(__method,__e);\");\n                    if (returnRequest) {\n                        p(\"return null;\");\n                    }                    \n                }\n                i(-1).p(\"}\");\n            }\n        }\n        i(-1).p(\"}\");\n    }\n\n    private <T extends Annotation> T findAnnotationOnMethodOrEnclosingType(final JMethod method, final Class<T> annotationType) {\n        T annotation = method.getAnnotation(annotationType);\n        if (annotation == null) {\n            annotation = method.getEnclosingType().getAnnotation(annotationType);\n        }\n        return annotation;\n    }\n\n    protected String toStringExpression(JParameter arg) {\n        Attribute attribute = arg.getAnnotation(Attribute.class);\n        if(attribute != null){\n            return arg.getName() + \".\" + attribute.value();\n        }\n        return toStringExpression(arg.getType(), arg.getName());\n    }\n\n    protected String toFormStringExpression(JParameter argument, Style classStyle) throws UnableToCompleteException {\n        JType type = argument.getType();\n        String expr = argument.getName();\n\n        if (type.isPrimitive() != null) {\n            return \"\\\"\\\"+\" + expr;\n        }\n        if (STRING_TYPE == type) {\n            return expr;\n        }\n        if (type.isClass() != null &&\n                isOverlayArrayType(type.isClass())) {\n            return \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.isClass() != null &&\n                OVERLAY_VALUE_TYPE.isAssignableFrom(type.isClass())) {\n            return \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.getQualifiedBinaryName().startsWith(\"java.lang.\")) {\n            return String.format(\"(%s != null ? %s.toString() : null)\", expr, expr);\n        }\n\n        Json jsonAnnotation = argument.getAnnotation(Json.class);\n        final Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n        return locator.encodeExpression(type, expr, style) + \".toString()\";\n    }\n\n    protected String toStringExpression(JType type, String expr) {\n        if (type.isPrimitive() != null) {\n            return \"\\\"\\\"+\" + expr;\n        }\n        if (STRING_TYPE == type) {\n            return expr;\n        }\n        if (type.isClass() != null &&\n            isOverlayArrayType(type.isClass())) {\n          return \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.isClass() != null &&\n            OVERLAY_VALUE_TYPE.isAssignableFrom(type.isClass())) {\n          return \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        }\n\n        return String.format(\"(%s != null ? %s.toString() : null)\", expr, expr);\n    }\n\n    protected String toIteratedStringExpression(JParameter arg) {\n        StringBuilder result = new StringBuilder();\n        result.append(\"new org.fusesource.restygwt.client.StringIterable (\")\n            .append(arg.getName()).append(\")\");\n\n        return result.toString();\n    }\n\n    private JClassType getCallbackTypeGenericClass(final JClassType callbackType) throws UnableToCompleteException {\n        return branch(\"getCallbackTypeGenericClass()\", new Branch<JClassType>() {\n            @Override\n            public JClassType execute() throws UnableToCompleteException {\n\n                for (JMethod method : callbackType.getOverridableMethods()) {\n                    getLogger().log(DEBUG, \"checking method: \" + method.getName());\n                    if (method.getName().equals(\"onSuccess\")) {\n                        JParameter[] parameters = method.getParameters();\n                        getLogger().log(DEBUG, \"checking method params: \" + parameters.length);\n                        if (parameters.length == 2) {\n                            getLogger().log(DEBUG, \"checking first param: \" + parameters[0].getType());\n                            if (parameters[0].getType() == METHOD_TYPE) {\n                                getLogger().log(DEBUG, \"checking 2nd param: \" + parameters[1].getType());\n                                JType param2Type = parameters[1].getType();\n                                JClassType type = param2Type.isClassOrInterface();\n                                if (type == null) {\n                                    getLogger().log(ERROR, \"The type of the callback not supported: \" + param2Type.getJNISignature());\n                                    throw new UnableToCompleteException();\n                                }\n                                getLogger().log(DEBUG, \"match: \" + type);\n                                return type;\n                            }\n                        }\n                    }\n                }\n                getLogger().log(ERROR, \"The type of the callback could not be determined: \" + callbackType.getParameterizedQualifiedSourceName());\n                throw new UnableToCompleteException();\n            }\n        });\n    }\n\n    private String getRestMethod(JMethod method) throws UnableToCompleteException {\n        String restMethod = null;\n        if (method.getAnnotation(DELETE.class) != null) {\n            restMethod = METHOD_DELETE;\n        } else if (method.getAnnotation(GET.class) != null) {\n            restMethod = METHOD_GET;\n        } else if (method.getAnnotation(HEAD.class) != null) {\n            restMethod = METHOD_HEAD;\n        } else if (method.getAnnotation(OPTIONS.class) != null) {\n            restMethod = METHOD_OPTIONS;\n        } else if (method.getAnnotation(POST.class) != null) {\n            restMethod = METHOD_POST;\n        } else if (method.getAnnotation(PUT.class) != null) {\n            restMethod = METHOD_PUT;\n        } else if (method.getAnnotation(JSONP.class) != null) {\n            restMethod = METHOD_JSONP;\n        } else {\n            restMethod = method.getName();\n            if (!REST_METHODS.contains(restMethod)) {\n                getLogger().log(ERROR, \"Invalid rest method. It must either have a lower case rest method name or have a javax rs method annotation: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n        }\n        return restMethod;\n    }\n\n    /**\n     * access additional AnnotationResolvers possibly added by\n     *\n     * {@link BindingDefaults#addAnnotationResolver(AnnotationResolver)}\n     * @return\n     */\n    // TODO remove suppression\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private List<AnnotationResolver> getAnnotationResolvers(final GeneratorContext context, final TreeLogger logger) {\n        java.lang.reflect.Method m = null;\n        ArrayList args = new ArrayList();\n        ArrayList types = new ArrayList();\n\n        types.add(GeneratorContext.class);\n        args.add(context);\n        types.add(TreeLogger.class);\n        args.add(logger);\n\n        Object[] argValues = args.toArray();\n        Class[] argtypes = (Class[]) types.toArray(new Class[argValues.length]);\n\n        try {\n             m = BINDING_DEFAULTS.getMethod(\"getAnnotationResolvers\", argtypes);\n        } catch (SecurityException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"could not resolve method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        List<AnnotationResolver> l = new ArrayList<AnnotationResolver>();\n        try {\n            l = (List<AnnotationResolver>) m.invoke(null, context, logger);\n        } catch (IllegalArgumentException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (InvocationTargetException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        return l;\n    }\n    \n    private String returnRequest(boolean returnRequest, boolean isJsonp) {\n        String type = isJsonp ? JsonpRequest.class.getName() : Request.class.getName();\n        return returnRequest ? \"return (\"+type+\")\" : \"\";\n    }    \n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport com.google.gwt.core.client.*;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.*;\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.jsonp.client.JsonpRequest;\nimport com.google.gwt.user.client.rpc.RemoteServiceRelativePath;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport com.google.gwt.xml.client.Document;\nimport org.fusesource.restygwt.client.*;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport javax.ws.rs.*;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\nimport java.util.regex.Pattern;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added automatically create resource from Path annotation,\n *         enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\npublic class RestServiceClassCreator extends BaseSourceCreator {\n\n    private static final String REST_SERVICE_PROXY_SUFFIX = \"_Generated_RestServiceProxy_\";\n\n    private static final String METHOD_CLASS = Method.class.getName();\n    private static final String RESOURCE_CLASS = Resource.class.getName();\n    private static final String DISPATCHER_CLASS = Dispatcher.class.getName();\n    private static final String DEFAULTS_CLASS = Defaults.class.getName();\n    private static final String ABSTRACT_REQUEST_CALLBACK_CLASS = AbstractRequestCallback.class.getName();\n    private static final String ABSTRACT_ASYNC_CALLBACK_CLASS = AbstractAsyncCallback.class.getName();\n    private static final String JSON_PARSER_CLASS = JSONParser.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String REQUEST_EXCEPTION_CLASS = RequestException.class.getName();\n    private static final String RESPONSE_FORMAT_EXCEPTION_CLASS = ResponseFormatException.class.getName();\n    private static final String JSONP_METHOD_CLASS = JsonpMethod.class.getName();\n    private static final String FORM_POST_CONTENT_CLASS = FormPostContent.class.getName();\n\n    /*\n     * static class in which are some compile-time relevant infos.\n     *\n     * TODO (andi): too much flexibility and overhead with reflection here?\n     */\n    private static final Class<BindingDefaults> BINDING_DEFAULTS = BindingDefaults.class;\n\n    private static final String METHOD_JSONP = \"jsonp\";\n    private static final String METHOD_PUT = \"put\";\n    private static final String METHOD_POST = \"post\";\n    private static final String METHOD_OPTIONS = \"options\";\n    private static final String METHOD_HEAD = \"head\";\n    private static final String METHOD_GET = \"get\";\n    private static final String METHOD_DELETE = \"delete\";\n\n    private static final HashSet<String> REST_METHODS = new HashSet<String>(8);\n    static {\n        REST_METHODS.add(METHOD_DELETE);\n        REST_METHODS.add(METHOD_GET);\n        REST_METHODS.add(METHOD_HEAD);\n        REST_METHODS.add(METHOD_OPTIONS);\n        REST_METHODS.add(METHOD_POST);\n        REST_METHODS.add(METHOD_PUT);\n        REST_METHODS.add(METHOD_JSONP);\n    }\n\n    private JClassType XML_CALLBACK_TYPE;\n    private JClassType METHOD_CALLBACK_TYPE;\n    private JClassType TEXT_CALLBACK_TYPE;\n    private JClassType JSON_CALLBACK_TYPE;\n    private JClassType OVERLAY_CALLBACK_TYPE;\n    private JClassType DOCUMENT_TYPE;\n    private JClassType METHOD_TYPE;\n    private JClassType STRING_TYPE;\n    private JClassType JSON_VALUE_TYPE;\n    private JClassType OVERLAY_VALUE_TYPE;\n    private Set<JClassType> OVERLAY_ARRAY_TYPES;\n    private Set<JClassType> QUERY_PARAM_LIST_TYPES;\n    private JClassType REST_SERVICE_TYPE;\n    private JsonEncoderDecoderInstanceLocator locator;\n\n    public RestServiceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n        super(logger, context, source, REST_SERVICE_PROXY_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n    \tString parameters = \"\";\n    \tif(source instanceof JGenericType)\n    \t{\n    \t\tJGenericType gtype = (JGenericType)source;\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tbuilder.append(\"<\");\n\t\t\tboolean first = true;\n   \t\t\tfor(JTypeParameter arg : gtype.getTypeParameters())\n   \t\t\t{\n   \t\t\t\tif(!first)\n   \t\t\t\t\tbuilder.append(\",\");\n   \t\t\t\tbuilder.append(arg.getName());\n   \t\t\t\tbuilder.append(\" extends \");\n\t   \t\t\tbuilder.append(arg.getFirstBound().getParameterizedQualifiedSourceName());\n\t   \t\t\tfirst = false;\n   \t\t\t}\n   \t\t\tbuilder.append(\">\");\n   \t\t\tparameters = builder.toString();\n     \t}\n    \t\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName + parameters);\n        composerFactory.addImplementedInterface(source.getParameterizedQualifiedSourceName());\n        composerFactory.addImplementedInterface(RestServiceProxy.class.getName());\n        return composerFactory;\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n\n        if (source.isInterface() == null) {\n            getLogger().log(ERROR, \"Type is not an interface.\");\n            throw new UnableToCompleteException();\n        }\n\n        locator = new JsonEncoderDecoderInstanceLocator(context, getLogger());\n\n        this.XML_CALLBACK_TYPE = find(XmlCallback.class, getLogger(), context);\n        this.METHOD_CALLBACK_TYPE = find(MethodCallback.class, getLogger(), context);\n        this.TEXT_CALLBACK_TYPE = find(TextCallback.class, getLogger(), context);\n        this.JSON_CALLBACK_TYPE = find(JsonCallback.class, getLogger(), context);\n        this.OVERLAY_CALLBACK_TYPE = find(OverlayCallback.class, getLogger(), context);\n        this.DOCUMENT_TYPE = find(Document.class, getLogger(), context);\n        this.METHOD_TYPE = find(Method.class, getLogger(), context);\n        this.STRING_TYPE = find(String.class, getLogger(), context);\n        this.JSON_VALUE_TYPE = find(JSONValue.class, getLogger(), context);\n        this.OVERLAY_VALUE_TYPE = find(JavaScriptObject.class, getLogger(), context);\n        this.OVERLAY_ARRAY_TYPES = new HashSet<JClassType>();\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArray.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayBoolean.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayInteger.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayNumber.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayString.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES = new HashSet<JClassType>();\n        this.QUERY_PARAM_LIST_TYPES.add(find(List.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES.add(find(Set.class, getLogger(), context));\n\t\tthis.REST_SERVICE_TYPE = find(RestService.class, getLogger(), context);\n\t\t\n        String path = null;\n        Path pathAnnotation = source.getAnnotation(Path.class);\n        if (pathAnnotation != null) {\n            path = pathAnnotation.value();\n        }\n\n        RemoteServiceRelativePath relativePath = source.getAnnotation(RemoteServiceRelativePath.class);\n        if (relativePath != null) {\n            path = relativePath.value();\n        }\n\n        p(\"private \" + RESOURCE_CLASS + \" resource = null;\");\n        p();\n\n        p(\"public void setResource(\" + RESOURCE_CLASS + \" resource) {\").i(1);\n        {\n            p(\"this.resource = resource;\");\n        }\n        i(-1).p(\"}\");\n\n        p(\"public \" + RESOURCE_CLASS + \" getResource() {\").i(1);\n        {\n            p(\"if (this.resource == null) {\").i(1);\n            if (path == null) {\n                p(\"this.resource = new \" + RESOURCE_CLASS + \"(\" + DEFAULTS_CLASS + \".getServiceRoot());\");\n            } else {\n                p(\"this.resource = new \" + RESOURCE_CLASS + \"(\" + DEFAULTS_CLASS + \".getServiceRoot()).resolve(\"+quote(path)+\");\");\n            }\n            i(-1).p(\"}\");\n            p(\"return this.resource;\");\n        }\n        i(-1).p(\"}\");\n\n\n        Options options = source.getAnnotation(Options.class);\n        if( options!=null && options.dispatcher()!=Dispatcher.class ) {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = \"+options.dispatcher().getName()+\".INSTANCE;\");\n        } else {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = null;\");\n        }\n\n        p();\n        p(\"public void setDispatcher(\" + DISPATCHER_CLASS + \" dispatcher) {\").i(1);\n        {\n            p(\"this.dispatcher = dispatcher;\");\n        }\n        i(-1).p(\"}\");\n\n        p();\n        p(\"public \" + DISPATCHER_CLASS + \" getDispatcher() {\").i(1);\n        {\n            p(\"return this.dispatcher;\");\n        }\n        i(-1).p(\"}\");\n\n        for (JMethod method : source.getInheritableMethods()) {\n        \tJClassType iface = method.getReturnType().isInterface();\n        \tif(iface != null && REST_SERVICE_TYPE.isAssignableFrom(iface))\n        \t\twriteSubresourceLocatorImpl(method);\n        \telse\n            \twriteMethodImpl(method);\n        }\n    }\n\n    private String quote(String path) {\n        // TODO: unlikely to occur. but we should escape chars like newlines..\n        return \"\\\"\" + path + \"\\\"\";\n    }\n\n    private boolean isOverlayArrayType(JClassType type) {\n        for (JClassType arrayType : OVERLAY_ARRAY_TYPES) {\n            if (type.isAssignableTo(arrayType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isQueryParamListType(JClassType type) {\n        if (type.isParameterized() == null) {\n            return false;\n        }\n        for (JClassType listType : QUERY_PARAM_LIST_TYPES) {\n            if (type.isAssignableTo(listType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\t\n    private void writeSubresourceLocatorImpl(JMethod method) throws UnableToCompleteException\n    {\n    \tJClassType iface = method.getReturnType().isInterface();\n    \tif(iface == null || !REST_SERVICE_TYPE.isAssignableFrom(iface)) {\n    \t\tgetLogger().log(ERROR, \"Invalid subresource locator method. Method must have return type of an interface that extends RestService: \" + method.getReadableDeclaration());\n            throw new UnableToCompleteException();\n    \t}\n    \t\n        Path pathAnnotation = method.getAnnotation(Path.class);\n        if (pathAnnotation == null) {\n        \tgetLogger().log(ERROR, \"Invalid subresource locator method. Method must have @Path annotation: \" + method.getReadableDeclaration());\n            throw new UnableToCompleteException();\n        }\n        String pathExpression = wrap(pathAnnotation.value());\n\n        for (JParameter arg : method.getParameters()) {\n            PathParam paramPath = arg.getAnnotation(PathParam.class);\n            if (paramPath != null) {\n                pathExpression = pathExpression.replaceAll(Pattern.quote(\"{\" + paramPath.value() + \"}\"), \"\\\"+com.google.gwt.http.client.URL.encodePathSegment(\" + toStringExpression(arg) + \")+\\\"\");\n            }\n        }\n\n\n        p(method.getReadableDeclaration(false, false, false, false, true) + \" {\").i(1);\n        {\n        \tJType type = method.getReturnType();\n        \tString name;\n        \tif(type instanceof JClassType)\n        \t{\n                JClassType restService = (JClassType)type;\n                RestServiceClassCreator generator = new RestServiceClassCreator(getLogger(), context, restService);\n                name = generator.create();\n        \t}\n        \telse\n        \t{\n        \t\tthrow new UnsupportedOperationException(\"Subresource method may not return: \" + type);\n        \t}\n        \tp(method.getReturnType().getQualifiedSourceName() + \" __subresource = new \" + name + \"();\");\n        \tp(\"((\" + RestServiceProxy.class.getName() + \")__subresource).setResource(getResource().resolve(\" + pathExpression + \"));\");\n        \tp(\"return __subresource;\");\n        }\n        i(-1).p(\"}\");\n    }\n    \n    private void writeMethodImpl(JMethod method) throws UnableToCompleteException {\n        boolean returnRequest = false;\n        if (method.getReturnType() != JPrimitiveType.VOID) {\n            if (!method.getReturnType().getQualifiedSourceName().equals(Request.class.getName()) && \n                !method.getReturnType().getQualifiedSourceName().equals(JsonpRequest.class.getName())) {\n                getLogger().log(ERROR, \"Invalid rest method. Method must have void, Request or JsonpRequest return types: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            } else {\n                returnRequest = true;\n            }\n        }\n\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n\n        Options classOptions = source.getAnnotation(Options.class);\n        Options options = method.getAnnotation(Options.class);\n\n        p(method.getReadableDeclaration(false, false, false, false, true) + \" {\").i(1);\n        {\n            String restMethod = getRestMethod(method);\n            LinkedList<JParameter> args = new LinkedList<JParameter>(Arrays.asList(method.getParameters()));\n\n            // the last arg should be the callback.\n            if (args.isEmpty()) {\n                getLogger().log(ERROR, \"Invalid rest method. Method must declare at least a callback argument: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            JParameter callbackArg = args.removeLast();\n            JClassType callbackType = callbackArg.getType().isClassOrInterface();\n            JClassType methodCallbackType = METHOD_CALLBACK_TYPE;\n            if (callbackType == null || !callbackType.isAssignableTo(methodCallbackType)) {\n                getLogger().log(ERROR, \"Invalid rest method. Last argument must be a \" + methodCallbackType.getName() + \" type: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            JClassType resultType = getCallbackTypeGenericClass(callbackType);\n\n            String pathExpression = null;\n            Path pathAnnotation = method.getAnnotation(Path.class);\n            if (pathAnnotation != null) {\n                pathExpression = wrap(pathAnnotation.value());\n            }\n\n            JParameter contentArg = null;\n            HashMap<String, JParameter> queryParams = new HashMap<String, JParameter>();\n            HashMap<String, JParameter> formParams = new HashMap<String, JParameter>();\n            HashMap<String, JParameter> headerParams = new HashMap<String, JParameter>();\n\n            for (JParameter arg : args) {\n                PathParam paramPath = arg.getAnnotation(PathParam.class);\n                if (paramPath != null) {\n                    if (pathExpression == null) {\n                        getLogger().log(ERROR, \"Invalid rest method.  Invalid @PathParam annotation. Method is missing the @Path annotation: \" + method.getReadableDeclaration());\n                        throw new UnableToCompleteException();\n                    }\n                    pathExpression = pathExpression.replaceAll(Pattern.quote(\"{\" + paramPath.value() + \"}\"), \"\\\"+com.google.gwt.http.client.URL.encodePathSegment(\" + toStringExpression(arg) + \")+\\\"\");\n                    if (arg.getAnnotation(Attribute.class) != null) {\n                        // allow part of the arg-object participate in as PathParam and the object goes over the wire\n                        contentArg = arg;\n                    }\n                    continue;\n                }\n\n                QueryParam queryParam = arg.getAnnotation(QueryParam.class);\n                if (queryParam != null) {\n                    queryParams.put(queryParam.value(), arg);\n                    continue;\n                }\n\n                FormParam formParam = arg.getAnnotation(FormParam.class);\n                if (formParam != null) {\n                    formParams.put(formParam.value(), arg);\n                    continue;\n                }\n\n                HeaderParam headerParam = arg.getAnnotation(HeaderParam.class);\n                if (headerParam != null) {\n                    headerParams.put(headerParam.value(), arg);\n                    continue;\n                }\n\n                if (!formParams.isEmpty()) {\n                    getLogger().log(ERROR, \"You can not have both @FormParam parameters and a content parameter: \" +\n                                                method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n\n                if (contentArg != null) {\n                    getLogger().log(ERROR, \"Invalid rest method. Only one content parameter is supported: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n                contentArg = arg;\n            }\n\n            String acceptTypeBuiltIn = null;\n            if (callbackType.equals(TEXT_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_TEXT\";\n            } else if (callbackType.equals(JSON_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.isAssignableTo(OVERLAY_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.equals(XML_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_XML\";\n            }\n\n            p(\"final \" + METHOD_CLASS + \" __method =\");\n\n            p(\"getResource()\");\n            if (pathExpression != null) {\n                p(\".resolve(\" + pathExpression + \")\");\n            }\n            for (Map.Entry<String, JParameter> entry : queryParams.entrySet()) {\n                String expr = entry.getValue().getName();\n                JClassType type = entry.getValue().getType().isClassOrInterface();\n                if (type != null && isQueryParamListType(type)) {\n                    p(\".addQueryParams(\" + wrap(entry.getKey()) + \", \" +\n                      toIteratedStringExpression(entry.getValue()) + \")\");\n                } else {\n                    p(\".addQueryParam(\" + wrap(entry.getKey()) + \", \" +\n                      toStringExpression(entry.getValue().getType(), expr) + \")\");\n                }\n            }\n            // example: .get()\n            p(\".\" + restMethod + \"();\");\n\n            // Handle JSONP specific configuration...\n            JSONP jsonpAnnotation = method.getAnnotation(JSONP.class);\n\n            final boolean isJsonp = restMethod.equals(METHOD_JSONP) && jsonpAnnotation!=null;\n            if( isJsonp ) {\n                if (returnRequest && !method.getReturnType().getQualifiedSourceName().equals(JsonpRequest.class.getName())) {\n                    getLogger().log(ERROR, \"Invalid rest method. JSONP method must have void or JsonpRequest return types: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n                if( jsonpAnnotation.callbackParam().length() > 0 ) {\n                    p(\"((\"+JSONP_METHOD_CLASS+\")__method).callbackParam(\"+wrap(jsonpAnnotation.callbackParam())+\");\");\n                }\n                if( jsonpAnnotation.failureCallbackParam().length() > 0 ) {\n                    p(\"((\"+JSONP_METHOD_CLASS+\")__method).failureCallbackParam(\"+wrap(jsonpAnnotation.failureCallbackParam())+\");\");\n                }\n            } else {\n                if (returnRequest && !method.getReturnType().getQualifiedSourceName().equals(Request.class.getName())) {\n                    getLogger().log(ERROR, \"Invalid rest method. Non JSONP method must have void or Request return types: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n            }\n\n            // configure the dispatcher\n            if( options!=null && options.dispatcher()!=Dispatcher.class ) {\n                // use the dispatcher configured for the method.\n                p(\"__method.setDispatcher(\"+options.dispatcher().getName()+\".INSTANCE);\");\n            } else {\n                // use the default dispatcher configured for the service..\n                p(\"__method.setDispatcher(this.dispatcher);\");\n            }\n\n            // configure the expected statuses..\n            if( options!=null && options.expect().length!=0 ) {\n                // Using method level defined expected status\n                p(\"__method.expect(\"+join(options.expect(), \", \")+\");\");\n            } else if( classOptions!=null && classOptions.expect().length!=0 ) {\n                // Using class level defined expected status\n                p(\"__method.expect(\"+join(classOptions.expect(), \", \")+\");\");\n            }\n\n            // configure the timeout\n            if( options!=null && options.timeout() >= 0 ) {\n                // Using method level defined value\n                p(\"__method.timeout(\"+options.timeout()+\");\");\n            } else if( classOptions!=null && classOptions.timeout() >= 0 ) {\n                // Using class level defined value\n                p(\"__method.timeout(\"+classOptions.timeout()+\");\");\n            }\n\n            if(jsonpAnnotation == null) {\n                Produces producesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Produces.class);\n                if (producesAnnotation != null) {\n                    p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \"+wrap(producesAnnotation.value()[0])+\");\");\n                } else {\n                    // set the default accept header....\n                    if (acceptTypeBuiltIn != null) {\n                        p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \" + RESOURCE_CLASS + \".\" + acceptTypeBuiltIn + \");\");\n                    } else {\n                        p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \" + RESOURCE_CLASS + \".CONTENT_TYPE_JSON);\");\n                    }\n                }\n\n                Consumes consumesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Consumes.class);\n                if (consumesAnnotation != null) {\n                    p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_CONTENT_TYPE, \"+wrap(consumesAnnotation.value()[0])+\");\");\n                }\n\n                // and set the explicit headers now (could override the accept header)\n                for (Map.Entry<String, JParameter> entry : headerParams.entrySet()) {\n                    String expr = entry.getValue().getName();\n                    p(\"__method.header(\" + wrap(entry.getKey()) + \", \" + toStringExpression(entry.getValue().getType(), expr) + \");\");\n                }\n            }\n\n            if (! formParams.isEmpty()) {\n                p(FORM_POST_CONTENT_CLASS + \" __formPostContent = new \" + FORM_POST_CONTENT_CLASS + \"();\");\n\n                for (Map.Entry<String, JParameter> entry : formParams.entrySet()) {\n                    p(\"__formPostContent.addParameter(\" +\n                        wrap(entry.getKey()) + \", \" +\n                        toFormStringExpression(entry.getValue(), classStyle) +\n                        \");\");\n                }\n\n                p(\"__method.form(__formPostContent.getTextContent());\");\n            }\n\n            if (contentArg != null) {\n                if (contentArg.getType() == STRING_TYPE) {\n                    p(\"__method.text(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType() == JSON_VALUE_TYPE) {\n                    p(\"__method.json(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType().isClass() != null &&\n                           isOverlayArrayType(contentArg.getType().isClass())) {\n                    p(\"__method.json(new \" + JSON_ARRAY_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType().isClass() != null &&\n                           contentArg.getType().isClass().isAssignableTo(OVERLAY_VALUE_TYPE)) {\n                    p(\"__method.json(new \" + JSON_OBJECT_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType() == DOCUMENT_TYPE) {\n                    p(\"__method.xml(\" + contentArg.getName() + \");\");\n                } else {\n                    JClassType contentClass = contentArg.getType().isClass();\n                    if (contentClass == null) {\n                        contentClass = contentArg.getType().isClassOrInterface();\n                        if (!locator.isCollectionType(contentClass)) {\n                            getLogger().log(ERROR, \"Content argument must be a class.\");\n                            throw new UnableToCompleteException();\n                        }\n                    }\n\n                    jsonAnnotation = contentArg.getAnnotation(Json.class);\n                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n                    // example:\n                    // .json(Listings$_Generated_JsonEncoder_$.INSTANCE.encode(arg0)\n                    // )\n                    p(\"__method.json(\" + locator.encodeExpression(contentClass, contentArg.getName(), style) + \");\");\n                }\n            }\n\n\n            List<AnnotationResolver> annotationResolvers = getAnnotationResolvers(context, getLogger());\n            getLogger().log(TreeLogger.DEBUG, \"found \" + annotationResolvers.size() + \" additional AnnotationResolvers\");\n\n            for (AnnotationResolver a : annotationResolvers) {\n                getLogger().log(TreeLogger.DEBUG, \"(\" + a.getClass().getName() + \") resolve `\" + source.getName()\n                        + \"#\" + method.getName() + \" ...\");\n                final Map<String, String[]> addDataParams = a.resolveAnnotation(getLogger(), source, method, restMethod);\n\n                if (addDataParams != null) {\n                    for (String s : addDataParams.keySet()) {\n                        final StringBuilder sb = new StringBuilder();\n                        final List<String> classList = Arrays.asList(addDataParams.get(s));\n\n                        sb.append(\"[\");\n                        for (int i = 0; i < classList.size(); ++i) {\n                            sb.append(\"\\\\\\\"\").append(classList.get(i)).append(\"\\\\\\\"\");\n\n                            if ((i+1) <  classList.size()) {\n                                sb.append(\",\");\n                            }\n                        }\n                        sb.append(\"]\");\n\n                        getLogger().log(TreeLogger.DEBUG, \"add call with (\\\"\" + s + \"\\\", \\\"\" +\n                                sb.toString() + \"\\\")\");\n                        p(\"__method.addData(\\\"\" + s + \"\\\", \\\"\" + sb.toString() + \"\\\");\");\n                    }\n                }\n            }\n\n\n            if (acceptTypeBuiltIn != null) {\n                // TODO: shouldn't we also have a cach in here?\n                p(returnRequest(returnRequest,isJsonp) + \"__method.send(\" + callbackArg.getName() + \");\");\n            } else if ( isJsonp ){\n                    p(returnRequest(returnRequest,isJsonp) + \"((\" + JSONP_METHOD_CLASS + \")__method).send(new \" + ABSTRACT_ASYNC_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">((\" + JSONP_METHOD_CLASS + \")__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult(\" + JSON_VALUE_CLASS + \" result) throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) null;\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    if(resultType.isAssignableTo(locator.LIST_TYPE)){\n                                        p(\"result = new \" + JSON_ARRAY_CLASS + \"(result.getJavaScriptObject());\");\n                                    }\n                                    jsonAnnotation = method.getAnnotation(Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, \"result\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n            } else {\n                p(\"try {\").i(1);\n                {\n                    p(returnRequest(returnRequest,isJsonp) + \"__method.send(new \" + ABSTRACT_REQUEST_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">(__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult() throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) null;\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    jsonAnnotation = method.getAnnotation(Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, JSON_PARSER_CLASS + \".parse(__method.getResponse().getText())\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n                }\n                i(-1).p(\"} catch (\" + REQUEST_EXCEPTION_CLASS + \" __e) {\").i(1);\n                {\n                    p(callbackArg.getName() + \".onFailure(__method,__e);\");\n                    if (returnRequest) {\n                        p(\"return null;\");\n                    }                    \n                }\n                i(-1).p(\"}\");\n            }\n        }\n        i(-1).p(\"}\");\n    }\n\n    private <T extends Annotation> T findAnnotationOnMethodOrEnclosingType(final JMethod method, final Class<T> annotationType) {\n        T annotation = method.getAnnotation(annotationType);\n        if (annotation == null) {\n            annotation = method.getEnclosingType().getAnnotation(annotationType);\n        }\n        return annotation;\n    }\n\n    protected String toStringExpression(JParameter arg) {\n        Attribute attribute = arg.getAnnotation(Attribute.class);\n        if(attribute != null){\n            return arg.getName() + \".\" + attribute.value();\n        }\n        return toStringExpression(arg.getType(), arg.getName());\n    }\n\n    protected String toFormStringExpression(JParameter argument, Style classStyle) throws UnableToCompleteException {\n        JType type = argument.getType();\n        String expr = argument.getName();\n\n        if (type.isPrimitive() != null) {\n            return \"\\\"\\\"+\" + expr;\n        }\n        if (STRING_TYPE == type) {\n            return expr;\n        }\n        if (type.isClass() != null &&\n                isOverlayArrayType(type.isClass())) {\n            return \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.isClass() != null &&\n                OVERLAY_VALUE_TYPE.isAssignableFrom(type.isClass())) {\n            return \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.getQualifiedBinaryName().startsWith(\"java.lang.\")) {\n            return String.format(\"(%s != null ? %s.toString() : null)\", expr, expr);\n        }\n\n        Json jsonAnnotation = argument.getAnnotation(Json.class);\n        final Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n        return locator.encodeExpression(type, expr, style) + \".toString()\";\n    }\n\n    protected String toStringExpression(JType type, String expr) {\n        if (type.isPrimitive() != null) {\n            return \"\\\"\\\"+\" + expr;\n        }\n        if (STRING_TYPE == type) {\n            return expr;\n        }\n        if (type.isClass() != null &&\n            isOverlayArrayType(type.isClass())) {\n          return \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.isClass() != null &&\n            OVERLAY_VALUE_TYPE.isAssignableFrom(type.isClass())) {\n          return \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        }\n\n        return String.format(\"(%s != null ? %s.toString() : null)\", expr, expr);\n    }\n\n    protected String toIteratedStringExpression(JParameter arg) {\n        StringBuilder result = new StringBuilder();\n        result.append(\"new org.fusesource.restygwt.client.StringIterable (\")\n            .append(arg.getName()).append(\")\");\n\n        return result.toString();\n    }\n\n    private JClassType getCallbackTypeGenericClass(final JClassType callbackType) throws UnableToCompleteException {\n        return branch(\"getCallbackTypeGenericClass()\", new Branch<JClassType>() {\n            @Override\n            public JClassType execute() throws UnableToCompleteException {\n\n                for (JMethod method : callbackType.getOverridableMethods()) {\n                    getLogger().log(DEBUG, \"checking method: \" + method.getName());\n                    if (method.getName().equals(\"onSuccess\")) {\n                        JParameter[] parameters = method.getParameters();\n                        getLogger().log(DEBUG, \"checking method params: \" + parameters.length);\n                        if (parameters.length == 2) {\n                            getLogger().log(DEBUG, \"checking first param: \" + parameters[0].getType());\n                            if (parameters[0].getType() == METHOD_TYPE) {\n                                getLogger().log(DEBUG, \"checking 2nd param: \" + parameters[1].getType());\n                                JType param2Type = parameters[1].getType();\n                                JClassType type = param2Type.isClassOrInterface();\n                                if (type == null) {\n                                    getLogger().log(ERROR, \"The type of the callback not supported: \" + param2Type.getJNISignature());\n                                    throw new UnableToCompleteException();\n                                }\n                                getLogger().log(DEBUG, \"match: \" + type);\n                                return type;\n                            }\n                        }\n                    }\n                }\n                getLogger().log(ERROR, \"The type of the callback could not be determined: \" + callbackType.getParameterizedQualifiedSourceName());\n                throw new UnableToCompleteException();\n            }\n        });\n    }\n\n    private String getRestMethod(JMethod method) throws UnableToCompleteException {\n        String restMethod = null;\n        if (method.getAnnotation(DELETE.class) != null) {\n            restMethod = METHOD_DELETE;\n        } else if (method.getAnnotation(GET.class) != null) {\n            restMethod = METHOD_GET;\n        } else if (method.getAnnotation(HEAD.class) != null) {\n            restMethod = METHOD_HEAD;\n        } else if (method.getAnnotation(OPTIONS.class) != null) {\n            restMethod = METHOD_OPTIONS;\n        } else if (method.getAnnotation(POST.class) != null) {\n            restMethod = METHOD_POST;\n        } else if (method.getAnnotation(PUT.class) != null) {\n            restMethod = METHOD_PUT;\n        } else if (method.getAnnotation(JSONP.class) != null) {\n            restMethod = METHOD_JSONP;\n        } else {\n            restMethod = method.getName();\n            if (!REST_METHODS.contains(restMethod)) {\n                getLogger().log(ERROR, \"Invalid rest method. It must either have a lower case rest method name or have a javax rs method annotation: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n        }\n        return restMethod;\n    }\n\n    /**\n     * access additional AnnotationResolvers possibly added by\n     *\n     * {@link BindingDefaults#addAnnotationResolver(AnnotationResolver)}\n     * @return\n     */\n    // TODO remove suppression\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private List<AnnotationResolver> getAnnotationResolvers(final GeneratorContext context, final TreeLogger logger) {\n        java.lang.reflect.Method m = null;\n        ArrayList args = new ArrayList();\n        ArrayList types = new ArrayList();\n\n        types.add(GeneratorContext.class);\n        args.add(context);\n        types.add(TreeLogger.class);\n        args.add(logger);\n\n        Object[] argValues = args.toArray();\n        Class[] argtypes = (Class[]) types.toArray(new Class[argValues.length]);\n\n        try {\n             m = BINDING_DEFAULTS.getMethod(\"getAnnotationResolvers\", argtypes);\n        } catch (SecurityException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"could not resolve method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        List<AnnotationResolver> l = new ArrayList<AnnotationResolver>();\n        try {\n            l = (List<AnnotationResolver>) m.invoke(null, context, logger);\n        } catch (IllegalArgumentException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (InvocationTargetException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        return l;\n    }\n    \n    private String returnRequest(boolean returnRequest, boolean isJsonp) {\n        String type = isJsonp ? JsonpRequest.class.getName() : Request.class.getName();\n        return returnRequest ? \"return (\"+type+\")\" : \"\";\n    }    \n}\n","lineNo":312}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport com.google.gwt.core.client.*;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.*;\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.jsonp.client.JsonpRequest;\nimport com.google.gwt.user.client.rpc.RemoteServiceRelativePath;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport com.google.gwt.xml.client.Document;\nimport org.fusesource.restygwt.client.*;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport javax.ws.rs.*;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\nimport java.util.regex.Pattern;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added automatically create resource from Path annotation,\n *         enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\npublic class RestServiceClassCreator extends BaseSourceCreator {\n\n    private static final String REST_SERVICE_PROXY_SUFFIX = \"_Generated_RestServiceProxy_\";\n\n    private static final String METHOD_CLASS = Method.class.getName();\n    private static final String RESOURCE_CLASS = Resource.class.getName();\n    private static final String DISPATCHER_CLASS = Dispatcher.class.getName();\n    private static final String DEFAULTS_CLASS = Defaults.class.getName();\n    private static final String ABSTRACT_REQUEST_CALLBACK_CLASS = AbstractRequestCallback.class.getName();\n    private static final String ABSTRACT_ASYNC_CALLBACK_CLASS = AbstractAsyncCallback.class.getName();\n    private static final String JSON_PARSER_CLASS = JSONParser.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String REQUEST_EXCEPTION_CLASS = RequestException.class.getName();\n    private static final String RESPONSE_FORMAT_EXCEPTION_CLASS = ResponseFormatException.class.getName();\n    private static final String JSONP_METHOD_CLASS = JsonpMethod.class.getName();\n    private static final String FORM_POST_CONTENT_CLASS = FormPostContent.class.getName();\n\n    /*\n     * static class in which are some compile-time relevant infos.\n     *\n     * TODO (andi): too much flexibility and overhead with reflection here?\n     */\n    private static final Class<BindingDefaults> BINDING_DEFAULTS = BindingDefaults.class;\n\n    private static final String METHOD_JSONP = \"jsonp\";\n    private static final String METHOD_PUT = \"put\";\n    private static final String METHOD_POST = \"post\";\n    private static final String METHOD_OPTIONS = \"options\";\n    private static final String METHOD_HEAD = \"head\";\n    private static final String METHOD_GET = \"get\";\n    private static final String METHOD_DELETE = \"delete\";\n\n    private static final HashSet<String> REST_METHODS = new HashSet<String>(8);\n    static {\n        REST_METHODS.add(METHOD_DELETE);\n        REST_METHODS.add(METHOD_GET);\n        REST_METHODS.add(METHOD_HEAD);\n        REST_METHODS.add(METHOD_OPTIONS);\n        REST_METHODS.add(METHOD_POST);\n        REST_METHODS.add(METHOD_PUT);\n        REST_METHODS.add(METHOD_JSONP);\n    }\n\n    private JClassType XML_CALLBACK_TYPE;\n    private JClassType METHOD_CALLBACK_TYPE;\n    private JClassType TEXT_CALLBACK_TYPE;\n    private JClassType JSON_CALLBACK_TYPE;\n    private JClassType OVERLAY_CALLBACK_TYPE;\n    private JClassType DOCUMENT_TYPE;\n    private JClassType METHOD_TYPE;\n    private JClassType STRING_TYPE;\n    private JClassType JSON_VALUE_TYPE;\n    private JClassType OVERLAY_VALUE_TYPE;\n    private Set<JClassType> OVERLAY_ARRAY_TYPES;\n    private Set<JClassType> QUERY_PARAM_LIST_TYPES;\n    private JClassType REST_SERVICE_TYPE;\n    private JsonEncoderDecoderInstanceLocator locator;\n\n    public RestServiceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n        super(logger, context, source, REST_SERVICE_PROXY_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n    \tString parameters = \"\";\n    \tif(source instanceof JGenericType)\n    \t{\n    \t\tJGenericType gtype = (JGenericType)source;\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tbuilder.append(\"<\");\n\t\t\tboolean first = true;\n   \t\t\tfor(JTypeParameter arg : gtype.getTypeParameters())\n   \t\t\t{\n   \t\t\t\tif(!first)\n   \t\t\t\t\tbuilder.append(\",\");\n   \t\t\t\tbuilder.append(arg.getName());\n   \t\t\t\tbuilder.append(\" extends \");\n\t   \t\t\tbuilder.append(arg.getFirstBound().getParameterizedQualifiedSourceName());\n\t   \t\t\tfirst = false;\n   \t\t\t}\n   \t\t\tbuilder.append(\">\");\n   \t\t\tparameters = builder.toString();\n     \t}\n    \t\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName + parameters);\n        composerFactory.addImplementedInterface(source.getParameterizedQualifiedSourceName());\n        composerFactory.addImplementedInterface(RestServiceProxy.class.getName());\n        return composerFactory;\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n\n        if (source.isInterface() == null) {\n            getLogger().log(ERROR, \"Type is not an interface.\");\n            throw new UnableToCompleteException();\n        }\n\n        locator = new JsonEncoderDecoderInstanceLocator(context, getLogger());\n\n        this.XML_CALLBACK_TYPE = find(XmlCallback.class, getLogger(), context);\n        this.METHOD_CALLBACK_TYPE = find(MethodCallback.class, getLogger(), context);\n        this.TEXT_CALLBACK_TYPE = find(TextCallback.class, getLogger(), context);\n        this.JSON_CALLBACK_TYPE = find(JsonCallback.class, getLogger(), context);\n        this.OVERLAY_CALLBACK_TYPE = find(OverlayCallback.class, getLogger(), context);\n        this.DOCUMENT_TYPE = find(Document.class, getLogger(), context);\n        this.METHOD_TYPE = find(Method.class, getLogger(), context);\n        this.STRING_TYPE = find(String.class, getLogger(), context);\n        this.JSON_VALUE_TYPE = find(JSONValue.class, getLogger(), context);\n        this.OVERLAY_VALUE_TYPE = find(JavaScriptObject.class, getLogger(), context);\n        this.OVERLAY_ARRAY_TYPES = new HashSet<JClassType>();\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArray.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayBoolean.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayInteger.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayNumber.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayString.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES = new HashSet<JClassType>();\n        this.QUERY_PARAM_LIST_TYPES.add(find(List.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES.add(find(Set.class, getLogger(), context));\n\t\tthis.REST_SERVICE_TYPE = find(RestService.class, getLogger(), context);\n\t\t\n        String path = null;\n        Path pathAnnotation = source.getAnnotation(Path.class);\n        if (pathAnnotation != null) {\n            path = pathAnnotation.value();\n        }\n\n        RemoteServiceRelativePath relativePath = source.getAnnotation(RemoteServiceRelativePath.class);\n        if (relativePath != null) {\n            path = relativePath.value();\n        }\n\n        p(\"private \" + RESOURCE_CLASS + \" resource = null;\");\n        p();\n\n        p(\"public void setResource(\" + RESOURCE_CLASS + \" resource) {\").i(1);\n        {\n            p(\"this.resource = resource;\");\n        }\n        i(-1).p(\"}\");\n\n        p(\"public \" + RESOURCE_CLASS + \" getResource() {\").i(1);\n        {\n            p(\"if (this.resource == null) {\").i(1);\n            if (path == null) {\n                p(\"this.resource = new \" + RESOURCE_CLASS + \"(\" + DEFAULTS_CLASS + \".getServiceRoot());\");\n            } else {\n                p(\"this.resource = new \" + RESOURCE_CLASS + \"(\" + DEFAULTS_CLASS + \".getServiceRoot()).resolve(\"+quote(path)+\");\");\n            }\n            i(-1).p(\"}\");\n            p(\"return this.resource;\");\n        }\n        i(-1).p(\"}\");\n\n\n        Options options = source.getAnnotation(Options.class);\n        if( options!=null && options.dispatcher()!=Dispatcher.class ) {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = \"+options.dispatcher().getName()+\".INSTANCE;\");\n        } else {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = null;\");\n        }\n\n        p();\n        p(\"public void setDispatcher(\" + DISPATCHER_CLASS + \" dispatcher) {\").i(1);\n        {\n            p(\"this.dispatcher = dispatcher;\");\n        }\n        i(-1).p(\"}\");\n\n        p();\n        p(\"public \" + DISPATCHER_CLASS + \" getDispatcher() {\").i(1);\n        {\n            p(\"return this.dispatcher;\");\n        }\n        i(-1).p(\"}\");\n\n        for (JMethod method : source.getInheritableMethods()) {\n        \tJClassType iface = method.getReturnType().isInterface();\n        \tif(iface != null && REST_SERVICE_TYPE.isAssignableFrom(iface))\n        \t\twriteSubresourceLocatorImpl(method);\n        \telse\n            \twriteMethodImpl(method);\n        }\n    }\n\n    private String quote(String path) {\n        // TODO: unlikely to occur. but we should escape chars like newlines..\n        return \"\\\"\" + path + \"\\\"\";\n    }\n\n    private boolean isOverlayArrayType(JClassType type) {\n        for (JClassType arrayType : OVERLAY_ARRAY_TYPES) {\n            if (type.isAssignableTo(arrayType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isQueryParamListType(JClassType type) {\n        if (type.isParameterized() == null) {\n            return false;\n        }\n        for (JClassType listType : QUERY_PARAM_LIST_TYPES) {\n            if (type.isAssignableTo(listType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\t\n    private void writeSubresourceLocatorImpl(JMethod method) throws UnableToCompleteException\n    {\n    \tJClassType iface = method.getReturnType().isInterface();\n    \tif(iface == null || !REST_SERVICE_TYPE.isAssignableFrom(iface)) {\n    \t\tgetLogger().log(ERROR, \"Invalid subresource locator method. Method must have return type of an interface that extends RestService: \" + method.getReadableDeclaration());\n            throw new UnableToCompleteException();\n    \t}\n    \t\n        Path pathAnnotation = method.getAnnotation(Path.class);\n        if (pathAnnotation == null) {\n        \tgetLogger().log(ERROR, \"Invalid subresource locator method. Method must have @Path annotation: \" + method.getReadableDeclaration());\n            throw new UnableToCompleteException();\n        }\n        String pathExpression = wrap(pathAnnotation.value());\n\n        for (JParameter arg : method.getParameters()) {\n            PathParam paramPath = arg.getAnnotation(PathParam.class);\n            if (paramPath != null) {\n                pathExpression = pathExpression(pathExpression, arg, paramPath);\n            }\n        }\n\n\n        p(method.getReadableDeclaration(false, false, false, false, true) + \" {\").i(1);\n        {\n        \tJType type = method.getReturnType();\n        \tString name;\n        \tif(type instanceof JClassType)\n        \t{\n                JClassType restService = (JClassType)type;\n                RestServiceClassCreator generator = new RestServiceClassCreator(getLogger(), context, restService);\n                name = generator.create();\n        \t}\n        \telse\n        \t{\n        \t\tthrow new UnsupportedOperationException(\"Subresource method may not return: \" + type);\n        \t}\n        \tp(method.getReturnType().getQualifiedSourceName() + \" __subresource = new \" + name + \"();\");\n        \tp(\"((\" + RestServiceProxy.class.getName() + \")__subresource).setResource(getResource().resolve(\" + pathExpression + \"));\");\n        \tp(\"return __subresource;\");\n        }\n        i(-1).p(\"}\");\n    }\n\n    private String pathExpression(String pathExpression, JParameter arg, PathParam paramPath) {\n        String expr = toStringExpression(arg);\n        return pathExpression.replaceAll(Pattern.quote(\"{\" + paramPath.value() + \"}\"), \n               \"\\\"+(\" + expr + \"== null? null : com.google.gwt.http.client.URL.encodePathSegment(\" + expr + \"))+\\\"\");\n    }\n    \n    private void writeMethodImpl(JMethod method) throws UnableToCompleteException {\n        boolean returnRequest = false;\n        if (method.getReturnType() != JPrimitiveType.VOID) {\n            if (!method.getReturnType().getQualifiedSourceName().equals(Request.class.getName()) && \n                !method.getReturnType().getQualifiedSourceName().equals(JsonpRequest.class.getName())) {\n                getLogger().log(ERROR, \"Invalid rest method. Method must have void, Request or JsonpRequest return types: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            } else {\n                returnRequest = true;\n            }\n        }\n\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n\n        Options classOptions = source.getAnnotation(Options.class);\n        Options options = method.getAnnotation(Options.class);\n\n        p(method.getReadableDeclaration(false, false, false, false, true) + \" {\").i(1);\n        {\n            String restMethod = getRestMethod(method);\n            LinkedList<JParameter> args = new LinkedList<JParameter>(Arrays.asList(method.getParameters()));\n\n            // the last arg should be the callback.\n            if (args.isEmpty()) {\n                getLogger().log(ERROR, \"Invalid rest method. Method must declare at least a callback argument: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            JParameter callbackArg = args.removeLast();\n            JClassType callbackType = callbackArg.getType().isClassOrInterface();\n            JClassType methodCallbackType = METHOD_CALLBACK_TYPE;\n            if (callbackType == null || !callbackType.isAssignableTo(methodCallbackType)) {\n                getLogger().log(ERROR, \"Invalid rest method. Last argument must be a \" + methodCallbackType.getName() + \" type: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            JClassType resultType = getCallbackTypeGenericClass(callbackType);\n\n            String pathExpression = null;\n            Path pathAnnotation = method.getAnnotation(Path.class);\n            if (pathAnnotation != null) {\n                pathExpression = wrap(pathAnnotation.value());\n            }\n\n            JParameter contentArg = null;\n            HashMap<String, JParameter> queryParams = new HashMap<String, JParameter>();\n            HashMap<String, JParameter> formParams = new HashMap<String, JParameter>();\n            HashMap<String, JParameter> headerParams = new HashMap<String, JParameter>();\n\n            for (JParameter arg : args) {\n                PathParam paramPath = arg.getAnnotation(PathParam.class);\n                if (paramPath != null) {\n                    if (pathExpression == null) {\n                        getLogger().log(ERROR, \"Invalid rest method.  Invalid @PathParam annotation. Method is missing the @Path annotation: \" + method.getReadableDeclaration());\n                        throw new UnableToCompleteException();\n                    }\n                    pathExpression = pathExpression(pathExpression, arg, paramPath);\n                    //.replaceAll(Pattern.quote(\"{\" + paramPath.value() + \"}\"), \"\\\"+com.google.gwt.http.client.URL.encodePathSegment(\" + toStringExpression(arg) + \")+\\\"\");\n                    if (arg.getAnnotation(Attribute.class) != null) {\n                        // allow part of the arg-object participate in as PathParam and the object goes over the wire\n                        contentArg = arg;\n                    }\n                    continue;\n                }\n\n                QueryParam queryParam = arg.getAnnotation(QueryParam.class);\n                if (queryParam != null) {\n                    queryParams.put(queryParam.value(), arg);\n                    continue;\n                }\n\n                FormParam formParam = arg.getAnnotation(FormParam.class);\n                if (formParam != null) {\n                    formParams.put(formParam.value(), arg);\n                    continue;\n                }\n\n                HeaderParam headerParam = arg.getAnnotation(HeaderParam.class);\n                if (headerParam != null) {\n                    headerParams.put(headerParam.value(), arg);\n                    continue;\n                }\n\n                if (!formParams.isEmpty()) {\n                    getLogger().log(ERROR, \"You can not have both @FormParam parameters and a content parameter: \" +\n                                                method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n\n                if (contentArg != null) {\n                    getLogger().log(ERROR, \"Invalid rest method. Only one content parameter is supported: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n                contentArg = arg;\n            }\n\n            String acceptTypeBuiltIn = null;\n            if (callbackType.equals(TEXT_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_TEXT\";\n            } else if (callbackType.equals(JSON_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.isAssignableTo(OVERLAY_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.equals(XML_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_XML\";\n            }\n\n            p(\"final \" + METHOD_CLASS + \" __method =\");\n\n            p(\"getResource()\");\n            if (pathExpression != null) {\n                p(\".resolve(\" + pathExpression + \")\");\n            }\n            for (Map.Entry<String, JParameter> entry : queryParams.entrySet()) {\n                String expr = entry.getValue().getName();\n                JClassType type = entry.getValue().getType().isClassOrInterface();\n                if (type != null && isQueryParamListType(type)) {\n                    p(\".addQueryParams(\" + wrap(entry.getKey()) + \", \" +\n                      toIteratedStringExpression(entry.getValue()) + \")\");\n                } else {\n                    p(\".addQueryParam(\" + wrap(entry.getKey()) + \", \" +\n                      toStringExpression(entry.getValue().getType(), expr) + \")\");\n                }\n            }\n            // example: .get()\n            p(\".\" + restMethod + \"();\");\n\n            // Handle JSONP specific configuration...\n            JSONP jsonpAnnotation = method.getAnnotation(JSONP.class);\n\n            final boolean isJsonp = restMethod.equals(METHOD_JSONP) && jsonpAnnotation!=null;\n            if( isJsonp ) {\n                if (returnRequest && !method.getReturnType().getQualifiedSourceName().equals(JsonpRequest.class.getName())) {\n                    getLogger().log(ERROR, \"Invalid rest method. JSONP method must have void or JsonpRequest return types: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n                if( jsonpAnnotation.callbackParam().length() > 0 ) {\n                    p(\"((\"+JSONP_METHOD_CLASS+\")__method).callbackParam(\"+wrap(jsonpAnnotation.callbackParam())+\");\");\n                }\n                if( jsonpAnnotation.failureCallbackParam().length() > 0 ) {\n                    p(\"((\"+JSONP_METHOD_CLASS+\")__method).failureCallbackParam(\"+wrap(jsonpAnnotation.failureCallbackParam())+\");\");\n                }\n            } else {\n                if (returnRequest && !method.getReturnType().getQualifiedSourceName().equals(Request.class.getName())) {\n                    getLogger().log(ERROR, \"Invalid rest method. Non JSONP method must have void or Request return types: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n            }\n\n            // configure the dispatcher\n            if( options!=null && options.dispatcher()!=Dispatcher.class ) {\n                // use the dispatcher configured for the method.\n                p(\"__method.setDispatcher(\"+options.dispatcher().getName()+\".INSTANCE);\");\n            } else {\n                // use the default dispatcher configured for the service..\n                p(\"__method.setDispatcher(this.dispatcher);\");\n            }\n\n            // configure the expected statuses..\n            if( options!=null && options.expect().length!=0 ) {\n                // Using method level defined expected status\n                p(\"__method.expect(\"+join(options.expect(), \", \")+\");\");\n            } else if( classOptions!=null && classOptions.expect().length!=0 ) {\n                // Using class level defined expected status\n                p(\"__method.expect(\"+join(classOptions.expect(), \", \")+\");\");\n            }\n\n            // configure the timeout\n            if( options!=null && options.timeout() >= 0 ) {\n                // Using method level defined value\n                p(\"__method.timeout(\"+options.timeout()+\");\");\n            } else if( classOptions!=null && classOptions.timeout() >= 0 ) {\n                // Using class level defined value\n                p(\"__method.timeout(\"+classOptions.timeout()+\");\");\n            }\n\n            if(jsonpAnnotation == null) {\n                Produces producesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Produces.class);\n                if (producesAnnotation != null) {\n                    p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \"+wrap(producesAnnotation.value()[0])+\");\");\n                } else {\n                    // set the default accept header....\n                    if (acceptTypeBuiltIn != null) {\n                        p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \" + RESOURCE_CLASS + \".\" + acceptTypeBuiltIn + \");\");\n                    } else {\n                        p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \" + RESOURCE_CLASS + \".CONTENT_TYPE_JSON);\");\n                    }\n                }\n\n                Consumes consumesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Consumes.class);\n                if (consumesAnnotation != null) {\n                    p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_CONTENT_TYPE, \"+wrap(consumesAnnotation.value()[0])+\");\");\n                }\n\n                // and set the explicit headers now (could override the accept header)\n                for (Map.Entry<String, JParameter> entry : headerParams.entrySet()) {\n                    String expr = entry.getValue().getName();\n                    p(\"__method.header(\" + wrap(entry.getKey()) + \", \" + toStringExpression(entry.getValue().getType(), expr) + \");\");\n                }\n            }\n\n            if (! formParams.isEmpty()) {\n                p(FORM_POST_CONTENT_CLASS + \" __formPostContent = new \" + FORM_POST_CONTENT_CLASS + \"();\");\n\n                for (Map.Entry<String, JParameter> entry : formParams.entrySet()) {\n                    p(\"__formPostContent.addParameter(\" +\n                        wrap(entry.getKey()) + \", \" +\n                        toFormStringExpression(entry.getValue(), classStyle) +\n                        \");\");\n                }\n\n                p(\"__method.form(__formPostContent.getTextContent());\");\n            }\n\n            if (contentArg != null) {\n                if (contentArg.getType() == STRING_TYPE) {\n                    p(\"__method.text(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType() == JSON_VALUE_TYPE) {\n                    p(\"__method.json(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType().isClass() != null &&\n                           isOverlayArrayType(contentArg.getType().isClass())) {\n                    p(\"__method.json(new \" + JSON_ARRAY_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType().isClass() != null &&\n                           contentArg.getType().isClass().isAssignableTo(OVERLAY_VALUE_TYPE)) {\n                    p(\"__method.json(new \" + JSON_OBJECT_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType() == DOCUMENT_TYPE) {\n                    p(\"__method.xml(\" + contentArg.getName() + \");\");\n                } else {\n                    JClassType contentClass = contentArg.getType().isClass();\n                    if (contentClass == null) {\n                        contentClass = contentArg.getType().isClassOrInterface();\n                        if (!locator.isCollectionType(contentClass)) {\n                            getLogger().log(ERROR, \"Content argument must be a class.\");\n                            throw new UnableToCompleteException();\n                        }\n                    }\n\n                    jsonAnnotation = contentArg.getAnnotation(Json.class);\n                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n                    // example:\n                    // .json(Listings$_Generated_JsonEncoder_$.INSTANCE.encode(arg0)\n                    // )\n                    p(\"__method.json(\" + locator.encodeExpression(contentClass, contentArg.getName(), style) + \");\");\n                }\n            }\n\n\n            List<AnnotationResolver> annotationResolvers = getAnnotationResolvers(context, getLogger());\n            getLogger().log(TreeLogger.DEBUG, \"found \" + annotationResolvers.size() + \" additional AnnotationResolvers\");\n\n            for (AnnotationResolver a : annotationResolvers) {\n                getLogger().log(TreeLogger.DEBUG, \"(\" + a.getClass().getName() + \") resolve `\" + source.getName()\n                        + \"#\" + method.getName() + \" ...\");\n                final Map<String, String[]> addDataParams = a.resolveAnnotation(getLogger(), source, method, restMethod);\n\n                if (addDataParams != null) {\n                    for (String s : addDataParams.keySet()) {\n                        final StringBuilder sb = new StringBuilder();\n                        final List<String> classList = Arrays.asList(addDataParams.get(s));\n\n                        sb.append(\"[\");\n                        for (int i = 0; i < classList.size(); ++i) {\n                            sb.append(\"\\\\\\\"\").append(classList.get(i)).append(\"\\\\\\\"\");\n\n                            if ((i+1) <  classList.size()) {\n                                sb.append(\",\");\n                            }\n                        }\n                        sb.append(\"]\");\n\n                        getLogger().log(TreeLogger.DEBUG, \"add call with (\\\"\" + s + \"\\\", \\\"\" +\n                                sb.toString() + \"\\\")\");\n                        p(\"__method.addData(\\\"\" + s + \"\\\", \\\"\" + sb.toString() + \"\\\");\");\n                    }\n                }\n            }\n\n\n            if (acceptTypeBuiltIn != null) {\n                // TODO: shouldn't we also have a cach in here?\n                p(returnRequest(returnRequest,isJsonp) + \"__method.send(\" + callbackArg.getName() + \");\");\n            } else if ( isJsonp ){\n                    p(returnRequest(returnRequest,isJsonp) + \"((\" + JSONP_METHOD_CLASS + \")__method).send(new \" + ABSTRACT_ASYNC_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">((\" + JSONP_METHOD_CLASS + \")__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult(\" + JSON_VALUE_CLASS + \" result) throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) null;\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    if(resultType.isAssignableTo(locator.LIST_TYPE)){\n                                        p(\"result = new \" + JSON_ARRAY_CLASS + \"(result.getJavaScriptObject());\");\n                                    }\n                                    jsonAnnotation = method.getAnnotation(Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, \"result\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n            } else {\n                p(\"try {\").i(1);\n                {\n                    p(returnRequest(returnRequest,isJsonp) + \"__method.send(new \" + ABSTRACT_REQUEST_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">(__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult() throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) null;\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    jsonAnnotation = method.getAnnotation(Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, JSON_PARSER_CLASS + \".parse(__method.getResponse().getText())\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n                }\n                i(-1).p(\"} catch (\" + REQUEST_EXCEPTION_CLASS + \" __e) {\").i(1);\n                {\n                    p(callbackArg.getName() + \".onFailure(__method,__e);\");\n                    if (returnRequest) {\n                        p(\"return null;\");\n                    }                    \n                }\n                i(-1).p(\"}\");\n            }\n        }\n        i(-1).p(\"}\");\n    }\n\n    private <T extends Annotation> T findAnnotationOnMethodOrEnclosingType(final JMethod method, final Class<T> annotationType) {\n        T annotation = method.getAnnotation(annotationType);\n        if (annotation == null) {\n            annotation = method.getEnclosingType().getAnnotation(annotationType);\n        }\n        return annotation;\n    }\n\n    protected String toStringExpression(JParameter arg) {\n        Attribute attribute = arg.getAnnotation(Attribute.class);\n        if(attribute != null){\n            return arg.getName() + \".\" + attribute.value();\n        }\n        return toStringExpression(arg.getType(), arg.getName());\n    }\n\n    protected String toFormStringExpression(JParameter argument, Style classStyle) throws UnableToCompleteException {\n        JType type = argument.getType();\n        String expr = argument.getName();\n\n        if (type.isPrimitive() != null) {\n            return \"\\\"\\\"+\" + expr;\n        }\n        if (STRING_TYPE == type) {\n            return expr;\n        }\n        if (type.isClass() != null &&\n                isOverlayArrayType(type.isClass())) {\n            return \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.isClass() != null &&\n                OVERLAY_VALUE_TYPE.isAssignableFrom(type.isClass())) {\n            return \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.getQualifiedBinaryName().startsWith(\"java.lang.\")) {\n            return String.format(\"(%s != null ? %s.toString() : null)\", expr, expr);\n        }\n\n        Json jsonAnnotation = argument.getAnnotation(Json.class);\n        final Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n        return locator.encodeExpression(type, expr, style) + \".toString()\";\n    }\n\n    protected String toStringExpression(JType type, String expr) {\n        if (type.isPrimitive() != null) {\n            return \"\\\"\\\"+\" + expr;\n        }\n        if (STRING_TYPE == type) {\n            return expr;\n        }\n        if (type.isClass() != null &&\n            isOverlayArrayType(type.isClass())) {\n          return \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.isClass() != null &&\n            OVERLAY_VALUE_TYPE.isAssignableFrom(type.isClass())) {\n          return \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        }\n\n        return String.format(\"(%s != null ? %s.toString() : null)\", expr, expr);\n    }\n\n    protected String toIteratedStringExpression(JParameter arg) {\n        StringBuilder result = new StringBuilder();\n        result.append(\"new org.fusesource.restygwt.client.StringIterable (\")\n            .append(arg.getName()).append(\")\");\n\n        return result.toString();\n    }\n\n    private JClassType getCallbackTypeGenericClass(final JClassType callbackType) throws UnableToCompleteException {\n        return branch(\"getCallbackTypeGenericClass()\", new Branch<JClassType>() {\n            @Override\n            public JClassType execute() throws UnableToCompleteException {\n\n                for (JMethod method : callbackType.getOverridableMethods()) {\n                    getLogger().log(DEBUG, \"checking method: \" + method.getName());\n                    if (method.getName().equals(\"onSuccess\")) {\n                        JParameter[] parameters = method.getParameters();\n                        getLogger().log(DEBUG, \"checking method params: \" + parameters.length);\n                        if (parameters.length == 2) {\n                            getLogger().log(DEBUG, \"checking first param: \" + parameters[0].getType());\n                            if (parameters[0].getType() == METHOD_TYPE) {\n                                getLogger().log(DEBUG, \"checking 2nd param: \" + parameters[1].getType());\n                                JType param2Type = parameters[1].getType();\n                                JClassType type = param2Type.isClassOrInterface();\n                                if (type == null) {\n                                    getLogger().log(ERROR, \"The type of the callback not supported: \" + param2Type.getJNISignature());\n                                    throw new UnableToCompleteException();\n                                }\n                                getLogger().log(DEBUG, \"match: \" + type);\n                                return type;\n                            }\n                        }\n                    }\n                }\n                getLogger().log(ERROR, \"The type of the callback could not be determined: \" + callbackType.getParameterizedQualifiedSourceName());\n                throw new UnableToCompleteException();\n            }\n        });\n    }\n\n    private String getRestMethod(JMethod method) throws UnableToCompleteException {\n        String restMethod = null;\n        if (method.getAnnotation(DELETE.class) != null) {\n            restMethod = METHOD_DELETE;\n        } else if (method.getAnnotation(GET.class) != null) {\n            restMethod = METHOD_GET;\n        } else if (method.getAnnotation(HEAD.class) != null) {\n            restMethod = METHOD_HEAD;\n        } else if (method.getAnnotation(OPTIONS.class) != null) {\n            restMethod = METHOD_OPTIONS;\n        } else if (method.getAnnotation(POST.class) != null) {\n            restMethod = METHOD_POST;\n        } else if (method.getAnnotation(PUT.class) != null) {\n            restMethod = METHOD_PUT;\n        } else if (method.getAnnotation(JSONP.class) != null) {\n            restMethod = METHOD_JSONP;\n        } else {\n            restMethod = method.getName();\n            if (!REST_METHODS.contains(restMethod)) {\n                getLogger().log(ERROR, \"Invalid rest method. It must either have a lower case rest method name or have a javax rs method annotation: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n        }\n        return restMethod;\n    }\n\n    /**\n     * access additional AnnotationResolvers possibly added by\n     *\n     * {@link BindingDefaults#addAnnotationResolver(AnnotationResolver)}\n     * @return\n     */\n    // TODO remove suppression\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private List<AnnotationResolver> getAnnotationResolvers(final GeneratorContext context, final TreeLogger logger) {\n        java.lang.reflect.Method m = null;\n        ArrayList args = new ArrayList();\n        ArrayList types = new ArrayList();\n\n        types.add(GeneratorContext.class);\n        args.add(context);\n        types.add(TreeLogger.class);\n        args.add(logger);\n\n        Object[] argValues = args.toArray();\n        Class[] argtypes = (Class[]) types.toArray(new Class[argValues.length]);\n\n        try {\n             m = BINDING_DEFAULTS.getMethod(\"getAnnotationResolvers\", argtypes);\n        } catch (SecurityException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"could not resolve method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        List<AnnotationResolver> l = new ArrayList<AnnotationResolver>();\n        try {\n            l = (List<AnnotationResolver>) m.invoke(null, context, logger);\n        } catch (IllegalArgumentException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (InvocationTargetException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        return l;\n    }\n    \n    private String returnRequest(boolean returnRequest, boolean isJsonp) {\n        String type = isJsonp ? JsonpRequest.class.getName() : Request.class.getName();\n        return returnRequest ? \"return (\"+type+\")\" : \"\";\n    }    \n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport com.google.gwt.core.client.*;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.*;\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.jsonp.client.JsonpRequest;\nimport com.google.gwt.user.client.rpc.RemoteServiceRelativePath;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport com.google.gwt.xml.client.Document;\nimport org.fusesource.restygwt.client.*;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport javax.ws.rs.*;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\nimport java.util.regex.Pattern;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added automatically create resource from Path annotation,\n *         enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\npublic class RestServiceClassCreator extends BaseSourceCreator {\n\n    private static final String REST_SERVICE_PROXY_SUFFIX = \"_Generated_RestServiceProxy_\";\n\n    private static final String METHOD_CLASS = Method.class.getName();\n    private static final String RESOURCE_CLASS = Resource.class.getName();\n    private static final String DISPATCHER_CLASS = Dispatcher.class.getName();\n    private static final String DEFAULTS_CLASS = Defaults.class.getName();\n    private static final String ABSTRACT_REQUEST_CALLBACK_CLASS = AbstractRequestCallback.class.getName();\n    private static final String ABSTRACT_ASYNC_CALLBACK_CLASS = AbstractAsyncCallback.class.getName();\n    private static final String JSON_PARSER_CLASS = JSONParser.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String REQUEST_EXCEPTION_CLASS = RequestException.class.getName();\n    private static final String RESPONSE_FORMAT_EXCEPTION_CLASS = ResponseFormatException.class.getName();\n    private static final String JSONP_METHOD_CLASS = JsonpMethod.class.getName();\n    private static final String FORM_POST_CONTENT_CLASS = FormPostContent.class.getName();\n\n    /*\n     * static class in which are some compile-time relevant infos.\n     *\n     * TODO (andi): too much flexibility and overhead with reflection here?\n     */\n    private static final Class<BindingDefaults> BINDING_DEFAULTS = BindingDefaults.class;\n\n    private static final String METHOD_JSONP = \"jsonp\";\n    private static final String METHOD_PUT = \"put\";\n    private static final String METHOD_POST = \"post\";\n    private static final String METHOD_OPTIONS = \"options\";\n    private static final String METHOD_HEAD = \"head\";\n    private static final String METHOD_GET = \"get\";\n    private static final String METHOD_DELETE = \"delete\";\n\n    private static final HashSet<String> REST_METHODS = new HashSet<String>(8);\n    static {\n        REST_METHODS.add(METHOD_DELETE);\n        REST_METHODS.add(METHOD_GET);\n        REST_METHODS.add(METHOD_HEAD);\n        REST_METHODS.add(METHOD_OPTIONS);\n        REST_METHODS.add(METHOD_POST);\n        REST_METHODS.add(METHOD_PUT);\n        REST_METHODS.add(METHOD_JSONP);\n    }\n\n    private JClassType XML_CALLBACK_TYPE;\n    private JClassType METHOD_CALLBACK_TYPE;\n    private JClassType TEXT_CALLBACK_TYPE;\n    private JClassType JSON_CALLBACK_TYPE;\n    private JClassType OVERLAY_CALLBACK_TYPE;\n    private JClassType DOCUMENT_TYPE;\n    private JClassType METHOD_TYPE;\n    private JClassType STRING_TYPE;\n    private JClassType JSON_VALUE_TYPE;\n    private JClassType OVERLAY_VALUE_TYPE;\n    private Set<JClassType> OVERLAY_ARRAY_TYPES;\n    private Set<JClassType> QUERY_PARAM_LIST_TYPES;\n    private JClassType REST_SERVICE_TYPE;\n    private JsonEncoderDecoderInstanceLocator locator;\n\n    public RestServiceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n        super(logger, context, source, REST_SERVICE_PROXY_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n    \tString parameters = \"\";\n    \tif(source instanceof JGenericType)\n    \t{\n    \t\tJGenericType gtype = (JGenericType)source;\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tbuilder.append(\"<\");\n\t\t\tboolean first = true;\n   \t\t\tfor(JTypeParameter arg : gtype.getTypeParameters())\n   \t\t\t{\n   \t\t\t\tif(!first)\n   \t\t\t\t\tbuilder.append(\",\");\n   \t\t\t\tbuilder.append(arg.getName());\n   \t\t\t\tbuilder.append(\" extends \");\n\t   \t\t\tbuilder.append(arg.getFirstBound().getParameterizedQualifiedSourceName());\n\t   \t\t\tfirst = false;\n   \t\t\t}\n   \t\t\tbuilder.append(\">\");\n   \t\t\tparameters = builder.toString();\n     \t}\n    \t\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName + parameters);\n        composerFactory.addImplementedInterface(source.getParameterizedQualifiedSourceName());\n        composerFactory.addImplementedInterface(RestServiceProxy.class.getName());\n        return composerFactory;\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n\n        if (source.isInterface() == null) {\n            getLogger().log(ERROR, \"Type is not an interface.\");\n            throw new UnableToCompleteException();\n        }\n\n        locator = new JsonEncoderDecoderInstanceLocator(context, getLogger());\n\n        this.XML_CALLBACK_TYPE = find(XmlCallback.class, getLogger(), context);\n        this.METHOD_CALLBACK_TYPE = find(MethodCallback.class, getLogger(), context);\n        this.TEXT_CALLBACK_TYPE = find(TextCallback.class, getLogger(), context);\n        this.JSON_CALLBACK_TYPE = find(JsonCallback.class, getLogger(), context);\n        this.OVERLAY_CALLBACK_TYPE = find(OverlayCallback.class, getLogger(), context);\n        this.DOCUMENT_TYPE = find(Document.class, getLogger(), context);\n        this.METHOD_TYPE = find(Method.class, getLogger(), context);\n        this.STRING_TYPE = find(String.class, getLogger(), context);\n        this.JSON_VALUE_TYPE = find(JSONValue.class, getLogger(), context);\n        this.OVERLAY_VALUE_TYPE = find(JavaScriptObject.class, getLogger(), context);\n        this.OVERLAY_ARRAY_TYPES = new HashSet<JClassType>();\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArray.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayBoolean.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayInteger.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayNumber.class, getLogger(), context));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayString.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES = new HashSet<JClassType>();\n        this.QUERY_PARAM_LIST_TYPES.add(find(List.class, getLogger(), context));\n        this.QUERY_PARAM_LIST_TYPES.add(find(Set.class, getLogger(), context));\n\t\tthis.REST_SERVICE_TYPE = find(RestService.class, getLogger(), context);\n\t\t\n        String path = null;\n        Path pathAnnotation = source.getAnnotation(Path.class);\n        if (pathAnnotation != null) {\n            path = pathAnnotation.value();\n        }\n\n        RemoteServiceRelativePath relativePath = source.getAnnotation(RemoteServiceRelativePath.class);\n        if (relativePath != null) {\n            path = relativePath.value();\n        }\n\n        p(\"private \" + RESOURCE_CLASS + \" resource = null;\");\n        p();\n\n        p(\"public void setResource(\" + RESOURCE_CLASS + \" resource) {\").i(1);\n        {\n            p(\"this.resource = resource;\");\n        }\n        i(-1).p(\"}\");\n\n        p(\"public \" + RESOURCE_CLASS + \" getResource() {\").i(1);\n        {\n            p(\"if (this.resource == null) {\").i(1);\n            if (path == null) {\n                p(\"this.resource = new \" + RESOURCE_CLASS + \"(\" + DEFAULTS_CLASS + \".getServiceRoot());\");\n            } else {\n                p(\"this.resource = new \" + RESOURCE_CLASS + \"(\" + DEFAULTS_CLASS + \".getServiceRoot()).resolve(\"+quote(path)+\");\");\n            }\n            i(-1).p(\"}\");\n            p(\"return this.resource;\");\n        }\n        i(-1).p(\"}\");\n\n\n        Options options = source.getAnnotation(Options.class);\n        if( options!=null && options.dispatcher()!=Dispatcher.class ) {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = \"+options.dispatcher().getName()+\".INSTANCE;\");\n        } else {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = null;\");\n        }\n\n        p();\n        p(\"public void setDispatcher(\" + DISPATCHER_CLASS + \" dispatcher) {\").i(1);\n        {\n            p(\"this.dispatcher = dispatcher;\");\n        }\n        i(-1).p(\"}\");\n\n        p();\n        p(\"public \" + DISPATCHER_CLASS + \" getDispatcher() {\").i(1);\n        {\n            p(\"return this.dispatcher;\");\n        }\n        i(-1).p(\"}\");\n\n        for (JMethod method : source.getInheritableMethods()) {\n        \tJClassType iface = method.getReturnType().isInterface();\n        \tif(iface != null && REST_SERVICE_TYPE.isAssignableFrom(iface))\n        \t\twriteSubresourceLocatorImpl(method);\n        \telse\n            \twriteMethodImpl(method);\n        }\n    }\n\n    private String quote(String path) {\n        // TODO: unlikely to occur. but we should escape chars like newlines..\n        return \"\\\"\" + path + \"\\\"\";\n    }\n\n    private boolean isOverlayArrayType(JClassType type) {\n        for (JClassType arrayType : OVERLAY_ARRAY_TYPES) {\n            if (type.isAssignableTo(arrayType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isQueryParamListType(JClassType type) {\n        if (type.isParameterized() == null) {\n            return false;\n        }\n        for (JClassType listType : QUERY_PARAM_LIST_TYPES) {\n            if (type.isAssignableTo(listType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\t\n    private void writeSubresourceLocatorImpl(JMethod method) throws UnableToCompleteException\n    {\n    \tJClassType iface = method.getReturnType().isInterface();\n    \tif(iface == null || !REST_SERVICE_TYPE.isAssignableFrom(iface)) {\n    \t\tgetLogger().log(ERROR, \"Invalid subresource locator method. Method must have return type of an interface that extends RestService: \" + method.getReadableDeclaration());\n            throw new UnableToCompleteException();\n    \t}\n    \t\n        Path pathAnnotation = method.getAnnotation(Path.class);\n        if (pathAnnotation == null) {\n        \tgetLogger().log(ERROR, \"Invalid subresource locator method. Method must have @Path annotation: \" + method.getReadableDeclaration());\n            throw new UnableToCompleteException();\n        }\n        String pathExpression = wrap(pathAnnotation.value());\n\n        for (JParameter arg : method.getParameters()) {\n            PathParam paramPath = arg.getAnnotation(PathParam.class);\n            if (paramPath != null) {\n                pathExpression = pathExpression.replaceAll(Pattern.quote(\"{\" + paramPath.value() + \"}\"), \"\\\"+com.google.gwt.http.client.URL.encodePathSegment(\" + toStringExpression(arg) + \")+\\\"\");\n            }\n        }\n\n\n        p(method.getReadableDeclaration(false, false, false, false, true) + \" {\").i(1);\n        {\n        \tJType type = method.getReturnType();\n        \tString name;\n        \tif(type instanceof JClassType)\n        \t{\n                JClassType restService = (JClassType)type;\n                RestServiceClassCreator generator = new RestServiceClassCreator(getLogger(), context, restService);\n                name = generator.create();\n        \t}\n        \telse\n        \t{\n        \t\tthrow new UnsupportedOperationException(\"Subresource method may not return: \" + type);\n        \t}\n        \tp(method.getReturnType().getQualifiedSourceName() + \" __subresource = new \" + name + \"();\");\n        \tp(\"((\" + RestServiceProxy.class.getName() + \")__subresource).setResource(getResource().resolve(\" + pathExpression + \"));\");\n        \tp(\"return __subresource;\");\n        }\n        i(-1).p(\"}\");\n    }\n    \n    private void writeMethodImpl(JMethod method) throws UnableToCompleteException {\n        boolean returnRequest = false;\n        if (method.getReturnType() != JPrimitiveType.VOID) {\n            if (!method.getReturnType().getQualifiedSourceName().equals(Request.class.getName()) && \n                !method.getReturnType().getQualifiedSourceName().equals(JsonpRequest.class.getName())) {\n                getLogger().log(ERROR, \"Invalid rest method. Method must have void, Request or JsonpRequest return types: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            } else {\n                returnRequest = true;\n            }\n        }\n\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n\n        Options classOptions = source.getAnnotation(Options.class);\n        Options options = method.getAnnotation(Options.class);\n\n        p(method.getReadableDeclaration(false, false, false, false, true) + \" {\").i(1);\n        {\n            String restMethod = getRestMethod(method);\n            LinkedList<JParameter> args = new LinkedList<JParameter>(Arrays.asList(method.getParameters()));\n\n            // the last arg should be the callback.\n            if (args.isEmpty()) {\n                getLogger().log(ERROR, \"Invalid rest method. Method must declare at least a callback argument: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            JParameter callbackArg = args.removeLast();\n            JClassType callbackType = callbackArg.getType().isClassOrInterface();\n            JClassType methodCallbackType = METHOD_CALLBACK_TYPE;\n            if (callbackType == null || !callbackType.isAssignableTo(methodCallbackType)) {\n                getLogger().log(ERROR, \"Invalid rest method. Last argument must be a \" + methodCallbackType.getName() + \" type: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n            JClassType resultType = getCallbackTypeGenericClass(callbackType);\n\n            String pathExpression = null;\n            Path pathAnnotation = method.getAnnotation(Path.class);\n            if (pathAnnotation != null) {\n                pathExpression = wrap(pathAnnotation.value());\n            }\n\n            JParameter contentArg = null;\n            HashMap<String, JParameter> queryParams = new HashMap<String, JParameter>();\n            HashMap<String, JParameter> formParams = new HashMap<String, JParameter>();\n            HashMap<String, JParameter> headerParams = new HashMap<String, JParameter>();\n\n            for (JParameter arg : args) {\n                PathParam paramPath = arg.getAnnotation(PathParam.class);\n                if (paramPath != null) {\n                    if (pathExpression == null) {\n                        getLogger().log(ERROR, \"Invalid rest method.  Invalid @PathParam annotation. Method is missing the @Path annotation: \" + method.getReadableDeclaration());\n                        throw new UnableToCompleteException();\n                    }\n                    pathExpression = pathExpression.replaceAll(Pattern.quote(\"{\" + paramPath.value() + \"}\"), \"\\\"+com.google.gwt.http.client.URL.encodePathSegment(\" + toStringExpression(arg) + \")+\\\"\");\n                    if (arg.getAnnotation(Attribute.class) != null) {\n                        // allow part of the arg-object participate in as PathParam and the object goes over the wire\n                        contentArg = arg;\n                    }\n                    continue;\n                }\n\n                QueryParam queryParam = arg.getAnnotation(QueryParam.class);\n                if (queryParam != null) {\n                    queryParams.put(queryParam.value(), arg);\n                    continue;\n                }\n\n                FormParam formParam = arg.getAnnotation(FormParam.class);\n                if (formParam != null) {\n                    formParams.put(formParam.value(), arg);\n                    continue;\n                }\n\n                HeaderParam headerParam = arg.getAnnotation(HeaderParam.class);\n                if (headerParam != null) {\n                    headerParams.put(headerParam.value(), arg);\n                    continue;\n                }\n\n                if (!formParams.isEmpty()) {\n                    getLogger().log(ERROR, \"You can not have both @FormParam parameters and a content parameter: \" +\n                                                method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n\n                if (contentArg != null) {\n                    getLogger().log(ERROR, \"Invalid rest method. Only one content parameter is supported: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n                contentArg = arg;\n            }\n\n            String acceptTypeBuiltIn = null;\n            if (callbackType.equals(TEXT_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_TEXT\";\n            } else if (callbackType.equals(JSON_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.isAssignableTo(OVERLAY_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.equals(XML_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_XML\";\n            }\n\n            p(\"final \" + METHOD_CLASS + \" __method =\");\n\n            p(\"getResource()\");\n            if (pathExpression != null) {\n                p(\".resolve(\" + pathExpression + \")\");\n            }\n            for (Map.Entry<String, JParameter> entry : queryParams.entrySet()) {\n                String expr = entry.getValue().getName();\n                JClassType type = entry.getValue().getType().isClassOrInterface();\n                if (type != null && isQueryParamListType(type)) {\n                    p(\".addQueryParams(\" + wrap(entry.getKey()) + \", \" +\n                      toIteratedStringExpression(entry.getValue()) + \")\");\n                } else {\n                    p(\".addQueryParam(\" + wrap(entry.getKey()) + \", \" +\n                      toStringExpression(entry.getValue().getType(), expr) + \")\");\n                }\n            }\n            // example: .get()\n            p(\".\" + restMethod + \"();\");\n\n            // Handle JSONP specific configuration...\n            JSONP jsonpAnnotation = method.getAnnotation(JSONP.class);\n\n            final boolean isJsonp = restMethod.equals(METHOD_JSONP) && jsonpAnnotation!=null;\n            if( isJsonp ) {\n                if (returnRequest && !method.getReturnType().getQualifiedSourceName().equals(JsonpRequest.class.getName())) {\n                    getLogger().log(ERROR, \"Invalid rest method. JSONP method must have void or JsonpRequest return types: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n                if( jsonpAnnotation.callbackParam().length() > 0 ) {\n                    p(\"((\"+JSONP_METHOD_CLASS+\")__method).callbackParam(\"+wrap(jsonpAnnotation.callbackParam())+\");\");\n                }\n                if( jsonpAnnotation.failureCallbackParam().length() > 0 ) {\n                    p(\"((\"+JSONP_METHOD_CLASS+\")__method).failureCallbackParam(\"+wrap(jsonpAnnotation.failureCallbackParam())+\");\");\n                }\n            } else {\n                if (returnRequest && !method.getReturnType().getQualifiedSourceName().equals(Request.class.getName())) {\n                    getLogger().log(ERROR, \"Invalid rest method. Non JSONP method must have void or Request return types: \" + method.getReadableDeclaration());\n                    throw new UnableToCompleteException();\n                }\n            }\n\n            // configure the dispatcher\n            if( options!=null && options.dispatcher()!=Dispatcher.class ) {\n                // use the dispatcher configured for the method.\n                p(\"__method.setDispatcher(\"+options.dispatcher().getName()+\".INSTANCE);\");\n            } else {\n                // use the default dispatcher configured for the service..\n                p(\"__method.setDispatcher(this.dispatcher);\");\n            }\n\n            // configure the expected statuses..\n            if( options!=null && options.expect().length!=0 ) {\n                // Using method level defined expected status\n                p(\"__method.expect(\"+join(options.expect(), \", \")+\");\");\n            } else if( classOptions!=null && classOptions.expect().length!=0 ) {\n                // Using class level defined expected status\n                p(\"__method.expect(\"+join(classOptions.expect(), \", \")+\");\");\n            }\n\n            // configure the timeout\n            if( options!=null && options.timeout() >= 0 ) {\n                // Using method level defined value\n                p(\"__method.timeout(\"+options.timeout()+\");\");\n            } else if( classOptions!=null && classOptions.timeout() >= 0 ) {\n                // Using class level defined value\n                p(\"__method.timeout(\"+classOptions.timeout()+\");\");\n            }\n\n            if(jsonpAnnotation == null) {\n                Produces producesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Produces.class);\n                if (producesAnnotation != null) {\n                    p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \"+wrap(producesAnnotation.value()[0])+\");\");\n                } else {\n                    // set the default accept header....\n                    if (acceptTypeBuiltIn != null) {\n                        p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \" + RESOURCE_CLASS + \".\" + acceptTypeBuiltIn + \");\");\n                    } else {\n                        p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \" + RESOURCE_CLASS + \".CONTENT_TYPE_JSON);\");\n                    }\n                }\n\n                Consumes consumesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Consumes.class);\n                if (consumesAnnotation != null) {\n                    p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_CONTENT_TYPE, \"+wrap(consumesAnnotation.value()[0])+\");\");\n                }\n\n                // and set the explicit headers now (could override the accept header)\n                for (Map.Entry<String, JParameter> entry : headerParams.entrySet()) {\n                    String expr = entry.getValue().getName();\n                    p(\"__method.header(\" + wrap(entry.getKey()) + \", \" + toStringExpression(entry.getValue().getType(), expr) + \");\");\n                }\n            }\n\n            if (! formParams.isEmpty()) {\n                p(FORM_POST_CONTENT_CLASS + \" __formPostContent = new \" + FORM_POST_CONTENT_CLASS + \"();\");\n\n                for (Map.Entry<String, JParameter> entry : formParams.entrySet()) {\n                    p(\"__formPostContent.addParameter(\" +\n                        wrap(entry.getKey()) + \", \" +\n                        toFormStringExpression(entry.getValue(), classStyle) +\n                        \");\");\n                }\n\n                p(\"__method.form(__formPostContent.getTextContent());\");\n            }\n\n            if (contentArg != null) {\n                if (contentArg.getType() == STRING_TYPE) {\n                    p(\"__method.text(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType() == JSON_VALUE_TYPE) {\n                    p(\"__method.json(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType().isClass() != null &&\n                           isOverlayArrayType(contentArg.getType().isClass())) {\n                    p(\"__method.json(new \" + JSON_ARRAY_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType().isClass() != null &&\n                           contentArg.getType().isClass().isAssignableTo(OVERLAY_VALUE_TYPE)) {\n                    p(\"__method.json(new \" + JSON_OBJECT_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType() == DOCUMENT_TYPE) {\n                    p(\"__method.xml(\" + contentArg.getName() + \");\");\n                } else {\n                    JClassType contentClass = contentArg.getType().isClass();\n                    if (contentClass == null) {\n                        contentClass = contentArg.getType().isClassOrInterface();\n                        if (!locator.isCollectionType(contentClass)) {\n                            getLogger().log(ERROR, \"Content argument must be a class.\");\n                            throw new UnableToCompleteException();\n                        }\n                    }\n\n                    jsonAnnotation = contentArg.getAnnotation(Json.class);\n                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n                    // example:\n                    // .json(Listings$_Generated_JsonEncoder_$.INSTANCE.encode(arg0)\n                    // )\n                    p(\"__method.json(\" + locator.encodeExpression(contentClass, contentArg.getName(), style) + \");\");\n                }\n            }\n\n\n            List<AnnotationResolver> annotationResolvers = getAnnotationResolvers(context, getLogger());\n            getLogger().log(TreeLogger.DEBUG, \"found \" + annotationResolvers.size() + \" additional AnnotationResolvers\");\n\n            for (AnnotationResolver a : annotationResolvers) {\n                getLogger().log(TreeLogger.DEBUG, \"(\" + a.getClass().getName() + \") resolve `\" + source.getName()\n                        + \"#\" + method.getName() + \" ...\");\n                final Map<String, String[]> addDataParams = a.resolveAnnotation(getLogger(), source, method, restMethod);\n\n                if (addDataParams != null) {\n                    for (String s : addDataParams.keySet()) {\n                        final StringBuilder sb = new StringBuilder();\n                        final List<String> classList = Arrays.asList(addDataParams.get(s));\n\n                        sb.append(\"[\");\n                        for (int i = 0; i < classList.size(); ++i) {\n                            sb.append(\"\\\\\\\"\").append(classList.get(i)).append(\"\\\\\\\"\");\n\n                            if ((i+1) <  classList.size()) {\n                                sb.append(\",\");\n                            }\n                        }\n                        sb.append(\"]\");\n\n                        getLogger().log(TreeLogger.DEBUG, \"add call with (\\\"\" + s + \"\\\", \\\"\" +\n                                sb.toString() + \"\\\")\");\n                        p(\"__method.addData(\\\"\" + s + \"\\\", \\\"\" + sb.toString() + \"\\\");\");\n                    }\n                }\n            }\n\n\n            if (acceptTypeBuiltIn != null) {\n                // TODO: shouldn't we also have a cach in here?\n                p(returnRequest(returnRequest,isJsonp) + \"__method.send(\" + callbackArg.getName() + \");\");\n            } else if ( isJsonp ){\n                    p(returnRequest(returnRequest,isJsonp) + \"((\" + JSONP_METHOD_CLASS + \")__method).send(new \" + ABSTRACT_ASYNC_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">((\" + JSONP_METHOD_CLASS + \")__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult(\" + JSON_VALUE_CLASS + \" result) throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) null;\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    if(resultType.isAssignableTo(locator.LIST_TYPE)){\n                                        p(\"result = new \" + JSON_ARRAY_CLASS + \"(result.getJavaScriptObject());\");\n                                    }\n                                    jsonAnnotation = method.getAnnotation(Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, \"result\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n            } else {\n                p(\"try {\").i(1);\n                {\n                    p(returnRequest(returnRequest,isJsonp) + \"__method.send(new \" + ABSTRACT_REQUEST_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">(__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult() throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) null;\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    jsonAnnotation = method.getAnnotation(Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, JSON_PARSER_CLASS + \".parse(__method.getResponse().getText())\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n                }\n                i(-1).p(\"} catch (\" + REQUEST_EXCEPTION_CLASS + \" __e) {\").i(1);\n                {\n                    p(callbackArg.getName() + \".onFailure(__method,__e);\");\n                    if (returnRequest) {\n                        p(\"return null;\");\n                    }                    \n                }\n                i(-1).p(\"}\");\n            }\n        }\n        i(-1).p(\"}\");\n    }\n\n    private <T extends Annotation> T findAnnotationOnMethodOrEnclosingType(final JMethod method, final Class<T> annotationType) {\n        T annotation = method.getAnnotation(annotationType);\n        if (annotation == null) {\n            annotation = method.getEnclosingType().getAnnotation(annotationType);\n        }\n        return annotation;\n    }\n\n    protected String toStringExpression(JParameter arg) {\n        Attribute attribute = arg.getAnnotation(Attribute.class);\n        if(attribute != null){\n            return arg.getName() + \".\" + attribute.value();\n        }\n        return toStringExpression(arg.getType(), arg.getName());\n    }\n\n    protected String toFormStringExpression(JParameter argument, Style classStyle) throws UnableToCompleteException {\n        JType type = argument.getType();\n        String expr = argument.getName();\n\n        if (type.isPrimitive() != null) {\n            return \"\\\"\\\"+\" + expr;\n        }\n        if (STRING_TYPE == type) {\n            return expr;\n        }\n        if (type.isClass() != null &&\n                isOverlayArrayType(type.isClass())) {\n            return \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.isClass() != null &&\n                OVERLAY_VALUE_TYPE.isAssignableFrom(type.isClass())) {\n            return \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.getQualifiedBinaryName().startsWith(\"java.lang.\")) {\n            return String.format(\"(%s != null ? %s.toString() : null)\", expr, expr);\n        }\n\n        Json jsonAnnotation = argument.getAnnotation(Json.class);\n        final Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n        return locator.encodeExpression(type, expr, style) + \".toString()\";\n    }\n\n    protected String toStringExpression(JType type, String expr) {\n        if (type.isPrimitive() != null) {\n            return \"\\\"\\\"+\" + expr;\n        }\n        if (STRING_TYPE == type) {\n            return expr;\n        }\n        if (type.isClass() != null &&\n            isOverlayArrayType(type.isClass())) {\n          return \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.isClass() != null &&\n            OVERLAY_VALUE_TYPE.isAssignableFrom(type.isClass())) {\n          return \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        }\n\n        return String.format(\"(%s != null ? %s.toString() : null)\", expr, expr);\n    }\n\n    protected String toIteratedStringExpression(JParameter arg) {\n        StringBuilder result = new StringBuilder();\n        result.append(\"new org.fusesource.restygwt.client.StringIterable (\")\n            .append(arg.getName()).append(\")\");\n\n        return result.toString();\n    }\n\n    private JClassType getCallbackTypeGenericClass(final JClassType callbackType) throws UnableToCompleteException {\n        return branch(\"getCallbackTypeGenericClass()\", new Branch<JClassType>() {\n            @Override\n            public JClassType execute() throws UnableToCompleteException {\n\n                for (JMethod method : callbackType.getOverridableMethods()) {\n                    getLogger().log(DEBUG, \"checking method: \" + method.getName());\n                    if (method.getName().equals(\"onSuccess\")) {\n                        JParameter[] parameters = method.getParameters();\n                        getLogger().log(DEBUG, \"checking method params: \" + parameters.length);\n                        if (parameters.length == 2) {\n                            getLogger().log(DEBUG, \"checking first param: \" + parameters[0].getType());\n                            if (parameters[0].getType() == METHOD_TYPE) {\n                                getLogger().log(DEBUG, \"checking 2nd param: \" + parameters[1].getType());\n                                JType param2Type = parameters[1].getType();\n                                JClassType type = param2Type.isClassOrInterface();\n                                if (type == null) {\n                                    getLogger().log(ERROR, \"The type of the callback not supported: \" + param2Type.getJNISignature());\n                                    throw new UnableToCompleteException();\n                                }\n                                getLogger().log(DEBUG, \"match: \" + type);\n                                return type;\n                            }\n                        }\n                    }\n                }\n                getLogger().log(ERROR, \"The type of the callback could not be determined: \" + callbackType.getParameterizedQualifiedSourceName());\n                throw new UnableToCompleteException();\n            }\n        });\n    }\n\n    private String getRestMethod(JMethod method) throws UnableToCompleteException {\n        String restMethod = null;\n        if (method.getAnnotation(DELETE.class) != null) {\n            restMethod = METHOD_DELETE;\n        } else if (method.getAnnotation(GET.class) != null) {\n            restMethod = METHOD_GET;\n        } else if (method.getAnnotation(HEAD.class) != null) {\n            restMethod = METHOD_HEAD;\n        } else if (method.getAnnotation(OPTIONS.class) != null) {\n            restMethod = METHOD_OPTIONS;\n        } else if (method.getAnnotation(POST.class) != null) {\n            restMethod = METHOD_POST;\n        } else if (method.getAnnotation(PUT.class) != null) {\n            restMethod = METHOD_PUT;\n        } else if (method.getAnnotation(JSONP.class) != null) {\n            restMethod = METHOD_JSONP;\n        } else {\n            restMethod = method.getName();\n            if (!REST_METHODS.contains(restMethod)) {\n                getLogger().log(ERROR, \"Invalid rest method. It must either have a lower case rest method name or have a javax rs method annotation: \" + method.getReadableDeclaration());\n                throw new UnableToCompleteException();\n            }\n        }\n        return restMethod;\n    }\n\n    /**\n     * access additional AnnotationResolvers possibly added by\n     *\n     * {@link BindingDefaults#addAnnotationResolver(AnnotationResolver)}\n     * @return\n     */\n    // TODO remove suppression\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private List<AnnotationResolver> getAnnotationResolvers(final GeneratorContext context, final TreeLogger logger) {\n        java.lang.reflect.Method m = null;\n        ArrayList args = new ArrayList();\n        ArrayList types = new ArrayList();\n\n        types.add(GeneratorContext.class);\n        args.add(context);\n        types.add(TreeLogger.class);\n        args.add(logger);\n\n        Object[] argValues = args.toArray();\n        Class[] argtypes = (Class[]) types.toArray(new Class[argValues.length]);\n\n        try {\n             m = BINDING_DEFAULTS.getMethod(\"getAnnotationResolvers\", argtypes);\n        } catch (SecurityException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"could not resolve method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        List<AnnotationResolver> l = new ArrayList<AnnotationResolver>();\n        try {\n            l = (List<AnnotationResolver>) m.invoke(null, context, logger);\n        } catch (IllegalArgumentException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (InvocationTargetException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        return l;\n    }\n    \n    private String returnRequest(boolean returnRequest, boolean isJsonp) {\n        String type = isJsonp ? JsonpRequest.class.getName() : Request.class.getName();\n        return returnRequest ? \"return (\"+type+\")\" : \"\";\n    }    \n}\n","lineNo":312}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.codehaus.jackson.annotate.JsonCreator;\nimport org.codehaus.jackson.annotate.JsonIgnore;\nimport org.codehaus.jackson.annotate.JsonIgnoreProperties;\nimport org.codehaus.jackson.annotate.JsonProperty;\nimport org.codehaus.jackson.annotate.JsonSubTypes;\nimport org.codehaus.jackson.annotate.JsonTypeInfo;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.As;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.Id;\nimport org.codehaus.jackson.annotate.JsonTypeName;\nimport org.codehaus.jackson.map.annotate.JsonTypeIdResolver;\nimport org.codehaus.jackson.map.jsontype.TypeIdResolver;\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JConstructor;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.thirdparty.guava.common.collect.Lists;\nimport com.google.gwt.thirdparty.guava.common.collect.Maps;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * \n *         Updates: added getter & setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n * \n *         added polymorphic support\n * @author <a href=\"http://charliemason.info\">Charlie Mason<\/a>\n * \n */\n\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n\n    JsonEncoderDecoderInstanceLocator locator;\n\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n\tsuper(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n\tClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n\tcomposerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n\treturn composerFactory;\n    }\n\n    private static class Subtype {\n\tfinal String tag;\n\tfinal JClassType clazz;\n\n\tpublic Subtype(String tag, JClassType clazz) {\n\t    this.tag = tag;\n\t    this.clazz = clazz;\n\t}\n    }\n\n    private <T extends Annotation> T findAnnotation(JClassType clazz, Class<T> annotation) {\n\tif (clazz == null)\n\t    return null;\n\telse if (clazz.isAnnotationPresent(annotation))\n\t    return clazz.getAnnotation(annotation);\n\telse\n\t    return findAnnotation(clazz.getSuperclass(), annotation);\n    }\n\n    @Override\n    public void generate() throws UnableToCompleteException {\n        final List<Subtype> possibleTypes = Lists.newArrayList();\n        final JsonTypeInfo typeInfo = findAnnotation(source, JsonTypeInfo.class);\n        final boolean isLeaf = !source.isAnnotationPresent(JsonTypeInfo.class);\n        if (typeInfo != null) {\n            final JsonSubTypes jacksonSubTypes = findAnnotation(source, JsonSubTypes.class);\n            if (typeInfo.use() == Id.CLASS || typeInfo.use() == Id.MINIMAL_CLASS) {\n        \tif (jacksonSubTypes != null) {\n        \t    for (JsonSubTypes.Type type : jacksonSubTypes.value()) {\n        \t\tJClassType typeClass = find(type.value());\n        \t\tif (!isLeaf || source.equals(typeClass))\n        \t\t    possibleTypes.add(new Subtype(typeInfo.use() == Id.CLASS ? typeClass.getQualifiedSourceName() : typeClass.getSimpleSourceName(), typeClass));\n        \t    }\n        \t} else {\n        \t    error(\"@JsonSubTypes annotation missing for type: \" + source);\n        \t}\n            } else if (typeInfo.use() != Id.NONE) {\n        \tfinal JsonTypeIdResolver typeResolver = findAnnotation(source, JsonTypeIdResolver.class);\n        \tif (jacksonSubTypes != null) {\n        \t    for (JsonSubTypes.Type type : jacksonSubTypes.value()) {\n        \t\tif (type.name() != null && !type.name().isEmpty()) {\n        \t\t    JClassType typeClass = find(type.value());\n        \t\t    if (!isLeaf || source.equals(typeClass))\n        \t\t\tpossibleTypes.add(new Subtype(type.name(), typeClass));\n        \t\t} else {\n        \t\t    JsonTypeName nameAnnotation = type.value().getAnnotation(JsonTypeName.class);\n        \t\t    if (nameAnnotation == null || nameAnnotation.value() == null || nameAnnotation.value().isEmpty())\n        \t\t\terror(\"Cannot find @JsonTypeName annotation for type: \" + type.value());\n        \t\t    JClassType typeClass = find(type.value());\n        \t\t    if (!isLeaf || source.equals(typeClass))\n        \t\t\tpossibleTypes.add(new Subtype(nameAnnotation.value(), typeClass));\n        \t\t}\n        \t    }\n        \t    if (isLeaf && possibleTypes.size() == 0)\n        \t\terror(\"Could not find @JsonSubTypes entry for type: \" + source);\n        \t} else if (typeResolver != null) {\n        \t    Class<? extends TypeIdResolver> resolverClass = typeResolver.value();\n        \t    RestyJsonTypeIdResolver restyResolver;\n        \t    if (RestyJsonTypeIdResolver.class.isAssignableFrom(resolverClass)) {\n        \t\ttry {\n        \t\t    restyResolver = (RestyJsonTypeIdResolver) resolverClass.newInstance();\n        \t\t} catch (Exception e) {\n        \t\t    logger.log(ERROR, \"Could not acccess: \" + resolverClass, e);\n        \t\t    throw new UnableToCompleteException();\n        \t\t}\n        \t    } else {\n        \t\trestyResolver = getRestyResolverClassMap(context, logger).get(resolverClass);\n        \t\tif (restyResolver == null)\n        \t\t    error(\"Could not find RestyJsonTypeIdResolver for \" + resolverClass + \" did you forget to put <extend-configuration-property name=\\\"org.fusesource.restygwt.jsontypeidresolver\\\" value=\\\"<fully-qualified-class-implementing-RestyJsonTypeIdResolver>\\\"/> in your *.gwt.xml?\");\n    \n        \t    }\n    \n        \t    for (Map.Entry<String, Class<?>> entry : restyResolver.getIdClassMap().entrySet()) {\n        \t\tJClassType entryType = find(entry.getValue());\n        \t\tif (!isLeaf || source.equals(entryType))\n        \t\t    possibleTypes.add(new Subtype(entry.getKey(), entryType));\n        \t    }\n        \t    if (isLeaf && possibleTypes.size() == 0)\n        \t\terror(\"Could not find entry in \" + restyResolver.getClass().getName() + \" for type: \" + source);\n        \t} else {\n        \t    error(\"Cannot find required subtype resolution for type: \" + source);\n        \t}\n            } else {\n        \terror(\"Id.NONE not supported\");\n            }\n        } else {\n            possibleTypes.add(new Subtype(null, source));\n        }\n        locator = new JsonEncoderDecoderInstanceLocator(context, logger);\n    \n        JClassType sourceClazz = source.isClass();\n        if (sourceClazz == null) {\n            error(\"Type is not a class\");\n        }\n    \n    \n        if (sourceClazz.isAbstract()) {\n            if (typeInfo == null) {\n        \terror(\"Abstract classes must be annotated with JsonTypeInfo\");\n            }\n        }\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n        final String railsWrapperName = jsonAnnotation != null && jsonAnnotation.name().length() > 0 ? jsonAnnotation.name() : sourceClazz.getName().toLowerCase();\n    \n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n    \n        if (null != sourceClazz.isEnum()) {\n            p();\n            p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n            {\n        \tp(\"if( value==null ) {\").i(1);\n        \t{\n        \t    p(\"return com.google.gwt.json.client.JSONNull.getInstance();\").i(-1);\n        \t}\n        \tp(\"}\");\n        \tp(\"return new com.google.gwt.json.client.JSONString(value.name());\");\n            }\n            i(-1).p(\"}\");\n            p();\n            p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n            {\n        \tp(\"if( value == null || value.isNull()!=null ) {\").i(1);\n        \t{\n        \t    p(\"return null;\").i(-1);\n        \t}\n        \tp(\"}\");\n        \tp(\"com.google.gwt.json.client.JSONString str = value.isString();\");\n        \tp(\"if( null == str ) {\").i(1);\n        \t{\n        \t    p(\"throw new DecodingException(\\\"Expected a json string (for enum), but was given: \\\"+value);\").i(-1);\n        \t}\n        \tp(\"}\");\n        \tp(\"return Enum.valueOf(\" + source.getParameterizedQualifiedSourceName() + \".class, str.stringValue());\").i(-1);\n            }\n            p(\"}\");\n            p();\n            return;\n        }\n    \n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n        \tp(\"return null;\");\n            }\n            i(-1).p(\"}\");\n    \n            boolean returnWrapper = false; // if set, return rrc\n    \n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n            if (classStyle == Style.RAILS) {\n        \treturnWrapper = true;\n        \tp(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n        \tp(\"rrc.put(\\\"\" + railsWrapperName + \"\\\" , rc);\");\n            }\n    \n            for (Subtype possibleType : possibleTypes) {\n        \t// Try to find a constuctor that is annotated as creator\n        \tfinal JConstructor creator = findCreator(possibleType.clazz);\n        \t\n                List<JField> orderedFields = creator == null ? null : getOrderedFields(getFields(possibleType.clazz), creator);\n    \n        \tif (!isLeaf) {\n        \t    // Generate a decoder for each possible type\n        \t    p(\"if(value.getClass().getName().equals(\\\"\" + possibleType.clazz.getQualifiedBinaryName() + \"\\\"))\");\n        \t    p(\"{\");\n        \t}\n    \n        \tif (typeInfo != null) {\n        \t    switch (typeInfo.include()) {\n        \t    case PROPERTY:\n        \t\tp(\"com.google.gwt.json.client.JSONValue className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\");\");\n        \t\tp(\"if( className!=null ) { \").i(1);\n        \t\tp(\"rc.put(\" + getTypeInfoPropertyValue(typeInfo) + \", className);\");\n        \t\ti(-1).p(\"}\");\n        \t\tbreak;\n        \t    case WRAPPER_OBJECT:\n        \t\treturnWrapper = true;\n        \t\tp(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n        \t\tp(\"rrc.put(\\\"\" + possibleType.tag + \"\\\", rc);\");\n        \t\tbreak;\n        \t    case WRAPPER_ARRAY:\n        \t\treturnWrapper = true;\n        \t\tp(JSON_ARRAY_CLASS + \" rrc = new \" + JSON_ARRAY_CLASS + \"();\");\n        \t\tp(\"rrc.set(0, org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\"));\");\n        \t\tp(\"rrc.set(1, rc);\");\n        \t    }\n        \t}\n    \n        \tp(possibleType.clazz.getParameterizedQualifiedSourceName() + \" parseValue = (\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \")value;\");\n    \n        \tfor (final JField field : getFields(possibleType.clazz)) {\n    \n        \t    final String getterName = getGetterName(field);\n\n                boolean ignoreField = false;\n                if(possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null) {\n                    for(String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value()) {\n                        if(s.equals(field.getName())) {\n                            ignoreField = true;\n                            break;\n                        }\n                    }\n                }\n    \n        \t    // If can ignore some fields right off the back..\n        \t    // if there is a creator encode only final fields with JsonProperty annotation\n                if (ignoreField || getterName == null && (field.isStatic() || (field.isFinal() && !(creator != null && orderedFields.contains(field))) || field.isTransient() \n                        || field.isAnnotationPresent(JsonIgnore.class))) {\n                    continue;\n                }\n\n        \t    branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n        \t\tpublic Void execute() throws UnableToCompleteException {\n        \t\t    // TODO: try to get the field with a setter or\n        \t\t    // JSNI\n        \t\t    if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n    \n        \t\t\tJson jsonAnnotation = field.getAnnotation(Json.class);\n                    JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n    \n        \t\t\tString name = field.getName();\n        \t\t\tString jsonName = name;\n    \n        \t\t\tif (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n        \t\t\t    jsonName = jsonAnnotation.name();\n        \t\t\t}\n                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                        jsonName = jsonPropertyAnnotation.value();\n                    }\n    \n        \t\t\tString fieldExpr = \"parseValue.\" + name;\n        \t\t\tif (getterName != null) {\n        \t\t\t    fieldExpr = \"parseValue.\" + getterName + \"()\";\n        \t\t\t}\n    \n        \t\t\tStyle style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n        \t\t\tString expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n    \n        \t\t\tp(\"{\").i(1);\n        \t\t\t{\n        \t\t\t    if (null != field.getType().isEnum()) {\n        \t\t\t\tp(\"if(\" + fieldExpr + \" == null) {\").i(1);\n        \t\t\t\tp(\"rc.put(\" + wrap(jsonName) + \", null);\");\n        \t\t\t\ti(-1).p(\"} else {\").i(1);\n        \t\t\t    }\n    \n        \t\t\t    p(JSON_VALUE_CLASS + \" v=\" + expression + \";\");\n        \t\t\t    p(\"if( v!=null ) {\").i(1);\n        \t\t\t    {\n        \t\t\t\tp(\"rc.put(\" + wrap(jsonName) + \", v);\");\n        \t\t\t    }\n        \t\t\t    i(-1).p(\"}\");\n    \n        \t\t\t    if (null != field.getType().isEnum()) {\n        \t\t\t\ti(-1).p(\"}\");\n        \t\t\t    }\n    \n        \t\t\t}\n        \t\t\ti(-1).p(\"}\");\n    \n        \t\t    } else {\n        \t\t        logger.log(ERROR, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n        \t\t    }\n        \t\t    return null;\n        \t\t}\n        \t    });\n    \n        \t}\n    \n        \tif (returnWrapper) {\n        \t    p(\"return rrc;\");\n        \t} else {\n        \t    p(\"return rc;\");\n        \t}\n    \n        \tif (!isLeaf) {\n        \t    p(\"}\");\n        \t}\n            }\n    \n            if (!isLeaf) {\n        \t// Shouldn't get called\n        \tp(\"return null;\");\n            }\n        }\n        i(-1).p(\"}\");\n        p();\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n            {\n                p(\"return null;\").i(-1);\n            }\n            p(\"}\");\n            if (classStyle == Style.RAILS) {\n        \tp(JSON_OBJECT_CLASS + \" object = toObjectFromWrapper(value, \\\"\" + railsWrapperName + \"\\\");\");\n            } else if (typeInfo != null && typeInfo.include() == As.WRAPPER_ARRAY) {\n        \tp(JSON_ARRAY_CLASS + \" array = (\" + JSON_ARRAY_CLASS + \")value;\");\n        \tif (!isLeaf)\n        \t    p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(array.get(0));\");\n        \tp(JSON_OBJECT_CLASS + \" object = toObject(array.get(1));\");\n            } else {\n        \tp(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            }\n    \n            if (!isLeaf && typeInfo != null && typeInfo.include() == As.PROPERTY) {\n                p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" + getTypeInfoPropertyValue(typeInfo) + \"));\");\n            }\n    \n            for (Subtype possibleType : possibleTypes) {\n        \t// Try to find a constuctor that is annotated as creator\n        \tfinal JConstructor creator = findCreator(possibleType.clazz);\n        \tif (typeInfo != null) {\n        \t    if (typeInfo.include() == As.WRAPPER_OBJECT) {\n        \t\tif (!isLeaf) {\n        \t\t    p(\"if(object.containsKey(\\\"\" + possibleType.tag + \"\\\"))\");\n        \t\t    p(\"{\");\n        \t\t}\n        \t\tp(\"object = toObjectFromWrapper(value, \\\"\" + possibleType.tag + \"\\\");\");\n        \t    } else if (!isLeaf) {\n        \t\tp(\"if(sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n        \t\tp(\"{\");\n        \t    }\n        \t}\n    \n        \tList<JField> orderedFields = null;\n        \tif (creator != null) {\n        \t    p(\"// We found a creator so we use the annotated constructor\");\n        \t    p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"(\");\n        \t    i(1).p(\"// The arguments are placed in the order they appear within the annotated constructor\").i(-1);\n        \t    orderedFields = getOrderedFields(getFields(possibleType.clazz), creator);\n        \t    final JField lastField = orderedFields.get(orderedFields.size() - 1);\n        \t    for (final JField field : orderedFields) {\n        \t\tbranch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n        \t\t    public Void execute() throws UnableToCompleteException {\n        \t\t\tJson jsonAnnotation = field.getAnnotation(Json.class);\n        \t\t\tStyle style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n        \t\t\tString jsonName = field.getName();\n        \t\t\tif (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n        \t\t\t    jsonName = jsonAnnotation.name();\n        \t\t\t}\n        \t\t\tString objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n        \t\t\tString expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n        \t\t\tString defaultValue = field.getType().isPrimitive() == null ? \"null\": field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n        \t\t\ti(1).p(\"\" + (objectGetter + \" == null || \" + objectGetter + \" instanceof com.google.gwt.json.client.JSONNull ? \" + defaultValue + \" : \" + expression + ((field != lastField) ? \", \" : \"\"))).i(-1);\n        \t\t\t\n        \t\t\treturn null;\n        \t\t    }\n        \t\t});\n        \t    }\n        \t    p(\");\");\n        \t}\n        \t\n        \tif (orderedFields == null){\n        \t    p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"();\");\n        \t}\n        \t\n                for (final JField field : getFields(possibleType.clazz)) {\n\n                    boolean ignoreField = false;\n                    if(possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null) {\n                        for(String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value()) {\n                            if(s.equals(field.getName())) {\n                                ignoreField = true;\n                                break;\n                            }\n                        }\n                    }\n                    if(ignoreField) {\n                        continue;\n                    }\n\n        \t    if (orderedFields != null && orderedFields.contains(field)){\n        \t        continue;\n        \t    }\n    \n        \t\tfinal String setterName = getSetterName(field);\n    \n        \t\t// If can ignore some fields right off the back..\n        \t\tif (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient()) || \n        \t\t        field.isAnnotationPresent(JsonIgnore.class)) {\n        \t\t    continue;\n        \t\t}\n    \n        \t\tbranch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n        \t\t    public Void execute() throws UnableToCompleteException {\n    \n        \t\t\t// TODO: try to set the field with a setter\n        \t\t\t// or JSNI\n        \t\t\tif (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n    \n        \t\t\t    Json jsonAnnotation = field.getAnnotation(Json.class);\n        \t\t\t    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                        JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n                        \n                        String name = field.getName();\n                        String jsonName = name;\n        \n                        if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                            jsonName = jsonAnnotation.name();\n                        }\n                        if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                            jsonName = jsonPropertyAnnotation.value();\n                        }\n         \n        \t\t\t    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n        \t\t\t    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n    \n                        String cast = field.getType().isPrimitive() == JPrimitiveType.SHORT ? \"(short) \" : \"\";\n        \t\t\t    p(\"if(\" + objectGetter + \" != null) {\").i(1);\n    \n        \t\t\t\tp(\"if(\" + objectGetter + \" instanceof com.google.gwt.json.client.JSONNull) {\").i(1);\n                        String defaultValue = field.getType().isPrimitive() == null ? \"null\": field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n                        \n        \t\t\t\tif (setterName != null) {\n                            p(\"rc.\" + setterName + \"(\" + cast + defaultValue + \");\");\n        \t\t\t\t} else {\n                            p(\"rc.\" + name + \"=\" + cast + defaultValue + \";\");\n        \t\t\t\t}\n    \n        \t\t\t\ti(-1).p(\"} else {\").i(1);\n        \t\t\t    \n        \t\t\t    if (setterName != null) {\n                            p(\"rc.\" + setterName + \"(\" + cast + expression + \");\");\n        \t\t\t    } else {\n                            p(\"rc.\" + name + \"=\" + cast + expression + \";\");\n        \t\t\t    }\n        \t\t\t    i(-1).p(\"}\");    \n        \t\t\t    i(-1).p(\"}\");    \n\n        \t\t\t} else {\n                        logger.log(ERROR, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n        \t\t\t}\n        \t\t\treturn null;\n        \t\t    }\n        \t\t});\n        \t}\n        \t\n        \tp(\"return rc;\");\n    \n        \tif (typeInfo != null && !isLeaf) {\n        \t    p(\"}\");\n        \t}\n            }\n    \n            if (typeInfo != null && !isLeaf) {\n        \tp(\"return null;\");\n            }\n            i(-1).p(\"}\");\n            p();\n        }\n    }\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> sTypeIdResolverMap = null;\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> getRestyResolverClassMap(GeneratorContext context, TreeLogger logger) throws UnableToCompleteException {\n\tif (sTypeIdResolverMap == null) {\n\t    try {\n\t\tMap<Class<?>, RestyJsonTypeIdResolver> map = Maps.newHashMap();\n\t\tList<String> values = context.getPropertyOracle().getConfigurationProperty(\"org.fusesource.restygwt.jsontypeidresolver\").getValues();\n\t\tfor (String value : values)\n\t\t    try {\n\t\t\tClass<?> clazz = Class.forName(value);\n\t\t\tRestyJsonTypeIdResolver resolver = (RestyJsonTypeIdResolver) clazz.newInstance();\n\t\t\tmap.put(resolver.getTypeIdResolverClass(), resolver);\n\t\t    } catch (Exception e) {\n\t\t\tlogger.log(WARN, \"Could not access class: \" + values.get(0), e);\n\t\t    }\n\t\t    sTypeIdResolverMap = map;\n\t    } catch (BadPropertyValueException e) {\n\t\tlogger.log(ERROR, \"Could not acccess property: RestyJsonTypeIdResolver\", e);\n\t\tthrow new UnableToCompleteException();\n\t    }\n\t}\n\treturn sTypeIdResolverMap;\n    }\n\n    private List<JField> getOrderedFields(List<JField> fields, JConstructor creator) throws UnableToCompleteException {\n\tList<JField> orderedFields = new ArrayList<JField>();\n\tfor (JParameter param : creator.getParameters()) {\n\t    JsonProperty prop = param.getAnnotation(JsonProperty.class);\n\t    if (prop != null) {\n\t\tfor (JField field : fields) {\n\t\t    if (field.getName().equals(prop.value())) {\n\t\t\torderedFields.add(field);\n\t\t    }\n\t\t}\n\t    } else {\n\t\terror(\"a constructor annotated with @JsonCreator requires that all paramaters are annotated with @JsonProperty.\");\n\t    }\n\t}\n\n\treturn orderedFields;\n    }\n\n    private JConstructor findCreator(JClassType sourceClazz) {\n\tfor (JConstructor constructor : sourceClazz.getConstructors()) {\n\t    if (constructor.getAnnotation(JsonCreator.class) != null) {\n\t\treturn constructor;\n\t    }\n\t}\n\n\treturn null;\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the setter for the specified field or null if a\n     *         setter can't be found.\n     */\n    private String getSetterName(JField field) {\n\tString fieldName = field.getName();\n\tfieldName = \"set\" + upperCaseFirstChar(fieldName);\n\tJClassType type = field.getEnclosingType();\n\tif (exists(type, field, fieldName, true)) {\n\t    return fieldName;\n\t} else {\n\t    return null;\n\t}\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the getter for the specified field or null if a\n     *         getter can't be found.\n     */\n    private String getGetterName(JField field) {\n\tString fieldName = field.getName();\n\tJType booleanType = null;\n\ttry {\n\t    booleanType = find(Boolean.class);\n\t} catch (UnableToCompleteException e) {\n\t    // do nothing\n\t}\n\tJClassType type = field.getEnclosingType();\n\tif (field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)) {\n\t    fieldName = \"is\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t    fieldName = \"has\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t}\n\tfieldName = \"get\" + upperCaseFirstChar(field.getName());\n\tif (exists(type, field, fieldName, false)) {\n\t    return fieldName;\n\t} else {\n\t    return null;\n\t}\n    }\n\n    private String upperCaseFirstChar(String in) {\n\tif (in.length() == 1) {\n\t    return in.toUpperCase();\n\t} else {\n\t    return in.substring(0, 1).toUpperCase() + in.substring(1);\n\t}\n    }\n\n    /**\n     * checks whether a getter or setter exists on the specified type or any of\n     * its super classes excluding Object.\n     * \n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {\n        if ( field instanceof DummyJField ){\n            return true;\n        }\n        \n\tJType[] args = null;\n\tif (isSetter) {\n\t    args = new JType[] { field.getType() };\n\t} else {\n\t    args = new JType[] {};\n\t}\n\n\tif (null != type.findMethod(fieldName, args)) {\n\t    return true;\n\t} else {\n\t    try {\n\t\tJType objectType = find(Object.class);\n\t\tJClassType superType = type.getSuperclass();\n\t\tif (!objectType.equals(superType)) {\n\t\t    return exists(superType, field, fieldName, isSetter);\n\t\t}\n\t    } catch (UnableToCompleteException e) {\n\t\t// do nothing\n\t    }\n\t}\n\treturn false;\n    }\n\n    /**\n     * Inspects the supplied type and all super classes up to but excluding\n     * Object and returns a list of all fields found in these classes.\n     * \n     * @param type\n     * @return\n     */\n    private List<JField> getFields(JClassType type) {\n        List<JField> allFields = getFields(new ArrayList<JField>(), type);\n        Map<String, JMethod> getters = new HashMap<String, JMethod>();\n        Map<String, JType> setters = new HashMap<String, JType>();\n        for( JMethod m: type.getInheritableMethods() ){\n            if( m.getName().startsWith(\"set\") && m.getParameterTypes().length == 1 && m.getReturnType() == JPrimitiveType.VOID){\n                setters.put( m.getName().replaceFirst(\"^set\", \"\"), m.getParameterTypes()[0] );\n            }\n            else if( m.getName().startsWith(\"get\") && m.getParameterTypes().length == 0 &&  m.getReturnType() != JPrimitiveType.VOID){\n                getters.put( m.getName().replaceFirst(\"^get\", \"\"), m );\n            }\n        }\n        for( Map.Entry<String, JMethod> entry: getters.entrySet() ){\n            if ( setters.containsKey( entry.getKey() ) && setters.get( entry.getKey() ).equals( entry.getValue().getReturnType() ) ) {\n                String name = entry.getKey().substring(0, 1).toLowerCase() + entry.getKey().substring(1);\n\n                boolean found = false;\n                for( JField f : allFields ){\n                    if( f.getName().equals( name ) ){\n                        found = true;\n                        break;\n                    }\n                }\n                JField f = type.getField( name );\n                if ( ! found && !( f != null && f.isAnnotationPresent( JsonIgnore.class ) ) ){\n                    DummyJField dummy = new DummyJField( name, entry.getValue().getReturnType() );\n                    if ( entry.getValue().isAnnotationPresent(JsonProperty.class) ) { \n                        dummy.setAnnotation( entry.getValue().getAnnotation(JsonProperty.class) );\n                    }\n                    allFields.add( dummy );\n                }\n            }\n        }\n        return allFields;\n    }\n\n    private List<JField> getFields(List<JField> allFields, JClassType type) {\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n            if (!field.isTransient() && !field.isAnnotationPresent(JsonIgnore.class)) {\n                allFields.add(field);\n            }\n        }\n        try {\n            JType objectType = find(Object.class);\n            if (!objectType.equals(type)) {\n                JClassType superType = type.getSuperclass();\n                return getFields(allFields, superType);\n            }\n        }\n        catch (UnableToCompleteException e) {\n\t    // do nothing\n        }\n        \n    \treturn allFields;\n    }\n    \n    private String getTypeInfoPropertyValue(final JsonTypeInfo typeInfo){\n        String propValue;\n        if (typeInfo.use() == Id.CLASS && \"\".equals(typeInfo.property()))\n            propValue = Id.CLASS.getDefaultPropertyName();\n        else\n            propValue = typeInfo.property();\n\n        \n        return wrap(propValue);\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.codehaus.jackson.annotate.JsonCreator;\nimport org.codehaus.jackson.annotate.JsonIgnore;\nimport org.codehaus.jackson.annotate.JsonIgnoreProperties;\nimport org.codehaus.jackson.annotate.JsonProperty;\nimport org.codehaus.jackson.annotate.JsonSubTypes;\nimport org.codehaus.jackson.annotate.JsonTypeInfo;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.As;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.Id;\nimport org.codehaus.jackson.annotate.JsonTypeName;\nimport org.codehaus.jackson.map.annotate.JsonDeserialize;\nimport org.codehaus.jackson.map.annotate.JsonTypeIdResolver;\nimport org.codehaus.jackson.map.jsontype.TypeIdResolver;\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JConstructor;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.thirdparty.guava.common.collect.Lists;\nimport com.google.gwt.thirdparty.guava.common.collect.Maps;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * \n *         Updates: added getter & setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n * \n *         added polymorphic support\n * @author <a href=\"http://charliemason.info\">Charlie Mason<\/a>\n * \n *         Updates : add support for JsonTypeInfo default property value class for id.class\n *                   add support for JsonDeserialize for interface\n *                      -> will look for all possible concrete sub-classes\n * @author <a href=\"http://wwww.ronanquillevere.fr\">Ronan Quillevere<\/a>\n * \n */\n\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator\n{\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n \n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source)\n            throws UnableToCompleteException\n    {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory()\n    {\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n        composerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() +\n                \">\");\n        return composerFactory;\n    }\n\n    private static class Subtype\n    {\n        final String tag;\n        final JClassType clazz;\n\n        public Subtype(String tag, JClassType clazz)\n        {\n            this.tag = tag;\n            this.clazz = clazz;\n        }\n    }\n\n    private static <T extends Annotation> T findAnnotation(JClassType clazz, Class<T> annotation)\n    {\n        if (clazz == null)\n            return null;\n        else if (clazz.isAnnotationPresent(annotation))\n            return clazz.getAnnotation(annotation);\n        else\n            return findAnnotation(clazz.getSuperclass(), annotation);\n    }\n\n    @Override\n    public void generate() throws UnableToCompleteException\n    {\n        final JsonTypeInfo typeInfo = findAnnotation(source, JsonTypeInfo.class);\n        final List<Subtype> possibleTypes = findPossibleTypes(context, source);\n\n        if(source.isInterface() != null ){            \n            if (!source.isAnnotationPresent(JsonDeserialize.class))\n                    error(\"Interface must be annotated with @JsonDeserialize.\");\n        } else {\n            if (source.isClass() == null) \n                error(\"Type is not a class or an interface\");\n            \n            if (source.isAbstract())\n            {\n                if (typeInfo == null)\n                    error(\"Abstract classes must be annotated with JsonTypeInfo\");\n            }\n        }\n        \n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n        final String railsWrapperName = jsonAnnotation != null && jsonAnnotation.name().length() > 0 ? jsonAnnotation\n                .name() : source.getName().toLowerCase();\n        final boolean isLeaf = isLeaf(source);\n        final JsonEncoderDecoderInstanceLocator locator = new JsonEncoderDecoderInstanceLocator(context, logger);\n        \n        writeSingleton();\n        writeEncode(source, typeInfo, possibleTypes, classStyle, railsWrapperName, isLeaf, locator);\n        writeDecode(source, typeInfo, possibleTypes, classStyle, railsWrapperName, isLeaf, locator);\n    }\n\n    private void writeDecode(final JClassType source, JsonTypeInfo typeInfo, final List<Subtype> possibleTypes,\n            final Style classStyle, final String railsWrapperName, boolean isLeaf, final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        //TODO @rqu sourceClazz instead of source\n        if (null != source.isEnum())\n        {\n            p();\n            p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n            {\n                p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n                {\n                    p(\"return null;\").i(-1);\n                }\n                p(\"}\");\n                p(\"com.google.gwt.json.client.JSONString str = value.isString();\");\n                p(\"if( null == str ) {\").i(1);\n                {\n                    p(\"throw new DecodingException(\\\"Expected a json string (for enum), but was given: \\\"+value);\").i(\n                            -1);\n                }\n                p(\"}\");\n                p(\"return Enum.valueOf(\" + source.getParameterizedQualifiedSourceName() + \".class, str.stringValue());\")\n                        .i(-1);\n            }\n            p(\"}\");\n            p();\n            return;\n        }\n        \n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n            {\n                p(\"return null;\").i(-1);\n            }\n            p(\"}\");\n            if (classStyle == Style.RAILS)\n            {\n                p(JSON_OBJECT_CLASS + \" object = toObjectFromWrapper(value, \\\"\" + railsWrapperName + \"\\\");\");\n            }\n            else if (typeInfo != null && typeInfo.include() == As.WRAPPER_ARRAY)\n            {\n                p(JSON_ARRAY_CLASS + \" array = (\" + JSON_ARRAY_CLASS + \")value;\");\n                if (!isLeaf)\n                    p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(array.get(0));\");\n                p(JSON_OBJECT_CLASS + \" object = toObject(array.get(1));\");\n            }\n            else\n            {\n                p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            }\n\n            typeInfo = writeSourceName(source, possibleTypes, typeInfo, isLeaf);\n\n            for (Subtype possibleType : possibleTypes)\n            {\n                // Try to find a constuctor that is annotated as creator\n                final JConstructor creator = findCreator(possibleType.clazz);\n                if (typeInfo != null)\n                {\n                    if (typeInfo.include() == As.WRAPPER_OBJECT)\n                    {\n                        if (!isLeaf)\n                        {\n                            p(\"if(object.containsKey(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        }\n                        p(\"object = toObjectFromWrapper(value, \\\"\" + possibleType.tag + \"\\\");\");\n                    }\n                    else if (!isLeaf)\n                    {\n                        p(\"if(sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n                        p(\"{\");\n                    }\n                }\n\n                List<JField> orderedFields = null;\n                if (creator != null)\n                {\n                    p(\"// We found a creator so we use the annotated constructor\");\n                    p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" +\n                            possibleType.clazz.getParameterizedQualifiedSourceName() + \"(\");\n                    i(1).p(\"// The arguments are placed in the order they appear within the annotated constructor\").i(\n                            -1);\n                    orderedFields = getOrderedFields(getFields(possibleType.clazz), creator);\n                    final JField lastField = orderedFields.get(orderedFields.size() - 1);\n                    for (final JField field : orderedFields)\n                    {\n                        branch(\"Processing field: \" + field.getName(), new Branch<Void>()\n                        {\n                            public Void execute() throws UnableToCompleteException\n                            {\n                                Json jsonAnnotation = field.getAnnotation(Json.class);\n                                Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                String jsonName = field.getName();\n                                if (jsonAnnotation != null && jsonAnnotation.name().length() > 0)\n                                {\n                                    jsonName = jsonAnnotation.name();\n                                }\n                                String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                String defaultValue = field.getType().isPrimitive() == null ? \"null\" : field.getType()\n                                        .isPrimitive().getUninitializedFieldExpression() +\n                                        \"\";\n                                i(1).p(\"\" +\n                                        (objectGetter + \" == null || \" + objectGetter +\n                                                \" instanceof com.google.gwt.json.client.JSONNull ? \" + defaultValue +\n                                                \" : \" + expression + ((field != lastField) ? \", \" : \"\"))).i(-1);\n\n                                return null;\n                            }\n                        });\n                    }\n                    p(\");\");\n                }\n\n                if (orderedFields == null)\n                {\n                    p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" +\n                            possibleType.clazz.getParameterizedQualifiedSourceName() + \"();\");\n                }\n\n                for (final JField field : getFields(possibleType.clazz))\n                {\n\n                    boolean ignoreField = false;\n                    if (possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null)\n                    {\n                        for (String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value())\n                        {\n                            if (s.equals(field.getName()))\n                            {\n                                ignoreField = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (ignoreField)\n                    {\n                        continue;\n                    }\n\n                    if (orderedFields != null && orderedFields.contains(field))\n                    {\n                        continue;\n                    }\n\n                    final String setterName = getSetterName(field);\n\n                    // If can ignore some fields right off the back..\n                    if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient()) ||\n                            field.isAnnotationPresent(JsonIgnore.class))\n                    {\n                        continue;\n                    }\n\n                    branch(\"Processing field: \" + field.getName(), new Branch<Void>()\n                    {\n                        public Void execute() throws UnableToCompleteException\n                        {\n\n                            // TODO: try to set the field with a setter\n                            // or JSNI\n                            if (setterName != null || field.isDefaultAccess() || field.isProtected() ||\n                                    field.isPublic())\n                            {\n\n                                Json jsonAnnotation = field.getAnnotation(Json.class);\n                                Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n\n                                String name = field.getName();\n                                String jsonName = name;\n\n                                if (jsonAnnotation != null && jsonAnnotation.name().length() > 0)\n                                {\n                                    jsonName = jsonAnnotation.name();\n                                }\n                                if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null &&\n                                        jsonPropertyAnnotation.value().length() > 0)\n                                {\n                                    jsonName = jsonPropertyAnnotation.value();\n                                }\n\n                                String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                String cast = field.getType().isPrimitive() == JPrimitiveType.SHORT ? \"(short) \" : \"\";\n                                p(\"if(\" + objectGetter + \" != null) {\").i(1);\n\n                                p(\"if(\" + objectGetter + \" instanceof com.google.gwt.json.client.JSONNull) {\").i(1);\n                                String defaultValue = field.getType().isPrimitive() == null ? \"null\" : field.getType()\n                                        .isPrimitive().getUninitializedFieldExpression() +\n                                        \"\";\n\n                                if (setterName != null)\n                                {\n                                    p(\"rc.\" + setterName + \"(\" + cast + defaultValue + \");\");\n                                }\n                                else\n                                {\n                                    p(\"rc.\" + name + \"=\" + cast + defaultValue + \";\");\n                                }\n\n                                i(-1).p(\"} else {\").i(1);\n\n                                if (setterName != null)\n                                {\n                                    p(\"rc.\" + setterName + \"(\" + cast + expression + \");\");\n                                }\n                                else\n                                {\n                                    p(\"rc.\" + name + \"=\" + cast + expression + \";\");\n                                }\n                                i(-1).p(\"}\");\n                                i(-1).p(\"}\");\n\n                            }\n                            else\n                            {\n                                logger.log(ERROR, \"private field gets ignored: \" +\n                                        field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                            }\n                            return null;\n                        }\n                    });\n                }\n\n                p(\"return rc;\");\n\n                if (typeInfo != null && !isLeaf)\n                {\n                    p(\"}\");\n                }\n            }\n\n            if (typeInfo != null && !isLeaf)\n            {\n                p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n            p();\n        }\n    }\n\n    private void writeEncode(final JClassType source, final JsonTypeInfo typeInfo, final List<Subtype> possibleTypes,\n            final Style classStyle, final String railsWrapperName, boolean isLeaf, final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != source.isEnum())\n        {\n            p();\n            p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\")\n                    .i(1);\n            {\n                p(\"if( value==null ) {\").i(1);\n                {\n                    p(\"return com.google.gwt.json.client.JSONNull.getInstance();\").i(-1);\n                }\n                p(\"}\");\n                p(\"return new com.google.gwt.json.client.JSONString(value.name());\");\n            }\n            i(-1).p(\"}\");\n            p();  \n            return;\n        }\n        \n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n\n            boolean returnWrapper = false; // if set, return rrc\n\n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n            if (classStyle == Style.RAILS)\n            {\n                returnWrapper = true;\n                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                p(\"rrc.put(\\\"\" + railsWrapperName + \"\\\" , rc);\");\n            }\n\n            for (Subtype possibleType : possibleTypes)\n            {\n                // Try to find a constuctor that is annotated as creator\n                final JConstructor creator = findCreator(possibleType.clazz);\n\n                List<JField> orderedFields = creator == null ? null : getOrderedFields(getFields(possibleType.clazz),\n                        creator);\n\n                if (!isLeaf)\n                {\n                    // Generate a decoder for each possible type\n                    p(\"if(value.getClass().getName().equals(\\\"\" + possibleType.clazz.getQualifiedBinaryName() + \"\\\"))\");\n                    p(\"{\");\n                }\n\n                if (typeInfo != null)\n                {\n                    switch (typeInfo.include())\n                    {\n                        case PROPERTY:\n                            p(\"com.google.gwt.json.client.JSONValue className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" +\n                                    possibleType.tag + \"\\\");\");\n                            p(\"if( className!=null ) { \").i(1);\n                            p(\"rc.put(\" + getTypeInfoPropertyValue(typeInfo) + \", className);\");\n                            i(-1).p(\"}\");\n                            break;\n                        case WRAPPER_OBJECT:\n                            returnWrapper = true;\n                            p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                            p(\"rrc.put(\\\"\" + possibleType.tag + \"\\\", rc);\");\n                            break;\n                        case WRAPPER_ARRAY:\n                            returnWrapper = true;\n                            p(JSON_ARRAY_CLASS + \" rrc = new \" + JSON_ARRAY_CLASS + \"();\");\n                            p(\"rrc.set(0, org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" +\n                                    possibleType.tag + \"\\\"));\");\n                            p(\"rrc.set(1, rc);\");\n                    }\n                }\n\n                p(possibleType.clazz.getParameterizedQualifiedSourceName() + \" parseValue = (\" +\n                        possibleType.clazz.getParameterizedQualifiedSourceName() + \")value;\");\n\n                for (final JField field : getFields(possibleType.clazz))\n                {\n\n                    final String getterName = getGetterName(field);\n\n                    boolean ignoreField = false;\n                    if (possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null)\n                    {\n                        for (String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value())\n                        {\n                            if (s.equals(field.getName()))\n                            {\n                                ignoreField = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    // If can ignore some fields right off the back..\n                    // if there is a creator encode only final fields with JsonProperty annotation\n                    if (ignoreField ||\n                            getterName == null &&\n                            (field.isStatic() ||\n                                    (field.isFinal() && !(creator != null && orderedFields.contains(field))) ||\n                                    field.isTransient() || field.isAnnotationPresent(JsonIgnore.class)))\n                    {\n                        continue;\n                    }\n\n                    branch(\"Processing field: \" + field.getName(), new Branch<Void>()\n                    {\n                        public Void execute() throws UnableToCompleteException\n                        {\n                            // TODO: try to get the field with a setter or\n                            // JSNI\n                            if (getterName != null || field.isDefaultAccess() || field.isProtected() ||\n                                    field.isPublic())\n                            {\n\n                                Json jsonAnnotation = field.getAnnotation(Json.class);\n                                JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n\n                                String name = field.getName();\n                                String jsonName = name;\n\n                                if (jsonAnnotation != null && jsonAnnotation.name().length() > 0)\n                                {\n                                    jsonName = jsonAnnotation.name();\n                                }\n                                if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null &&\n                                        jsonPropertyAnnotation.value().length() > 0)\n                                {\n                                    jsonName = jsonPropertyAnnotation.value();\n                                }\n\n                                String fieldExpr = \"parseValue.\" + name;\n                                if (getterName != null)\n                                {\n                                    fieldExpr = \"parseValue.\" + getterName + \"()\";\n                                }\n\n                                Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                String expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n\n                                p(\"{\").i(1);\n                                {\n                                    if (null != field.getType().isEnum())\n                                    {\n                                        p(\"if(\" + fieldExpr + \" == null) {\").i(1);\n                                        p(\"rc.put(\" + wrap(jsonName) + \", null);\");\n                                        i(-1).p(\"} else {\").i(1);\n                                    }\n\n                                    p(JSON_VALUE_CLASS + \" v=\" + expression + \";\");\n                                    p(\"if( v!=null ) {\").i(1);\n                                    {\n                                        p(\"rc.put(\" + wrap(jsonName) + \", v);\");\n                                    }\n                                    i(-1).p(\"}\");\n\n                                    if (null != field.getType().isEnum())\n                                    {\n                                        i(-1).p(\"}\");\n                                    }\n\n                                }\n                                i(-1).p(\"}\");\n\n                            }\n                            else\n                            {\n                                logger.log(ERROR, \"private field gets ignored: \" +\n                                        field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                            }\n                            return null;\n                        }\n                    });\n\n                }\n\n                if (returnWrapper)\n                {\n                    p(\"return rrc;\");\n                }\n                else\n                {\n                    p(\"return rc;\");\n                }\n\n                if (!isLeaf)\n                {\n                    p(\"}\");\n                }\n            }\n\n            if (!isLeaf)\n            {\n                // Shouldn't get called\n                p(\"return null;\");\n            }\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n\n    private JsonTypeInfo writeSourceName(final JClassType source, final List<Subtype> possibleTypes, JsonTypeInfo typeInfo, boolean isLeaf) throws UnableToCompleteException\n    {\n        if (source.isInterface() != null){\n                \n            boolean classFound = false;\n            JsonTypeInfo ti = null;\n            for (Subtype subtype : possibleTypes)\n            {\n                ti = subtype.clazz.findAnnotationInTypeHierarchy(JsonTypeInfo.class);\n                if (ti != null && ti.use() == Id.CLASS){\n                    classFound = true;\n                    break;\n                }\n            }\n            \n            if (!classFound)\n                error(\"One of the class implementing the interface should have the annotation JsonTypeInfo = class\");\n            \n            p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" +\n                    getTypeInfoPropertyValue(ti) + \"));\");\n            \n            return ti;\n    \n        } else {\n            if (!isLeaf && typeInfo != null && typeInfo.include() == As.PROPERTY)\n            {\n                p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" +\n                        getTypeInfoPropertyValue(typeInfo) + \"));\");\n            }\n            \n            return typeInfo;\n        }\n    }\n\n    private void writeSingleton()\n    {\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n    }\n\n    private static boolean isLeaf(JClassType source)\n    {\n        return !(source.getSubtypes() != null && source.getSubtypes().length > 0);\n    }\n\n    private List<Subtype> findPossibleTypes(GeneratorContext context, JClassType classType) throws UnableToCompleteException\n    {\n        if (classType.isClass() != null)\n            return findPossibleTypesForClass(context, classType);\n        \n        if (classType.isInterface() != null)\n            return findPossibleTypesForInterface(context, classType);\n\n        error(\"Cannot find required subtype resolution for : \" + classType);\n        return null;\n    }\n\n    private List<Subtype> findPossibleTypesForInterface(GeneratorContext context, JClassType classType) throws UnableToCompleteException\n    {\n        if (!classType.isAnnotationPresent(JsonDeserialize.class))\n            error(\"Cannot find required subtype resolution for interface (missing @JsonDeserialize annotation): \" + classType);\n        \n        final List<Subtype> possibleTypes = Lists.newArrayList();\n        \n        final JClassType type = find(classType.getAnnotation(JsonDeserialize.class).as());\n        \n        List<JClassType> resolvedSubtypes = findConcreteSubtypes(context, type);\n        \n        for (JClassType typeClass : resolvedSubtypes) {\n            possibleTypes.add(new Subtype(typeClass.getQualifiedSourceName(), typeClass));\n        }\n\n        return possibleTypes;\n    }\n\n    private List<Subtype> findPossibleTypesForClass(GeneratorContext context, JClassType source) throws UnableToCompleteException\n    {\n        final List<Subtype> possibleTypes = Lists.newArrayList();\n        final JsonTypeInfo typeInfo = findAnnotation(source, JsonTypeInfo.class);\n        final boolean isLeaf = isLeaf(source);\n        if (typeInfo != null)\n        {\n            final JsonSubTypes jacksonSubTypes = findAnnotation(source, JsonSubTypes.class);\n            if (typeInfo.use() == Id.CLASS || typeInfo.use() == Id.MINIMAL_CLASS)\n            {\n                List<JClassType> resolvedSubtypes = Lists.newArrayList();\n                if (jacksonSubTypes != null)\n                {\n                    for (JsonSubTypes.Type type : jacksonSubTypes.value())\n                    {\n                        JClassType typeClass = find(type.value());\n                        if (!isLeaf || source.equals(typeClass))\n                            resolvedSubtypes.add(typeClass);\n                    }\n                }\n                else\n                {\n                   resolvedSubtypes.addAll(findConcreteSubtypes(context, source));                  \n                }\n                for (JClassType typeClass : resolvedSubtypes)\n                    possibleTypes.add(new Subtype(typeInfo.use() == Id.CLASS ? typeClass.getQualifiedSourceName()\n                            : \".\" + typeClass.getSimpleSourceName(), typeClass));\n            }\n            else if (typeInfo.use() != Id.NONE)\n            {\n                final JsonTypeIdResolver typeResolver = findAnnotation(source, JsonTypeIdResolver.class);\n                if (jacksonSubTypes != null)\n                {\n                    for (JsonSubTypes.Type type : jacksonSubTypes.value())\n                    {\n                        if (type.name() != null && !type.name().isEmpty())\n                        {\n                            JClassType typeClass = find(type.value());\n                            if (!isLeaf || source.equals(typeClass))\n                                possibleTypes.add(new Subtype(type.name(), typeClass));\n                        }\n                        else\n                        {\n                            JsonTypeName nameAnnotation = type.value().getAnnotation(JsonTypeName.class);\n                            if (nameAnnotation == null || nameAnnotation.value() == null ||\n                                    nameAnnotation.value().isEmpty())\n                                error(\"Cannot find @JsonTypeName annotation for type: \" + type.value());\n                            JClassType typeClass = find(type.value());\n                            if (!isLeaf || source.equals(typeClass))\n                                possibleTypes.add(new Subtype(nameAnnotation.value(), typeClass));\n                        }\n                    }\n                    if (isLeaf && possibleTypes.size() == 0)\n                        error(\"Could not find @JsonSubTypes entry for type: \" + source);\n                }\n                else if (typeResolver != null)\n                {\n                    Class<? extends TypeIdResolver> resolverClass = typeResolver.value();\n                    RestyJsonTypeIdResolver restyResolver;\n                    if (RestyJsonTypeIdResolver.class.isAssignableFrom(resolverClass))\n                    {\n                        try\n                        {\n                            restyResolver = (RestyJsonTypeIdResolver) resolverClass.newInstance();\n                        }\n                        catch (Exception e)\n                        {\n                            logger.log(ERROR, \"Could not acccess: \" + resolverClass, e);\n                            throw new UnableToCompleteException();\n                        }\n                    }\n                    else\n                    {\n                        restyResolver = getRestyResolverClassMap(context, logger).get(resolverClass);\n                        if (restyResolver == null)\n                            error(\"Could not find RestyJsonTypeIdResolver for \" +\n                                    resolverClass +\n                                    \" did you forget to put <extend-configuration-property name=\\\"org.fusesource.restygwt.jsontypeidresolver\\\" value=\\\"<fully-qualified-class-implementing-RestyJsonTypeIdResolver>\\\"/> in your *.gwt.xml?\");\n\n                    }\n\n                    for (Map.Entry<String, Class<?>> entry : restyResolver.getIdClassMap().entrySet())\n                    {\n                        JClassType entryType = find(entry.getValue());\n                        if (!isLeaf || source.equals(entryType))\n                            possibleTypes.add(new Subtype(entry.getKey(), entryType));\n                    }\n                    if (isLeaf && possibleTypes.size() == 0)\n                        error(\"Could not find entry in \" + restyResolver.getClass().getName() + \" for type: \" + source);\n                }\n                else\n                {\n                    error(\"Cannot find required subtype resolution for type: \" + source);\n                }\n            }\n            else\n            {\n                error(\"Id.NONE not supported\");\n            }\n        }\n        else\n        {           \n            possibleTypes.add(new Subtype(null, source));\n        }\n        return possibleTypes;\n    }\n\n    private static List<JClassType> findConcreteSubtypes(GeneratorContext context, final JClassType classType)\n    {\n        List<JClassType> l = Lists.newArrayList();\n        for (JClassType t : context.getTypeOracle().getTypes()) {\n            if (!t.isAbstract() && t.isAssignableTo(classType))\n                l.add(t);\n        }\n        return l;\n    }\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> sTypeIdResolverMap = null;\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> getRestyResolverClassMap(GeneratorContext context,\n            TreeLogger logger) throws UnableToCompleteException\n    {\n        if (sTypeIdResolverMap == null)\n        {\n            try\n            {\n                Map<Class<?>, RestyJsonTypeIdResolver> map = Maps.newHashMap();\n                List<String> values = context.getPropertyOracle()\n                        .getConfigurationProperty(\"org.fusesource.restygwt.jsontypeidresolver\").getValues();\n                for (String value : values)\n                    try\n                    {\n                        Class<?> clazz = Class.forName(value);\n                        RestyJsonTypeIdResolver resolver = (RestyJsonTypeIdResolver) clazz.newInstance();\n                        map.put(resolver.getTypeIdResolverClass(), resolver);\n                    }\n                    catch (Exception e)\n                    {\n                        logger.log(WARN, \"Could not access class: \" + values.get(0), e);\n                    }\n                sTypeIdResolverMap = map;\n            }\n            catch (BadPropertyValueException e)\n            {\n                logger.log(ERROR, \"Could not acccess property: RestyJsonTypeIdResolver\", e);\n                throw new UnableToCompleteException();\n            }\n        }\n        return sTypeIdResolverMap;\n    }\n\n    private List<JField> getOrderedFields(List<JField> fields, JConstructor creator) throws UnableToCompleteException\n    {\n        List<JField> orderedFields = new ArrayList<JField>();\n        for (JParameter param : creator.getParameters())\n        {\n            JsonProperty prop = param.getAnnotation(JsonProperty.class);\n            if (prop != null)\n            {\n                for (JField field : fields)\n                {\n                    if (field.getName().equals(prop.value()))\n                    {\n                        orderedFields.add(field);\n                    }\n                }\n            }\n            else\n            {\n                error(\"a constructor annotated with @JsonCreator requires that all paramaters are annotated with @JsonProperty.\");\n            }\n        }\n\n        return orderedFields;\n    }\n\n    private JConstructor findCreator(JClassType sourceClazz)\n    {\n        for (JConstructor constructor : sourceClazz.getConstructors())\n        {\n            if (constructor.getAnnotation(JsonCreator.class) != null)\n            {\n                return constructor;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the setter for the specified field or null if a setter can't be found.\n     */\n    private String getSetterName(JField field)\n    {\n        String fieldName = field.getName();\n        fieldName = \"set\" + upperCaseFirstChar(fieldName);\n        JClassType type = field.getEnclosingType();\n        if (exists(type, field, fieldName, true))\n        {\n            return fieldName;\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the getter for the specified field or null if a getter can't be found.\n     */\n    private String getGetterName(JField field)\n    {\n        String fieldName = field.getName();\n        JType booleanType = null;\n        try\n        {\n            booleanType = find(Boolean.class);\n        }\n        catch (UnableToCompleteException e)\n        {\n            // do nothing\n        }\n        JClassType type = field.getEnclosingType();\n        if (field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType))\n        {\n            fieldName = \"is\" + upperCaseFirstChar(field.getName());\n            if (exists(type, field, fieldName, false))\n            {\n                return fieldName;\n            }\n            fieldName = \"has\" + upperCaseFirstChar(field.getName());\n            if (exists(type, field, fieldName, false))\n            {\n                return fieldName;\n            }\n        }\n        fieldName = \"get\" + upperCaseFirstChar(field.getName());\n        if (exists(type, field, fieldName, false))\n        {\n            return fieldName;\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    private String upperCaseFirstChar(String in)\n    {\n        if (in.length() == 1)\n        {\n            return in.toUpperCase();\n        }\n        else\n        {\n            return in.substring(0, 1).toUpperCase() + in.substring(1);\n        }\n    }\n\n    /**\n     * checks whether a getter or setter exists on the specified type or any of its super classes\n     * excluding Object.\n     * \n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter)\n    {\n        if (field instanceof DummyJField)\n        {\n            return true;\n        }\n\n        JType[] args = null;\n        if (isSetter)\n        {\n            args = new JType[]\n            {\n                field.getType()\n            };\n        }\n        else\n        {\n            args = new JType[] {};\n        }\n\n        if (null != type.findMethod(fieldName, args))\n        {\n            return true;\n        }\n        else\n        {\n            try\n            {\n                JType objectType = find(Object.class);\n                JClassType superType = type.getSuperclass();\n                if (!objectType.equals(superType))\n                {\n                    return exists(superType, field, fieldName, isSetter);\n                }\n            }\n            catch (UnableToCompleteException e)\n            {\n                // do nothing\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Inspects the supplied type and all super classes up to but excluding Object and returns a\n     * list of all fields found in these classes.\n     * \n     * @param type\n     * @return\n     */\n    private List<JField> getFields(JClassType type)\n    {\n        List<JField> allFields = getFields(new ArrayList<JField>(), type);\n        Map<String, JMethod> getters = new HashMap<String, JMethod>();\n        Map<String, JType> setters = new HashMap<String, JType>();\n        for (JMethod m : type.getInheritableMethods())\n        {\n            if (m.getName().startsWith(\"set\") && m.getParameterTypes().length == 1 &&\n                    m.getReturnType() == JPrimitiveType.VOID)\n            {\n                setters.put(m.getName().replaceFirst(\"^set\", \"\"), m.getParameterTypes()[0]);\n            }\n            else if (m.getName().startsWith(\"get\") && m.getParameterTypes().length == 0 &&\n                    m.getReturnType() != JPrimitiveType.VOID)\n            {\n                getters.put(m.getName().replaceFirst(\"^get\", \"\"), m);\n            }\n        }\n        for (Map.Entry<String, JMethod> entry : getters.entrySet())\n        {\n            if (setters.containsKey(entry.getKey()) &&\n                    setters.get(entry.getKey()).equals(entry.getValue().getReturnType()))\n            {\n                String name = entry.getKey().substring(0, 1).toLowerCase() + entry.getKey().substring(1);\n\n                boolean found = false;\n                for (JField f : allFields)\n                {\n                    if (f.getName().equals(name))\n                    {\n                        found = true;\n                        break;\n                    }\n                }\n                JField f = type.getField(name);\n                if (!found && !(f != null && f.isAnnotationPresent(JsonIgnore.class)))\n                {\n                    DummyJField dummy = new DummyJField(name, entry.getValue().getReturnType());\n                    if (entry.getValue().isAnnotationPresent(JsonProperty.class))\n                    {\n                        dummy.setAnnotation(entry.getValue().getAnnotation(JsonProperty.class));\n                    }\n                    allFields.add(dummy);\n                }\n            }\n        }\n        return allFields;\n    }\n\n    private List<JField> getFields(List<JField> allFields, JClassType type)\n    {\n        JField[] fields = type.getFields();\n        for (JField field : fields)\n        {\n            if (!field.isTransient() && !field.isAnnotationPresent(JsonIgnore.class))\n            {\n                allFields.add(field);\n            }\n        }\n        try\n        {\n            JType objectType = find(Object.class);\n            if (!objectType.equals(type))\n            {\n                JClassType superType = type.getSuperclass();\n                return getFields(allFields, superType);\n            }\n        }\n        catch (UnableToCompleteException e)\n        {\n            // do nothing\n        }\n\n        return allFields;\n    }\n\n    private String getTypeInfoPropertyValue(final JsonTypeInfo typeInfo)\n    {\n        String propValue;\n        if (typeInfo.use() == Id.CLASS && \"\".equals(typeInfo.property()))\n            propValue = Id.CLASS.getDefaultPropertyName();\n        else\n            propValue = typeInfo.property();\n\n        return wrap(propValue);\n    }\n}\n","lineNo":182}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.codehaus.jackson.annotate.JsonCreator;\nimport org.codehaus.jackson.annotate.JsonIgnore;\nimport org.codehaus.jackson.annotate.JsonIgnoreProperties;\nimport org.codehaus.jackson.annotate.JsonProperty;\nimport org.codehaus.jackson.annotate.JsonSubTypes;\nimport org.codehaus.jackson.annotate.JsonTypeInfo;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.As;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.Id;\nimport org.codehaus.jackson.annotate.JsonTypeName;\nimport org.codehaus.jackson.map.annotate.JsonTypeIdResolver;\nimport org.codehaus.jackson.map.jsontype.TypeIdResolver;\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JConstructor;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.thirdparty.guava.common.collect.Lists;\nimport com.google.gwt.thirdparty.guava.common.collect.Maps;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * \n *         Updates: added getter & setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n * \n *         added polymorphic support\n * @author <a href=\"http://charliemason.info\">Charlie Mason<\/a>\n * \n */\n\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n\n    JsonEncoderDecoderInstanceLocator locator;\n\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n\tsuper(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n\tClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n\tcomposerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n\treturn composerFactory;\n    }\n\n    private static class Subtype {\n\tfinal String tag;\n\tfinal JClassType clazz;\n\n\tpublic Subtype(String tag, JClassType clazz) {\n\t    this.tag = tag;\n\t    this.clazz = clazz;\n\t}\n    }\n\n    private <T extends Annotation> T findAnnotation(JClassType clazz, Class<T> annotation) {\n\tif (clazz == null)\n\t    return null;\n\telse if (clazz.isAnnotationPresent(annotation))\n\t    return clazz.getAnnotation(annotation);\n\telse\n\t    return findAnnotation(clazz.getSuperclass(), annotation);\n    }\n\n    @Override\n    public void generate() throws UnableToCompleteException {\n        final List<Subtype> possibleTypes = Lists.newArrayList();\n        final JsonTypeInfo typeInfo = findAnnotation(source, JsonTypeInfo.class);\n        final boolean isLeaf = !source.isAnnotationPresent(JsonTypeInfo.class);\n        if (typeInfo != null) {\n            final JsonSubTypes jacksonSubTypes = findAnnotation(source, JsonSubTypes.class);\n            if (typeInfo.use() == Id.CLASS || typeInfo.use() == Id.MINIMAL_CLASS) {\n        \tif (jacksonSubTypes != null) {\n        \t    for (JsonSubTypes.Type type : jacksonSubTypes.value()) {\n        \t\tJClassType typeClass = find(type.value());\n        \t\tif (!isLeaf || source.equals(typeClass))\n        \t\t    possibleTypes.add(new Subtype(typeInfo.use() == Id.CLASS ? typeClass.getQualifiedSourceName() : typeClass.getSimpleSourceName(), typeClass));\n        \t    }\n        \t} else {\n        \t    error(\"@JsonSubTypes annotation missing for type: \" + source);\n        \t}\n            } else if (typeInfo.use() != Id.NONE) {\n        \tfinal JsonTypeIdResolver typeResolver = findAnnotation(source, JsonTypeIdResolver.class);\n        \tif (jacksonSubTypes != null) {\n        \t    for (JsonSubTypes.Type type : jacksonSubTypes.value()) {\n        \t\tif (type.name() != null && !type.name().isEmpty()) {\n        \t\t    JClassType typeClass = find(type.value());\n        \t\t    if (!isLeaf || source.equals(typeClass))\n        \t\t\tpossibleTypes.add(new Subtype(type.name(), typeClass));\n        \t\t} else {\n        \t\t    JsonTypeName nameAnnotation = type.value().getAnnotation(JsonTypeName.class);\n        \t\t    if (nameAnnotation == null || nameAnnotation.value() == null || nameAnnotation.value().isEmpty())\n        \t\t\terror(\"Cannot find @JsonTypeName annotation for type: \" + type.value());\n        \t\t    JClassType typeClass = find(type.value());\n        \t\t    if (!isLeaf || source.equals(typeClass))\n        \t\t\tpossibleTypes.add(new Subtype(nameAnnotation.value(), typeClass));\n        \t\t}\n        \t    }\n        \t    if (isLeaf && possibleTypes.size() == 0)\n        \t\terror(\"Could not find @JsonSubTypes entry for type: \" + source);\n        \t} else if (typeResolver != null) {\n        \t    Class<? extends TypeIdResolver> resolverClass = typeResolver.value();\n        \t    RestyJsonTypeIdResolver restyResolver;\n        \t    if (RestyJsonTypeIdResolver.class.isAssignableFrom(resolverClass)) {\n        \t\ttry {\n        \t\t    restyResolver = (RestyJsonTypeIdResolver) resolverClass.newInstance();\n        \t\t} catch (Exception e) {\n        \t\t    logger.log(ERROR, \"Could not acccess: \" + resolverClass, e);\n        \t\t    throw new UnableToCompleteException();\n        \t\t}\n        \t    } else {\n        \t\trestyResolver = getRestyResolverClassMap(context, logger).get(resolverClass);\n        \t\tif (restyResolver == null)\n        \t\t    error(\"Could not find RestyJsonTypeIdResolver for \" + resolverClass + \" did you forget to put <extend-configuration-property name=\\\"org.fusesource.restygwt.jsontypeidresolver\\\" value=\\\"<fully-qualified-class-implementing-RestyJsonTypeIdResolver>\\\"/> in your *.gwt.xml?\");\n    \n        \t    }\n    \n        \t    for (Map.Entry<String, Class<?>> entry : restyResolver.getIdClassMap().entrySet()) {\n        \t\tJClassType entryType = find(entry.getValue());\n        \t\tif (!isLeaf || source.equals(entryType))\n        \t\t    possibleTypes.add(new Subtype(entry.getKey(), entryType));\n        \t    }\n        \t    if (isLeaf && possibleTypes.size() == 0)\n        \t\terror(\"Could not find entry in \" + restyResolver.getClass().getName() + \" for type: \" + source);\n        \t} else {\n        \t    error(\"Cannot find required subtype resolution for type: \" + source);\n        \t}\n            } else {\n        \terror(\"Id.NONE not supported\");\n            }\n        } else {\n            possibleTypes.add(new Subtype(null, source));\n        }\n        locator = new JsonEncoderDecoderInstanceLocator(context, logger);\n    \n        JClassType sourceClazz = source.isClass();\n        if (sourceClazz == null) {\n            error(\"Type is not a class\");\n        }\n    \n    \n        if (sourceClazz.isAbstract()) {\n            if (typeInfo == null) {\n        \terror(\"Abstract classes must be annotated with JsonTypeInfo\");\n            }\n        }\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n        final String railsWrapperName = jsonAnnotation != null && jsonAnnotation.name().length() > 0 ? jsonAnnotation.name() : sourceClazz.getName().toLowerCase();\n    \n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n    \n        if (null != sourceClazz.isEnum()) {\n            p();\n            p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n            {\n        \tp(\"if( value==null ) {\").i(1);\n        \t{\n        \t    p(\"return com.google.gwt.json.client.JSONNull.getInstance();\").i(-1);\n        \t}\n        \tp(\"}\");\n        \tp(\"return new com.google.gwt.json.client.JSONString(value.name());\");\n            }\n            i(-1).p(\"}\");\n            p();\n            p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n            {\n        \tp(\"if( value == null || value.isNull()!=null ) {\").i(1);\n        \t{\n        \t    p(\"return null;\").i(-1);\n        \t}\n        \tp(\"}\");\n        \tp(\"com.google.gwt.json.client.JSONString str = value.isString();\");\n        \tp(\"if( null == str ) {\").i(1);\n        \t{\n        \t    p(\"throw new DecodingException(\\\"Expected a json string (for enum), but was given: \\\"+value);\").i(-1);\n        \t}\n        \tp(\"}\");\n        \tp(\"return Enum.valueOf(\" + source.getParameterizedQualifiedSourceName() + \".class, str.stringValue());\").i(-1);\n            }\n            p(\"}\");\n            p();\n            return;\n        }\n    \n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n        \tp(\"return null;\");\n            }\n            i(-1).p(\"}\");\n    \n            boolean returnWrapper = false; // if set, return rrc\n    \n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n            if (classStyle == Style.RAILS) {\n        \treturnWrapper = true;\n        \tp(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n        \tp(\"rrc.put(\\\"\" + railsWrapperName + \"\\\" , rc);\");\n            }\n    \n            for (Subtype possibleType : possibleTypes) {\n        \t// Try to find a constuctor that is annotated as creator\n        \tfinal JConstructor creator = findCreator(possibleType.clazz);\n        \t\n                List<JField> orderedFields = creator == null ? null : getOrderedFields(getFields(possibleType.clazz), creator);\n    \n        \tif (!isLeaf) {\n        \t    // Generate a decoder for each possible type\n        \t    p(\"if(value.getClass().getName().equals(\\\"\" + possibleType.clazz.getQualifiedBinaryName() + \"\\\"))\");\n        \t    p(\"{\");\n        \t}\n    \n        \tif (typeInfo != null) {\n        \t    switch (typeInfo.include()) {\n        \t    case PROPERTY:\n        \t\tp(\"com.google.gwt.json.client.JSONValue className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\");\");\n        \t\tp(\"if( className!=null ) { \").i(1);\n        \t\tp(\"rc.put(\" + getTypeInfoPropertyValue(typeInfo) + \", className);\");\n        \t\ti(-1).p(\"}\");\n        \t\tbreak;\n        \t    case WRAPPER_OBJECT:\n        \t\treturnWrapper = true;\n        \t\tp(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n        \t\tp(\"rrc.put(\\\"\" + possibleType.tag + \"\\\", rc);\");\n        \t\tbreak;\n        \t    case WRAPPER_ARRAY:\n        \t\treturnWrapper = true;\n        \t\tp(JSON_ARRAY_CLASS + \" rrc = new \" + JSON_ARRAY_CLASS + \"();\");\n        \t\tp(\"rrc.set(0, org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\"));\");\n        \t\tp(\"rrc.set(1, rc);\");\n        \t    }\n        \t}\n    \n        \tp(possibleType.clazz.getParameterizedQualifiedSourceName() + \" parseValue = (\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \")value;\");\n    \n        \tfor (final JField field : getFields(possibleType.clazz)) {\n    \n        \t    final String getterName = getGetterName(field);\n\n                boolean ignoreField = false;\n                if(possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null) {\n                    for(String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value()) {\n                        if(s.equals(field.getName())) {\n                            ignoreField = true;\n                            break;\n                        }\n                    }\n                }\n    \n        \t    // If can ignore some fields right off the back..\n        \t    // if there is a creator encode only final fields with JsonProperty annotation\n                if (ignoreField || getterName == null && (field.isStatic() || (field.isFinal() && !(creator != null && orderedFields.contains(field))) || field.isTransient() \n                        || field.isAnnotationPresent(JsonIgnore.class))) {\n                    continue;\n                }\n\n        \t    branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n        \t\tpublic Void execute() throws UnableToCompleteException {\n        \t\t    // TODO: try to get the field with a setter or\n        \t\t    // JSNI\n        \t\t    if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n    \n        \t\t\tJson jsonAnnotation = field.getAnnotation(Json.class);\n                    JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n    \n        \t\t\tString name = field.getName();\n        \t\t\tString jsonName = name;\n    \n        \t\t\tif (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n        \t\t\t    jsonName = jsonAnnotation.name();\n        \t\t\t}\n                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                        jsonName = jsonPropertyAnnotation.value();\n                    }\n    \n        \t\t\tString fieldExpr = \"parseValue.\" + name;\n        \t\t\tif (getterName != null) {\n        \t\t\t    fieldExpr = \"parseValue.\" + getterName + \"()\";\n        \t\t\t}\n    \n        \t\t\tStyle style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n        \t\t\tString expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n    \n        \t\t\tp(\"{\").i(1);\n        \t\t\t{\n        \t\t\t    if (null != field.getType().isEnum()) {\n        \t\t\t\tp(\"if(\" + fieldExpr + \" == null) {\").i(1);\n        \t\t\t\tp(\"rc.put(\" + wrap(jsonName) + \", null);\");\n        \t\t\t\ti(-1).p(\"} else {\").i(1);\n        \t\t\t    }\n    \n        \t\t\t    p(JSON_VALUE_CLASS + \" v=\" + expression + \";\");\n        \t\t\t    p(\"if( v!=null ) {\").i(1);\n        \t\t\t    {\n        \t\t\t\tp(\"rc.put(\" + wrap(jsonName) + \", v);\");\n        \t\t\t    }\n        \t\t\t    i(-1).p(\"}\");\n    \n        \t\t\t    if (null != field.getType().isEnum()) {\n        \t\t\t\ti(-1).p(\"}\");\n        \t\t\t    }\n    \n        \t\t\t}\n        \t\t\ti(-1).p(\"}\");\n    \n        \t\t    } else {\n        \t\t        logger.log(ERROR, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n        \t\t    }\n        \t\t    return null;\n        \t\t}\n        \t    });\n    \n        \t}\n    \n        \tif (returnWrapper) {\n        \t    p(\"return rrc;\");\n        \t} else {\n        \t    p(\"return rc;\");\n        \t}\n    \n        \tif (!isLeaf) {\n        \t    p(\"}\");\n        \t}\n            }\n    \n            if (!isLeaf) {\n        \t// Shouldn't get called\n        \tp(\"return null;\");\n            }\n        }\n        i(-1).p(\"}\");\n        p();\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n            {\n                p(\"return null;\").i(-1);\n            }\n            p(\"}\");\n            if (classStyle == Style.RAILS) {\n        \tp(JSON_OBJECT_CLASS + \" object = toObjectFromWrapper(value, \\\"\" + railsWrapperName + \"\\\");\");\n            } else if (typeInfo != null && typeInfo.include() == As.WRAPPER_ARRAY) {\n        \tp(JSON_ARRAY_CLASS + \" array = (\" + JSON_ARRAY_CLASS + \")value;\");\n        \tif (!isLeaf)\n        \t    p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(array.get(0));\");\n        \tp(JSON_OBJECT_CLASS + \" object = toObject(array.get(1));\");\n            } else {\n        \tp(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            }\n    \n            if (!isLeaf && typeInfo != null && typeInfo.include() == As.PROPERTY) {\n                p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" + getTypeInfoPropertyValue(typeInfo) + \"));\");\n            }\n    \n            for (Subtype possibleType : possibleTypes) {\n        \t// Try to find a constuctor that is annotated as creator\n        \tfinal JConstructor creator = findCreator(possibleType.clazz);\n        \tif (typeInfo != null) {\n        \t    if (typeInfo.include() == As.WRAPPER_OBJECT) {\n        \t\tif (!isLeaf) {\n        \t\t    p(\"if(object.containsKey(\\\"\" + possibleType.tag + \"\\\"))\");\n        \t\t    p(\"{\");\n        \t\t}\n        \t\tp(\"object = toObjectFromWrapper(value, \\\"\" + possibleType.tag + \"\\\");\");\n        \t    } else if (!isLeaf) {\n        \t\tp(\"if(sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n        \t\tp(\"{\");\n        \t    }\n        \t}\n    \n        \tList<JField> orderedFields = null;\n        \tif (creator != null) {\n        \t    p(\"// We found a creator so we use the annotated constructor\");\n        \t    p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"(\");\n        \t    i(1).p(\"// The arguments are placed in the order they appear within the annotated constructor\").i(-1);\n        \t    orderedFields = getOrderedFields(getFields(possibleType.clazz), creator);\n        \t    final JField lastField = orderedFields.get(orderedFields.size() - 1);\n        \t    for (final JField field : orderedFields) {\n        \t\tbranch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n        \t\t    public Void execute() throws UnableToCompleteException {\n        \t\t\tJson jsonAnnotation = field.getAnnotation(Json.class);\n        \t\t\tStyle style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n        \t\t\tString jsonName = field.getName();\n        \t\t\tif (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n        \t\t\t    jsonName = jsonAnnotation.name();\n        \t\t\t}\n        \t\t\tString objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n        \t\t\tString expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n        \t\t\tString defaultValue = field.getType().isPrimitive() == null ? \"null\": field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n        \t\t\ti(1).p(\"\" + (objectGetter + \" == null || \" + objectGetter + \" instanceof com.google.gwt.json.client.JSONNull ? \" + defaultValue + \" : \" + expression + ((field != lastField) ? \", \" : \"\"))).i(-1);\n        \t\t\t\n        \t\t\treturn null;\n        \t\t    }\n        \t\t});\n        \t    }\n        \t    p(\");\");\n        \t}\n        \t\n        \tif (orderedFields == null){\n        \t    p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"();\");\n        \t}\n        \t\n                for (final JField field : getFields(possibleType.clazz)) {\n\n                    boolean ignoreField = false;\n                    if(possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null) {\n                        for(String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value()) {\n                            if(s.equals(field.getName())) {\n                                ignoreField = true;\n                                break;\n                            }\n                        }\n                    }\n                    if(ignoreField) {\n                        continue;\n                    }\n\n        \t    if (orderedFields != null && orderedFields.contains(field)){\n        \t        continue;\n        \t    }\n    \n        \t\tfinal String setterName = getSetterName(field);\n    \n        \t\t// If can ignore some fields right off the back..\n        \t\tif (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient()) || \n        \t\t        field.isAnnotationPresent(JsonIgnore.class)) {\n        \t\t    continue;\n        \t\t}\n    \n        \t\tbranch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n        \t\t    public Void execute() throws UnableToCompleteException {\n    \n        \t\t\t// TODO: try to set the field with a setter\n        \t\t\t// or JSNI\n        \t\t\tif (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n    \n        \t\t\t    Json jsonAnnotation = field.getAnnotation(Json.class);\n        \t\t\t    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                        JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n                        \n                        String name = field.getName();\n                        String jsonName = name;\n        \n                        if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                            jsonName = jsonAnnotation.name();\n                        }\n                        if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                            jsonName = jsonPropertyAnnotation.value();\n                        }\n         \n        \t\t\t    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n        \t\t\t    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n    \n                        String cast = field.getType().isPrimitive() == JPrimitiveType.SHORT ? \"(short) \" : \"\";\n        \t\t\t    p(\"if(\" + objectGetter + \" != null) {\").i(1);\n    \n        \t\t\t\tp(\"if(\" + objectGetter + \" instanceof com.google.gwt.json.client.JSONNull) {\").i(1);\n                        String defaultValue = field.getType().isPrimitive() == null ? \"null\": field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n                        \n        \t\t\t\tif (setterName != null) {\n                            p(\"rc.\" + setterName + \"(\" + cast + defaultValue + \");\");\n        \t\t\t\t} else {\n                            p(\"rc.\" + name + \"=\" + cast + defaultValue + \";\");\n        \t\t\t\t}\n    \n        \t\t\t\ti(-1).p(\"} else {\").i(1);\n        \t\t\t    \n        \t\t\t    if (setterName != null) {\n                            p(\"rc.\" + setterName + \"(\" + cast + expression + \");\");\n        \t\t\t    } else {\n                            p(\"rc.\" + name + \"=\" + cast + expression + \";\");\n        \t\t\t    }\n        \t\t\t    i(-1).p(\"}\");    \n        \t\t\t    i(-1).p(\"}\");    \n\n        \t\t\t} else {\n                        logger.log(ERROR, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n        \t\t\t}\n        \t\t\treturn null;\n        \t\t    }\n        \t\t});\n        \t}\n        \t\n        \tp(\"return rc;\");\n    \n        \tif (typeInfo != null && !isLeaf) {\n        \t    p(\"}\");\n        \t}\n            }\n    \n            if (typeInfo != null && !isLeaf) {\n        \tp(\"return null;\");\n            }\n            i(-1).p(\"}\");\n            p();\n        }\n    }\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> sTypeIdResolverMap = null;\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> getRestyResolverClassMap(GeneratorContext context, TreeLogger logger) throws UnableToCompleteException {\n\tif (sTypeIdResolverMap == null) {\n\t    try {\n\t\tMap<Class<?>, RestyJsonTypeIdResolver> map = Maps.newHashMap();\n\t\tList<String> values = context.getPropertyOracle().getConfigurationProperty(\"org.fusesource.restygwt.jsontypeidresolver\").getValues();\n\t\tfor (String value : values)\n\t\t    try {\n\t\t\tClass<?> clazz = Class.forName(value);\n\t\t\tRestyJsonTypeIdResolver resolver = (RestyJsonTypeIdResolver) clazz.newInstance();\n\t\t\tmap.put(resolver.getTypeIdResolverClass(), resolver);\n\t\t    } catch (Exception e) {\n\t\t\tlogger.log(WARN, \"Could not access class: \" + values.get(0), e);\n\t\t    }\n\t\t    sTypeIdResolverMap = map;\n\t    } catch (BadPropertyValueException e) {\n\t\tlogger.log(ERROR, \"Could not acccess property: RestyJsonTypeIdResolver\", e);\n\t\tthrow new UnableToCompleteException();\n\t    }\n\t}\n\treturn sTypeIdResolverMap;\n    }\n\n    private List<JField> getOrderedFields(List<JField> fields, JConstructor creator) throws UnableToCompleteException {\n\tList<JField> orderedFields = new ArrayList<JField>();\n\tfor (JParameter param : creator.getParameters()) {\n\t    JsonProperty prop = param.getAnnotation(JsonProperty.class);\n\t    if (prop != null) {\n\t\tfor (JField field : fields) {\n\t\t    if (field.getName().equals(prop.value())) {\n\t\t\torderedFields.add(field);\n\t\t    }\n\t\t}\n\t    } else {\n\t\terror(\"a constructor annotated with @JsonCreator requires that all paramaters are annotated with @JsonProperty.\");\n\t    }\n\t}\n\n\treturn orderedFields;\n    }\n\n    private JConstructor findCreator(JClassType sourceClazz) {\n\tfor (JConstructor constructor : sourceClazz.getConstructors()) {\n\t    if (constructor.getAnnotation(JsonCreator.class) != null) {\n\t\treturn constructor;\n\t    }\n\t}\n\n\treturn null;\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the setter for the specified field or null if a\n     *         setter can't be found.\n     */\n    private String getSetterName(JField field) {\n\tString fieldName = field.getName();\n\tfieldName = \"set\" + upperCaseFirstChar(fieldName);\n\tJClassType type = field.getEnclosingType();\n\tif (exists(type, field, fieldName, true)) {\n\t    return fieldName;\n\t} else {\n\t    return null;\n\t}\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the getter for the specified field or null if a\n     *         getter can't be found.\n     */\n    private String getGetterName(JField field) {\n\tString fieldName = field.getName();\n\tJType booleanType = null;\n\ttry {\n\t    booleanType = find(Boolean.class);\n\t} catch (UnableToCompleteException e) {\n\t    // do nothing\n\t}\n\tJClassType type = field.getEnclosingType();\n\tif (field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)) {\n\t    fieldName = \"is\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t    fieldName = \"has\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t}\n\tfieldName = \"get\" + upperCaseFirstChar(field.getName());\n\tif (exists(type, field, fieldName, false)) {\n\t    return fieldName;\n\t} else {\n\t    return null;\n\t}\n    }\n\n    private String upperCaseFirstChar(String in) {\n\tif (in.length() == 1) {\n\t    return in.toUpperCase();\n\t} else {\n\t    return in.substring(0, 1).toUpperCase() + in.substring(1);\n\t}\n    }\n\n    /**\n     * checks whether a getter or setter exists on the specified type or any of\n     * its super classes excluding Object.\n     * \n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {\n        if ( field instanceof DummyJField ){\n            return true;\n        }\n        \n\tJType[] args = null;\n\tif (isSetter) {\n\t    args = new JType[] { field.getType() };\n\t} else {\n\t    args = new JType[] {};\n\t}\n\n\tif (null != type.findMethod(fieldName, args)) {\n\t    return true;\n\t} else {\n\t    try {\n\t\tJType objectType = find(Object.class);\n\t\tJClassType superType = type.getSuperclass();\n\t\tif (!objectType.equals(superType)) {\n\t\t    return exists(superType, field, fieldName, isSetter);\n\t\t}\n\t    } catch (UnableToCompleteException e) {\n\t\t// do nothing\n\t    }\n\t}\n\treturn false;\n    }\n\n    /**\n     * Inspects the supplied type and all super classes up to but excluding\n     * Object and returns a list of all fields found in these classes.\n     * \n     * @param type\n     * @return\n     */\n    private List<JField> getFields(JClassType type) {\n        List<JField> allFields = getFields(new ArrayList<JField>(), type);\n        Map<String, JMethod> getters = new HashMap<String, JMethod>();\n        Map<String, JType> setters = new HashMap<String, JType>();\n        for( JMethod m: type.getInheritableMethods() ){\n            if( m.getName().startsWith(\"set\") && m.getParameterTypes().length == 1 && m.getReturnType() == JPrimitiveType.VOID){\n                setters.put( m.getName().replaceFirst(\"^set\", \"\"), m.getParameterTypes()[0] );\n            }\n            else if( m.getName().startsWith(\"get\") && m.getParameterTypes().length == 0 &&  m.getReturnType() != JPrimitiveType.VOID){\n                getters.put( m.getName().replaceFirst(\"^get\", \"\"), m );\n            }\n        }\n        for( Map.Entry<String, JMethod> entry: getters.entrySet() ){\n            if ( setters.containsKey( entry.getKey() ) && setters.get( entry.getKey() ).equals( entry.getValue().getReturnType() ) ) {\n                String name = entry.getKey().substring(0, 1).toLowerCase() + entry.getKey().substring(1);\n\n                boolean found = false;\n                for( JField f : allFields ){\n                    if( f.getName().equals( name ) ){\n                        found = true;\n                        break;\n                    }\n                }\n                JField f = type.getField( name );\n                if ( ! found && !( f != null && f.isAnnotationPresent( JsonIgnore.class ) ) ){\n                    DummyJField dummy = new DummyJField( name, entry.getValue().getReturnType() );\n                    if ( entry.getValue().isAnnotationPresent(JsonProperty.class) ) { \n                        dummy.setAnnotation( entry.getValue().getAnnotation(JsonProperty.class) );\n                    }\n                    allFields.add( dummy );\n                }\n            }\n        }\n        return allFields;\n    }\n\n    private List<JField> getFields(List<JField> allFields, JClassType type) {\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n            if (!field.isTransient() && !field.isAnnotationPresent(JsonIgnore.class)) {\n                allFields.add(field);\n            }\n        }\n        try {\n            JType objectType = find(Object.class);\n            if (!objectType.equals(type)) {\n                JClassType superType = type.getSuperclass();\n                return getFields(allFields, superType);\n            }\n        }\n        catch (UnableToCompleteException e) {\n\t    // do nothing\n        }\n        \n    \treturn allFields;\n    }\n    \n    private String getTypeInfoPropertyValue(final JsonTypeInfo typeInfo){\n        String propValue;\n        if (typeInfo.use() == Id.CLASS && \"\".equals(typeInfo.property()))\n            propValue = Id.CLASS.getDefaultPropertyName();\n        else\n            propValue = typeInfo.property();\n\n        \n        return wrap(propValue);\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.codehaus.jackson.annotate.JsonCreator;\nimport org.codehaus.jackson.annotate.JsonIgnore;\nimport org.codehaus.jackson.annotate.JsonIgnoreProperties;\nimport org.codehaus.jackson.annotate.JsonProperty;\nimport org.codehaus.jackson.annotate.JsonSubTypes;\nimport org.codehaus.jackson.annotate.JsonTypeInfo;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.As;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.Id;\nimport org.codehaus.jackson.annotate.JsonTypeName;\nimport org.codehaus.jackson.map.annotate.JsonDeserialize;\nimport org.codehaus.jackson.map.annotate.JsonTypeIdResolver;\nimport org.codehaus.jackson.map.jsontype.TypeIdResolver;\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JConstructor;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.thirdparty.guava.common.collect.Lists;\nimport com.google.gwt.thirdparty.guava.common.collect.Maps;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * \n *         Updates: added getter & setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n * \n *         added polymorphic support\n * @author <a href=\"http://charliemason.info\">Charlie Mason<\/a>\n * \n *         Updates : add support for JsonTypeInfo default property value class for id.class\n *                   add support for JsonDeserialize for interface\n *                      -> will look for all possible concrete sub-classes\n * @author <a href=\"http://wwww.ronanquillevere.fr\">Ronan Quillevere<\/a>\n * \n */\n\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator\n{\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n \n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source)\n            throws UnableToCompleteException\n    {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory()\n    {\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n        composerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() +\n                \">\");\n        return composerFactory;\n    }\n\n    private static class Subtype\n    {\n        final String tag;\n        final JClassType clazz;\n\n        public Subtype(String tag, JClassType clazz)\n        {\n            this.tag = tag;\n            this.clazz = clazz;\n        }\n    }\n\n    private static <T extends Annotation> T findAnnotation(JClassType clazz, Class<T> annotation)\n    {\n        if (clazz == null)\n            return null;\n        else if (clazz.isAnnotationPresent(annotation))\n            return clazz.getAnnotation(annotation);\n        else\n            return findAnnotation(clazz.getSuperclass(), annotation);\n    }\n\n    @Override\n    public void generate() throws UnableToCompleteException\n    {\n        final JsonTypeInfo typeInfo = findAnnotation(source, JsonTypeInfo.class);\n        final List<Subtype> possibleTypes = findPossibleTypes(context, source);\n\n        if(source.isInterface() != null ){            \n            if (!source.isAnnotationPresent(JsonDeserialize.class))\n                    error(\"Interface must be annotated with @JsonDeserialize.\");\n        } else {\n            if (source.isClass() == null) \n                error(\"Type is not a class or an interface\");\n            \n            if (source.isAbstract())\n            {\n                if (typeInfo == null)\n                    error(\"Abstract classes must be annotated with JsonTypeInfo\");\n            }\n        }\n        \n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n        final String railsWrapperName = jsonAnnotation != null && jsonAnnotation.name().length() > 0 ? jsonAnnotation\n                .name() : source.getName().toLowerCase();\n        final boolean isLeaf = isLeaf(source);\n        final JsonEncoderDecoderInstanceLocator locator = new JsonEncoderDecoderInstanceLocator(context, logger);\n        \n        writeSingleton();\n        writeEncode(source, typeInfo, possibleTypes, classStyle, railsWrapperName, isLeaf, locator);\n        writeDecode(source, typeInfo, possibleTypes, classStyle, railsWrapperName, isLeaf, locator);\n    }\n\n    private void writeDecode(final JClassType source, JsonTypeInfo typeInfo, final List<Subtype> possibleTypes,\n            final Style classStyle, final String railsWrapperName, boolean isLeaf, final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        //TODO @rqu sourceClazz instead of source\n        if (null != source.isEnum())\n        {\n            p();\n            p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n            {\n                p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n                {\n                    p(\"return null;\").i(-1);\n                }\n                p(\"}\");\n                p(\"com.google.gwt.json.client.JSONString str = value.isString();\");\n                p(\"if( null == str ) {\").i(1);\n                {\n                    p(\"throw new DecodingException(\\\"Expected a json string (for enum), but was given: \\\"+value);\").i(\n                            -1);\n                }\n                p(\"}\");\n                p(\"return Enum.valueOf(\" + source.getParameterizedQualifiedSourceName() + \".class, str.stringValue());\")\n                        .i(-1);\n            }\n            p(\"}\");\n            p();\n            return;\n        }\n        \n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n            {\n                p(\"return null;\").i(-1);\n            }\n            p(\"}\");\n            if (classStyle == Style.RAILS)\n            {\n                p(JSON_OBJECT_CLASS + \" object = toObjectFromWrapper(value, \\\"\" + railsWrapperName + \"\\\");\");\n            }\n            else if (typeInfo != null && typeInfo.include() == As.WRAPPER_ARRAY)\n            {\n                p(JSON_ARRAY_CLASS + \" array = (\" + JSON_ARRAY_CLASS + \")value;\");\n                if (!isLeaf)\n                    p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(array.get(0));\");\n                p(JSON_OBJECT_CLASS + \" object = toObject(array.get(1));\");\n            }\n            else\n            {\n                p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            }\n\n            typeInfo = writeSourceName(source, possibleTypes, typeInfo, isLeaf);\n\n            for (Subtype possibleType : possibleTypes)\n            {\n                // Try to find a constuctor that is annotated as creator\n                final JConstructor creator = findCreator(possibleType.clazz);\n                if (typeInfo != null)\n                {\n                    if (typeInfo.include() == As.WRAPPER_OBJECT)\n                    {\n                        if (!isLeaf)\n                        {\n                            p(\"if(object.containsKey(\\\"\" + possibleType.tag + \"\\\"))\");\n                            p(\"{\");\n                        }\n                        p(\"object = toObjectFromWrapper(value, \\\"\" + possibleType.tag + \"\\\");\");\n                    }\n                    else if (!isLeaf)\n                    {\n                        p(\"if(sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n                        p(\"{\");\n                    }\n                }\n\n                List<JField> orderedFields = null;\n                if (creator != null)\n                {\n                    p(\"// We found a creator so we use the annotated constructor\");\n                    p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" +\n                            possibleType.clazz.getParameterizedQualifiedSourceName() + \"(\");\n                    i(1).p(\"// The arguments are placed in the order they appear within the annotated constructor\").i(\n                            -1);\n                    orderedFields = getOrderedFields(getFields(possibleType.clazz), creator);\n                    final JField lastField = orderedFields.get(orderedFields.size() - 1);\n                    for (final JField field : orderedFields)\n                    {\n                        branch(\"Processing field: \" + field.getName(), new Branch<Void>()\n                        {\n                            public Void execute() throws UnableToCompleteException\n                            {\n                                Json jsonAnnotation = field.getAnnotation(Json.class);\n                                Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                String jsonName = field.getName();\n                                if (jsonAnnotation != null && jsonAnnotation.name().length() > 0)\n                                {\n                                    jsonName = jsonAnnotation.name();\n                                }\n                                String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                String defaultValue = field.getType().isPrimitive() == null ? \"null\" : field.getType()\n                                        .isPrimitive().getUninitializedFieldExpression() +\n                                        \"\";\n                                i(1).p(\"\" +\n                                        (objectGetter + \" == null || \" + objectGetter +\n                                                \" instanceof com.google.gwt.json.client.JSONNull ? \" + defaultValue +\n                                                \" : \" + expression + ((field != lastField) ? \", \" : \"\"))).i(-1);\n\n                                return null;\n                            }\n                        });\n                    }\n                    p(\");\");\n                }\n\n                if (orderedFields == null)\n                {\n                    p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" +\n                            possibleType.clazz.getParameterizedQualifiedSourceName() + \"();\");\n                }\n\n                for (final JField field : getFields(possibleType.clazz))\n                {\n\n                    boolean ignoreField = false;\n                    if (possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null)\n                    {\n                        for (String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value())\n                        {\n                            if (s.equals(field.getName()))\n                            {\n                                ignoreField = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (ignoreField)\n                    {\n                        continue;\n                    }\n\n                    if (orderedFields != null && orderedFields.contains(field))\n                    {\n                        continue;\n                    }\n\n                    final String setterName = getSetterName(field);\n\n                    // If can ignore some fields right off the back..\n                    if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient()) ||\n                            field.isAnnotationPresent(JsonIgnore.class))\n                    {\n                        continue;\n                    }\n\n                    branch(\"Processing field: \" + field.getName(), new Branch<Void>()\n                    {\n                        public Void execute() throws UnableToCompleteException\n                        {\n\n                            // TODO: try to set the field with a setter\n                            // or JSNI\n                            if (setterName != null || field.isDefaultAccess() || field.isProtected() ||\n                                    field.isPublic())\n                            {\n\n                                Json jsonAnnotation = field.getAnnotation(Json.class);\n                                Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n\n                                String name = field.getName();\n                                String jsonName = name;\n\n                                if (jsonAnnotation != null && jsonAnnotation.name().length() > 0)\n                                {\n                                    jsonName = jsonAnnotation.name();\n                                }\n                                if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null &&\n                                        jsonPropertyAnnotation.value().length() > 0)\n                                {\n                                    jsonName = jsonPropertyAnnotation.value();\n                                }\n\n                                String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                String cast = field.getType().isPrimitive() == JPrimitiveType.SHORT ? \"(short) \" : \"\";\n                                p(\"if(\" + objectGetter + \" != null) {\").i(1);\n\n                                p(\"if(\" + objectGetter + \" instanceof com.google.gwt.json.client.JSONNull) {\").i(1);\n                                String defaultValue = field.getType().isPrimitive() == null ? \"null\" : field.getType()\n                                        .isPrimitive().getUninitializedFieldExpression() +\n                                        \"\";\n\n                                if (setterName != null)\n                                {\n                                    p(\"rc.\" + setterName + \"(\" + cast + defaultValue + \");\");\n                                }\n                                else\n                                {\n                                    p(\"rc.\" + name + \"=\" + cast + defaultValue + \";\");\n                                }\n\n                                i(-1).p(\"} else {\").i(1);\n\n                                if (setterName != null)\n                                {\n                                    p(\"rc.\" + setterName + \"(\" + cast + expression + \");\");\n                                }\n                                else\n                                {\n                                    p(\"rc.\" + name + \"=\" + cast + expression + \";\");\n                                }\n                                i(-1).p(\"}\");\n                                i(-1).p(\"}\");\n\n                            }\n                            else\n                            {\n                                logger.log(ERROR, \"private field gets ignored: \" +\n                                        field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                            }\n                            return null;\n                        }\n                    });\n                }\n\n                p(\"return rc;\");\n\n                if (typeInfo != null && !isLeaf)\n                {\n                    p(\"}\");\n                }\n            }\n\n            if (typeInfo != null && !isLeaf)\n            {\n                p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n            p();\n        }\n    }\n\n    private void writeEncode(final JClassType source, final JsonTypeInfo typeInfo, final List<Subtype> possibleTypes,\n            final Style classStyle, final String railsWrapperName, boolean isLeaf, final JsonEncoderDecoderInstanceLocator locator) throws UnableToCompleteException\n    {\n        if (null != source.isEnum())\n        {\n            p();\n            p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\")\n                    .i(1);\n            {\n                p(\"if( value==null ) {\").i(1);\n                {\n                    p(\"return com.google.gwt.json.client.JSONNull.getInstance();\").i(-1);\n                }\n                p(\"}\");\n                p(\"return new com.google.gwt.json.client.JSONString(value.name());\");\n            }\n            i(-1).p(\"}\");\n            p();  \n            return;\n        }\n        \n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n\n            boolean returnWrapper = false; // if set, return rrc\n\n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n            if (classStyle == Style.RAILS)\n            {\n                returnWrapper = true;\n                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                p(\"rrc.put(\\\"\" + railsWrapperName + \"\\\" , rc);\");\n            }\n\n            for (Subtype possibleType : possibleTypes)\n            {\n                // Try to find a constuctor that is annotated as creator\n                final JConstructor creator = findCreator(possibleType.clazz);\n\n                List<JField> orderedFields = creator == null ? null : getOrderedFields(getFields(possibleType.clazz),\n                        creator);\n\n                if (!isLeaf)\n                {\n                    // Generate a decoder for each possible type\n                    p(\"if(value.getClass().getName().equals(\\\"\" + possibleType.clazz.getQualifiedBinaryName() + \"\\\"))\");\n                    p(\"{\");\n                }\n\n                if (typeInfo != null)\n                {\n                    switch (typeInfo.include())\n                    {\n                        case PROPERTY:\n                            p(\"com.google.gwt.json.client.JSONValue className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" +\n                                    possibleType.tag + \"\\\");\");\n                            p(\"if( className!=null ) { \").i(1);\n                            p(\"rc.put(\" + getTypeInfoPropertyValue(typeInfo) + \", className);\");\n                            i(-1).p(\"}\");\n                            break;\n                        case WRAPPER_OBJECT:\n                            returnWrapper = true;\n                            p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                            p(\"rrc.put(\\\"\" + possibleType.tag + \"\\\", rc);\");\n                            break;\n                        case WRAPPER_ARRAY:\n                            returnWrapper = true;\n                            p(JSON_ARRAY_CLASS + \" rrc = new \" + JSON_ARRAY_CLASS + \"();\");\n                            p(\"rrc.set(0, org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" +\n                                    possibleType.tag + \"\\\"));\");\n                            p(\"rrc.set(1, rc);\");\n                    }\n                }\n\n                p(possibleType.clazz.getParameterizedQualifiedSourceName() + \" parseValue = (\" +\n                        possibleType.clazz.getParameterizedQualifiedSourceName() + \")value;\");\n\n                for (final JField field : getFields(possibleType.clazz))\n                {\n\n                    final String getterName = getGetterName(field);\n\n                    boolean ignoreField = false;\n                    if (possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null)\n                    {\n                        for (String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value())\n                        {\n                            if (s.equals(field.getName()))\n                            {\n                                ignoreField = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    // If can ignore some fields right off the back..\n                    // if there is a creator encode only final fields with JsonProperty annotation\n                    if (ignoreField ||\n                            getterName == null &&\n                            (field.isStatic() ||\n                                    (field.isFinal() && !(creator != null && orderedFields.contains(field))) ||\n                                    field.isTransient() || field.isAnnotationPresent(JsonIgnore.class)))\n                    {\n                        continue;\n                    }\n\n                    branch(\"Processing field: \" + field.getName(), new Branch<Void>()\n                    {\n                        public Void execute() throws UnableToCompleteException\n                        {\n                            // TODO: try to get the field with a setter or\n                            // JSNI\n                            if (getterName != null || field.isDefaultAccess() || field.isProtected() ||\n                                    field.isPublic())\n                            {\n\n                                Json jsonAnnotation = field.getAnnotation(Json.class);\n                                JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n\n                                String name = field.getName();\n                                String jsonName = name;\n\n                                if (jsonAnnotation != null && jsonAnnotation.name().length() > 0)\n                                {\n                                    jsonName = jsonAnnotation.name();\n                                }\n                                if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null &&\n                                        jsonPropertyAnnotation.value().length() > 0)\n                                {\n                                    jsonName = jsonPropertyAnnotation.value();\n                                }\n\n                                String fieldExpr = \"parseValue.\" + name;\n                                if (getterName != null)\n                                {\n                                    fieldExpr = \"parseValue.\" + getterName + \"()\";\n                                }\n\n                                Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                String expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n\n                                p(\"{\").i(1);\n                                {\n                                    if (null != field.getType().isEnum())\n                                    {\n                                        p(\"if(\" + fieldExpr + \" == null) {\").i(1);\n                                        p(\"rc.put(\" + wrap(jsonName) + \", null);\");\n                                        i(-1).p(\"} else {\").i(1);\n                                    }\n\n                                    p(JSON_VALUE_CLASS + \" v=\" + expression + \";\");\n                                    p(\"if( v!=null ) {\").i(1);\n                                    {\n                                        p(\"rc.put(\" + wrap(jsonName) + \", v);\");\n                                    }\n                                    i(-1).p(\"}\");\n\n                                    if (null != field.getType().isEnum())\n                                    {\n                                        i(-1).p(\"}\");\n                                    }\n\n                                }\n                                i(-1).p(\"}\");\n\n                            }\n                            else\n                            {\n                                logger.log(ERROR, \"private field gets ignored: \" +\n                                        field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                            }\n                            return null;\n                        }\n                    });\n\n                }\n\n                if (returnWrapper)\n                {\n                    p(\"return rrc;\");\n                }\n                else\n                {\n                    p(\"return rc;\");\n                }\n\n                if (!isLeaf)\n                {\n                    p(\"}\");\n                }\n            }\n\n            if (!isLeaf)\n            {\n                // Shouldn't get called\n                p(\"return null;\");\n            }\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n\n    private JsonTypeInfo writeSourceName(final JClassType source, final List<Subtype> possibleTypes, JsonTypeInfo typeInfo, boolean isLeaf) throws UnableToCompleteException\n    {\n        if (source.isInterface() != null){\n                \n            boolean classFound = false;\n            JsonTypeInfo ti = null;\n            for (Subtype subtype : possibleTypes)\n            {\n                ti = subtype.clazz.findAnnotationInTypeHierarchy(JsonTypeInfo.class);\n                if (ti != null && ti.use() == Id.CLASS){\n                    classFound = true;\n                    break;\n                }\n            }\n            \n            if (!classFound)\n                error(\"One of the class implementing the interface should have the annotation JsonTypeInfo = class\");\n            \n            p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" +\n                    getTypeInfoPropertyValue(ti) + \"));\");\n            \n            return ti;\n    \n        } else {\n            if (!isLeaf && typeInfo != null && typeInfo.include() == As.PROPERTY)\n            {\n                p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" +\n                        getTypeInfoPropertyValue(typeInfo) + \"));\");\n            }\n            \n            return typeInfo;\n        }\n    }\n\n    private void writeSingleton()\n    {\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n    }\n\n    private static boolean isLeaf(JClassType source)\n    {\n        return !(source.getSubtypes() != null && source.getSubtypes().length > 0);\n    }\n\n    private List<Subtype> findPossibleTypes(GeneratorContext context, JClassType classType) throws UnableToCompleteException\n    {\n        if (classType.isClass() != null)\n            return findPossibleTypesForClass(context, classType);\n        \n        if (classType.isInterface() != null)\n            return findPossibleTypesForInterface(context, classType);\n\n        error(\"Cannot find required subtype resolution for : \" + classType);\n        return null;\n    }\n\n    private List<Subtype> findPossibleTypesForInterface(GeneratorContext context, JClassType classType) throws UnableToCompleteException\n    {\n        if (!classType.isAnnotationPresent(JsonDeserialize.class))\n            error(\"Cannot find required subtype resolution for interface (missing @JsonDeserialize annotation): \" + classType);\n        \n        final List<Subtype> possibleTypes = Lists.newArrayList();\n        \n        final JClassType type = find(classType.getAnnotation(JsonDeserialize.class).as());\n        \n        List<JClassType> resolvedSubtypes = findConcreteSubtypes(context, type);\n        \n        for (JClassType typeClass : resolvedSubtypes) {\n            possibleTypes.add(new Subtype(typeClass.getQualifiedSourceName(), typeClass));\n        }\n\n        return possibleTypes;\n    }\n\n    private List<Subtype> findPossibleTypesForClass(GeneratorContext context, JClassType source) throws UnableToCompleteException\n    {\n        final List<Subtype> possibleTypes = Lists.newArrayList();\n        final JsonTypeInfo typeInfo = findAnnotation(source, JsonTypeInfo.class);\n        final boolean isLeaf = isLeaf(source);\n        if (typeInfo != null)\n        {\n            final JsonSubTypes jacksonSubTypes = findAnnotation(source, JsonSubTypes.class);\n            if (typeInfo.use() == Id.CLASS || typeInfo.use() == Id.MINIMAL_CLASS)\n            {\n                List<JClassType> resolvedSubtypes = Lists.newArrayList();\n                if (jacksonSubTypes != null)\n                {\n                    for (JsonSubTypes.Type type : jacksonSubTypes.value())\n                    {\n                        JClassType typeClass = find(type.value());\n                        if (!isLeaf || source.equals(typeClass))\n                            resolvedSubtypes.add(typeClass);\n                    }\n                }\n                else\n                {\n                   resolvedSubtypes.addAll(findConcreteSubtypes(context, source));                  \n                }\n                for (JClassType typeClass : resolvedSubtypes)\n                    possibleTypes.add(new Subtype(typeInfo.use() == Id.CLASS ? typeClass.getQualifiedSourceName()\n                            : \".\" + typeClass.getSimpleSourceName(), typeClass));\n            }\n            else if (typeInfo.use() != Id.NONE)\n            {\n                final JsonTypeIdResolver typeResolver = findAnnotation(source, JsonTypeIdResolver.class);\n                if (jacksonSubTypes != null)\n                {\n                    for (JsonSubTypes.Type type : jacksonSubTypes.value())\n                    {\n                        if (type.name() != null && !type.name().isEmpty())\n                        {\n                            JClassType typeClass = find(type.value());\n                            if (!isLeaf || source.equals(typeClass))\n                                possibleTypes.add(new Subtype(type.name(), typeClass));\n                        }\n                        else\n                        {\n                            JsonTypeName nameAnnotation = type.value().getAnnotation(JsonTypeName.class);\n                            if (nameAnnotation == null || nameAnnotation.value() == null ||\n                                    nameAnnotation.value().isEmpty())\n                                error(\"Cannot find @JsonTypeName annotation for type: \" + type.value());\n                            JClassType typeClass = find(type.value());\n                            if (!isLeaf || source.equals(typeClass))\n                                possibleTypes.add(new Subtype(nameAnnotation.value(), typeClass));\n                        }\n                    }\n                    if (isLeaf && possibleTypes.size() == 0)\n                        error(\"Could not find @JsonSubTypes entry for type: \" + source);\n                }\n                else if (typeResolver != null)\n                {\n                    Class<? extends TypeIdResolver> resolverClass = typeResolver.value();\n                    RestyJsonTypeIdResolver restyResolver;\n                    if (RestyJsonTypeIdResolver.class.isAssignableFrom(resolverClass))\n                    {\n                        try\n                        {\n                            restyResolver = (RestyJsonTypeIdResolver) resolverClass.newInstance();\n                        }\n                        catch (Exception e)\n                        {\n                            logger.log(ERROR, \"Could not acccess: \" + resolverClass, e);\n                            throw new UnableToCompleteException();\n                        }\n                    }\n                    else\n                    {\n                        restyResolver = getRestyResolverClassMap(context, logger).get(resolverClass);\n                        if (restyResolver == null)\n                            error(\"Could not find RestyJsonTypeIdResolver for \" +\n                                    resolverClass +\n                                    \" did you forget to put <extend-configuration-property name=\\\"org.fusesource.restygwt.jsontypeidresolver\\\" value=\\\"<fully-qualified-class-implementing-RestyJsonTypeIdResolver>\\\"/> in your *.gwt.xml?\");\n\n                    }\n\n                    for (Map.Entry<String, Class<?>> entry : restyResolver.getIdClassMap().entrySet())\n                    {\n                        JClassType entryType = find(entry.getValue());\n                        if (!isLeaf || source.equals(entryType))\n                            possibleTypes.add(new Subtype(entry.getKey(), entryType));\n                    }\n                    if (isLeaf && possibleTypes.size() == 0)\n                        error(\"Could not find entry in \" + restyResolver.getClass().getName() + \" for type: \" + source);\n                }\n                else\n                {\n                    error(\"Cannot find required subtype resolution for type: \" + source);\n                }\n            }\n            else\n            {\n                error(\"Id.NONE not supported\");\n            }\n        }\n        else\n        {           \n            possibleTypes.add(new Subtype(null, source));\n        }\n        return possibleTypes;\n    }\n\n    private static List<JClassType> findConcreteSubtypes(GeneratorContext context, final JClassType classType)\n    {\n        List<JClassType> l = Lists.newArrayList();\n        for (JClassType t : context.getTypeOracle().getTypes()) {\n            if (!t.isAbstract() && t.isAssignableTo(classType))\n                l.add(t);\n        }\n        return l;\n    }\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> sTypeIdResolverMap = null;\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> getRestyResolverClassMap(GeneratorContext context,\n            TreeLogger logger) throws UnableToCompleteException\n    {\n        if (sTypeIdResolverMap == null)\n        {\n            try\n            {\n                Map<Class<?>, RestyJsonTypeIdResolver> map = Maps.newHashMap();\n                List<String> values = context.getPropertyOracle()\n                        .getConfigurationProperty(\"org.fusesource.restygwt.jsontypeidresolver\").getValues();\n                for (String value : values)\n                    try\n                    {\n                        Class<?> clazz = Class.forName(value);\n                        RestyJsonTypeIdResolver resolver = (RestyJsonTypeIdResolver) clazz.newInstance();\n                        map.put(resolver.getTypeIdResolverClass(), resolver);\n                    }\n                    catch (Exception e)\n                    {\n                        logger.log(WARN, \"Could not access class: \" + values.get(0), e);\n                    }\n                sTypeIdResolverMap = map;\n            }\n            catch (BadPropertyValueException e)\n            {\n                logger.log(ERROR, \"Could not acccess property: RestyJsonTypeIdResolver\", e);\n                throw new UnableToCompleteException();\n            }\n        }\n        return sTypeIdResolverMap;\n    }\n\n    private List<JField> getOrderedFields(List<JField> fields, JConstructor creator) throws UnableToCompleteException\n    {\n        List<JField> orderedFields = new ArrayList<JField>();\n        for (JParameter param : creator.getParameters())\n        {\n            JsonProperty prop = param.getAnnotation(JsonProperty.class);\n            if (prop != null)\n            {\n                for (JField field : fields)\n                {\n                    if (field.getName().equals(prop.value()))\n                    {\n                        orderedFields.add(field);\n                    }\n                }\n            }\n            else\n            {\n                error(\"a constructor annotated with @JsonCreator requires that all paramaters are annotated with @JsonProperty.\");\n            }\n        }\n\n        return orderedFields;\n    }\n\n    private JConstructor findCreator(JClassType sourceClazz)\n    {\n        for (JConstructor constructor : sourceClazz.getConstructors())\n        {\n            if (constructor.getAnnotation(JsonCreator.class) != null)\n            {\n                return constructor;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the setter for the specified field or null if a setter can't be found.\n     */\n    private String getSetterName(JField field)\n    {\n        String fieldName = field.getName();\n        fieldName = \"set\" + upperCaseFirstChar(fieldName);\n        JClassType type = field.getEnclosingType();\n        if (exists(type, field, fieldName, true))\n        {\n            return fieldName;\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the getter for the specified field or null if a getter can't be found.\n     */\n    private String getGetterName(JField field)\n    {\n        String fieldName = field.getName();\n        JType booleanType = null;\n        try\n        {\n            booleanType = find(Boolean.class);\n        }\n        catch (UnableToCompleteException e)\n        {\n            // do nothing\n        }\n        JClassType type = field.getEnclosingType();\n        if (field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType))\n        {\n            fieldName = \"is\" + upperCaseFirstChar(field.getName());\n            if (exists(type, field, fieldName, false))\n            {\n                return fieldName;\n            }\n            fieldName = \"has\" + upperCaseFirstChar(field.getName());\n            if (exists(type, field, fieldName, false))\n            {\n                return fieldName;\n            }\n        }\n        fieldName = \"get\" + upperCaseFirstChar(field.getName());\n        if (exists(type, field, fieldName, false))\n        {\n            return fieldName;\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    private String upperCaseFirstChar(String in)\n    {\n        if (in.length() == 1)\n        {\n            return in.toUpperCase();\n        }\n        else\n        {\n            return in.substring(0, 1).toUpperCase() + in.substring(1);\n        }\n    }\n\n    /**\n     * checks whether a getter or setter exists on the specified type or any of its super classes\n     * excluding Object.\n     * \n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter)\n    {\n        if (field instanceof DummyJField)\n        {\n            return true;\n        }\n\n        JType[] args = null;\n        if (isSetter)\n        {\n            args = new JType[]\n            {\n                field.getType()\n            };\n        }\n        else\n        {\n            args = new JType[] {};\n        }\n\n        if (null != type.findMethod(fieldName, args))\n        {\n            return true;\n        }\n        else\n        {\n            try\n            {\n                JType objectType = find(Object.class);\n                JClassType superType = type.getSuperclass();\n                if (!objectType.equals(superType))\n                {\n                    return exists(superType, field, fieldName, isSetter);\n                }\n            }\n            catch (UnableToCompleteException e)\n            {\n                // do nothing\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Inspects the supplied type and all super classes up to but excluding Object and returns a\n     * list of all fields found in these classes.\n     * \n     * @param type\n     * @return\n     */\n    private List<JField> getFields(JClassType type)\n    {\n        List<JField> allFields = getFields(new ArrayList<JField>(), type);\n        Map<String, JMethod> getters = new HashMap<String, JMethod>();\n        Map<String, JType> setters = new HashMap<String, JType>();\n        for (JMethod m : type.getInheritableMethods())\n        {\n            if (m.getName().startsWith(\"set\") && m.getParameterTypes().length == 1 &&\n                    m.getReturnType() == JPrimitiveType.VOID)\n            {\n                setters.put(m.getName().replaceFirst(\"^set\", \"\"), m.getParameterTypes()[0]);\n            }\n            else if (m.getName().startsWith(\"get\") && m.getParameterTypes().length == 0 &&\n                    m.getReturnType() != JPrimitiveType.VOID)\n            {\n                getters.put(m.getName().replaceFirst(\"^get\", \"\"), m);\n            }\n        }\n        for (Map.Entry<String, JMethod> entry : getters.entrySet())\n        {\n            if (setters.containsKey(entry.getKey()) &&\n                    setters.get(entry.getKey()).equals(entry.getValue().getReturnType()))\n            {\n                String name = entry.getKey().substring(0, 1).toLowerCase() + entry.getKey().substring(1);\n\n                boolean found = false;\n                for (JField f : allFields)\n                {\n                    if (f.getName().equals(name))\n                    {\n                        found = true;\n                        break;\n                    }\n                }\n                JField f = type.getField(name);\n                if (!found && !(f != null && f.isAnnotationPresent(JsonIgnore.class)))\n                {\n                    DummyJField dummy = new DummyJField(name, entry.getValue().getReturnType());\n                    if (entry.getValue().isAnnotationPresent(JsonProperty.class))\n                    {\n                        dummy.setAnnotation(entry.getValue().getAnnotation(JsonProperty.class));\n                    }\n                    allFields.add(dummy);\n                }\n            }\n        }\n        return allFields;\n    }\n\n    private List<JField> getFields(List<JField> allFields, JClassType type)\n    {\n        JField[] fields = type.getFields();\n        for (JField field : fields)\n        {\n            if (!field.isTransient() && !field.isAnnotationPresent(JsonIgnore.class))\n            {\n                allFields.add(field);\n            }\n        }\n        try\n        {\n            JType objectType = find(Object.class);\n            if (!objectType.equals(type))\n            {\n                JClassType superType = type.getSuperclass();\n                return getFields(allFields, superType);\n            }\n        }\n        catch (UnableToCompleteException e)\n        {\n            // do nothing\n        }\n\n        return allFields;\n    }\n\n    private String getTypeInfoPropertyValue(final JsonTypeInfo typeInfo)\n    {\n        String propValue;\n        if (typeInfo.use() == Id.CLASS && \"\".equals(typeInfo.property()))\n            propValue = Id.CLASS.getDefaultPropertyName();\n        else\n            propValue = typeInfo.property();\n\n        return wrap(propValue);\n    }\n}\n","lineNo":182}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport static org.fusesource.restygwt.rebind.BaseSourceCreator.DEBUG;\nimport static org.fusesource.restygwt.rebind.BaseSourceCreator.ERROR;\nimport static org.fusesource.restygwt.rebind.BaseSourceCreator.INFO;\nimport static org.fusesource.restygwt.rebind.BaseSourceCreator.TRACE;\nimport static org.fusesource.restygwt.rebind.BaseSourceCreator.WARN;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.fusesource.restygwt.client.AbstractJsonEncoderDecoder;\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\nimport org.fusesource.restygwt.client.ObjectEncoderDecoder;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JParameterizedType;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.xml.client.Document;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n */\npublic class JsonEncoderDecoderInstanceLocator {\n\n    public static final String JSON_ENCODER_DECODER_CLASS = AbstractJsonEncoderDecoder.class.getName();\n    public static final String JSON_CLASS = Json.class.getName();\n\n    public final JClassType STRING_TYPE;\n    public final JClassType JSON_VALUE_TYPE;\n    public final JClassType DOCUMENT_TYPE;\n    public final JClassType MAP_TYPE;\n    public final JClassType SET_TYPE;\n    public final JClassType LIST_TYPE;\n\n    public final HashMap<JType, String> builtInEncoderDecoders = new HashMap<JType, String>();\n\n    public final GeneratorContext context;\n    public final TreeLogger logger;\n\n    public JsonEncoderDecoderInstanceLocator(GeneratorContext context, TreeLogger logger)\n            throws UnableToCompleteException {\n        this.context = context;\n        this.logger = logger;\n\n        this.STRING_TYPE = find(String.class);\n        this.JSON_VALUE_TYPE = find(JSONValue.class);\n        this.DOCUMENT_TYPE = find(Document.class);\n        this.MAP_TYPE = find(Map.class);\n        this.SET_TYPE = find(Set.class);\n        this.LIST_TYPE = find(List.class);\n\n        builtInEncoderDecoders.put(JPrimitiveType.BOOLEAN, JSON_ENCODER_DECODER_CLASS + \".BOOLEAN\");\n        builtInEncoderDecoders.put(JPrimitiveType.BYTE, JSON_ENCODER_DECODER_CLASS + \".BYTE\");\n        builtInEncoderDecoders.put(JPrimitiveType.CHAR, JSON_ENCODER_DECODER_CLASS + \".CHAR\");\n        builtInEncoderDecoders.put(JPrimitiveType.SHORT, JSON_ENCODER_DECODER_CLASS + \".SHORT\");\n        builtInEncoderDecoders.put(JPrimitiveType.INT, JSON_ENCODER_DECODER_CLASS + \".INT\");\n        builtInEncoderDecoders.put(JPrimitiveType.LONG, JSON_ENCODER_DECODER_CLASS + \".LONG\");\n        builtInEncoderDecoders.put(JPrimitiveType.FLOAT, JSON_ENCODER_DECODER_CLASS + \".FLOAT\");\n        builtInEncoderDecoders.put(JPrimitiveType.DOUBLE, JSON_ENCODER_DECODER_CLASS + \".DOUBLE\");\n        builtInEncoderDecoders.put(find(Boolean.class), JSON_ENCODER_DECODER_CLASS + \".BOOLEAN\");\n        builtInEncoderDecoders.put(find(Byte.class), JSON_ENCODER_DECODER_CLASS + \".BYTE\");\n        builtInEncoderDecoders.put(find(Character.class), JSON_ENCODER_DECODER_CLASS + \".CHAR\");\n        builtInEncoderDecoders.put(find(Short.class), JSON_ENCODER_DECODER_CLASS + \".SHORT\");\n        builtInEncoderDecoders.put(find(Integer.class), JSON_ENCODER_DECODER_CLASS + \".INT\");\n        builtInEncoderDecoders.put(find(Long.class), JSON_ENCODER_DECODER_CLASS + \".LONG\");\n        builtInEncoderDecoders.put(find(Float.class), JSON_ENCODER_DECODER_CLASS + \".FLOAT\");\n        builtInEncoderDecoders.put(find(Double.class), JSON_ENCODER_DECODER_CLASS + \".DOUBLE\");\n        builtInEncoderDecoders.put(find(BigDecimal.class), JSON_ENCODER_DECODER_CLASS + \".BIG_DECIMAL\");\n        builtInEncoderDecoders.put(find(BigInteger.class), JSON_ENCODER_DECODER_CLASS + \".BIG_INTEGER\");\n\n        builtInEncoderDecoders.put(STRING_TYPE, JSON_ENCODER_DECODER_CLASS + \".STRING\");\n        builtInEncoderDecoders.put(DOCUMENT_TYPE, JSON_ENCODER_DECODER_CLASS + \".DOCUMENT\");\n        builtInEncoderDecoders.put(JSON_VALUE_TYPE, JSON_ENCODER_DECODER_CLASS + \".JSON_VALUE\");\n\n        builtInEncoderDecoders.put(find(Date.class), JSON_ENCODER_DECODER_CLASS + \".DATE\");\n        \n        builtInEncoderDecoders.put(find(Object.class), ObjectEncoderDecoder.class.getName() + \".INSTANCE\");\n\n    }\n\n    private JClassType find(Class<?> type) throws UnableToCompleteException {\n        return find(type.getName());\n    }\n\n    private JClassType find(String type) throws UnableToCompleteException {\n        return RestServiceGenerator.find(logger, context, type);\n    }\n\n    private String getEncoderDecoder(JType type, TreeLogger logger) throws UnableToCompleteException {\n        String rc = builtInEncoderDecoders.get(type);\n        if (rc == null) {\n            JClassType ct = type.isClass();\n            if (ct != null && !isCollectionType(ct)) {\n                JsonEncoderDecoderClassCreator generator = new JsonEncoderDecoderClassCreator(logger, context, ct);\n                return generator.create() + \".INSTANCE\";\n            }\n        }\n        return rc;\n    }\n\n    public String encodeExpression(JType type, String expression, Style style) throws UnableToCompleteException {\n        return encodeDecodeExpression(type, expression, style, \"encode\", JSON_ENCODER_DECODER_CLASS + \".toJSON\", JSON_ENCODER_DECODER_CLASS + \".toJSON\", JSON_ENCODER_DECODER_CLASS\n                + \".toJSON\", JSON_ENCODER_DECODER_CLASS + \".toJSON\");\n    }\n\n    public String decodeExpression(JType type, String expression, Style style) throws UnableToCompleteException {\n        return encodeDecodeExpression(type, expression, style, \"decode\", JSON_ENCODER_DECODER_CLASS + \".toMap\", JSON_ENCODER_DECODER_CLASS + \".toSet\", JSON_ENCODER_DECODER_CLASS\n                + \".toList\", JSON_ENCODER_DECODER_CLASS + \".toArray\");\n    }\n\n    private String encodeDecodeExpression(JType type, String expression, Style style, String encoderMethod, String mapMethod, String setMethod, String listMethod, String arrayMethod)\n            throws UnableToCompleteException {\n\n        if (null != type.isEnum()) {\n            if (encoderMethod.equals(\"encode\")) {\n                return encodeDecodeExpression(STRING_TYPE, expression + \".name()\", style, encoderMethod, mapMethod, setMethod, listMethod, arrayMethod);\n            } else {\n                return type.getQualifiedSourceName() + \".valueOf(\" + encodeDecodeExpression(STRING_TYPE, expression, style, encoderMethod, mapMethod, setMethod, listMethod, arrayMethod) + \")\";\n            }\n        }\n\n        String encoderDecoder = getEncoderDecoder(type, logger);\n        if (encoderDecoder != null) {\n            return encoderDecoder + \".\" + encoderMethod + \"(\" + expression + \")\";\n        }\n\n        JClassType clazz = type.isClassOrInterface();\n\n        if (isCollectionType(clazz)) {\n            JParameterizedType parameterizedType = type.isParameterized();\n            if (parameterizedType == null || parameterizedType.getTypeArgs() == null) {\n                error(\"Collection types must be parameterized.\");\n            }\n            JClassType[] types = parameterizedType.getTypeArgs();\n\n            if (clazz.isAssignableTo(MAP_TYPE)) {\n                if (types.length != 2) {\n                    error(\"Map must define two and only two type parameters\");\n                }\n                if (isCollectionType(types[0])) {\n                    error(\"Map key can't be a collection\");\n                }\n                if (!builtInEncoderDecoders.containsKey(types[0])) {\n                    error(\"Map key can't be an object\");\n                }\n                String keyEncoderDecoder = getEncoderDecoder(types[0], logger);\n                encoderDecoder = getEncoderDecoder(types[1], logger);\n                if (encoderDecoder != null && keyEncoderDecoder != null) {\n                    return mapMethod + \"(\" + expression + \", \" + keyEncoderDecoder + \", \" + encoderDecoder + \", \"\n                            + JSON_CLASS + \".Style.\" + style.name() + \")\";\n                } else if (encoderDecoder != null) {\n                    return mapMethod + \"(\" + expression + \", \" + encoderDecoder + \", \" + JSON_CLASS + \".Style.\"\n                            + style.name() + \")\";\n                }\n            } else if (clazz.isAssignableTo(SET_TYPE)) {\n                if (types.length != 1) {\n                    error(\"Set must define one and only one type parameter\");\n                }\n                encoderDecoder = getEncoderDecoder(types[0], logger);\n                if (encoderDecoder != null) {\n                    return setMethod + \"(\" + expression + \", \" + encoderDecoder + \")\";\n                }\n            } else if (clazz.isAssignableTo(LIST_TYPE)) {\n                if (types.length != 1) {\n                    error(\"List must define one and only one type parameter\");\n                }\n                encoderDecoder = getEncoderDecoder(types[0], logger);\n                debug(\"type encoder for: \" + types[0] + \" is \" + encoderDecoder);\n                if (encoderDecoder != null) {\n                    return listMethod + \"(\" + expression + \", \" + encoderDecoder + \")\";\n                }\n            }\n        } else if (type.isArray() != null) {\n            JType componentType = type.isArray().getComponentType();\n            \n            if (componentType.isArray() != null) {\n                error(\"Multi-dimensional arrays are not yet supported\");\n            }\n            \n            encoderDecoder = getEncoderDecoder(componentType, logger);\n            debug(\"type encoder for: \" + componentType + \" is \" + encoderDecoder);\n            if (encoderDecoder != null) {\n                if (encoderMethod.equals(\"encode\")) {\n                    return arrayMethod + \"(\" + expression + \", \" + encoderDecoder + \")\";\n                } else {\n                    return arrayMethod + \"(\" + expression + \", \" + encoderDecoder\n                            + \", new \" + componentType.getQualifiedSourceName()\n                            + \"[\" + JSON_ENCODER_DECODER_CLASS + \".getSize(\" + expression + \")])\";\n                }\n            }\n        }\n\n        error(\"Do not know how to encode/decode \" + type);\n        return null;\n    }\n\n    boolean isCollectionType(JClassType clazz) {\n        return clazz != null\n                && (clazz.isAssignableTo(SET_TYPE) || clazz.isAssignableTo(LIST_TYPE) || clazz.isAssignableTo(MAP_TYPE));\n    }\n\n    protected void error(String msg) throws UnableToCompleteException {\n        logger.log(ERROR, msg);\n        throw new UnableToCompleteException();\n    }\n\n    protected void warn(String msg) throws UnableToCompleteException {\n        logger.log(WARN, msg);\n        throw new UnableToCompleteException();\n    }\n\n    protected void info(String msg) throws UnableToCompleteException {\n        logger.log(INFO, msg);\n    }\n\n    protected void debug(String msg) throws UnableToCompleteException {\n        logger.log(DEBUG, msg);\n    }\n\n    protected void trace(String msg) throws UnableToCompleteException {\n        logger.log(TRACE, msg);\n    }\n\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport static org.fusesource.restygwt.rebind.BaseSourceCreator.DEBUG;\nimport static org.fusesource.restygwt.rebind.BaseSourceCreator.ERROR;\nimport static org.fusesource.restygwt.rebind.BaseSourceCreator.INFO;\nimport static org.fusesource.restygwt.rebind.BaseSourceCreator.TRACE;\nimport static org.fusesource.restygwt.rebind.BaseSourceCreator.WARN;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.codehaus.jackson.map.annotate.JsonDeserialize;\nimport org.fusesource.restygwt.client.AbstractJsonEncoderDecoder;\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\nimport org.fusesource.restygwt.client.ObjectEncoderDecoder;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JParameterizedType;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.xml.client.Document;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * \n *          Update : Add support for JsonDeserialize annotation for interfaces\n * @author <a href=\"http://wwww.ronanquillevere.fr\">Ronan Quillevere<\/a>\n */\npublic class JsonEncoderDecoderInstanceLocator {\n\n    public static final String JSON_ENCODER_DECODER_CLASS = AbstractJsonEncoderDecoder.class.getName();\n    public static final String JSON_CLASS = Json.class.getName();\n\n    public final JClassType STRING_TYPE;\n    public final JClassType JSON_VALUE_TYPE;\n    public final JClassType DOCUMENT_TYPE;\n    public final JClassType MAP_TYPE;\n    public final JClassType SET_TYPE;\n    public final JClassType LIST_TYPE;\n\n    public final HashMap<JType, String> builtInEncoderDecoders = new HashMap<JType, String>();\n\n    public final GeneratorContext context;\n    public final TreeLogger logger;\n\n    public JsonEncoderDecoderInstanceLocator(GeneratorContext context, TreeLogger logger)\n            throws UnableToCompleteException {\n        this.context = context;\n        this.logger = logger;\n\n        this.STRING_TYPE = find(String.class);\n        this.JSON_VALUE_TYPE = find(JSONValue.class);\n        this.DOCUMENT_TYPE = find(Document.class);\n        this.MAP_TYPE = find(Map.class);\n        this.SET_TYPE = find(Set.class);\n        this.LIST_TYPE = find(List.class);\n\n        builtInEncoderDecoders.put(JPrimitiveType.BOOLEAN, JSON_ENCODER_DECODER_CLASS + \".BOOLEAN\");\n        builtInEncoderDecoders.put(JPrimitiveType.BYTE, JSON_ENCODER_DECODER_CLASS + \".BYTE\");\n        builtInEncoderDecoders.put(JPrimitiveType.CHAR, JSON_ENCODER_DECODER_CLASS + \".CHAR\");\n        builtInEncoderDecoders.put(JPrimitiveType.SHORT, JSON_ENCODER_DECODER_CLASS + \".SHORT\");\n        builtInEncoderDecoders.put(JPrimitiveType.INT, JSON_ENCODER_DECODER_CLASS + \".INT\");\n        builtInEncoderDecoders.put(JPrimitiveType.LONG, JSON_ENCODER_DECODER_CLASS + \".LONG\");\n        builtInEncoderDecoders.put(JPrimitiveType.FLOAT, JSON_ENCODER_DECODER_CLASS + \".FLOAT\");\n        builtInEncoderDecoders.put(JPrimitiveType.DOUBLE, JSON_ENCODER_DECODER_CLASS + \".DOUBLE\");\n        builtInEncoderDecoders.put(find(Boolean.class), JSON_ENCODER_DECODER_CLASS + \".BOOLEAN\");\n        builtInEncoderDecoders.put(find(Byte.class), JSON_ENCODER_DECODER_CLASS + \".BYTE\");\n        builtInEncoderDecoders.put(find(Character.class), JSON_ENCODER_DECODER_CLASS + \".CHAR\");\n        builtInEncoderDecoders.put(find(Short.class), JSON_ENCODER_DECODER_CLASS + \".SHORT\");\n        builtInEncoderDecoders.put(find(Integer.class), JSON_ENCODER_DECODER_CLASS + \".INT\");\n        builtInEncoderDecoders.put(find(Long.class), JSON_ENCODER_DECODER_CLASS + \".LONG\");\n        builtInEncoderDecoders.put(find(Float.class), JSON_ENCODER_DECODER_CLASS + \".FLOAT\");\n        builtInEncoderDecoders.put(find(Double.class), JSON_ENCODER_DECODER_CLASS + \".DOUBLE\");\n        builtInEncoderDecoders.put(find(BigDecimal.class), JSON_ENCODER_DECODER_CLASS + \".BIG_DECIMAL\");\n        builtInEncoderDecoders.put(find(BigInteger.class), JSON_ENCODER_DECODER_CLASS + \".BIG_INTEGER\");\n\n        builtInEncoderDecoders.put(STRING_TYPE, JSON_ENCODER_DECODER_CLASS + \".STRING\");\n        builtInEncoderDecoders.put(DOCUMENT_TYPE, JSON_ENCODER_DECODER_CLASS + \".DOCUMENT\");\n        builtInEncoderDecoders.put(JSON_VALUE_TYPE, JSON_ENCODER_DECODER_CLASS + \".JSON_VALUE\");\n\n        builtInEncoderDecoders.put(find(Date.class), JSON_ENCODER_DECODER_CLASS + \".DATE\");\n        \n        builtInEncoderDecoders.put(find(Object.class), ObjectEncoderDecoder.class.getName() + \".INSTANCE\");\n\n    }\n\n    private JClassType find(Class<?> type) throws UnableToCompleteException {\n        return find(type.getName());\n    }\n\n    private JClassType find(String type) throws UnableToCompleteException {\n        return RestServiceGenerator.find(logger, context, type);\n    }\n\n    private String getEncoderDecoder(JType type, TreeLogger logger) throws UnableToCompleteException {\n        String rc = builtInEncoderDecoders.get(type);\n        if (rc == null) {\n            JClassType ct = type.isClass();\n            if (ct != null && !isCollectionType(ct)) {\n                return new JsonEncoderDecoderClassCreator(logger, context, ct).create() + \".INSTANCE\";\n            }\n            \n            ct = type.isInterface();\n            if (ct != null && (ct.findAnnotationInTypeHierarchy(JsonDeserialize.class) != null)){\n                return new JsonEncoderDecoderClassCreator(logger, context, ct).create() + \".INSTANCE\";\n            }\n        }\n        return rc;\n    }\n\n    public String encodeExpression(JType type, String expression, Style style) throws UnableToCompleteException {\n        return encodeDecodeExpression(type, expression, style, \"encode\", JSON_ENCODER_DECODER_CLASS + \".toJSON\", JSON_ENCODER_DECODER_CLASS + \".toJSON\", JSON_ENCODER_DECODER_CLASS\n                + \".toJSON\", JSON_ENCODER_DECODER_CLASS + \".toJSON\");\n    }\n\n    public String decodeExpression(JType type, String expression, Style style) throws UnableToCompleteException {\n        return encodeDecodeExpression(type, expression, style, \"decode\", JSON_ENCODER_DECODER_CLASS + \".toMap\", JSON_ENCODER_DECODER_CLASS + \".toSet\", JSON_ENCODER_DECODER_CLASS\n                + \".toList\", JSON_ENCODER_DECODER_CLASS + \".toArray\");\n    }\n\n    private String encodeDecodeExpression(JType type, String expression, Style style, String encoderMethod, String mapMethod, String setMethod, String listMethod, String arrayMethod)\n            throws UnableToCompleteException {\n\n        if (null != type.isEnum()) {\n            if (encoderMethod.equals(\"encode\")) {\n                return encodeDecodeExpression(STRING_TYPE, expression + \".name()\", style, encoderMethod, mapMethod, setMethod, listMethod, arrayMethod);\n            } else {\n                return type.getQualifiedSourceName() + \".valueOf(\" + encodeDecodeExpression(STRING_TYPE, expression, style, encoderMethod, mapMethod, setMethod, listMethod, arrayMethod) + \")\";\n            }\n        }\n\n        String encoderDecoder = getEncoderDecoder(type, logger);\n        if (encoderDecoder != null) {\n            return encoderDecoder + \".\" + encoderMethod + \"(\" + expression + \")\";\n        }\n\n        JClassType clazz = type.isClassOrInterface();\n\n        if (isCollectionType(clazz)) {\n            JParameterizedType parameterizedType = type.isParameterized();\n            if (parameterizedType == null || parameterizedType.getTypeArgs() == null) {\n                error(\"Collection types must be parameterized.\");\n            }\n            JClassType[] types = parameterizedType.getTypeArgs();\n\n            if (clazz.isAssignableTo(MAP_TYPE)) {\n                if (types.length != 2) {\n                    error(\"Map must define two and only two type parameters\");\n                }\n                if (isCollectionType(types[0])) {\n                    error(\"Map key can't be a collection\");\n                }\n                if (!builtInEncoderDecoders.containsKey(types[0])) {\n                    error(\"Map key can't be an object\");\n                }\n                String keyEncoderDecoder = getEncoderDecoder(types[0], logger);\n                encoderDecoder = getEncoderDecoder(types[1], logger);\n                if (encoderDecoder != null && keyEncoderDecoder != null) {\n                    return mapMethod + \"(\" + expression + \", \" + keyEncoderDecoder + \", \" + encoderDecoder + \", \"\n                            + JSON_CLASS + \".Style.\" + style.name() + \")\";\n                } else if (encoderDecoder != null) {\n                    return mapMethod + \"(\" + expression + \", \" + encoderDecoder + \", \" + JSON_CLASS + \".Style.\"\n                            + style.name() + \")\";\n                }\n            } else if (clazz.isAssignableTo(SET_TYPE)) {\n                if (types.length != 1) {\n                    error(\"Set must define one and only one type parameter\");\n                }\n                encoderDecoder = getEncoderDecoder(types[0], logger);\n                if (encoderDecoder != null) {\n                    return setMethod + \"(\" + expression + \", \" + encoderDecoder + \")\";\n                }\n            } else if (clazz.isAssignableTo(LIST_TYPE)) {\n                if (types.length != 1) {\n                    error(\"List must define one and only one type parameter\");\n                }\n                encoderDecoder = getEncoderDecoder(types[0], logger);\n                debug(\"type encoder for: \" + types[0] + \" is \" + encoderDecoder);\n                if (encoderDecoder != null) {\n                    return listMethod + \"(\" + expression + \", \" + encoderDecoder + \")\";\n                }\n            }\n        } else if (type.isArray() != null) {\n            JType componentType = type.isArray().getComponentType();\n            \n            if (componentType.isArray() != null) {\n                error(\"Multi-dimensional arrays are not yet supported\");\n            }\n            \n            encoderDecoder = getEncoderDecoder(componentType, logger);\n            debug(\"type encoder for: \" + componentType + \" is \" + encoderDecoder);\n            if (encoderDecoder != null) {\n                if (encoderMethod.equals(\"encode\")) {\n                    return arrayMethod + \"(\" + expression + \", \" + encoderDecoder + \")\";\n                } else {\n                    return arrayMethod + \"(\" + expression + \", \" + encoderDecoder\n                            + \", new \" + componentType.getQualifiedSourceName()\n                            + \"[\" + JSON_ENCODER_DECODER_CLASS + \".getSize(\" + expression + \")])\";\n                }\n            }\n        }\n\n        error(\"Do not know how to encode/decode \" + type);\n        return null;\n    }\n\n    boolean isCollectionType(JClassType clazz) {\n        return clazz != null\n                && (clazz.isAssignableTo(SET_TYPE) || clazz.isAssignableTo(LIST_TYPE) || clazz.isAssignableTo(MAP_TYPE));\n    }\n\n    protected void error(String msg) throws UnableToCompleteException {\n        logger.log(ERROR, msg);\n        throw new UnableToCompleteException();\n    }\n\n    protected void warn(String msg) throws UnableToCompleteException {\n        logger.log(WARN, msg);\n        throw new UnableToCompleteException();\n    }\n\n    protected void info(String msg) throws UnableToCompleteException {\n        logger.log(INFO, msg);\n    }\n\n    protected void debug(String msg) throws UnableToCompleteException {\n        logger.log(DEBUG, msg);\n    }\n\n    protected void trace(String msg) throws UnableToCompleteException {\n        logger.log(TRACE, msg);\n    }\n\n}\n","lineNo":125}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.codehaus.jackson.annotate.JsonCreator;\nimport org.codehaus.jackson.annotate.JsonIgnore;\nimport org.codehaus.jackson.annotate.JsonIgnoreProperties;\nimport org.codehaus.jackson.annotate.JsonProperty;\nimport org.codehaus.jackson.annotate.JsonSubTypes;\nimport org.codehaus.jackson.annotate.JsonTypeInfo;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.As;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.Id;\nimport org.codehaus.jackson.annotate.JsonTypeName;\nimport org.codehaus.jackson.map.annotate.JsonTypeIdResolver;\nimport org.codehaus.jackson.map.jsontype.TypeIdResolver;\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JConstructor;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JMethod;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.thirdparty.guava.common.collect.Lists;\nimport com.google.gwt.thirdparty.guava.common.collect.Maps;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * \n *         Updates: added getter & setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n * \n *         added polymorphic support\n * @author <a href=\"http://charliemason.info\">Charlie Mason<\/a>\n * \n */\n\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n\n    JsonEncoderDecoderInstanceLocator locator;\n\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n\tsuper(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n\tClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n\tcomposerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n\treturn composerFactory;\n    }\n\n    private static class Subtype {\n\tfinal String tag;\n\tfinal JClassType clazz;\n\n\tpublic Subtype(String tag, JClassType clazz) {\n\t    this.tag = tag;\n\t    this.clazz = clazz;\n\t}\n    }\n\n    private <T extends Annotation> T findAnnotation(JClassType clazz, Class<T> annotation) {\n\tif (clazz == null)\n\t    return null;\n\telse if (clazz.isAnnotationPresent(annotation))\n\t    return clazz.getAnnotation(annotation);\n\telse\n\t    return findAnnotation(clazz.getSuperclass(), annotation);\n    }\n\n    @Override\n    public void generate() throws UnableToCompleteException {\n        final List<Subtype> possibleTypes = Lists.newArrayList();\n        final JsonTypeInfo typeInfo = findAnnotation(source, JsonTypeInfo.class);\n        final boolean isLeaf = !source.isAnnotationPresent(JsonTypeInfo.class);\n        if (typeInfo != null) {\n            final JsonSubTypes jacksonSubTypes = findAnnotation(source, JsonSubTypes.class);\n            if (typeInfo.use() == Id.CLASS || typeInfo.use() == Id.MINIMAL_CLASS) {\n        \tif (jacksonSubTypes != null) {\n        \t    for (JsonSubTypes.Type type : jacksonSubTypes.value()) {\n        \t\tJClassType typeClass = find(type.value());\n        \t\tif (!isLeaf || source.equals(typeClass))\n        \t\t    possibleTypes.add(new Subtype(typeInfo.use() == Id.CLASS ? typeClass.getQualifiedSourceName() : typeClass.getSimpleSourceName(), typeClass));\n        \t    }\n        \t} else {\n        \t    error(\"@JsonSubTypes annotation missing for type: \" + source);\n        \t}\n            } else if (typeInfo.use() != Id.NONE) {\n        \tfinal JsonTypeIdResolver typeResolver = findAnnotation(source, JsonTypeIdResolver.class);\n        \tif (jacksonSubTypes != null) {\n        \t    for (JsonSubTypes.Type type : jacksonSubTypes.value()) {\n        \t\tif (type.name() != null && !type.name().isEmpty()) {\n        \t\t    JClassType typeClass = find(type.value());\n        \t\t    if (!isLeaf || source.equals(typeClass))\n        \t\t\tpossibleTypes.add(new Subtype(type.name(), typeClass));\n        \t\t} else {\n        \t\t    JsonTypeName nameAnnotation = type.value().getAnnotation(JsonTypeName.class);\n        \t\t    if (nameAnnotation == null || nameAnnotation.value() == null || nameAnnotation.value().isEmpty())\n        \t\t\terror(\"Cannot find @JsonTypeName annotation for type: \" + type.value());\n        \t\t    JClassType typeClass = find(type.value());\n        \t\t    if (!isLeaf || source.equals(typeClass))\n        \t\t\tpossibleTypes.add(new Subtype(nameAnnotation.value(), typeClass));\n        \t\t}\n        \t    }\n        \t    if (isLeaf && possibleTypes.size() == 0)\n        \t\terror(\"Could not find @JsonSubTypes entry for type: \" + source);\n        \t} else if (typeResolver != null) {\n        \t    Class<? extends TypeIdResolver> resolverClass = typeResolver.value();\n        \t    RestyJsonTypeIdResolver restyResolver;\n        \t    if (RestyJsonTypeIdResolver.class.isAssignableFrom(resolverClass)) {\n        \t\ttry {\n        \t\t    restyResolver = (RestyJsonTypeIdResolver) resolverClass.newInstance();\n        \t\t} catch (Exception e) {\n        \t\t    logger.log(ERROR, \"Could not acccess: \" + resolverClass, e);\n        \t\t    throw new UnableToCompleteException();\n        \t\t}\n        \t    } else {\n        \t\trestyResolver = getRestyResolverClassMap(context, logger).get(resolverClass);\n        \t\tif (restyResolver == null)\n        \t\t    error(\"Could not find RestyJsonTypeIdResolver for \" + resolverClass + \" did you forget to put <extend-configuration-property name=\\\"org.fusesource.restygwt.jsontypeidresolver\\\" value=\\\"<fully-qualified-class-implementing-RestyJsonTypeIdResolver>\\\"/> in your *.gwt.xml?\");\n    \n        \t    }\n    \n        \t    for (Map.Entry<String, Class<?>> entry : restyResolver.getIdClassMap().entrySet()) {\n        \t\tJClassType entryType = find(entry.getValue());\n        \t\tif (!isLeaf || source.equals(entryType))\n        \t\t    possibleTypes.add(new Subtype(entry.getKey(), entryType));\n        \t    }\n        \t    if (isLeaf && possibleTypes.size() == 0)\n        \t\terror(\"Could not find entry in \" + restyResolver.getClass().getName() + \" for type: \" + source);\n        \t} else {\n        \t    error(\"Cannot find required subtype resolution for type: \" + source);\n        \t}\n            } else {\n        \terror(\"Id.NONE not supported\");\n            }\n        } else {\n            possibleTypes.add(new Subtype(null, source));\n        }\n        locator = new JsonEncoderDecoderInstanceLocator(context, logger);\n    \n        JClassType sourceClazz = source.isClass();\n        if (sourceClazz == null) {\n            error(\"Type is not a class\");\n        }\n    \n    \n        if (sourceClazz.isAbstract()) {\n            if (typeInfo == null) {\n        \terror(\"Abstract classes must be annotated with JsonTypeInfo\");\n            }\n        }\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n        final String railsWrapperName = jsonAnnotation != null && jsonAnnotation.name().length() > 0 ? jsonAnnotation.name() : sourceClazz.getName().toLowerCase();\n    \n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n    \n        if (null != sourceClazz.isEnum()) {\n            p();\n            p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n            {\n        \tp(\"if( value==null ) {\").i(1);\n        \t{\n        \t    p(\"return com.google.gwt.json.client.JSONNull.getInstance();\").i(-1);\n        \t}\n        \tp(\"}\");\n        \tp(\"return new com.google.gwt.json.client.JSONString(value.name());\");\n            }\n            i(-1).p(\"}\");\n            p();\n            p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n            {\n        \tp(\"if( value == null || value.isNull()!=null ) {\").i(1);\n        \t{\n        \t    p(\"return null;\").i(-1);\n        \t}\n        \tp(\"}\");\n        \tp(\"com.google.gwt.json.client.JSONString str = value.isString();\");\n        \tp(\"if( null == str ) {\").i(1);\n        \t{\n        \t    p(\"throw new DecodingException(\\\"Expected a json string (for enum), but was given: \\\"+value);\").i(-1);\n        \t}\n        \tp(\"}\");\n        \tp(\"return Enum.valueOf(\" + source.getParameterizedQualifiedSourceName() + \".class, str.stringValue());\").i(-1);\n            }\n            p(\"}\");\n            p();\n            return;\n        }\n    \n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n        \tp(\"return null;\");\n            }\n            i(-1).p(\"}\");\n    \n            boolean returnWrapper = false; // if set, return rrc\n    \n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n            if (classStyle == Style.RAILS) {\n        \treturnWrapper = true;\n        \tp(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n        \tp(\"rrc.put(\\\"\" + railsWrapperName + \"\\\" , rc);\");\n            }\n    \n            for (Subtype possibleType : possibleTypes) {\n        \t// Try to find a constuctor that is annotated as creator\n        \tfinal JConstructor creator = findCreator(possibleType.clazz);\n        \t\n                List<JField> orderedFields = creator == null ? null : getOrderedFields(getFields(possibleType.clazz), creator);\n    \n        \tif (!isLeaf) {\n        \t    // Generate a decoder for each possible type\n        \t    p(\"if(value.getClass().getName().equals(\\\"\" + possibleType.clazz.getQualifiedBinaryName() + \"\\\"))\");\n        \t    p(\"{\");\n        \t}\n    \n        \tif (typeInfo != null) {\n        \t    switch (typeInfo.include()) {\n        \t    case PROPERTY:\n        \t\tp(\"com.google.gwt.json.client.JSONValue className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\");\");\n        \t\tp(\"if( className!=null ) { \").i(1);\n        \t\tp(\"rc.put(\\\"\" + typeInfo.property() + \"\\\", className);\");\n        \t\ti(-1).p(\"}\");\n        \t\tbreak;\n        \t    case WRAPPER_OBJECT:\n        \t\treturnWrapper = true;\n        \t\tp(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n        \t\tp(\"rrc.put(\\\"\" + possibleType.tag + \"\\\", rc);\");\n        \t\tbreak;\n        \t    case WRAPPER_ARRAY:\n        \t\treturnWrapper = true;\n        \t\tp(JSON_ARRAY_CLASS + \" rrc = new \" + JSON_ARRAY_CLASS + \"();\");\n        \t\tp(\"rrc.set(0, org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\"));\");\n        \t\tp(\"rrc.set(1, rc);\");\n        \t    }\n        \t}\n    \n        \tp(possibleType.clazz.getParameterizedQualifiedSourceName() + \" parseValue = (\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \")value;\");\n    \n        \tfor (final JField field : getFields(possibleType.clazz)) {\n    \n        \t    final String getterName = getGetterName(field);\n\n                boolean ignoreField = false;\n                if(possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null) {\n                    for(String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value()) {\n                        if(s.equals(field.getName())) {\n                            ignoreField = true;\n                            break;\n                        }\n                    }\n                }\n    \n        \t    // If can ignore some fields right off the back..\n        \t    // if there is a creator encode only final fields with JsonProperty annotation\n                if (ignoreField || getterName == null && (field.isStatic() || (field.isFinal() && !(creator != null && orderedFields.contains(field))) || field.isTransient() \n                        || field.isAnnotationPresent(JsonIgnore.class))) {\n                    continue;\n                }\n\n        \t    branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n        \t\tpublic Void execute() throws UnableToCompleteException {\n        \t\t    // TODO: try to get the field with a setter or\n        \t\t    // JSNI\n        \t\t    if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n    \n        \t\t\tJson jsonAnnotation = field.getAnnotation(Json.class);\n                    JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n    \n        \t\t\tString name = field.getName();\n        \t\t\tString jsonName = name;\n    \n        \t\t\tif (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n        \t\t\t    jsonName = jsonAnnotation.name();\n        \t\t\t}\n                    if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                        jsonName = jsonPropertyAnnotation.value();\n                    }\n    \n        \t\t\tString fieldExpr = \"parseValue.\" + name;\n        \t\t\tif (getterName != null) {\n        \t\t\t    fieldExpr = \"parseValue.\" + getterName + \"()\";\n        \t\t\t}\n    \n        \t\t\tStyle style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n        \t\t\tString expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n    \n        \t\t\tp(\"{\").i(1);\n        \t\t\t{\n        \t\t\t    if (null != field.getType().isEnum()) {\n        \t\t\t\tp(\"if(\" + fieldExpr + \" == null) {\").i(1);\n        \t\t\t\tp(\"rc.put(\" + wrap(jsonName) + \", null);\");\n        \t\t\t\ti(-1).p(\"} else {\").i(1);\n        \t\t\t    }\n    \n        \t\t\t    p(JSON_VALUE_CLASS + \" v=\" + expression + \";\");\n        \t\t\t    p(\"if( v!=null ) {\").i(1);\n        \t\t\t    {\n        \t\t\t\tp(\"rc.put(\" + wrap(jsonName) + \", v);\");\n        \t\t\t    }\n        \t\t\t    i(-1).p(\"}\");\n    \n        \t\t\t    if (null != field.getType().isEnum()) {\n        \t\t\t\ti(-1).p(\"}\");\n        \t\t\t    }\n    \n        \t\t\t}\n        \t\t\ti(-1).p(\"}\");\n    \n        \t\t    } else {\n        \t\t        logger.log(ERROR, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n        \t\t    }\n        \t\t    return null;\n        \t\t}\n        \t    });\n    \n        \t}\n    \n        \tif (returnWrapper) {\n        \t    p(\"return rrc;\");\n        \t} else {\n        \t    p(\"return rc;\");\n        \t}\n    \n        \tif (!isLeaf) {\n        \t    p(\"}\");\n        \t}\n            }\n    \n            if (!isLeaf) {\n        \t// Shouldn't get called\n        \tp(\"return null;\");\n            }\n        }\n        i(-1).p(\"}\");\n        p();\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n            {\n                p(\"return null;\").i(-1);\n            }\n            p(\"}\");\n            if (classStyle == Style.RAILS) {\n        \tp(JSON_OBJECT_CLASS + \" object = toObjectFromWrapper(value, \\\"\" + railsWrapperName + \"\\\");\");\n            } else if (typeInfo != null && typeInfo.include() == As.WRAPPER_ARRAY) {\n        \tp(JSON_ARRAY_CLASS + \" array = (\" + JSON_ARRAY_CLASS + \")value;\");\n        \tif (!isLeaf)\n        \t    p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(array.get(0));\");\n        \tp(JSON_OBJECT_CLASS + \" object = toObject(array.get(1));\");\n            } else {\n        \tp(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            }\n    \n            if (!isLeaf && typeInfo != null && typeInfo.include() == As.PROPERTY) {\n        \tp(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" + wrap(typeInfo.property()) + \"));\");\n            }\n    \n            for (Subtype possibleType : possibleTypes) {\n        \t// Try to find a constuctor that is annotated as creator\n        \tfinal JConstructor creator = findCreator(possibleType.clazz);\n        \tif (typeInfo != null) {\n        \t    if (typeInfo.include() == As.WRAPPER_OBJECT) {\n        \t\tif (!isLeaf) {\n        \t\t    p(\"if(object.containsKey(\\\"\" + possibleType.tag + \"\\\"))\");\n        \t\t    p(\"{\");\n        \t\t}\n        \t\tp(\"object = toObjectFromWrapper(value, \\\"\" + possibleType.tag + \"\\\");\");\n        \t    } else if (!isLeaf) {\n        \t\tp(\"if(sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n        \t\tp(\"{\");\n        \t    }\n        \t}\n    \n        \tList<JField> orderedFields = null;\n        \tif (creator != null) {\n        \t    p(\"// We found a creator so we use the annotated constructor\");\n        \t    p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"(\");\n        \t    i(1).p(\"// The arguments are placed in the order they appear within the annotated constructor\").i(-1);\n        \t    orderedFields = getOrderedFields(getFields(possibleType.clazz), creator);\n        \t    final JField lastField = orderedFields.get(orderedFields.size() - 1);\n        \t    for (final JField field : orderedFields) {\n        \t\tbranch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n        \t\t    public Void execute() throws UnableToCompleteException {\n        \t\t\tJson jsonAnnotation = field.getAnnotation(Json.class);\n        \t\t\tStyle style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n        \t\t\tString jsonName = field.getName();\n        \t\t\tif (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n        \t\t\t    jsonName = jsonAnnotation.name();\n        \t\t\t}\n        \t\t\tString objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n        \t\t\tString expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n        \t\t\tString defaultValue = field.getType().isPrimitive() == null ? \"null\": field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n        \t\t\ti(1).p(\"\" + (objectGetter + \" == null || \" + objectGetter + \" instanceof com.google.gwt.json.client.JSONNull ? \" + defaultValue + \" : \" + expression + ((field != lastField) ? \", \" : \"\"))).i(-1);\n        \t\t\t\n        \t\t\treturn null;\n        \t\t    }\n        \t\t});\n        \t    }\n        \t    p(\");\");\n        \t}\n        \t\n        \tif (orderedFields == null){\n        \t    p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"();\");\n        \t}\n        \t\n                for (final JField field : getFields(possibleType.clazz)) {\n\n                    boolean ignoreField = false;\n                    if(possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null) {\n                        for(String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value()) {\n                            if(s.equals(field.getName())) {\n                                ignoreField = true;\n                                break;\n                            }\n                        }\n                    }\n                    if(ignoreField) {\n                        continue;\n                    }\n\n        \t    if (orderedFields != null && orderedFields.contains(field)){\n        \t        continue;\n        \t    }\n    \n        \t\tfinal String setterName = getSetterName(field);\n    \n        \t\t// If can ignore some fields right off the back..\n        \t\tif (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient()) || \n        \t\t        field.isAnnotationPresent(JsonIgnore.class)) {\n        \t\t    continue;\n        \t\t}\n    \n        \t\tbranch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n        \t\t    public Void execute() throws UnableToCompleteException {\n    \n        \t\t\t// TODO: try to set the field with a setter\n        \t\t\t// or JSNI\n        \t\t\tif (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n    \n        \t\t\t    Json jsonAnnotation = field.getAnnotation(Json.class);\n        \t\t\t    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                        JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n                        \n                        String name = field.getName();\n                        String jsonName = name;\n        \n                        if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                            jsonName = jsonAnnotation.name();\n                        }\n                        if (jsonPropertyAnnotation != null && jsonPropertyAnnotation.value() != null && jsonPropertyAnnotation.value().length() > 0) {\n                            jsonName = jsonPropertyAnnotation.value();\n                        }\n         \n        \t\t\t    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n        \t\t\t    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n    \n                        String cast = field.getType().isPrimitive() == JPrimitiveType.SHORT ? \"(short) \" : \"\";\n        \t\t\t    p(\"if(\" + objectGetter + \" != null) {\").i(1);\n    \n        \t\t\t\tp(\"if(\" + objectGetter + \" instanceof com.google.gwt.json.client.JSONNull) {\").i(1);\n                        String defaultValue = field.getType().isPrimitive() == null ? \"null\": field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n                        \n        \t\t\t\tif (setterName != null) {\n                            p(\"rc.\" + setterName + \"(\" + cast + defaultValue + \");\");\n        \t\t\t\t} else {\n                            p(\"rc.\" + name + \"=\" + cast + defaultValue + \";\");\n        \t\t\t\t}\n    \n        \t\t\t\ti(-1).p(\"} else {\").i(1);\n        \t\t\t    \n        \t\t\t    if (setterName != null) {\n                            p(\"rc.\" + setterName + \"(\" + cast + expression + \");\");\n        \t\t\t    } else {\n                            p(\"rc.\" + name + \"=\" + cast + expression + \";\");\n        \t\t\t    }\n        \t\t\t    i(-1).p(\"}\");    \n        \t\t\t    i(-1).p(\"}\");    \n\n        \t\t\t} else {\n                        logger.log(ERROR, \"private field gets ignored: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n        \t\t\t}\n        \t\t\treturn null;\n        \t\t    }\n        \t\t});\n        \t}\n        \t\n        \tp(\"return rc;\");\n    \n        \tif (typeInfo != null && !isLeaf) {\n        \t    p(\"}\");\n        \t}\n            }\n    \n            if (typeInfo != null && !isLeaf) {\n        \tp(\"return null;\");\n            }\n            i(-1).p(\"}\");\n            p();\n        }\n    }\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> sTypeIdResolverMap = null;\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> getRestyResolverClassMap(GeneratorContext context, TreeLogger logger) throws UnableToCompleteException {\n\tif (sTypeIdResolverMap == null) {\n\t    try {\n\t\tMap<Class<?>, RestyJsonTypeIdResolver> map = Maps.newHashMap();\n\t\tList<String> values = context.getPropertyOracle().getConfigurationProperty(\"org.fusesource.restygwt.jsontypeidresolver\").getValues();\n\t\tfor (String value : values)\n\t\t    try {\n\t\t\tClass<?> clazz = Class.forName(value);\n\t\t\tRestyJsonTypeIdResolver resolver = (RestyJsonTypeIdResolver) clazz.newInstance();\n\t\t\tmap.put(resolver.getTypeIdResolverClass(), resolver);\n\t\t    } catch (Exception e) {\n\t\t\tlogger.log(WARN, \"Could not access class: \" + values.get(0), e);\n\t\t    }\n\t\t    sTypeIdResolverMap = map;\n\t    } catch (BadPropertyValueException e) {\n\t\tlogger.log(ERROR, \"Could not acccess property: RestyJsonTypeIdResolver\", e);\n\t\tthrow new UnableToCompleteException();\n\t    }\n\t}\n\treturn sTypeIdResolverMap;\n    }\n\n    private List<JField> getOrderedFields(List<JField> fields, JConstructor creator) throws UnableToCompleteException {\n\tList<JField> orderedFields = new ArrayList<JField>();\n\tfor (JParameter param : creator.getParameters()) {\n\t    JsonProperty prop = param.getAnnotation(JsonProperty.class);\n\t    if (prop != null) {\n\t\tfor (JField field : fields) {\n\t\t    if (field.getName().equals(prop.value())) {\n\t\t\torderedFields.add(field);\n\t\t    }\n\t\t}\n\t    } else {\n\t\terror(\"a constructor annotated with @JsonCreator requires that all paramaters are annotated with @JsonProperty.\");\n\t    }\n\t}\n\n\treturn orderedFields;\n    }\n\n    private JConstructor findCreator(JClassType sourceClazz) {\n\tfor (JConstructor constructor : sourceClazz.getConstructors()) {\n\t    if (constructor.getAnnotation(JsonCreator.class) != null) {\n\t\treturn constructor;\n\t    }\n\t}\n\n\treturn null;\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the setter for the specified field or null if a\n     *         setter can't be found.\n     */\n    private String getSetterName(JField field) {\n\tString fieldName = field.getName();\n\tfieldName = \"set\" + upperCaseFirstChar(fieldName);\n\tJClassType type = field.getEnclosingType();\n\tif (exists(type, field, fieldName, true)) {\n\t    return fieldName;\n\t} else {\n\t    return null;\n\t}\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the getter for the specified field or null if a\n     *         getter can't be found.\n     */\n    private String getGetterName(JField field) {\n\tString fieldName = field.getName();\n\tJType booleanType = null;\n\ttry {\n\t    booleanType = find(Boolean.class);\n\t} catch (UnableToCompleteException e) {\n\t    // do nothing\n\t}\n\tJClassType type = field.getEnclosingType();\n\tif (field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)) {\n\t    fieldName = \"is\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t    fieldName = \"has\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t}\n\tfieldName = \"get\" + upperCaseFirstChar(field.getName());\n\tif (exists(type, field, fieldName, false)) {\n\t    return fieldName;\n\t} else {\n\t    return null;\n\t}\n    }\n\n    private String upperCaseFirstChar(String in) {\n\tif (in.length() == 1) {\n\t    return in.toUpperCase();\n\t} else {\n\t    return in.substring(0, 1).toUpperCase() + in.substring(1);\n\t}\n    }\n\n    /**\n     * checks whether a getter or setter exists on the specified type or any of\n     * its super classes excluding Object.\n     * \n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {\n        if ( field instanceof DummyJField ){\n            return true;\n        }\n        \n\tJType[] args = null;\n\tif (isSetter) {\n\t    args = new JType[] { field.getType() };\n\t} else {\n\t    args = new JType[] {};\n\t}\n\n\tif (null != type.findMethod(fieldName, args)) {\n\t    return true;\n\t} else {\n\t    try {\n\t\tJType objectType = find(Object.class);\n\t\tJClassType superType = type.getSuperclass();\n\t\tif (!objectType.equals(superType)) {\n\t\t    return exists(superType, field, fieldName, isSetter);\n\t\t}\n\t    } catch (UnableToCompleteException e) {\n\t\t// do nothing\n\t    }\n\t}\n\treturn false;\n    }\n\n    /**\n     * Inspects the supplied type and all super classes up to but excluding\n     * Object and returns a list of all fields found in these classes.\n     * \n     * @param type\n     * @return\n     */\n    private List<JField> getFields(JClassType type) {\n        List<JField> allFields = getFields(new ArrayList<JField>(), type);\n        Map<String, JMethod> getters = new HashMap<String, JMethod>();\n        Map<String, JType> setters = new HashMap<String, JType>();\n        for( JMethod m: type.getInheritableMethods() ){\n            if( m.getName().startsWith(\"set\") && m.getParameterTypes().length == 1 && m.getReturnType() == JPrimitiveType.VOID){\n                setters.put( m.getName().replaceFirst(\"^set\", \"\"), m.getParameterTypes()[0] );\n            }\n            else if( m.getName().startsWith(\"get\") && m.getParameterTypes().length == 0 &&  m.getReturnType() != JPrimitiveType.VOID){\n                getters.put( m.getName().replaceFirst(\"^get\", \"\"), m );\n            }\n        }\n        for( Map.Entry<String, JMethod> entry: getters.entrySet() ){\n            if ( setters.containsKey( entry.getKey() ) && setters.get( entry.getKey() ).equals( entry.getValue().getReturnType() ) ) {\n                String name = entry.getKey().substring(0, 1).toLowerCase() + entry.getKey().substring(1);\n\n                boolean found = false;\n                for( JField f : allFields ){\n                    if( f.getName().equals( name ) ){\n                        found = true;\n                        break;\n                    }\n                }\n                JField f = type.getField( name );\n                if ( ! found && !( f != null && f.isAnnotationPresent( JsonIgnore.class ) ) ){\n                    DummyJField dummy = new DummyJField( name, entry.getValue().getReturnType() );\n                    if ( entry.getValue().isAnnotationPresent(JsonProperty.class) ) { \n                        dummy.setAnnotation( entry.getValue().getAnnotation(JsonProperty.class) );\n                    }\n                    allFields.add( dummy );\n                }\n            }\n        }\n        return allFields;\n    }\n\n    private List<JField> getFields(List<JField> allFields, JClassType type) {\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n            if (!field.isTransient() && !field.isAnnotationPresent(JsonIgnore.class)) {\n                allFields.add(field);\n            }\n        }\n        try {\n            JType objectType = find(Object.class);\n            if (!objectType.equals(type)) {\n                JClassType superType = type.getSuperclass();\n                return getFields(allFields, superType);\n            }\n        }\n        catch (UnableToCompleteException e) {\n\t    // do nothing\n        }\n        \n    \treturn allFields;\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.codehaus.jackson.annotate.JsonCreator;\nimport org.codehaus.jackson.annotate.JsonIgnore;\nimport org.codehaus.jackson.annotate.JsonIgnoreProperties;\nimport org.codehaus.jackson.annotate.JsonProperty;\nimport org.codehaus.jackson.annotate.JsonSubTypes;\nimport org.codehaus.jackson.annotate.JsonTypeInfo;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.As;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.Id;\nimport org.codehaus.jackson.annotate.JsonTypeName;\nimport org.codehaus.jackson.map.annotate.JsonTypeIdResolver;\nimport org.codehaus.jackson.map.jsontype.TypeIdResolver;\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport com.google.gwt.core.ext.BadPropertyValueException;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JConstructor;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.thirdparty.guava.common.collect.Lists;\nimport com.google.gwt.thirdparty.guava.common.collect.Maps;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * \n *         Updates: added getter & setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n * \n *         added polymorphic support\n * @author <a href=\"http://charliemason.info\">Charlie Mason<\/a>\n * \n */\n\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n\n    JsonEncoderDecoderInstanceLocator locator;\n\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n\tsuper(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n\tClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n\tcomposerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n\treturn composerFactory;\n    }\n\n    private static class Subtype {\n\tfinal String tag;\n\tfinal JClassType clazz;\n\n\tpublic Subtype(String tag, JClassType clazz) {\n\t    this.tag = tag;\n\t    this.clazz = clazz;\n\t}\n    }\n\n    private <T extends Annotation> T findAnnotation(JClassType clazz, Class<T> annotation) {\n\tif (clazz == null)\n\t    return null;\n\telse if (clazz.isAnnotationPresent(annotation))\n\t    return clazz.getAnnotation(annotation);\n\telse\n\t    return findAnnotation(clazz.getSuperclass(), annotation);\n    }\n\n    @Override\n    public void generate() throws UnableToCompleteException {\n        final List<Subtype> possibleTypes = Lists.newArrayList();\n        final JsonTypeInfo typeInfo = findAnnotation(source, JsonTypeInfo.class);\n        final boolean isLeaf = !source.isAnnotationPresent(JsonTypeInfo.class);\n        if (typeInfo != null) {\n            final JsonSubTypes jacksonSubTypes = findAnnotation(source, JsonSubTypes.class);\n            if (typeInfo.use() == Id.CLASS || typeInfo.use() == Id.MINIMAL_CLASS) {\n        \tif (jacksonSubTypes != null) {\n        \t    for (JsonSubTypes.Type type : jacksonSubTypes.value()) {\n        \t\tJClassType typeClass = find(type.value());\n        \t\tif (!isLeaf || source.equals(typeClass))\n        \t\t    possibleTypes.add(new Subtype(typeInfo.use() == Id.CLASS ? typeClass.getQualifiedSourceName() : typeClass.getSimpleSourceName(), typeClass));\n        \t    }\n        \t} else {\n        \t    error(\"@JsonSubTypes annotation missing for type: \" + source);\n        \t}\n            } else if (typeInfo.use() != Id.NONE) {\n        \tfinal JsonTypeIdResolver typeResolver = findAnnotation(source, JsonTypeIdResolver.class);\n        \tif (jacksonSubTypes != null) {\n        \t    for (JsonSubTypes.Type type : jacksonSubTypes.value()) {\n        \t\tif (type.name() != null && !type.name().isEmpty()) {\n        \t\t    JClassType typeClass = find(type.value());\n        \t\t    if (!isLeaf || source.equals(typeClass))\n        \t\t\tpossibleTypes.add(new Subtype(type.name(), typeClass));\n        \t\t} else {\n        \t\t    JsonTypeName nameAnnotation = type.value().getAnnotation(JsonTypeName.class);\n        \t\t    if (nameAnnotation == null || nameAnnotation.value() == null || nameAnnotation.value().isEmpty())\n        \t\t\terror(\"Cannot find @JsonTypeName annotation for type: \" + type.value());\n        \t\t    JClassType typeClass = find(type.value());\n        \t\t    if (!isLeaf || source.equals(typeClass))\n        \t\t\tpossibleTypes.add(new Subtype(nameAnnotation.value(), typeClass));\n        \t\t}\n        \t    }\n        \t    if (isLeaf && possibleTypes.size() == 0)\n        \t\terror(\"Could not find @JsonSubTypes entry for type: \" + source);\n        \t} else if (typeResolver != null) {\n        \t    Class<? extends TypeIdResolver> resolverClass = typeResolver.value();\n        \t    RestyJsonTypeIdResolver restyResolver;\n        \t    if (RestyJsonTypeIdResolver.class.isAssignableFrom(resolverClass)) {\n        \t\ttry {\n        \t\t    restyResolver = (RestyJsonTypeIdResolver) resolverClass.newInstance();\n        \t\t} catch (Exception e) {\n        \t\t    logger.log(ERROR, \"Could not acccess: \" + resolverClass, e);\n        \t\t    throw new UnableToCompleteException();\n        \t\t}\n        \t    } else {\n        \t\trestyResolver = getRestyResolverClassMap(context, logger).get(resolverClass);\n        \t\tif (restyResolver == null)\n        \t\t    error(\"Could not find RestyJsonTypeIdResolver for \" + resolverClass + \" did you forget to put <extend-configuration-property name=\\\"org.fusesource.restygwt.jsontypeidresolver\\\" value=\\\"<fully-qualified-class-implementing-RestyJsonTypeIdResolver>\\\"/> in your *.gwt.xml?\");\n    \n        \t    }\n    \n        \t    for (Map.Entry<String, Class<?>> entry : restyResolver.getIdClassMap().entrySet()) {\n        \t\tJClassType entryType = find(entry.getValue());\n        \t\tif (!isLeaf || source.equals(entryType))\n        \t\t    possibleTypes.add(new Subtype(entry.getKey(), entryType));\n        \t    }\n        \t    if (isLeaf && possibleTypes.size() == 0)\n        \t\terror(\"Could not find entry in \" + restyResolver.getClass().getName() + \" for type: \" + source);\n        \t} else {\n        \t    error(\"Cannot find required subtype resolution for type: \" + source);\n        \t}\n            } else {\n        \terror(\"Id.NONE not supported\");\n            }\n        } else {\n            possibleTypes.add(new Subtype(null, source));\n        }\n        locator = new JsonEncoderDecoderInstanceLocator(context, logger);\n    \n        JClassType sourceClazz = source.isClass();\n        if (sourceClazz == null) {\n            error(\"Type is not a class\");\n        }\n    \n    \n        if (sourceClazz.isAbstract()) {\n            if (typeInfo == null) {\n        \terror(\"Abstract classes must be annotated with JsonTypeInfo\");\n            }\n        }\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n        final String railsWrapperName = jsonAnnotation != null && jsonAnnotation.name().length() > 0 ? jsonAnnotation.name() : sourceClazz.getName().toLowerCase();\n    \n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n    \n        if (null != sourceClazz.isEnum()) {\n            p();\n            p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n            {\n        \tp(\"if( value==null ) {\").i(1);\n        \t{\n        \t    p(\"return com.google.gwt.json.client.JSONNull.getInstance();\").i(-1);\n        \t}\n        \tp(\"}\");\n        \tp(\"return new com.google.gwt.json.client.JSONString(value.name());\");\n            }\n            i(-1).p(\"}\");\n            p();\n            p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n            {\n        \tp(\"if( value == null || value.isNull()!=null ) {\").i(1);\n        \t{\n        \t    p(\"return null;\").i(-1);\n        \t}\n        \tp(\"}\");\n        \tp(\"com.google.gwt.json.client.JSONString str = value.isString();\");\n        \tp(\"if( null == str ) {\").i(1);\n        \t{\n        \t    p(\"throw new DecodingException(\\\"Expected a json string (for enum), but was given: \\\"+value);\").i(-1);\n        \t}\n        \tp(\"}\");\n        \tp(\"return Enum.valueOf(\" + source.getParameterizedQualifiedSourceName() + \".class, str.stringValue());\").i(-1);\n            }\n            p(\"}\");\n            p();\n            return;\n        }\n    \n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n        \tp(\"return null;\");\n            }\n            i(-1).p(\"}\");\n    \n            boolean returnWrapper = false; // if set, return rrc\n    \n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n            if (classStyle == Style.RAILS) {\n        \treturnWrapper = true;\n        \tp(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n        \tp(\"rrc.put(\\\"\" + railsWrapperName + \"\\\" , rc);\");\n            }\n    \n            for (Subtype possibleType : possibleTypes) {\n        \t// Try to find a constuctor that is annotated as creator\n        \tfinal JConstructor creator = findCreator(possibleType.clazz);\n        \t\n                List<JField> orderedFields = creator == null ? null : getOrderedFields(getFields(possibleType.clazz), creator);\n    \n        \tif (!isLeaf) {\n        \t    // Generate a decoder for each possible type\n        \t    p(\"if(value.getClass().getName().equals(\\\"\" + possibleType.clazz.getQualifiedBinaryName() + \"\\\"))\");\n        \t    p(\"{\");\n        \t}\n    \n        \tif (typeInfo != null) {\n        \t    switch (typeInfo.include()) {\n        \t    case PROPERTY:\n        \t\tp(\"com.google.gwt.json.client.JSONValue className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\");\");\n        \t\tp(\"if( className!=null ) { \").i(1);\n        \t\tp(\"rc.put(\\\"\" + typeInfo.property() + \"\\\", className);\");\n        \t\ti(-1).p(\"}\");\n        \t\tbreak;\n        \t    case WRAPPER_OBJECT:\n        \t\treturnWrapper = true;\n        \t\tp(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n        \t\tp(\"rrc.put(\\\"\" + possibleType.tag + \"\\\", rc);\");\n        \t\tbreak;\n        \t    case WRAPPER_ARRAY:\n        \t\treturnWrapper = true;\n        \t\tp(JSON_ARRAY_CLASS + \" rrc = new \" + JSON_ARRAY_CLASS + \"();\");\n        \t\tp(\"rrc.set(0, org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + possibleType.tag + \"\\\"));\");\n        \t\tp(\"rrc.set(1, rc);\");\n        \t    }\n        \t}\n    \n        \tp(possibleType.clazz.getParameterizedQualifiedSourceName() + \" parseValue = (\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \")value;\");\n    \n        \tfor (final JField field : getFields(possibleType.clazz)) {\n    \n        \t    final String getterName = getGetterName(field);\n\n                    boolean ignoreField = false;\n                    if(possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null) {\n                        for(String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value()) {\n\t\t\t    if(s.equals(field.getName())) {\n\t\t\t\tignoreField = true;\n\t\t\t\tbreak;\n\t\t\t    }\n                        }\n                    }\n    \n        \t    // If can ignore some fields right off the back..\n        \t    // if there is a creator encode only final fields with JsonProperty annotation\n                    if (ignoreField || getterName == null && (field.isStatic() || (field.isFinal() && !(creator != null && orderedFields.contains(field))) || field.isTransient() \n                            || field.isAnnotationPresent(JsonIgnore.class))) {\n                        continue;\n                    }\n    \n        \t    branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n        \t\tpublic Void execute() throws UnableToCompleteException {\n        \t\t    // TODO: try to get the field with a setter or\n        \t\t    // JSNI\n        \t\t    if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n    \n        \t\t\tJson jsonAnnotation = field.getAnnotation(Json.class);\n    \n        \t\t\tString name = field.getName();\n        \t\t\tString jsonName = name;\n    \n        \t\t\tif (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n        \t\t\t    jsonName = jsonAnnotation.name();\n        \t\t\t}\n    \n        \t\t\tString fieldExpr = \"parseValue.\" + name;\n        \t\t\tif (getterName != null) {\n        \t\t\t    fieldExpr = \"parseValue.\" + getterName + \"()\";\n        \t\t\t}\n    \n        \t\t\tStyle style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n        \t\t\tString expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n    \n        \t\t\tp(\"{\").i(1);\n        \t\t\t{\n        \t\t\t    if (null != field.getType().isEnum()) {\n        \t\t\t\tp(\"if(\" + fieldExpr + \" == null) {\").i(1);\n        \t\t\t\tp(\"rc.put(\" + wrap(name) + \", null);\");\n        \t\t\t\ti(-1).p(\"} else {\").i(1);\n        \t\t\t    }\n    \n        \t\t\t    p(JSON_VALUE_CLASS + \" v=\" + expression + \";\");\n        \t\t\t    p(\"if( v!=null ) {\").i(1);\n        \t\t\t    {\n        \t\t\t\tp(\"rc.put(\" + wrap(jsonName) + \", v);\");\n        \t\t\t    }\n        \t\t\t    i(-1).p(\"}\");\n    \n        \t\t\t    if (null != field.getType().isEnum()) {\n        \t\t\t\ti(-1).p(\"}\");\n        \t\t\t    }\n    \n        \t\t\t}\n        \t\t\ti(-1).p(\"}\");\n    \n        \t\t    } else {\n        \t\t\terror(\"field must not be private: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n        \t\t    }\n        \t\t    return null;\n        \t\t}\n        \t    });\n    \n        \t}\n    \n        \tif (returnWrapper) {\n        \t    p(\"return rrc;\");\n        \t} else {\n        \t    p(\"return rc;\");\n        \t}\n    \n        \tif (!isLeaf) {\n        \t    p(\"}\");\n        \t}\n            }\n    \n            if (!isLeaf) {\n        \t// Shouldn't get called\n        \tp(\"return null;\");\n            }\n        }\n        i(-1).p(\"}\");\n        p();\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n            {\n                p(\"return null;\").i(-1);\n            }\n            p(\"}\");\n            if (classStyle == Style.RAILS) {\n        \tp(JSON_OBJECT_CLASS + \" object = toObjectFromWrapper(value, \\\"\" + railsWrapperName + \"\\\");\");\n            } else if (typeInfo != null && typeInfo.include() == As.WRAPPER_ARRAY) {\n        \tp(JSON_ARRAY_CLASS + \" array = (\" + JSON_ARRAY_CLASS + \")value;\");\n        \tif (!isLeaf)\n        \t    p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(array.get(0));\");\n        \tp(JSON_OBJECT_CLASS + \" object = toObject(array.get(1));\");\n            } else {\n        \tp(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            }\n    \n            if (!isLeaf && typeInfo != null && typeInfo.include() == As.PROPERTY) {\n        \tp(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" + wrap(typeInfo.property()) + \"));\");\n            }\n    \n            for (Subtype possibleType : possibleTypes) {\n        \t// Try to find a constuctor that is annotated as creator\n        \tfinal JConstructor creator = findCreator(possibleType.clazz);\n        \tif (typeInfo != null) {\n        \t    if (typeInfo.include() == As.WRAPPER_OBJECT) {\n        \t\tif (!isLeaf) {\n        \t\t    p(\"if(object.containsKey(\\\"\" + possibleType.tag + \"\\\"))\");\n        \t\t    p(\"{\");\n        \t\t}\n        \t\tp(\"object = toObjectFromWrapper(value, \\\"\" + possibleType.tag + \"\\\");\");\n        \t    } else if (!isLeaf) {\n        \t\tp(\"if(sourceName.equals(\\\"\" + possibleType.tag + \"\\\"))\");\n        \t\tp(\"{\");\n        \t    }\n        \t}\n    \n        \tList<JField> orderedFields = null;\n        \tif (creator != null) {\n        \t    p(\"// We found a creator so we use the annotated constructor\");\n        \t    p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"(\");\n        \t    i(1).p(\"// The arguments are placed in the order they appear within the annotated constructor\").i(-1);\n        \t    orderedFields = getOrderedFields(getFields(possibleType.clazz), creator);\n        \t    final JField lastField = orderedFields.get(orderedFields.size() - 1);\n        \t    for (final JField field : orderedFields) {\n        \t\tbranch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n        \t\t    public Void execute() throws UnableToCompleteException {\n        \t\t\tJson jsonAnnotation = field.getAnnotation(Json.class);\n        \t\t\tStyle style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n        \t\t\tString jsonName = field.getName();\n        \t\t\tif (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n        \t\t\t    jsonName = jsonAnnotation.name();\n        \t\t\t}\n        \t\t\tString objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n        \t\t\tString expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n        \t\t\tString defaultValue = field.getType().isPrimitive() == null ? \"null\": field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n        \t\t\ti(1).p(\"\" + (objectGetter + \" == null || \" + objectGetter + \" instanceof com.google.gwt.json.client.JSONNull ? \" + defaultValue + \" : \" + expression + ((field != lastField) ? \", \" : \"\"))).i(-1);\n        \t\t\t\n        \t\t\treturn null;\n        \t\t    }\n        \t\t});\n        \t    }\n        \t    p(\");\");\n        \t}\n        \t\n        \tif (orderedFields == null){\n        \t    p(\"\" + possibleType.clazz.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.clazz.getParameterizedQualifiedSourceName() + \"();\");\n        \t}\n        \t\n                for (final JField field : getFields(possibleType.clazz)) {\n\n\t\t    boolean ignoreField = false;\n                    if(possibleType.clazz.getAnnotation(JsonIgnoreProperties.class) != null) {\n                        for(String s : possibleType.clazz.getAnnotation(JsonIgnoreProperties.class).value()) {\n\t\t\t    if(s.equals(field.getName())) {\n\t\t\t\tignoreField = true;\n\t\t\t\tbreak;\n\t\t\t    }\n                        }\n                    }\n                    if(ignoreField) {\n                        continue;\n                    }\n\n        \t    if (orderedFields != null && orderedFields.contains(field)){\n        \t        continue;\n        \t    }\n    \n        \t\tfinal String setterName = getSetterName(field);\n    \n        \t\t// If can ignore some fields right off the back..\n        \t\tif (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient()) || \n        \t\t        field.isAnnotationPresent(JsonIgnore.class)) {\n        \t\t    continue;\n        \t\t}\n    \n        \t\tbranch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n        \t\t    public Void execute() throws UnableToCompleteException {\n    \n        \t\t\t// TODO: try to set the field with a setter\n        \t\t\t// or JSNI\n        \t\t\tif (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n    \n        \t\t\t    Json jsonAnnotation = field.getAnnotation(Json.class);\n        \t\t\t    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n    \n        \t\t\t    String name = field.getName();\n        \t\t\t    String jsonName = field.getName();\n    \n        \t\t\t    if (jsonAnnotation != null && jsonAnnotation.name().length() > 0) {\n                            jsonName = jsonAnnotation.name();\n        \t\t\t    }\n    \n        \t\t\t    String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n        \t\t\t    String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n    \n                        String cast = field.getType().isPrimitive() == JPrimitiveType.SHORT ? \"(short) \" : \"\";\n        \t\t\t    p(\"if(\" + objectGetter + \" != null) {\").i(1);\n    \n        \t\t\t\tp(\"if(\" + objectGetter + \" instanceof com.google.gwt.json.client.JSONNull) {\").i(1);\n                        String defaultValue = field.getType().isPrimitive() == null ? \"null\": field.getType().isPrimitive().getUninitializedFieldExpression() + \"\";\n                        \n        \t\t\t\tif (setterName != null) {\n                            p(\"rc.\" + setterName + \"(\" + cast + defaultValue + \");\");\n        \t\t\t\t} else {\n                            p(\"rc.\" + name + \"=\" + cast + defaultValue + \";\");\n        \t\t\t\t}\n    \n        \t\t\t\ti(-1).p(\"} else {\").i(1);\n        \t\t\t    \n        \t\t\t    if (setterName != null) {\n                            p(\"rc.\" + setterName + \"(\" + cast + expression + \");\");\n        \t\t\t    } else {\n                            p(\"rc.\" + name + \"=\" + cast + expression + \";\");\n        \t\t\t    }\n        \t\t\t    i(-1).p(\"}\");    \n        \t\t\t    i(-1).p(\"}\");    \n\n        \t\t\t} else {\n        \t\t\t    error(\"field must not be private.\");\n        \t\t\t}\n        \t\t\treturn null;\n        \t\t    }\n        \t\t});\n        \t}\n        \t\n        \tp(\"return rc;\");\n    \n        \tif (typeInfo != null && !isLeaf) {\n        \t    p(\"}\");\n        \t}\n            }\n    \n            if (typeInfo != null && !isLeaf) {\n        \tp(\"return null;\");\n            }\n            i(-1).p(\"}\");\n            p();\n        }\n    }\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> sTypeIdResolverMap = null;\n\n    private static Map<Class<?>, RestyJsonTypeIdResolver> getRestyResolverClassMap(GeneratorContext context, TreeLogger logger) throws UnableToCompleteException {\n\tif (sTypeIdResolverMap == null) {\n\t    try {\n\t\tMap<Class<?>, RestyJsonTypeIdResolver> map = Maps.newHashMap();\n\t\tList<String> values = context.getPropertyOracle().getConfigurationProperty(\"org.fusesource.restygwt.jsontypeidresolver\").getValues();\n\t\tfor (String value : values)\n\t\t    try {\n\t\t\tClass<?> clazz = Class.forName(value);\n\t\t\tRestyJsonTypeIdResolver resolver = (RestyJsonTypeIdResolver) clazz.newInstance();\n\t\t\tmap.put(resolver.getTypeIdResolverClass(), resolver);\n\t\t    } catch (Exception e) {\n\t\t\tlogger.log(WARN, \"Could not access class: \" + values.get(0), e);\n\t\t    }\n\t\t    sTypeIdResolverMap = map;\n\t    } catch (BadPropertyValueException e) {\n\t\tlogger.log(ERROR, \"Could not acccess property: RestyJsonTypeIdResolver\", e);\n\t\tthrow new UnableToCompleteException();\n\t    }\n\t}\n\treturn sTypeIdResolverMap;\n    }\n\n    private List<JField> getOrderedFields(List<JField> fields, JConstructor creator) throws UnableToCompleteException {\n\tList<JField> orderedFields = new ArrayList<JField>();\n\tfor (JParameter param : creator.getParameters()) {\n\t    JsonProperty prop = param.getAnnotation(JsonProperty.class);\n\t    if (prop != null) {\n\t\tfor (JField field : fields) {\n\t\t    if (field.getName().equals(prop.value())) {\n\t\t\torderedFields.add(field);\n\t\t    }\n\t\t}\n\t    } else {\n\t\terror(\"a constructor annotated with @JsonCreator requires that all paramaters are annotated with @JsonProperty.\");\n\t    }\n\t}\n\n\treturn orderedFields;\n    }\n\n    private JConstructor findCreator(JClassType sourceClazz) {\n\tfor (JConstructor constructor : sourceClazz.getConstructors()) {\n\t    if (constructor.getAnnotation(JsonCreator.class) != null) {\n\t\treturn constructor;\n\t    }\n\t}\n\n\treturn null;\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the setter for the specified field or null if a\n     *         setter can't be found.\n     */\n    private String getSetterName(JField field) {\n\tString fieldName = field.getName();\n\tfieldName = \"set\" + upperCaseFirstChar(fieldName);\n\tJClassType type = field.getEnclosingType();\n\tif (exists(type, field, fieldName, true)) {\n\t    return fieldName;\n\t} else {\n\t    return null;\n\t}\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the getter for the specified field or null if a\n     *         getter can't be found.\n     */\n    private String getGetterName(JField field) {\n\tString fieldName = field.getName();\n\tJType booleanType = null;\n\ttry {\n\t    booleanType = find(Boolean.class);\n\t} catch (UnableToCompleteException e) {\n\t    // do nothing\n\t}\n\tJClassType type = field.getEnclosingType();\n\tif (field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)) {\n\t    fieldName = \"is\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t    fieldName = \"has\" + upperCaseFirstChar(field.getName());\n\t    if (exists(type, field, fieldName, false)) {\n\t\treturn fieldName;\n\t    }\n\t}\n\tfieldName = \"get\" + upperCaseFirstChar(field.getName());\n\tif (exists(type, field, fieldName, false)) {\n\t    return fieldName;\n\t} else {\n\t    return null;\n\t}\n    }\n\n    private String upperCaseFirstChar(String in) {\n\tif (in.length() == 1) {\n\t    return in.toUpperCase();\n\t} else {\n\t    return in.substring(0, 1).toUpperCase() + in.substring(1);\n\t}\n    }\n\n    /**\n     * checks whether a getter or setter exists on the specified type or any of\n     * its super classes excluding Object.\n     * \n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {\n\tJType[] args = null;\n\tif (isSetter) {\n\t    args = new JType[] { field.getType() };\n\t} else {\n\t    args = new JType[] {};\n\t}\n\n\tif (null != type.findMethod(fieldName, args)) {\n\t    return true;\n\t} else {\n\t    try {\n\t\tJType objectType = find(Object.class);\n\t\tJClassType superType = type.getSuperclass();\n\t\tif (!objectType.equals(superType)) {\n\t\t    return exists(superType, field, fieldName, isSetter);\n\t\t}\n\t    } catch (UnableToCompleteException e) {\n\t\t// do nothing\n\t    }\n\t}\n\treturn false;\n    }\n\n    /**\n     * Inspects the supplied type and all super classes up to but excluding\n     * Object and returns a list of all fields found in these classes.\n     * \n     * @param type\n     * @return\n     */\n    private List<JField> getFields(JClassType type) {\n    return getFields(new ArrayList<JField>(), type);\n    }\n\n    private List<JField> getFields(List<JField> allFields, JClassType type) {\n\tJField[] fields = type.getFields();\n\tfor (JField field : fields) {\n\t    if (!field.isTransient() && !field.isAnnotationPresent(JsonIgnore.class)) {\n\t        allFields.add(field);\n\t    }\n\t}\n\ttry {\n\t    JType objectType = find(Object.class);\n\t    if (!objectType.equals(type)) {\n\t        JClassType superType = type.getSuperclass();\n\t\treturn getFields(allFields, superType);\n\t    }\n\t} catch (UnableToCompleteException e) {\n\t    // do nothing\n\t}\n\treturn allFields;\n    }\n}\n","lineNo":493}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.client;\n\nimport com.google.gwt.i18n.client.DateTimeFormat;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONBoolean;\nimport com.google.gwt.json.client.JSONException;\nimport com.google.gwt.json.client.JSONNull;\nimport com.google.gwt.json.client.JSONNumber;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONString;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.xml.client.Document;\nimport com.google.gwt.xml.client.XMLParser;\n\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\nabstract public class AbstractJsonEncoderDecoder<T> implements JsonEncoderDecoder<T> {\n\n    // /////////////////////////////////////////////////////////////////\n    // Built in encoders for the native types.\n    // /////////////////////////////////////////////////////////////////\n    public static final AbstractJsonEncoderDecoder<Boolean> BOOLEAN = new AbstractJsonEncoderDecoder<Boolean>() {\n\n        public Boolean decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONBoolean bool = value.isBoolean();\n            if (bool == null) {\n                throw new DecodingException(\"Expected a json boolean, but was given: \" + value);\n            }\n            return bool.booleanValue();\n        }\n\n        public JSONValue encode(Boolean value) throws EncodingException {\n            return (value == null) ? getNullType() : JSONBoolean.getInstance(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Character> CHAR = new AbstractJsonEncoderDecoder<Character>() {\n\n        public Character decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (char) toDouble(value);\n        }\n\n        public JSONValue encode(Character value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Byte> BYTE = new AbstractJsonEncoderDecoder<Byte>() {\n\n        public Byte decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (byte) toDouble(value);\n\n        }\n\n        public JSONValue encode(Byte value) throws EncodingException {\n            if (value == null) {\n                return null;\n            }\n            return new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Short> SHORT = new AbstractJsonEncoderDecoder<Short>() {\n\n        public Short decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (short) toDouble(value);\n        }\n\n        public JSONValue encode(Short value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Integer> INT = new AbstractJsonEncoderDecoder<Integer>() {\n\n        public Integer decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (int) toDouble(value);\n        }\n\n        public JSONValue encode(Integer value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Long> LONG = new AbstractJsonEncoderDecoder<Long>() {\n\n        public Long decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (long) toDouble(value);\n        }\n\n        public JSONValue encode(Long value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Float> FLOAT = new AbstractJsonEncoderDecoder<Float>() {\n\n        public Float decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (float) toDouble(value);\n        }\n\n        public JSONValue encode(Float value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Double> DOUBLE = new AbstractJsonEncoderDecoder<Double>() {\n\n        public Double decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return toDouble(value);\n        }\n\n        public JSONValue encode(Double value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<String> STRING = new AbstractJsonEncoderDecoder<String>() {\n\n        public String decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONString str = value.isString();\n            if (str == null) {\n                if (value.isBoolean() != null || value.isNumber() != null) {\n                    return value.toString();\n                } else {\n                    throw new DecodingException(\"Expected a json string, but was given: \" + value);\n                }\n            }\n            return str.stringValue();\n        }\n\n        public JSONValue encode(String value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<BigDecimal> BIG_DECIMAL = new AbstractJsonEncoderDecoder<BigDecimal>() {\n\n        public BigDecimal decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return toBigDecimal(value);\n        }\n\n        public JSONValue encode(BigDecimal value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value.toString());\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<BigInteger> BIG_INTEGER = new AbstractJsonEncoderDecoder<BigInteger>() {\n\n        public BigInteger decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONNumber number = value.isNumber();\n            if (number == null) {\n                JSONString str = value.isString();\n                if (str == null) {\n                    throw new DecodingException(\"Expected a json number r string, but was given: \" + value);\n                }\n\n                // Doing a straight conversion from string to BigInteger will\n                // not work for large values\n                // So we convert to BigDecimal first and then convert it to\n                // BigInteger.\n                return new BigDecimal(str.stringValue()).toBigInteger();\n            }\n\n            // Doing a straight conversion from string to BigInteger will not\n            // work for large values\n            // So we convert to BigDecimal first and then convert it to\n            // BigInteger.\n            return new BigDecimal(value.toString()).toBigInteger();\n        }\n\n        public JSONValue encode(BigInteger value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value.toString());\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Document> DOCUMENT = new AbstractJsonEncoderDecoder<Document>() {\n\n        public Document decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONString str = value.isString();\n            if (str == null) {\n                throw new DecodingException(\"Expected a json string, but was given: \" + value);\n            }\n            return XMLParser.parse(str.stringValue());\n        }\n\n        public JSONValue encode(Document value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value.toString());\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<JSONValue> JSON_VALUE = new AbstractJsonEncoderDecoder<JSONValue>() {\n\n        public JSONValue decode(JSONValue value) throws DecodingException {\n            return value;\n        }\n\n        public JSONValue encode(JSONValue value) throws EncodingException {\n            return value;\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Date> DATE = new AbstractJsonEncoderDecoder<Date>() {\n\n        public Date decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            String format = Defaults.getDateFormat();\n            if (format == null) {\n                JSONNumber num = value.isNumber();\n                if (num == null) {\n                    throw new DecodingException(\"Expected a json number, but was given: \" + value);\n                }\n                return new Date((long) num.doubleValue());\n            } else {\n                JSONString str = value.isString();\n                if (str == null) {\n                    throw new DecodingException(\"Expected a json string, but was given: \" + value);\n                }\n                return DateTimeFormat.getFormat(format).parse(str.stringValue());\n            }\n        }\n\n        public JSONValue encode(Date value) throws EncodingException {\n            if (value == null) {\n                return getNullType();\n            }\n            String format = Defaults.getDateFormat();\n            if (format == null) {\n                return new JSONNumber(value.getTime());\n            } else {\n                return new JSONString(DateTimeFormat.getFormat(format).format(value));\n            }\n        }\n    };\n\n    // /////////////////////////////////////////////////////////////////\n    // Helper Methods.\n    // /////////////////////////////////////////////////////////////////\n\n    static public BigDecimal toBigDecimal(JSONValue value) {\n        JSONNumber number = value.isNumber();\n        if (number == null) {\n            throw new DecodingException(\"Expected a json number, but was given: \" + value);\n        }\n        return new BigDecimal(value.toString());\n    }\n\n    static public double toDouble(JSONValue value) {\n        JSONNumber number = value.isNumber();\n        if (number == null) {\n            JSONString val = value.isString();\n            if (val != null){\n                try {\n                    return Double.parseDouble(val.stringValue());\n                }\n                catch(NumberFormatException e){\n                    // just through exception below\n                }\n            }\n            throw new DecodingException(\"Expected a json number, but was given: \" + value);\n        }\n        return number.doubleValue();\n    }\n\n    static public JSONObject toObject(JSONValue value) {\n        JSONObject object = value.isObject();\n        if (object == null) {\n            throw new DecodingException(\"Expected a json object, but was given: \" + object);\n        }\n        return object;\n    }\n\n    static public JSONObject toObjectFromWrapper(JSONValue value, String name) {\n        JSONObject object = value.isObject();\n        if (object == null) {\n            throw new DecodingException(\"Expected a json object, but was given: \" + object);\n        }\n        JSONValue result = object.get(name);\n        if (result == null) {\n            // no wrapper found but that is possible within the hierarchy\n            return toObject(value);\n        }\n        return toObject(result);\n    }\n    \n    static private JSONArray asArray(JSONValue value) {\n        JSONArray array = value.isArray();\n        if (array == null) {\n            throw new DecodingException(\"Expected a json array, but was given: \" + value);\n        }\n        return array;\n    }\n\n    static public <Type> List<Type> toList(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        ArrayList<Type> rc = new ArrayList<Type>(array.size());\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            rc.add(encoder.decode(array.get(i)));\n        }\n        return rc;\n    }\n\n    static public <Type> Type[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder, Type[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public short[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Short> encoder, short[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public long[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Long> encoder, long[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public int[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Integer> encoder, int[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public float[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Float> encoder, float[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public double[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Double> encoder, double[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public byte[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Byte> encoder, byte[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public char[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Character> encoder, char[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public boolean[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Boolean> encoder, boolean[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public int getSize(JSONValue value) {\n        if (value == null || value.isNull() != null) {\n            return 0;\n        }\n        JSONArray array = asArray(value);\n        return array.size();\n    }\n\n    static public <Type> Set<Type> toSet(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        HashSet<Type> rc = new HashSet<Type>(array.size() * 2);\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            rc.add(encoder.decode(array.get(i)));\n        }\n        return rc;\n    }\n\n    static public <Type> Map<String, Type> toMap(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder, Style style) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n\n            HashMap<String, Type> rc = new HashMap<String, Type>(object.size() * 2);\n            for (String key : object.keySet()) {\n                rc.put(key, encoder.decode(object.get(key)));\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n            value = object.get(\"entry\");\n            if (value == null) {\n                throw new DecodingException(\"Expected an entry array not found\");\n            }\n            JSONArray entries = value.isArray();\n            if (entries == null) {\n                throw new DecodingException(\"Expected an entry array, but was given: \" + value);\n            }\n\n            HashMap<String, Type> rc = new HashMap<String, Type>(object.size() * 2);\n            for (int i = 0; i < entries.size(); i++) {\n                JSONObject entry = entries.get(i).isObject();\n                if (entry == null)\n                    throw new DecodingException(\"Expected an entry object, but was given: \" + value);\n                JSONValue key = entry.get(\"key\");\n                if (key == null)\n                    throw new DecodingException(\"Expected an entry key field not found\");\n                JSONString k = key.isString();\n                if (k == null)\n                    throw new DecodingException(\"Expected an entry key to be a string, but was given: \" + value);\n\n                rc.put(k.stringValue(), encoder.decode(entry.get(\"value\")));\n            }\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet suppored: \" + style.name());\n        }\n    }\n\n    static public <KeyType, ValueType> Map<KeyType, ValueType> toMap(JSONValue value,\n            AbstractJsonEncoderDecoder<KeyType> keyEncoder, AbstractJsonEncoderDecoder<ValueType> valueEncoder,\n            Style style) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n\n            HashMap<KeyType, ValueType> rc = new HashMap<KeyType, ValueType>(object.size() * 2);\n            for (String key : object.keySet()) {\n                try{\n                    rc.put(keyEncoder.decode(JSONParser.parseStrict(key)), valueEncoder.decode(object.get(key)));\n                }\n                catch(JSONException e){\n                    // that can happen for generic key types like Object and then a String key gets passed in\n                    rc.put(keyEncoder.decode(JSONParser.parseStrict(\"\\\"\" + key + \"\\\"\")), valueEncoder.decode(object.get(key)));                    \n                }\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n            value = object.get(\"entry\");\n            if (value == null) {\n                throw new DecodingException(\"Expected an entry array not found\");\n            }\n            JSONArray entries = value.isArray();\n            if (entries == null) {\n                throw new DecodingException(\"Expected an entry array, but was given: \" + value);\n            }\n\n            HashMap<KeyType, ValueType> rc = new HashMap<KeyType, ValueType>(object.size() * 2);\n            for (int i = 0; i < entries.size(); i++) {\n                JSONObject entry = entries.get(i).isObject();\n                if (entry == null)\n                    throw new DecodingException(\"Expected an entry object, but was given: \" + value);\n                JSONValue key = entry.get(\"key\");\n                if (key == null)\n                    throw new DecodingException(\"Expected an entry key field not found\");\n                JSONString k = key.isString();\n                if (k == null)\n                    throw new DecodingException(\"Expected an entry key to be a string, but was given: \" + value);\n                rc.put(keyEncoder.decode(JSONParser.parseStrict(k.stringValue())), valueEncoder.decode(entry.get(\"value\")));\n            }\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet supported: \" + style.name());\n        }\n    }\n\n    // TODO(sbeutel): new map method to handle other key values than String\n    static public <KeyType, ValueType> JSONValue toJSON(Map<KeyType, ValueType> value,\n            AbstractJsonEncoderDecoder<KeyType> keyEncoder, AbstractJsonEncoderDecoder<ValueType> valueEncoder,\n            Style style) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject rc = new JSONObject();\n            \n            for (Entry<KeyType, ValueType> t : value.entrySet()) {\n                //TODO find a way to check only once\n                JSONValue k = keyEncoder.encode(t.getKey());\n                if (k.isString() != null) {\n                    rc.put(k.isString().stringValue(), valueEncoder.encode(t.getValue()));\n                }\n                else {\n                    rc.put(k.toString(), valueEncoder.encode(t.getValue()));\n                }\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject rc = new JSONObject();\n            JSONArray entries = new JSONArray();\n            int i = 0;\n            for (Entry<KeyType, ValueType> t : value.entrySet()) {\n                JSONObject entry = new JSONObject();\n                //TODO find a way to check only once\n                JSONValue k = keyEncoder.encode(t.getKey());\n                if (k.isString() != null) {\n                    entry.put(\"key\", k);\n                }\n                else {\n                    entry.put(\"key\", new JSONString(k.toString()));\n                }\n                entry.put(\"value\", valueEncoder.encode(t.getValue()));\n                entries.set(i++, entry);\n            }\n            rc.put(\"entry\", entries);\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet supported: \" + style.name());\n        }\n    }\n\n    static public <Type> JSONValue toJSON(Map<String, Type> value, AbstractJsonEncoderDecoder<Type> encoder, Style style) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject rc = new JSONObject();\n            for (Entry<String, Type> t : value.entrySet()) {\n                rc.put(t.getKey(), encoder.encode(t.getValue()));\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject rc = new JSONObject();\n            JSONArray entries = new JSONArray();\n            int i = 0;\n            for (Entry<String, Type> t : value.entrySet()) {\n                JSONObject entry = new JSONObject();\n                entry.put(\"key\", new JSONString(t.getKey()));\n                entry.put(\"value\", encoder.encode(t.getValue()));\n                entries.set(i++, entry);\n            }\n            rc.put(\"entry\", entries);\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet suppored: \" + style.name());\n        }\n    }\n\n    static public <Type> JSONValue toJSON(Collection<Type> value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (Type t : value) {\n            rc.set(i++, encoder.encode(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(Type[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (Type t : value) {\n            rc.set(i++, encoder.encode(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(short[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (short t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(int[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (int t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(long[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (long t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(float[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (float t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n    \n    static public <Type> JSONValue toJSON(double[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (double t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(boolean[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (boolean t : value) {\n            rc.set(i++, JSONBoolean.getInstance(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(char[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (char t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(byte[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (byte t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static private JSONNull getNullType() {\n        return (Defaults.doesIgnoreJsonNulls()) ? null : JSONNull.getInstance();\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.client;\n\nimport com.google.gwt.i18n.client.DateTimeFormat;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONBoolean;\nimport com.google.gwt.json.client.JSONException;\nimport com.google.gwt.json.client.JSONNull;\nimport com.google.gwt.json.client.JSONNumber;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONString;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.xml.client.Document;\nimport com.google.gwt.xml.client.XMLParser;\n\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\nabstract public class AbstractJsonEncoderDecoder<T> implements JsonEncoderDecoder<T> {\n\n    // /////////////////////////////////////////////////////////////////\n    // Built in encoders for the native types.\n    // /////////////////////////////////////////////////////////////////\n    public static final AbstractJsonEncoderDecoder<Boolean> BOOLEAN = new AbstractJsonEncoderDecoder<Boolean>() {\n\n        public Boolean decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONBoolean bool = value.isBoolean();\n            if (bool == null) {\n                throw new DecodingException(\"Expected a json boolean, but was given: \" + value);\n            }\n            return bool.booleanValue();\n        }\n\n        public JSONValue encode(Boolean value) throws EncodingException {\n            return (value == null) ? getNullType() : JSONBoolean.getInstance(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Character> CHAR = new AbstractJsonEncoderDecoder<Character>() {\n\n        public Character decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (char) toDouble(value);\n        }\n\n        public JSONValue encode(Character value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Byte> BYTE = new AbstractJsonEncoderDecoder<Byte>() {\n\n        public Byte decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (byte) toDouble(value);\n\n        }\n\n        public JSONValue encode(Byte value) throws EncodingException {\n            if (value == null) {\n                return null;\n            }\n            return new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Short> SHORT = new AbstractJsonEncoderDecoder<Short>() {\n\n        public Short decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (short) toDouble(value);\n        }\n\n        public JSONValue encode(Short value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Integer> INT = new AbstractJsonEncoderDecoder<Integer>() {\n\n        public Integer decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (int) toDouble(value);\n        }\n\n        public JSONValue encode(Integer value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Long> LONG = new AbstractJsonEncoderDecoder<Long>() {\n\n        public Long decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (long) toDouble(value);\n        }\n\n        public JSONValue encode(Long value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Float> FLOAT = new AbstractJsonEncoderDecoder<Float>() {\n\n        public Float decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (float) toDouble(value);\n        }\n\n        public JSONValue encode(Float value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Double> DOUBLE = new AbstractJsonEncoderDecoder<Double>() {\n\n        public Double decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return toDouble(value);\n        }\n\n        public JSONValue encode(Double value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<String> STRING = new AbstractJsonEncoderDecoder<String>() {\n\n        public String decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONString str = value.isString();\n            if (str == null) {\n                if (value.isBoolean() != null || value.isNumber() != null) {\n                    return value.toString();\n                } else {\n                    throw new DecodingException(\"Expected a json string, but was given: \" + value);\n                }\n            }\n            return str.stringValue();\n        }\n\n        public JSONValue encode(String value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<BigDecimal> BIG_DECIMAL = new AbstractJsonEncoderDecoder<BigDecimal>() {\n\n        public BigDecimal decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return toBigDecimal(value);\n        }\n\n        public JSONValue encode(BigDecimal value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value.toString());\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<BigInteger> BIG_INTEGER = new AbstractJsonEncoderDecoder<BigInteger>() {\n\n        public BigInteger decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONNumber number = value.isNumber();\n            if (number == null) {\n                JSONString str = value.isString();\n                if (str == null) {\n                    throw new DecodingException(\"Expected a json number r string, but was given: \" + value);\n                }\n\n                // Doing a straight conversion from string to BigInteger will\n                // not work for large values\n                // So we convert to BigDecimal first and then convert it to\n                // BigInteger.\n                return new BigDecimal(str.stringValue()).toBigInteger();\n            }\n\n            // Doing a straight conversion from string to BigInteger will not\n            // work for large values\n            // So we convert to BigDecimal first and then convert it to\n            // BigInteger.\n            return new BigDecimal(value.toString()).toBigInteger();\n        }\n\n        public JSONValue encode(BigInteger value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value.toString());\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Document> DOCUMENT = new AbstractJsonEncoderDecoder<Document>() {\n\n        public Document decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONString str = value.isString();\n            if (str == null) {\n                throw new DecodingException(\"Expected a json string, but was given: \" + value);\n            }\n            return XMLParser.parse(str.stringValue());\n        }\n\n        public JSONValue encode(Document value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value.toString());\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<JSONValue> JSON_VALUE = new AbstractJsonEncoderDecoder<JSONValue>() {\n\n        public JSONValue decode(JSONValue value) throws DecodingException {\n            return value;\n        }\n\n        public JSONValue encode(JSONValue value) throws EncodingException {\n            return value;\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Date> DATE = new AbstractJsonEncoderDecoder<Date>() {\n\n        public Date decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            String format = Defaults.getDateFormat();\n            if (format == null) {\n                JSONNumber num = value.isNumber();\n                if (num == null) {\n                    throw new DecodingException(\"Expected a json number, but was given: \" + value);\n                }\n                return new Date((long) num.doubleValue());\n            } else {\n                JSONString str = value.isString();\n                if (str == null) {\n                    throw new DecodingException(\"Expected a json string, but was given: \" + value);\n                }\n                return DateTimeFormat.getFormat(format).parse(str.stringValue());\n            }\n        }\n\n        public JSONValue encode(Date value) throws EncodingException {\n            if (value == null) {\n                return getNullType();\n            }\n            String format = Defaults.getDateFormat();\n            if (format == null) {\n                return new JSONNumber(value.getTime());\n            } else {\n                return new JSONString(DateTimeFormat.getFormat(format).format(value));\n            }\n        }\n    };\n\n    // /////////////////////////////////////////////////////////////////\n    // Helper Methods.\n    // /////////////////////////////////////////////////////////////////\n\n    static public BigDecimal toBigDecimal(JSONValue value) {\n        JSONNumber number = value.isNumber();\n        if (number == null) {\n            throw new DecodingException(\"Expected a json number, but was given: \" + value);\n        }\n        return new BigDecimal(value.toString());\n    }\n\n    static public double toDouble(JSONValue value) {\n        JSONNumber number = value.isNumber();\n        if (number == null) {\n            JSONString val = value.isString();\n            if (val != null){\n                try {\n                    return Double.parseDouble(val.stringValue());\n                }\n                catch(NumberFormatException e){\n                    // just through exception below\n                }\n            }\n            throw new DecodingException(\"Expected a json number, but was given: \" + value);\n        }\n        return number.doubleValue();\n    }\n\n    static public JSONObject toObject(JSONValue value) {\n        JSONObject object = value.isObject();\n        if (object == null) {\n            throw new DecodingException(\"Expected a json object, but was given: \" + object);\n        }\n        return object;\n    }\n\n    static public JSONObject toObjectFromWrapper(JSONValue value, String name) {\n        JSONObject object = value.isObject();\n        if (object == null) {\n            throw new DecodingException(\"Expected a json object, but was given: \" + object);\n        }\n        JSONValue result = object.get(name);\n        if (result == null) {\n            // no wrapper found but that is possible within the hierarchy\n            return toObject(value);\n        }\n        return toObject(result);\n    }\n    \n    static private JSONArray asArray(JSONValue value) {\n        JSONArray array = value.isArray();\n        if (array == null) {\n            throw new DecodingException(\"Expected a json array, but was given: \" + value);\n        }\n        return array;\n    }\n\n    static public <Type> List<Type> toList(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        ArrayList<Type> rc = new ArrayList<Type>(array.size());\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            rc.add(encoder.decode(array.get(i)));\n        }\n        return rc;\n    }\n\n    static public <Type> Type[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder, Type[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public short[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Short> encoder, short[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public long[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Long> encoder, long[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public int[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Integer> encoder, int[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public float[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Float> encoder, float[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public double[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Double> encoder, double[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public byte[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Byte> encoder, byte[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public char[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Character> encoder, char[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public boolean[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Boolean> encoder, boolean[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public int getSize(JSONValue value) {\n        if (value == null || value.isNull() != null) {\n            return 0;\n        }\n        JSONArray array = asArray(value);\n        return array.size();\n    }\n\n    static public <Type> Set<Type> toSet(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        HashSet<Type> rc = new HashSet<Type>(array.size() * 2);\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            rc.add(encoder.decode(array.get(i)));\n        }\n        return rc;\n    }\n\n    static public <Type> Map<String, Type> toMap(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder, Style style) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n\n            HashMap<String, Type> rc = new HashMap<String, Type>(object.size() * 2);\n            for (String key : object.keySet()) {\n                rc.put(key, encoder.decode(object.get(key)));\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n            value = object.get(\"entry\");\n            if (value == null) {\n                throw new DecodingException(\"Expected an entry array not found\");\n            }\n            JSONArray entries = value.isArray();\n            if (entries == null) {\n                throw new DecodingException(\"Expected an entry array, but was given: \" + value);\n            }\n\n            HashMap<String, Type> rc = new HashMap<String, Type>(object.size() * 2);\n            for (int i = 0; i < entries.size(); i++) {\n                JSONObject entry = entries.get(i).isObject();\n                if (entry == null)\n                    throw new DecodingException(\"Expected an entry object, but was given: \" + value);\n                JSONValue key = entry.get(\"key\");\n                if (key == null)\n                    throw new DecodingException(\"Expected an entry key field not found\");\n                JSONString k = key.isString();\n                if (k == null)\n                    throw new DecodingException(\"Expected an entry key to be a string, but was given: \" + value);\n\n                rc.put(k.stringValue(), encoder.decode(entry.get(\"value\")));\n            }\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet suppored: \" + style.name());\n        }\n    }\n\n    static public <KeyType, ValueType> Map<KeyType, ValueType> toMap(JSONValue value,\n            AbstractJsonEncoderDecoder<KeyType> keyEncoder, AbstractJsonEncoderDecoder<ValueType> valueEncoder,\n            Style style) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n\n            HashMap<KeyType, ValueType> rc = new HashMap<KeyType, ValueType>(object.size() * 2);\n            for (String key : object.keySet()) {\n                try{\n                    rc.put(keyEncoder.decode(JSONParser.parseStrict(key)), valueEncoder.decode(object.get(key)));\n                }\n                catch(JSONException e){\n                    // that can happen for generic key types like Object and then a String key gets passed in\n                    rc.put(keyEncoder.decode(JSONParser.parseStrict(\"\\\"\" + key + \"\\\"\")), valueEncoder.decode(object.get(key)));                    \n                }\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n            value = object.get(\"entry\");\n            if (value == null) {\n                throw new DecodingException(\"Expected an entry array not found\");\n            }\n            JSONArray entries = value.isArray();\n            if (entries == null) {\n                throw new DecodingException(\"Expected an entry array, but was given: \" + value);\n            }\n\n            HashMap<KeyType, ValueType> rc = new HashMap<KeyType, ValueType>(object.size() * 2);\n            for (int i = 0; i < entries.size(); i++) {\n                JSONObject entry = entries.get(i).isObject();\n                if (entry == null)\n                    throw new DecodingException(\"Expected an entry object, but was given: \" + value);\n                JSONValue key = entry.get(\"key\");\n                if (key == null)\n                    throw new DecodingException(\"Expected an entry key field not found\");\n                JSONString k = key.isString();\n                if (k == null)\n                    throw new DecodingException(\"Expected an entry key to be a string, but was given: \" + value);\n                rc.put(keyEncoder.decode(JSONParser.parseStrict(k.stringValue())), valueEncoder.decode(entry.get(\"value\")));\n            }\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet supported: \" + style.name());\n        }\n    }\n\n    // TODO(sbeutel): new map method to handle other key values than String\n    static public <KeyType, ValueType> JSONValue toJSON(Map<KeyType, ValueType> value,\n            AbstractJsonEncoderDecoder<KeyType> keyEncoder, AbstractJsonEncoderDecoder<ValueType> valueEncoder,\n            Style style) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject rc = new JSONObject();\n            for (Entry<KeyType, ValueType> t : value.entrySet()) {\n                rc.put(keyEncoder.encode(t.getKey()).toString(), valueEncoder.encode(t.getValue()));\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject rc = new JSONObject();\n            JSONArray entries = new JSONArray();\n            int i = 0;\n            for (Entry<KeyType, ValueType> t : value.entrySet()) {\n                JSONObject entry = new JSONObject();\n                entry.put(\"key\", new JSONString(keyEncoder.encode(t.getKey()).toString()));\n                entry.put(\"value\", valueEncoder.encode(t.getValue()));\n                entries.set(i++, entry);\n            }\n            rc.put(\"entry\", entries);\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet supported: \" + style.name());\n        }\n    }\n\n    static public <Type> JSONValue toJSON(Map<String, Type> value, AbstractJsonEncoderDecoder<Type> encoder, Style style) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject rc = new JSONObject();\n            for (Entry<String, Type> t : value.entrySet()) {\n                rc.put(t.getKey(), encoder.encode(t.getValue()));\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject rc = new JSONObject();\n            JSONArray entries = new JSONArray();\n            int i = 0;\n            for (Entry<String, Type> t : value.entrySet()) {\n                JSONObject entry = new JSONObject();\n                entry.put(\"key\", new JSONString(t.getKey()));\n                entry.put(\"value\", encoder.encode(t.getValue()));\n                entries.set(i++, entry);\n            }\n            rc.put(\"entry\", entries);\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet suppored: \" + style.name());\n        }\n    }\n\n    static public <Type> JSONValue toJSON(Collection<Type> value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (Type t : value) {\n            rc.set(i++, encoder.encode(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(Type[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (Type t : value) {\n            rc.set(i++, encoder.encode(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(short[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (short t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(int[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (int t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(long[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (long t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(float[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (float t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n    \n    static public <Type> JSONValue toJSON(double[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (double t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(boolean[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (boolean t : value) {\n            rc.set(i++, JSONBoolean.getInstance(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(char[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (char t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(byte[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (byte t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static private JSONNull getNullType() {\n        return (Defaults.doesIgnoreJsonNulls()) ? null : JSONNull.getInstance();\n    }\n}\n","lineNo":651}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.client;\n\nimport com.google.gwt.i18n.client.DateTimeFormat;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONBoolean;\nimport com.google.gwt.json.client.JSONException;\nimport com.google.gwt.json.client.JSONNull;\nimport com.google.gwt.json.client.JSONNumber;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONString;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.xml.client.Document;\nimport com.google.gwt.xml.client.XMLParser;\n\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\nabstract public class AbstractJsonEncoderDecoder<T> implements JsonEncoderDecoder<T> {\n\n    // /////////////////////////////////////////////////////////////////\n    // Built in encoders for the native types.\n    // /////////////////////////////////////////////////////////////////\n    public static final AbstractJsonEncoderDecoder<Boolean> BOOLEAN = new AbstractJsonEncoderDecoder<Boolean>() {\n\n        public Boolean decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONBoolean bool = value.isBoolean();\n            if (bool == null) {\n                throw new DecodingException(\"Expected a json boolean, but was given: \" + value);\n            }\n            return bool.booleanValue();\n        }\n\n        public JSONValue encode(Boolean value) throws EncodingException {\n            return (value == null) ? getNullType() : JSONBoolean.getInstance(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Character> CHAR = new AbstractJsonEncoderDecoder<Character>() {\n\n        public Character decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (char) toDouble(value);\n        }\n\n        public JSONValue encode(Character value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Byte> BYTE = new AbstractJsonEncoderDecoder<Byte>() {\n\n        public Byte decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (byte) toDouble(value);\n\n        }\n\n        public JSONValue encode(Byte value) throws EncodingException {\n            if (value == null) {\n                return null;\n            }\n            return new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Short> SHORT = new AbstractJsonEncoderDecoder<Short>() {\n\n        public Short decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (short) toDouble(value);\n        }\n\n        public JSONValue encode(Short value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Integer> INT = new AbstractJsonEncoderDecoder<Integer>() {\n\n        public Integer decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (int) toDouble(value);\n        }\n\n        public JSONValue encode(Integer value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Long> LONG = new AbstractJsonEncoderDecoder<Long>() {\n\n        public Long decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (long) toDouble(value);\n        }\n\n        public JSONValue encode(Long value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Float> FLOAT = new AbstractJsonEncoderDecoder<Float>() {\n\n        public Float decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (float) toDouble(value);\n        }\n\n        public JSONValue encode(Float value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Double> DOUBLE = new AbstractJsonEncoderDecoder<Double>() {\n\n        public Double decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return toDouble(value);\n        }\n\n        public JSONValue encode(Double value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<String> STRING = new AbstractJsonEncoderDecoder<String>() {\n\n        public String decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONString str = value.isString();\n            if (str == null) {\n                if (value.isBoolean() != null || value.isNumber() != null) {\n                    return value.toString();\n                } else {\n                    throw new DecodingException(\"Expected a json string, but was given: \" + value);\n                }\n            }\n            return str.stringValue();\n        }\n\n        public JSONValue encode(String value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<BigDecimal> BIG_DECIMAL = new AbstractJsonEncoderDecoder<BigDecimal>() {\n\n        public BigDecimal decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return toBigDecimal(value);\n        }\n\n        public JSONValue encode(BigDecimal value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value.toString());\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<BigInteger> BIG_INTEGER = new AbstractJsonEncoderDecoder<BigInteger>() {\n\n        public BigInteger decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONNumber number = value.isNumber();\n            if (number == null) {\n                JSONString str = value.isString();\n                if (str == null) {\n                    throw new DecodingException(\"Expected a json number r string, but was given: \" + value);\n                }\n\n                // Doing a straight conversion from string to BigInteger will\n                // not work for large values\n                // So we convert to BigDecimal first and then convert it to\n                // BigInteger.\n                return new BigDecimal(str.stringValue()).toBigInteger();\n            }\n\n            // Doing a straight conversion from string to BigInteger will not\n            // work for large values\n            // So we convert to BigDecimal first and then convert it to\n            // BigInteger.\n            return new BigDecimal(value.toString()).toBigInteger();\n        }\n\n        public JSONValue encode(BigInteger value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value.toString());\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Document> DOCUMENT = new AbstractJsonEncoderDecoder<Document>() {\n\n        public Document decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONString str = value.isString();\n            if (str == null) {\n                throw new DecodingException(\"Expected a json string, but was given: \" + value);\n            }\n            return XMLParser.parse(str.stringValue());\n        }\n\n        public JSONValue encode(Document value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value.toString());\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<JSONValue> JSON_VALUE = new AbstractJsonEncoderDecoder<JSONValue>() {\n\n        public JSONValue decode(JSONValue value) throws DecodingException {\n            return value;\n        }\n\n        public JSONValue encode(JSONValue value) throws EncodingException {\n            return value;\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Date> DATE = new AbstractJsonEncoderDecoder<Date>() {\n\n        public Date decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            String format = Defaults.getDateFormat();\n            if (format == null) {\n                JSONNumber num = value.isNumber();\n                if (num == null) {\n                    throw new DecodingException(\"Expected a json number, but was given: \" + value);\n                }\n                return new Date((long) num.doubleValue());\n            } else {\n                JSONString str = value.isString();\n                if (str == null) {\n                    throw new DecodingException(\"Expected a json string, but was given: \" + value);\n                }\n                return DateTimeFormat.getFormat(format).parse(str.stringValue());\n            }\n        }\n\n        public JSONValue encode(Date value) throws EncodingException {\n            if (value == null) {\n                return getNullType();\n            }\n            String format = Defaults.getDateFormat();\n            if (format == null) {\n                return new JSONNumber(value.getTime());\n            } else {\n                return new JSONString(DateTimeFormat.getFormat(format).format(value));\n            }\n        }\n    };\n\n    // /////////////////////////////////////////////////////////////////\n    // Helper Methods.\n    // /////////////////////////////////////////////////////////////////\n\n    static public BigDecimal toBigDecimal(JSONValue value) {\n        JSONNumber number = value.isNumber();\n        if (number == null) {\n            throw new DecodingException(\"Expected a json number, but was given: \" + value);\n        }\n        return new BigDecimal(value.toString());\n    }\n\n    static public double toDouble(JSONValue value) {\n        JSONNumber number = value.isNumber();\n        if (number == null) {\n            JSONString val = value.isString();\n            if (val != null){\n                try {\n                    return Double.parseDouble(val.stringValue());\n                }\n                catch(NumberFormatException e){\n                    // just through exception below\n                }\n            }\n            throw new DecodingException(\"Expected a json number, but was given: \" + value);\n        }\n        return number.doubleValue();\n    }\n\n    static public JSONObject toObject(JSONValue value) {\n        JSONObject object = value.isObject();\n        if (object == null) {\n            throw new DecodingException(\"Expected a json object, but was given: \" + object);\n        }\n        return object;\n    }\n\n    static public JSONObject toObjectFromWrapper(JSONValue value, String name) {\n        JSONObject object = value.isObject();\n        if (object == null) {\n            throw new DecodingException(\"Expected a json object, but was given: \" + object);\n        }\n        JSONValue result = object.get(name);\n        if (result == null) {\n            // no wrapper found but that is possible within the hierarchy\n            return toObject(value);\n        }\n        return toObject(result);\n    }\n    \n    static private JSONArray asArray(JSONValue value) {\n        JSONArray array = value.isArray();\n        if (array == null) {\n            throw new DecodingException(\"Expected a json array, but was given: \" + value);\n        }\n        return array;\n    }\n\n    static public <Type> List<Type> toList(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        ArrayList<Type> rc = new ArrayList<Type>(array.size());\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            rc.add(encoder.decode(array.get(i)));\n        }\n        return rc;\n    }\n\n    static public <Type> Type[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder, Type[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public short[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Short> encoder, short[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public long[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Long> encoder, long[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public int[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Integer> encoder, int[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public float[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Float> encoder, float[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public double[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Double> encoder, double[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public byte[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Byte> encoder, byte[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public char[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Character> encoder, char[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public boolean[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Boolean> encoder, boolean[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public int getSize(JSONValue value) {\n        if (value == null || value.isNull() != null) {\n            return 0;\n        }\n        JSONArray array = asArray(value);\n        return array.size();\n    }\n\n    static public <Type> Set<Type> toSet(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        HashSet<Type> rc = new HashSet<Type>(array.size() * 2);\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            rc.add(encoder.decode(array.get(i)));\n        }\n        return rc;\n    }\n\n    static public <Type> Map<String, Type> toMap(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder, Style style) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n\n            HashMap<String, Type> rc = new HashMap<String, Type>(object.size() * 2);\n            for (String key : object.keySet()) {\n                rc.put(key, encoder.decode(object.get(key)));\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n            value = object.get(\"entry\");\n            if (value == null) {\n                throw new DecodingException(\"Expected an entry array not found\");\n            }\n            JSONArray entries = value.isArray();\n            if (entries == null) {\n                throw new DecodingException(\"Expected an entry array, but was given: \" + value);\n            }\n\n            HashMap<String, Type> rc = new HashMap<String, Type>(object.size() * 2);\n            for (int i = 0; i < entries.size(); i++) {\n                JSONObject entry = entries.get(i).isObject();\n                if (entry == null)\n                    throw new DecodingException(\"Expected an entry object, but was given: \" + value);\n                JSONValue key = entry.get(\"key\");\n                if (key == null)\n                    throw new DecodingException(\"Expected an entry key field not found\");\n                JSONString k = key.isString();\n                if (k == null)\n                    throw new DecodingException(\"Expected an entry key to be a string, but was given: \" + value);\n\n                rc.put(k.stringValue(), encoder.decode(entry.get(\"value\")));\n            }\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet suppored: \" + style.name());\n        }\n    }\n\n    static public <KeyType, ValueType> Map<KeyType, ValueType> toMap(JSONValue value,\n            AbstractJsonEncoderDecoder<KeyType> keyEncoder, AbstractJsonEncoderDecoder<ValueType> valueEncoder,\n            Style style) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n\n            HashMap<KeyType, ValueType> rc = new HashMap<KeyType, ValueType>(object.size() * 2);\n            for (String key : object.keySet()) {\n                try{\n                    rc.put(keyEncoder.decode(JSONParser.parseStrict(key)), valueEncoder.decode(object.get(key)));\n                }\n                catch(JSONException e){\n                    // that can happen for generic key types like Object and then a String key gets passed in\n                    rc.put(keyEncoder.decode(JSONParser.parseStrict(\"\\\"\" + key + \"\\\"\")), valueEncoder.decode(object.get(key)));                    \n                }\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n            value = object.get(\"entry\");\n            if (value == null) {\n                throw new DecodingException(\"Expected an entry array not found\");\n            }\n            JSONArray entries = value.isArray();\n            if (entries == null) {\n                throw new DecodingException(\"Expected an entry array, but was given: \" + value);\n            }\n\n            HashMap<KeyType, ValueType> rc = new HashMap<KeyType, ValueType>(object.size() * 2);\n            for (int i = 0; i < entries.size(); i++) {\n                JSONObject entry = entries.get(i).isObject();\n                if (entry == null)\n                    throw new DecodingException(\"Expected an entry object, but was given: \" + value);\n                JSONValue key = entry.get(\"key\");\n                if (key == null)\n                    throw new DecodingException(\"Expected an entry key field not found\");\n                JSONString k = key.isString();\n                if (k == null)\n                    throw new DecodingException(\"Expected an entry key to be a string, but was given: \" + value);\n                rc.put(keyEncoder.decode(JSONParser.parseStrict(k.stringValue())), valueEncoder.decode(entry.get(\"value\")));\n            }\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet supported: \" + style.name());\n        }\n    }\n\n    // TODO(sbeutel): new map method to handle other key values than String\n    static public <KeyType, ValueType> JSONValue toJSON(Map<KeyType, ValueType> value,\n            AbstractJsonEncoderDecoder<KeyType> keyEncoder, AbstractJsonEncoderDecoder<ValueType> valueEncoder,\n            Style style) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject rc = new JSONObject();\n            \n            for (Entry<KeyType, ValueType> t : value.entrySet()) {\n                //TODO find a way to check only once\n                JSONValue k = keyEncoder.encode(t.getKey());\n                if (k.isString() != null) {\n                    rc.put(k.isString().stringValue(), valueEncoder.encode(t.getValue()));\n                }\n                else {\n                    rc.put(k.toString(), valueEncoder.encode(t.getValue()));\n                }\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject rc = new JSONObject();\n            JSONArray entries = new JSONArray();\n            int i = 0;\n            for (Entry<KeyType, ValueType> t : value.entrySet()) {\n                JSONObject entry = new JSONObject();\n                //TODO find a way to check only once\n                JSONValue k = keyEncoder.encode(t.getKey());\n                if (k.isString() != null) {\n                    entry.put(\"key\", k);\n                }\n                else {\n                    entry.put(\"key\", new JSONString(k.toString()));\n                }\n                entry.put(\"value\", valueEncoder.encode(t.getValue()));\n                entries.set(i++, entry);\n            }\n            rc.put(\"entry\", entries);\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet supported: \" + style.name());\n        }\n    }\n\n    static public <Type> JSONValue toJSON(Map<String, Type> value, AbstractJsonEncoderDecoder<Type> encoder, Style style) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject rc = new JSONObject();\n            for (Entry<String, Type> t : value.entrySet()) {\n                rc.put(t.getKey(), encoder.encode(t.getValue()));\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject rc = new JSONObject();\n            JSONArray entries = new JSONArray();\n            int i = 0;\n            for (Entry<String, Type> t : value.entrySet()) {\n                JSONObject entry = new JSONObject();\n                entry.put(\"key\", new JSONString(t.getKey()));\n                entry.put(\"value\", encoder.encode(t.getValue()));\n                entries.set(i++, entry);\n            }\n            rc.put(\"entry\", entries);\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet suppored: \" + style.name());\n        }\n    }\n\n    static public <Type> JSONValue toJSON(Collection<Type> value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (Type t : value) {\n            rc.set(i++, encoder.encode(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(Type[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (Type t : value) {\n            rc.set(i++, encoder.encode(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(short[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (short t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(int[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (int t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(long[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (long t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(float[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (float t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n    \n    static public <Type> JSONValue toJSON(double[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (double t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(boolean[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (boolean t : value) {\n            rc.set(i++, JSONBoolean.getInstance(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(char[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (char t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(byte[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (byte t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static private JSONNull getNullType() {\n        return (Defaults.doesIgnoreJsonNulls()) ? null : JSONNull.getInstance();\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.client;\n\nimport com.google.gwt.i18n.client.DateTimeFormat;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONBoolean;\nimport com.google.gwt.json.client.JSONException;\nimport com.google.gwt.json.client.JSONNull;\nimport com.google.gwt.json.client.JSONNumber;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONString;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.xml.client.Document;\nimport com.google.gwt.xml.client.XMLParser;\n\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\nabstract public class AbstractJsonEncoderDecoder<T> implements JsonEncoderDecoder<T> {\n\n    // /////////////////////////////////////////////////////////////////\n    // Built in encoders for the native types.\n    // /////////////////////////////////////////////////////////////////\n    public static final AbstractJsonEncoderDecoder<Boolean> BOOLEAN = new AbstractJsonEncoderDecoder<Boolean>() {\n\n        public Boolean decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONBoolean bool = value.isBoolean();\n            if (bool == null) {\n                throw new DecodingException(\"Expected a json boolean, but was given: \" + value);\n            }\n            return bool.booleanValue();\n        }\n\n        public JSONValue encode(Boolean value) throws EncodingException {\n            return (value == null) ? getNullType() : JSONBoolean.getInstance(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Character> CHAR = new AbstractJsonEncoderDecoder<Character>() {\n\n        public Character decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (char) toDouble(value);\n        }\n\n        public JSONValue encode(Character value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Byte> BYTE = new AbstractJsonEncoderDecoder<Byte>() {\n\n        public Byte decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (byte) toDouble(value);\n\n        }\n\n        public JSONValue encode(Byte value) throws EncodingException {\n            if (value == null) {\n                return null;\n            }\n            return new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Short> SHORT = new AbstractJsonEncoderDecoder<Short>() {\n\n        public Short decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (short) toDouble(value);\n        }\n\n        public JSONValue encode(Short value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Integer> INT = new AbstractJsonEncoderDecoder<Integer>() {\n\n        public Integer decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (int) toDouble(value);\n        }\n\n        public JSONValue encode(Integer value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Long> LONG = new AbstractJsonEncoderDecoder<Long>() {\n\n        public Long decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (long) toDouble(value);\n        }\n\n        public JSONValue encode(Long value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Float> FLOAT = new AbstractJsonEncoderDecoder<Float>() {\n\n        public Float decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (float) toDouble(value);\n        }\n\n        public JSONValue encode(Float value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Double> DOUBLE = new AbstractJsonEncoderDecoder<Double>() {\n\n        public Double decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return toDouble(value);\n        }\n\n        public JSONValue encode(Double value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<String> STRING = new AbstractJsonEncoderDecoder<String>() {\n\n        public String decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONString str = value.isString();\n            if (str == null) {\n                if (value.isBoolean() != null || value.isNumber() != null) {\n                    return value.toString();\n                } else {\n                    throw new DecodingException(\"Expected a json string, but was given: \" + value);\n                }\n            }\n            return str.stringValue();\n        }\n\n        public JSONValue encode(String value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<BigDecimal> BIG_DECIMAL = new AbstractJsonEncoderDecoder<BigDecimal>() {\n\n        public BigDecimal decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return toBigDecimal(value);\n        }\n\n        public JSONValue encode(BigDecimal value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value.toString());\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<BigInteger> BIG_INTEGER = new AbstractJsonEncoderDecoder<BigInteger>() {\n\n        public BigInteger decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONNumber number = value.isNumber();\n            if (number == null) {\n                JSONString str = value.isString();\n                if (str == null) {\n                    throw new DecodingException(\"Expected a json number r string, but was given: \" + value);\n                }\n\n                // Doing a straight conversion from string to BigInteger will\n                // not work for large values\n                // So we convert to BigDecimal first and then convert it to\n                // BigInteger.\n                return new BigDecimal(str.stringValue()).toBigInteger();\n            }\n\n            // Doing a straight conversion from string to BigInteger will not\n            // work for large values\n            // So we convert to BigDecimal first and then convert it to\n            // BigInteger.\n            return new BigDecimal(value.toString()).toBigInteger();\n        }\n\n        public JSONValue encode(BigInteger value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value.toString());\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Document> DOCUMENT = new AbstractJsonEncoderDecoder<Document>() {\n\n        public Document decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONString str = value.isString();\n            if (str == null) {\n                throw new DecodingException(\"Expected a json string, but was given: \" + value);\n            }\n            return XMLParser.parse(str.stringValue());\n        }\n\n        public JSONValue encode(Document value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value.toString());\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<JSONValue> JSON_VALUE = new AbstractJsonEncoderDecoder<JSONValue>() {\n\n        public JSONValue decode(JSONValue value) throws DecodingException {\n            return value;\n        }\n\n        public JSONValue encode(JSONValue value) throws EncodingException {\n            return value;\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Date> DATE = new AbstractJsonEncoderDecoder<Date>() {\n\n        public Date decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            String format = Defaults.getDateFormat();\n            if (format == null) {\n                JSONNumber num = value.isNumber();\n                if (num == null) {\n                    throw new DecodingException(\"Expected a json number, but was given: \" + value);\n                }\n                return new Date((long) num.doubleValue());\n            } else {\n                JSONString str = value.isString();\n                if (str == null) {\n                    throw new DecodingException(\"Expected a json string, but was given: \" + value);\n                }\n                return DateTimeFormat.getFormat(format).parse(str.stringValue());\n            }\n        }\n\n        public JSONValue encode(Date value) throws EncodingException {\n            if (value == null) {\n                return getNullType();\n            }\n            String format = Defaults.getDateFormat();\n            if (format == null) {\n                return new JSONNumber(value.getTime());\n            } else {\n                return new JSONString(DateTimeFormat.getFormat(format).format(value));\n            }\n        }\n    };\n\n    // /////////////////////////////////////////////////////////////////\n    // Helper Methods.\n    // /////////////////////////////////////////////////////////////////\n\n    static public BigDecimal toBigDecimal(JSONValue value) {\n        JSONNumber number = value.isNumber();\n        if (number == null) {\n            throw new DecodingException(\"Expected a json number, but was given: \" + value);\n        }\n        return new BigDecimal(value.toString());\n    }\n\n    static public double toDouble(JSONValue value) {\n        JSONNumber number = value.isNumber();\n        if (number == null) {\n            JSONString val = value.isString();\n            if (val != null){\n                try {\n                    return Double.parseDouble(val.stringValue());\n                }\n                catch(NumberFormatException e){\n                    // just through exception below\n                }\n            }\n            throw new DecodingException(\"Expected a json number, but was given: \" + value);\n        }\n        return number.doubleValue();\n    }\n\n    static public JSONObject toObject(JSONValue value) {\n        JSONObject object = value.isObject();\n        if (object == null) {\n            throw new DecodingException(\"Expected a json object, but was given: \" + object);\n        }\n        return object;\n    }\n\n    static public JSONObject toObjectFromWrapper(JSONValue value, String name) {\n        JSONObject object = value.isObject();\n        if (object == null) {\n            throw new DecodingException(\"Expected a json object, but was given: \" + object);\n        }\n        JSONValue result = object.get(name);\n        if (result == null) {\n            // no wrapper found but that is possible within the hierarchy\n            return toObject(value);\n        }\n        return toObject(result);\n    }\n    \n    static private JSONArray asArray(JSONValue value) {\n        JSONArray array = value.isArray();\n        if (array == null) {\n            throw new DecodingException(\"Expected a json array, but was given: \" + value);\n        }\n        return array;\n    }\n\n    static public <Type> List<Type> toList(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        ArrayList<Type> rc = new ArrayList<Type>(array.size());\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            rc.add(encoder.decode(array.get(i)));\n        }\n        return rc;\n    }\n\n    static public <Type> Type[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder, Type[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public short[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Short> encoder, short[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public long[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Long> encoder, long[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public int[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Integer> encoder, int[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public float[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Float> encoder, float[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public double[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Double> encoder, double[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public byte[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Byte> encoder, byte[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public char[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Character> encoder, char[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public boolean[] toArray(JSONValue value, AbstractJsonEncoderDecoder<Boolean> encoder, boolean[] template) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            template[i] = encoder.decode(array.get(i));\n        }\n        return template;\n    }\n\n    static public int getSize(JSONValue value) {\n        if (value == null || value.isNull() != null) {\n            return 0;\n        }\n        JSONArray array = asArray(value);\n        return array.size();\n    }\n\n    static public <Type> Set<Type> toSet(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = asArray(value);\n\n        HashSet<Type> rc = new HashSet<Type>(array.size() * 2);\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            rc.add(encoder.decode(array.get(i)));\n        }\n        return rc;\n    }\n\n    static public <Type> Map<String, Type> toMap(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder, Style style) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n\n            HashMap<String, Type> rc = new HashMap<String, Type>(object.size() * 2);\n            for (String key : object.keySet()) {\n                rc.put(key, encoder.decode(object.get(key)));\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n            value = object.get(\"entry\");\n            if (value == null) {\n                throw new DecodingException(\"Expected an entry array not found\");\n            }\n            JSONArray entries = value.isArray();\n            if (entries == null) {\n                throw new DecodingException(\"Expected an entry array, but was given: \" + value);\n            }\n\n            HashMap<String, Type> rc = new HashMap<String, Type>(object.size() * 2);\n            for (int i = 0; i < entries.size(); i++) {\n                JSONObject entry = entries.get(i).isObject();\n                if (entry == null)\n                    throw new DecodingException(\"Expected an entry object, but was given: \" + value);\n                JSONValue key = entry.get(\"key\");\n                if (key == null)\n                    throw new DecodingException(\"Expected an entry key field not found\");\n                JSONString k = key.isString();\n                if (k == null)\n                    throw new DecodingException(\"Expected an entry key to be a string, but was given: \" + value);\n\n                rc.put(k.stringValue(), encoder.decode(entry.get(\"value\")));\n            }\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet suppored: \" + style.name());\n        }\n    }\n\n    static public <KeyType, ValueType> Map<KeyType, ValueType> toMap(JSONValue value,\n            AbstractJsonEncoderDecoder<KeyType> keyEncoder, AbstractJsonEncoderDecoder<ValueType> valueEncoder,\n            Style style) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n\n            HashMap<KeyType, ValueType> rc = new HashMap<KeyType, ValueType>(object.size() * 2);\n            for (String key : object.keySet()) {\n                try{\n                    rc.put(keyEncoder.decode(JSONParser.parseStrict(key)), valueEncoder.decode(object.get(key)));\n                }\n                catch(JSONException e){\n                    // that can happen for generic key types like Object and then a String key gets passed in\n                    rc.put(keyEncoder.decode(JSONParser.parseStrict(\"\\\"\" + key + \"\\\"\")), valueEncoder.decode(object.get(key)));                    \n                }\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n            value = object.get(\"entry\");\n            if (value == null) {\n                throw new DecodingException(\"Expected an entry array not found\");\n            }\n            JSONArray entries = value.isArray();\n            if (entries == null) {\n                throw new DecodingException(\"Expected an entry array, but was given: \" + value);\n            }\n\n            HashMap<KeyType, ValueType> rc = new HashMap<KeyType, ValueType>(object.size() * 2);\n            for (int i = 0; i < entries.size(); i++) {\n                JSONObject entry = entries.get(i).isObject();\n                if (entry == null)\n                    throw new DecodingException(\"Expected an entry object, but was given: \" + value);\n                JSONValue key = entry.get(\"key\");\n                if (key == null)\n                    throw new DecodingException(\"Expected an entry key field not found\");\n                JSONString k = key.isString();\n                if (k == null)\n                    throw new DecodingException(\"Expected an entry key to be a string, but was given: \" + value);\n                rc.put(keyEncoder.decode(JSONParser.parseStrict(k.stringValue())), valueEncoder.decode(entry.get(\"value\")));\n            }\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet supported: \" + style.name());\n        }\n    }\n\n    // TODO(sbeutel): new map method to handle other key values than String\n    static public <KeyType, ValueType> JSONValue toJSON(Map<KeyType, ValueType> value,\n            AbstractJsonEncoderDecoder<KeyType> keyEncoder, AbstractJsonEncoderDecoder<ValueType> valueEncoder,\n            Style style) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject rc = new JSONObject();\n            for (Entry<KeyType, ValueType> t : value.entrySet()) {\n                rc.put(keyEncoder.encode(t.getKey()).toString(), valueEncoder.encode(t.getValue()));\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject rc = new JSONObject();\n            JSONArray entries = new JSONArray();\n            int i = 0;\n            for (Entry<KeyType, ValueType> t : value.entrySet()) {\n                JSONObject entry = new JSONObject();\n                entry.put(\"key\", new JSONString(keyEncoder.encode(t.getKey()).toString()));\n                entry.put(\"value\", valueEncoder.encode(t.getValue()));\n                entries.set(i++, entry);\n            }\n            rc.put(\"entry\", entries);\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet supported: \" + style.name());\n        }\n    }\n\n    static public <Type> JSONValue toJSON(Map<String, Type> value, AbstractJsonEncoderDecoder<Type> encoder, Style style) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject rc = new JSONObject();\n            for (Entry<String, Type> t : value.entrySet()) {\n                rc.put(t.getKey(), encoder.encode(t.getValue()));\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject rc = new JSONObject();\n            JSONArray entries = new JSONArray();\n            int i = 0;\n            for (Entry<String, Type> t : value.entrySet()) {\n                JSONObject entry = new JSONObject();\n                entry.put(\"key\", new JSONString(t.getKey()));\n                entry.put(\"value\", encoder.encode(t.getValue()));\n                entries.set(i++, entry);\n            }\n            rc.put(\"entry\", entries);\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet suppored: \" + style.name());\n        }\n    }\n\n    static public <Type> JSONValue toJSON(Collection<Type> value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (Type t : value) {\n            rc.set(i++, encoder.encode(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(Type[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (Type t : value) {\n            rc.set(i++, encoder.encode(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(short[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (short t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(int[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (int t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(long[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (long t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(float[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (float t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n    \n    static public <Type> JSONValue toJSON(double[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (double t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(boolean[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (boolean t : value) {\n            rc.set(i++, JSONBoolean.getInstance(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(char[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (char t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static public <Type> JSONValue toJSON(byte[] value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (byte t : value) {\n            rc.set(i++, new JSONNumber(t));\n        }\n        return rc;\n    }\n\n    static private JSONNull getNullType() {\n        return (Defaults.doesIgnoreJsonNulls()) ? null : JSONNull.getInstance();\n    }\n}\n","lineNo":668}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.client;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport org.fusesource.restygwt.rebind.AnnotationResolver;\n\nimport com.google.gwt.core.client.GWT;\nimport com.google.gwt.core.client.JavaScriptObject;\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestBuilder;\nimport com.google.gwt.http.client.RequestCallback;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.http.client.Response;\nimport com.google.gwt.json.client.JSONException;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.xml.client.Document;\nimport com.google.gwt.xml.client.XMLParser;\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n */\npublic class Method {\n\n    /**\n     * GWT hides the full spectrum of methods because safari has a bug:\n     * http://bugs.webkit.org/show_bug.cgi?id=3812\n     *\n     * We extend assume the server side will also check the\n     * X-HTTP-Method-Override header.\n     *\n     * TODO: add an option to support using this approach to bypass restrictive\n     * firewalls even if the browser does support the setting all the method\n     * types.\n     *\n     * @author chirino\n     */\n    static private class MethodRequestBuilder extends RequestBuilder {\n        public MethodRequestBuilder(String method, String url) {\n\n            super(method, url);\n\n            setHeader(\"X-HTTP-Method-Override\", method);\n        }\n    }\n\n    public RequestBuilder builder;\n\n    final Set<Integer> expectedStatuses;\n    {\n      expectedStatuses = new HashSet<Integer>();\n      expectedStatuses.add(200);\n      expectedStatuses.add(201);\n      expectedStatuses.add(204);\n    };\n    boolean anyStatus;\n\n    Request request;\n    Response response;\n    Dispatcher dispatcher;\n\n    /**\n     * additional data which can be set per instance, e.g. from a {@link AnnotationResolver}\n     */\n    private final Map<String, String> data = new HashMap<String, String>();\n\n    protected Method() {\n    }\n\n    public Method(Resource resource, String method) {\n        builder = new MethodRequestBuilder(method, resource.getUri());\n    }\n\n    public Method user(String user) {\n        builder.setUser(user);\n        return this;\n    }\n\n    public Method password(String password) {\n        builder.setPassword(password);\n        return this;\n    }\n\n    public Method header(String header, String value) {\n        builder.setHeader(header, value);\n        return this;\n    }\n\n    public Method headers(Map<String, String> headers) {\n        if (headers != null) {\n            for (Entry<String, String> entry : headers.entrySet()) {\n                builder.setHeader(entry.getKey(), entry.getValue());\n            }\n        }\n        return this;\n    }\n\n    private void doSetTimeout() {\n        if (Defaults.getRequestTimeout() > -1) {\n            builder.setTimeoutMillis(Defaults.getRequestTimeout());\n        }\n    }\n\n    public Method text(String data) {\n        defaultContentType(Resource.CONTENT_TYPE_TEXT);\n        builder.setRequestData(data);\n        return this;\n    }\n\n    public Method json(JSONValue data) {\n        defaultContentType(Resource.CONTENT_TYPE_JSON);\n        builder.setRequestData(data.toString());\n\n\n        return this;\n    }\n\n    public Method xml(Document data) {\n        defaultContentType(Resource.CONTENT_TYPE_XML);\n        builder.setRequestData(data.toString());\n        return this;\n    }\n\n    public Method timeout(int timeout) {\n        builder.setTimeoutMillis(timeout);\n        return this;\n    }\n\n    /**\n     * sets the expected response status code.  If the response status code does not match\n     * any of the values specified then the request is considered to have failed.  Defaults to accepting\n     * 200,201,204. If set to -1 then any status code is considered a success.\n     */\n    public Method expect(int ... statuses) {\n        if ( statuses.length==1 && statuses[0] < 0) {\n            anyStatus = true;\n        } else {\n            anyStatus = false;\n            this.expectedStatuses.clear();\n            for( int status : statuses ) {\n                this.expectedStatuses.add(status);\n            }\n        }\n        return this;\n    }\n\n\t/**\n     * Local file-system (file://) does not return any status codes.\n     * Therefore - if we read from the file-system we accept all codes.\n     * \n     * This is for instance relevant when developing a PhoneGap application with\n     * restyGwt.\n     */\n    public boolean isExpected(int status) {\n    \t\n    \tString baseUrl = GWT.getHostPageBaseURL();\n    \tString requestUrl = builder.getUrl();\n\t\t\n    \tif (FileSystemHelper.isRequestGoingToFileSystem(baseUrl, requestUrl)) {\n    \t\treturn true;\n    \t} else if (anyStatus) {\n            return true;\n        } else {\n            return this.expectedStatuses.contains(status);\n        }\n    }\n\n    public void send(final RequestCallback callback) throws RequestException {\n        doSetTimeout();\n        builder.setCallback(callback);\n        // lazily load dispatcher from defaults, if one is not set yet.\n        Dispatcher localDispatcher = dispatcher == null ? Defaults.getDispatcher() : dispatcher;\n        localDispatcher.send(this, builder);\n    }\n\n    public void send(final TextCallback callback) {\n        defaultAcceptType(Resource.CONTENT_TYPE_TEXT);\n        try {\n            send(new AbstractRequestCallback<String>(this, callback) {\n                protected String parseResult() throws Exception {\n                    return response.getText();\n                }\n            });\n        } catch (Throwable e) {\n            GWT.log(\"Received http error for: \" + builder.getHTTPMethod() + \" \" + builder.getUrl(), e);\n            callback.onFailure(this, e);\n        }\n    }\n\n    public void send(final JsonCallback callback) {\n        defaultAcceptType(Resource.CONTENT_TYPE_JSON);\n\n        try {\n            send(new AbstractRequestCallback<JSONValue>(this, callback) {\n                protected JSONValue parseResult() throws Exception {\n                    try {\n                        return JSONParser.parseStrict(response.getText());\n                    } catch (Throwable e) {\n                        throw new ResponseFormatException(\"Response was NOT a valid JSON document\", e);\n                    }\n                }\n            });\n        } catch (Throwable e) {\n            GWT.log(\"Received http error for: \" + builder.getHTTPMethod() + \" \" + builder.getUrl(), e);\n            callback.onFailure(this, e);\n        }\n    }\n\n    public void send(final XmlCallback callback) {\n        defaultAcceptType(Resource.CONTENT_TYPE_XML);\n        try {\n            send(new AbstractRequestCallback<Document>(this, callback) {\n                protected Document parseResult() throws Exception {\n                    try {\n                        return XMLParser.parse(response.getText());\n                    } catch (Throwable e) {\n                        throw new ResponseFormatException(\"Response was NOT a valid XML document\", e);\n                    }\n                }\n            });\n        } catch (Throwable e) {\n            GWT.log(\"Received http error for: \" + builder.getHTTPMethod() + \" \" + builder.getUrl(), e);\n            callback.onFailure(this, e);\n        }\n    }\n\n    public <T extends JavaScriptObject> void send(final OverlayCallback<T> callback) {\n\n\n        defaultAcceptType(Resource.CONTENT_TYPE_JSON);\n        try {\n            send(new AbstractRequestCallback<T>(this, callback) {\n                @SuppressWarnings(\"unchecked\")\n                protected T parseResult() throws Exception {\n                    try {\n                        JSONValue val = JSONParser.parseStrict(response.getText());\n                        if (val.isObject() != null) {\n                            return (T) val.isObject().getJavaScriptObject();\n                        } else if (val.isArray() != null) {\n                            return (T) val.isArray().getJavaScriptObject();\n                        } else {\n                            throw new ResponseFormatException(\"Response was NOT a JSON object\");\n                        }\n                    } catch (JSONException e) {\n                        throw new ResponseFormatException(\"Response was NOT a valid JSON document\", e);\n                    } catch (IllegalArgumentException e) {\n                        throw new ResponseFormatException(\"Response was NOT a valid JSON document\", e);\n                    }\n                }\n            });\n        } catch (Throwable e) {\n            GWT.log(\"Received http error for: \" + builder.getHTTPMethod() + \" \" + builder.getUrl(), e);\n            callback.onFailure(this, e);\n        }\n    }\n\n    public Request getRequest() {\n        return request;\n    }\n\n    public Response getResponse() {\n        return response;\n    }\n\n    protected void defaultContentType(String type) {\n        if (builder.getHeader(Resource.HEADER_CONTENT_TYPE) == null) {\n            header(Resource.HEADER_CONTENT_TYPE, type);\n        }\n    }\n\n    protected void defaultAcceptType(String type) {\n        if (builder.getHeader(Resource.HEADER_ACCEPT) == null) {\n            header(Resource.HEADER_ACCEPT, type);\n        }\n    }\n\n    public Dispatcher getDispatcher() {\n        return dispatcher;\n    }\n\n    public void setDispatcher(Dispatcher dispatcher) {\n        this.dispatcher = dispatcher;\n    }\n\n    /**\n     * add some information onto the method which could be interesting when this method\n     * comes back to the dispatcher.\n     *\n     * @param key\n     * @param value\n     */\n    public void addData(String key, String value) {\n        data.put(key, value);\n    }\n\n    /**\n     * get all data fields which was previously added\n     *\n     * @return\n     */\n    public Map<String, String> getData() {\n        return data;\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.client;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport org.fusesource.restygwt.rebind.AnnotationResolver;\n\nimport com.google.gwt.core.client.GWT;\nimport com.google.gwt.core.client.JavaScriptObject;\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestBuilder;\nimport com.google.gwt.http.client.RequestCallback;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.http.client.Response;\nimport com.google.gwt.json.client.JSONException;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.xml.client.Document;\nimport com.google.gwt.xml.client.XMLParser;\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n */\npublic class Method {\n\n    /**\n     * GWT hides the full spectrum of methods because safari has a bug:\n     * http://bugs.webkit.org/show_bug.cgi?id=3812\n     *\n     * We extend assume the server side will also check the\n     * X-HTTP-Method-Override header.\n     *\n     * TODO: add an option to support using this approach to bypass restrictive\n     * firewalls even if the browser does support the setting all the method\n     * types.\n     *\n     * @author chirino\n     */\n    static private class MethodRequestBuilder extends RequestBuilder {\n        public MethodRequestBuilder(String method, String url) {\n\n            super(method, url);\n\n            setHeader(\"X-HTTP-Method-Override\", method);\n        }\n    }\n\n    public RequestBuilder builder;\n\n    final Set<Integer> expectedStatuses;\n    {\n      expectedStatuses = new HashSet<Integer>();\n      expectedStatuses.add(200);\n      expectedStatuses.add(201);\n      expectedStatuses.add(204);\n    };\n    boolean anyStatus;\n\n    Request request;\n    Response response;\n    Dispatcher dispatcher = Defaults.getDispatcher();\n\n    /**\n     * additional data which can be set per instance, e.g. from a {@link AnnotationResolver}\n     */\n    private final Map<String, String> data = new HashMap<String, String>();\n\n    protected Method() {\n    }\n\n    public Method(Resource resource, String method) {\n        builder = new MethodRequestBuilder(method, resource.getUri());\n    }\n\n    public Method user(String user) {\n        builder.setUser(user);\n        return this;\n    }\n\n    public Method password(String password) {\n        builder.setPassword(password);\n        return this;\n    }\n\n    public Method header(String header, String value) {\n        builder.setHeader(header, value);\n        return this;\n    }\n\n    public Method headers(Map<String, String> headers) {\n        if (headers != null) {\n            for (Entry<String, String> entry : headers.entrySet()) {\n                builder.setHeader(entry.getKey(), entry.getValue());\n            }\n        }\n        return this;\n    }\n\n    private void doSetTimeout() {\n        if (Defaults.getRequestTimeout() > -1) {\n            builder.setTimeoutMillis(Defaults.getRequestTimeout());\n        }\n    }\n\n    public Method text(String data) {\n        defaultContentType(Resource.CONTENT_TYPE_TEXT);\n        builder.setRequestData(data);\n        return this;\n    }\n\n    public Method json(JSONValue data) {\n        defaultContentType(Resource.CONTENT_TYPE_JSON);\n        builder.setRequestData(data.toString());\n\n\n        return this;\n    }\n\n    public Method xml(Document data) {\n        defaultContentType(Resource.CONTENT_TYPE_XML);\n        builder.setRequestData(data.toString());\n        return this;\n    }\n\n    public Method timeout(int timeout) {\n        builder.setTimeoutMillis(timeout);\n        return this;\n    }\n\n    /**\n     * sets the expected response status code.  If the response status code does not match\n     * any of the values specified then the request is considered to have failed.  Defaults to accepting\n     * 200,201,204. If set to -1 then any status code is considered a success.\n     */\n    public Method expect(int ... statuses) {\n        if ( statuses.length==1 && statuses[0] < 0) {\n            anyStatus = true;\n        } else {\n            anyStatus = false;\n            this.expectedStatuses.clear();\n            for( int status : statuses ) {\n                this.expectedStatuses.add(status);\n            }\n        }\n        return this;\n    }\n\n\t/**\n     * Local file-system (file://) does not return any status codes.\n     * Therefore - if we read from the file-system we accept all codes.\n     * \n     * This is for instance relevant when developing a PhoneGap application with\n     * restyGwt.\n     */\n    public boolean isExpected(int status) {\n    \t\n    \tString baseUrl = GWT.getHostPageBaseURL();\n    \tString requestUrl = builder.getUrl();\n\t\t\n    \tif (FileSystemHelper.isRequestGoingToFileSystem(baseUrl, requestUrl)) {\n    \t\treturn true;\n    \t} else if (anyStatus) {\n            return true;\n        } else {\n            return this.expectedStatuses.contains(status);\n        }\n    }\n\n    public void send(final RequestCallback callback) throws RequestException {\n        doSetTimeout();\n        builder.setCallback(callback);\n        dispatcher.send(this, builder);\n    }\n\n    public void send(final TextCallback callback) {\n        defaultAcceptType(Resource.CONTENT_TYPE_TEXT);\n        try {\n            send(new AbstractRequestCallback<String>(this, callback) {\n                protected String parseResult() throws Exception {\n                    return response.getText();\n                }\n            });\n        } catch (Throwable e) {\n            GWT.log(\"Received http error for: \" + builder.getHTTPMethod() + \" \" + builder.getUrl(), e);\n            callback.onFailure(this, e);\n        }\n    }\n\n    public void send(final JsonCallback callback) {\n        defaultAcceptType(Resource.CONTENT_TYPE_JSON);\n\n        try {\n            send(new AbstractRequestCallback<JSONValue>(this, callback) {\n                protected JSONValue parseResult() throws Exception {\n                    try {\n                        return JSONParser.parseStrict(response.getText());\n                    } catch (Throwable e) {\n                        throw new ResponseFormatException(\"Response was NOT a valid JSON document\", e);\n                    }\n                }\n            });\n        } catch (Throwable e) {\n            GWT.log(\"Received http error for: \" + builder.getHTTPMethod() + \" \" + builder.getUrl(), e);\n            callback.onFailure(this, e);\n        }\n    }\n\n    public void send(final XmlCallback callback) {\n        defaultAcceptType(Resource.CONTENT_TYPE_XML);\n        try {\n            send(new AbstractRequestCallback<Document>(this, callback) {\n                protected Document parseResult() throws Exception {\n                    try {\n                        return XMLParser.parse(response.getText());\n                    } catch (Throwable e) {\n                        throw new ResponseFormatException(\"Response was NOT a valid XML document\", e);\n                    }\n                }\n            });\n        } catch (Throwable e) {\n            GWT.log(\"Received http error for: \" + builder.getHTTPMethod() + \" \" + builder.getUrl(), e);\n            callback.onFailure(this, e);\n        }\n    }\n\n    public <T extends JavaScriptObject> void send(final OverlayCallback<T> callback) {\n\n\n        defaultAcceptType(Resource.CONTENT_TYPE_JSON);\n        try {\n            send(new AbstractRequestCallback<T>(this, callback) {\n                @SuppressWarnings(\"unchecked\")\n                protected T parseResult() throws Exception {\n                    try {\n                        JSONValue val = JSONParser.parseStrict(response.getText());\n                        if (val.isObject() != null) {\n                            return (T) val.isObject().getJavaScriptObject();\n                        } else if (val.isArray() != null) {\n                            return (T) val.isArray().getJavaScriptObject();\n                        } else {\n                            throw new ResponseFormatException(\"Response was NOT a JSON object\");\n                        }\n                    } catch (JSONException e) {\n                        throw new ResponseFormatException(\"Response was NOT a valid JSON document\", e);\n                    } catch (IllegalArgumentException e) {\n                        throw new ResponseFormatException(\"Response was NOT a valid JSON document\", e);\n                    }\n                }\n            });\n        } catch (Throwable e) {\n            GWT.log(\"Received http error for: \" + builder.getHTTPMethod() + \" \" + builder.getUrl(), e);\n            callback.onFailure(this, e);\n        }\n    }\n\n    public Request getRequest() {\n        return request;\n    }\n\n    public Response getResponse() {\n        return response;\n    }\n\n    protected void defaultContentType(String type) {\n        if (builder.getHeader(Resource.HEADER_CONTENT_TYPE) == null) {\n            header(Resource.HEADER_CONTENT_TYPE, type);\n        }\n    }\n\n    protected void defaultAcceptType(String type) {\n        if (builder.getHeader(Resource.HEADER_ACCEPT) == null) {\n            header(Resource.HEADER_ACCEPT, type);\n        }\n    }\n\n    public Dispatcher getDispatcher() {\n        return dispatcher;\n    }\n\n    public void setDispatcher(Dispatcher dispatcher) {\n        this.dispatcher = dispatcher;\n    }\n\n    /**\n     * add some information onto the method which could be interesting when this method\n     * comes back to the dispatcher.\n     *\n     * @param key\n     * @param value\n     */\n    public void addData(String key, String value) {\n        data.put(key, value);\n    }\n\n    /**\n     * get all data fields which was previously added\n     *\n     * @return\n     */\n    public Map<String, String> getData() {\n        return data;\n    }\n}\n","lineNo":193}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.client;\n\nimport java.util.Map;\n\nimport com.google.gwt.core.client.JavaScriptObject;\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestCallback;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.http.client.Response;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.jsonp.client.JsonpRequestBuilder;\nimport com.google.gwt.user.client.rpc.AsyncCallback;\nimport com.google.gwt.xml.client.Document;\n\n/**\n * A specialized method which accesses a resource as a JSONP request.\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n */\npublic class JsonpMethod extends Method {\n\n    private final Resource resource;\n    private final JsonpRequestBuilder builder = new JsonpRequestBuilder();\n\n    public JsonpMethod(Resource resource) {\n        this.resource = resource;\n    }\n    \n    public JsonpMethod callbackParam(String callbackParam) {\n        builder.setCallbackParam(callbackParam);\n        return this;\n    }\n\n    public JsonpMethod failureCallbackParam(String failureCallbackParam) {\n        builder.setFailureCallbackParam(failureCallbackParam);\n        return this;\n    }\n\n    @Override\n    public Method timeout(int timeout) {\n        builder.setTimeout(timeout);\n        return this;\n    }\n\n    @Override\n    public void send(final JsonCallback callback) {\n        builder.requestObject(resource.getUri(), new AsyncCallback<JavaScriptObject>() {\n            public void onSuccess(JavaScriptObject result) {\n                JSONObject obj = new JSONObject(result);\n                JSONArray arr = obj.isArray();\n                if (arr != null){\n                    callback.onSuccess(JsonpMethod.this, arr);\n                }\n                else {\n                    callback.onSuccess(JsonpMethod.this, obj);\n                }\n            }\n\n            public void onFailure(Throwable caught) {\n                callback.onFailure(JsonpMethod.this, caught);\n            }\n        });\n    }\n\n    @Override\n    public void send(final TextCallback callback) {\n        builder.requestString(resource.getUri(), new AsyncCallback<String>() {\n            public void onSuccess(String result) {\n                callback.onSuccess(JsonpMethod.this, result);\n            }\n\n            public void onFailure(Throwable caught) {\n                callback.onFailure(JsonpMethod.this, caught);\n            }\n        });\n    }\n\n    /**\n     * helper method to make RestServiceClassCreator easier to maintain\n     * @param callback\n     */\n    public void send(final AsyncCallback<JavaScriptObject> callback) {\n        builder.requestObject(resource.getUri(), callback);\n    }\n\n    @Override\n    public void send(RequestCallback callback) throws RequestException {\n        throw unsupported();\n    }\n\n    @Override\n    public Method expect(int ...status) {\n        throw unsupported();\n    }\n\n    @Override\n    public Request getRequest() {\n        throw unsupported();\n    }\n\n    @Override\n    public Response getResponse() {\n        throw unsupported();\n    }\n\n    @Override\n    public Method header(String header, String value) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method headers(Map<String, String> headers) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method json(JSONValue data) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method password(String password) {\n        throw unsupported();\n    }\n\n    @Override\n    public void send(XmlCallback callback) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method text(String data) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method user(String user) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method xml(Document data) {\n        throw unsupported();\n    }\n\n    private UnsupportedOperationException unsupported() {\n        return new UnsupportedOperationException(\"The jasonp method is restricted in what it can be configured with.\");\n    }\n\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.client;\n\nimport java.util.Map;\n\nimport com.google.gwt.core.client.JavaScriptObject;\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestCallback;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.http.client.Response;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.jsonp.client.JsonpRequestBuilder;\nimport com.google.gwt.user.client.rpc.AsyncCallback;\nimport com.google.gwt.xml.client.Document;\n\n/**\n * A specialized method which accesses a resource as a JSONP request.\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n */\npublic class JsonpMethod extends Method {\n\n    private final Resource resource;\n    private final JsonpRequestBuilder builder = new JsonpRequestBuilder();\n\n    public JsonpMethod(Resource resource) {\n        this.resource = resource;\n    }\n    \n    public JsonpMethod callbackParam(String callbackParam) {\n        builder.setCallbackParam(callbackParam);\n        return this;\n    }\n\n    public JsonpMethod failureCallbackParam(String failureCallbackParam) {\n        builder.setFailureCallbackParam(failureCallbackParam);\n        return this;\n    }\n\n    @Override\n    public Method timeout(int timeout) {\n        builder.setTimeout(timeout);\n        return this;\n    }\n\n    @Override\n    public void send(final JsonCallback callback) {\n        builder.requestObject(resource.getUri(), new AsyncCallback<JavaScriptObject>() {\n            public void onSuccess(JavaScriptObject result) {\n                callback.onSuccess(JsonpMethod.this, new JSONObject(result));\n            }\n\n            public void onFailure(Throwable caught) {\n                callback.onFailure(JsonpMethod.this, caught);\n            }\n        });\n    }\n\n    @Override\n    public void send(final TextCallback callback) {\n        builder.requestString(resource.getUri(), new AsyncCallback<String>() {\n            public void onSuccess(String result) {\n                callback.onSuccess(JsonpMethod.this, result);\n            }\n\n            public void onFailure(Throwable caught) {\n                callback.onFailure(JsonpMethod.this, caught);\n            }\n        });\n    }\n\n    /**\n     * helper method to make RestServiceClassCreator easier to maintain\n     * @param callback\n     */\n    public void send(final AsyncCallback<JavaScriptObject> callback) {\n        builder.requestObject(resource.getUri(), callback);\n    }\n\n    @Override\n    public void send(RequestCallback callback) throws RequestException {\n        throw unsupported();\n    }\n\n    @Override\n    public Method expect(int ...status) {\n        throw unsupported();\n    }\n\n    @Override\n    public Request getRequest() {\n        throw unsupported();\n    }\n\n    @Override\n    public Response getResponse() {\n        throw unsupported();\n    }\n\n    @Override\n    public Method header(String header, String value) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method headers(Map<String, String> headers) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method json(JSONValue data) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method password(String password) {\n        throw unsupported();\n    }\n\n    @Override\n    public void send(XmlCallback callback) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method text(String data) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method user(String user) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method xml(Document data) {\n        throw unsupported();\n    }\n\n    private UnsupportedOperationException unsupported() {\n        return new UnsupportedOperationException(\"The jasonp method is restricted in what it can be configured with.\");\n    }\n\n}\n","lineNo":69}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.client;\n\nimport java.util.Map;\n\nimport com.google.gwt.core.client.JavaScriptObject;\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestCallback;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.http.client.Response;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.jsonp.client.JsonpRequestBuilder;\nimport com.google.gwt.user.client.rpc.AsyncCallback;\nimport com.google.gwt.xml.client.Document;\n\n/**\n * A specialized method which accesses a resource as a JSONP request.\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n */\npublic class JsonpMethod extends Method {\n\n    private final Resource resource;\n    private final JsonpRequestBuilder builder = new JsonpRequestBuilder();\n\n    public JsonpMethod(Resource resource) {\n        this.resource = resource;\n    }\n    \n    public JsonpMethod callbackParam(String callbackParam) {\n        builder.setCallbackParam(callbackParam);\n        return this;\n    }\n\n    public JsonpMethod failureCallbackParam(String failureCallbackParam) {\n        builder.setFailureCallbackParam(failureCallbackParam);\n        return this;\n    }\n\n    @Override\n    public Method timeout(int timeout) {\n        builder.setTimeout(timeout);\n        return this;\n    }\n\n    @Override\n    public void send(final JsonCallback callback) {\n        builder.requestObject(resource.getUri(), new AsyncCallback<JavaScriptObject>() {\n            public void onSuccess(JavaScriptObject result) {\n                JSONObject obj = new JSONObject(result);\n                JSONArray arr = obj.isArray();\n                if (arr != null){\n                    callback.onSuccess(JsonpMethod.this, arr);\n                }\n                else {\n                    callback.onSuccess(JsonpMethod.this, obj);\n                }\n            }\n\n            public void onFailure(Throwable caught) {\n                callback.onFailure(JsonpMethod.this, caught);\n            }\n        });\n    }\n\n    @Override\n    public void send(final TextCallback callback) {\n        builder.requestString(resource.getUri(), new AsyncCallback<String>() {\n            public void onSuccess(String result) {\n                callback.onSuccess(JsonpMethod.this, result);\n            }\n\n            public void onFailure(Throwable caught) {\n                callback.onFailure(JsonpMethod.this, caught);\n            }\n        });\n    }\n\n    /**\n     * helper method to make RestServiceClassCreator easier to maintain\n     * @param callback\n     */\n    public void send(final AsyncCallback<JavaScriptObject> callback) {\n        builder.requestObject(resource.getUri(), callback);\n    }\n\n    @Override\n    public void send(RequestCallback callback) throws RequestException {\n        throw unsupported();\n    }\n\n    @Override\n    public Method expect(int ...status) {\n        throw unsupported();\n    }\n\n    @Override\n    public Request getRequest() {\n        throw unsupported();\n    }\n\n    @Override\n    public Response getResponse() {\n        throw unsupported();\n    }\n\n    @Override\n    public Method header(String header, String value) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method headers(Map<String, String> headers) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method json(JSONValue data) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method password(String password) {\n        throw unsupported();\n    }\n\n    @Override\n    public void send(XmlCallback callback) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method text(String data) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method user(String user) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method xml(Document data) {\n        throw unsupported();\n    }\n\n    private UnsupportedOperationException unsupported() {\n        return new UnsupportedOperationException(\"The jasonp method is restricted in what it can be configured with.\");\n    }\n\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2012 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.client;\n\nimport java.util.Map;\n\nimport com.google.gwt.core.client.JavaScriptObject;\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestCallback;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.http.client.Response;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.jsonp.client.JsonpRequestBuilder;\nimport com.google.gwt.user.client.rpc.AsyncCallback;\nimport com.google.gwt.xml.client.Document;\n\n/**\n * A specialized method which accesses a resource as a JSONP request.\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n */\npublic class JsonpMethod extends Method {\n\n    private final Resource resource;\n    private final JsonpRequestBuilder builder = new JsonpRequestBuilder();\n\n    public JsonpMethod(Resource resource) {\n        this.resource = resource;\n    }\n    \n    public JsonpMethod callbackParam(String callbackParam) {\n        builder.setCallbackParam(callbackParam);\n        return this;\n    }\n\n    public JsonpMethod failureCallbackParam(String failureCallbackParam) {\n        builder.setFailureCallbackParam(failureCallbackParam);\n        return this;\n    }\n\n    @Override\n    public Method timeout(int timeout) {\n        builder.setTimeout(timeout);\n        return this;\n    }\n\n    @Override\n    public void send(final JsonCallback callback) {\n        builder.requestObject(resource.getUri(), new AsyncCallback<JavaScriptObject>() {\n            public void onSuccess(JavaScriptObject result) {\n                callback.onSuccess(JsonpMethod.this, new JSONObject(result));\n            }\n\n            public void onFailure(Throwable caught) {\n                callback.onFailure(JsonpMethod.this, caught);\n            }\n        });\n    }\n\n    @Override\n    public void send(final TextCallback callback) {\n        builder.requestString(resource.getUri(), new AsyncCallback<String>() {\n            public void onSuccess(String result) {\n                callback.onSuccess(JsonpMethod.this, result);\n            }\n\n            public void onFailure(Throwable caught) {\n                callback.onFailure(JsonpMethod.this, caught);\n            }\n        });\n    }\n\n    /**\n     * helper method to make RestServiceClassCreator easier to maintain\n     * @param callback\n     */\n    public void send(final AsyncCallback<JavaScriptObject> callback) {\n        builder.requestObject(resource.getUri(), callback);\n    }\n\n    @Override\n    public void send(RequestCallback callback) throws RequestException {\n        throw unsupported();\n    }\n\n    @Override\n    public Method expect(int ...status) {\n        throw unsupported();\n    }\n\n    @Override\n    public Request getRequest() {\n        throw unsupported();\n    }\n\n    @Override\n    public Response getResponse() {\n        throw unsupported();\n    }\n\n    @Override\n    public Method header(String header, String value) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method headers(Map<String, String> headers) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method json(JSONValue data) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method password(String password) {\n        throw unsupported();\n    }\n\n    @Override\n    public void send(XmlCallback callback) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method text(String data) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method user(String user) {\n        throw unsupported();\n    }\n\n    @Override\n    public Method xml(Document data) {\n        throw unsupported();\n    }\n\n    private UnsupportedOperationException unsupported() {\n        return new UnsupportedOperationException(\"The jasonp method is restricted in what it can be configured with.\");\n    }\n\n}\n","lineNo":70}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2011 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.client.callback;\n\nimport org.fusesource.restygwt.client.Method;\nimport org.fusesource.restygwt.client.cache.QueueableCacheStorage;\n\nimport com.google.gwt.http.client.RequestCallback;\nimport com.google.gwt.http.client.Response;\n\npublic class XSRFTokenCallbackFilter implements CallbackFilter {\n\n    protected XSRFToken xsrf;\n\n    public XSRFTokenCallbackFilter(XSRFToken xsrf) {\n        this.xsrf = xsrf;\n    }\n\n    @Override\n    public RequestCallback filter(final Method method, final Response response,\n            RequestCallback callback) {\n        String token = response.getHeader(this.xsrf.getHeaderKey());\n        String restyCacheHeader = response.getHeader(QueueableCacheStorage.RESTY_CACHE_HEADER);\n        if (token != null && (restyCacheHeader == null || restyCacheHeader.isEmpty())){\n            this.xsrf.setToken(token);\n        }\n        return callback;\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2011 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.client.callback;\n\nimport org.fusesource.restygwt.client.Method;\nimport org.fusesource.restygwt.client.cache.QueueableCacheStorage;\n\nimport com.google.gwt.http.client.RequestCallback;\nimport com.google.gwt.http.client.Response;\n\npublic class XSRFTokenCallbackFilter implements CallbackFilter {\n\n    protected XSRFToken xsrf;\n\n    public XSRFTokenCallbackFilter(XSRFToken xsrf) {\n        this.xsrf = xsrf;\n    }\n\n    @Override\n    public RequestCallback filter(final Method method, final Response response,\n            RequestCallback callback) {\n        String token = response.getHeader(this.xsrf.getHeaderKey());\n        if (token != null && response.getHeader(QueueableCacheStorage.RESTY_CACHE_HEADER) == null){\n            this.xsrf.setToken(token);\n        }\n        return callback;\n    }\n}\n","lineNo":39}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2010 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.codehaus.jackson.annotate.JsonCreator;\nimport org.codehaus.jackson.annotate.JsonProperty;\nimport org.codehaus.jackson.annotate.JsonSubTypes;\nimport org.codehaus.jackson.annotate.JsonTypeInfo;\nimport org.codehaus.jackson.annotate.JsonTypeName;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.Id;\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JConstructor;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.core.ext.typeinfo.NotFoundException;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added getter & setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n *\n *                  added polymorphic support\n * @author <a href=\"http://charliemason.info\">Charlie Mason<\/a>\n *\n */\n\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n\n    JsonEncoderDecoderInstanceLocator locator;\n\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n        composerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n        return composerFactory;\n    }\n\n    @Override\n    public void generate() throws UnableToCompleteException {\n\n        JsonTypeInfo typeInfo = source.getAnnotation(JsonTypeInfo.class);\n        JsonSubTypes jacksonSubTypes = source.getAnnotation(JsonSubTypes.class);\n        if(jacksonSubTypes == null && source.getSuperclass() != null){\n            jacksonSubTypes = source.getSuperclass().getAnnotation(JsonSubTypes.class);\n        }\n        ArrayList<JClassType> possibleTypes = new ArrayList<JClassType>();\n\n        locator = new JsonEncoderDecoderInstanceLocator(context, logger);\n\n        JClassType sourceClazz = source.isClass();\n        if (sourceClazz == null) {\n            error(\"Type is not a class\");\n        }\n\n        // Try to find a constuctor that is annotated as creator\n        final JConstructor creator = findCreator(sourceClazz);\n\n        if(sourceClazz.isAbstract()){\n            if(typeInfo == null){\n                error(\"Abstract classes must be annotated with JsonTypeInfo\");\n            }\n        }\n        else if(creator == null && !sourceClazz.isDefaultInstantiable()) {\n            error(\"No default constuctor\");\n        }\n\n        if(typeInfo == null){\n            //Just add this type\n            possibleTypes.add(source);\n        }\n        else{\n            //Get all the possible types from the annotation\n            if(jacksonSubTypes != null){\n                for(JsonSubTypes.Type type : jacksonSubTypes.value())\n                {\n                    try{\n                        //Look up and add each declared type\n                        possibleTypes.add(context.getTypeOracle().getType(type.value().getName()));\n                    }\n                    catch (NotFoundException e){\n                        error(\"Unable to find decalred JsonSubType \" + type.value());\n                    }\n                }\n            }\n            else{\n                error(\"Unable to find required JsonSubTypes annotion on \" + source.getQualifiedSourceName());\n            }\n        }\n\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n        final String railsWrapperName = jsonAnnotation != null && jsonAnnotation.name().length() > 0 ?\n                jsonAnnotation.name() : sourceClazz.getName().toLowerCase();\n\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n\n        if(null != sourceClazz.isEnum()) {\n            p();\n            p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n            {\n                p(\"if( value==null ) {\").i(1);\n                {\n                    p(\"return com.google.gwt.json.client.JSONNull.getInstance();\").i(-1);\n                }\n                p(\"}\");\n                p(\"return new com.google.gwt.json.client.JSONString(value.name());\");\n            }\n            i(-1).p(\"}\");\n            p();\n            p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n            {\n                p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n                {\n                    p(\"return null;\").i(-1);\n                }\n                p(\"}\");\n                p(\"com.google.gwt.json.client.JSONString str = value.isString();\");\n                p(\"if( null == str ) {\").i(1);\n                {\n                    p(\"throw new DecodingException(\\\"Expected a json string (for enum), but was given: \\\"+value);\").i(-1);\n                }\n                p(\"}\");\n                p(\"return Enum.valueOf(\"+source.getParameterizedQualifiedSourceName()+\".class, str.stringValue());\").i(-1);\n            }\n            p(\"}\");\n            p();\n            return;\n        }\n\n\n        String wrapperName = null;\n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n\n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n            if(classStyle == Style.RAILS) {\n                wrapperName = railsWrapperName;\n                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                p(\"rrc.put(\\\"\" + railsWrapperName + \"\\\" , rc);\");\n            }\n\n            JsonTypeInfo sourceTypeInfo = findJsonTypeInfo(source);\n\n            for(JClassType possibleType : possibleTypes){\n\n                if(possibleTypes.size() > 1){\n                    //Generate a decoder for each possible type\n                    p(\"if(value.getClass().getName().equals(\\\"\" + possibleType.getParameterizedQualifiedSourceName() + \"\\\"))\");\n                    p(\"{\");\n                }\n\n                if(sourceTypeInfo != null) {\n                    switch( sourceTypeInfo.include()){ \n                        case PROPERTY:\n                            //Write out the type info so it can be decoded correctly\n                            p(\"com.google.gwt.json.client.JSONValue className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + getTypeIdentifier(sourceTypeInfo, jacksonSubTypes, possibleType) + \"\\\");\");\n                            p(\"if( className!=null ) { \").i(1);\n                            p(\"rc.put(\\\"\" + sourceTypeInfo.property() +\"\\\", className);\");\n                            i(-1).p(\"}\");\n                            break;\n                        case WRAPPER_OBJECT:\n                            wrapperName = getTypeIdentifier(sourceTypeInfo, jacksonSubTypes, possibleType);\n                            p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                            p(\"rrc.put(\\\"\" + wrapperName + \"\\\", rc);\");\n                            break;\n                    }\n                }\n\n                p(possibleType.getParameterizedQualifiedSourceName() + \" parseValue = (\" + possibleType.getParameterizedQualifiedSourceName() +\")value;\");\n\n\n                for (final JField field : getFields(possibleType))\n                {\n\n                    final String getterName = getGetterName(field);\n\n                    // If can ignore some fields right off the back..\n                    if (getterName == null && (field.isStatic() || field.isFinal() || field.isTransient())) {\n                        continue;\n                    }\n\n                    branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                        public Void execute() throws UnableToCompleteException {\n                            // TODO: try to get the field with a setter or JSNI\n                            if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                                Json jsonAnnotation = field.getAnnotation(Json.class);\n\n                                String name = field.getName();\n                                String jsonName = name;\n\n                                if( jsonAnnotation !=null && jsonAnnotation.name().length() > 0  ) {\n                                    jsonName = jsonAnnotation.name();\n                                }\n\n                                String fieldExpr = \"parseValue.\" + name;\n                                if (getterName != null) {\n                                    fieldExpr = \"parseValue.\" + getterName + \"()\";\n                                }\n\n                                Style style = jsonAnnotation!=null ? jsonAnnotation.style() : classStyle;\n                                String expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n\n                                p(\"{\").i(1);\n                                {\n                                    if(null != field.getType().isEnum()) {\n                                        p(\"if(\"+fieldExpr+\" == null) {\").i(1);\n                                        p(\"rc.put(\" + wrap(name) + \", null);\");\n                                        i(-1).p(\"} else {\").i(1);\n                                    }\n\n                                    p(JSON_VALUE_CLASS + \" v=\" + expression + \";\");\n                                    p(\"if( v!=null ) {\").i(1);\n                                    {\n                                        p(\"rc.put(\" + wrap(jsonName) + \", v);\");\n                                    }\n                                    i(-1).p(\"}\");\n\n                                    if(null != field.getType().isEnum()) {\n                                        i(-1).p(\"}\");\n                                    }\n\n                                }\n                                i(-1).p(\"}\");\n\n                            } else {\n                                error(\"field must not be private: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                            }\n                            return null;\n                        }\n                    });\n\n                }\n\n                if (wrapperName != null) {\n                    p(\"return rrc;\");\n                }\n                else {\n                    p(\"return rc;\");\n                }\n\n                if(possibleTypes.size() > 1)\n                {\n                    p(\"}\");\n                }\n            }\n\n            if(possibleTypes.size() > 1)\n            {\n                //Shouldn't get called\n                p(\"return null;\");\n            }\n        }\n        i(-1).p(\"}\");\n        p();\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            if(wrapperName != null){\n                p(JSON_OBJECT_CLASS + \" object = toObject(value, \\\"\" + wrapperName + \"\\\");\");\n            }\n            else{\n                p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            }\n\n            JsonTypeInfo sourceTypeInfo = source.getAnnotation(JsonTypeInfo.class);\n\n            if(sourceTypeInfo != null){\n                switch(sourceTypeInfo.include()){ \n                    case PROPERTY:\n                        p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" + wrap(sourceTypeInfo.property()) + \"));\");\n                        break;\n                    case WRAPPER_OBJECT:\n                        p(\"String sourceName = \\\"\" +  wrapperName + \"\\\";\");\n                        break;\n                }\n            }\n\n            for(JClassType possibleType : possibleTypes){\n                if(possibleTypes.size() > 1){\n                    //Generate a decoder for each possible type\n                    p(\"if(sourceName.equals(\\\"\" + getTypeIdentifier(typeInfo, jacksonSubTypes, possibleType) + \"\\\"))\");\n                    p(\"{\");\n                }\n\n                if(creator != null) {\n                \tp(\"// We found a creator so we use the annotated constructor\");\n                \tp(\"\" + possibleType.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.getParameterizedQualifiedSourceName() + \"(\");\n                \ti(1).p(\"// The arguments are placed in the order they appear within the annotated constructor\").i(-1);\n                \tList<JField> orderedFields = getOrderedFields(getFields(possibleType), creator);\n                \tfinal JField lastField = orderedFields.get(orderedFields.size() - 1);\n                \tfor (final JField field : orderedFields) {\n                \t\tbranch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n\t                        public Void execute() throws UnableToCompleteException {\n                                Json jsonAnnotation = field.getAnnotation(Json.class);\n                                Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                String jsonName = field.getName();\n                                if( jsonAnnotation !=null && jsonAnnotation.name().length() > 0  ) {\n                                    jsonName = jsonAnnotation.name();\n                                }\n                                String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                if (field.getType().isPrimitive() == null) {\n                                \ti(1).p(\"\" + (objectGetter + \" instanceof com.google.gwt.json.client.JSONNull ? null : \" + expression + ((field != lastField) ? \", \" : \"\"))).i(-1);\n                                }\n                                else {\n                                \ti(1).p(\"\" + expression + ((field != lastField) ? \", \" : \"\")).i(-1);\n                                }\n\n                                return null;\n\t                        }\n\t                    });\n                \t}\n                \tp(\");\");\n                }\n                else {\n\t                p(\"\" + possibleType.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.getParameterizedQualifiedSourceName() + \"();\");\n\n\t                for (final JField field : getFields(possibleType)) {\n\n\n\t                    final String setterName = getSetterName(field);\n\n\t                    // If can ignore some fields right off the back..\n\t                    if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient())) {\n\t                        continue;\n\t                    }\n\n\t                    branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n\t                        public Void execute() throws UnableToCompleteException {\n\n\t                            // TODO: try to set the field with a setter or JSNI\n\t                            if (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n\t                                Json jsonAnnotation = field.getAnnotation(Json.class);\n\t                                Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n\t                                String name = field.getName();\n\t                                String jsonName = field.getName();\n\n\t                                if( jsonAnnotation !=null && jsonAnnotation.name().length() > 0  ) {\n\t                                    jsonName = jsonAnnotation.name();\n\t                                }\n\n\t                                String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n\t                                String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n\t                                p(\"if(\" + objectGetter + \" != null) {\").i(1);\n\n\t                                if (field.getType().isPrimitive() == null) {\n\t                                    p(\"if(\" + objectGetter + \" instanceof com.google.gwt.json.client.JSONNull) {\").i(1);\n\n\t                                    if (setterName != null) {\n\t                                        p(\"rc.\" + setterName + \"(null);\");\n\t                                    } else {\n\t                                        p(\"rc.\" + name + \"=null;\");\n\t                                    }\n\n\t                                    i(-1).p(\"} else {\").i(1);\n\t                                }\n\n\t                                if (setterName != null) {\n\t                                    p(\"rc.\" + setterName + \"(\" + expression + \");\");\n\t                                } else {\n\t                                    p(\"rc.\" + name + \"=\" + expression + \";\");\n\t                                }\n\t                                i(-1).p(\"}\");\n\n\t                                if (field.getType().isPrimitive() == null) {\n\t                                    i(-1).p(\"}\");\n\t                                }\n\n\t                            } else {\n\t                                error(\"field must not be private.\");\n\t                            }\n\t                            return null;\n\t                        }\n\t                    });\n\t                }\n                }\n\n                p(\"return rc;\");\n\n                if(possibleTypes.size() > 1)\n                {\n                    p(\"}\");\n                }\n            }\n\n            if(possibleTypes.size() > 1)\n            {\n                //Shouldn't get called\n                p(\"return null;\");\n            }\n\n            i(-1).p(\"}\");\n            p();\n        }\n    }\n\n    private List<JField> getOrderedFields(List<JField> fields, JConstructor creator) throws UnableToCompleteException {\n\t\tList<JField> orderedFields = new ArrayList<JField>();\n\t\tfor(JParameter param : creator.getParameters()) {\n\t\t\tJsonProperty prop = param.getAnnotation(JsonProperty.class);\n\t\t\tif(prop != null) {\n\t\t\t\tfor(JField field : fields) {\n\t\t\t\t\tif(field.getName().equals(prop.value())) {\n\t\t\t\t\t\torderedFields.add(field);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\terror(\"a constructor annotated with @JsonCreator requires that all paramaters are annotated with @JsonProperty.\");\n\t\t\t}\n\t\t}\n\n\t\treturn orderedFields;\n\t}\n\n\tprivate JConstructor findCreator(JClassType sourceClazz) {\n    \tfor(JConstructor constructor : sourceClazz.getConstructors()) {\n    \t\tif(constructor.getAnnotation(JsonCreator.class) != null) {\n    \t\t\treturn constructor;\n    \t\t}\n    \t}\n\n    \treturn null;\n\t}\n\n    private JsonTypeInfo findJsonTypeInfo(JClassType type) {\n        JsonTypeInfo sourceTypeInfo = type.getAnnotation(JsonTypeInfo.class);\n        if (sourceTypeInfo == null && type.getSuperclass() != null) {\n            return findJsonTypeInfo(type.getSuperclass());\n        }\n        return sourceTypeInfo;\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the setter for the specified field or null if a\n     *         setter can't be found.\n     */\n    private String getSetterName(JField field) {\n        String fieldName = field.getName();\n        fieldName = \"set\" + upperCaseFirstChar(fieldName);\n        JClassType type = field.getEnclosingType();\n        if (exists(type, field, fieldName, true)) {\n            return fieldName;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the getter for the specified field or null if a\n     *         getter can't be found.\n     */\n    private String getGetterName(JField field) {\n        String fieldName = field.getName();\n        JType booleanType = null;\n        try {\n            booleanType = find(Boolean.class);\n        } catch (UnableToCompleteException e) {\n            // do nothing\n        }\n        JClassType type = field.getEnclosingType();\n        if (field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)) {\n            fieldName = \"is\" + upperCaseFirstChar(field.getName());\n            if (exists(type, field, fieldName, false)) {\n                return fieldName;\n            }\n            fieldName = \"has\" + upperCaseFirstChar(field.getName());\n            if (exists(type, field, fieldName, false)) {\n                return fieldName;\n            }\n        }\n        fieldName = \"get\" + upperCaseFirstChar(field.getName());\n        if (exists(type, field, fieldName, false)) {\n            return fieldName;\n        } else {\n            return null;\n        }\n    }\n\n\n    private String upperCaseFirstChar(String in) {\n        if (in.length() == 1) {\n            return in.toUpperCase();\n        } else {\n            return in.substring(0, 1).toUpperCase() + in.substring(1);\n        }\n    }\n\n    /**\n     * checks whether a getter or setter exists on the specified type or any of\n     * its super classes excluding Object.\n     *\n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {\n        JType[] args = null;\n        if (isSetter) {\n            args = new JType[] { field.getType() };\n        } else {\n            args = new JType[] {};\n        }\n\n        if (null != type.findMethod(fieldName, args)) {\n            return true;\n        } else {\n            try {\n                JType objectType = find(Object.class);\n                JClassType superType = type.getSuperclass();\n                if (!objectType.equals(superType)) {\n                    return exists(superType, field, fieldName, isSetter);\n                }\n            } catch (UnableToCompleteException e) {\n                // do nothing\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Inspects the supplied type and all super classes up to but excluding\n     * Object and returns a list of all fields found in these classes.\n     *\n     * @param type\n     * @return\n     */\n    private List<JField> getFields(JClassType type) {\n        return getFields(new ArrayList<JField>(), type);\n    }\n\n    private List<JField> getFields(List<JField> allFields, JClassType type) {\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n            if(!field.isTransient()) {\n                allFields.add(field);\n            }\n        }\n        try {\n            JType objectType = find(Object.class);\n            JClassType superType = type.getSuperclass();\n            if (!objectType.equals(superType)) {\n                return getFields(allFields, superType);\n            }\n        } catch (UnableToCompleteException e) {\n            // do nothing\n        }\n        return allFields;\n    }\n\n    private String getTypeIdentifier(JsonTypeInfo typeInfo, JsonSubTypes subTypes, JClassType classType) throws UnableToCompleteException\n    {\n        if(typeInfo.use() == Id.CLASS){\n\n            //Just return the full class name\n            return classType.getQualifiedSourceName();\n        }\n        else if(typeInfo.use() == Id.NAME){\n\n            //Find the subtype entry\n            for(JsonSubTypes.Type type : subTypes.value()){\n\n                //Check if this is correct type and return its name\n                if(type.value().getName().equals(classType.getParameterizedQualifiedSourceName())){\n\n                    if(type.name() != null && !type.name().isEmpty())\n                        return type.name();\n                }\n            }\n\n            //We obviously couldn't find it so check if its got\n            //it declared as an annotation on the class its self\n            JsonTypeName typeName = classType.getAnnotation(JsonTypeName.class);\n\n            if(typeName != null){\n                return typeName.value();\n            }\n            else{\n                error(\"Unable to find custom type name for \" + classType.getParameterizedQualifiedSourceName());\n            }\n        }\n\n        else if(typeInfo.use() == Id.MINIMAL_CLASS){\n            error(\"JsonTypeInfo.use MINIMAL_CLASS is currently unsupported\");\n        }\n\n        else if(typeInfo.use() == Id.CUSTOM){\n            error(\"JsonTypeInfo.use CUSTOM is currently unsupported\");\n        }\n\n        return \"\";\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2010 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.codehaus.jackson.annotate.JsonCreator;\nimport org.codehaus.jackson.annotate.JsonProperty;\nimport org.codehaus.jackson.annotate.JsonSubTypes;\nimport org.codehaus.jackson.annotate.JsonTypeInfo;\nimport org.codehaus.jackson.annotate.JsonTypeName;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.As;\nimport org.codehaus.jackson.annotate.JsonTypeInfo.Id;\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JConstructor;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JParameter;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.core.ext.typeinfo.NotFoundException;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added getter & setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n *\n *                  added polymorphic support\n * @author <a href=\"http://charliemason.info\">Charlie Mason<\/a>\n *\n */\n\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n\n    JsonEncoderDecoderInstanceLocator locator;\n\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n        composerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n        return composerFactory;\n    }\n\n    @Override\n    public void generate() throws UnableToCompleteException {\n\n        JsonTypeInfo typeInfo = source.getAnnotation(JsonTypeInfo.class);\n        JsonSubTypes jacksonSubTypes = source.getAnnotation(JsonSubTypes.class);\n        if(jacksonSubTypes == null && source.getSuperclass() != null){\n            jacksonSubTypes = source.getSuperclass().getAnnotation(JsonSubTypes.class);\n        }\n        ArrayList<JClassType> possibleTypes = new ArrayList<JClassType>();\n\n        locator = new JsonEncoderDecoderInstanceLocator(context, logger);\n\n        JClassType sourceClazz = source.isClass();\n        if (sourceClazz == null) {\n            error(\"Type is not a class\");\n        }\n\n        // Try to find a constuctor that is annotated as creator\n        final JConstructor creator = findCreator(sourceClazz);\n\n        if(sourceClazz.isAbstract()){\n            if(typeInfo == null){\n                error(\"Abstract classes must be annotated with JsonTypeInfo\");\n            }\n        }\n        else if(creator == null && !sourceClazz.isDefaultInstantiable()) {\n            error(\"No default constuctor\");\n        }\n\n        if(typeInfo == null){\n            //Just add this type\n            possibleTypes.add(source);\n        }\n        else{\n            //Get all the possible types from the annotation\n            if(jacksonSubTypes != null){\n                for(JsonSubTypes.Type type : jacksonSubTypes.value())\n                {\n                    try{\n                        //Look up and add each declared type\n                        possibleTypes.add(context.getTypeOracle().getType(type.value().getName()));\n                    }\n                    catch (NotFoundException e){\n                        error(\"Unable to find decalred JsonSubType \" + type.name());\n                    }\n                }\n            }\n            else{\n                error(\"Unable to find required JsonSubTypes annotion on \" + source.getQualifiedSourceName());\n            }\n        }\n\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n        final String railsWrapperName = jsonAnnotation != null && jsonAnnotation.name().length() > 0 ?\n                jsonAnnotation.name() : sourceClazz.getName().toLowerCase();\n\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n\n        if(null != sourceClazz.isEnum()) {\n            p();\n            p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n            {\n                p(\"if( value==null ) {\").i(1);\n                {\n                    p(\"return com.google.gwt.json.client.JSONNull.getInstance();\").i(-1);\n                }\n                p(\"}\");\n                p(\"return new com.google.gwt.json.client.JSONString(value.name());\");\n            }\n            i(-1).p(\"}\");\n            p();\n            p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n            {\n                p(\"if( value == null || value.isNull()!=null ) {\").i(1);\n                {\n                    p(\"return null;\").i(-1);\n                }\n                p(\"}\");\n                p(\"com.google.gwt.json.client.JSONString str = value.isString();\");\n                p(\"if( null == str ) {\").i(1);\n                {\n                    p(\"throw new DecodingException(\\\"Expected a json string (for enum), but was given: \\\"+value);\").i(-1);\n                }\n                p(\"}\");\n                p(\"return Enum.valueOf(\"+source.getParameterizedQualifiedSourceName()+\".class, str.stringValue());\").i(-1);\n            }\n            p(\"}\");\n            p();\n            return;\n        }\n\n\n\n\n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n            p(\"if( value==null ) {\").i(1);\n            {\n                p(\"return null;\");\n            }\n            i(-1).p(\"}\");\n\n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n            if(classStyle == Style.RAILS) {\n                p(JSON_OBJECT_CLASS + \" rrc = new \" + JSON_OBJECT_CLASS + \"();\");\n                p(\"rrc.put(\\\"\" + railsWrapperName + \"\\\" , rc);\");\n            }\n\n            JsonTypeInfo sourceTypeInfo = findJsonTypeInfo(source);\n\n            for(JClassType possibleType : possibleTypes){\n\n                if(possibleTypes.size() > 1){\n                    //Generate a decoder for each possible type\n                    p(\"if(value.getClass().getName().equals(\\\"\" + possibleType.getParameterizedQualifiedSourceName() + \"\\\"))\");\n                    p(\"{\");\n                }\n\n                if(sourceTypeInfo != null && sourceTypeInfo.include()==As.PROPERTY){\n                    //Write out the type info so it can be decoded correctly\n                    p(\"com.google.gwt.json.client.JSONValue className=org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.encode(\\\"\" + getTypeIdentifier(sourceTypeInfo, jacksonSubTypes, possibleType) + \"\\\");\");\n                    p(\"if( className!=null ) { \").i(1);\n                    p(\"rc.put(\\\"\" + sourceTypeInfo.property() +\"\\\", className);\");\n                    i(-1).p(\"}\");\n                }\n\n                p(possibleType.getParameterizedQualifiedSourceName() + \" parseValue = (\" + possibleType.getParameterizedQualifiedSourceName() +\")value;\");\n\n\n                for (final JField field : getFields(possibleType))\n                {\n\n                    final String getterName = getGetterName(field);\n\n                    // If can ignore some fields right off the back..\n                    if (getterName == null && (field.isStatic() || field.isFinal() || field.isTransient())) {\n                        continue;\n                    }\n\n                    branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n                        public Void execute() throws UnableToCompleteException {\n                            // TODO: try to get the field with a setter or JSNI\n                            if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                                Json jsonAnnotation = field.getAnnotation(Json.class);\n\n                                String name = field.getName();\n                                String jsonName = name;\n\n                                if( jsonAnnotation !=null && jsonAnnotation.name().length() > 0  ) {\n                                    jsonName = jsonAnnotation.name();\n                                }\n\n                                String fieldExpr = \"parseValue.\" + name;\n                                if (getterName != null) {\n                                    fieldExpr = \"parseValue.\" + getterName + \"()\";\n                                }\n\n                                Style style = jsonAnnotation!=null ? jsonAnnotation.style() : classStyle;\n                                String expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n\n                                p(\"{\").i(1);\n                                {\n                                    if(null != field.getType().isEnum()) {\n                                        p(\"if(\"+fieldExpr+\" == null) {\").i(1);\n                                        p(\"rc.put(\" + wrap(name) + \", null);\");\n                                        i(-1).p(\"} else {\").i(1);\n                                    }\n\n                                    p(JSON_VALUE_CLASS + \" v=\" + expression + \";\");\n                                    p(\"if( v!=null ) {\").i(1);\n                                    {\n                                        p(\"rc.put(\" + wrap(jsonName) + \", v);\");\n                                    }\n                                    i(-1).p(\"}\");\n\n                                    if(null != field.getType().isEnum()) {\n                                        i(-1).p(\"}\");\n                                    }\n\n                                }\n                                i(-1).p(\"}\");\n\n                            } else {\n                                error(\"field must not be private: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                            }\n                            return null;\n                        }\n                    });\n\n                }\n\n                if(classStyle == Style.RAILS){\n                    p(\"return rrc;\");\n                }\n                else {\n                    p(\"return rc;\");\n                }\n\n                if(possibleTypes.size() > 1)\n                {\n                    p(\"}\");\n                }\n            }\n\n            if(possibleTypes.size() > 1)\n            {\n                //Shouldn't get called\n                p(\"return null;\");\n            }\n        }\n        i(-1).p(\"}\");\n        p();\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            if(classStyle == Style.RAILS){\n                p(JSON_OBJECT_CLASS + \" object = toObject(value, \\\"\" + railsWrapperName + \"\\\");\");\n            }\n            else{\n                p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            }\n\n            JsonTypeInfo sourceTypeInfo = source.getAnnotation(JsonTypeInfo.class);\n\n            if(sourceTypeInfo != null && sourceTypeInfo.include()==As.PROPERTY){\n                p(\"String sourceName = org.fusesource.restygwt.client.AbstractJsonEncoderDecoder.STRING.decode(object.get(\" + wrap(sourceTypeInfo.property()) + \"));\");\n            }\n\n            for(JClassType possibleType : possibleTypes){\n                if(possibleTypes.size() > 1){\n                    //Generate a decoder for each possible type\n                    p(\"if(sourceName.equals(\\\"\" + getTypeIdentifier(typeInfo, jacksonSubTypes, possibleType) + \"\\\"))\");\n                    p(\"{\");\n                }\n\n                if(creator != null) {\n                \tp(\"// We found a creator so we use the annotated constructor\");\n                \tp(\"\" + possibleType.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.getParameterizedQualifiedSourceName() + \"(\");\n                \ti(1).p(\"// The arguments are placed in the order they appear within the annotated constructor\").i(-1);\n                \tList<JField> orderedFields = getOrderedFields(getFields(possibleType), creator);\n                \tfinal JField lastField = orderedFields.get(orderedFields.size() - 1);\n                \tfor (final JField field : orderedFields) {\n                \t\tbranch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n\t                        public Void execute() throws UnableToCompleteException {\n                                Json jsonAnnotation = field.getAnnotation(Json.class);\n                                Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                String jsonName = field.getName();\n                                if( jsonAnnotation !=null && jsonAnnotation.name().length() > 0  ) {\n                                    jsonName = jsonAnnotation.name();\n                                }\n                                String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                                String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n                                if (field.getType().isPrimitive() == null) {\n                                \ti(1).p(\"\" + (objectGetter + \" instanceof com.google.gwt.json.client.JSONNull ? null : \" + expression + ((field != lastField) ? \", \" : \"\"))).i(-1);\n                                }\n                                else {\n                                \ti(1).p(\"\" + expression + ((field != lastField) ? \", \" : \"\")).i(-1);\n                                }\n\n                                return null;\n\t                        }\n\t                    });\n                \t}\n                \tp(\");\");\n                }\n                else {\n\t                p(\"\" + possibleType.getParameterizedQualifiedSourceName() + \" rc = new \" + possibleType.getParameterizedQualifiedSourceName() + \"();\");\n\n\t                for (final JField field : getFields(possibleType)) {\n\n\n\t                    final String setterName = getSetterName(field);\n\n\t                    // If can ignore some fields right off the back..\n\t                    if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient())) {\n\t                        continue;\n\t                    }\n\n\t                    branch(\"Processing field: \" + field.getName(), new Branch<Void>() {\n\t                        public Void execute() throws UnableToCompleteException {\n\n\t                            // TODO: try to set the field with a setter or JSNI\n\t                            if (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n\t                                Json jsonAnnotation = field.getAnnotation(Json.class);\n\t                                Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n\t                                String name = field.getName();\n\t                                String jsonName = field.getName();\n\n\t                                if( jsonAnnotation !=null && jsonAnnotation.name().length() > 0  ) {\n\t                                    jsonName = jsonAnnotation.name();\n\t                                }\n\n\t                                String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n\t                                String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n\n\t                                p(\"if(\" + objectGetter + \" != null) {\").i(1);\n\n\t                                if (field.getType().isPrimitive() == null) {\n\t                                    p(\"if(\" + objectGetter + \" instanceof com.google.gwt.json.client.JSONNull) {\").i(1);\n\n\t                                    if (setterName != null) {\n\t                                        p(\"rc.\" + setterName + \"(null);\");\n\t                                    } else {\n\t                                        p(\"rc.\" + name + \"=null;\");\n\t                                    }\n\n\t                                    i(-1).p(\"} else {\").i(1);\n\t                                }\n\n\t                                if (setterName != null) {\n\t                                    p(\"rc.\" + setterName + \"(\" + expression + \");\");\n\t                                } else {\n\t                                    p(\"rc.\" + name + \"=\" + expression + \";\");\n\t                                }\n\t                                i(-1).p(\"}\");\n\n\t                                if (field.getType().isPrimitive() == null) {\n\t                                    i(-1).p(\"}\");\n\t                                }\n\n\t                            } else {\n\t                                error(\"field must not be private.\");\n\t                            }\n\t                            return null;\n\t                        }\n\t                    });\n\t                }\n                }\n\n                p(\"return rc;\");\n\n                if(possibleTypes.size() > 1)\n                {\n                    p(\"}\");\n                }\n            }\n\n            if(possibleTypes.size() > 1)\n            {\n                //Shouldn't get called\n                p(\"return null;\");\n            }\n\n            i(-1).p(\"}\");\n            p();\n        }\n    }\n\n    private List<JField> getOrderedFields(List<JField> fields, JConstructor creator) throws UnableToCompleteException {\n\t\tList<JField> orderedFields = new ArrayList<JField>();\n\t\tfor(JParameter param : creator.getParameters()) {\n\t\t\tJsonProperty prop = param.getAnnotation(JsonProperty.class);\n\t\t\tif(prop != null) {\n\t\t\t\tfor(JField field : fields) {\n\t\t\t\t\tif(field.getName().equals(prop.value())) {\n\t\t\t\t\t\torderedFields.add(field);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\terror(\"a constructor annotated with @JsonCreator requires that all paramaters are annotated with @JsonProperty.\");\n\t\t\t}\n\t\t}\n\n\t\treturn orderedFields;\n\t}\n\n\tprivate JConstructor findCreator(JClassType sourceClazz) {\n    \tfor(JConstructor constructor : sourceClazz.getConstructors()) {\n    \t\tif(constructor.getAnnotation(JsonCreator.class) != null) {\n    \t\t\treturn constructor;\n    \t\t}\n    \t}\n\n    \treturn null;\n\t}\n\n    private JsonTypeInfo findJsonTypeInfo(JClassType type) {\n        JsonTypeInfo sourceTypeInfo = type.getAnnotation(JsonTypeInfo.class);\n        if (sourceTypeInfo == null && type.getSuperclass() != null) {\n            return findJsonTypeInfo(type.getSuperclass());\n        }\n        return sourceTypeInfo;\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the setter for the specified field or null if a\n     *         setter can't be found.\n     */\n    private String getSetterName(JField field) {\n        String fieldName = field.getName();\n        fieldName = \"set\" + upperCaseFirstChar(fieldName);\n        JClassType type = field.getEnclosingType();\n        if (exists(type, field, fieldName, true)) {\n            return fieldName;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     *\n     * @param field\n     * @return the name for the getter for the specified field or null if a\n     *         getter can't be found.\n     */\n    private String getGetterName(JField field) {\n        String fieldName = field.getName();\n        JType booleanType = null;\n        try {\n            booleanType = find(Boolean.class);\n        } catch (UnableToCompleteException e) {\n            // do nothing\n        }\n        JClassType type = field.getEnclosingType();\n        if (field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)) {\n            fieldName = \"is\" + upperCaseFirstChar(field.getName());\n            if (exists(type, field, fieldName, false)) {\n                return fieldName;\n            }\n            fieldName = \"has\" + upperCaseFirstChar(field.getName());\n            if (exists(type, field, fieldName, false)) {\n                return fieldName;\n            }\n        }\n        fieldName = \"get\" + upperCaseFirstChar(field.getName());\n        if (exists(type, field, fieldName, false)) {\n            return fieldName;\n        } else {\n            return null;\n        }\n    }\n\n\n    private String upperCaseFirstChar(String in) {\n        if (in.length() == 1) {\n            return in.toUpperCase();\n        } else {\n            return in.substring(0, 1).toUpperCase() + in.substring(1);\n        }\n    }\n\n    /**\n     * checks whether a getter or setter exists on the specified type or any of\n     * its super classes excluding Object.\n     *\n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {\n        JType[] args = null;\n        if (isSetter) {\n            args = new JType[] { field.getType() };\n        } else {\n            args = new JType[] {};\n        }\n\n        if (null != type.findMethod(fieldName, args)) {\n            return true;\n        } else {\n            try {\n                JType objectType = find(Object.class);\n                JClassType superType = type.getSuperclass();\n                if (!objectType.equals(superType)) {\n                    return exists(superType, field, fieldName, isSetter);\n                }\n            } catch (UnableToCompleteException e) {\n                // do nothing\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Inspects the supplied type and all super classes up to but excluding\n     * Object and returns a list of all fields found in these classes.\n     *\n     * @param type\n     * @return\n     */\n    private List<JField> getFields(JClassType type) {\n        return getFields(new ArrayList<JField>(), type);\n    }\n\n    private List<JField> getFields(List<JField> allFields, JClassType type) {\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n            if(!field.isTransient()) {\n                allFields.add(field);\n            }\n        }\n        try {\n            JType objectType = find(Object.class);\n            JClassType superType = type.getSuperclass();\n            if (!objectType.equals(superType)) {\n                return getFields(allFields, superType);\n            }\n        } catch (UnableToCompleteException e) {\n            // do nothing\n        }\n        return allFields;\n    }\n\n    private String getTypeIdentifier(JsonTypeInfo typeInfo, JsonSubTypes subTypes, JClassType classType) throws UnableToCompleteException\n    {\n        if(typeInfo.use() == Id.CLASS){\n\n            //Just return the full class name\n            return classType.getQualifiedSourceName();\n        }\n        else if(typeInfo.use() == Id.NAME){\n\n            //Find the subtype entry\n            for(JsonSubTypes.Type type : subTypes.value()){\n\n                //Check if this is correct type and return its name\n                if(type.value().getName().equals(classType.getParameterizedQualifiedSourceName())){\n\n                    if(type.name() != null && !type.name().isEmpty())\n                        return type.name();\n                }\n            }\n\n            //We obviously couldn't find it so check if its got\n            //it declared as an annotation on the class its self\n            JsonTypeName typeName = classType.getAnnotation(JsonTypeName.class);\n\n            if(typeName != null){\n                return typeName.value();\n            }\n            else{\n                error(\"Unable to find custom type name for \" + classType.getParameterizedQualifiedSourceName());\n            }\n        }\n\n        else if(typeInfo.use() == Id.MINIMAL_CLASS){\n            error(\"JsonTypeInfo.use MINIMAL_CLASS is currently unsupported\");\n        }\n\n        else if(typeInfo.use() == Id.CUSTOM){\n            error(\"JsonTypeInfo.use CUSTOM is currently unsupported\");\n        }\n\n        return \"\";\n    }\n}\n","lineNo":174}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2010 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport java.io.PrintWriter;\nimport java.util.HashSet;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JParameterizedType;\nimport com.google.gwt.user.rebind.AbstractSourceCreator;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport com.google.gwt.user.rebind.SourceWriter;\n\n/**\n * provides additional helper methods for generating source..\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n */\npublic abstract class BaseSourceCreator extends AbstractSourceCreator {\n\n    public static final TreeLogger.Type ERROR = TreeLogger.ERROR;\n    public static final TreeLogger.Type WARN = TreeLogger.WARN;\n    public static final TreeLogger.Type INFO = TreeLogger.INFO;\n    public static final TreeLogger.Type TRACE = TreeLogger.TRACE;\n    public static final TreeLogger.Type DEBUG = TreeLogger.DEBUG;\n    public static final TreeLogger.Type SPAM = TreeLogger.SPAM;\n    public static final TreeLogger.Type ALL = TreeLogger.ALL;\n\n    protected final GeneratorContext context;\n    protected final JClassType source;\n    protected final String packageName;\n    protected final String shortName;\n    protected final String name;\n    protected TreeLogger logger;\n    protected SourceWriter sourceWriter;\n    private PrintWriter writer;\n\n    static final private ThreadLocal<HashSet<String>> GENERATED_CLASSES = new ThreadLocal<HashSet<String>>();\n\n    static public HashSet<String> getGeneratedClasses() {\n        HashSet<String> rc = GENERATED_CLASSES.get();\n        if (rc == null) {\n            rc = new HashSet<String>();\n            GENERATED_CLASSES.set(rc);\n        }\n        return rc;\n    }\n\n    static public void clearGeneratedClasses() {\n        GENERATED_CLASSES.set(null);\n    }\n\n    public BaseSourceCreator(TreeLogger logger, GeneratorContext context, JClassType source, String suffix) {\n        this.logger = logger;\n        this.context = context;\n        this.source = source;\n        this.packageName = source.getPackage().getName();\n\n        final JParameterizedType parameterized = source.isParameterized();\n        final String simpleSourceName;\n\n        if (null == parameterized) {\n            simpleSourceName = source.getSimpleSourceName();\n            logger.log(TreeLogger.INFO, \"generating non-generic type: \" + simpleSourceName + \" from \"\n                    + source.getParameterizedQualifiedSourceName());\n        } else {\n            // TODO handle the case where there are more than one parameterized types\n            simpleSourceName = source.getSimpleSourceName() + \"__\" + parameterized.getTypeArgs()[0].getQualifiedSourceName().replace(\".\", \"_\");\n            logger.log(TreeLogger.INFO, \"generating GENERIC type: \" + simpleSourceName + \" from \"\n                    + source.getParameterizedQualifiedSourceName());\n        }\n\n        this.shortName = simpleSourceName + suffix;\n        this.name = packageName + \".\" + shortName;\n    }\n\n    protected PrintWriter writer() throws UnableToCompleteException {\n        HashSet<String> classes = getGeneratedClasses();\n        if (classes.contains(name)) {\n            return null;\n        }\n        classes.add(name);\n        PrintWriter writer = context.tryCreate(logger, packageName, shortName);\n        if (writer == null) {\n            return null;\n        }\n        return writer;\n    }\n\n    public interface Branch<R> {\n        R execute() throws UnableToCompleteException;\n    }\n\n    protected <R> R branch(String msg, Branch<R> callable) throws UnableToCompleteException {\n        return branch(DEBUG, msg, callable);\n    }\n\n    protected <R> R branch(TreeLogger.Type level, String msg, Branch<R> callable) throws UnableToCompleteException {\n        TreeLogger original = logger;\n        try {\n            logger = logger.branch(level, msg);\n            return callable.execute();\n        } finally {\n            logger = original;\n        }\n    }\n\n    protected void error(String msg) throws UnableToCompleteException {\n        logger.log(ERROR, msg);\n        throw new UnableToCompleteException();\n    }\n\n    protected void warn(String msg) throws UnableToCompleteException {\n        logger.log(WARN, msg);\n        throw new UnableToCompleteException();\n    }\n\n    protected void info(String msg) throws UnableToCompleteException {\n        logger.log(INFO, msg);\n    }\n\n    protected void debug(String msg) throws UnableToCompleteException {\n        logger.log(DEBUG, msg);\n    }\n\n    protected void trace(String msg) throws UnableToCompleteException {\n        logger.log(TRACE, msg);\n    }\n\n    protected JClassType find(Class<?> type) throws UnableToCompleteException {\n        return find(type.getName());\n    }\n\n    protected JClassType find(String type) throws UnableToCompleteException {\n        return RestServiceGenerator.find(logger, context, type);\n    }\n\n    protected BaseSourceCreator i(int i) {\n        if (i == 1) {\n            this.sourceWriter.indent();\n        } else if (i == -1) {\n            this.sourceWriter.outdent();\n        } else {\n            throw new IllegalArgumentException();\n        }\n        return this;\n    }\n\n    protected BaseSourceCreator p(String value) {\n        this.sourceWriter.println(value);\n\n        // System.out.println(value);\n        return this;\n    }\n\n    protected BaseSourceCreator p() {\n        this.sourceWriter.println();\n        return this;\n    }\n\n    static String join(int []values, String sep) {\n        StringBuilder sb = new StringBuilder();\n        for(int i =0; i < values.length; i++) {\n            if( i!=0 ) {\n                sb.append(sep);\n            }\n            sb.append(values[i]);\n        }\n        return sb.toString();\n    }\n\n    static String join(Object []values, String sep) {\n        StringBuilder sb = new StringBuilder();\n        for(int i =0; i < values.length; i++) {\n            if( i!=0 ) {\n                sb.append(sep);\n            }\n            sb.append(values[i]);\n        }\n        return sb.toString();\n    }\n\n    final public String create() throws UnableToCompleteException {\n        writer = writer();\n        if (writer == null) {\n            return name;\n        }\n        logger = logger.branch(TreeLogger.DEBUG, \"Generating: \" + name);\n\n        ClassSourceFileComposerFactory composerFactory = createComposerFactory();\n        sourceWriter = composerFactory.createSourceWriter(context, writer);\n\n        generate();\n        sourceWriter.commit(logger);\n        return name;\n    }\n\n    abstract protected ClassSourceFileComposerFactory createComposerFactory() throws UnableToCompleteException;\n\n    abstract protected void generate() throws UnableToCompleteException;\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2010 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.user.rebind.AbstractSourceCreator;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport com.google.gwt.user.rebind.SourceWriter;\n\nimport java.io.PrintWriter;\nimport java.util.HashSet;\n\n/**\n * provides additional helper methods for generating source..\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n */\npublic abstract class BaseSourceCreator extends AbstractSourceCreator {\n\n    public static final TreeLogger.Type ERROR = TreeLogger.ERROR;\n    public static final TreeLogger.Type WARN = TreeLogger.WARN;\n    public static final TreeLogger.Type INFO = TreeLogger.INFO;\n    public static final TreeLogger.Type TRACE = TreeLogger.TRACE;\n    public static final TreeLogger.Type DEBUG = TreeLogger.DEBUG;\n    public static final TreeLogger.Type SPAM = TreeLogger.SPAM;\n    public static final TreeLogger.Type ALL = TreeLogger.ALL;\n\n    protected final GeneratorContext context;\n    protected final JClassType source;\n    protected final String packageName;\n    protected final String shortName;\n    protected final String name;\n    protected TreeLogger logger;\n    protected SourceWriter sourceWriter;\n    private PrintWriter writer;\n\n    static final private ThreadLocal<HashSet<String>> GENERATED_CLASSES = new ThreadLocal<HashSet<String>>();\n\n    static public HashSet<String> getGeneratedClasses() {\n        HashSet<String> rc = GENERATED_CLASSES.get();\n        if (rc == null) {\n            rc = new HashSet<String>();\n            GENERATED_CLASSES.set(rc);\n        }\n        return rc;\n    }\n\n    static public void clearGeneratedClasses() {\n        GENERATED_CLASSES.set(null);\n    }\n\n    public BaseSourceCreator(TreeLogger logger, GeneratorContext context, JClassType source, String suffix) {\n        this.logger = logger;\n        this.context = context;\n        this.source = source;\n        this.packageName = source.getPackage().getName();\n        this.shortName = source.getSimpleSourceName() + suffix;\n        this.name = packageName + \".\" + shortName;\n    }\n\n    protected PrintWriter writer() throws UnableToCompleteException {\n        HashSet<String> classes = getGeneratedClasses();\n        if (classes.contains(name)) {\n            return null;\n        }\n        classes.add(name);\n        PrintWriter writer = context.tryCreate(logger, packageName, shortName);\n        if (writer == null) {\n            return null;\n        }\n        return writer;\n    }\n\n    public interface Branch<R> {\n        R execute() throws UnableToCompleteException;\n    }\n\n    protected <R> R branch(String msg, Branch<R> callable) throws UnableToCompleteException {\n        return branch(DEBUG, msg, callable);\n    }\n\n    protected <R> R branch(TreeLogger.Type level, String msg, Branch<R> callable) throws UnableToCompleteException {\n        TreeLogger original = logger;\n        try {\n            logger = logger.branch(level, msg);\n            return callable.execute();\n        } finally {\n            logger = original;\n        }\n    }\n\n    protected void error(String msg) throws UnableToCompleteException {\n        logger.log(ERROR, msg);\n        throw new UnableToCompleteException();\n    }\n\n    protected void warn(String msg) throws UnableToCompleteException {\n        logger.log(WARN, msg);\n        throw new UnableToCompleteException();\n    }\n\n    protected void info(String msg) throws UnableToCompleteException {\n        logger.log(INFO, msg);\n    }\n\n    protected void debug(String msg) throws UnableToCompleteException {\n        logger.log(DEBUG, msg);\n    }\n\n    protected void trace(String msg) throws UnableToCompleteException {\n        logger.log(TRACE, msg);\n    }\n\n    protected JClassType find(Class<?> type) throws UnableToCompleteException {\n        return find(type.getName());\n    }\n\n    protected JClassType find(String type) throws UnableToCompleteException {\n        return RestServiceGenerator.find(logger, context, type);\n    }\n\n    protected BaseSourceCreator i(int i) {\n        if (i == 1) {\n            this.sourceWriter.indent();\n        } else if (i == -1) {\n            this.sourceWriter.outdent();\n        } else {\n            throw new IllegalArgumentException();\n        }\n        return this;\n    }\n\n    protected BaseSourceCreator p(String value) {\n        this.sourceWriter.println(value);\n\n        // System.out.println(value);\n        return this;\n    }\n\n    protected BaseSourceCreator p() {\n        this.sourceWriter.println();\n        return this;\n    }\n\n    static String join(int []values, String sep) {\n        StringBuilder sb = new StringBuilder();\n        for(int i =0; i < values.length; i++) {\n            if( i!=0 ) {\n                sb.append(sep);\n            }\n            sb.append(values[i]);\n        }\n        return sb.toString();\n    }\n\n    static String join(Object []values, String sep) {\n        StringBuilder sb = new StringBuilder();\n        for(int i =0; i < values.length; i++) {\n            if( i!=0 ) {\n                sb.append(sep);\n            }\n            sb.append(values[i]);\n        }\n        return sb.toString();\n    }\n\n    final public String create() throws UnableToCompleteException {\n        writer = writer();\n        if (writer == null) {\n            return name;\n        }\n        logger = logger.branch(TreeLogger.DEBUG, \"Generating: \" + name);\n\n        ClassSourceFileComposerFactory composerFactory = createComposerFactory();\n        sourceWriter = composerFactory.createSourceWriter(context, writer);\n\n        generate();\n        sourceWriter.commit(logger);\n        return name;\n    }\n\n    abstract protected ClassSourceFileComposerFactory createComposerFactory() throws UnableToCompleteException;\n\n    abstract protected void generate() throws UnableToCompleteException;\n}\n","lineNo":79}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2010 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.client;\n\nimport com.google.gwt.i18n.client.DateTimeFormat;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONBoolean;\nimport com.google.gwt.json.client.JSONNull;\nimport com.google.gwt.json.client.JSONNumber;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONString;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.xml.client.Document;\nimport com.google.gwt.xml.client.XMLParser;\n\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\nabstract public class AbstractJsonEncoderDecoder<T> implements JsonEncoderDecoder<T> {\n\n    // /////////////////////////////////////////////////////////////////\n    // Built in encoders for the native types.\n    // /////////////////////////////////////////////////////////////////\n    public static final AbstractJsonEncoderDecoder<Boolean> BOOLEAN = new AbstractJsonEncoderDecoder<Boolean>() {\n\n        public Boolean decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONBoolean bool = value.isBoolean();\n            if (bool == null) {\n                throw new DecodingException(\"Expected a json boolean, but was given: \" + value);\n            }\n            return bool.booleanValue();\n        }\n\n        public JSONValue encode(Boolean value) throws EncodingException {\n            return (value == null) ? getNullType() : JSONBoolean.getInstance(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Character> CHAR = new AbstractJsonEncoderDecoder<Character>() {\n\n        public Character decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (char) toDouble(value);\n        }\n\n        public JSONValue encode(Character value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Byte> BYTE = new AbstractJsonEncoderDecoder<Byte>() {\n\n        public Byte decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (byte) toDouble(value);\n      \n        }\n\n        public JSONValue encode(Byte value) throws EncodingException {\n            if (value == null) {\n                return null;\n            }\n            return new JSONNumber(value);\n        }\n    };\n    \n    public static final AbstractJsonEncoderDecoder<Short> SHORT = new AbstractJsonEncoderDecoder<Short>() {\n\n        public Short decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (short) toDouble(value);\n        }\n\n        public JSONValue encode(Short value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Integer> INT = new AbstractJsonEncoderDecoder<Integer>() {\n\n        public Integer decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (int) toDouble(value);\n        }\n\n        public JSONValue encode(Integer value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Long> LONG = new AbstractJsonEncoderDecoder<Long>() {\n\n        public Long decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (long) toDouble(value);\n        }\n\n        public JSONValue encode(Long value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Float> FLOAT = new AbstractJsonEncoderDecoder<Float>() {\n\n        public Float decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (float) toDouble(value);\n        }\n\n        public JSONValue encode(Float value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Double> DOUBLE = new AbstractJsonEncoderDecoder<Double>() {\n\n        public Double decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return toDouble(value);\n        }\n\n        public JSONValue encode(Double value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<String> STRING = new AbstractJsonEncoderDecoder<String>() {\n\n        public String decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONString str = value.isString();\n            if (str == null) {\n                throw new DecodingException(\"Expected a json string, but was given: \" + value);\n            }\n            return str.stringValue();\n        }\n\n        public JSONValue encode(String value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<BigDecimal> BIG_DECIMAL = new AbstractJsonEncoderDecoder<BigDecimal>() {\n\n        public BigDecimal decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return toBigDecimal(value);\n        }\n\n        public JSONValue encode(BigDecimal value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value.toString());\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<BigInteger> BIG_INTEGER = new AbstractJsonEncoderDecoder<BigInteger>() {\n\n        public BigInteger decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONNumber number = value.isNumber();\n            if (number == null) {\n                throw new DecodingException(\"Expected a json number, but was given: \" + value);\n            }\n\n            // Doing a straight conversion from string to BigInteger will not work for large values\n            // So we convert to BigDecimal first and then convert it to BigInteger.\n            return new BigDecimal(value.toString()).toBigInteger();\n        }\n\n        public JSONValue encode(BigInteger value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value.toString());\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Document> DOCUMENT = new AbstractJsonEncoderDecoder<Document>() {\n\n        public Document decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONString str = value.isString();\n            if (str == null) {\n                throw new DecodingException(\"Expected a json string, but was given: \" + value);\n            }\n            return XMLParser.parse(str.stringValue());\n        }\n\n        public JSONValue encode(Document value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value.toString());\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<JSONValue> JSON_VALUE = new AbstractJsonEncoderDecoder<JSONValue>() {\n\n        public JSONValue decode(JSONValue value) throws DecodingException {\n            return value;\n        }\n\n        public JSONValue encode(JSONValue value) throws EncodingException {\n            return value;\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Date> DATE = new AbstractJsonEncoderDecoder<Date>() {\n\n        public Date decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            String format = Defaults.getDateFormat();\n            if (format == null) {\n                JSONNumber num = value.isNumber();\n                if (num == null) {\n                    throw new DecodingException(\"Expected a json number, but was given: \" + value);\n                }\n                return new Date((long)num.doubleValue());\n            } else {\n                JSONString str = value.isString();\n                if (str == null) {\n                    throw new DecodingException(\"Expected a json string, but was given: \" + value);\n                }\n                return DateTimeFormat.getFormat(format).parse(str.stringValue());\n            }\n        }\n\n        public JSONValue encode(Date value) throws EncodingException {\n            if (value == null) {\n                return getNullType();\n            }\n            String format = Defaults.getDateFormat();\n            if (format == null) {\n                return new JSONNumber(value.getTime());\n            } else {\n                return new JSONString(DateTimeFormat.getFormat(format).format(value));\n            }\n        }\n    };\n\n    // /////////////////////////////////////////////////////////////////\n    // Helper Methods.\n    // /////////////////////////////////////////////////////////////////\n\n    static public BigDecimal toBigDecimal(JSONValue value) {\n        JSONNumber number = value.isNumber();\n        if (number == null) {\n            throw new DecodingException(\"Expected a json number, but was given: \" + value);\n        }\n        return new BigDecimal(value.toString());\n    }\n\n    static public double toDouble(JSONValue value) {\n        JSONNumber number = value.isNumber();\n        if (number == null) {\n            throw new DecodingException(\"Expected a json number, but was given: \" + value);\n        }\n        return number.doubleValue();\n    }\n\n\n    static public JSONObject toObject(JSONValue value) {\n        JSONObject object = value.isObject();\n        if (object == null) {\n            throw new DecodingException(\"Expected a json object, but was given: \" + object);\n        }\n        return object;\n    }\n\n    static public JSONObject toObject(JSONValue value, String name) {\n        JSONObject object = value.isObject();\n        if (object == null) {\n            throw new DecodingException(\"Expected a json object, but was given: \" + object);\n        }\n        JSONValue result = object.get(name);\n        // if nothing was found under the given name then return null\n        return result == null ? null : toObject(result);\n    }\n\n    static public <Type> List<Type> toList(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = value.isArray();\n        if (array == null) {\n            throw new DecodingException(\"Expected a json array, but was given: \" + value);\n        }\n\n        ArrayList<Type> rc = new ArrayList<Type>(array.size());\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            rc.add(encoder.decode(array.get(i)));\n        }\n        return rc;\n    }\n\n    static public <Type> Set<Type> toSet(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = value.isArray();\n        if (array == null) {\n            throw new DecodingException(\"Expected a json array, but was given: \" + value);\n        }\n\n        HashSet<Type> rc = new HashSet<Type>(array.size() * 2);\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            rc.add(encoder.decode(array.get(i)));\n        }\n        return rc;\n    }\n\n    static public <Type> Map<String, Type> toMap(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder, Style style) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n\n            HashMap<String, Type> rc = new HashMap<String, Type>(object.size() * 2);\n            for (String key : object.keySet()) {\n                rc.put(key, encoder.decode(object.get(key)));\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n            value = object.get(\"entry\");\n            if (value == null) {\n                throw new DecodingException(\"Expected an entry array not found\");\n            }\n            JSONArray entries = value.isArray();\n            if (entries == null) {\n                throw new DecodingException(\"Expected an entry array, but was given: \" + value);\n            }\n\n            HashMap<String, Type> rc = new HashMap<String, Type>(object.size() * 2);\n            for (int i = 0; i < entries.size(); i++) {\n                JSONObject entry = entries.get(i).isObject();\n                if (entry == null)\n                    throw new DecodingException(\"Expected an entry object, but was given: \" + value);\n                JSONValue key = entry.get(\"key\");\n                if (key == null)\n                    throw new DecodingException(\"Expected an entry key field not found\");\n                JSONString k = key.isString();\n                if (k == null)\n                    throw new DecodingException(\"Expected an entry key to be a string, but was given: \" + value);\n\n                rc.put(k.stringValue(), encoder.decode(entry.get(\"value\")));\n            }\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet suppored: \" + style.name());\n        }\n    }\n\n    static public <Type> JSONValue toJSON(Map<String, Type> value, AbstractJsonEncoderDecoder<Type> encoder, Style style) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject rc = new JSONObject();\n            for (Entry<String, Type> t : value.entrySet()) {\n                rc.put(t.getKey(), encoder.encode(t.getValue()));\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject rc = new JSONObject();\n            JSONArray entries = new JSONArray();\n            int i = 0;\n            for (Entry<String, Type> t : value.entrySet()) {\n                JSONObject entry = new JSONObject();\n                entry.put(\"key\", new JSONString(t.getKey()));\n                entry.put(\"value\", encoder.encode(t.getValue()));\n                entries.set(i++, entry);\n            }\n            rc.put(\"entry\", entries);\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet suppored: \" + style.name());\n        }\n    }\n\n    static public <Type> JSONValue toJSON(Collection<Type> value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (Type t : value) {\n            rc.set(i++, encoder.encode(t));\n        }\n        return rc;\n    }\n\n    static private JSONNull getNullType() {\n        return (Defaults.doesIgnoreJsonNulls()) ? null : JSONNull.getInstance();\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2010 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.client;\n\nimport com.google.gwt.i18n.client.DateTimeFormat;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONBoolean;\nimport com.google.gwt.json.client.JSONNull;\nimport com.google.gwt.json.client.JSONNumber;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONString;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.xml.client.Document;\nimport com.google.gwt.xml.client.XMLParser;\n\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\nabstract public class AbstractJsonEncoderDecoder<T> implements JsonEncoderDecoder<T> {\n\n    // /////////////////////////////////////////////////////////////////\n    // Built in encoders for the native types.\n    // /////////////////////////////////////////////////////////////////\n    public static final AbstractJsonEncoderDecoder<Boolean> BOOLEAN = new AbstractJsonEncoderDecoder<Boolean>() {\n\n        public Boolean decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONBoolean bool = value.isBoolean();\n            if (bool == null) {\n                throw new DecodingException(\"Expected a json boolean, but was given: \" + value);\n            }\n            return bool.booleanValue();\n        }\n\n        public JSONValue encode(Boolean value) throws EncodingException {\n            return (value == null) ? getNullType() : JSONBoolean.getInstance(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Character> CHAR = new AbstractJsonEncoderDecoder<Character>() {\n\n        public Character decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (char) toDouble(value);\n        }\n\n        public JSONValue encode(Character value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Byte> BYTE = new AbstractJsonEncoderDecoder<Byte>() {\n\n        public Byte decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (byte) toDouble(value);\n      \n        }\n\n        public JSONValue encode(Byte value) throws EncodingException {\n            if (value == null) {\n                return null;\n            }\n            return new JSONNumber(value);\n        }\n    };\n    \n    public static final AbstractJsonEncoderDecoder<Short> SHORT = new AbstractJsonEncoderDecoder<Short>() {\n\n        public Short decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (short) toDouble(value);\n        }\n\n        public JSONValue encode(Short value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Integer> INT = new AbstractJsonEncoderDecoder<Integer>() {\n\n        public Integer decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (int) toDouble(value);\n        }\n\n        public JSONValue encode(Integer value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Long> LONG = new AbstractJsonEncoderDecoder<Long>() {\n\n        public Long decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (long) toDouble(value);\n        }\n\n        public JSONValue encode(Long value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Float> FLOAT = new AbstractJsonEncoderDecoder<Float>() {\n\n        public Float decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return (float) toDouble(value);\n        }\n\n        public JSONValue encode(Float value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Double> DOUBLE = new AbstractJsonEncoderDecoder<Double>() {\n\n        public Double decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return toDouble(value);\n        }\n\n        public JSONValue encode(Double value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONNumber(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<String> STRING = new AbstractJsonEncoderDecoder<String>() {\n\n        public String decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONString str = value.isString();\n            if (str == null) {\n                throw new DecodingException(\"Expected a json string, but was given: \" + value);\n            }\n            return str.stringValue();\n        }\n\n        public JSONValue encode(String value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value);\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<BigDecimal> BIG_DECIMAL = new AbstractJsonEncoderDecoder<BigDecimal>() {\n\n        public BigDecimal decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            return toBigDecimal(value);\n        }\n\n        public JSONValue encode(BigDecimal value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value.toString());\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<BigInteger> BIG_INTEGER = new AbstractJsonEncoderDecoder<BigInteger>() {\n\n        public BigInteger decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONNumber number = value.isNumber();\n            if (number == null) {\n                throw new DecodingException(\"Expected a json number, but was given: \" + value);\n            }\n\n            // Doing a straight conversion from string to BigInteger will not work for large values\n            // So we convert to BigDecimal first and then convert it to BigInteger.\n            return new BigDecimal(value.toString()).toBigInteger();\n        }\n\n        public JSONValue encode(BigInteger value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value.toString());\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Document> DOCUMENT = new AbstractJsonEncoderDecoder<Document>() {\n\n        public Document decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            JSONString str = value.isString();\n            if (str == null) {\n                throw new DecodingException(\"Expected a json string, but was given: \" + value);\n            }\n            return XMLParser.parse(str.stringValue());\n        }\n\n        public JSONValue encode(Document value) throws EncodingException {\n            return (value == null) ? getNullType() : new JSONString(value.toString());\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<JSONValue> JSON_VALUE = new AbstractJsonEncoderDecoder<JSONValue>() {\n\n        public JSONValue decode(JSONValue value) throws DecodingException {\n            return value;\n        }\n\n        public JSONValue encode(JSONValue value) throws EncodingException {\n            return value;\n        }\n    };\n\n    public static final AbstractJsonEncoderDecoder<Date> DATE = new AbstractJsonEncoderDecoder<Date>() {\n\n        public Date decode(JSONValue value) throws DecodingException {\n            if (value == null || value.isNull() != null) {\n                return null;\n            }\n            String format = Defaults.getDateFormat();\n            if (format == null) {\n                JSONNumber num = value.isNumber();\n                if (num == null) {\n                    throw new DecodingException(\"Expected a json number, but was given: \" + value);\n                }\n                return new Date((long)num.doubleValue());\n            } else {\n                JSONString str = value.isString();\n                if (str == null) {\n                    throw new DecodingException(\"Expected a json string, but was given: \" + value);\n                }\n                return DateTimeFormat.getFormat(format).parse(str.stringValue());\n            }\n        }\n\n        public JSONValue encode(Date value) throws EncodingException {\n            if (value == null) {\n                return getNullType();\n            }\n            String format = Defaults.getDateFormat();\n            if (format == null) {\n                return new JSONNumber(value.getTime());\n            } else {\n                return new JSONString(DateTimeFormat.getFormat(format).format(value));\n            }\n        }\n    };\n\n    // /////////////////////////////////////////////////////////////////\n    // Helper Methods.\n    // /////////////////////////////////////////////////////////////////\n\n    static public BigDecimal toBigDecimal(JSONValue value) {\n        JSONNumber number = value.isNumber();\n        if (number == null) {\n            throw new DecodingException(\"Expected a json number, but was given: \" + value);\n        }\n        return new BigDecimal(value.toString());\n    }\n\n    static public double toDouble(JSONValue value) {\n        JSONNumber number = value.isNumber();\n        if (number == null) {\n            throw new DecodingException(\"Expected a json number, but was given: \" + value);\n        }\n        return number.doubleValue();\n    }\n\n\n    static public JSONObject toObject(JSONValue value) {\n        JSONObject object = value.isObject();\n        if (object == null) {\n            throw new DecodingException(\"Expected a json object, but was given: \" + object);\n        }\n        return object;\n    }\n\n    static public JSONObject toObject(JSONValue value, String name) {\n        JSONObject object = value.isObject();\n        if (object == null) {\n            throw new DecodingException(\"Expected a json object, but was given: \" + object);\n        }\n        return toObject(object.get(name));\n    }\n\n    static public <Type> List<Type> toList(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = value.isArray();\n        if (array == null) {\n            throw new DecodingException(\"Expected a json array, but was given: \" + value);\n        }\n\n        ArrayList<Type> rc = new ArrayList<Type>(array.size());\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            rc.add(encoder.decode(array.get(i)));\n        }\n        return rc;\n    }\n\n    static public <Type> Set<Type> toSet(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n        JSONArray array = value.isArray();\n        if (array == null) {\n            throw new DecodingException(\"Expected a json array, but was given: \" + value);\n        }\n\n        HashSet<Type> rc = new HashSet<Type>(array.size() * 2);\n        int size = array.size();\n        for (int i = 0; i < size; i++) {\n            rc.add(encoder.decode(array.get(i)));\n        }\n        return rc;\n    }\n\n    static public <Type> Map<String, Type> toMap(JSONValue value, AbstractJsonEncoderDecoder<Type> encoder, Style style) {\n        if (value == null || value.isNull() != null) {\n            return null;\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n\n            HashMap<String, Type> rc = new HashMap<String, Type>(object.size() * 2);\n            for (String key : object.keySet()) {\n                rc.put(key, encoder.decode(object.get(key)));\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject object = value.isObject();\n            if (object == null) {\n                throw new DecodingException(\"Expected a json object, but was given: \" + value);\n            }\n            value = object.get(\"entry\");\n            if (value == null) {\n                throw new DecodingException(\"Expected an entry array not found\");\n            }\n            JSONArray entries = value.isArray();\n            if (entries == null) {\n                throw new DecodingException(\"Expected an entry array, but was given: \" + value);\n            }\n\n            HashMap<String, Type> rc = new HashMap<String, Type>(object.size() * 2);\n            for (int i = 0; i < entries.size(); i++) {\n                JSONObject entry = entries.get(i).isObject();\n                if (entry == null)\n                    throw new DecodingException(\"Expected an entry object, but was given: \" + value);\n                JSONValue key = entry.get(\"key\");\n                if (key == null)\n                    throw new DecodingException(\"Expected an entry key field not found\");\n                JSONString k = key.isString();\n                if (k == null)\n                    throw new DecodingException(\"Expected an entry key to be a string, but was given: \" + value);\n\n                rc.put(k.stringValue(), encoder.decode(entry.get(\"value\")));\n            }\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet suppored: \" + style.name());\n        }\n    }\n\n    static public <Type> JSONValue toJSON(Map<String, Type> value, AbstractJsonEncoderDecoder<Type> encoder, Style style) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n\n        switch (style) {\n        case DEFAULT:\n        case SIMPLE: {\n            JSONObject rc = new JSONObject();\n            for (Entry<String, Type> t : value.entrySet()) {\n                rc.put(t.getKey(), encoder.encode(t.getValue()));\n            }\n            return rc;\n        }\n        case JETTISON_NATURAL: {\n            JSONObject rc = new JSONObject();\n            JSONArray entries = new JSONArray();\n            int i = 0;\n            for (Entry<String, Type> t : value.entrySet()) {\n                JSONObject entry = new JSONObject();\n                entry.put(\"key\", new JSONString(t.getKey()));\n                entry.put(\"value\", encoder.encode(t.getValue()));\n                entries.set(i++, entry);\n            }\n            rc.put(\"entry\", entries);\n            return rc;\n        }\n        default:\n            throw new UnsupportedOperationException(\"The encoding style is not yet suppored: \" + style.name());\n        }\n    }\n\n    static public <Type> JSONValue toJSON(Collection<Type> value, AbstractJsonEncoderDecoder<Type> encoder) {\n        if (value == null) {\n            return JSONNull.getInstance();\n        }\n        JSONArray rc = new JSONArray();\n        int i = 0;\n        for (Type t : value) {\n            rc.set(i++, encoder.encode(t));\n        }\n        return rc;\n    }\n\n    static private JSONNull getNullType() {\n        return (Defaults.doesIgnoreJsonNulls()) ? null : JSONNull.getInstance();\n    }\n}\n","lineNo":327}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2010 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.fusesource.restygwt.client.callback;\n\nimport java.util.logging.Logger;\n\nimport org.fusesource.restygwt.client.Method;\n\nimport com.google.gwt.core.client.GWT;\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestBuilder;\nimport com.google.gwt.http.client.RequestCallback;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.http.client.Response;\nimport com.google.gwt.logging.client.LogConfiguration;\nimport com.google.gwt.user.client.Timer;\nimport com.google.gwt.user.client.Window;\n\npublic class RetryingFilterawareRequestCallback extends DefaultFilterawareRequestCallback {\n\n    /**\n     * Used by RetryingCallback\n     * default value is 5\n     */\n    protected int numberOfRetries = 5;\n\n    /**\n     * time to wait for reconnect upon failure\n     */\n    protected int gracePeriod = 1000;\n\n    protected int currentRetryCounter = 0;\n\n    public RetryingFilterawareRequestCallback(Method method) {\n        super(method);\n    }\n\n    public RetryingFilterawareRequestCallback(Method method,\n            int gracePeriodMillis, int numberOfRetries) {\n        super(method);\n        this.gracePeriod = gracePeriodMillis;\n        this.numberOfRetries = numberOfRetries;\n    }\n\n    @Override\n    public final void onResponseReceived(Request request, Response response) {\n        int code = response.getStatusCode();\n        if (!(code < 300 && code >= 200)) {\n            /*\n             * retry only on GET requests that are no redirects (301, 302, 303)\n             */\n            if (code != 301\n                    && code != 302\n                    && code != 303\n                    && code != 404\n                    && (method.builder == null // jsonp method do not have a builder !! \n                            || method.builder.getHTTPMethod().equalsIgnoreCase(\"get\"))) {\n                handleErrorGracefully(request, response, requestCallback);\n            } else {\n                if (LogConfiguration.loggingIsEnabled()) {\n                    Logger.getLogger(RetryingFilterawareRequestCallback.class.getName()).severe(\n                            \"ERROR with non-GET method: \" + method.builder.getHTTPMethod() + \" \"\n                            + method.builder.getUrl() + \", \" + response.getStatusText());\n                }\n\n                /*\n                 *  RuntimeException token from\n                 *  com.google.gwt.http.client.Request#fireOnResponseReceived()\n                 */\n                requestCallback.onError(request, new RuntimeException(\"Response \"\n                        + response.getStatusCode() + \" for \" + method.builder.getHTTPMethod() + \" \"\n                        + method.builder.getUrl()));\n            }\n            return;\n        } else {\n            // filter only in success case for now\n            runFilters(request, response);\n        }\n    }\n\n//    /**\n//     * TODO when is this used ? maybe just forward to requestCallback.onError\n//     */\n//    @Override\n//    public void onError(Request request, Throwable exception) {\n//        if (LogConfiguration.loggingIsEnabled()) {\n//            Logger.getLogger(RetryingFilterawareRequestCallback.class.getName())\n//                    .severe(\"call onError in \" + this.getClass() + \". this should not happen...\");\n//        }\n//        requestCallback.onError(request, exception);\n////        handleErrorGracefully(null, null, null);\n//    }\n\n    public void handleErrorGracefully(Request request, Response response,\n            RequestCallback requestCallback) {\n        // error handling...:\n        if (currentRetryCounter < numberOfRetries) {\n            System.out.println(\"counter \" + currentRetryCounter);\n            if (GWT.isClient() && LogConfiguration.loggingIsEnabled()) {\n                Logger.getLogger(RetryingFilterawareRequestCallback.class.getName()).severe(\n                        \"error handling in progress for: \" + method.builder.getHTTPMethod()\n                        + \" \" + method.builder.getUrl());\n            }\n\n            currentRetryCounter++;\n\n            Timer t = new Timer() {\n                public void run() {\n                    try {\n                        System.out.println(\"run . . .\" + method.builder.getCallback());\n                                    \n                        method.builder.send();\n                    } catch (RequestException ex) {\n                        if (GWT.isClient() && LogConfiguration.loggingIsEnabled()) {\n                            Logger.getLogger(RetryingFilterawareRequestCallback.class.getName())\n                                    .severe(ex.getMessage());\n                        }\n                    }\n                }\n            };\n\n            t.schedule(gracePeriod);\n            gracePeriod = gracePeriod * 2;\n        } else {\n            if (GWT.isClient() && LogConfiguration.loggingIsEnabled()) {\n                Logger.getLogger(RetryingFilterawareRequestCallback.class.getName()).severe(\"Request failed: \"\n                        + method.builder.getHTTPMethod() + \" \" + method.builder.getUrl()\n                        + \" after \" + currentRetryCounter + \" tries.\");\n            }\n\n            if (null != request\n                    && null != response\n                    && null != requestCallback) {\n                // got the original callback, call error here\n                requestCallback.onError(request, new RuntimeException(\"Response \"\n                        + response.getStatusCode() + \" for \" + method.builder.getHTTPMethod() + \" \"\n                        + method.builder.getUrl() + \" after \" + numberOfRetries + \" retries.\"));\n            } else {\n                // got no callback - well, goodbye\n                if (Window.confirm(\"something severly went wrong - error - reload page ?\")) {\n                    // Super severe error.\n                    // reload app or redirect.\n                    // ===> this breaks the app but that's by intention.\n                    Window.Location.reload();\n                }\n            }\n        }\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2010 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.fusesource.restygwt.client.callback;\n\nimport java.util.logging.Logger;\n\nimport org.fusesource.restygwt.client.Method;\n\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestBuilder;\nimport com.google.gwt.http.client.RequestCallback;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.http.client.Response;\nimport com.google.gwt.logging.client.LogConfiguration;\nimport com.google.gwt.user.client.Timer;\nimport com.google.gwt.user.client.Window;\n\npublic class RetryingFilterawareRequestCallback extends DefaultFilterawareRequestCallback {\n\n    /**\n     * Used by RetryingCallback\n     * default value is 5\n     */\n    protected static int numberOfRetries = 5;\n\n    /**\n     * time to wait for reconnect upon failure\n     */\n    protected int gracePeriod = 1000;\n\n    protected int currentRetryCounter = 0;\n\n    public RetryingFilterawareRequestCallback(Method method) {\n        super(method);\n    }\n\n    @Override\n    public final void onResponseReceived(Request request, Response response) {\n        if (!(response.getStatusCode() < 300 && response.getStatusCode() >= 200)) {\n            /*\n             * retry only on GET requests that are no redirects (301, 302)\n             */\n            if (response.getStatusCode() != 301\n                    && response.getStatusCode() != 302\n                    && response.getStatusCode() != 404\n                    && method.builder.getHTTPMethod().equals(RequestBuilder.GET.toString())) {\n                handleErrorGracefully(request, response, requestCallback);\n            } else {\n                if (LogConfiguration.loggingIsEnabled()) {\n                    Logger.getLogger(RetryingFilterawareRequestCallback.class.getName()).severe(\n                            \"ERROR with non-GET method: \" + method.builder.getHTTPMethod() + \" \"\n                            + method.builder.getUrl() + \", \" + response.getStatusText());\n                }\n\n                /*\n                 *  RuntimeException token from\n                 *  com.google.gwt.http.client.Request#fireOnResponseReceived()\n                 */\n                requestCallback.onError(request, new RuntimeException(\"Response \"\n                        + response.getStatusCode() + \" for \" + method.builder.getHTTPMethod() + \" \"\n                        + method.builder.getUrl()));\n            }\n            return;\n        } else {\n            // filter only in success case for now\n            runFilters(request, response);\n        }\n    }\n\n    /**\n     * TODO when is this used ? maybe just forward to requestCallback.onError\n     */\n    @Override\n    public void onError(Request request, Throwable exception) {\n        if (LogConfiguration.loggingIsEnabled()) {\n            Logger.getLogger(RetryingFilterawareRequestCallback.class.getName())\n                    .severe(\"call onError in \" + this.getClass() + \". this should not happen...\");\n        }\n        handleErrorGracefully(null, null, null);\n    }\n\n    public void handleErrorGracefully(Request request, Response response,\n            RequestCallback requestCallback) {\n        // error handling...:\n        if (currentRetryCounter < numberOfRetries) {\n            if (LogConfiguration.loggingIsEnabled()) {\n                Logger.getLogger(RetryingFilterawareRequestCallback.class.getName()).severe(\n                        \"error handling in progress for: \" + method.builder.getHTTPMethod()\n                        + \" \" + method.builder.getUrl());\n            }\n\n            currentRetryCounter++;\n\n            Timer t = new Timer() {\n                public void run() {\n                    try {\n                        method.builder.send();\n                    } catch (RequestException ex) {\n                        if (LogConfiguration.loggingIsEnabled()) {\n                            Logger.getLogger(RetryingFilterawareRequestCallback.class.getName())\n                                    .severe(ex.getMessage());\n                        }\n                    }\n                }\n            };\n\n            t.schedule(gracePeriod);\n            gracePeriod = gracePeriod * 2;\n        } else {\n            if (LogConfiguration.loggingIsEnabled()) {\n                Logger.getLogger(RetryingFilterawareRequestCallback.class.getName()).severe(\"Request failed: \"\n                        + method.builder.getHTTPMethod() + \" \" + method.builder.getUrl()\n                        + \" after \" + currentRetryCounter + \" tries.\");\n            }\n\n            if (null != request\n                    && null != response\n                    && null != requestCallback) {\n                // got the original callback, call error here\n                requestCallback.onError(request, new RuntimeException(\"Response \"\n                        + response.getStatusCode() + \" for \" + method.builder.getHTTPMethod() + \" \"\n                        + method.builder.getUrl() + \" after \" + numberOfRetries + \" retries.\"));\n            } else {\n                // got no callback - well, goodbye\n                if (Window.confirm(\"error - reload page ?\")) {\n                    // Super severe error.\n                    // reload app or redirect.\n                    // ===> this breaks the app but that's by intention.\n                    Window.Location.reload();\n                }\n            }\n        }\n    }\n}\n","lineNo":62}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2010 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport com.google.gwt.core.client.*;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.*;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.user.client.rpc.RemoteServiceRelativePath;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport com.google.gwt.xml.client.Document;\nimport org.fusesource.restygwt.client.*;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport javax.ws.rs.*;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\nimport java.util.regex.Pattern;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added automatically create resource from Path annotation,\n *         enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\npublic class RestServiceClassCreator extends BaseSourceCreator {\n\n    private static final String REST_SERVICE_PROXY_SUFFIX = \"_Generated_RestServiceProxy_\";\n\n    private static final String METHOD_CLASS = Method.class.getName();\n    private static final String RESOURCE_CLASS = Resource.class.getName();\n    private static final String DISPATCHER_CLASS = Dispatcher.class.getName();\n    private static final String DEFAULTS_CLASS = Defaults.class.getName();\n    private static final String ABSTRACT_REQUEST_CALLBACK_CLASS = AbstractRequestCallback.class.getName();\n    private static final String ABSTRACT_ASYNC_CALLBACK_CLASS = AbstractAsyncCallback.class.getName();\n    private static final String JSON_PARSER_CLASS = JSONParser.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String REQUEST_EXCEPTION_CLASS = RequestException.class.getName();\n    private static final String RESPONSE_FORMAT_EXCEPTION_CLASS = ResponseFormatException.class.getName();\n    private static final String JSONP_METHOD_CLASS = JsonpMethod.class.getName();\n\n    /*\n     * static class in which are some compile-time relevant infos.\n     *\n     * TODO (andi): too much flexibility and overhead with reflection here?\n     */\n    private static final Class<BindingDefaults> BINDING_DEFAULTS = BindingDefaults.class;\n\n    private static final String METHOD_JSONP = \"jsonp\";\n    private static final String METHOD_PUT = \"put\";\n    private static final String METHOD_POST = \"post\";\n    private static final String METHOD_OPTIONS = \"options\";\n    private static final String METHOD_HEAD = \"head\";\n    private static final String METHOD_GET = \"get\";\n    private static final String METHOD_DELETE = \"delete\";\n\n    private static final HashSet<String> REST_METHODS = new HashSet<String>(8);\n    static {\n        REST_METHODS.add(METHOD_DELETE);\n        REST_METHODS.add(METHOD_GET);\n        REST_METHODS.add(METHOD_HEAD);\n        REST_METHODS.add(METHOD_OPTIONS);\n        REST_METHODS.add(METHOD_POST);\n        REST_METHODS.add(METHOD_PUT);\n        REST_METHODS.add(METHOD_JSONP);\n    }\n\n    private JClassType XML_CALLBACK_TYPE;\n    private JClassType METHOD_CALLBACK_TYPE;\n    private JClassType TEXT_CALLBACK_TYPE;\n    private JClassType JSON_CALLBACK_TYPE;\n    private JClassType OVERLAY_CALLBACK_TYPE;\n    private JClassType DOCUMENT_TYPE;\n    private JClassType METHOD_TYPE;\n    private JClassType STRING_TYPE;\n    private JClassType JSON_VALUE_TYPE;\n    private JClassType OVERLAY_VALUE_TYPE;\n    private Set<JClassType> OVERLAY_ARRAY_TYPES;\n    private Set<JClassType> QUERY_PARAM_LIST_TYPES;\n    private JsonEncoderDecoderInstanceLocator locator;\n\n    public RestServiceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n        super(logger, context, source, REST_SERVICE_PROXY_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n        composerFactory.addImplementedInterface(source.getName());\n        composerFactory.addImplementedInterface(RestServiceProxy.class.getName());\n        return composerFactory;\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n\n        if (source.isInterface() == null) {\n            error(\"Type is not an interface.\");\n        }\n\n        locator = new JsonEncoderDecoderInstanceLocator(context, logger);\n\n        this.XML_CALLBACK_TYPE = find(XmlCallback.class);\n        this.METHOD_CALLBACK_TYPE = find(MethodCallback.class);\n        this.TEXT_CALLBACK_TYPE = find(TextCallback.class);\n        this.JSON_CALLBACK_TYPE = find(JsonCallback.class);\n        this.OVERLAY_CALLBACK_TYPE = find(OverlayCallback.class);\n        this.DOCUMENT_TYPE = find(Document.class);\n        this.METHOD_TYPE = find(Method.class);\n        this.STRING_TYPE = find(String.class);\n        this.JSON_VALUE_TYPE = find(JSONValue.class);\n        this.OVERLAY_VALUE_TYPE = find(JavaScriptObject.class);\n        this.OVERLAY_ARRAY_TYPES = new HashSet<JClassType>();\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArray.class));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayBoolean.class));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayInteger.class));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayNumber.class));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayString.class));\n        this.QUERY_PARAM_LIST_TYPES = new HashSet<JClassType>();\n        this.QUERY_PARAM_LIST_TYPES.add(find(List.class));\n        this.QUERY_PARAM_LIST_TYPES.add(find(Set.class));\n\n        String path = null;\n        Path pathAnnotation = source.getAnnotation(Path.class);\n        if (pathAnnotation != null) {\n            path = pathAnnotation.value();\n        }\n\n        RemoteServiceRelativePath relativePath = source.getAnnotation(RemoteServiceRelativePath.class);\n        if (relativePath != null) {\n            path = relativePath.value();\n        }\n\n        if (path == null) {\n            p(\"private \" + RESOURCE_CLASS + \" resource = new \" + RESOURCE_CLASS + \"(\" + DEFAULTS_CLASS + \".getServiceRoot());\");\n        } else {\n            p(\"private \" + RESOURCE_CLASS + \" resource = new \" + RESOURCE_CLASS + \"(\" + DEFAULTS_CLASS + \".getServiceRoot()).resolve(\"+quote(path)+\");\");\n        }\n        p();\n\n        p(\"public void setResource(\" + RESOURCE_CLASS + \" resource) {\").i(1);\n        {\n            p(\"this.resource = resource;\");\n        }\n        i(-1).p(\"}\");\n\n\n        Options options = source.getAnnotation(Options.class);\n        if( options!=null && options.dispatcher()!=Dispatcher.class ) {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = \"+options.dispatcher().getName()+\".INSTANCE;\");\n        } else {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = \"+DEFAULTS_CLASS+\".getDispatcher();\");\n        }\n\n        p();\n        p(\"public void setDispatcher(\" + DISPATCHER_CLASS + \" dispatcher) {\").i(1);\n        {\n            p(\"this.dispatcher = dispatcher;\");\n        }\n        i(-1).p(\"}\");\n\n        for (JMethod method : source.getInheritableMethods()) {\n            writeMethodImpl(method);\n        }\n    }\n\n    private String quote(String path) {\n        // TODO: unlikely to occur. but we should escape chars like newlines..\n        return \"\\\"\" + path + \"\\\"\";\n    }\n\n    private boolean isOverlayArrayType(JClassType type) {\n        for (JClassType arrayType : OVERLAY_ARRAY_TYPES) {\n            if (type.isAssignableTo(arrayType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isQueryParamListType(JClassType type) {\n        if (type.isParameterized() == null) {\n            return false;\n        }\n        for (JClassType listType : QUERY_PARAM_LIST_TYPES) {\n            if (type.isAssignableTo(listType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void writeMethodImpl(JMethod method) throws UnableToCompleteException {\n        if (method.getReturnType().isPrimitive() != JPrimitiveType.VOID) {\n            error(\"Invalid rest method. Method must have void return type: \" + method.getReadableDeclaration());\n        }\n\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n\n        Options classOptions = source.getAnnotation(Options.class);\n        Options options = method.getAnnotation(Options.class);\n\n        p(method.getReadableDeclaration(false, false, false, false, true) + \" {\").i(1);\n        {\n            String restMethod = getRestMethod(method);\n            LinkedList<JParameter> args = new LinkedList<JParameter>(Arrays.asList(method.getParameters()));\n\n            // the last arg should be the callback.\n            if (args.isEmpty()) {\n                error(\"Invalid rest method. Method must declare at least a callback argument: \" + method.getReadableDeclaration());\n            }\n            JParameter callbackArg = args.removeLast();\n            JClassType callbackType = callbackArg.getType().isClassOrInterface();\n            JClassType methodCallbackType = METHOD_CALLBACK_TYPE;\n            if (callbackType == null || !callbackType.isAssignableTo(methodCallbackType)) {\n                error(\"Invalid rest method. Last argument must be a \" + methodCallbackType.getName() + \" type: \" + method.getReadableDeclaration());\n            }\n            JClassType resultType = getCallbackTypeGenericClass(callbackType);\n\n            String pathExpression = null;\n            Path pathAnnotation = method.getAnnotation(Path.class);\n            if (pathAnnotation != null) {\n                pathExpression = wrap(pathAnnotation.value());\n            }\n\n            JParameter contentArg = null;\n            HashMap<String, JParameter> queryParams = new HashMap<String, JParameter>();\n            HashMap<String, JParameter> headerParams = new HashMap<String, JParameter>();\n\n            for (JParameter arg : args) {\n                PathParam paramPath = arg.getAnnotation(PathParam.class);\n                if (paramPath != null) {\n                    if (pathExpression == null) {\n                        error(\"Invalid rest method.  Invalid @PathParam annotation. Method is missing the @Path annotation: \" + method.getReadableDeclaration());\n                    }\n                    pathExpression = pathExpression.replaceAll(Pattern.quote(\"{\" + paramPath.value() + \"}\"), \"\\\"+\" + toStringExpression(arg) + \"+\\\"\");\n                    continue;\n                }\n\n                QueryParam queryParam = arg.getAnnotation(QueryParam.class);\n                if (queryParam != null) {\n                    queryParams.put(queryParam.value(), arg);\n                    continue;\n                }\n\n                HeaderParam headerParam = arg.getAnnotation(HeaderParam.class);\n                if (headerParam != null) {\n                    headerParams.put(headerParam.value(), arg);\n                    continue;\n                }\n\n                if (contentArg != null) {\n                    error(\"Invalid rest method. Only one content parameter is supported: \" + method.getReadableDeclaration());\n                }\n                contentArg = arg;\n            }\n\n            String acceptTypeBuiltIn = null;\n            if (callbackType.equals(TEXT_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_TEXT\";\n            } else if (callbackType.equals(JSON_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.isAssignableTo(OVERLAY_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.equals(XML_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_XML\";\n            }\n\n            p(\"final \" + METHOD_CLASS + \" __method =\");\n\n            p(\"this.resource\");\n            if (pathExpression != null) {\n                p(\".resolve(\" + pathExpression + \")\");\n            }\n            for (Map.Entry<String, JParameter> entry : queryParams.entrySet()) {\n                String expr = entry.getValue().getName();\n                JClassType type = entry.getValue().getType().isClassOrInterface();\n                if (type != null && isQueryParamListType(type)) {\n                    p(\".addQueryParams(\" + wrap(entry.getKey()) + \", \" +\n                      toIteratedStringExpression(entry.getValue()) + \")\");\n                } else {\n                    p(\".addQueryParam(\" + wrap(entry.getKey()) + \", \" +\n                      toStringExpression(entry.getValue().getType(), expr) + \")\");\n                }\n            }\n            // example: .get()\n            p(\".\" + restMethod + \"();\");\n\n            // Handle JSONP specific configuration...\n            JSONP jsonpAnnotation = method.getAnnotation(JSONP.class);\n\n            final boolean isJsonp = restMethod.equals(METHOD_JSONP) && jsonpAnnotation!=null;\n            if( isJsonp ) {\n                if( jsonpAnnotation.callbackParam().length() > 0 ) {\n                    p(\"((\"+JSONP_METHOD_CLASS+\")__method).callbackParam(\"+wrap(jsonpAnnotation.callbackParam())+\");\");\n                }\n                if( jsonpAnnotation.failureCallbackParam().length() > 0 ) {\n                    p(\"((\"+JSONP_METHOD_CLASS+\")__method).failureCallbackParam(\"+wrap(jsonpAnnotation.failureCallbackParam())+\");\");\n                }\n            }\n\n            // configure the dispatcher\n            if( options!=null && options.dispatcher()!=Dispatcher.class ) {\n                // use the dispatcher configured for the method.\n                p(\"__method.setDispatcher(\"+options.dispatcher().getName()+\".INSTANCE);\");\n            } else {\n                // use the default dispatcher configured for the service..\n                p(\"__method.setDispatcher(this.dispatcher);\");\n            }\n\n            // configure the expected statuses..\n            if( options!=null && options.expect().length!=0 ) {\n                // Using method level defined expected status\n                p(\"__method.expect(\"+join(options.expect(), \", \")+\");\");\n            } else if( classOptions!=null && classOptions.expect().length!=0 ) {\n                // Using class level defined expected status\n                p(\"__method.expect(\"+join(classOptions.expect(), \", \")+\");\");\n            }\n\n            // configure the timeout\n            if( options!=null && options.timeout() >= 0 ) {\n                // Using method level defined value\n                p(\"__method.timeout(\"+options.timeout()+\");\");\n            } else if( classOptions!=null && classOptions.timeout() >= 0 ) {\n                // Using class level defined value\n                p(\"__method.timeout(\"+classOptions.timeout()+\");\");\n            }\n\n            if(jsonpAnnotation == null) {\n                Produces producesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Produces.class);\n                if (producesAnnotation != null) {\n                    p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \"+wrap(producesAnnotation.value()[0])+\");\");\n                } else {\n                    // set the default accept header....\n                    if (acceptTypeBuiltIn != null) {\n                        p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \" + RESOURCE_CLASS + \".\" + acceptTypeBuiltIn + \");\");\n                    } else {\n                        p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \" + RESOURCE_CLASS + \".CONTENT_TYPE_JSON);\");\n                    }\n                }\n\n                Consumes consumesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Consumes.class);\n                if (consumesAnnotation != null) {\n                    p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_CONTENT_TYPE, \"+wrap(consumesAnnotation.value()[0])+\");\");\n                }\n\n                // and set the explicit headers now (could override the accept header)\n                for (Map.Entry<String, JParameter> entry : headerParams.entrySet()) {\n                    String expr = entry.getValue().getName();\n                    p(\"__method.header(\" + wrap(entry.getKey()) + \", \" + toStringExpression(entry.getValue().getType(), expr) + \");\");\n                }\n            }\n\n            if (contentArg != null) {\n                if (contentArg.getType() == STRING_TYPE) {\n                    p(\"__method.text(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType() == JSON_VALUE_TYPE) {\n                    p(\"__method.json(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType().isClass() != null &&\n                           isOverlayArrayType(contentArg.getType().isClass())) {\n                    p(\"__method.json(new \" + JSON_ARRAY_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType().isClass() != null &&\n                           contentArg.getType().isClass().isAssignableTo(OVERLAY_VALUE_TYPE)) {\n                    p(\"__method.json(new \" + JSON_OBJECT_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType() == DOCUMENT_TYPE) {\n                    p(\"__method.xml(\" + contentArg.getName() + \");\");\n                } else {\n                    JClassType contentClass = contentArg.getType().isClass();\n                    if (contentClass == null) {\n                        contentClass = contentArg.getType().isClassOrInterface();\n                        if (!locator.isCollectionType(contentClass)) {\n                            error(\"Content argument must be a class.\");\n                        }\n                    }\n\n                    jsonAnnotation = contentArg.getAnnotation(Json.class);\n                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n                    // example:\n                    // .json(Listings$_Generated_JsonEncoder_$.INSTANCE.encode(arg0)\n                    // )\n                    p(\"__method.json(\" + locator.encodeExpression(contentClass, contentArg.getName(), style) + \");\");\n                }\n            }\n\n\n            List<AnnotationResolver> annotationResolvers = getAnnotationResolvers(context, logger);\n            logger.log(TreeLogger.DEBUG, \"found \" + annotationResolvers.size() + \" additional AnnotationResolvers\");\n\n            for (AnnotationResolver a : annotationResolvers) {\n                logger.log(TreeLogger.DEBUG, \"(\" + a.getClass().getName() + \") resolve `\" + source.getName()\n                        + \"#\" + method.getName() + \" ...\");\n                final Map<String, String[]> addDataParams = a.resolveAnnotation(logger, source, method, restMethod);\n\n                if (addDataParams != null) {\n                    for (String s : addDataParams.keySet()) {\n                        final StringBuilder sb = new StringBuilder();\n                        final List<String> classList = Arrays.asList(addDataParams.get(s));\n\n                        sb.append(\"[\");\n                        for (int i = 0; i < classList.size(); ++i) {\n                            sb.append(\"\\\\\\\"\").append(classList.get(i)).append(\"\\\\\\\"\");\n\n                            if ((i+1) <  classList.size()) {\n                                sb.append(\",\");\n                            }\n                        }\n                        sb.append(\"]\");\n\n                        logger.log(TreeLogger.DEBUG, \"add call with (\\\"\" + s + \"\\\", \\\"\" +\n                                sb.toString() + \"\\\")\");\n                        p(\"__method.addData(\\\"\" + s + \"\\\", \\\"\" + sb.toString() + \"\\\");\");\n                    }\n                }\n            }\n\n\n            if (acceptTypeBuiltIn != null) {\n                p(\"__method.send(\" + callbackArg.getName() + \");\");\n            } else if ( isJsonp ){\n                    p(\"((\" + JSONP_METHOD_CLASS + \")__method).send(new \" + ABSTRACT_ASYNC_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">((\" + JSONP_METHOD_CLASS + \")__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult(\" + JSON_OBJECT_CLASS + \" result) throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) new java.lang.Object();\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    jsonAnnotation = method.getAnnotation(Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, \"result\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n            } else {\n                p(\"try {\").i(1);\n                {\n                    p(\"__method.send(new \" + ABSTRACT_REQUEST_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">(__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult() throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) new java.lang.Object();\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    jsonAnnotation = method.getAnnotation(Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, JSON_PARSER_CLASS + \".parse(__method.getResponse().getText())\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n                }\n                i(-1).p(\"} catch (\" + REQUEST_EXCEPTION_CLASS + \" __e) {\").i(1);\n                {\n                    p(callbackArg.getName() + \".onFailure(__method,__e);\");\n                }\n                i(-1).p(\"}\");\n            }\n        }\n        i(-1).p(\"}\");\n    }\n\n    private <T extends Annotation> T findAnnotationOnMethodOrEnclosingType(final JMethod method, final Class<T> annotationType) {\n        T annotation = method.getAnnotation(annotationType);\n        if (annotation == null) {\n            annotation = method.getEnclosingType().getAnnotation(annotationType);\n        }\n        return annotation;\n    }\n\n    protected String toStringExpression(JParameter arg) {\n        Attribute attribute = arg.getAnnotation(Attribute.class);\n        if(attribute != null){\n            return arg.getName() + \".\" + attribute.value();\n        }\n        return toStringExpression(arg.getType(), arg.getName());\n    }\n\n    protected String toStringExpression(JType type, String expr) {\n        if (type.isPrimitive() != null) {\n            return \"\\\"\\\"+\" + expr;\n        }\n        if (STRING_TYPE == type) {\n            return expr;\n        }\n        if (type.isClass() != null &&\n            isOverlayArrayType(type.isClass())) {\n          return \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.isClass() != null &&\n            OVERLAY_VALUE_TYPE.isAssignableFrom(type.isClass())) {\n          return \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        }\n\n        return expr + \".toString()\";\n    }\n\n    protected String toIteratedStringExpression(JParameter arg) {\n        StringBuilder result = new StringBuilder();\n        result.append(\"new org.fusesource.restygwt.client.StringIterable (\")\n            .append(arg.getName()).append(\")\");\n\n        return result.toString();\n    }\n\n    private JClassType getCallbackTypeGenericClass(final JClassType callbackType) throws UnableToCompleteException {\n        return branch(\"getCallbackTypeGenericClass()\", new Branch<JClassType>() {\n            public JClassType execute() throws UnableToCompleteException {\n\n                for (JMethod method : callbackType.getOverridableMethods()) {\n                    debug(\"checking method: \" + method.getName());\n                    if (method.getName().equals(\"onSuccess\")) {\n                        JParameter[] parameters = method.getParameters();\n                        debug(\"checking method params: \" + parameters.length);\n                        if (parameters.length == 2) {\n                            debug(\"checking first param: \" + parameters[0].getType());\n                            if (parameters[0].getType() == METHOD_TYPE) {\n                                debug(\"checking 2nd param: \" + parameters[1].getType());\n                                JType param2Type = parameters[1].getType();\n                                JClassType type = param2Type.isClassOrInterface();\n                                if (type == null) {\n                                    error(\"The type of the callback not supported: \" + param2Type.getJNISignature());\n                                }\n                                debug(\"match: \" + type);\n                                return type;\n                            }\n                        }\n                    }\n                }\n                error(\"The type of the callback could not be determined: \" + callbackType.getParameterizedQualifiedSourceName());\n                return null;\n\n            }\n        });\n    }\n\n    private String getRestMethod(JMethod method) throws UnableToCompleteException {\n        String restMethod = null;\n        if (method.getAnnotation(DELETE.class) != null) {\n            restMethod = METHOD_DELETE;\n        } else if (method.getAnnotation(GET.class) != null) {\n            restMethod = METHOD_GET;\n        } else if (method.getAnnotation(HEAD.class) != null) {\n            restMethod = METHOD_HEAD;\n        } else if (method.getAnnotation(OPTIONS.class) != null) {\n            restMethod = METHOD_OPTIONS;\n        } else if (method.getAnnotation(POST.class) != null) {\n            restMethod = METHOD_POST;\n        } else if (method.getAnnotation(PUT.class) != null) {\n            restMethod = METHOD_PUT;\n        } else if (method.getAnnotation(JSONP.class) != null) {\n            restMethod = METHOD_JSONP;\n        } else {\n            restMethod = method.getName();\n            if (!REST_METHODS.contains(restMethod)) {\n                error(\"Invalid rest method. It must either have a lower case rest method name or have a javax rs method annotation: \" + method.getReadableDeclaration());\n            }\n        }\n        return restMethod;\n    }\n\n    /**\n     * access additional AnnotationResolvers possibly added by\n     *\n     * {@link BindingDefaults#addAnnotationResolver(AnnotationResolver)}\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    private List<AnnotationResolver> getAnnotationResolvers(final GeneratorContext context, final TreeLogger logger) {\n        java.lang.reflect.Method m = null;\n        ArrayList args = new ArrayList();\n        ArrayList types = new ArrayList();\n\n        types.add(GeneratorContext.class);\n        args.add(context);\n        types.add(TreeLogger.class);\n        args.add(logger);\n\n        Object[] argValues = args.toArray();\n        Class[] argtypes = (Class[]) types.toArray(new Class[argValues.length]);\n\n        try {\n             m = BINDING_DEFAULTS.getMethod(\"getAnnotationResolvers\", argtypes);\n        } catch (SecurityException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"could not resolve method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        List<AnnotationResolver> l = new ArrayList<AnnotationResolver>();\n        try {\n             Object[] params = new Object[]{context};\n\n            l = (List<AnnotationResolver>) m.invoke(null, context, logger);\n        } catch (IllegalArgumentException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (InvocationTargetException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        return l;\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2010 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport com.google.gwt.core.client.*;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.*;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.json.client.JSONArray;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.user.client.rpc.RemoteServiceRelativePath;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport com.google.gwt.xml.client.Document;\nimport org.fusesource.restygwt.client.*;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport javax.ws.rs.*;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\nimport java.util.regex.Pattern;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n *\n *         Updates: added automatically create resource from Path annotation,\n *         enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\npublic class RestServiceClassCreator extends BaseSourceCreator {\n\n    private static final String REST_SERVICE_PROXY_SUFFIX = \"_Generated_RestServiceProxy_\";\n\n    private static final String METHOD_CLASS = Method.class.getName();\n    private static final String RESOURCE_CLASS = Resource.class.getName();\n    private static final String DISPATCHER_CLASS = Dispatcher.class.getName();\n    private static final String DEFAULTS_CLASS = Defaults.class.getName();\n    private static final String ABSTRACT_REQUEST_CALLBACK_CLASS = AbstractRequestCallback.class.getName();\n    private static final String JSON_PARSER_CLASS = JSONParser.class.getName();\n    private static final String JSON_ARRAY_CLASS = JSONArray.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n    private static final String REQUEST_EXCEPTION_CLASS = RequestException.class.getName();\n    private static final String RESPONSE_FORMAT_EXCEPTION_CLASS = ResponseFormatException.class.getName();\n    private static final String JSONP_METHOD_CLASS = JsonpMethod.class.getName();\n\n    /*\n     * static class in which are some compile-time relevant infos.\n     *\n     * TODO (andi): too much flexibility and overhead with reflection here?\n     */\n    private static final Class<BindingDefaults> BINDING_DEFAULTS = BindingDefaults.class;\n\n    private static final String METHOD_JSONP = \"jsonp\";\n    private static final String METHOD_PUT = \"put\";\n    private static final String METHOD_POST = \"post\";\n    private static final String METHOD_OPTIONS = \"options\";\n    private static final String METHOD_HEAD = \"head\";\n    private static final String METHOD_GET = \"get\";\n    private static final String METHOD_DELETE = \"delete\";\n\n    private static final HashSet<String> REST_METHODS = new HashSet<String>(8);\n    static {\n        REST_METHODS.add(METHOD_DELETE);\n        REST_METHODS.add(METHOD_GET);\n        REST_METHODS.add(METHOD_HEAD);\n        REST_METHODS.add(METHOD_OPTIONS);\n        REST_METHODS.add(METHOD_POST);\n        REST_METHODS.add(METHOD_PUT);\n        REST_METHODS.add(METHOD_JSONP);\n    }\n\n    private JClassType XML_CALLBACK_TYPE;\n    private JClassType METHOD_CALLBACK_TYPE;\n    private JClassType TEXT_CALLBACK_TYPE;\n    private JClassType JSON_CALLBACK_TYPE;\n    private JClassType OVERLAY_CALLBACK_TYPE;\n    private JClassType DOCUMENT_TYPE;\n    private JClassType METHOD_TYPE;\n    private JClassType STRING_TYPE;\n    private JClassType JSON_VALUE_TYPE;\n    private JClassType OVERLAY_VALUE_TYPE;\n    private Set<JClassType> OVERLAY_ARRAY_TYPES;\n    private Set<JClassType> QUERY_PARAM_LIST_TYPES;\n    private JsonEncoderDecoderInstanceLocator locator;\n\n    public RestServiceClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n        super(logger, context, source, REST_SERVICE_PROXY_SUFFIX);\n    }\n\n    @Override\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n        composerFactory.addImplementedInterface(source.getName());\n        composerFactory.addImplementedInterface(RestServiceProxy.class.getName());\n        return composerFactory;\n    }\n\n    @Override\n    protected void generate() throws UnableToCompleteException {\n\n        if (source.isInterface() == null) {\n            error(\"Type is not an interface.\");\n        }\n\n        locator = new JsonEncoderDecoderInstanceLocator(context, logger);\n\n        this.XML_CALLBACK_TYPE = find(XmlCallback.class);\n        this.METHOD_CALLBACK_TYPE = find(MethodCallback.class);\n        this.TEXT_CALLBACK_TYPE = find(TextCallback.class);\n        this.JSON_CALLBACK_TYPE = find(JsonCallback.class);\n        this.OVERLAY_CALLBACK_TYPE = find(OverlayCallback.class);\n        this.DOCUMENT_TYPE = find(Document.class);\n        this.METHOD_TYPE = find(Method.class);\n        this.STRING_TYPE = find(String.class);\n        this.JSON_VALUE_TYPE = find(JSONValue.class);\n        this.OVERLAY_VALUE_TYPE = find(JavaScriptObject.class);\n        this.OVERLAY_ARRAY_TYPES = new HashSet<JClassType>();\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArray.class));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayBoolean.class));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayInteger.class));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayNumber.class));\n        this.OVERLAY_ARRAY_TYPES.add(find(JsArrayString.class));\n        this.QUERY_PARAM_LIST_TYPES = new HashSet<JClassType>();\n        this.QUERY_PARAM_LIST_TYPES.add(find(List.class));\n        this.QUERY_PARAM_LIST_TYPES.add(find(Set.class));\n\n        String path = null;\n        Path pathAnnotation = source.getAnnotation(Path.class);\n        if (pathAnnotation != null) {\n            path = pathAnnotation.value();\n        }\n\n        RemoteServiceRelativePath relativePath = source.getAnnotation(RemoteServiceRelativePath.class);\n        if (relativePath != null) {\n            path = relativePath.value();\n        }\n\n        if (path == null) {\n            p(\"private \" + RESOURCE_CLASS + \" resource = new \" + RESOURCE_CLASS + \"(\" + DEFAULTS_CLASS + \".getServiceRoot());\");\n        } else {\n            p(\"private \" + RESOURCE_CLASS + \" resource = new \" + RESOURCE_CLASS + \"(\" + DEFAULTS_CLASS + \".getServiceRoot()).resolve(\"+quote(path)+\");\");\n        }\n        p();\n\n        p(\"public void setResource(\" + RESOURCE_CLASS + \" resource) {\").i(1);\n        {\n            p(\"this.resource = resource;\");\n        }\n        i(-1).p(\"}\");\n\n\n        Options options = source.getAnnotation(Options.class);\n        if( options!=null && options.dispatcher()!=Dispatcher.class ) {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = \"+options.dispatcher().getName()+\".INSTANCE;\");\n        } else {\n            p(\"private \" + DISPATCHER_CLASS + \" dispatcher = \"+DEFAULTS_CLASS+\".getDispatcher();\");\n        }\n\n        p();\n        p(\"public void setDispatcher(\" + DISPATCHER_CLASS + \" dispatcher) {\").i(1);\n        {\n            p(\"this.dispatcher = dispatcher;\");\n        }\n        i(-1).p(\"}\");\n\n        for (JMethod method : source.getInheritableMethods()) {\n            writeMethodImpl(method);\n        }\n    }\n\n    private String quote(String path) {\n        // TODO: unlikely to occur. but we should escape chars like newlines..\n        return \"\\\"\" + path + \"\\\"\";\n    }\n\n    private boolean isOverlayArrayType(JClassType type) {\n        for (JClassType arrayType : OVERLAY_ARRAY_TYPES) {\n            if (type.isAssignableTo(arrayType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isQueryParamListType(JClassType type) {\n        if (type.isParameterized() == null) {\n            return false;\n        }\n        for (JClassType listType : QUERY_PARAM_LIST_TYPES) {\n            if (type.isAssignableTo(listType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void writeMethodImpl(JMethod method) throws UnableToCompleteException {\n        if (method.getReturnType().isPrimitive() != JPrimitiveType.VOID) {\n            error(\"Invalid rest method. Method must have void return type: \" + method.getReadableDeclaration());\n        }\n\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation != null ? jsonAnnotation.style() : Style.DEFAULT;\n\n        Options classOptions = source.getAnnotation(Options.class);\n        Options options = method.getAnnotation(Options.class);\n\n        p(method.getReadableDeclaration(false, false, false, false, true) + \" {\").i(1);\n        {\n            String restMethod = getRestMethod(method);\n            LinkedList<JParameter> args = new LinkedList<JParameter>(Arrays.asList(method.getParameters()));\n\n            // the last arg should be the callback.\n            if (args.isEmpty()) {\n                error(\"Invalid rest method. Method must declare at least a callback argument: \" + method.getReadableDeclaration());\n            }\n            JParameter callbackArg = args.removeLast();\n            JClassType callbackType = callbackArg.getType().isClassOrInterface();\n            JClassType methodCallbackType = METHOD_CALLBACK_TYPE;\n            if (callbackType == null || !callbackType.isAssignableTo(methodCallbackType)) {\n                error(\"Invalid rest method. Last argument must be a \" + methodCallbackType.getName() + \" type: \" + method.getReadableDeclaration());\n            }\n            JClassType resultType = getCallbackTypeGenericClass(callbackType);\n\n            String pathExpression = null;\n            Path pathAnnotation = method.getAnnotation(Path.class);\n            if (pathAnnotation != null) {\n                pathExpression = wrap(pathAnnotation.value());\n            }\n\n            JParameter contentArg = null;\n            HashMap<String, JParameter> queryParams = new HashMap<String, JParameter>();\n            HashMap<String, JParameter> headerParams = new HashMap<String, JParameter>();\n\n            for (JParameter arg : args) {\n                PathParam paramPath = arg.getAnnotation(PathParam.class);\n                if (paramPath != null) {\n                    if (pathExpression == null) {\n                        error(\"Invalid rest method.  Invalid @PathParam annotation. Method is missing the @Path annotation: \" + method.getReadableDeclaration());\n                    }\n                    pathExpression = pathExpression.replaceAll(Pattern.quote(\"{\" + paramPath.value() + \"}\"), \"\\\"+\" + toStringExpression(arg) + \"+\\\"\");\n                    continue;\n                }\n\n                QueryParam queryParam = arg.getAnnotation(QueryParam.class);\n                if (queryParam != null) {\n                    queryParams.put(queryParam.value(), arg);\n                    continue;\n                }\n\n                HeaderParam headerParam = arg.getAnnotation(HeaderParam.class);\n                if (headerParam != null) {\n                    headerParams.put(headerParam.value(), arg);\n                    continue;\n                }\n\n                if (contentArg != null) {\n                    error(\"Invalid rest method. Only one content parameter is supported: \" + method.getReadableDeclaration());\n                }\n                contentArg = arg;\n            }\n\n            String acceptTypeBuiltIn = null;\n            if (callbackType.equals(TEXT_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_TEXT\";\n            } else if (callbackType.equals(JSON_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.isAssignableTo(OVERLAY_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_JSON\";\n            } else if (callbackType.equals(XML_CALLBACK_TYPE)) {\n                acceptTypeBuiltIn = \"CONTENT_TYPE_XML\";\n            }\n\n            p(\"final \" + METHOD_CLASS + \" __method =\");\n\n            p(\"this.resource\");\n            if (pathExpression != null) {\n                p(\".resolve(\" + pathExpression + \")\");\n            }\n            for (Map.Entry<String, JParameter> entry : queryParams.entrySet()) {\n                String expr = entry.getValue().getName();\n                JClassType type = entry.getValue().getType().isClassOrInterface();\n                if (type != null && isQueryParamListType(type)) {\n                    p(\".addQueryParams(\" + wrap(entry.getKey()) + \", \" +\n                      toIteratedStringExpression(entry.getValue()) + \")\");\n                } else {\n                    p(\".addQueryParam(\" + wrap(entry.getKey()) + \", \" +\n                      toStringExpression(entry.getValue().getType(), expr) + \")\");\n                }\n            }\n            // example: .get()\n            p(\".\" + restMethod + \"();\");\n\n            // Handle JSONP specific configuration...\n            JSONP jsonpAnnotation = method.getAnnotation(JSONP.class);\n\n            if( restMethod.equals(METHOD_JSONP) && jsonpAnnotation!=null ) {\n                if( jsonpAnnotation.callbackParam().length() > 0 ) {\n                    p(\"((\"+JSONP_METHOD_CLASS+\")__method).callbackParam(\"+wrap(jsonpAnnotation.callbackParam())+\");\");\n                }\n                if( jsonpAnnotation.failureCallbackParam().length() > 0 ) {\n                    p(\"((\"+JSONP_METHOD_CLASS+\")__method).failureCallbackParam(\"+wrap(jsonpAnnotation.failureCallbackParam())+\");\");\n                }\n            }\n\n            // configure the dispatcher\n            if( options!=null && options.dispatcher()!=Dispatcher.class ) {\n                // use the dispatcher configured for the method.\n                p(\"__method.setDispatcher(\"+options.dispatcher().getName()+\".INSTANCE);\");\n            } else {\n                // use the default dispatcher configured for the service..\n                p(\"__method.setDispatcher(this.dispatcher);\");\n            }\n\n            // configure the expected statuses..\n            if( options!=null && options.expect().length!=0 ) {\n                // Using method level defined expected status\n                p(\"__method.expect(\"+join(options.expect(), \", \")+\");\");\n            } else if( classOptions!=null && classOptions.expect().length!=0 ) {\n                // Using class level defined expected status\n                p(\"__method.expect(\"+join(classOptions.expect(), \", \")+\");\");\n            }\n\n            // configure the timeout\n            if( options!=null && options.timeout() >= 0 ) {\n                // Using method level defined value\n                p(\"__method.timeout(\"+options.timeout()+\");\");\n            } else if( classOptions!=null && classOptions.timeout() >= 0 ) {\n                // Using class level defined value\n                p(\"__method.timeout(\"+classOptions.timeout()+\");\");\n            }\n\n            if(jsonpAnnotation == null) {\n                Produces producesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Produces.class);\n                if (producesAnnotation != null) {\n                    p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \"+wrap(producesAnnotation.value()[0])+\");\");\n                } else {\n                    // set the default accept header....\n                    if (acceptTypeBuiltIn != null) {\n                        p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \" + RESOURCE_CLASS + \".\" + acceptTypeBuiltIn + \");\");\n                    } else {\n                        p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_ACCEPT, \" + RESOURCE_CLASS + \".CONTENT_TYPE_JSON);\");\n                    }\n                }\n\n                Consumes consumesAnnotation = findAnnotationOnMethodOrEnclosingType(method, Consumes.class);\n                if (consumesAnnotation != null) {\n                    p(\"__method.header(\" + RESOURCE_CLASS + \".HEADER_CONTENT_TYPE, \"+wrap(consumesAnnotation.value()[0])+\");\");\n                }\n\n                // and set the explicit headers now (could override the accept header)\n                for (Map.Entry<String, JParameter> entry : headerParams.entrySet()) {\n                    String expr = entry.getValue().getName();\n                    p(\"__method.header(\" + wrap(entry.getKey()) + \", \" + toStringExpression(entry.getValue().getType(), expr) + \");\");\n                }\n            }\n\n            if (contentArg != null) {\n                if (contentArg.getType() == STRING_TYPE) {\n                    p(\"__method.text(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType() == JSON_VALUE_TYPE) {\n                    p(\"__method.json(\" + contentArg.getName() + \");\");\n                } else if (contentArg.getType().isClass() != null &&\n                           isOverlayArrayType(contentArg.getType().isClass())) {\n                    p(\"__method.json(new \" + JSON_ARRAY_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType().isClass() != null &&\n                           contentArg.getType().isClass().isAssignableTo(OVERLAY_VALUE_TYPE)) {\n                    p(\"__method.json(new \" + JSON_OBJECT_CLASS + \"(\" + contentArg.getName() + \"));\");\n                } else if (contentArg.getType() == DOCUMENT_TYPE) {\n                    p(\"__method.xml(\" + contentArg.getName() + \");\");\n                } else {\n                    JClassType contentClass = contentArg.getType().isClass();\n                    if (contentClass == null) {\n                        contentClass = contentArg.getType().isClassOrInterface();\n                        if (!locator.isCollectionType(contentClass)) {\n                            error(\"Content argument must be a class.\");\n                        }\n                    }\n\n                    jsonAnnotation = contentArg.getAnnotation(Json.class);\n                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n\n                    // example:\n                    // .json(Listings$_Generated_JsonEncoder_$.INSTANCE.encode(arg0)\n                    // )\n                    p(\"__method.json(\" + locator.encodeExpression(contentClass, contentArg.getName(), style) + \");\");\n                }\n            }\n\n\n            List<AnnotationResolver> annotationResolvers = getAnnotationResolvers(context, logger);\n            logger.log(TreeLogger.DEBUG, \"found \" + annotationResolvers.size() + \" additional AnnotationResolvers\");\n\n            for (AnnotationResolver a : annotationResolvers) {\n                logger.log(TreeLogger.DEBUG, \"(\" + a.getClass().getName() + \") resolve `\" + source.getName()\n                        + \"#\" + method.getName() + \" ...\");\n                final Map<String, String[]> addDataParams = a.resolveAnnotation(logger, source, method, restMethod);\n\n                if (addDataParams != null) {\n                    for (String s : addDataParams.keySet()) {\n                        final StringBuilder sb = new StringBuilder();\n                        final List<String> classList = Arrays.asList(addDataParams.get(s));\n\n                        sb.append(\"[\");\n                        for (int i = 0; i < classList.size(); ++i) {\n                            sb.append(\"\\\\\\\"\").append(classList.get(i)).append(\"\\\\\\\"\");\n\n                            if ((i+1) <  classList.size()) {\n                                sb.append(\",\");\n                            }\n                        }\n                        sb.append(\"]\");\n\n                        logger.log(TreeLogger.DEBUG, \"add call with (\\\"\" + s + \"\\\", \\\"\" +\n                                sb.toString() + \"\\\")\");\n                        p(\"__method.addData(\\\"\" + s + \"\\\", \\\"\" + sb.toString() + \"\\\");\");\n                    }\n                }\n            }\n\n\n            if (acceptTypeBuiltIn != null) {\n                p(\"__method.send(\" + callbackArg.getName() + \");\");\n            } else {\n                p(\"try {\").i(1);\n                {\n                    p(\n                            \"__method.send(new \" + ABSTRACT_REQUEST_CALLBACK_CLASS + \"<\" + resultType.getParameterizedQualifiedSourceName() + \">(__method, \"\n                                    + callbackArg.getName() + \") {\").i(1);\n                    {\n                        p(\"protected \" + resultType.getParameterizedQualifiedSourceName() + \" parseResult() throws Exception {\").i(1);\n                        {\n                            if(resultType.getParameterizedQualifiedSourceName().equals(\"java.lang.Void\")) {\n                                p(\"return (java.lang.Void) new java.lang.Object();\");\n                            }\n                            else {\n                                p(\"try {\").i(1);\n                                {\n                                    jsonAnnotation = method.getAnnotation(Json.class);\n                                    Style style = jsonAnnotation != null ? jsonAnnotation.style() : classStyle;\n                                    p(\"return \" + locator.decodeExpression(resultType, JSON_PARSER_CLASS + \".parse(__method.getResponse().getText())\", style) + \";\");\n                                }\n                                i(-1).p(\"} catch (Throwable __e) {\").i(1);\n                                {\n                                    p(\"throw new \" + RESPONSE_FORMAT_EXCEPTION_CLASS + \"(\\\"Response was NOT a valid JSON document\\\", __e);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                        }\n                        i(-1).p(\"}\");\n                    }\n                    i(-1).p(\"});\");\n                }\n                i(-1).p(\"} catch (\" + REQUEST_EXCEPTION_CLASS + \" __e) {\").i(1);\n                {\n                    p(callbackArg.getName() + \".onFailure(__method,__e);\");\n                }\n                i(-1).p(\"}\");\n            }\n        }\n        i(-1).p(\"}\");\n    }\n\n    private <T extends Annotation> T findAnnotationOnMethodOrEnclosingType(final JMethod method, final Class<T> annotationType) {\n        T annotation = method.getAnnotation(annotationType);\n        if (annotation == null) {\n            annotation = method.getEnclosingType().getAnnotation(annotationType);\n        }\n        return annotation;\n    }\n\n    protected String toStringExpression(JParameter arg) {\n        Attribute attribute = arg.getAnnotation(Attribute.class);\n        if(attribute != null){\n            return arg.getName() + \".\" + attribute.value();\n        }\n        return toStringExpression(arg.getType(), arg.getName());\n    }\n\n    protected String toStringExpression(JType type, String expr) {\n        if (type.isPrimitive() != null) {\n            return \"\\\"\\\"+\" + expr;\n        }\n        if (STRING_TYPE == type) {\n            return expr;\n        }\n        if (type.isClass() != null &&\n            isOverlayArrayType(type.isClass())) {\n          return \"(new \" + JSON_ARRAY_CLASS + \"(\" + expr + \")).toString()\";\n        }\n        if (type.isClass() != null &&\n            OVERLAY_VALUE_TYPE.isAssignableFrom(type.isClass())) {\n          return \"(new \" + JSON_OBJECT_CLASS + \"(\" + expr + \")).toString()\";\n        }\n\n        return expr + \".toString()\";\n    }\n\n    protected String toIteratedStringExpression(JParameter arg) {\n        StringBuilder result = new StringBuilder();\n        result.append(\"new org.fusesource.restygwt.client.StringIterable (\")\n            .append(arg.getName()).append(\")\");\n\n        return result.toString();\n    }\n\n    private JClassType getCallbackTypeGenericClass(final JClassType callbackType) throws UnableToCompleteException {\n        return branch(\"getCallbackTypeGenericClass()\", new Branch<JClassType>() {\n            public JClassType execute() throws UnableToCompleteException {\n\n                for (JMethod method : callbackType.getOverridableMethods()) {\n                    debug(\"checking method: \" + method.getName());\n                    if (method.getName().equals(\"onSuccess\")) {\n                        JParameter[] parameters = method.getParameters();\n                        debug(\"checking method params: \" + parameters.length);\n                        if (parameters.length == 2) {\n                            debug(\"checking first param: \" + parameters[0].getType());\n                            if (parameters[0].getType() == METHOD_TYPE) {\n                                debug(\"checking 2nd param: \" + parameters[1].getType());\n                                JType param2Type = parameters[1].getType();\n                                JClassType type = param2Type.isClassOrInterface();\n                                if (type == null) {\n                                    error(\"The type of the callback not supported: \" + param2Type.getJNISignature());\n                                }\n                                debug(\"match: \" + type);\n                                return type;\n                            }\n                        }\n                    }\n                }\n                error(\"The type of the callback could not be determined: \" + callbackType.getParameterizedQualifiedSourceName());\n                return null;\n\n            }\n        });\n    }\n\n    private String getRestMethod(JMethod method) throws UnableToCompleteException {\n        String restMethod = null;\n        if (method.getAnnotation(DELETE.class) != null) {\n            restMethod = METHOD_DELETE;\n        } else if (method.getAnnotation(GET.class) != null) {\n            restMethod = METHOD_GET;\n        } else if (method.getAnnotation(HEAD.class) != null) {\n            restMethod = METHOD_HEAD;\n        } else if (method.getAnnotation(OPTIONS.class) != null) {\n            restMethod = METHOD_OPTIONS;\n        } else if (method.getAnnotation(POST.class) != null) {\n            restMethod = METHOD_POST;\n        } else if (method.getAnnotation(PUT.class) != null) {\n            restMethod = METHOD_PUT;\n        } else if (method.getAnnotation(JSONP.class) != null) {\n            restMethod = METHOD_JSONP;\n        } else {\n            restMethod = method.getName();\n            if (!REST_METHODS.contains(restMethod)) {\n                error(\"Invalid rest method. It must either have a lower case rest method name or have a javax rs method annotation: \" + method.getReadableDeclaration());\n            }\n        }\n        return restMethod;\n    }\n\n    /**\n     * access additional AnnotationResolvers possibly added by\n     *\n     * {@link BindingDefaults#addAnnotationResolver(AnnotationResolver)}\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    private List<AnnotationResolver> getAnnotationResolvers(final GeneratorContext context, final TreeLogger logger) {\n        java.lang.reflect.Method m = null;\n        ArrayList args = new ArrayList();\n        ArrayList types = new ArrayList();\n\n        types.add(GeneratorContext.class);\n        args.add(context);\n        types.add(TreeLogger.class);\n        args.add(logger);\n\n        Object[] argValues = args.toArray();\n        Class[] argtypes = (Class[]) types.toArray(new Class[argValues.length]);\n\n        try {\n             m = BINDING_DEFAULTS.getMethod(\"getAnnotationResolvers\", argtypes);\n        } catch (SecurityException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"could not resolve method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        List<AnnotationResolver> l = new ArrayList<AnnotationResolver>();\n        try {\n             Object[] params = new Object[]{context};\n\n            l = (List<AnnotationResolver>) m.invoke(null, context, logger);\n        } catch (IllegalArgumentException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        } catch (InvocationTargetException e) {\n            throw new RuntimeException(\"could not call method `getAnnotationResolvers on \"\n                    + BINDING_DEFAULTS, e);\n        }\n\n        return l;\n    }\n}\n","lineNo":319}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2010 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.fusesource.restygwt.client.dispatcher;\n\nimport java.util.logging.Logger;\n\nimport org.fusesource.restygwt.client.Dispatcher;\nimport org.fusesource.restygwt.client.FilterawareRequestCallback;\nimport org.fusesource.restygwt.client.Method;\nimport org.fusesource.restygwt.client.cache.QueueableCacheStorage;\nimport org.fusesource.restygwt.client.callback.CallbackFactory;\nimport org.fusesource.restygwt.client.callback.FilterawareRetryingCallback;\n\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestBuilder;\nimport com.google.gwt.http.client.RequestCallback;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.http.client.Response;\nimport com.google.gwt.logging.client.LogConfiguration;\n\n/**\n * Some valuable ideas came from:\n * http://turbomanage.wordpress.com/2010/07/12/caching-batching-dispatcher-for-gwt-dispatch/\n * <p/>\n * Thanks David!\n * <p/>\n * Especially: - Waiting if a particular request is already on the way\n * (otherwise you end up having many requests on the same source.\n *\n * @author <a href=\"mailto:mail@raphaelbauer.com\">rEyez<\/<a>\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n */\npublic class CachingRetryingDispatcher implements Dispatcher {\n\n    private static CachingRetryingDispatcher INSTANCE = null;\n\n    /**\n     * where to get a callback from. gives us the ability to use\n     * customized {@link FilterawareRequestCallback}\n     */\n    private CallbackFactory callbackFactory;\n\n    /**\n     * one instance of {@link QueueableCacheStorage}\n     */\n    private QueueableCacheStorage cacheStorage;\n\n    /**\n     * get one instance of this class\n     *\n     * @param cacheStorage the one and only {@link QueueableCacheStorage} for this instance\n     * @param cf CallbackFactory to be able to use {@link FilterawareRetryingCallback}\n     * @return\n     */\n    public static CachingRetryingDispatcher singleton(QueueableCacheStorage cacheStorage,\n            CallbackFactory cf) {\n        if (null != INSTANCE) return INSTANCE;\n\n        INSTANCE = new CachingRetryingDispatcher();\n        INSTANCE.cacheStorage = cacheStorage;\n        INSTANCE.setCallbackFactory(cf);\n        return INSTANCE;\n    }\n\n    public Request send(Method method, RequestBuilder builder) throws RequestException {\n        final RequestCallback outerRequestCallback = builder.getCallback();\n        final CacheKey cacheKey = new CacheKey(builder);\n        final Response cachedResponse = cacheStorage.getResultOrReturnNull(cacheKey);\n        final boolean cachable = builder.getHTTPMethod().equals(RequestBuilder.GET.toString());\n\n        if (cachable == true) {\n            if (cachedResponse != null) {\n                //case 1: we got a result in cache => return it...\n                outerRequestCallback.onResponseReceived(null, cachedResponse);\n                return null;\n            }  else {\n                final RequestCallback retryingCallback = callbackFactory.createCallback(method);\n\n                //case 2: => no cache in result => queue it....\n                if (!cacheStorage.hasCallback(cacheKey)) {\n                    //case 2.1 => first callback => make a new one and execute...\n                    cacheStorage.addCallback(cacheKey, outerRequestCallback);\n\n                    if (LogConfiguration.loggingIsEnabled()) {\n                        Logger.getLogger(Dispatcher.class.getName())\n                                .info(\"Sending *caching* http request: \" + builder.getHTTPMethod() + \" \"\n                                + builder.getUrl());\n                    }\n\n                    // important part:\n                    builder.setCallback(retryingCallback);\n                    return builder.send();\n                } else {\n                    //case 2.2 => a callback already in progress => queue to get response when back\n                    cacheStorage.addCallback(cacheKey, retryingCallback);\n                    return null;\n                }\n            }\n        } else {\n            // non cachable case\n            if (LogConfiguration.loggingIsEnabled()) {\n                String content = builder.getRequestData();\n                Logger.getLogger(Dispatcher.class.getName())\n                        .info(\"Sending *non-caching* http request: \" + builder.getHTTPMethod() + \" \"\n                        + builder.getUrl() + \" (Content: `\" + content + \")\");\n            }\n\n            builder.setCallback(callbackFactory.createCallback(method));\n            return builder.send();\n        }\n    }\n\n    /**\n     * set the callbackFactory once on creation. non-public with purpose as this is\n     * an immutable field.\n     *\n     * @param callbackFactory\n     */\n    private void setCallbackFactory(CallbackFactory callbackFactory) {\n        this.callbackFactory = callbackFactory;\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2010 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.fusesource.restygwt.client.dispatcher;\n\nimport java.util.logging.Logger;\n\nimport org.fusesource.restygwt.client.Dispatcher;\nimport org.fusesource.restygwt.client.FilterawareRequestCallback;\nimport org.fusesource.restygwt.client.Method;\nimport org.fusesource.restygwt.client.cache.QueueableCacheStorage;\nimport org.fusesource.restygwt.client.callback.CallbackFactory;\nimport org.fusesource.restygwt.client.callback.FilterawareRetryingCallback;\n\nimport com.google.gwt.core.client.Scheduler;\nimport com.google.gwt.core.client.Scheduler.ScheduledCommand;\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestBuilder;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.http.client.Response;\nimport com.google.gwt.logging.client.LogConfiguration;\n\n/**\n * Some valuable ideas came from:\n * http://turbomanage.wordpress.com/2010/07/12/caching-batching-dispatcher-for-gwt-dispatch/\n * <p/>\n * Thanks David!\n * <p/>\n * Especially: - Waiting if a particular request is already on the way\n * (otherwise you end up having many requests on the same source.\n *\n * @author <a href=\"mailto:mail@raphaelbauer.com\">rEyez<\/<a>\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n */\npublic class CachingRetryingDispatcher implements Dispatcher {\n\n    private static CachingRetryingDispatcher INSTANCE = null;\n\n    /**\n     * where to get a callback from. gives us the ability to use\n     * customized {@link FilterawareRequestCallback}\n     */\n    private CallbackFactory callbackFactory;\n\n    /**\n     * one instance of {@link QueueableCacheStorage}\n     */\n    private QueueableCacheStorage cacheStorage;\n\n    /**\n     * get one instance of this class\n     *\n     * @param cacheStorage the one and only {@link QueueableCacheStorage} for this instance\n     * @param cf CallbackFactory to be able to use {@link FilterawareRetryingCallback}\n     * @return\n     */\n    public static CachingRetryingDispatcher singleton(QueueableCacheStorage cacheStorage,\n            CallbackFactory cf) {\n        if (null != INSTANCE) return INSTANCE;\n\n        INSTANCE = new CachingRetryingDispatcher();\n        INSTANCE.cacheStorage = cacheStorage;\n        INSTANCE.setCallbackFactory(cf);\n        return INSTANCE;\n    }\n\n    public Request send(Method method, final RequestBuilder builder) throws RequestException {\n        final CacheKey cacheKey = new CacheKey(builder);\n        final Response cachedResponse = cacheStorage.getResultOrReturnNull(cacheKey);\n\n        if (cachedResponse != null) {\n            if (LogConfiguration.loggingIsEnabled()) {\n                Logger.getLogger(CachingRetryingDispatcher.class.getName()).severe(\n                        \"Got a cache result for \" + cacheKey + \": \" + cachedResponse);\n            }\n\n            Scheduler.get().scheduleDeferred(new ScheduledCommand() {\n                @Override\n                public void execute() {\n                    builder.getCallback().onResponseReceived(null, cachedResponse);\n                }\n            });\n            return null;\n        } else {\n            if (LogConfiguration.loggingIsEnabled()) {\n                Logger.getLogger(CachingRetryingDispatcher.class.getName()).severe(\n                        \"No cache for \" + cacheKey +  \", sending http request: \"\n                        + builder.getHTTPMethod() + \" \" + builder.getUrl() + \" ,timeout:\"\n                        + builder.getTimeoutMillis() + \" content: \\\"\" + builder.getRequestData()\n                        + \"\\\"\");\n            }\n\n            builder.setCallback(callbackFactory.createCallback(method));\n            return builder.send();\n        }\n    }\n\n    /**\n     * set the callbackFactory once on creation. non-public with purpose as this is\n     * an immutable field.\n     *\n     * @param callbackFactory\n     */\n    private void setCallbackFactory(CallbackFactory callbackFactory) {\n        this.callbackFactory = callbackFactory;\n    }\n}\n","lineNo":117}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2010 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.client.cache;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\nimport org.fusesource.restygwt.client.dispatcher.CacheKey;\n\nimport com.google.gwt.core.client.GWT;\nimport com.google.gwt.http.client.RequestCallback;\nimport com.google.gwt.http.client.Response;\nimport com.google.gwt.user.client.Timer;\n\npublic class QueuableRuntimeCacheStorage implements QueueableCacheStorage {\n    /**\n     * how long will a cachekey be allowed to exist\n     */\n    private static final long DEFAULT_LIFETIME_MS = 30 * 1000;\n\n    /**\n     * key <> value hashmap for holding cache values. nothing special here.\n     *\n     * invalidated values will be dropped by timer\n     */\n    private final Map<String, HashMap<CacheKey, Response>> cache =\n            new HashMap<String, HashMap<CacheKey, Response>>();\n\n    private final Map<CacheKey, List<RequestCallback>> pendingCallbacks\n            = new HashMap<CacheKey, List<RequestCallback>>();\n\n    public Response getResultOrReturnNull(CacheKey key) {\n        return getResultOrReturnNull(key, \"\");\n    }\n\n    public Response getResultOrReturnNull(final CacheKey key, final String scope) {\n        final HashMap<CacheKey, Response> scoped = cache.get(scope);\n\n        if (null != scoped) {\n            return scoped.get(key);\n        }\n\n        return null;\n    }\n\n    @Override\n    public void putResult(final CacheKey key, final Response response) {\n        putResult(key, response, \"\");\n    }\n\n    public void putResult(final CacheKey key, final Response response, final String scope) {\n        Timer t = new Timer() {\n            public void run() {\n                try {\n                    GWT.log(\"removing cache-key \" + key.getEverythingAsConcatenatedString()\n                            + \" from scope \\\"\" + scope + \"\\\"\");\n                    cache.get(scope).remove(key);\n                } catch (Exception ex) {\n                    Logger.getLogger(QueuableRuntimeCacheStorage.class.getName())\n                            .severe(ex.getMessage());\n                }\n            }\n        };\n        t.schedule((int) DEFAULT_LIFETIME_MS);\n\n        HashMap<CacheKey, Response> scoped = cache.get(scope);\n\n        if (null != scoped) {\n            cache.put(scope, new HashMap<CacheKey, Response>());\n            scoped = cache.get(scope);\n        }\n\n        scoped.put(key, response);\n    }\n\n    @Override\n    public boolean hasCallback(final CacheKey k) {\n        return pendingCallbacks.containsKey(k);\n    }\n\n    @Override\n    public void addCallback(final CacheKey k, final RequestCallback rc) {\n        //init value of key if not there...\n        if (!pendingCallbacks.containsKey(k)) {\n            pendingCallbacks.put(k, new ArrayList<RequestCallback>());\n        }\n\n        pendingCallbacks.get(k).add(rc);\n    }\n\n    @Override\n    public List<RequestCallback> removeCallbacks(final CacheKey k) {\n        return pendingCallbacks.remove(k);\n    }\n\n    @Override\n    public void purge() {\n        cache.clear();\n    }\n\n    @Override\n    public void purge(final String scope) {\n        HashMap<CacheKey, Response> scoped = cache.get(scope);\n\n        if(null != scoped) scoped.clear();\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2010 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.client.cache;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\nimport org.fusesource.restygwt.client.dispatcher.CacheKey;\n\nimport com.google.gwt.core.client.GWT;\nimport com.google.gwt.http.client.RequestCallback;\nimport com.google.gwt.http.client.Response;\nimport com.google.gwt.user.client.Timer;\n\npublic class QueuableRuntimeCacheStorage implements QueueableCacheStorage {\n    /**\n     * how long will a cachekey be allowed to exist\n     */\n    private static final long DEFAULT_LIFETIME_MS = 30 * 1000;\n\n    /**\n     * key <> value hashmap for holding cache values. nothing special here.\n     *\n     * invalidated values will be dropped by timer\n     */\n    private final HashMap<CacheKey, Response> cache = new HashMap<CacheKey, Response>();\n\n    private final Map<CacheKey, List<RequestCallback>> pendingCallbacks\n            = new HashMap<CacheKey, List<RequestCallback>>();\n\n    public Response getResultOrReturnNull(CacheKey key) {\n        Response val = cache.get(key);\n\n        return val;\n    }\n\n    public void putResult(final CacheKey key, Response response) {\n        Timer t = new Timer() {\n            public void run() {\n                try {\n                    GWT.log(\"removing cache-key \" + key.getEverythingAsConcatenatedString()\n                            + \" from internal storage\");\n                    cache.remove(key);\n                } catch (Exception ex) {\n                    Logger.getLogger(QueuableRuntimeCacheStorage.class.getName())\n                            .severe(ex.getMessage());\n                }\n            }\n        };\n        t.schedule((int) DEFAULT_LIFETIME_MS);\n        cache.put(key, response);\n    }\n\n    @Override\n    public boolean hasCallback(CacheKey k) {\n        return pendingCallbacks.containsKey(k);\n    }\n\n    @Override\n    public void addCallback(CacheKey k, RequestCallback rc) {\n        //init value of key if not there...\n        if (!pendingCallbacks.containsKey(k)) {\n            pendingCallbacks.put(k, new ArrayList<RequestCallback>());\n        }\n\n        pendingCallbacks.get(k).add(rc);\n    }\n\n    @Override\n    public List<RequestCallback> removeCallbacks(CacheKey k) {\n        return pendingCallbacks.remove(k);\n    }\n}\n","lineNo":85}
{"Refactored Sample":"/**\n * Copyright (C) 2009-2010 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport com.google.gwt.core.ext.Generator;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\n\n/**\n *\n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n */\npublic class RestServiceGenerator extends Generator {\n\n    @Override\n    public String generate(TreeLogger logger, GeneratorContext context, String source) throws UnableToCompleteException {\n        try {\n            JClassType restService = find(logger, context, source);\n            RestServiceClassCreator generator = new RestServiceClassCreator(logger, context, restService);\n\n            String generated = generator.create();\n            return generated;\n        } finally {\n            BaseSourceCreator.clearGeneratedClasses();\n        }\n    }\n\n    static JClassType find(TreeLogger logger, GeneratorContext context, String type) throws UnableToCompleteException {\n        JClassType rc = context.getTypeOracle().findType(type);\n        if (rc == null) {\n            logger.log(TreeLogger.ERROR, \"TypeOracle could not find \" + type);\n            throw new UnableToCompleteException();\n        }\n        return rc;\n    }\n\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009-2010 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.fusesource.restygwt.rebind;\n\nimport com.google.gwt.core.ext.Generator;\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n */\npublic class RestServiceGenerator extends Generator {\n\n    @Override\n    public String generate(TreeLogger logger, GeneratorContext context, String source) throws UnableToCompleteException {\n        try {\n            JClassType restService = find(logger, context, source);\n            RestServiceClassCreator generator = new RestServiceClassCreator(logger, context, restService);\n            return generator.create();\n        } finally {\n            BaseSourceCreator.clearGeneratedClasses();\n        }\n    }\n\n    static JClassType find(TreeLogger logger, GeneratorContext context, String type) throws UnableToCompleteException {\n        JClassType rc = context.getTypeOracle().findType(type);\n        if (rc == null) {\n            logger.log(TreeLogger.ERROR, \"TypeOracle could not find \" + type);\n            throw new UnableToCompleteException();\n        }\n        return rc;\n    }\n\n}\n","lineNo":39}
{"Refactored Sample":"/**\n * Copyright (C) 2010, Progress Software Corporation and/or its \n * subsidiaries or affiliates.  All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.fusesource.restygwt.rebind;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * \n * Updates:\n * added getter & setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n\tprivate String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n\tprivate static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n\tprivate static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n\n\tJsonEncoderDecoderInstanceLocator locator;\n\t\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n        composerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n        return composerFactory;\n    }\n\n    public void generate() throws UnableToCompleteException {\n        \n    \tlocator = new JsonEncoderDecoderInstanceLocator(context, logger);\n    \t\n        JClassType soruceClazz = source.isClass();\n        if (soruceClazz == null) {\n            error(\"Type is not a class\");\n        }\n        if (!soruceClazz.isDefaultInstantiable()) {\n            error(\"No default constuctor\");\n        }\n\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation!=null ? jsonAnnotation.style() : Style.DEFAULT;\n\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n\n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n\t\t\tp(\"if( value==null ) {\").i(1); {\n        \t\tp(\"return null;\");\n\t\t\t} i(-1).p(\"}\");         \n        \tp(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n\n            for (final JField field : getFields(source)) {\n\n                final String getterName = getGetterName(field);\n                \n                // If can ignore some fields right off the back..\n                if (getterName == null && (field.isStatic() || field.isFinal() || field.isTransient())) {\n                    continue;\n                }\n                \n                branch(\"Processing field: \" + field.getName(), new Branch<Void>(){\n                    public Void execute() throws UnableToCompleteException {\n                        // TODO: try to get the field with a setter or JSNI\n                        if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                            Json jsonAnnotation = field.getAnnotation(Json.class);\n\n                            String name = field.getName();\n                            String jsonName = name;\n\n                            if( jsonAnnotation !=null && jsonAnnotation.name().length() > 0  ) {\n                                jsonName = jsonAnnotation.name();\n                            }\n\n                            String fieldExpr = \"value.\" + name;\n                            if(getterName != null){\n                                fieldExpr = \"value.\" + getterName+\"()\";\n                            }\n                            \n                            Style style = jsonAnnotation!=null ? jsonAnnotation.style() : classStyle;\n                            \n                            String expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n\n                            p(\"{\").i(1);\n                            {\n                                p(JSON_VALUE_CLASS + \" v=\" + expression + \";\");\n                                p(\"if( v!=null ) {\").i(1);\n                                {\n                                    p(\"rc.put(\" + wrap(jsonName) + \", v);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                            i(-1).p(\"}\");\n                            \n                        } else {\n                            error(\"field must not be private: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                        }\n                        return null;\n                    }\n                });\n\n            }\n\n            p(\"return rc;\");\n        }\n        i(-1).p(\"}\");\n        p();\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            p(\"\" + source.getParameterizedQualifiedSourceName() + \" rc = new \" + source.getParameterizedQualifiedSourceName() + \"();\");\n            for (final JField field : getFields(source)) {\n\n                final String setterName = getSetterName(field);\n                \n                // If can ignore some fields right off the back..\n                if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient())) {\n                    continue;\n                }\n                \n                branch(\"Processing field: \" + field.getName(), new Branch<Void>(){\n                    public Void execute() throws UnableToCompleteException {\n\n                        // TODO: try to set the field with a setter or JSNI\n                       if (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                            Json jsonAnnotation = field.getAnnotation(Json.class);\n                            Style style = jsonAnnotation!=null ? jsonAnnotation.style() : classStyle;\n\n                            String name = field.getName();\n                            String jsonName = field.getName();\n\n                            if( jsonAnnotation !=null && jsonAnnotation.name().length() > 0  ) {\n                                jsonName = jsonAnnotation.name();\n                            }\n\n                            String objectGetter = \"object.get(\" + wrap(jsonName) + \")\";\n                            String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n                        \n                            p(\"if(\" + objectGetter + \" != null) {\").i(1);\n                            if (setterName != null) {\n                                p(\"rc.\" + setterName + \"(\" + expression+ \");\");\n                            } else {\n                            \tp(\"rc.\" + name + \"=\" + expression + \";\");\n                        \t} i(-1).p(\"}\");\n\n                        } else {\n                            error(\"field must not be private.\");\n                        }\n                        return null;\n                    }\n                });\n            }\n\n            p(\"return rc;\");\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the setter for the specified field or null if a setter can't be found.\n     */\n    private String getSetterName( JField field){\n        String fieldName = field.getName();\n        fieldName = \"set\"+upperCaseFirstChar(fieldName);\n        JClassType type = field.getEnclosingType();\n        if(exists(type, field, fieldName, true)){\n            return fieldName;\n        }else{\n            return null;\n        }\n    }\n    \n    /**\n     * \n     * @param field\n     * @return the name for the getter for the specified field or null if a getter can't be found.\n     */\n    private String getGetterName( JField field){\n        String fieldName = field.getName();\n        JType booleanType = null;\n        try{\n            booleanType = find(Boolean.class);\n        }catch(UnableToCompleteException e){\n            //do nothing\n        }\n        if(field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)){\n            fieldName = \"is\"+upperCaseFirstChar(fieldName);\n        }else{\n            fieldName = \"get\"+upperCaseFirstChar(fieldName);\n        }\n        JClassType type = field.getEnclosingType();\n        if(exists(type, field, fieldName, false)){\n            return fieldName;\n        }else{\n            return null;\n        }\n    }\n    \n    private String upperCaseFirstChar(String in){\n        if(in.length()==1){\n            return in.toUpperCase();\n        }else{\n            return in.substring(0, 1).toUpperCase()+in.substring(1);\n        }\n    }\n    \n    /**\n     * checks whether a getter or setter exists on the specified \n     * type or any of its super classes excluding Object.\n     * \n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter){\n        JType[] args = null;\n        if(isSetter){\n            args = new JType[]{field.getType()};\n        }else{\n            args = new JType[]{};\n        }\n        \n        if(null != type.findMethod(fieldName, args)){\n            return true;\n        }else{\n            try{\n                JType objectType = find(Object.class);\n                JClassType superType = type.getSuperclass();\n                if(!objectType.equals(superType)){\n                    return exists(superType, field, fieldName, isSetter);\n                }\n            }catch(UnableToCompleteException e){\n                //do nothing\n            }\n        }\n        return false;\n    }\n    \n    /**\n     * Inspects the supplied type and all super classes\n     *  up to but excluding Object and returns a list of \n     *  all fields found in these classes.\n     * \n     * @param type\n     * @return\n     */\n    private List < JField > getFields( JClassType type){\n        return getFields(new ArrayList < JField >(), type);\n    }\n\n    private List < JField > getFields(List < JField > allFields, JClassType type){\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n            allFields.add(field);\n        }\n        try{\n            JType objectType = find(Object.class);\n            JClassType superType = type.getSuperclass();\n            if(!objectType.equals(superType)){\n                return getFields(allFields, superType);\n            }\n        }catch(UnableToCompleteException e){\n            //do nothing\n        }\n        return allFields;\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2010, Progress Software Corporation and/or its \n * subsidiaries or affiliates.  All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.fusesource.restygwt.rebind;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * \n * Updates:\n * added getter & setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n\tprivate String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n\tprivate static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n\tprivate static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n\n\tJsonEncoderDecoderInstanceLocator locator;\n\t\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n        composerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n        return composerFactory;\n    }\n\n    public void generate() throws UnableToCompleteException {\n        \n    \tlocator = new JsonEncoderDecoderInstanceLocator(context, logger);\n    \t\n        JClassType soruceClazz = source.isClass();\n        if (soruceClazz == null) {\n            error(\"Type is not a class\");\n        }\n        if (!soruceClazz.isDefaultInstantiable()) {\n            error(\"No default constuctor\");\n        }\n\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation!=null ? jsonAnnotation.style() : Style.DEFAULT;\n\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n\n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n\t\t\tp(\"if( value==null ) {\").i(1); {\n        \t\tp(\"return null;\");\n\t\t\t} i(-1).p(\"}\");         \n        \tp(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n\n            for (final JField field : getFields(source)) {\n\n                final String getterName = getGetterName(field);\n                \n                // If can ignore some fields right off the back..\n                if (getterName == null && (field.isStatic() || field.isFinal() || field.isTransient())) {\n                    continue;\n                }\n                \n                branch(\"Processing field: \" + field.getName(), new Branch<Void>(){\n                    public Void execute() throws UnableToCompleteException {\n                        // TODO: try to get the field with a setter or JSNI\n                        if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                            String name = field.getName();\n                            \n                            String fieldExpr = \"value.\" + name;\n                            if(getterName != null){\n                                fieldExpr = \"value.\" + getterName+\"()\";\n                            }\n                            \n                            Json jsonAnnotation = field.getAnnotation(Json.class);\n                            Style style = jsonAnnotation!=null ? jsonAnnotation.style() : classStyle;\n                            \n                            String expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n\n                            p(\"{\").i(1);\n                            {\n                                p(JSON_VALUE_CLASS + \" v=\" + expression + \";\");\n                                p(\"if( v!=null ) {\").i(1);\n                                {\n                                    p(\"rc.put(\" + wrap(name) + \", v);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                            i(-1).p(\"}\");\n                            \n                        } else {\n                            error(\"field must not be private: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                        }\n                        return null;\n                    }\n                });\n\n            }\n\n            p(\"return rc;\");\n        }\n        i(-1).p(\"}\");\n        p();\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            p(\"\" + source.getParameterizedQualifiedSourceName() + \" rc = new \" + source.getParameterizedQualifiedSourceName() + \"();\");\n            for (final JField field : getFields(source)) {\n\n                final String setterName = getSetterName(field);\n                \n                // If can ignore some fields right off the back..\n                if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient())) {\n                    continue;\n                }\n                \n                branch(\"Processing field: \" + field.getName(), new Branch<Void>(){\n                    public Void execute() throws UnableToCompleteException {\n\n                        // TODO: try to set the field with a setter or JSNI\n                       if (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                            Json jsonAnnotation = field.getAnnotation(Json.class);\n                            Style style = jsonAnnotation!=null ? jsonAnnotation.style() : classStyle;\n\n                            String name = field.getName();\n                            String objectGetter = \"object.get(\" + wrap(name) + \")\";\n                            String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n                        \n                            p(\"if(\" + objectGetter + \" != null) {\").i(1);\n                            if (setterName != null) {\n                                p(\"rc.\" + setterName + \"(\" + expression+ \");\");\n                            } else {\n                            \tp(\"rc.\" + name + \"=\" + expression + \";\");\n                        \t} i(-1).p(\"}\");\n\n                        } else {\n                            error(\"field must not be private.\");\n                        }\n                        return null;\n                    }\n                });\n            }\n\n            p(\"return rc;\");\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the setter for the specified field or null if a setter can't be found.\n     */\n    private String getSetterName( JField field){\n        String fieldName = field.getName();\n        fieldName = \"set\"+upperCaseFirstChar(fieldName);\n        JClassType type = field.getEnclosingType();\n        if(exists(type, field, fieldName, true)){\n            return fieldName;\n        }else{\n            return null;\n        }\n    }\n    \n    /**\n     * \n     * @param field\n     * @return the name for the getter for the specified field or null if a getter can't be found.\n     */\n    private String getGetterName( JField field){\n        String fieldName = field.getName();\n        JType booleanType = null;\n        try{\n            booleanType = find(Boolean.class);\n        }catch(UnableToCompleteException e){\n            //do nothing\n        }\n        if(field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)){\n            fieldName = \"is\"+upperCaseFirstChar(fieldName);\n        }else{\n            fieldName = \"get\"+upperCaseFirstChar(fieldName);\n        }\n        JClassType type = field.getEnclosingType();\n        if(exists(type, field, fieldName, false)){\n            return fieldName;\n        }else{\n            return null;\n        }\n    }\n    \n    private String upperCaseFirstChar(String in){\n        if(in.length()==1){\n            return in.toUpperCase();\n        }else{\n            return in.substring(0, 1).toUpperCase()+in.substring(1);\n        }\n    }\n    \n    /**\n     * checks whether a getter or setter exists on the specified \n     * type or any of its super classes excluding Object.\n     * \n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter){\n        JType[] args = null;\n        if(isSetter){\n            args = new JType[]{field.getType()};\n        }else{\n            args = new JType[]{};\n        }\n        \n        if(null != type.findMethod(fieldName, args)){\n            return true;\n        }else{\n            try{\n                JType objectType = find(Object.class);\n                JClassType superType = type.getSuperclass();\n                if(!objectType.equals(superType)){\n                    return exists(superType, field, fieldName, isSetter);\n                }\n            }catch(UnableToCompleteException e){\n                //do nothing\n            }\n        }\n        return false;\n    }\n    \n    /**\n     * Inspects the supplied type and all super classes\n     *  up to but excluding Object and returns a list of \n     *  all fields found in these classes.\n     * \n     * @param type\n     * @return\n     */\n    private List < JField > getFields( JClassType type){\n        return getFields(new ArrayList < JField >(), type);\n    }\n\n    private List < JField > getFields(List < JField > allFields, JClassType type){\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n            allFields.add(field);\n        }\n        try{\n            JType objectType = find(Object.class);\n            JClassType superType = type.getSuperclass();\n            if(!objectType.equals(superType)){\n                return getFields(allFields, superType);\n            }\n        }catch(UnableToCompleteException e){\n            //do nothing\n        }\n        return allFields;\n    }\n}\n","lineNo":106}
{"Refactored Sample":"/**\n * Copyright (C) 2010, Progress Software Corporation and/or its \n * subsidiaries or affiliates.  All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.fusesource.restygwt.rebind;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * \n * Updates:\n * added getter & setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n\tprivate String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n\tprivate static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n\tprivate static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n\n\tJsonEncoderDecoderInstanceLocator locator;\n\t\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n        composerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n        return composerFactory;\n    }\n\n    public void generate() throws UnableToCompleteException {\n        \n    \tlocator = new JsonEncoderDecoderInstanceLocator(context, logger);\n    \t\n        JClassType soruceClazz = source.isClass();\n        if (soruceClazz == null) {\n            error(\"Type is not a class\");\n        }\n        if (!soruceClazz.isDefaultInstantiable()) {\n            error(\"No default constuctor\");\n        }\n\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation!=null ? jsonAnnotation.style() : Style.DEFAULT;\n\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n\n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n\t\t\tp(\"if( value==null ) {\").i(1); {\n        \t\tp(\"return null;\");\n\t\t\t} i(-1).p(\"}\");         \n        \tp(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n\n            for (final JField field : getFields(source)) {\n\n                final String getterName = getGetterName(field);\n                \n                // If can ignore some fields right off the back..\n                if (getterName == null && (field.isStatic() || field.isFinal() || field.isTransient())) {\n                    continue;\n                }\n                \n                branch(\"Processing field: \" + field.getName(), new Branch<Void>(){\n                    public Void execute() throws UnableToCompleteException {\n                        // TODO: try to get the field with a setter or JSNI\n                        if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                            String name = field.getName();\n                            \n                            String fieldExpr = \"value.\" + name;\n                            if(getterName != null){\n                                fieldExpr = \"value.\" + getterName+\"()\";\n                            }\n                            \n                            Json jsonAnnotation = field.getAnnotation(Json.class);\n                            Style style = jsonAnnotation!=null ? jsonAnnotation.style() : classStyle;\n                            \n                            String expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n\n                            p(\"{\").i(1);\n                            {\n                                p(JSON_VALUE_CLASS + \" v=\" + expression + \";\");\n                                p(\"if( v!=null ) {\").i(1);\n                                {\n                                    p(\"rc.put(\" + wrap(name) + \", v);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                            i(-1).p(\"}\");\n                            \n                        } else {\n                            error(\"field must not be private: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                        }\n                        return null;\n                    }\n                });\n\n            }\n\n            p(\"return rc;\");\n        }\n        i(-1).p(\"}\");\n        p();\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            p(\"\" + source.getParameterizedQualifiedSourceName() + \" rc = new \" + source.getParameterizedQualifiedSourceName() + \"();\");\n            for (final JField field : getFields(source)) {\n\n                final String setterName = getSetterName(field);\n                \n                // If can ignore some fields right off the back..\n                if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient())) {\n                    continue;\n                }\n                \n                branch(\"Processing field: \" + field.getName(), new Branch<Void>(){\n                    public Void execute() throws UnableToCompleteException {\n\n                        // TODO: try to set the field with a setter or JSNI\n                       if (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                            Json jsonAnnotation = field.getAnnotation(Json.class);\n                            Style style = jsonAnnotation!=null ? jsonAnnotation.style() : classStyle;\n\n                            String name = field.getName();\n                            String objectGetter = \"object.get(\" + wrap(name) + \")\";\n                            String expression = locator.decodeExpression(field.getType(), objectGetter, style);\n                        \n                            p(\"if(\" + objectGetter + \" != null) {\").i(1);\n                            if (setterName != null) {\n                                p(\"rc.\" + setterName + \"(\" + expression+ \");\");\n                            } else {\n                            \tp(\"rc.\" + name + \"=\" + expression + \";\");\n                        \t} i(-1).p(\"}\");\n\n                        } else {\n                            error(\"field must not be private.\");\n                        }\n                        return null;\n                    }\n                });\n            }\n\n            p(\"return rc;\");\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the setter for the specified field or null if a setter can't be found.\n     */\n    private String getSetterName( JField field){\n        String fieldName = field.getName();\n        fieldName = \"set\"+upperCaseFirstChar(fieldName);\n        JClassType type = field.getEnclosingType();\n        if(exists(type, field, fieldName, true)){\n            return fieldName;\n        }else{\n            return null;\n        }\n    }\n    \n    /**\n     * \n     * @param field\n     * @return the name for the getter for the specified field or null if a getter can't be found.\n     */\n    private String getGetterName( JField field){\n        String fieldName = field.getName();\n        JType booleanType = null;\n        try{\n            booleanType = find(Boolean.class);\n        }catch(UnableToCompleteException e){\n            //do nothing\n        }\n        if(field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)){\n            fieldName = \"is\"+upperCaseFirstChar(fieldName);\n        }else{\n            fieldName = \"get\"+upperCaseFirstChar(fieldName);\n        }\n        JClassType type = field.getEnclosingType();\n        if(exists(type, field, fieldName, false)){\n            return fieldName;\n        }else{\n            return null;\n        }\n    }\n    \n    private String upperCaseFirstChar(String in){\n        if(in.length()==1){\n            return in.toUpperCase();\n        }else{\n            return in.substring(0, 1).toUpperCase()+in.substring(1);\n        }\n    }\n    \n    /**\n     * checks whether a getter or setter exists on the specified \n     * type or any of its super classes excluding Object.\n     * \n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter){\n        JType[] args = null;\n        if(isSetter){\n            args = new JType[]{field.getType()};\n        }else{\n            args = new JType[]{};\n        }\n        \n        if(null != type.findMethod(fieldName, args)){\n            return true;\n        }else{\n            try{\n                JType objectType = find(Object.class);\n                JClassType superType = type.getSuperclass();\n                if(!objectType.equals(superType)){\n                    return exists(superType, field, fieldName, isSetter);\n                }\n            }catch(UnableToCompleteException e){\n                //do nothing\n            }\n        }\n        return false;\n    }\n    \n    /**\n     * Inspects the supplied type and all super classes\n     *  up to but excluding Object and returns a list of \n     *  all fields found in these classes.\n     * \n     * @param type\n     * @return\n     */\n    private List < JField > getFields( JClassType type){\n        return getFields(new ArrayList < JField >(), type);\n    }\n\n    private List < JField > getFields(List < JField > allFields, JClassType type){\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n            allFields.add(field);\n        }\n        try{\n            JType objectType = find(Object.class);\n            JClassType superType = type.getSuperclass();\n            if(!objectType.equals(superType)){\n                return getFields(allFields, superType);\n            }\n        }catch(UnableToCompleteException e){\n            //do nothing\n        }\n        return allFields;\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2010, Progress Software Corporation and/or its \n * subsidiaries or affiliates.  All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.fusesource.restygwt.rebind;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.fusesource.restygwt.client.Json;\nimport org.fusesource.restygwt.client.Json.Style;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * \n * Updates:\n * added getter & setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n\tprivate String JSON_ENCODER_DECODER_CLASS = JsonEncoderDecoderInstanceLocator.JSON_ENCODER_DECODER_CLASS;\n\tprivate static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n\tprivate static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n\n\tJsonEncoderDecoderInstanceLocator locator;\n\t\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n        composerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n        return composerFactory;\n    }\n\n    public void generate() throws UnableToCompleteException {\n        \n    \tlocator = new JsonEncoderDecoderInstanceLocator(context, logger);\n    \t\n        JClassType soruceClazz = source.isClass();\n        if (soruceClazz == null) {\n            error(\"Type is not a class\");\n        }\n        if (!soruceClazz.isDefaultInstantiable()) {\n            error(\"No default constuctor\");\n        }\n\n        Json jsonAnnotation = source.getAnnotation(Json.class);\n        final Style classStyle = jsonAnnotation!=null ? jsonAnnotation.style() : Style.DEFAULT;\n\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n\n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n\t\t\tp(\"if( value==null ) {\").i(1); {\n        \t\tp(\"return null;\");\n\t\t\t} i(-1).p(\"}\");         \n        \tp(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n\n            for (final JField field : getFields(source)) {\n\n                final String getterName = getGetterName(field);\n                \n                // If can ignore some fields right off the back..\n                if (getterName == null && (field.isStatic() || field.isFinal() || field.isTransient())) {\n                    continue;\n                }\n                \n                branch(\"Processing field: \" + field.getName(), new Branch<Void>(){\n                    public Void execute() throws UnableToCompleteException {\n                        // TODO: try to get the field with a setter or JSNI\n                        if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                            String name = field.getName();\n                            \n                            String fieldExpr = \"value.\" + name;\n                            if(getterName != null){\n                                fieldExpr = \"value.\" + getterName+\"()\";\n                            }\n                            \n                            Json jsonAnnotation = field.getAnnotation(Json.class);\n                            Style style = jsonAnnotation!=null ? jsonAnnotation.style() : classStyle;\n                            \n                            String expression = locator.encodeExpression(field.getType(), fieldExpr, style);\n\n                            p(\"{\").i(1);\n                            {\n                                p(JSON_VALUE_CLASS + \" v=\" + expression + \";\");\n                                p(\"if( v!=null ) {\").i(1);\n                                {\n                                    p(\"rc.put(\" + wrap(name) + \", v);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                            i(-1).p(\"}\");\n                            \n                        } else {\n                            error(\"field must not be private: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                        }\n                        return null;\n                    }\n                });\n\n            }\n\n            p(\"return rc;\");\n        }\n        i(-1).p(\"}\");\n        p();\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            p(\"\" + source.getParameterizedQualifiedSourceName() + \" rc = new \" + source.getParameterizedQualifiedSourceName() + \"();\");\n            for (final JField field : getFields(source)) {\n\n                final String setterName = getSetterName(field);\n                \n                // If can ignore some fields right off the back..\n                if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient())) {\n                    continue;\n                }\n                \n                branch(\"Processing field: \" + field.getName(), new Branch<Void>(){\n                    public Void execute() throws UnableToCompleteException {\n\n                        // TODO: try to set the field with a setter or JSNI\n                       if (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                            Json jsonAnnotation = field.getAnnotation(Json.class);\n                            Style style = jsonAnnotation!=null ? jsonAnnotation.style() : classStyle;\n\n                            String name = field.getName();\n                            String expression = locator.decodeExpression(field.getType(), \"object.get(\" + wrap(name) + \")\", style);\n                        \t\n                        \tif(setterName != null){\n                                p(\"rc.\" + setterName + \"(\" + expression + \");\");\n                        \t}else{\n                                p(\"rc.\" + name + \"=\" + expression + \";\");\n                        \t}\n                        \t\n                        } else {\n                            error(\"field must not be private.\");\n                        }\n                        return null;\n                    }\n                });\n            }\n\n            p(\"return rc;\");\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the setter for the specified field or null if a setter can't be found.\n     */\n    private String getSetterName( JField field){\n        String fieldName = field.getName();\n        fieldName = \"set\"+upperCaseFirstChar(fieldName);\n        JClassType type = field.getEnclosingType();\n        if(exists(type, field, fieldName, true)){\n            return fieldName;\n        }else{\n            return null;\n        }\n    }\n    \n    /**\n     * \n     * @param field\n     * @return the name for the getter for the specified field or null if a getter can't be found.\n     */\n    private String getGetterName( JField field){\n        String fieldName = field.getName();\n        JType booleanType = null;\n        try{\n            booleanType = find(Boolean.class);\n        }catch(UnableToCompleteException e){\n            //do nothing\n        }\n        if(field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)){\n            fieldName = \"is\"+upperCaseFirstChar(fieldName);\n        }else{\n            fieldName = \"get\"+upperCaseFirstChar(fieldName);\n        }\n        JClassType type = field.getEnclosingType();\n        if(exists(type, field, fieldName, false)){\n            return fieldName;\n        }else{\n            return null;\n        }\n    }\n    \n    private String upperCaseFirstChar(String in){\n        if(in.length()==1){\n            return in.toUpperCase();\n        }else{\n            return in.substring(0, 1).toUpperCase()+in.substring(1);\n        }\n    }\n    \n    /**\n     * checks whether a getter or setter exists on the specified \n     * type or any of its super classes excluding Object.\n     * \n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter){\n        JType[] args = null;\n        if(isSetter){\n            args = new JType[]{field.getType()};\n        }else{\n            args = new JType[]{};\n        }\n        \n        if(null != type.findMethod(fieldName, args)){\n            return true;\n        }else{\n            try{\n                JType objectType = find(Object.class);\n                JClassType superType = type.getSuperclass();\n                if(!objectType.equals(superType)){\n                    return exists(superType, field, fieldName, isSetter);\n                }\n            }catch(UnableToCompleteException e){\n                //do nothing\n            }\n        }\n        return false;\n    }\n    \n    /**\n     * Inspects the supplied type and all super classes\n     *  up to but excluding Object and returns a list of \n     *  all fields found in these classes.\n     * \n     * @param type\n     * @return\n     */\n    private List < JField > getFields( JClassType type){\n        return getFields(new ArrayList < JField >(), type);\n    }\n\n    private List < JField > getFields(List < JField > allFields, JClassType type){\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n            allFields.add(field);\n        }\n        try{\n            JType objectType = find(Object.class);\n            JClassType superType = type.getSuperclass();\n            if(!objectType.equals(superType)){\n                return getFields(allFields, superType);\n            }\n        }catch(UnableToCompleteException e){\n            //do nothing\n        }\n        return allFields;\n    }\n}\n","lineNo":162}
{"Refactored Sample":"/**\n * Copyright (C) 2009  Hiram Chirino\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *    http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.hiramchirino.restygwt.client;\n\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport com.google.gwt.core.client.GWT;\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestBuilder;\nimport com.google.gwt.http.client.RequestCallback;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.http.client.Response;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.xml.client.Document;\nimport com.google.gwt.xml.client.XMLParser;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n */\npublic class Method {\n\n    /**\n     * GWT hides the full spectrum of methods because safari\n     * has a bug: http://bugs.webkit.org/show_bug.cgi?id=3812\n     *\n     * We extend assume the server side will also check the \n     * X-HTTP-Method-Override header.\n     * \n     * TODO: add an option to support using this approach to bypass\n     * restrictive firewalls even if the browser does support the\n     * setting all the method types.\n     * \n     * @author chirino\n     */\n\tstatic private class MethodRequestBuilder extends RequestBuilder {\n\t\tpublic MethodRequestBuilder(String method, String url) {\n\t\t\tsuper(method, url);\n\t        setHeader(\"X-HTTP-Method-Override\", method);\n\t\t}\n\t}\n\n\tRequestBuilder builder;\n\tint expectedStatus = 200;\n\tRequest request;\n\tResponse response;\n\n\tpublic Method(Resource resource, String method) {\n\t\tString uri = resource.getUri();\n\t\tif( resource.getQuery()!=null ) {\n\t\t    uri += \"?\"+resource.getQuery();\n\t\t}\n        builder = new MethodRequestBuilder(method, uri);\n\t}\n\n\tpublic Method user(String user) {\n\t\tbuilder.setUser(user);\n\t\treturn this;\n\t}\n\n\tpublic Method password(String password) {\n\t\tbuilder.setPassword(password);\n\t\treturn this;\n\t}\n\n\tpublic Method header(String header, String value) {\n\t\tbuilder.setHeader(header, value);\n\t\treturn this;\n\t}\n\n\tpublic Method headers(Map<String, String> headers) {\n\t\tif (headers != null) {\n\t\t\tfor (Entry<String, String> entry : headers.entrySet()) {\n\t\t\t\tbuilder.setHeader(entry.getKey(), entry.getValue());\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic Method text(String data) {\n\t\tdefaultContentType(Resource.CONTENT_TYPE_TEXT);\n\t\tbuilder.setRequestData(data);\n\t\treturn this;\n\t}\n\n\tpublic Method json(JSONValue data) {\n\t\tdefaultContentType(Resource.CONTENT_TYPE_JSON);\n\t\tbuilder.setRequestData(data.toString());\n\t\treturn this;\n\t}\n\n\tpublic Method xml(Document data) {\n\t\tdefaultContentType(Resource.CONTENT_TYPE_XML);\n\t\tbuilder.setRequestData(data.toString());\n\t\treturn this;\n\t}\n\n\tpublic Method timeout(int timeout) {\n\t\tbuilder.setTimeoutMillis(timeout);\n\t\treturn this;\n\t}\n\t\n    public void expect(int status) throws RequestException {\n        this.expectedStatus = status;\n    }\n\n\tpublic void send(RequestCallback callback) throws RequestException {\n\t\tbuilder.setCallback(callback);\n        GWT.log(\"Sending http request: \"+builder.getHTTPMethod()+\" \"+builder.getUrl(), null);\n        String content = builder.getRequestData();\n        if( content!=null && content.length()>0) {\n            GWT.log(content, null);\n        }\n        request = builder.send();\n\t}\n\n\tpublic void send(final TextCallback callback) {\n\t\tdefaultAcceptType(Resource.CONTENT_TYPE_TEXT);\n        try {\n            send(new AbstractRequestCallback<String>(this, callback) {\n                protected String parseResult() throws Exception {\n                    return response.getText();\n                }\n            });\n        } catch (RequestException e) {\n            GWT.log(\"Received http error for: \"+builder.getHTTPMethod()+\" \"+builder.getUrl(), e);\n            callback.onFailure(this, e);\n        }\n\t}\n\n\tpublic void send(final JsonCallback callback) {\n\t\tdefaultAcceptType(Resource.CONTENT_TYPE_JSON);\n        try {\n            send(new AbstractRequestCallback<JSONValue>(this, callback) {\n                protected JSONValue parseResult() throws Exception {\n                    try {\n\t\t\t\t\t\treturn JSONParser.parse(response.getText());\n\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\tthrow new ResponseFormatException(\"Response was NOT a valid JSON document\",e );\n\t\t\t\t\t}\n                }\n            });\n        } catch (RequestException e) {\n            GWT.log(\"Received http error for: \"+builder.getHTTPMethod()+\" \"+builder.getUrl(), e);\n            callback.onFailure(this, e);\n        }\n\t}\n\n\tpublic void send(final XmlCallback callback) {\n\t\tdefaultAcceptType(Resource.CONTENT_TYPE_XML);\n        try {\n            send(new AbstractRequestCallback<Document>(this, callback) {\n                protected Document parseResult() throws Exception {\n                    try {\n                    \treturn XMLParser.parse(response.getText());\n\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\tthrow new ResponseFormatException(\"Response was NOT a valid XML document\", e);\n\t\t\t\t\t}\n                }\n            });\n        } catch (RequestException e) {\n            GWT.log(\"Received http error for: \"+builder.getHTTPMethod()+\" \"+builder.getUrl(), e);\n            callback.onFailure(this, e);\n        }\n\t}\n\n\tpublic Request getRequest() {\n\t\treturn request;\n\t}\n\n\tpublic Response getResponse() {\n\t\treturn response;\n\t}\n\n\tprotected void defaultContentType(String type) {\n\t\tif (builder.getHeader(Resource.HEADER_CONTENT_TYPE) == null) {\n\t\t    header(Resource.HEADER_CONTENT_TYPE, type);\n\t\t}\n\t}\n\tprotected void defaultAcceptType(String type) {\n\t\tif (builder.getHeader(Resource.HEADER_ACCEPT) == null) {\n\t\t\theader(Resource.HEADER_ACCEPT, type);\n\t\t}\n\t}\n\n\t\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009  Hiram Chirino\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *    http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.hiramchirino.restygwt.client;\n\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport com.google.gwt.core.client.GWT;\nimport com.google.gwt.http.client.Request;\nimport com.google.gwt.http.client.RequestBuilder;\nimport com.google.gwt.http.client.RequestCallback;\nimport com.google.gwt.http.client.RequestException;\nimport com.google.gwt.http.client.Response;\nimport com.google.gwt.json.client.JSONParser;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.xml.client.Document;\nimport com.google.gwt.xml.client.XMLParser;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n */\npublic class Method {\n\n    /**\n     * GWT hides the full spectrum of methods because safari\n     * has a bug: http://bugs.webkit.org/show_bug.cgi?id=3812\n     *\n     * We extend assume the server side will also check the \n     * X-HTTP-Method-Override header.\n     * \n     * TODO: add an option to support using this approach to bypass\n     * restrictive firewalls even if the browser does support the\n     * setting all the method types.\n     * \n     * @author chirino\n     */\n\tstatic private class MethodRequestBuilder extends RequestBuilder {\n\t\tpublic MethodRequestBuilder(String method, String url) {\n\t\t\tsuper(method, url);\n\t        setHeader(\"X-HTTP-Method-Override\", method);\n\t\t}\n\t}\n\n\tRequestBuilder builder;\n\tint expectedStatus = 200;\n\tRequest request;\n\tResponse response;\n\n\tpublic Method(Resource resource, String method) {\n\t\tString uri = resource.getUri();\n\t\tif( resource.getQuery()!=null ) {\n\t\t    uri += \"?\"+resource.getQuery();\n\t\t}\n        builder = new MethodRequestBuilder(method, uri);\n\t}\n\n\tpublic Method user(String user) {\n\t\tbuilder.setUser(user);\n\t\treturn this;\n\t}\n\n\tpublic Method password(String password) {\n\t\tbuilder.setPassword(password);\n\t\treturn this;\n\t}\n\n\tpublic Method header(String header, String value) {\n\t\tbuilder.setHeader(header, value);\n\t\treturn this;\n\t}\n\n\tpublic Method headers(Map<String, String> headers) {\n\t\tif (headers != null) {\n\t\t\tfor (Entry<String, String> entry : headers.entrySet()) {\n\t\t\t\tbuilder.setHeader(entry.getKey(), entry.getValue());\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic Method text(String data) {\n\t\tdefaultContentType(Resource.CONTENT_TYPE_TEXT);\n\t\tbuilder.setRequestData(data);\n\t\treturn this;\n\t}\n\n\tpublic Method json(JSONValue data) {\n\t\tdefaultContentType(Resource.CONTENT_TYPE_JSON);\n\t\tbuilder.setRequestData(data.toString());\n\t\treturn this;\n\t}\n\n\tpublic Method xml(Document data) {\n\t\tdefaultContentType(Resource.CONTENT_TYPE_XML);\n\t\tbuilder.setRequestData(data.toString());\n\t\treturn this;\n\t}\n\n\tpublic Method timeout(int timeout) {\n\t\tbuilder.setTimeoutMillis(timeout);\n\t\treturn this;\n\t}\n\t\n    public void expect(int status) throws RequestException {\n        this.expectedStatus = status;\n    }\n\n\tpublic void send(RequestCallback callback) throws RequestException {\n\t\tbuilder.setCallback(callback);\n        GWT.log(\"Sending http request: \"+builder.getHTTPMethod()+\" \"+builder.getUrl(), null);\n        GWT.log(builder.getRequestData(), null);\n        request = builder.send();\n\t}\n\n\tpublic void send(final TextCallback callback) {\n\t\tdefaultAcceptType(Resource.CONTENT_TYPE_TEXT);\n        try {\n            send(new AbstractRequestCallback<String>(this, callback) {\n                protected String parseResult() throws Exception {\n                    return response.getText();\n                }\n            });\n        } catch (RequestException e) {\n            GWT.log(\"Received http error for: \"+builder.getHTTPMethod()+\" \"+builder.getUrl(), e);\n            callback.onFailure(this, e);\n        }\n\t}\n\n\tpublic void send(final JsonCallback callback) {\n\t\tdefaultAcceptType(Resource.CONTENT_TYPE_JSON);\n        try {\n            send(new AbstractRequestCallback<JSONValue>(this, callback) {\n                protected JSONValue parseResult() throws Exception {\n                    try {\n\t\t\t\t\t\treturn JSONParser.parse(response.getText());\n\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\tthrow new ResponseFormatException(\"Response was NOT a valid JSON document\",e );\n\t\t\t\t\t}\n                }\n            });\n        } catch (RequestException e) {\n            GWT.log(\"Received http error for: \"+builder.getHTTPMethod()+\" \"+builder.getUrl(), e);\n            callback.onFailure(this, e);\n        }\n\t}\n\n\tpublic void send(final XmlCallback callback) {\n\t\tdefaultAcceptType(Resource.CONTENT_TYPE_XML);\n        try {\n            send(new AbstractRequestCallback<Document>(this, callback) {\n                protected Document parseResult() throws Exception {\n                    try {\n                    \treturn XMLParser.parse(response.getText());\n\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\tthrow new ResponseFormatException(\"Response was NOT a valid XML document\", e);\n\t\t\t\t\t}\n                }\n            });\n        } catch (RequestException e) {\n            GWT.log(\"Received http error for: \"+builder.getHTTPMethod()+\" \"+builder.getUrl(), e);\n            callback.onFailure(this, e);\n        }\n\t}\n\n\tpublic Request getRequest() {\n\t\treturn request;\n\t}\n\n\tpublic Response getResponse() {\n\t\treturn response;\n\t}\n\n\tprotected void defaultContentType(String type) {\n\t\tif (builder.getHeader(Resource.HEADER_CONTENT_TYPE) == null) {\n\t\t    header(Resource.HEADER_CONTENT_TYPE, type);\n\t\t}\n\t}\n\tprotected void defaultAcceptType(String type) {\n\t\tif (builder.getHeader(Resource.HEADER_ACCEPT) == null) {\n\t\t\theader(Resource.HEADER_ACCEPT, type);\n\t\t}\n\t}\n\n\t\n}\n","lineNo":125}
{"Refactored Sample":"/**\n * Copyright (C) 2009  Hiram Chirino\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *    http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.hiramchirino.restygwt.rebind;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JParameterizedType;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport com.google.gwt.xml.client.Document;\nimport com.hiramchirino.restygwt.client.AbstractJsonEncoderDecoder;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n * \n * Updates:\n * added getter & setter support, enhanced generics support\n * @author <a href=\"http://www.acuedo.com\">Dave Finch<\/a>\n */\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private static final String JSON_ENCODER_DECODER_CLASS = AbstractJsonEncoderDecoder.class.getName();\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n\n    private JClassType STRING_TYPE = null;\n    private JClassType JSON_VALUE_TYPE = null;\n    private JClassType DOCUMENT_TYPE = null;\n    private JClassType MAP_TYPE = null;\n    private JClassType SET_TYPE = null;\n    private JClassType COLLECTION_CLASS;\n    private JClassType LIST_TYPE;\n\n    private HashMap<JType, String> builtInEncoderDecoders;\n\n\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n        composerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getParameterizedQualifiedSourceName() + \">\");\n        return composerFactory;\n    }\n\n    public void generate() throws UnableToCompleteException {\n        \n        this.STRING_TYPE = find(String.class);\n        this.JSON_VALUE_TYPE = find(JSONValue.class);\n        this.DOCUMENT_TYPE = find(Document.class);\n        this.LIST_TYPE = find(List.class);\n        this.MAP_TYPE = find(Map.class);\n        this.SET_TYPE = find(Set.class);\n        this.COLLECTION_CLASS = find(Collection.class); \n        \n        builtInEncoderDecoders = new HashMap<JType, String>();\n        builtInEncoderDecoders.put(JPrimitiveType.BOOLEAN, JSON_ENCODER_DECODER_CLASS + \".BOOLEAN\");\n        builtInEncoderDecoders.put(JPrimitiveType.BYTE, JSON_ENCODER_DECODER_CLASS + \".BYTE\");\n        builtInEncoderDecoders.put(JPrimitiveType.CHAR, JSON_ENCODER_DECODER_CLASS + \".CHAR\");\n        builtInEncoderDecoders.put(JPrimitiveType.SHORT, JSON_ENCODER_DECODER_CLASS + \".SHORT\");\n        builtInEncoderDecoders.put(JPrimitiveType.INT, JSON_ENCODER_DECODER_CLASS + \".INT\");\n        builtInEncoderDecoders.put(JPrimitiveType.LONG, JSON_ENCODER_DECODER_CLASS + \".LONG\");\n        builtInEncoderDecoders.put(JPrimitiveType.FLOAT, JSON_ENCODER_DECODER_CLASS + \".FLOAT\");\n        builtInEncoderDecoders.put(JPrimitiveType.DOUBLE, JSON_ENCODER_DECODER_CLASS + \".DOUBLE\");\n        builtInEncoderDecoders.put(find(Boolean.class), JSON_ENCODER_DECODER_CLASS + \".BOOLEAN\");\n        builtInEncoderDecoders.put(find(Byte.class), JSON_ENCODER_DECODER_CLASS + \".BYTE\");\n        builtInEncoderDecoders.put(find(Character.class), JSON_ENCODER_DECODER_CLASS + \".CHAR\");\n        builtInEncoderDecoders.put(find(Short.class), JSON_ENCODER_DECODER_CLASS + \".SHORT\");\n        builtInEncoderDecoders.put(find(Integer.class), JSON_ENCODER_DECODER_CLASS + \".INT\");\n        builtInEncoderDecoders.put(find(Long.class), JSON_ENCODER_DECODER_CLASS + \".LONG\");\n        builtInEncoderDecoders.put(find(Float.class), JSON_ENCODER_DECODER_CLASS + \".FLOAT\");\n        builtInEncoderDecoders.put(find(Double.class), JSON_ENCODER_DECODER_CLASS + \".DOUBLE\");\n        \n        builtInEncoderDecoders.put(STRING_TYPE, JSON_ENCODER_DECODER_CLASS + \".STRING\");\n        builtInEncoderDecoders.put(DOCUMENT_TYPE, JSON_ENCODER_DECODER_CLASS + \".DOCUMENT\");\n        builtInEncoderDecoders.put(JSON_VALUE_TYPE, JSON_ENCODER_DECODER_CLASS + \".JSON_VALUE\");\n\n        builtInEncoderDecoders.put(find(Date.class), JSON_ENCODER_DECODER_CLASS + \".DATE\");\n\n        JClassType soruceClazz = source.isClass();\n        if (soruceClazz == null) {\n            error(\"Type is not a class\");\n        }\n        if (!soruceClazz.isDefaultInstantiable()) {\n            error(\"No default constuctor\");\n        }\n\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n\n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getParameterizedQualifiedSourceName() + \" value) {\").i(1);\n        {\n        \tp(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n\n            for (final JField field : getFields(source)) {\n\n                final String getterName = getGetterName(field);\n                \n                // If can ignore some fields right off the back..\n                if (getterName == null && (field.isStatic() || field.isFinal() || field.isTransient())) {\n                    continue;\n                }\n                \n                branch(\"Processing field: \" + field.getName(), new Branch<Void>(){\n                    public Void execute() throws UnableToCompleteException {\n                        // TODO: try to get the field with a setter or JSNI\n                        if (getterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                            String name = field.getName();\n                            \n                            String fieldExpr = \"value.\" + name;\n                            if(getterName != null){\n                                fieldExpr = \"value.\" + getterName+\"()\";\n                            }\n                            \n                            String expression = null;\n                        \tif(null != field.getType().isEnum()){\n                        \t\texpression = encodeExpression(STRING_TYPE, fieldExpr+\".name()\");\n                        \t}else{\n                        \t\texpression = encodeExpression(field.getType(), fieldExpr);\n                        \t}\n                        \t                            \n\n                            p(\"{\").i(1);\n                            {\n                                p(JSON_VALUE_CLASS + \" v=\" + expression + \";\");\n                                p(\"if( v!=null ) {\").i(1);\n                                {\n                                    p(\"rc.put(\" + wrap(name) + \", v);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                            i(-1).p(\"}\");\n                            \n                        } else {\n                            error(\"field must not be private: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                        }\n                        return null;\n                    }\n                });\n\n            }\n\n            p(\"return rc;\");\n        }\n        i(-1).p(\"}\");\n        p();\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            p(\"\" + source.getParameterizedQualifiedSourceName() + \" rc = new \" + source.getParameterizedQualifiedSourceName() + \"();\");\n            for (final JField field : getFields(source)) {\n\n                final String setterName = getSetterName(field);\n                \n                // If can ignore some fields right off the back..\n                if (setterName == null && (field.isStatic() || field.isFinal() || field.isTransient())) {\n                    continue;\n                }\n                \n                branch(\"Processing field: \" + field.getName(), new Branch<Void>(){\n                    public Void execute() throws UnableToCompleteException {\n\n                        // TODO: try to set the field with a setter or JSNI\n                       if (setterName != null || field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                            String name = field.getName();\n                            String expression = null;\n                        \tif(null != field.getType().isEnum()){\n                        \t\texpression =  field.getType().getQualifiedSourceName()+\".valueOf(\"+\n                        \t\t\tdecodeExpression(STRING_TYPE, \"object.get(\" + wrap(name) + \"))\");\n                        \t}else{\n                        \t\texpression = decodeExpression(field.getType(), \"object.get(\" + wrap(name) + \")\");\n                        \t}\n                        \t\n                        \tif(setterName != null){\n                                p(\"rc.\" + setterName + \"(\" + expression + \");\");\n                        \t}else{\n                                p(\"rc.\" + name + \"=\" + expression + \";\");\n                        \t}\n                        \t\n                        } else {\n                            error(\"field must not be private.\");\n                        }\n                        return null;\n                    }\n                });\n            }\n\n            p(\"return rc;\");\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n\n    private String encodeExpression(JType type, String expression) throws UnableToCompleteException {\n        return encodeDecodeExpression(type, expression, \"encode\", \"toJSON\", \"toJSON\", \"toJSON\");\n    }\n\n    private String decodeExpression(JType type, String expression) throws UnableToCompleteException {\n        return encodeDecodeExpression(type, expression, \"decode\", \"toMap\", \"toSet\", \"toList\");\n    }\n    \n    private String encodeDecodeExpression(JType type, String expression, String encoderMethod, String mapMethod, String setMethod, String listMethod) throws UnableToCompleteException {\n        String encoderDecoder = getEncoderDecoder(type);\n        if (encoderDecoder != null) {\n            return encoderDecoder + \".\" + encoderMethod + \"(\" + expression + \")\";\n        }\n\n        JClassType clazz = type.isClassOrInterface();\n        if (clazz != null && clazz.isAssignableTo(COLLECTION_CLASS)) {\n            JParameterizedType parameterizedType = type.isParameterized();\n            if (parameterizedType == null || parameterizedType.getTypeArgs() == null) {\n                error(\"Collection types must be parameterized.\");\n            }\n            JClassType[] types = parameterizedType.getTypeArgs();\n            \n            if (parameterizedType.isAssignableTo(MAP_TYPE)) {\n                if (types.length != 2) {\n                    error(\"Map must define two and only two type parameters\");\n                }\n                if( types[0]!= STRING_TYPE ) {\n                    error(\"Map's frst type parameter must be of type String\");\n                }\n                encoderDecoder = getEncoderDecoder(types[1]);\n                if (encoderDecoder != null) {\n                    return mapMethod + \"(\" + expression + \", \" + encoderDecoder + \")\";\n                }\n            } else if (parameterizedType.isAssignableTo(SET_TYPE)) {\n                if (types.length != 1) {\n                    error(\"Set must define one and only one type parameter\");\n                }\n                encoderDecoder = getEncoderDecoder(types[0]);\n                if (encoderDecoder != null) {\n                    return setMethod + \"(\" + expression + \", \" + encoderDecoder + \")\";\n                }\n            } else if ( parameterizedType.isAssignableFrom(LIST_TYPE) ) {\n                if (types.length != 1) {\n                    error(\"List must define one and only one type parameter\");\n                }\n                encoderDecoder = getEncoderDecoder(types[0]);\n                debug(\"type encoder for: \"+types[0]+\" is \"+encoderDecoder);\n                if (encoderDecoder != null) {\n                    return listMethod + \"(\" + expression + \", \" + encoderDecoder + \")\";\n                }\n            }\n        }\n\n        error(\"Do not know how to encode/decode \" + type + \" to JSON\");\n        return null;\n    }\n\n    private String getEncoderDecoder(JType type) throws UnableToCompleteException {\n        String rc = builtInEncoderDecoders.get(type);\n        if (rc == null) {\n            JClassType ct = type.isClass();\n            if (ct != null && !ct.isAssignableTo(COLLECTION_CLASS)) {\n                JsonEncoderDecoderClassCreator generator = new JsonEncoderDecoderClassCreator(logger, context, ct);\n                return generator.create()+\".INSTANCE\";\n            }\n        }\n        return rc;\n    }\n\n    /**\n     * \n     * @param field\n     * @return the name for the setter for the specified field or null if a setter can't be found.\n     */\n    private String getSetterName( JField field){\n        String fieldName = field.getName();\n        fieldName = \"set\"+upperCaseFirstChar(fieldName);\n        JClassType type = field.getEnclosingType();\n        if(exists(type, field, fieldName, true)){\n            return fieldName;\n        }else{\n            return null;\n        }\n    }\n    \n    /**\n     * \n     * @param field\n     * @return the name for the getter for the specified field or null if a getter can't be found.\n     */\n    private String getGetterName( JField field){\n        String fieldName = field.getName();\n        JType booleanType = null;\n        try{\n            booleanType = find(Boolean.class);\n        }catch(UnableToCompleteException e){\n            //do nothing\n        }\n        if(field.getType().equals(JPrimitiveType.BOOLEAN) || field.getType().equals(booleanType)){\n            fieldName = \"is\"+upperCaseFirstChar(fieldName);\n        }else{\n            fieldName = \"get\"+upperCaseFirstChar(fieldName);\n        }\n        JClassType type = field.getEnclosingType();\n        if(exists(type, field, fieldName, false)){\n            return fieldName;\n        }else{\n            return null;\n        }\n    }\n    \n    private String upperCaseFirstChar(String in){\n        if(in.length()==1){\n            return in.toUpperCase();\n        }else{\n            return in.substring(0, 1).toUpperCase()+in.substring(1);\n        }\n    }\n    \n    /**\n     * checks whether a getter or setter exists on the specified \n     * type or any of its super classes excluding Object.\n     * \n     * @param type\n     * @param field\n     * @param fieldName\n     * @param isSetter\n     * @return\n     */\n    private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter){\n        JType[] args = null;\n        if(isSetter){\n            args = new JType[]{field.getType()};\n        }else{\n            args = new JType[]{};\n        }\n        \n        if(null != type.findMethod(fieldName, args)){\n            return true;\n        }else{\n            try{\n                JType objectType = find(Object.class);\n                JClassType superType = type.getSuperclass();\n                if(!objectType.equals(superType)){\n                    return exists(superType, field, fieldName, isSetter);\n                }\n            }catch(UnableToCompleteException e){\n                //do nothing\n            }\n        }\n        return false;\n    }\n    \n    /**\n     * Inspects the supplied type and all super classes\n     *  up to but excluding Object and returns a list of \n     *  all fields found in these classes.\n     * \n     * @param type\n     * @return\n     */\n    private List < JField > getFields( JClassType type){\n        return getFields(new ArrayList < JField >(), type);\n    }\n\n    private List < JField > getFields(List < JField > allFields, JClassType type){\n        JField[] fields = type.getFields();\n        for (JField field : fields) {\n            allFields.add(field);\n        }\n        try{\n            JType objectType = find(Object.class);\n            JClassType superType = type.getSuperclass();\n            if(!objectType.equals(superType)){\n                return getFields(allFields, superType);\n            }\n        }catch(UnableToCompleteException e){\n            //do nothing\n        }\n        return allFields;\n    }\n}\n","Smelly Sample":"/**\n * Copyright (C) 2009  Hiram Chirino\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *    http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.hiramchirino.restygwt.rebind;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.google.gwt.core.ext.GeneratorContext;\nimport com.google.gwt.core.ext.TreeLogger;\nimport com.google.gwt.core.ext.UnableToCompleteException;\nimport com.google.gwt.core.ext.typeinfo.JClassType;\nimport com.google.gwt.core.ext.typeinfo.JField;\nimport com.google.gwt.core.ext.typeinfo.JParameterizedType;\nimport com.google.gwt.core.ext.typeinfo.JPrimitiveType;\nimport com.google.gwt.core.ext.typeinfo.JType;\nimport com.google.gwt.json.client.JSONObject;\nimport com.google.gwt.json.client.JSONValue;\nimport com.google.gwt.user.rebind.ClassSourceFileComposerFactory;\nimport com.google.gwt.xml.client.Document;\nimport com.hiramchirino.restygwt.client.AbstractJsonEncoderDecoder;\n\n/**\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino<\/a>\n */\npublic class JsonEncoderDecoderClassCreator extends BaseSourceCreator {\n    private static final String JSON_ENCODER_SUFFIX = \"_Generated_JsonEncoderDecoder_\";\n\n    private static final String JSON_ENCODER_DECODER_CLASS = AbstractJsonEncoderDecoder.class.getName();\n    private static final String JSON_VALUE_CLASS = JSONValue.class.getName();\n    private static final String JSON_OBJECT_CLASS = JSONObject.class.getName();\n\n    private JClassType STRING_TYPE = null;\n    private JClassType JSON_VALUE_TYPE = null;\n    private JClassType DOCUMENT_TYPE = null;\n    private JClassType MAP_TYPE = null;\n    private JClassType SET_TYPE = null;\n    private JClassType COLLECTION_CLASS;\n    private JClassType LIST_TYPE;\n\n    private HashMap<JType, String> builtInEncoderDecoders;\n\n\n    public JsonEncoderDecoderClassCreator(TreeLogger logger, GeneratorContext context, JClassType source) throws UnableToCompleteException {\n        super(logger, context, source, JSON_ENCODER_SUFFIX);\n    }\n\n    protected ClassSourceFileComposerFactory createComposerFactory() {\n        ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory(packageName, shortName);\n        composerFactory.setSuperclass(JSON_ENCODER_DECODER_CLASS + \"<\" + source.getName() + \">\");\n        return composerFactory;\n    }\n\n    public void generate() throws UnableToCompleteException {\n        \n        this.STRING_TYPE = find(String.class);\n        this.JSON_VALUE_TYPE = find(JSONValue.class);\n        this.DOCUMENT_TYPE = find(Document.class);\n        this.LIST_TYPE = find(List.class);\n        this.MAP_TYPE = find(Map.class);\n        this.SET_TYPE = find(Set.class);\n        this.COLLECTION_CLASS = find(Collection.class); \n        \n        builtInEncoderDecoders = new HashMap<JType, String>();\n        builtInEncoderDecoders.put(JPrimitiveType.BOOLEAN, JSON_ENCODER_DECODER_CLASS + \".BOOLEAN\");\n        builtInEncoderDecoders.put(JPrimitiveType.BYTE, JSON_ENCODER_DECODER_CLASS + \".BYTE\");\n        builtInEncoderDecoders.put(JPrimitiveType.CHAR, JSON_ENCODER_DECODER_CLASS + \".CHAR\");\n        builtInEncoderDecoders.put(JPrimitiveType.SHORT, JSON_ENCODER_DECODER_CLASS + \".SHORT\");\n        builtInEncoderDecoders.put(JPrimitiveType.INT, JSON_ENCODER_DECODER_CLASS + \".INT\");\n        builtInEncoderDecoders.put(JPrimitiveType.LONG, JSON_ENCODER_DECODER_CLASS + \".LONG\");\n        builtInEncoderDecoders.put(JPrimitiveType.FLOAT, JSON_ENCODER_DECODER_CLASS + \".FLOAT\");\n        builtInEncoderDecoders.put(JPrimitiveType.DOUBLE, JSON_ENCODER_DECODER_CLASS + \".DOUBLE\");\n        builtInEncoderDecoders.put(find(Boolean.class), JSON_ENCODER_DECODER_CLASS + \".BOOLEAN\");\n        builtInEncoderDecoders.put(find(Byte.class), JSON_ENCODER_DECODER_CLASS + \".BYTE\");\n        builtInEncoderDecoders.put(find(Character.class), JSON_ENCODER_DECODER_CLASS + \".CHAR\");\n        builtInEncoderDecoders.put(find(Short.class), JSON_ENCODER_DECODER_CLASS + \".SHORT\");\n        builtInEncoderDecoders.put(find(Integer.class), JSON_ENCODER_DECODER_CLASS + \".INT\");\n        builtInEncoderDecoders.put(find(Long.class), JSON_ENCODER_DECODER_CLASS + \".LONG\");\n        builtInEncoderDecoders.put(find(Float.class), JSON_ENCODER_DECODER_CLASS + \".FLOAT\");\n        builtInEncoderDecoders.put(find(Double.class), JSON_ENCODER_DECODER_CLASS + \".DOUBLE\");\n        \n        builtInEncoderDecoders.put(STRING_TYPE, JSON_ENCODER_DECODER_CLASS + \".STRING\");\n        builtInEncoderDecoders.put(DOCUMENT_TYPE, JSON_ENCODER_DECODER_CLASS + \".DOCUMENT\");\n        builtInEncoderDecoders.put(JSON_VALUE_TYPE, JSON_ENCODER_DECODER_CLASS + \".JSON_VALUE\");\n\n        JClassType soruceClazz = source.isClass();\n        if (soruceClazz == null) {\n            error(\"Type is not a class\");\n        }\n        if (!soruceClazz.isDefaultInstantiable()) {\n            error(\"No default constuctor\");\n        }\n\n        p();\n        p(\"public static final \" + shortName + \" INSTANCE = new \" + shortName + \"();\");\n        p();\n        p(\"public \" + JSON_VALUE_CLASS + \" encode(\" + source.getName() + \" value) {\").i(1);\n        {\n            p(JSON_OBJECT_CLASS + \" rc = new \" + JSON_OBJECT_CLASS + \"();\");\n\n            for (final JField field : source.getFields()) {\n\n                // If can ignore some fields right off the back..\n                if (field.isStatic() || field.isFinal() || field.isTransient()) {\n                    continue;\n                }\n                \n                branch(\"Processing field: \" + field.getName(), new Branch<Void>(){\n                    public Void execute() throws UnableToCompleteException {\n                        // TODO: try to get the field with a setter or JSNI\n                        if (field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                            String name = field.getName();\n                            String expression = encodeExpression(field.getType(), \"value.\" + name);\n\n                            p(\"{\").i(1);\n                            {\n                                p(JSON_VALUE_CLASS + \" v=\" + expression + \";\");\n                                p(\"if( v!=null ) {\").i(1);\n                                {\n                                    p(\"rc.put(\" + wrap(name) + \", v);\");\n                                }\n                                i(-1).p(\"}\");\n                            }\n                            i(-1).p(\"}\");\n                            \n                        } else {\n                            error(\"field must not be private: \" + field.getEnclosingType().getQualifiedSourceName() + \".\" + field.getName());\n                        }\n                        return null;\n                    }\n                });\n\n            }\n\n            p(\"return rc;\");\n        }\n        i(-1).p(\"}\");\n        p();\n        p(\"public \" + source.getName() + \" decode(\" + JSON_VALUE_CLASS + \" value) {\").i(1);\n        {\n            p(JSON_OBJECT_CLASS + \" object = toObject(value);\");\n            p(\"\" + source.getName() + \" rc = new \" + source.getName() + \"();\");\n            for (final JField field : source.getFields()) {\n\n                // If can ignore some fields right off the back..\n                if (field.isStatic() || field.isFinal() || field.isTransient()) {\n                    continue;\n                }\n                \n                branch(\"Processing field: \" + field.getName(), new Branch<Void>(){\n                    public Void execute() throws UnableToCompleteException {\n\n                        // TODO: try to set the field with a setter or JSNI\n                        if (field.isDefaultAccess() || field.isProtected() || field.isPublic()) {\n\n                            String name = field.getName();\n                            String expression = decodeExpression(field.getType(), \"object.get(\" + wrap(name) + \")\");\n\n                            p(\"rc.\" + name + \"=\" + expression + \";\");\n                        } else {\n                            error(\"field must not be private.\");\n                        }\n                        return null;\n                    }\n                });\n            }\n\n            p(\"return rc;\");\n        }\n        i(-1).p(\"}\");\n        p();\n    }\n\n    private String encodeExpression(JType type, String expression) throws UnableToCompleteException {\n        return encodeDecodeExpression(type, expression, \"encode\", \"toJSON\", \"toJSON\", \"toJSON\");\n    }\n\n    private String decodeExpression(JType type, String expression) throws UnableToCompleteException {\n        return encodeDecodeExpression(type, expression, \"decode\", \"toMap\", \"toSet\", \"toList\");\n    }\n    \n    private String encodeDecodeExpression(JType type, String expression, String encoderMethod, String mapMethod, String setMethod, String listMethod) throws UnableToCompleteException {\n        String encoderDecoder = getEncoderDecoder(type);\n        if (encoderDecoder != null) {\n            return encoderDecoder + \".\" + encoderMethod + \"(\" + expression + \")\";\n        }\n\n        JClassType clazz = type.isClassOrInterface();\n        if (clazz != null && clazz.isAssignableTo(COLLECTION_CLASS)) {\n            JParameterizedType parameterizedType = type.isParameterized();\n            if (parameterizedType == null || parameterizedType.getTypeArgs() == null) {\n                error(\"Collection types must be parameterized.\");\n            }\n            JClassType[] types = parameterizedType.getTypeArgs();\n            \n            if (parameterizedType.isAssignableTo(MAP_TYPE)) {\n                if (types.length != 2) {\n                    error(\"Map must define two and only two type parameters\");\n                }\n                if( types[0]!= STRING_TYPE ) {\n                    error(\"Map's frst type parameter must be of type String\");\n                }\n                encoderDecoder = getEncoderDecoder(types[1]);\n                if (encoderDecoder != null) {\n                    return mapMethod + \"(\" + expression + \", \" + encoderDecoder + \")\";\n                }\n            } else if (parameterizedType.isAssignableTo(SET_TYPE)) {\n                if (types.length != 1) {\n                    error(\"Set must define one and only one type parameter\");\n                }\n                encoderDecoder = getEncoderDecoder(types[0]);\n                if (encoderDecoder != null) {\n                    return setMethod + \"(\" + expression + \", \" + encoderDecoder + \")\";\n                }\n            } else if ( parameterizedType.isAssignableFrom(LIST_TYPE) ) {\n                if (types.length != 1) {\n                    error(\"List must define one and only one type parameter\");\n                }\n                encoderDecoder = getEncoderDecoder(types[0]);\n                debug(\"type encoder for: \"+types[0]+\" is \"+encoderDecoder);\n                if (encoderDecoder != null) {\n                    return listMethod + \"(\" + expression + \", \" + encoderDecoder + \")\";\n                }\n            }\n        }\n\n        error(\"Do not know how to encode/decode \" + type + \" to JSON\");\n        return null;\n    }\n\n    private String getEncoderDecoder(JType type) throws UnableToCompleteException {\n        String rc = builtInEncoderDecoders.get(type);\n        if (rc == null) {\n            JClassType ct = type.isClass();\n            if (ct != null && !ct.isAssignableTo(COLLECTION_CLASS)) {\n                JsonEncoderDecoderClassCreator generator = new JsonEncoderDecoderClassCreator(logger, context, ct);\n                return generator.create()+\".INSTANCE\";\n            }\n        }\n        return rc;\n    }\n\n}\n","lineNo":142}
