{"Refactored Sample":"package org.slf4j;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.spi.MDCAdapter;\nimport org.slf4j.spi.SLF4JServiceProvider;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\n\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.Assert.*;\n\npublic class LoggerFactoryTest {\n    private PrintStream rawSyserr;\n    private ByteArrayOutputStream mockedSyserr;\n\n    final ClassLoader classLoaderOfLoggerFactory = LoggerFactory.class.getClassLoader();\n\n    @Before\n    public void setUp() {\n        rawSyserr = System.err;\n        mockedSyserr = new ByteArrayOutputStream();\n        System.setErr(new PrintStream(mockedSyserr));\n    }\n\n    @After\n    public void cleanUp() {\n        System.clearProperty(LoggerFactory.BINDING_PROP);\n        System.setErr(rawSyserr);\n    }\n\n    @Test\n    public void testExplicitlySpecified() {\n        System.setProperty(LoggerFactory.BINDING_PROP, \"org.slf4j.LoggerFactoryTest$TestingProvider\");\n        SLF4JServiceProvider provider = LoggerFactory.loadExplicitlySpecified(classLoaderOfLoggerFactory);\n        assertTrue(\"provider should be instance of TestingProvider class\", provider instanceof  TestingProvider);\n        assertTrue(mockedSyserr.toString().contains(\" Attempting to load provider \\\"org.slf4j.LoggerFactoryTest$TestingProvider\\\" specified via \\\"slf4j.binding\\\" system property\"));\n        System.out.println(mockedSyserr.toString());\n\n\n    }\n\n    @Test\n    public void testExplicitlySpecifiedNull() {\n        assertNull(LoggerFactory.loadExplicitlySpecified(classLoaderOfLoggerFactory));\n    }\n\n    @Test\n    public void testExplicitlySpecifyMissingServiceProvider() {\n        System.setProperty(LoggerFactory.BINDING_PROP, \"com.example.ServiceProvider\");\n        SLF4JServiceProvider provider = LoggerFactory.loadExplicitlySpecified(classLoaderOfLoggerFactory);\n        assertNull(provider);\n        assertTrue(mockedSyserr.toString().contains(\"Failed to instantiate the specified SLF4JServiceProvider (com.example.ServiceProvider)\"));\n    }\n\n    @Test\n    public void testExplicitlySpecifyNonServiceProvider() {\n        System.setProperty(LoggerFactory.BINDING_PROP, \"java.lang.String\");\n        assertNull(LoggerFactory.loadExplicitlySpecified(classLoaderOfLoggerFactory));\n        assertTrue(mockedSyserr.toString().contains(\"Specified SLF4JServiceProvider (java.lang.String) does not implement SLF4JServiceProvider interface\"));\n    }\n\n    public static class TestingProvider implements SLF4JServiceProvider {\n        @Override\n        public ILoggerFactory getLoggerFactory() {\n            return null;\n        }\n\n        @Override\n        public IMarkerFactory getMarkerFactory() {\n            return null;\n        }\n\n        @Override\n        public MDCAdapter getMDCAdapter() {\n            return null;\n        }\n\n        @Override\n        public String getRequestedApiVersion() {\n            return null;\n        }\n\n        @Override\n        public void initialize() {\n\n        }\n    }\n}\n","Smelly Sample":"package org.slf4j;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.spi.MDCAdapter;\nimport org.slf4j.spi.SLF4JServiceProvider;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\n\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertThat;\n\npublic class LoggerFactoryTest {\n    private PrintStream rawSyserr;\n    private ByteArrayOutputStream mockedSyserr;\n\n    @Before\n    public void setUp() {\n        rawSyserr = System.err;\n        mockedSyserr = new ByteArrayOutputStream();\n        System.setErr(new PrintStream(mockedSyserr));\n    }\n\n    @After\n    public void cleanUp() {\n        System.setErr(rawSyserr);\n    }\n\n    @Test\n    public void testExplicitlySpecified() {\n        assertThat(LoggerFactory.loadExplicitlySpecified(\"org.slf4j.LoggerFactoryTest$TestingProvider\"),\n                   is(instanceOf(TestingProvider.class)));\n    }\n\n    @Test\n    public void testExplicitlySpecifiedNull() {\n        assertNull(LoggerFactory.loadExplicitlySpecified(null));\n    }\n\n    @Test\n    public void testExplicitlySpecifyMissingServiceProvider() {\n        assertNull(LoggerFactory.loadExplicitlySpecified(\"com.example.ServiceProvider\"));\n        assertThat(mockedSyserr.toString(),\n                   containsString(\"Failed to instantiate the specified SLF4JServiceProvider (com.example.ServiceProvider)\"));\n    }\n\n    @Test\n    public void testExplicitlySpecifyNonServiceProvider() {\n        assertNull(LoggerFactory.loadExplicitlySpecified(\"java.lang.String\"));\n        assertThat(mockedSyserr.toString(),\n                   containsString(\"Specified SLF4JServiceProvider (java.lang.String) does not implement SLF4JServiceProvider interface\"));\n    }\n\n    public static class TestingProvider implements SLF4JServiceProvider {\n        @Override\n        public ILoggerFactory getLoggerFactory() {\n            return null;\n        }\n\n        @Override\n        public IMarkerFactory getMarkerFactory() {\n            return null;\n        }\n\n        @Override\n        public MDCAdapter getMDCAdapter() {\n            return null;\n        }\n\n        @Override\n        public String getRequesteApiVersion() {\n            return null;\n        }\n\n        @Override\n        public void initialize() {\n\n        }\n    }\n}\n","lineNo":55}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.ServiceConfigurationError;\nimport java.util.ServiceLoader;\nimport java.util.Set;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nimport org.slf4j.event.SubstituteLoggingEvent;\nimport org.slf4j.helpers.NOP_FallbackServiceProvider;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.helpers.SubstituteServiceProvider;\nimport org.slf4j.helpers.Util;\nimport org.slf4j.spi.SLF4JServiceProvider;\n\n/**\n * The <code>LoggerFactory<\/code> is a utility class producing Loggers for\n * various logging APIs, most notably for log4j, logback and JDK 1.4 logging.\n * Other implementations such as {@link org.slf4j.helpers.NOPLogger NOPLogger} and\n * SimpleLogger are also supported.\n * \n * <p><code>LoggerFactory<\/code> is essentially a wrapper around an\n * {@link ILoggerFactory} instance bound with <code>LoggerFactory<\/code> at\n * compile time.\n * \n * <p>\n * Please note that all methods in <code>LoggerFactory<\/code> are static.\n * \n * @author Alexander Dorokhine\n * @author Robert Elliot\n * @author Ceki G&uuml;lc&uuml;\n * \n */\npublic final class LoggerFactory {\n\n    static final String CODES_PREFIX = \"https://www.slf4j.org/codes.html\";\n\n    static final String NO_PROVIDERS_URL = CODES_PREFIX + \"#noProviders\";\n    static final String IGNORED_BINDINGS_URL = CODES_PREFIX + \"#ignoredBindings\";\n\n    static final String NO_STATICLOGGERBINDER_URL = CODES_PREFIX + \"#StaticLoggerBinder\";\n    static final String MULTIPLE_BINDINGS_URL = CODES_PREFIX + \"#multiple_bindings\";\n    static final String NULL_LF_URL = CODES_PREFIX + \"#null_LF\";\n    static final String VERSION_MISMATCH = CODES_PREFIX + \"#version_mismatch\";\n    static final String SUBSTITUTE_LOGGER_URL = CODES_PREFIX + \"#substituteLogger\";\n    static final String LOGGER_NAME_MISMATCH_URL = CODES_PREFIX + \"#loggerNameMismatch\";\n    static final String REPLAY_URL = CODES_PREFIX + \"#replay\";\n\n    static final String UNSUCCESSFUL_INIT_URL = CODES_PREFIX + \"#unsuccessfulInit\";\n    static final String UNSUCCESSFUL_INIT_MSG = \"org.slf4j.LoggerFactory in failed state. Original exception was thrown EARLIER. See also \"\n                    + UNSUCCESSFUL_INIT_URL;\n\n    static final int UNINITIALIZED = 0;\n    static final int ONGOING_INITIALIZATION = 1;\n    static final int FAILED_INITIALIZATION = 2;\n    static final int SUCCESSFUL_INITIALIZATION = 3;\n    static final int NOP_FALLBACK_INITIALIZATION = 4;\n\n    static volatile int INITIALIZATION_STATE = UNINITIALIZED;\n    static final SubstituteServiceProvider SUBST_PROVIDER = new SubstituteServiceProvider();\n    static final NOP_FallbackServiceProvider NOP_FALLBACK_SERVICE_PROVIDER = new NOP_FallbackServiceProvider();\n\n    // Support for detecting mismatched logger names.\n    static final String DETECT_LOGGER_NAME_MISMATCH_PROPERTY = \"slf4j.detectLoggerNameMismatch\";\n    static final String JAVA_VENDOR_PROPERTY = \"java.vendor.url\";\n\n    static boolean DETECT_LOGGER_NAME_MISMATCH = Util.safeGetBooleanSystemProperty(DETECT_LOGGER_NAME_MISMATCH_PROPERTY);\n\n    static volatile SLF4JServiceProvider PROVIDER;\n\n    // Package access for tests\n    static List<SLF4JServiceProvider> findServiceProviders() {\n        // retain behaviour similar to that of 1.7 series and earlier. More specifically, use the class loader that\n        // loaded the present class to search for services\n        final ClassLoader classLoaderOfLoggerFactory = LoggerFactory.class.getClassLoader();\n        ServiceLoader<SLF4JServiceProvider> serviceLoader = ServiceLoader.load(SLF4JServiceProvider.class, classLoaderOfLoggerFactory);\n        List<SLF4JServiceProvider> providerList = new ArrayList<>();\n        Iterator<SLF4JServiceProvider> iterator = serviceLoader.iterator();\n        while (iterator.hasNext()) {\n            safelyInstantiate(providerList, iterator);\n        }\n        return providerList;\n    }\n\n    private static void safelyInstantiate(List<SLF4JServiceProvider> providerList, Iterator<SLF4JServiceProvider> iterator) {\n        try {\n            SLF4JServiceProvider provider = iterator.next();\n            providerList.add(provider);\n        } catch (ServiceConfigurationError e) {\n            Util.report(\"A SLF4J service provider failed to instantiate:\\n\" + e.getMessage());\n        }\n    }\n\n    /**\n     * It is LoggerFactory's responsibility to track version changes and manage\n     * the compatibility list.\n     * <p>\n     * <p>\n     * It is assumed that all versions in the 1.6 are mutually compatible.\n     */\n    static private final String[] API_COMPATIBILITY_LIST = new String[] { \"2.0\" };\n\n    // private constructor prevents instantiation\n    private LoggerFactory() {\n    }\n\n    /**\n     * Force LoggerFactory to consider itself uninitialized.\n     * <p>\n     * <p>\n     * This method is intended to be called by classes (in the same package) for\n     * testing purposes. This method is internal. It can be modified, renamed or\n     * removed at any time without notice.\n     * <p>\n     * <p>\n     * You are strongly discouraged from calling this method in production code.\n     */\n    static void reset() {\n        INITIALIZATION_STATE = UNINITIALIZED;\n    }\n\n    private final static void performInitialization() {\n        bind();\n        if (INITIALIZATION_STATE == SUCCESSFUL_INITIALIZATION) {\n            versionSanityCheck();\n        }\n    }\n\n    private final static void bind() {\n        try {\n            List<SLF4JServiceProvider> providersList = findServiceProviders();\n            reportMultipleBindingAmbiguity(providersList);\n            if (providersList != null && !providersList.isEmpty()) {\n                PROVIDER = providersList.get(0);\n                // SLF4JServiceProvider.initialize() is intended to be called here and nowhere else.\n                PROVIDER.initialize();\n                INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;\n                reportActualBinding(providersList);\n            } else {\n                INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;\n                Util.report(\"No SLF4J providers were found.\");\n                Util.report(\"Defaulting to no-operation (NOP) logger implementation\");\n                Util.report(\"See \" + NO_PROVIDERS_URL + \" for further details.\");\n\n                Set<URL> staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();\n                reportIgnoredStaticLoggerBinders(staticLoggerBinderPathSet);\n            }\n            postBindCleanUp();\n        } catch (Exception e) {\n            failedBinding(e);\n            throw new IllegalStateException(\"Unexpected initialization failure\", e);\n        }\n    }\n\n    private static void reportIgnoredStaticLoggerBinders(Set<URL> staticLoggerBinderPathSet) {\n        if (staticLoggerBinderPathSet.isEmpty()) {\n            return;\n        }\n        Util.report(\"Class path contains SLF4J bindings targeting slf4j-api versions 1.7.x or earlier.\");\n\n        for (URL path : staticLoggerBinderPathSet) {\n            Util.report(\"Ignoring binding found at [\" + path + \"]\");\n        }\n        Util.report(\"See \" + IGNORED_BINDINGS_URL + \" for an explanation.\");\n\n    }\n\n    // We need to use the name of the StaticLoggerBinder class, but we can't\n    // reference the class itself.\n    private static final String STATIC_LOGGER_BINDER_PATH = \"org/slf4j/impl/StaticLoggerBinder.class\";\n\n    static Set<URL> findPossibleStaticLoggerBinderPathSet() {\n        // use Set instead of list in order to deal with bug #138\n        // LinkedHashSet appropriate here because it preserves insertion order\n        // during iteration\n        Set<URL> staticLoggerBinderPathSet = new LinkedHashSet<>();\n        try {\n            ClassLoader loggerFactoryClassLoader = LoggerFactory.class.getClassLoader();\n            Enumeration<URL> paths;\n            if (loggerFactoryClassLoader == null) {\n                paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);\n            } else {\n                paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);\n            }\n            while (paths.hasMoreElements()) {\n                URL path = paths.nextElement();\n                staticLoggerBinderPathSet.add(path);\n            }\n        } catch (IOException ioe) {\n            Util.report(\"Error getting resources from path\", ioe);\n        }\n        return staticLoggerBinderPathSet;\n    }\n\n    private static void postBindCleanUp() {\n        fixSubstituteLoggers();\n        replayEvents();\n        // release all resources in SUBST_FACTORY\n        SUBST_PROVIDER.getSubstituteLoggerFactory().clear();\n    }\n\n    private static void fixSubstituteLoggers() {\n        synchronized (SUBST_PROVIDER) {\n            SUBST_PROVIDER.getSubstituteLoggerFactory().postInitialization();\n            for (SubstituteLogger substLogger : SUBST_PROVIDER.getSubstituteLoggerFactory().getLoggers()) {\n                Logger logger = getLogger(substLogger.getName());\n                substLogger.setDelegate(logger);\n            }\n        }\n\n    }\n\n    static void failedBinding(Throwable t) {\n        INITIALIZATION_STATE = FAILED_INITIALIZATION;\n        Util.report(\"Failed to instantiate SLF4J LoggerFactory\", t);\n    }\n\n    private static void replayEvents() {\n        final LinkedBlockingQueue<SubstituteLoggingEvent> queue = SUBST_PROVIDER.getSubstituteLoggerFactory().getEventQueue();\n        final int queueSize = queue.size();\n        int count = 0;\n        final int maxDrain = 128;\n        List<SubstituteLoggingEvent> eventList = new ArrayList<>(maxDrain);\n        while (true) {\n            int numDrained = queue.drainTo(eventList, maxDrain);\n            if (numDrained == 0)\n                break;\n            for (SubstituteLoggingEvent event : eventList) {\n                replaySingleEvent(event);\n                if (count++ == 0)\n                    emitReplayOrSubstituionWarning(event, queueSize);\n            }\n            eventList.clear();\n        }\n    }\n\n    private static void emitReplayOrSubstituionWarning(SubstituteLoggingEvent event, int queueSize) {\n        if (event.getLogger().isDelegateEventAware()) {\n            emitReplayWarning(queueSize);\n        } else if (event.getLogger().isDelegateNOP()) {\n            // nothing to do\n        } else {\n            emitSubstitutionWarning();\n        }\n    }\n\n    private static void replaySingleEvent(SubstituteLoggingEvent event) {\n        if (event == null)\n            return;\n\n        SubstituteLogger substLogger = event.getLogger();\n        String loggerName = substLogger.getName();\n        if (substLogger.isDelegateNull()) {\n            throw new IllegalStateException(\"Delegate logger cannot be null at this state.\");\n        }\n\n        if (substLogger.isDelegateNOP()) {\n            // nothing to do\n        } else if (substLogger.isDelegateEventAware()) {\n            substLogger.log(event);\n        } else {\n            Util.report(loggerName);\n        }\n    }\n\n    private static void emitSubstitutionWarning() {\n        Util.report(\"The following set of substitute loggers may have been accessed\");\n        Util.report(\"during the initialization phase. Logging calls during this\");\n        Util.report(\"phase were not honored. However, subsequent logging calls to these\");\n        Util.report(\"loggers will work as normally expected.\");\n        Util.report(\"See also \" + SUBSTITUTE_LOGGER_URL);\n    }\n\n    private static void emitReplayWarning(int eventCount) {\n        Util.report(\"A number (\" + eventCount + \") of logging calls during the initialization phase have been intercepted and are\");\n        Util.report(\"now being replayed. These are subject to the filtering rules of the underlying logging system.\");\n        Util.report(\"See also \" + REPLAY_URL);\n    }\n\n    private final static void versionSanityCheck() {\n        try {\n            String requested = PROVIDER.getRequestedApiVersion();\n\n            boolean match = false;\n            for (String aAPI_COMPATIBILITY_LIST : API_COMPATIBILITY_LIST) {\n                if (requested.startsWith(aAPI_COMPATIBILITY_LIST)) {\n                    match = true;\n                }\n            }\n            if (!match) {\n                Util.report(\"The requested version \" + requested + \" by your slf4j binding is not compatible with \"\n                                + Arrays.asList(API_COMPATIBILITY_LIST).toString());\n                Util.report(\"See \" + VERSION_MISMATCH + \" for further details.\");\n            }\n        } catch (java.lang.NoSuchFieldError nsfe) {\n            // given our large user base and SLF4J's commitment to backward\n            // compatibility, we cannot cry here. Only for implementations\n            // which willingly declare a REQUESTED_API_VERSION field do we\n            // emit compatibility warnings.\n        } catch (Throwable e) {\n            // we should never reach here\n            Util.report(\"Unexpected problem occured during version sanity check\", e);\n        }\n    }\n\n    private static boolean isAmbiguousProviderList(List<SLF4JServiceProvider> providerList) {\n        return providerList.size() > 1;\n    }\n\n    /**\n     * Prints a warning message on the console if multiple bindings were found\n     * on the class path. No reporting is done otherwise.\n     * \n     */\n    private static void reportMultipleBindingAmbiguity(List<SLF4JServiceProvider> providerList) {\n        if (isAmbiguousProviderList(providerList)) {\n            Util.report(\"Class path contains multiple SLF4J providers.\");\n            for (SLF4JServiceProvider provider : providerList) {\n                Util.report(\"Found provider [\" + provider + \"]\");\n            }\n            Util.report(\"See \" + MULTIPLE_BINDINGS_URL + \" for an explanation.\");\n        }\n    }\n\n    private static void reportActualBinding(List<SLF4JServiceProvider> providerList) {\n        // binderPathSet can be null under Android\n        if (!providerList.isEmpty() && isAmbiguousProviderList(providerList)) {\n            Util.report(\"Actual provider is of type [\" + providerList.get(0) + \"]\");\n        }\n    }\n\n    /**\n     * Return a logger named according to the name parameter using the\n     * statically bound {@link ILoggerFactory} instance.\n     * \n     * @param name\n     *            The name of the logger.\n     * @return logger\n     */\n    public static Logger getLogger(String name) {\n        ILoggerFactory iLoggerFactory = getILoggerFactory();\n        return iLoggerFactory.getLogger(name);\n    }\n\n    /**\n     * Return a logger named corresponding to the class passed as parameter,\n     * using the statically bound {@link ILoggerFactory} instance.\n     * \n     * <p>\n     * In case the <code>clazz<\/code> parameter differs from the name of the\n     * caller as computed internally by SLF4J, a logger name mismatch warning\n     * will be printed but only if the\n     * <code>slf4j.detectLoggerNameMismatch<\/code> system property is set to\n     * true. By default, this property is not set and no warnings will be\n     * printed even in case of a logger name mismatch.\n     * \n     * @param clazz\n     *            the returned logger will be named after clazz\n     * @return logger\n     * \n     * \n     * @see <a\n     *      href=\"http://www.slf4j.org/codes.html#loggerNameMismatch\">Detected\n     *      logger name mismatch<\/a>\n     */\n    public static Logger getLogger(Class<?> clazz) {\n        Logger logger = getLogger(clazz.getName());\n        if (DETECT_LOGGER_NAME_MISMATCH) {\n            Class<?> autoComputedCallingClass = Util.getCallingClass();\n            if (autoComputedCallingClass != null && nonMatchingClasses(clazz, autoComputedCallingClass)) {\n                Util.report(String.format(\"Detected logger name mismatch. Given name: \\\"%s\\\"; computed name: \\\"%s\\\".\", logger.getName(),\n                                autoComputedCallingClass.getName()));\n                Util.report(\"See \" + LOGGER_NAME_MISMATCH_URL + \" for an explanation\");\n            }\n        }\n        return logger;\n    }\n\n    private static boolean nonMatchingClasses(Class<?> clazz, Class<?> autoComputedCallingClass) {\n        return !autoComputedCallingClass.isAssignableFrom(clazz);\n    }\n\n    /**\n     * Return the {@link ILoggerFactory} instance in use.\n     * <p>\n     * <p>\n     * ILoggerFactory instance is bound with this class at compile time.\n     * \n     * @return the ILoggerFactory instance in use\n     */\n    public static ILoggerFactory getILoggerFactory() {\n        return getProvider().getLoggerFactory();\n    }\n\n    /**\n     * Return the {@link SLF4JServiceProvider} in use.\n    \n     * @return provider in use\n     * @since 1.8.0\n     */\n    static SLF4JServiceProvider getProvider() {\n        if (INITIALIZATION_STATE == UNINITIALIZED) {\n            synchronized (LoggerFactory.class) {\n                if (INITIALIZATION_STATE == UNINITIALIZED) {\n                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;\n                    performInitialization();\n                }\n            }\n        }\n        switch (INITIALIZATION_STATE) {\n        case SUCCESSFUL_INITIALIZATION:\n            return PROVIDER;\n        case NOP_FALLBACK_INITIALIZATION:\n            return NOP_FALLBACK_SERVICE_PROVIDER;\n        case FAILED_INITIALIZATION:\n            throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);\n        case ONGOING_INITIALIZATION:\n            // support re-entrant behavior.\n            // See also http://jira.qos.ch/browse/SLF4J-97\n            return SUBST_PROVIDER;\n        }\n        throw new IllegalStateException(\"Unreachable code\");\n    }\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.security.AccessControlException;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.ServiceConfigurationError;\nimport java.util.ServiceLoader;\nimport java.util.Set;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nimport org.slf4j.event.SubstituteLoggingEvent;\nimport org.slf4j.helpers.NOP_FallbackServiceProvider;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.helpers.SubstituteServiceProvider;\nimport org.slf4j.helpers.Util;\nimport org.slf4j.spi.SLF4JServiceProvider;\n\n/**\n * The <code>LoggerFactory<\/code> is a utility class producing Loggers for\n * various logging APIs, most notably for log4j, logback and JDK 1.4 logging.\n * Other implementations such as {@link org.slf4j.helpers.NOPLogger NOPLogger} and\n * SimpleLogger are also supported.\n * \n * <p><code>LoggerFactory<\/code> is essentially a wrapper around an\n * {@link ILoggerFactory} instance bound with <code>LoggerFactory<\/code> at\n * compile time.\n * \n * <p>\n * Please note that all methods in <code>LoggerFactory<\/code> are static.\n * \n * @author Alexander Dorokhine\n * @author Robert Elliot\n * @author Ceki G&uuml;lc&uuml;\n * \n */\npublic final class LoggerFactory {\n\n    static final String CODES_PREFIX = \"https://www.slf4j.org/codes.html\";\n\n    static final String NO_PROVIDERS_URL = CODES_PREFIX + \"#noProviders\";\n    static final String IGNORED_BINDINGS_URL = CODES_PREFIX + \"#ignoredBindings\";\n\n    static final String NO_STATICLOGGERBINDER_URL = CODES_PREFIX + \"#StaticLoggerBinder\";\n    static final String MULTIPLE_BINDINGS_URL = CODES_PREFIX + \"#multiple_bindings\";\n    static final String NULL_LF_URL = CODES_PREFIX + \"#null_LF\";\n    static final String VERSION_MISMATCH = CODES_PREFIX + \"#version_mismatch\";\n    static final String SUBSTITUTE_LOGGER_URL = CODES_PREFIX + \"#substituteLogger\";\n    static final String LOGGER_NAME_MISMATCH_URL = CODES_PREFIX + \"#loggerNameMismatch\";\n    static final String REPLAY_URL = CODES_PREFIX + \"#replay\";\n\n    static final String UNSUCCESSFUL_INIT_URL = CODES_PREFIX + \"#unsuccessfulInit\";\n    static final String UNSUCCESSFUL_INIT_MSG = \"org.slf4j.LoggerFactory in failed state. Original exception was thrown EARLIER. See also \"\n                    + UNSUCCESSFUL_INIT_URL;\n\n    static final int UNINITIALIZED = 0;\n    static final int ONGOING_INITIALIZATION = 1;\n    static final int FAILED_INITIALIZATION = 2;\n    static final int SUCCESSFUL_INITIALIZATION = 3;\n    static final int NOP_FALLBACK_INITIALIZATION = 4;\n\n    static volatile int INITIALIZATION_STATE = UNINITIALIZED;\n    static final SubstituteServiceProvider SUBST_PROVIDER = new SubstituteServiceProvider();\n    static final NOP_FallbackServiceProvider NOP_FALLBACK_SERVICE_PROVIDER = new NOP_FallbackServiceProvider();\n\n    // Support for detecting mismatched logger names.\n    static final String DETECT_LOGGER_NAME_MISMATCH_PROPERTY = \"slf4j.detectLoggerNameMismatch\";\n    static final String JAVA_VENDOR_PROPERTY = \"java.vendor.url\";\n\n    static boolean DETECT_LOGGER_NAME_MISMATCH = Util.safeGetBooleanSystemProperty(DETECT_LOGGER_NAME_MISMATCH_PROPERTY);\n\n    static volatile SLF4JServiceProvider PROVIDER;\n\n    // Package access for tests\n    static List<SLF4JServiceProvider> findServiceProviders() {\n        final ClassLoader cl = LoggerFactory.class.getClassLoader();\n        final PrivilegedAction<ServiceLoader<SLF4JServiceProvider>> action = () -> ServiceLoader.load(SLF4JServiceProvider.class, cl);\n        final ServiceLoader<SLF4JServiceProvider> serviceLoader = System.getSecurityManager() != null\n                        ? AccessController.doPrivileged(action)\n                        : action.run();\n        List<SLF4JServiceProvider> providerList = new ArrayList<>();\n        Iterator<SLF4JServiceProvider> iterator = serviceLoader.iterator();\n        while (iterator.hasNext()) {\n            try {\n                providerList.add(iterator.next());\n            } catch (ServiceConfigurationError | AccessControlException e) {\n                // Short warning\n                Util.report(\"A SLF4J service provider failed to instantiate:\\n\" + e.getMessage());\n            }\n        }\n        return providerList;\n    }\n\n    /**\n     * It is LoggerFactory's responsibility to track version changes and manage\n     * the compatibility list.\n     * <p>\n     * <p>\n     * It is assumed that all versions in the 1.6 are mutually compatible.\n     */\n    static private final String[] API_COMPATIBILITY_LIST = new String[] { \"2.0\" };\n\n    // private constructor prevents instantiation\n    private LoggerFactory() {\n    }\n\n    /**\n     * Force LoggerFactory to consider itself uninitialized.\n     * <p>\n     * <p>\n     * This method is intended to be called by classes (in the same package) for\n     * testing purposes. This method is internal. It can be modified, renamed or\n     * removed at any time without notice.\n     * <p>\n     * <p>\n     * You are strongly discouraged from calling this method in production code.\n     */\n    static void reset() {\n        INITIALIZATION_STATE = UNINITIALIZED;\n    }\n\n    private final static void performInitialization() {\n        bind();\n        if (INITIALIZATION_STATE == SUCCESSFUL_INITIALIZATION) {\n            versionSanityCheck();\n        }\n    }\n\n    private final static void bind() {\n        try {\n            List<SLF4JServiceProvider> providersList = findServiceProviders();\n            reportMultipleBindingAmbiguity(providersList);\n            if (providersList != null && !providersList.isEmpty()) {\n                PROVIDER = providersList.get(0);\n                // SLF4JServiceProvider.initialize() is intended to be called here and nowhere else.\n                PROVIDER.initialize();\n                INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;\n                reportActualBinding(providersList);\n            } else {\n                INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;\n                Util.report(\"No SLF4J providers were found.\");\n                Util.report(\"Defaulting to no-operation (NOP) logger implementation\");\n                Util.report(\"See \" + NO_PROVIDERS_URL + \" for further details.\");\n\n                Set<URL> staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();\n                reportIgnoredStaticLoggerBinders(staticLoggerBinderPathSet);\n            }\n            postBindCleanUp();\n        } catch (Exception e) {\n            failedBinding(e);\n            throw new IllegalStateException(\"Unexpected initialization failure\", e);\n        }\n    }\n\n    private static void reportIgnoredStaticLoggerBinders(Set<URL> staticLoggerBinderPathSet) {\n        if (staticLoggerBinderPathSet.isEmpty()) {\n            return;\n        }\n        Util.report(\"Class path contains SLF4J bindings targeting slf4j-api versions 1.7.x or earlier.\");\n\n        for (URL path : staticLoggerBinderPathSet) {\n            Util.report(\"Ignoring binding found at [\" + path + \"]\");\n        }\n        Util.report(\"See \" + IGNORED_BINDINGS_URL + \" for an explanation.\");\n\n    }\n\n    // We need to use the name of the StaticLoggerBinder class, but we can't\n    // reference the class itself.\n    private static final String STATIC_LOGGER_BINDER_PATH = \"org/slf4j/impl/StaticLoggerBinder.class\";\n\n    static Set<URL> findPossibleStaticLoggerBinderPathSet() {\n        // use Set instead of list in order to deal with bug #138\n        // LinkedHashSet appropriate here because it preserves insertion order\n        // during iteration\n        Set<URL> staticLoggerBinderPathSet = new LinkedHashSet<>();\n        try {\n            ClassLoader loggerFactoryClassLoader = LoggerFactory.class.getClassLoader();\n            Enumeration<URL> paths;\n            if (loggerFactoryClassLoader == null) {\n                paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);\n            } else {\n                paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);\n            }\n            while (paths.hasMoreElements()) {\n                URL path = paths.nextElement();\n                staticLoggerBinderPathSet.add(path);\n            }\n        } catch (IOException ioe) {\n            Util.report(\"Error getting resources from path\", ioe);\n        }\n        return staticLoggerBinderPathSet;\n    }\n\n    private static void postBindCleanUp() {\n        fixSubstituteLoggers();\n        replayEvents();\n        // release all resources in SUBST_FACTORY\n        SUBST_PROVIDER.getSubstituteLoggerFactory().clear();\n    }\n\n    private static void fixSubstituteLoggers() {\n        synchronized (SUBST_PROVIDER) {\n            SUBST_PROVIDER.getSubstituteLoggerFactory().postInitialization();\n            for (SubstituteLogger substLogger : SUBST_PROVIDER.getSubstituteLoggerFactory().getLoggers()) {\n                Logger logger = getLogger(substLogger.getName());\n                substLogger.setDelegate(logger);\n            }\n        }\n\n    }\n\n    static void failedBinding(Throwable t) {\n        INITIALIZATION_STATE = FAILED_INITIALIZATION;\n        Util.report(\"Failed to instantiate SLF4J LoggerFactory\", t);\n    }\n\n    private static void replayEvents() {\n        final LinkedBlockingQueue<SubstituteLoggingEvent> queue = SUBST_PROVIDER.getSubstituteLoggerFactory().getEventQueue();\n        final int queueSize = queue.size();\n        int count = 0;\n        final int maxDrain = 128;\n        List<SubstituteLoggingEvent> eventList = new ArrayList<>(maxDrain);\n        while (true) {\n            int numDrained = queue.drainTo(eventList, maxDrain);\n            if (numDrained == 0)\n                break;\n            for (SubstituteLoggingEvent event : eventList) {\n                replaySingleEvent(event);\n                if (count++ == 0)\n                    emitReplayOrSubstituionWarning(event, queueSize);\n            }\n            eventList.clear();\n        }\n    }\n\n    private static void emitReplayOrSubstituionWarning(SubstituteLoggingEvent event, int queueSize) {\n        if (event.getLogger().isDelegateEventAware()) {\n            emitReplayWarning(queueSize);\n        } else if (event.getLogger().isDelegateNOP()) {\n            // nothing to do\n        } else {\n            emitSubstitutionWarning();\n        }\n    }\n\n    private static void replaySingleEvent(SubstituteLoggingEvent event) {\n        if (event == null)\n            return;\n\n        SubstituteLogger substLogger = event.getLogger();\n        String loggerName = substLogger.getName();\n        if (substLogger.isDelegateNull()) {\n            throw new IllegalStateException(\"Delegate logger cannot be null at this state.\");\n        }\n\n        if (substLogger.isDelegateNOP()) {\n            // nothing to do\n        } else if (substLogger.isDelegateEventAware()) {\n            substLogger.log(event);\n        } else {\n            Util.report(loggerName);\n        }\n    }\n\n    private static void emitSubstitutionWarning() {\n        Util.report(\"The following set of substitute loggers may have been accessed\");\n        Util.report(\"during the initialization phase. Logging calls during this\");\n        Util.report(\"phase were not honored. However, subsequent logging calls to these\");\n        Util.report(\"loggers will work as normally expected.\");\n        Util.report(\"See also \" + SUBSTITUTE_LOGGER_URL);\n    }\n\n    private static void emitReplayWarning(int eventCount) {\n        Util.report(\"A number (\" + eventCount + \") of logging calls during the initialization phase have been intercepted and are\");\n        Util.report(\"now being replayed. These are subject to the filtering rules of the underlying logging system.\");\n        Util.report(\"See also \" + REPLAY_URL);\n    }\n\n    private final static void versionSanityCheck() {\n        try {\n            String requested = PROVIDER.getRequestedApiVersion();\n\n            boolean match = false;\n            for (String aAPI_COMPATIBILITY_LIST : API_COMPATIBILITY_LIST) {\n                if (requested.startsWith(aAPI_COMPATIBILITY_LIST)) {\n                    match = true;\n                }\n            }\n            if (!match) {\n                Util.report(\"The requested version \" + requested + \" by your slf4j binding is not compatible with \"\n                                + Arrays.asList(API_COMPATIBILITY_LIST).toString());\n                Util.report(\"See \" + VERSION_MISMATCH + \" for further details.\");\n            }\n        } catch (java.lang.NoSuchFieldError nsfe) {\n            // given our large user base and SLF4J's commitment to backward\n            // compatibility, we cannot cry here. Only for implementations\n            // which willingly declare a REQUESTED_API_VERSION field do we\n            // emit compatibility warnings.\n        } catch (Throwable e) {\n            // we should never reach here\n            Util.report(\"Unexpected problem occured during version sanity check\", e);\n        }\n    }\n\n    private static boolean isAmbiguousProviderList(List<SLF4JServiceProvider> providerList) {\n        return providerList.size() > 1;\n    }\n\n    /**\n     * Prints a warning message on the console if multiple bindings were found\n     * on the class path. No reporting is done otherwise.\n     * \n     */\n    private static void reportMultipleBindingAmbiguity(List<SLF4JServiceProvider> providerList) {\n        if (isAmbiguousProviderList(providerList)) {\n            Util.report(\"Class path contains multiple SLF4J providers.\");\n            for (SLF4JServiceProvider provider : providerList) {\n                Util.report(\"Found provider [\" + provider + \"]\");\n            }\n            Util.report(\"See \" + MULTIPLE_BINDINGS_URL + \" for an explanation.\");\n        }\n    }\n\n    private static void reportActualBinding(List<SLF4JServiceProvider> providerList) {\n        // binderPathSet can be null under Android\n        if (!providerList.isEmpty() && isAmbiguousProviderList(providerList)) {\n            Util.report(\"Actual provider is of type [\" + providerList.get(0) + \"]\");\n        }\n    }\n\n    /**\n     * Return a logger named according to the name parameter using the\n     * statically bound {@link ILoggerFactory} instance.\n     * \n     * @param name\n     *            The name of the logger.\n     * @return logger\n     */\n    public static Logger getLogger(String name) {\n        ILoggerFactory iLoggerFactory = getILoggerFactory();\n        return iLoggerFactory.getLogger(name);\n    }\n\n    /**\n     * Return a logger named corresponding to the class passed as parameter,\n     * using the statically bound {@link ILoggerFactory} instance.\n     * \n     * <p>\n     * In case the <code>clazz<\/code> parameter differs from the name of the\n     * caller as computed internally by SLF4J, a logger name mismatch warning\n     * will be printed but only if the\n     * <code>slf4j.detectLoggerNameMismatch<\/code> system property is set to\n     * true. By default, this property is not set and no warnings will be\n     * printed even in case of a logger name mismatch.\n     * \n     * @param clazz\n     *            the returned logger will be named after clazz\n     * @return logger\n     * \n     * \n     * @see <a\n     *      href=\"http://www.slf4j.org/codes.html#loggerNameMismatch\">Detected\n     *      logger name mismatch<\/a>\n     */\n    public static Logger getLogger(Class<?> clazz) {\n        Logger logger = getLogger(clazz.getName());\n        if (DETECT_LOGGER_NAME_MISMATCH) {\n            Class<?> autoComputedCallingClass = Util.getCallingClass();\n            if (autoComputedCallingClass != null && nonMatchingClasses(clazz, autoComputedCallingClass)) {\n                Util.report(String.format(\"Detected logger name mismatch. Given name: \\\"%s\\\"; computed name: \\\"%s\\\".\", logger.getName(),\n                                autoComputedCallingClass.getName()));\n                Util.report(\"See \" + LOGGER_NAME_MISMATCH_URL + \" for an explanation\");\n            }\n        }\n        return logger;\n    }\n\n    private static boolean nonMatchingClasses(Class<?> clazz, Class<?> autoComputedCallingClass) {\n        return !autoComputedCallingClass.isAssignableFrom(clazz);\n    }\n\n    /**\n     * Return the {@link ILoggerFactory} instance in use.\n     * <p>\n     * <p>\n     * ILoggerFactory instance is bound with this class at compile time.\n     * \n     * @return the ILoggerFactory instance in use\n     */\n    public static ILoggerFactory getILoggerFactory() {\n        return getProvider().getLoggerFactory();\n    }\n\n    /**\n     * Return the {@link SLF4JServiceProvider} in use.\n    \n     * @return provider in use\n     * @since 1.8.0\n     */\n    static SLF4JServiceProvider getProvider() {\n        if (INITIALIZATION_STATE == UNINITIALIZED) {\n            synchronized (LoggerFactory.class) {\n                if (INITIALIZATION_STATE == UNINITIALIZED) {\n                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;\n                    performInitialization();\n                }\n            }\n        }\n        switch (INITIALIZATION_STATE) {\n        case SUCCESSFUL_INITIALIZATION:\n            return PROVIDER;\n        case NOP_FALLBACK_INITIALIZATION:\n            return NOP_FALLBACK_SERVICE_PROVIDER;\n        case FAILED_INITIALIZATION:\n            throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);\n        case ONGOING_INITIALIZATION:\n            // support re-entrant behavior.\n            // See also http://jira.qos.ch/browse/SLF4J-97\n            return SUBST_PROVIDER;\n        }\n        throw new IllegalStateException(\"Unreachable code\");\n    }\n}\n","lineNo":118}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport org.slf4j.spi.MDCAdapter;\n\nimport java.util.*;\nimport java.util.Map;\n\n/**\n * Basic MDC implementation, which can be used with logging systems that lack\n * out-of-the-box MDC support.\n *\n * This code was initially inspired by  logback's LogbackMDCAdapter. However,\n * LogbackMDCAdapter has evolved and is now considerably more sophisticated.\n *\n * @author Ceki Gulcu\n * @author Maarten Bosteels\n * @author Lukasz Cwik\n * \n * @since 1.5.0\n */\npublic class BasicMDCAdapter implements MDCAdapter {\n\n    private InheritableThreadLocal<Map<String, String>> inheritableThreadLocal = new InheritableThreadLocal<Map<String, String>>() {\n        @Override\n        protected Map<String, String> childValue(Map<String, String> parentValue) {\n            if (parentValue == null) {\n                return null;\n            }\n            return new HashMap<String, String>(parentValue);\n        }\n    };\n\n    /**\n     * Put a context value (the <code>val<\/code> parameter) as identified with\n     * the <code>key<\/code> parameter into the current thread's context map.\n     * Note that contrary to log4j, the <code>val<\/code> parameter can be null.\n     *\n     * <p>\n     * If the current thread does not have a context map it is created as a side\n     * effect of this call.\n     *\n     * @throws IllegalArgumentException\n     *                 in case the \"key\" parameter is null\n     */\n    public void put(String key, String val) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map == null) {\n            map = new HashMap<String, String>();\n            inheritableThreadLocal.set(map);\n        }\n        map.put(key, val);\n    }\n\n    /**\n     * Get the context identified by the <code>key<\/code> parameter.\n     */\n    public String get(String key) {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if ((map != null) && (key != null)) {\n            return map.get(key);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Remove the the context identified by the <code>key<\/code> parameter.\n     */\n    public void remove(String key) {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            map.remove(key);\n        }\n    }\n\n    /**\n     * Clear all entries in the MDC.\n     */\n    public void clear() {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            map.clear();\n            inheritableThreadLocal.remove();\n        }\n    }\n\n    /**\n     * Returns the keys in the MDC as a {@link Set} of {@link String}s The\n     * returned value can be null.\n     *\n     * @return the keys in the MDC\n     */\n    public Set<String> getKeys() {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            return map.keySet();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Return a copy of the current thread's context map.\n     * Returned value may be null.\n     *\n     */\n    public Map<String, String> getCopyOfContextMap() {\n        Map<String, String> oldMap = inheritableThreadLocal.get();\n        if (oldMap != null) {\n            return new HashMap<String, String>(oldMap);\n        } else {\n            return null;\n        }\n    }\n\n    public void setContextMap(Map<String, String> contextMap) {\n        Map<String, String> copy = null;\n        if(contextMap != null) {\n            copy = new HashMap<String, String>(contextMap);\n        }\n        inheritableThreadLocal.set(copy);\n    }\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport org.slf4j.spi.MDCAdapter;\n\nimport java.util.*;\nimport java.util.Map;\n\n/**\n * Basic MDC implementation, which can be used with logging systems that lack\n * out-of-the-box MDC support.\n *\n * This code was initially inspired by  logback's LogbackMDCAdapter. However,\n * LogbackMDCAdapter has evolved and is now considerably more sophisticated.\n *\n * @author Ceki Gulcu\n * @author Maarten Bosteels\n * @author Lukasz Cwik\n * \n * @since 1.5.0\n */\npublic class BasicMDCAdapter implements MDCAdapter {\n\n    private InheritableThreadLocal<Map<String, String>> inheritableThreadLocal = new InheritableThreadLocal<Map<String, String>>() {\n        @Override\n        protected Map<String, String> childValue(Map<String, String> parentValue) {\n            if (parentValue == null) {\n                return null;\n            }\n            return new HashMap<String, String>(parentValue);\n        }\n    };\n\n    /**\n     * Put a context value (the <code>val<\/code> parameter) as identified with\n     * the <code>key<\/code> parameter into the current thread's context map.\n     * Note that contrary to log4j, the <code>val<\/code> parameter can be null.\n     *\n     * <p>\n     * If the current thread does not have a context map it is created as a side\n     * effect of this call.\n     *\n     * @throws IllegalArgumentException\n     *                 in case the \"key\" parameter is null\n     */\n    public void put(String key, String val) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map == null) {\n            map = new HashMap<String, String>();\n            inheritableThreadLocal.set(map);\n        }\n        map.put(key, val);\n    }\n\n    /**\n     * Get the context identified by the <code>key<\/code> parameter.\n     */\n    public String get(String key) {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if ((map != null) && (key != null)) {\n            return map.get(key);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Remove the the context identified by the <code>key<\/code> parameter.\n     */\n    public void remove(String key) {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            map.remove(key);\n        }\n    }\n\n    /**\n     * Clear all entries in the MDC.\n     */\n    public void clear() {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            map.clear();\n            inheritableThreadLocal.remove();\n        }\n    }\n\n    /**\n     * Returns the keys in the MDC as a {@link Set} of {@link String}s The\n     * returned value can be null.\n     *\n     * @return the keys in the MDC\n     */\n    public Set<String> getKeys() {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            return map.keySet();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Return a copy of the current thread's context map.\n     * Returned value may be null.\n     *\n     */\n    public Map<String, String> getCopyOfContextMap() {\n        Map<String, String> oldMap = inheritableThreadLocal.get();\n        if (oldMap != null) {\n            return new HashMap<String, String>(oldMap);\n        } else {\n            return null;\n        }\n    }\n\n    public void setContextMap(Map<String, String> contextMap) {\n        inheritableThreadLocal.set(new HashMap<String, String>(contextMap));\n    }\n}\n","lineNo":144}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.jul;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.AbstractLogger;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.LegacyAbstractLogger;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.NormalizedParameters;\nimport org.slf4j.helpers.ParameterNormalizer;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends LegacyAbstractLogger implements LocationAwareLogger {\n\n\tprivate static final long serialVersionUID = -8053026990503422791L;\n\n\ttransient final java.util.logging.Logger logger;\n\n\t// WARN: JDK14LoggerAdapter constructor should have only package access so\n\t// that only JDK14LoggerFactory be able to create one.\n\tJDK14LoggerAdapter(java.util.logging.Logger logger) {\n\t\tthis.logger = logger;\n\t\tthis.name = logger.getName();\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the FINEST level?\n\t * \n\t * @return True if this Logger is enabled for level FINEST, false otherwise.\n\t */\n\tpublic boolean isTraceEnabled() {\n\t\treturn logger.isLoggable(Level.FINEST);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the FINE level?\n\t * \n\t * @return True if this Logger is enabled for level FINE, false otherwise.\n\t */\n\tpublic boolean isDebugEnabled() {\n\t\treturn logger.isLoggable(Level.FINE);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the INFO level?\n\t * \n\t * @return True if this Logger is enabled for the INFO level, false otherwise.\n\t */\n\tpublic boolean isInfoEnabled() {\n\t\treturn logger.isLoggable(Level.INFO);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the WARNING level?\n\t * \n\t * @return True if this Logger is enabled for the WARNING level, false\n\t *         otherwise.\n\t */\n\tpublic boolean isWarnEnabled() {\n\t\treturn logger.isLoggable(Level.WARNING);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for level SEVERE?\n\t * \n\t * @return True if this Logger is enabled for level SEVERE, false otherwise.\n\t */\n\tpublic boolean isErrorEnabled() {\n\t\treturn logger.isLoggable(Level.SEVERE);\n\t}\n\n//    /**\n//     * Log the message at the specified level with the specified throwable if any.\n//     * This method creates a LogRecord and fills in caller date before calling\n//     * this instance's JDK14 logger.\n//     * \n//     * See bug report #13 for more details.\n//     * \n//     * @param level\n//     * @param msg\n//     * @param t\n//     */\n//    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n//        // millis and thread are filled by the constructor\n//        LogRecord record = new LogRecord(level, msg);\n//        record.setLoggerName(getName());\n//        record.setThrown(t);\n//        // Note: parameters in record are not set because SLF4J only\n//        // supports a single formatting style\n//        fillCallerData(callerFQCN, record);\n//        logger.log(record);\n//    }\n\n\t/**\n\t * Log the message at the specified level with the specified throwable if any.\n\t * This method creates a LogRecord and fills in caller date before calling this\n\t * instance's JDK14 logger.\n\t */\n\t@Override\n\tprotected void handleNormalizedLoggingCall(org.slf4j.event.Level level, Marker marker, String msg, Object[] args,\n\t\t\tThrowable throwable) {\n\t\tinnerNormalizedLoggingCallHandler(getFullyQualifiedCallerName(), level, marker, msg, args, throwable);\n\t}\n\n\t\n\tprivate void innerNormalizedLoggingCallHandler(String fqcn, org.slf4j.event.Level level, Marker marker, String msg, Object[] args,\n\t\t\tThrowable throwable) {\n\t\t// millis and thread are filled by the constructor\n\t\tLevel julLevel = slf4jLevelToJULLevel(level);\n\t\tString formattedMessage = MessageFormatter.basicArrayFormat(msg, args);\n\t\tLogRecord record = new LogRecord(julLevel, formattedMessage);\n\n\t\t// https://jira.qos.ch/browse/SLF4J-13\n\t\trecord.setLoggerName(getName());\n\t\trecord.setThrown(throwable);\n\t\t// Note: parameters in record are not set because SLF4J only\n\t\t// supports a single formatting style\n\t\t// See also https://jira.qos.ch/browse/SLF4J-10\n\t\tfillCallerData(fqcn, record);\n\t\tlogger.log(record);\n\t}\n\n\t\n\t@Override\n\tprotected String getFullyQualifiedCallerName() {\n\t\treturn SELF;\n\t}\n\t\n\t\n\t@Override\n\tpublic void log(Marker marker, String callerFQCN, int slf4jLevelInt, String message, Object[] arguments,\n\t\t\tThrowable throwable) {\n\n\t\torg.slf4j.event.Level slf4jLevel = org.slf4j.event.Level.intToLevel(slf4jLevelInt);\n\t\tLevel julLevel = slf4jLevelIntToJULLevel(slf4jLevelInt);\n\t\t\n\t\tif (logger.isLoggable(julLevel)) {\n\t\t\tNormalizedParameters np = ParameterNormalizer.normalize(message, arguments, throwable);\n\t\t\tinnerNormalizedLoggingCallHandler(callerFQCN, slf4jLevel, marker, np.getMessage(), np.getArguments(), np.getThrowable());\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Fill in caller data if possible.\n\t * \n\t * @param record The record to update\n\t */\n\tfinal private void fillCallerData(String callerFQCN, LogRecord record) {\n\t\tStackTraceElement[] steArray = new Throwable().getStackTrace();\n\n\t\tint selfIndex = -1;\n\t\tfor (int i = 0; i < steArray.length; i++) {\n\t\t\tfinal String className = steArray[i].getClassName();\n\n\t\t\tif (barrierMatch(callerFQCN, className)) {\n\t\t\t\tselfIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint found = -1;\n\t\tfor (int i = selfIndex + 1; i < steArray.length; i++) {\n\t\t\tfinal String className = steArray[i].getClassName();\n\t\t\tif (!(barrierMatch(callerFQCN, className))) {\n\t\t\t\tfound = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found != -1) {\n\t\t\tStackTraceElement ste = steArray[found];\n\t\t\t// setting the class name has the side effect of setting\n\t\t\t// the needToInferCaller variable to false.\n\t\t\trecord.setSourceClassName(ste.getClassName());\n\t\t\trecord.setSourceMethodName(ste.getMethodName());\n\t\t}\n\t}\n\n\tstatic String SELF = JDK14LoggerAdapter.class.getName();\n\t\n\tstatic String SUPER = LegacyAbstractLogger.class.getName();\n\tstatic String SUPER_OF_SUPER = AbstractLogger.class.getName();\n\tstatic String SUBSTITUE = SubstituteLogger.class.getName();\n\n\tstatic String BARRIER_CLASSES[] = new String[] { SUPER_OF_SUPER, SUPER, SELF, SUBSTITUE };\n\n\tprivate boolean barrierMatch(String callerFQCN, String candidateClassName) {\n\t\tif (candidateClassName.equals(callerFQCN))\n\t\t\treturn true;\n\t\tfor (String barrierClassName : BARRIER_CLASSES) {\n\t\t\tif (barrierClassName.equals(candidateClassName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tprivate static Level slf4jLevelIntToJULLevel(int levelInt) {\n\t\torg.slf4j.event.Level slf4jLevel = org.slf4j.event.Level.intToLevel(levelInt);\n\t\treturn slf4jLevelToJULLevel(slf4jLevel);\n\t}\n\n\tprivate static Level slf4jLevelToJULLevel(org.slf4j.event.Level slf4jLevel) {\n\t\tLevel julLevel;\n\t\tswitch (slf4jLevel) {\n\t\tcase TRACE:\n\t\t\tjulLevel = Level.FINEST;\n\t\t\tbreak;\n\t\tcase DEBUG:\n\t\t\tjulLevel = Level.FINE;\n\t\t\tbreak;\n\t\tcase INFO:\n\t\t\tjulLevel = Level.INFO;\n\t\t\tbreak;\n\t\tcase WARN:\n\t\t\tjulLevel = Level.WARNING;\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\t\tjulLevel = Level.SEVERE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Level \" + slf4jLevel + \" is not recognized.\");\n\t\t}\n\t\treturn julLevel;\n\t}\n\n\t/**\n\t * @since 1.7.15\n\t */\n\tpublic void log(LoggingEvent event) {\n\t\t// assumes that the invocation is made from a substitute logger\n\t\t// this assumption might change in the future with the advent of a fluent API\n\t\tLevel julLevel = slf4jLevelToJULLevel(event.getLevel());\n\t\tif (logger.isLoggable(julLevel)) {\n\t\t\tLogRecord record = eventToRecord(event, julLevel);\n\t\t\tlogger.log(record);\n\t\t}\n\t}\n\n\tprivate LogRecord eventToRecord(LoggingEvent event, Level julLevel) {\n\t\tString format = event.getMessage();\n\t\tObject[] arguments = event.getArgumentArray();\n\t\tFormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n\t\tif (ft.getThrowable() != null && event.getThrowable() != null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"both last element in argument array and last argument are of type Throwable\");\n\t\t}\n\n\t\tThrowable t = event.getThrowable();\n\t\tif (ft.getThrowable() != null) {\n\t\t\tt = ft.getThrowable();\n\t\t\tthrow new IllegalStateException(\"fix above code\");\n\t\t}\n\n\t\tLogRecord record = new LogRecord(julLevel, ft.getMessage());\n\t\trecord.setLoggerName(event.getLoggerName());\n\t\trecord.setMillis(event.getTimeStamp());\n\t\trecord.setSourceClassName(EventConstants.NA_SUBST);\n\t\trecord.setSourceMethodName(EventConstants.NA_SUBST);\n\n\t\trecord.setThrown(t);\n\t\treturn record;\n\t}\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.jul;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger {\n\n    private static final long serialVersionUID = -8053026990503422791L;\n\n    transient final java.util.logging.Logger logger;\n\n    // WARN: JDK14LoggerAdapter constructor should have only package access so\n    // that only JDK14LoggerFactory be able to create one.\n    JDK14LoggerAdapter(java.util.logging.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n    }\n\n    /**\n     * Is this logger instance enabled for the FINEST level?\n     * \n     * @return True if this Logger is enabled for level FINEST, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINEST);\n    }\n\n    /**\n     * Log a message object at level FINEST.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINEST.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void trace(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINEST with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the FINE level?\n     * \n     * @return True if this Logger is enabled for level FINE, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    /**\n     * Log a message object at level FINE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINE.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void debug(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the WARNING level?\n     * \n     * @return True if this Logger is enabled for the WARNING level, false\n     *         otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    /**\n     * Log a message object at the WARNING level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARNING according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARNING level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for level SEVERE?\n     * \n     * @return True if this Logger is enabled for level SEVERE, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n\n    /**\n     * Log a message object at the SEVERE level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level SEVERE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void error(String format, Object... arguments) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the SEVERE level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, t);\n        }\n    }\n\n    /**\n     * Log the message at the specified level with the specified throwable if any.\n     * This method creates a LogRecord and fills in caller date before calling\n     * this instance's JDK14 logger.\n     * \n     * See bug report #13 for more details.\n     * \n     * @param level\n     * @param msg\n     * @param t\n     */\n    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n        // millis and thread are filled by the constructor\n        LogRecord record = new LogRecord(level, msg);\n        record.setLoggerName(getName());\n        record.setThrown(t);\n        // Note: parameters in record are not set because SLF4J only\n        // supports a single formatting style\n        fillCallerData(callerFQCN, record);\n        logger.log(record);\n    }\n\n    static String SELF = JDK14LoggerAdapter.class.getName();\n    static String SUPER = MarkerIgnoringBase.class.getName();\n    static String SUBSTITUE = SubstituteLogger.class.getName();\n    \n    static String BARRIER_CLASSES[] = new String[] {SELF, SUPER, SUBSTITUE};\n  \n    /**\n     * Fill in caller data if possible.\n     * \n     * @param record\n     *          The record to update\n     */\n\tfinal private void fillCallerData(String callerFQCN, LogRecord record) {\n        StackTraceElement[] steArray = new Throwable().getStackTrace();\n\n        int selfIndex = -1;\n        for (int i = 0; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            \n            if (barrierMatch(callerFQCN, className)) {\n                selfIndex = i;\n                break;\n            }\n        }\n\n        int found = -1;\n        for (int i = selfIndex + 1; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            if (!(barrierMatch(callerFQCN, className))) {\n                found = i;\n                break;\n            }\n        }\n\n        if (found != -1) {\n            StackTraceElement ste = steArray[found];\n            // setting the class name has the side effect of setting\n            // the needToInferCaller variable to false.\n            record.setSourceClassName(ste.getClassName());\n            record.setSourceMethodName(ste.getMethodName());\n        }\n    }\n\n    private boolean barrierMatch(String callerFQCN, String candidateClassName) {\n    \tif(candidateClassName.equals(callerFQCN))\n    \t\treturn true;\n    \tfor(String barrierClassName: BARRIER_CLASSES) {\n    \t\tif(barrierClassName.equals(candidateClassName)) {\n    \t\t  return true;\n    \t\t}\n    \t}\n    \treturn false;\n\t}\n\n\tpublic void log(Marker marker, String callerFQCN, int level, String message, Object[] argArray, Throwable t) {\n        Level julLevel = slf4jLevelIntToJULLevel(level);\n        // the logger.isLoggable check avoids the unconditional\n        // construction of location data for disabled log\n        // statements. As of 2008-07-31, callers of this method\n        // do not perform this check. See also\n        // http://jira.qos.ch/browse/SLF4J-81\n        if (logger.isLoggable(julLevel)) {\n            log(callerFQCN, julLevel, message, t);\n        }\n    }\n\n    private Level slf4jLevelIntToJULLevel(int slf4jLevelInt) {\n        Level julLevel;\n        switch (slf4jLevelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            julLevel = Level.FINEST;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            julLevel = Level.FINE;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            julLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            julLevel = Level.WARNING;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            julLevel = Level.SEVERE;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + slf4jLevelInt + \" is not recognized.\");\n        }\n        return julLevel;\n    }\n\n    /**\n     * @since 1.7.15\n     */\n    public void log(LoggingEvent event) {\n    \t// assumes that the invocation is made from a substitute logger\n    \t// this assumption might change in the future with the advent of a fluent API\n        Level julLevel = slf4jLevelIntToJULLevel(event.getLevel().toInt());\n        if (logger.isLoggable(julLevel)) {\n            LogRecord record = eventToRecord(event, julLevel);\n            logger.log(record);\n        }\n    }\n\n    private LogRecord eventToRecord(LoggingEvent event, Level julLevel) {\n        String format = event.getMessage();\n        Object[] arguments = event.getArgumentArray();\n        FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n        if (ft.getThrowable() != null && event.getThrowable() != null) {\n            throw new IllegalArgumentException(\"both last element in argument array and last argument are of type Throwable\");\n        }\n\n        Throwable t = event.getThrowable();\n        if (ft.getThrowable() != null) {\n            t = ft.getThrowable();\n            throw new IllegalStateException(\"fix above code\");\n        }\n\n        LogRecord record = new LogRecord(julLevel, ft.getMessage());\n        record.setLoggerName(event.getLoggerName());\n        record.setMillis(event.getTimeStamp());\n        record.setSourceClassName(EventConstants.NA_SUBST);\n        record.setSourceMethodName(EventConstants.NA_SUBST);\n\n        record.setThrown(t);\n        return record;\n    }\n}\n","lineNo":148}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.jul;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.AbstractLogger;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.LegacyAbstractLogger;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.NormalizedParameters;\nimport org.slf4j.helpers.ParameterNormalizer;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends LegacyAbstractLogger implements LocationAwareLogger {\n\n\tprivate static final long serialVersionUID = -8053026990503422791L;\n\n\ttransient final java.util.logging.Logger logger;\n\n\t// WARN: JDK14LoggerAdapter constructor should have only package access so\n\t// that only JDK14LoggerFactory be able to create one.\n\tJDK14LoggerAdapter(java.util.logging.Logger logger) {\n\t\tthis.logger = logger;\n\t\tthis.name = logger.getName();\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the FINEST level?\n\t * \n\t * @return True if this Logger is enabled for level FINEST, false otherwise.\n\t */\n\tpublic boolean isTraceEnabled() {\n\t\treturn logger.isLoggable(Level.FINEST);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the FINE level?\n\t * \n\t * @return True if this Logger is enabled for level FINE, false otherwise.\n\t */\n\tpublic boolean isDebugEnabled() {\n\t\treturn logger.isLoggable(Level.FINE);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the INFO level?\n\t * \n\t * @return True if this Logger is enabled for the INFO level, false otherwise.\n\t */\n\tpublic boolean isInfoEnabled() {\n\t\treturn logger.isLoggable(Level.INFO);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the WARNING level?\n\t * \n\t * @return True if this Logger is enabled for the WARNING level, false\n\t *         otherwise.\n\t */\n\tpublic boolean isWarnEnabled() {\n\t\treturn logger.isLoggable(Level.WARNING);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for level SEVERE?\n\t * \n\t * @return True if this Logger is enabled for level SEVERE, false otherwise.\n\t */\n\tpublic boolean isErrorEnabled() {\n\t\treturn logger.isLoggable(Level.SEVERE);\n\t}\n\n//    /**\n//     * Log the message at the specified level with the specified throwable if any.\n//     * This method creates a LogRecord and fills in caller date before calling\n//     * this instance's JDK14 logger.\n//     * \n//     * See bug report #13 for more details.\n//     * \n//     * @param level\n//     * @param msg\n//     * @param t\n//     */\n//    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n//        // millis and thread are filled by the constructor\n//        LogRecord record = new LogRecord(level, msg);\n//        record.setLoggerName(getName());\n//        record.setThrown(t);\n//        // Note: parameters in record are not set because SLF4J only\n//        // supports a single formatting style\n//        fillCallerData(callerFQCN, record);\n//        logger.log(record);\n//    }\n\n\t/**\n\t * Log the message at the specified level with the specified throwable if any.\n\t * This method creates a LogRecord and fills in caller date before calling this\n\t * instance's JDK14 logger.\n\t */\n\t@Override\n\tprotected void handleNormalizedLoggingCall(org.slf4j.event.Level level, Marker marker, String msg, Object[] args,\n\t\t\tThrowable throwable) {\n\t\tinnerNormalizedLoggingCallHandler(getFullyQualifiedCallerName(), level, marker, msg, args, throwable);\n\t}\n\n\t\n\tprivate void innerNormalizedLoggingCallHandler(String fqcn, org.slf4j.event.Level level, Marker marker, String msg, Object[] args,\n\t\t\tThrowable throwable) {\n\t\t// millis and thread are filled by the constructor\n\t\tLevel julLevel = slf4jLevelToJULLevel(level);\n\t\tString formattedMessage = MessageFormatter.basicArrayFormat(msg, args);\n\t\tLogRecord record = new LogRecord(julLevel, formattedMessage);\n\n\t\t// https://jira.qos.ch/browse/SLF4J-13\n\t\trecord.setLoggerName(getName());\n\t\trecord.setThrown(throwable);\n\t\t// Note: parameters in record are not set because SLF4J only\n\t\t// supports a single formatting style\n\t\t// See also https://jira.qos.ch/browse/SLF4J-10\n\t\tfillCallerData(fqcn, record);\n\t\tlogger.log(record);\n\t}\n\n\t\n\t@Override\n\tprotected String getFullyQualifiedCallerName() {\n\t\treturn SELF;\n\t}\n\t\n\t\n\t@Override\n\tpublic void log(Marker marker, String callerFQCN, int slf4jLevelInt, String message, Object[] arguments,\n\t\t\tThrowable throwable) {\n\n\t\torg.slf4j.event.Level slf4jLevel = org.slf4j.event.Level.intToLevel(slf4jLevelInt);\n\t\tLevel julLevel = slf4jLevelIntToJULLevel(slf4jLevelInt);\n\t\t\n\t\tif (logger.isLoggable(julLevel)) {\n\t\t\tNormalizedParameters np = ParameterNormalizer.normalize(message, arguments, throwable);\n\t\t\tinnerNormalizedLoggingCallHandler(callerFQCN, slf4jLevel, marker, np.getMessage(), np.getArguments(), np.getThrowable());\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Fill in caller data if possible.\n\t * \n\t * @param record The record to update\n\t */\n\tfinal private void fillCallerData(String callerFQCN, LogRecord record) {\n\t\tStackTraceElement[] steArray = new Throwable().getStackTrace();\n\n\t\tint selfIndex = -1;\n\t\tfor (int i = 0; i < steArray.length; i++) {\n\t\t\tfinal String className = steArray[i].getClassName();\n\n\t\t\tif (barrierMatch(callerFQCN, className)) {\n\t\t\t\tselfIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint found = -1;\n\t\tfor (int i = selfIndex + 1; i < steArray.length; i++) {\n\t\t\tfinal String className = steArray[i].getClassName();\n\t\t\tif (!(barrierMatch(callerFQCN, className))) {\n\t\t\t\tfound = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found != -1) {\n\t\t\tStackTraceElement ste = steArray[found];\n\t\t\t// setting the class name has the side effect of setting\n\t\t\t// the needToInferCaller variable to false.\n\t\t\trecord.setSourceClassName(ste.getClassName());\n\t\t\trecord.setSourceMethodName(ste.getMethodName());\n\t\t}\n\t}\n\n\tstatic String SELF = JDK14LoggerAdapter.class.getName();\n\t\n\tstatic String SUPER = LegacyAbstractLogger.class.getName();\n\tstatic String SUPER_OF_SUPER = AbstractLogger.class.getName();\n\tstatic String SUBSTITUE = SubstituteLogger.class.getName();\n\n\tstatic String BARRIER_CLASSES[] = new String[] { SUPER_OF_SUPER, SUPER, SELF, SUBSTITUE };\n\n\tprivate boolean barrierMatch(String callerFQCN, String candidateClassName) {\n\t\tif (candidateClassName.equals(callerFQCN))\n\t\t\treturn true;\n\t\tfor (String barrierClassName : BARRIER_CLASSES) {\n\t\t\tif (barrierClassName.equals(candidateClassName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tprivate static Level slf4jLevelIntToJULLevel(int levelInt) {\n\t\torg.slf4j.event.Level slf4jLevel = org.slf4j.event.Level.intToLevel(levelInt);\n\t\treturn slf4jLevelToJULLevel(slf4jLevel);\n\t}\n\n\tprivate static Level slf4jLevelToJULLevel(org.slf4j.event.Level slf4jLevel) {\n\t\tLevel julLevel;\n\t\tswitch (slf4jLevel) {\n\t\tcase TRACE:\n\t\t\tjulLevel = Level.FINEST;\n\t\t\tbreak;\n\t\tcase DEBUG:\n\t\t\tjulLevel = Level.FINE;\n\t\t\tbreak;\n\t\tcase INFO:\n\t\t\tjulLevel = Level.INFO;\n\t\t\tbreak;\n\t\tcase WARN:\n\t\t\tjulLevel = Level.WARNING;\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\t\tjulLevel = Level.SEVERE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Level \" + slf4jLevel + \" is not recognized.\");\n\t\t}\n\t\treturn julLevel;\n\t}\n\n\t/**\n\t * @since 1.7.15\n\t */\n\tpublic void log(LoggingEvent event) {\n\t\t// assumes that the invocation is made from a substitute logger\n\t\t// this assumption might change in the future with the advent of a fluent API\n\t\tLevel julLevel = slf4jLevelToJULLevel(event.getLevel());\n\t\tif (logger.isLoggable(julLevel)) {\n\t\t\tLogRecord record = eventToRecord(event, julLevel);\n\t\t\tlogger.log(record);\n\t\t}\n\t}\n\n\tprivate LogRecord eventToRecord(LoggingEvent event, Level julLevel) {\n\t\tString format = event.getMessage();\n\t\tObject[] arguments = event.getArgumentArray();\n\t\tFormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n\t\tif (ft.getThrowable() != null && event.getThrowable() != null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"both last element in argument array and last argument are of type Throwable\");\n\t\t}\n\n\t\tThrowable t = event.getThrowable();\n\t\tif (ft.getThrowable() != null) {\n\t\t\tt = ft.getThrowable();\n\t\t\tthrow new IllegalStateException(\"fix above code\");\n\t\t}\n\n\t\tLogRecord record = new LogRecord(julLevel, ft.getMessage());\n\t\trecord.setLoggerName(event.getLoggerName());\n\t\trecord.setMillis(event.getTimeStamp());\n\t\trecord.setSourceClassName(EventConstants.NA_SUBST);\n\t\trecord.setSourceMethodName(EventConstants.NA_SUBST);\n\n\t\trecord.setThrown(t);\n\t\treturn record;\n\t}\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.jul;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger {\n\n    private static final long serialVersionUID = -8053026990503422791L;\n\n    transient final java.util.logging.Logger logger;\n\n    // WARN: JDK14LoggerAdapter constructor should have only package access so\n    // that only JDK14LoggerFactory be able to create one.\n    JDK14LoggerAdapter(java.util.logging.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n    }\n\n    /**\n     * Is this logger instance enabled for the FINEST level?\n     * \n     * @return True if this Logger is enabled for level FINEST, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINEST);\n    }\n\n    /**\n     * Log a message object at level FINEST.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINEST.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void trace(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINEST with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the FINE level?\n     * \n     * @return True if this Logger is enabled for level FINE, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    /**\n     * Log a message object at level FINE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINE.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void debug(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the WARNING level?\n     * \n     * @return True if this Logger is enabled for the WARNING level, false\n     *         otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    /**\n     * Log a message object at the WARNING level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARNING according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARNING level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for level SEVERE?\n     * \n     * @return True if this Logger is enabled for level SEVERE, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n\n    /**\n     * Log a message object at the SEVERE level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level SEVERE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void error(String format, Object... arguments) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the SEVERE level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, t);\n        }\n    }\n\n    /**\n     * Log the message at the specified level with the specified throwable if any.\n     * This method creates a LogRecord and fills in caller date before calling\n     * this instance's JDK14 logger.\n     * \n     * See bug report #13 for more details.\n     * \n     * @param level\n     * @param msg\n     * @param t\n     */\n    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n        // millis and thread are filled by the constructor\n        LogRecord record = new LogRecord(level, msg);\n        record.setLoggerName(getName());\n        record.setThrown(t);\n        // Note: parameters in record are not set because SLF4J only\n        // supports a single formatting style\n        fillCallerData(callerFQCN, record);\n        logger.log(record);\n    }\n\n    static String SELF = JDK14LoggerAdapter.class.getName();\n    static String SUPER = MarkerIgnoringBase.class.getName();\n    static String SUBSTITUE = SubstituteLogger.class.getName();\n    \n    static String BARRIER_CLASSES[] = new String[] {SELF, SUPER, SUBSTITUE};\n  \n    /**\n     * Fill in caller data if possible.\n     * \n     * @param record\n     *          The record to update\n     */\n\tfinal private void fillCallerData(String callerFQCN, LogRecord record) {\n        StackTraceElement[] steArray = new Throwable().getStackTrace();\n\n        int selfIndex = -1;\n        for (int i = 0; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            \n            if (barrierMatch(callerFQCN, className)) {\n                selfIndex = i;\n                break;\n            }\n        }\n\n        int found = -1;\n        for (int i = selfIndex + 1; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            if (!(barrierMatch(callerFQCN, className))) {\n                found = i;\n                break;\n            }\n        }\n\n        if (found != -1) {\n            StackTraceElement ste = steArray[found];\n            // setting the class name has the side effect of setting\n            // the needToInferCaller variable to false.\n            record.setSourceClassName(ste.getClassName());\n            record.setSourceMethodName(ste.getMethodName());\n        }\n    }\n\n    private boolean barrierMatch(String callerFQCN, String candidateClassName) {\n    \tif(candidateClassName.equals(callerFQCN))\n    \t\treturn true;\n    \tfor(String barrierClassName: BARRIER_CLASSES) {\n    \t\tif(barrierClassName.equals(candidateClassName)) {\n    \t\t  return true;\n    \t\t}\n    \t}\n    \treturn false;\n\t}\n\n\tpublic void log(Marker marker, String callerFQCN, int level, String message, Object[] argArray, Throwable t) {\n        Level julLevel = slf4jLevelIntToJULLevel(level);\n        // the logger.isLoggable check avoids the unconditional\n        // construction of location data for disabled log\n        // statements. As of 2008-07-31, callers of this method\n        // do not perform this check. See also\n        // http://jira.qos.ch/browse/SLF4J-81\n        if (logger.isLoggable(julLevel)) {\n            log(callerFQCN, julLevel, message, t);\n        }\n    }\n\n    private Level slf4jLevelIntToJULLevel(int slf4jLevelInt) {\n        Level julLevel;\n        switch (slf4jLevelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            julLevel = Level.FINEST;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            julLevel = Level.FINE;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            julLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            julLevel = Level.WARNING;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            julLevel = Level.SEVERE;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + slf4jLevelInt + \" is not recognized.\");\n        }\n        return julLevel;\n    }\n\n    /**\n     * @since 1.7.15\n     */\n    public void log(LoggingEvent event) {\n    \t// assumes that the invocation is made from a substitute logger\n    \t// this assumption might change in the future with the advent of a fluent API\n        Level julLevel = slf4jLevelIntToJULLevel(event.getLevel().toInt());\n        if (logger.isLoggable(julLevel)) {\n            LogRecord record = eventToRecord(event, julLevel);\n            logger.log(record);\n        }\n    }\n\n    private LogRecord eventToRecord(LoggingEvent event, Level julLevel) {\n        String format = event.getMessage();\n        Object[] arguments = event.getArgumentArray();\n        FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n        if (ft.getThrowable() != null && event.getThrowable() != null) {\n            throw new IllegalArgumentException(\"both last element in argument array and last argument are of type Throwable\");\n        }\n\n        Throwable t = event.getThrowable();\n        if (ft.getThrowable() != null) {\n            t = ft.getThrowable();\n            throw new IllegalStateException(\"fix above code\");\n        }\n\n        LogRecord record = new LogRecord(julLevel, ft.getMessage());\n        record.setLoggerName(event.getLoggerName());\n        record.setMillis(event.getTimeStamp());\n        record.setSourceClassName(EventConstants.NA_SUBST);\n        record.setSourceMethodName(EventConstants.NA_SUBST);\n\n        record.setThrown(t);\n        return record;\n    }\n}\n","lineNo":149}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.log4j12;\n\nimport static org.slf4j.event.EventConstants.NA_SUBST;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Level;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.ThrowableInformation;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.LegacyAbstractLogger;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.NormalizedParameters;\nimport org.slf4j.helpers.ParameterNormalizer;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends LegacyAbstractLogger implements LocationAwareLogger, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n\n    @Override\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] arguments, Throwable t) {\n        Level log4jLevel = toLog4jLevel(level);\n        NormalizedParameters np = ParameterNormalizer.normalize(msg, arguments, t);\n        String formattedMessage = MessageFormatter.basicArrayFormat(np.getMessage(), np.getArguments());\n        logger.log(callerFQCN, log4jLevel, formattedMessage, np.getThrowable());\n    }\n\n\t@Override\n\tprotected void handleNormalizedLoggingCall(org.slf4j.event.Level level, Marker marker, String msg, Object[] arguments,\n\t\t\tThrowable throwable) {\n\t\tLevel log4jLevel = toLog4jLevel(level.toInt());\n\t\tString formattedMessage = MessageFormatter.basicArrayFormat(msg, arguments);\n\t\tlogger.log(getFullyQualifiedCallerName(), log4jLevel, formattedMessage, throwable);\n\t}\n\n\t/**\n\t * Called by {@link SubstituteLogger}\n\t * @param event\n\t */\n    public void log(LoggingEvent event) {\n        Level log4jLevel = toLog4jLevel(event.getLevel().toInt());\n        if (!logger.isEnabledFor(log4jLevel))\n            return;\n\n        org.apache.log4j.spi.LoggingEvent log4jevent = toLog4jEvent(event, log4jLevel);\n        logger.callAppenders(log4jevent);\n\n    }\n    \n    private org.apache.log4j.spi.LoggingEvent toLog4jEvent(LoggingEvent event, Level log4jLevel) {\n\n        String formattedMessage = MessageFormatter.basicArrayFormat(event.getMessage(), event.getArgumentArray());\n\n        LocationInfo locationInfo = new LocationInfo(NA_SUBST, NA_SUBST, NA_SUBST, \"0\");\n\n        ThrowableInformation ti = null;\n        Throwable t = event.getThrowable();\n        if (t != null)\n            ti = new ThrowableInformation(t);\n\n        org.apache.log4j.spi.LoggingEvent log4jEvent = new org.apache.log4j.spi.LoggingEvent(FQCN, logger, event.getTimeStamp(), log4jLevel, formattedMessage,\n                        event.getThreadName(), ti, null, locationInfo, null);\n\n        return log4jEvent;\n    }\n\n\n\t\n    private Level toLog4jLevel(int slf4jLevelInt) {\n        Level log4jLevel;\n        switch (slf4jLevelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + slf4jLevelInt + \" is not recognized.\");\n        }\n        return log4jLevel;\n    }\n\n\t@Override\n\tprotected String getFullyQualifiedCallerName() {\n\t\treturn FQCN;\n\t}\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.log4j12;\n\nimport static org.slf4j.event.EventConstants.NA_SUBST;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Level;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.ThrowableInformation;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Log a message object at level TRACE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level TRACE.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void trace(String format, Object... arguments) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level TRACE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    /**\n     * Log a message object at level DEBUG.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level DEBUG.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments an array of arguments\n     */\n    public void debug(String format, Object... arguments) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level DEBUG with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        logger.log(FQCN, Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        logger.log(FQCN, Level.INFO, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    /**\n     * Log a message object at the WARN level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARN according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARN level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        logger.log(FQCN, Level.WARN, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    /**\n     * Log a message object at the ERROR level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level ERROR according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void error(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the ERROR level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        logger.log(FQCN, Level.ERROR, msg, t);\n    }\n\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] argArray, Throwable t) {\n        Level log4jLevel = toLog4jLevel(level);\n        logger.log(callerFQCN, log4jLevel, msg, t);\n    }\n\n    private Level toLog4jLevel(int level) {\n        Level log4jLevel;\n        switch (level) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + level + \" is not recognized.\");\n        }\n        return log4jLevel;\n    }\n\n    public void log(LoggingEvent event) {\n        Level log4jLevel = toLog4jLevel(event.getLevel().toInt());\n        if (!logger.isEnabledFor(log4jLevel))\n            return;\n\n        org.apache.log4j.spi.LoggingEvent log4jevent = toLog4jEvent(event, log4jLevel);\n        logger.callAppenders(log4jevent);\n\n    }\n\n    private org.apache.log4j.spi.LoggingEvent toLog4jEvent(LoggingEvent event, Level log4jLevel) {\n\n        FormattingTuple ft = MessageFormatter.format(event.getMessage(), event.getArgumentArray(), event.getThrowable());\n\n        LocationInfo locationInfo = new LocationInfo(NA_SUBST, NA_SUBST, NA_SUBST, \"0\");\n\n        ThrowableInformation ti = null;\n        Throwable t = ft.getThrowable();\n        if (t != null)\n            ti = new ThrowableInformation(t);\n\n        org.apache.log4j.spi.LoggingEvent log4jEvent = new org.apache.log4j.spi.LoggingEvent(FQCN, logger, event.getTimeStamp(), log4jLevel, ft.getMessage(),\n                        event.getThreadName(), ti, null, locationInfo, null);\n\n        return log4jEvent;\n    }\n\n}\n","lineNo":151}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.log4j12;\n\nimport static org.slf4j.event.EventConstants.NA_SUBST;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Level;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.ThrowableInformation;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.LegacyAbstractLogger;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.NormalizedParameters;\nimport org.slf4j.helpers.ParameterNormalizer;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends LegacyAbstractLogger implements LocationAwareLogger, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n\n    @Override\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] arguments, Throwable t) {\n        Level log4jLevel = toLog4jLevel(level);\n        NormalizedParameters np = ParameterNormalizer.normalize(msg, arguments, t);\n        String formattedMessage = MessageFormatter.basicArrayFormat(np.getMessage(), np.getArguments());\n        logger.log(callerFQCN, log4jLevel, formattedMessage, np.getThrowable());\n    }\n\n\t@Override\n\tprotected void handleNormalizedLoggingCall(org.slf4j.event.Level level, Marker marker, String msg, Object[] arguments,\n\t\t\tThrowable throwable) {\n\t\tLevel log4jLevel = toLog4jLevel(level.toInt());\n\t\tString formattedMessage = MessageFormatter.basicArrayFormat(msg, arguments);\n\t\tlogger.log(getFullyQualifiedCallerName(), log4jLevel, formattedMessage, throwable);\n\t}\n\n\t/**\n\t * Called by {@link SubstituteLogger}\n\t * @param event\n\t */\n    public void log(LoggingEvent event) {\n        Level log4jLevel = toLog4jLevel(event.getLevel().toInt());\n        if (!logger.isEnabledFor(log4jLevel))\n            return;\n\n        org.apache.log4j.spi.LoggingEvent log4jevent = toLog4jEvent(event, log4jLevel);\n        logger.callAppenders(log4jevent);\n\n    }\n    \n    private org.apache.log4j.spi.LoggingEvent toLog4jEvent(LoggingEvent event, Level log4jLevel) {\n\n        String formattedMessage = MessageFormatter.basicArrayFormat(event.getMessage(), event.getArgumentArray());\n\n        LocationInfo locationInfo = new LocationInfo(NA_SUBST, NA_SUBST, NA_SUBST, \"0\");\n\n        ThrowableInformation ti = null;\n        Throwable t = event.getThrowable();\n        if (t != null)\n            ti = new ThrowableInformation(t);\n\n        org.apache.log4j.spi.LoggingEvent log4jEvent = new org.apache.log4j.spi.LoggingEvent(FQCN, logger, event.getTimeStamp(), log4jLevel, formattedMessage,\n                        event.getThreadName(), ti, null, locationInfo, null);\n\n        return log4jEvent;\n    }\n\n\n\t\n    private Level toLog4jLevel(int slf4jLevelInt) {\n        Level log4jLevel;\n        switch (slf4jLevelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + slf4jLevelInt + \" is not recognized.\");\n        }\n        return log4jLevel;\n    }\n\n\t@Override\n\tprotected String getFullyQualifiedCallerName() {\n\t\treturn FQCN;\n\t}\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.log4j12;\n\nimport static org.slf4j.event.EventConstants.NA_SUBST;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Level;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.ThrowableInformation;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Log a message object at level TRACE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level TRACE.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void trace(String format, Object... arguments) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level TRACE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    /**\n     * Log a message object at level DEBUG.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level DEBUG.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments an array of arguments\n     */\n    public void debug(String format, Object... arguments) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level DEBUG with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        logger.log(FQCN, Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        logger.log(FQCN, Level.INFO, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    /**\n     * Log a message object at the WARN level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARN according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARN level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        logger.log(FQCN, Level.WARN, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    /**\n     * Log a message object at the ERROR level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level ERROR according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void error(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the ERROR level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        logger.log(FQCN, Level.ERROR, msg, t);\n    }\n\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] argArray, Throwable t) {\n        Level log4jLevel = toLog4jLevel(level);\n        logger.log(callerFQCN, log4jLevel, msg, t);\n    }\n\n    private Level toLog4jLevel(int level) {\n        Level log4jLevel;\n        switch (level) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + level + \" is not recognized.\");\n        }\n        return log4jLevel;\n    }\n\n    public void log(LoggingEvent event) {\n        Level log4jLevel = toLog4jLevel(event.getLevel().toInt());\n        if (!logger.isEnabledFor(log4jLevel))\n            return;\n\n        org.apache.log4j.spi.LoggingEvent log4jevent = toLog4jEvent(event, log4jLevel);\n        logger.callAppenders(log4jevent);\n\n    }\n\n    private org.apache.log4j.spi.LoggingEvent toLog4jEvent(LoggingEvent event, Level log4jLevel) {\n\n        FormattingTuple ft = MessageFormatter.format(event.getMessage(), event.getArgumentArray(), event.getThrowable());\n\n        LocationInfo locationInfo = new LocationInfo(NA_SUBST, NA_SUBST, NA_SUBST, \"0\");\n\n        ThrowableInformation ti = null;\n        Throwable t = ft.getThrowable();\n        if (t != null)\n            ti = new ThrowableInformation(t);\n\n        org.apache.log4j.spi.LoggingEvent log4jEvent = new org.apache.log4j.spi.LoggingEvent(FQCN, logger, event.getTimeStamp(), log4jLevel, ft.getMessage(),\n                        event.getThreadName(), ti, null, locationInfo, null);\n\n        return log4jEvent;\n    }\n\n}\n","lineNo":152}
{"Refactored Sample":"package org.slf4j.jdk;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ResourceBundle;\n\nimport static java.util.Objects.requireNonNull;\n\n/**\n * Adapts {@link Logger} to {@link System.Logger}.\n */\nclass SLF4JSystemLogger implements System.Logger {\n\n    private static final Logger INTERNAL_LOGGER = LoggerFactory.getLogger(SLF4JSystemLogger.class);\n\n    private final Logger logger;\n\n    public SLF4JSystemLogger(Logger logger) {\n        this.logger = requireNonNull(logger);\n    }\n\n    @Override\n    public String getName() {\n        return logger.getName();\n    }\n\n    @Override\n    public boolean isLoggable(Level level) {\n        switch(level) {\n            case ALL:\n                // fall-through intended because `ALL` is loggable if the\n                // lowest level is enabled\n            case TRACE:\n                return logger.isTraceEnabled();\n            case DEBUG:\n                return logger.isDebugEnabled();\n            case INFO:\n                return logger.isInfoEnabled();\n            case WARNING:\n                return logger.isWarnEnabled();\n            case ERROR:\n                return logger.isErrorEnabled();\n            case OFF:\n                // all logging is disabled if the highest level is disabled\n                return !logger.isErrorEnabled();\n            default:\n                INTERNAL_LOGGER.error(\n                        \"SLF4J internal error: unknown log level {} passed to `isLoggable` (likely by the JDK).\", level);\n                return true;\n        }\n    }\n\n    @Override\n    public void log(Level level, ResourceBundle bundle, String msg, Throwable thrown) {\n        String message = bundle == null ? msg : bundle.getString(msg);\n        switch(level) {\n            case ALL:\n                // fall-through intended because a message is visible on all log levels\n                // if it is logged on the lowest level\n            case TRACE:\n                logger.trace(message, thrown);\n                break;\n            case DEBUG:\n                logger.debug(message, thrown);\n                break;\n            case INFO:\n                logger.info(message, thrown);\n                break;\n            case WARNING:\n                logger.warn(message, thrown);\n                break;\n            case ERROR:\n                logger.error(message, thrown);\n                break;\n            case OFF:\n                // don't do anything for a message on level `OFF`\n                break;\n            default:\n                INTERNAL_LOGGER.error(\n                        \"SLF4J internal error: unknown log level {} passed to `log` (likely by the JDK).\", level);\n        }\n    }\n\n    @Override\n    public void log(Level level, ResourceBundle bundle, String format, Object... params) {\n        String message = bundle == null ? format : bundle.getString(format);\n        switch(level) {\n            case ALL:\n                // fall-through intended because a message is visible on all log levels\n                // if it is logged on the lowest level\n            case TRACE:\n                logger.trace(message, params);\n                break;\n            case DEBUG:\n                logger.debug(message, params);\n                break;\n            case INFO:\n                logger.info(message, params);\n                break;\n            case WARNING:\n                logger.warn(message, params);\n                break;\n            case ERROR:\n                logger.error(message, params);\n                break;\n            case OFF:\n                // don't do anything for a message on level `OFF`\n                break;\n            default:\n                INTERNAL_LOGGER.error(\n                        \"SLF4J internal error: unknown log level {} passed to `log` (likely by the JDK).\", level);\n        }\n    }\n\n}\n","Smelly Sample":"package org.slf4j.jdk;\n\nimport org.slf4j.Logger;\n\nimport java.text.MessageFormat;\nimport java.util.ResourceBundle;\n\nimport static java.util.Objects.requireNonNull;\n\nclass SLF4JSystemLogger implements System.Logger {\n\n    private final Logger logger;\n\n    public SLF4JSystemLogger(Logger logger) {\n        this.logger = requireNonNull(logger);\n    }\n\n    @Override\n    public String getName() {\n        return logger.getName();\n    }\n\n    @Override\n    public boolean isLoggable(Level level) {\n        switch(level) {\n            case ALL:\n                throw new UnsupportedOperationException();\n            case TRACE:\n                return logger.isTraceEnabled();\n            case DEBUG:\n                return logger.isDebugEnabled();\n            case INFO:\n                return logger.isInfoEnabled();\n            case WARNING:\n                return logger.isWarnEnabled();\n            case ERROR:\n                return logger.isErrorEnabled();\n            case OFF:\n                throw new UnsupportedOperationException();\n        }\n        // TODO\n        return true;\n    }\n\n    @Override\n    public void log(Level level, ResourceBundle bundle, String msg, Throwable thrown) {\n        switch(level) {\n            case ALL:\n                throw new UnsupportedOperationException();\n            case TRACE:\n                logger.trace(msg, thrown);\n                break;\n            case DEBUG:\n                logger.debug(msg, thrown);\n                break;\n            case INFO:\n                logger.info(msg, thrown);\n                break;\n            case WARNING:\n                logger.warn(msg, thrown);\n                break;\n            case ERROR:\n                logger.error(msg, thrown);\n                break;\n            case OFF:\n                throw new UnsupportedOperationException();\n        }\n    }\n\n    @Override\n    public void log(Level level, ResourceBundle bundle, String format, Object... params) {\n        switch(level) {\n            case ALL:\n                throw new UnsupportedOperationException();\n            case TRACE:\n                logger.trace(MessageFormat.format(format, params));\n                break;\n            case DEBUG:\n                logger.debug(MessageFormat.format(format, params));\n                break;\n            case INFO:\n                logger.info(MessageFormat.format(format, params));\n                break;\n            case WARNING:\n                logger.warn(MessageFormat.format(format, params));\n                break;\n            case ERROR:\n                logger.error(MessageFormat.format(format, params));\n                break;\n            case OFF:\n                throw new UnsupportedOperationException();\n        }\n    }\n\n}\n","lineNo":56}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport org.slf4j.spi.MDCAdapter;\n\nimport java.util.*;\nimport java.util.Map;\n\n/**\n * Basic MDC implementation, which can be used with logging systems that lack\n * out-of-the-box MDC support.\n *\n * This code was initially inspired by  logback's LogbackMDCAdapter. However,\n * LogbackMDCAdapter has evolved and is now considerably more sophisticated.\n *\n * @author Ceki Gulcu\n * @author Maarten Bosteels\n * @author Lukasz Cwik\n * \n * @since 1.5.0\n */\npublic class BasicMDCAdapter implements MDCAdapter {\n\n    private InheritableThreadLocal<Map<String, String>> inheritableThreadLocal = new InheritableThreadLocal<Map<String, String>>() {\n        @Override\n        protected Map<String, String> childValue(Map<String, String> parentValue) {\n            if (parentValue == null) {\n                return null;\n            }\n            return new HashMap<String, String>(parentValue);\n        }\n    };\n\n    /**\n     * Put a context value (the <code>val<\/code> parameter) as identified with\n     * the <code>key<\/code> parameter into the current thread's context map.\n     * Note that contrary to log4j, the <code>val<\/code> parameter can be null.\n     *\n     * <p>\n     * If the current thread does not have a context map it is created as a side\n     * effect of this call.\n     *\n     * @throws IllegalArgumentException\n     *                 in case the \"key\" parameter is null\n     */\n    public void put(String key, String val) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map == null) {\n            map = new HashMap<String, String>();\n            inheritableThreadLocal.set(map);\n        }\n        map.put(key, val);\n    }\n\n    /**\n     * Get the context identified by the <code>key<\/code> parameter.\n     */\n    public String get(String key) {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if ((map != null) && (key != null)) {\n            return map.get(key);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Remove the the context identified by the <code>key<\/code> parameter.\n     */\n    public void remove(String key) {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            map.remove(key);\n        }\n    }\n\n    /**\n     * Clear all entries in the MDC.\n     */\n    public void clear() {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            map.clear();\n            inheritableThreadLocal.remove();\n        }\n    }\n\n    /**\n     * Returns the keys in the MDC as a {@link Set} of {@link String}s The\n     * returned value can be null.\n     *\n     * @return the keys in the MDC\n     */\n    public Set<String> getKeys() {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            return map.keySet();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Return a copy of the current thread's context map.\n     * Returned value may be null.\n     *\n     */\n    public Map<String, String> getCopyOfContextMap() {\n        Map<String, String> oldMap = inheritableThreadLocal.get();\n        if (oldMap != null) {\n            return new HashMap<String, String>(oldMap);\n        } else {\n            return null;\n        }\n    }\n\n    public void setContextMap(Map<String, String> contextMap) {\n        Map<String, String> copy = null;\n        if(contextMap != null) {\n            copy = new HashMap<String, String>(contextMap);\n        }\n        inheritableThreadLocal.set(copy);\n    }\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport org.slf4j.spi.MDCAdapter;\n\nimport java.util.*;\nimport java.util.Map;\n\n/**\n * Basic MDC implementation, which can be used with logging systems that lack\n * out-of-the-box MDC support.\n *\n * This code was initially inspired by  logback's LogbackMDCAdapter. However,\n * LogbackMDCAdapter has evolved and is now considerably more sophisticated.\n *\n * @author Ceki Gulcu\n * @author Maarten Bosteels\n * @author Lukasz Cwik\n * \n * @since 1.5.0\n */\npublic class BasicMDCAdapter implements MDCAdapter {\n\n    private InheritableThreadLocal<Map<String, String>> inheritableThreadLocal = new InheritableThreadLocal<Map<String, String>>() {\n        @Override\n        protected Map<String, String> childValue(Map<String, String> parentValue) {\n            if (parentValue == null) {\n                return null;\n            }\n            return new HashMap<String, String>(parentValue);\n        }\n    };\n\n    /**\n     * Put a context value (the <code>val<\/code> parameter) as identified with\n     * the <code>key<\/code> parameter into the current thread's context map.\n     * Note that contrary to log4j, the <code>val<\/code> parameter can be null.\n     *\n     * <p>\n     * If the current thread does not have a context map it is created as a side\n     * effect of this call.\n     *\n     * @throws IllegalArgumentException\n     *                 in case the \"key\" parameter is null\n     */\n    public void put(String key, String val) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map == null) {\n            map = new HashMap<String, String>();\n            inheritableThreadLocal.set(map);\n        }\n        map.put(key, val);\n    }\n\n    /**\n     * Get the context identified by the <code>key<\/code> parameter.\n     */\n    public String get(String key) {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if ((map != null) && (key != null)) {\n            return map.get(key);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Remove the the context identified by the <code>key<\/code> parameter.\n     */\n    public void remove(String key) {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            map.remove(key);\n        }\n    }\n\n    /**\n     * Clear all entries in the MDC.\n     */\n    public void clear() {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            map.clear();\n            inheritableThreadLocal.remove();\n        }\n    }\n\n    /**\n     * Returns the keys in the MDC as a {@link Set} of {@link String}s The\n     * returned value can be null.\n     *\n     * @return the keys in the MDC\n     */\n    public Set<String> getKeys() {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            return map.keySet();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Return a copy of the current thread's context map.\n     * Returned value may be null.\n     *\n     */\n    public Map<String, String> getCopyOfContextMap() {\n        Map<String, String> oldMap = inheritableThreadLocal.get();\n        if (oldMap != null) {\n            return new HashMap<String, String>(oldMap);\n        } else {\n            return null;\n        }\n    }\n\n    public void setContextMap(Map<String, String> contextMap) {\n        inheritableThreadLocal.set(new HashMap<String, String>(contextMap));\n    }\n}\n","lineNo":144}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.jul;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.AbstractLogger;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.LegacyAbstractLogger;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.NormalizedParameters;\nimport org.slf4j.helpers.ParameterNormalizer;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends LegacyAbstractLogger implements LocationAwareLogger {\n\n\tprivate static final long serialVersionUID = -8053026990503422791L;\n\n\ttransient final java.util.logging.Logger logger;\n\n\t// WARN: JDK14LoggerAdapter constructor should have only package access so\n\t// that only JDK14LoggerFactory be able to create one.\n\tJDK14LoggerAdapter(java.util.logging.Logger logger) {\n\t\tthis.logger = logger;\n\t\tthis.name = logger.getName();\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the FINEST level?\n\t * \n\t * @return True if this Logger is enabled for level FINEST, false otherwise.\n\t */\n\tpublic boolean isTraceEnabled() {\n\t\treturn logger.isLoggable(Level.FINEST);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the FINE level?\n\t * \n\t * @return True if this Logger is enabled for level FINE, false otherwise.\n\t */\n\tpublic boolean isDebugEnabled() {\n\t\treturn logger.isLoggable(Level.FINE);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the INFO level?\n\t * \n\t * @return True if this Logger is enabled for the INFO level, false otherwise.\n\t */\n\tpublic boolean isInfoEnabled() {\n\t\treturn logger.isLoggable(Level.INFO);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the WARNING level?\n\t * \n\t * @return True if this Logger is enabled for the WARNING level, false\n\t *         otherwise.\n\t */\n\tpublic boolean isWarnEnabled() {\n\t\treturn logger.isLoggable(Level.WARNING);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for level SEVERE?\n\t * \n\t * @return True if this Logger is enabled for level SEVERE, false otherwise.\n\t */\n\tpublic boolean isErrorEnabled() {\n\t\treturn logger.isLoggable(Level.SEVERE);\n\t}\n\n//    /**\n//     * Log the message at the specified level with the specified throwable if any.\n//     * This method creates a LogRecord and fills in caller date before calling\n//     * this instance's JDK14 logger.\n//     * \n//     * See bug report #13 for more details.\n//     * \n//     * @param level\n//     * @param msg\n//     * @param t\n//     */\n//    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n//        // millis and thread are filled by the constructor\n//        LogRecord record = new LogRecord(level, msg);\n//        record.setLoggerName(getName());\n//        record.setThrown(t);\n//        // Note: parameters in record are not set because SLF4J only\n//        // supports a single formatting style\n//        fillCallerData(callerFQCN, record);\n//        logger.log(record);\n//    }\n\n\t/**\n\t * Log the message at the specified level with the specified throwable if any.\n\t * This method creates a LogRecord and fills in caller date before calling this\n\t * instance's JDK14 logger.\n\t */\n\t@Override\n\tprotected void handleNormalizedLoggingCall(org.slf4j.event.Level level, Marker marker, String msg, Object[] args,\n\t\t\tThrowable throwable) {\n\t\tinnerNormalizedLoggingCallHandler(getFullyQualifiedCallerName(), level, marker, msg, args, throwable);\n\t}\n\n\t\n\tprivate void innerNormalizedLoggingCallHandler(String fqcn, org.slf4j.event.Level level, Marker marker, String msg, Object[] args,\n\t\t\tThrowable throwable) {\n\t\t// millis and thread are filled by the constructor\n\t\tLevel julLevel = slf4jLevelToJULLevel(level);\n\t\tString formattedMessage = MessageFormatter.basicArrayFormat(msg, args);\n\t\tLogRecord record = new LogRecord(julLevel, formattedMessage);\n\n\t\t// https://jira.qos.ch/browse/SLF4J-13\n\t\trecord.setLoggerName(getName());\n\t\trecord.setThrown(throwable);\n\t\t// Note: parameters in record are not set because SLF4J only\n\t\t// supports a single formatting style\n\t\t// See also https://jira.qos.ch/browse/SLF4J-10\n\t\tfillCallerData(fqcn, record);\n\t\tlogger.log(record);\n\t}\n\n\t\n\t@Override\n\tprotected String getFullyQualifiedCallerName() {\n\t\treturn SELF;\n\t}\n\t\n\t\n\t@Override\n\tpublic void log(Marker marker, String callerFQCN, int slf4jLevelInt, String message, Object[] arguments,\n\t\t\tThrowable throwable) {\n\n\t\torg.slf4j.event.Level slf4jLevel = org.slf4j.event.Level.intToLevel(slf4jLevelInt);\n\t\tLevel julLevel = slf4jLevelIntToJULLevel(slf4jLevelInt);\n\t\t\n\t\tif (logger.isLoggable(julLevel)) {\n\t\t\tNormalizedParameters np = ParameterNormalizer.normalize(message, arguments, throwable);\n\t\t\tinnerNormalizedLoggingCallHandler(callerFQCN, slf4jLevel, marker, np.getMessage(), np.getArguments(), np.getThrowable());\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Fill in caller data if possible.\n\t * \n\t * @param record The record to update\n\t */\n\tfinal private void fillCallerData(String callerFQCN, LogRecord record) {\n\t\tStackTraceElement[] steArray = new Throwable().getStackTrace();\n\n\t\tint selfIndex = -1;\n\t\tfor (int i = 0; i < steArray.length; i++) {\n\t\t\tfinal String className = steArray[i].getClassName();\n\n\t\t\tif (barrierMatch(callerFQCN, className)) {\n\t\t\t\tselfIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint found = -1;\n\t\tfor (int i = selfIndex + 1; i < steArray.length; i++) {\n\t\t\tfinal String className = steArray[i].getClassName();\n\t\t\tif (!(barrierMatch(callerFQCN, className))) {\n\t\t\t\tfound = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found != -1) {\n\t\t\tStackTraceElement ste = steArray[found];\n\t\t\t// setting the class name has the side effect of setting\n\t\t\t// the needToInferCaller variable to false.\n\t\t\trecord.setSourceClassName(ste.getClassName());\n\t\t\trecord.setSourceMethodName(ste.getMethodName());\n\t\t}\n\t}\n\n\tstatic String SELF = JDK14LoggerAdapter.class.getName();\n\t\n\tstatic String SUPER = LegacyAbstractLogger.class.getName();\n\tstatic String SUPER_OF_SUPER = AbstractLogger.class.getName();\n\tstatic String SUBSTITUE = SubstituteLogger.class.getName();\n\n\tstatic String BARRIER_CLASSES[] = new String[] { SUPER_OF_SUPER, SUPER, SELF, SUBSTITUE };\n\n\tprivate boolean barrierMatch(String callerFQCN, String candidateClassName) {\n\t\tif (candidateClassName.equals(callerFQCN))\n\t\t\treturn true;\n\t\tfor (String barrierClassName : BARRIER_CLASSES) {\n\t\t\tif (barrierClassName.equals(candidateClassName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tprivate static Level slf4jLevelIntToJULLevel(int levelInt) {\n\t\torg.slf4j.event.Level slf4jLevel = org.slf4j.event.Level.intToLevel(levelInt);\n\t\treturn slf4jLevelToJULLevel(slf4jLevel);\n\t}\n\n\tprivate static Level slf4jLevelToJULLevel(org.slf4j.event.Level slf4jLevel) {\n\t\tLevel julLevel;\n\t\tswitch (slf4jLevel) {\n\t\tcase TRACE:\n\t\t\tjulLevel = Level.FINEST;\n\t\t\tbreak;\n\t\tcase DEBUG:\n\t\t\tjulLevel = Level.FINE;\n\t\t\tbreak;\n\t\tcase INFO:\n\t\t\tjulLevel = Level.INFO;\n\t\t\tbreak;\n\t\tcase WARN:\n\t\t\tjulLevel = Level.WARNING;\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\t\tjulLevel = Level.SEVERE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Level \" + slf4jLevel + \" is not recognized.\");\n\t\t}\n\t\treturn julLevel;\n\t}\n\n\t/**\n\t * @since 1.7.15\n\t */\n\tpublic void log(LoggingEvent event) {\n\t\t// assumes that the invocation is made from a substitute logger\n\t\t// this assumption might change in the future with the advent of a fluent API\n\t\tLevel julLevel = slf4jLevelToJULLevel(event.getLevel());\n\t\tif (logger.isLoggable(julLevel)) {\n\t\t\tLogRecord record = eventToRecord(event, julLevel);\n\t\t\tlogger.log(record);\n\t\t}\n\t}\n\n\tprivate LogRecord eventToRecord(LoggingEvent event, Level julLevel) {\n\t\tString format = event.getMessage();\n\t\tObject[] arguments = event.getArgumentArray();\n\t\tFormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n\t\tif (ft.getThrowable() != null && event.getThrowable() != null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"both last element in argument array and last argument are of type Throwable\");\n\t\t}\n\n\t\tThrowable t = event.getThrowable();\n\t\tif (ft.getThrowable() != null) {\n\t\t\tt = ft.getThrowable();\n\t\t\tthrow new IllegalStateException(\"fix above code\");\n\t\t}\n\n\t\tLogRecord record = new LogRecord(julLevel, ft.getMessage());\n\t\trecord.setLoggerName(event.getLoggerName());\n\t\trecord.setMillis(event.getTimeStamp());\n\t\trecord.setSourceClassName(EventConstants.NA_SUBST);\n\t\trecord.setSourceMethodName(EventConstants.NA_SUBST);\n\n\t\trecord.setThrown(t);\n\t\treturn record;\n\t}\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.jul;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger {\n\n    private static final long serialVersionUID = -8053026990503422791L;\n\n    transient final java.util.logging.Logger logger;\n\n    // WARN: JDK14LoggerAdapter constructor should have only package access so\n    // that only JDK14LoggerFactory be able to create one.\n    JDK14LoggerAdapter(java.util.logging.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n    }\n\n    /**\n     * Is this logger instance enabled for the FINEST level?\n     * \n     * @return True if this Logger is enabled for level FINEST, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINEST);\n    }\n\n    /**\n     * Log a message object at level FINEST.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINEST.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void trace(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINEST with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the FINE level?\n     * \n     * @return True if this Logger is enabled for level FINE, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    /**\n     * Log a message object at level FINE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINE.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void debug(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the WARNING level?\n     * \n     * @return True if this Logger is enabled for the WARNING level, false\n     *         otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    /**\n     * Log a message object at the WARNING level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARNING according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARNING level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for level SEVERE?\n     * \n     * @return True if this Logger is enabled for level SEVERE, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n\n    /**\n     * Log a message object at the SEVERE level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level SEVERE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void error(String format, Object... arguments) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the SEVERE level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, t);\n        }\n    }\n\n    /**\n     * Log the message at the specified level with the specified throwable if any.\n     * This method creates a LogRecord and fills in caller date before calling\n     * this instance's JDK14 logger.\n     * \n     * See bug report #13 for more details.\n     * \n     * @param level\n     * @param msg\n     * @param t\n     */\n    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n        // millis and thread are filled by the constructor\n        LogRecord record = new LogRecord(level, msg);\n        record.setLoggerName(getName());\n        record.setThrown(t);\n        // Note: parameters in record are not set because SLF4J only\n        // supports a single formatting style\n        fillCallerData(callerFQCN, record);\n        logger.log(record);\n    }\n\n    static String SELF = JDK14LoggerAdapter.class.getName();\n    static String SUPER = MarkerIgnoringBase.class.getName();\n    static String SUBSTITUE = SubstituteLogger.class.getName();\n    \n    static String BARRIER_CLASSES[] = new String[] {SELF, SUPER, SUBSTITUE};\n  \n    /**\n     * Fill in caller data if possible.\n     * \n     * @param record\n     *          The record to update\n     */\n\tfinal private void fillCallerData(String callerFQCN, LogRecord record) {\n        StackTraceElement[] steArray = new Throwable().getStackTrace();\n\n        int selfIndex = -1;\n        for (int i = 0; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            \n            if (barrierMatch(callerFQCN, className)) {\n                selfIndex = i;\n                break;\n            }\n        }\n\n        int found = -1;\n        for (int i = selfIndex + 1; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            if (!(barrierMatch(callerFQCN, className))) {\n                found = i;\n                break;\n            }\n        }\n\n        if (found != -1) {\n            StackTraceElement ste = steArray[found];\n            // setting the class name has the side effect of setting\n            // the needToInferCaller variable to false.\n            record.setSourceClassName(ste.getClassName());\n            record.setSourceMethodName(ste.getMethodName());\n        }\n    }\n\n    private boolean barrierMatch(String callerFQCN, String candidateClassName) {\n    \tif(candidateClassName.equals(callerFQCN))\n    \t\treturn true;\n    \tfor(String barrierClassName: BARRIER_CLASSES) {\n    \t\tif(barrierClassName.equals(candidateClassName)) {\n    \t\t  return true;\n    \t\t}\n    \t}\n    \treturn false;\n\t}\n\n\tpublic void log(Marker marker, String callerFQCN, int level, String message, Object[] argArray, Throwable t) {\n        Level julLevel = slf4jLevelIntToJULLevel(level);\n        // the logger.isLoggable check avoids the unconditional\n        // construction of location data for disabled log\n        // statements. As of 2008-07-31, callers of this method\n        // do not perform this check. See also\n        // http://jira.qos.ch/browse/SLF4J-81\n        if (logger.isLoggable(julLevel)) {\n            log(callerFQCN, julLevel, message, t);\n        }\n    }\n\n    private Level slf4jLevelIntToJULLevel(int slf4jLevelInt) {\n        Level julLevel;\n        switch (slf4jLevelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            julLevel = Level.FINEST;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            julLevel = Level.FINE;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            julLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            julLevel = Level.WARNING;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            julLevel = Level.SEVERE;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + slf4jLevelInt + \" is not recognized.\");\n        }\n        return julLevel;\n    }\n\n    /**\n     * @since 1.7.15\n     */\n    public void log(LoggingEvent event) {\n    \t// assumes that the invocation is made from a substitute logger\n    \t// this assumption might change in the future with the advent of a fluent API\n        Level julLevel = slf4jLevelIntToJULLevel(event.getLevel().toInt());\n        if (logger.isLoggable(julLevel)) {\n            LogRecord record = eventToRecord(event, julLevel);\n            logger.log(record);\n        }\n    }\n\n    private LogRecord eventToRecord(LoggingEvent event, Level julLevel) {\n        String format = event.getMessage();\n        Object[] arguments = event.getArgumentArray();\n        FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n        if (ft.getThrowable() != null && event.getThrowable() != null) {\n            throw new IllegalArgumentException(\"both last element in argument array and last argument are of type Throwable\");\n        }\n\n        Throwable t = event.getThrowable();\n        if (ft.getThrowable() != null) {\n            t = ft.getThrowable();\n            throw new IllegalStateException(\"fix above code\");\n        }\n\n        LogRecord record = new LogRecord(julLevel, ft.getMessage());\n        record.setLoggerName(event.getLoggerName());\n        record.setMillis(event.getTimeStamp());\n        record.setSourceClassName(EventConstants.NA_SUBST);\n        record.setSourceMethodName(EventConstants.NA_SUBST);\n\n        record.setThrown(t);\n        return record;\n    }\n}\n","lineNo":148}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.jul;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.AbstractLogger;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.LegacyAbstractLogger;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.NormalizedParameters;\nimport org.slf4j.helpers.ParameterNormalizer;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends LegacyAbstractLogger implements LocationAwareLogger {\n\n\tprivate static final long serialVersionUID = -8053026990503422791L;\n\n\ttransient final java.util.logging.Logger logger;\n\n\t// WARN: JDK14LoggerAdapter constructor should have only package access so\n\t// that only JDK14LoggerFactory be able to create one.\n\tJDK14LoggerAdapter(java.util.logging.Logger logger) {\n\t\tthis.logger = logger;\n\t\tthis.name = logger.getName();\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the FINEST level?\n\t * \n\t * @return True if this Logger is enabled for level FINEST, false otherwise.\n\t */\n\tpublic boolean isTraceEnabled() {\n\t\treturn logger.isLoggable(Level.FINEST);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the FINE level?\n\t * \n\t * @return True if this Logger is enabled for level FINE, false otherwise.\n\t */\n\tpublic boolean isDebugEnabled() {\n\t\treturn logger.isLoggable(Level.FINE);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the INFO level?\n\t * \n\t * @return True if this Logger is enabled for the INFO level, false otherwise.\n\t */\n\tpublic boolean isInfoEnabled() {\n\t\treturn logger.isLoggable(Level.INFO);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the WARNING level?\n\t * \n\t * @return True if this Logger is enabled for the WARNING level, false\n\t *         otherwise.\n\t */\n\tpublic boolean isWarnEnabled() {\n\t\treturn logger.isLoggable(Level.WARNING);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for level SEVERE?\n\t * \n\t * @return True if this Logger is enabled for level SEVERE, false otherwise.\n\t */\n\tpublic boolean isErrorEnabled() {\n\t\treturn logger.isLoggable(Level.SEVERE);\n\t}\n\n//    /**\n//     * Log the message at the specified level with the specified throwable if any.\n//     * This method creates a LogRecord and fills in caller date before calling\n//     * this instance's JDK14 logger.\n//     * \n//     * See bug report #13 for more details.\n//     * \n//     * @param level\n//     * @param msg\n//     * @param t\n//     */\n//    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n//        // millis and thread are filled by the constructor\n//        LogRecord record = new LogRecord(level, msg);\n//        record.setLoggerName(getName());\n//        record.setThrown(t);\n//        // Note: parameters in record are not set because SLF4J only\n//        // supports a single formatting style\n//        fillCallerData(callerFQCN, record);\n//        logger.log(record);\n//    }\n\n\t/**\n\t * Log the message at the specified level with the specified throwable if any.\n\t * This method creates a LogRecord and fills in caller date before calling this\n\t * instance's JDK14 logger.\n\t */\n\t@Override\n\tprotected void handleNormalizedLoggingCall(org.slf4j.event.Level level, Marker marker, String msg, Object[] args,\n\t\t\tThrowable throwable) {\n\t\tinnerNormalizedLoggingCallHandler(getFullyQualifiedCallerName(), level, marker, msg, args, throwable);\n\t}\n\n\t\n\tprivate void innerNormalizedLoggingCallHandler(String fqcn, org.slf4j.event.Level level, Marker marker, String msg, Object[] args,\n\t\t\tThrowable throwable) {\n\t\t// millis and thread are filled by the constructor\n\t\tLevel julLevel = slf4jLevelToJULLevel(level);\n\t\tString formattedMessage = MessageFormatter.basicArrayFormat(msg, args);\n\t\tLogRecord record = new LogRecord(julLevel, formattedMessage);\n\n\t\t// https://jira.qos.ch/browse/SLF4J-13\n\t\trecord.setLoggerName(getName());\n\t\trecord.setThrown(throwable);\n\t\t// Note: parameters in record are not set because SLF4J only\n\t\t// supports a single formatting style\n\t\t// See also https://jira.qos.ch/browse/SLF4J-10\n\t\tfillCallerData(fqcn, record);\n\t\tlogger.log(record);\n\t}\n\n\t\n\t@Override\n\tprotected String getFullyQualifiedCallerName() {\n\t\treturn SELF;\n\t}\n\t\n\t\n\t@Override\n\tpublic void log(Marker marker, String callerFQCN, int slf4jLevelInt, String message, Object[] arguments,\n\t\t\tThrowable throwable) {\n\n\t\torg.slf4j.event.Level slf4jLevel = org.slf4j.event.Level.intToLevel(slf4jLevelInt);\n\t\tLevel julLevel = slf4jLevelIntToJULLevel(slf4jLevelInt);\n\t\t\n\t\tif (logger.isLoggable(julLevel)) {\n\t\t\tNormalizedParameters np = ParameterNormalizer.normalize(message, arguments, throwable);\n\t\t\tinnerNormalizedLoggingCallHandler(callerFQCN, slf4jLevel, marker, np.getMessage(), np.getArguments(), np.getThrowable());\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Fill in caller data if possible.\n\t * \n\t * @param record The record to update\n\t */\n\tfinal private void fillCallerData(String callerFQCN, LogRecord record) {\n\t\tStackTraceElement[] steArray = new Throwable().getStackTrace();\n\n\t\tint selfIndex = -1;\n\t\tfor (int i = 0; i < steArray.length; i++) {\n\t\t\tfinal String className = steArray[i].getClassName();\n\n\t\t\tif (barrierMatch(callerFQCN, className)) {\n\t\t\t\tselfIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint found = -1;\n\t\tfor (int i = selfIndex + 1; i < steArray.length; i++) {\n\t\t\tfinal String className = steArray[i].getClassName();\n\t\t\tif (!(barrierMatch(callerFQCN, className))) {\n\t\t\t\tfound = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found != -1) {\n\t\t\tStackTraceElement ste = steArray[found];\n\t\t\t// setting the class name has the side effect of setting\n\t\t\t// the needToInferCaller variable to false.\n\t\t\trecord.setSourceClassName(ste.getClassName());\n\t\t\trecord.setSourceMethodName(ste.getMethodName());\n\t\t}\n\t}\n\n\tstatic String SELF = JDK14LoggerAdapter.class.getName();\n\t\n\tstatic String SUPER = LegacyAbstractLogger.class.getName();\n\tstatic String SUPER_OF_SUPER = AbstractLogger.class.getName();\n\tstatic String SUBSTITUE = SubstituteLogger.class.getName();\n\n\tstatic String BARRIER_CLASSES[] = new String[] { SUPER_OF_SUPER, SUPER, SELF, SUBSTITUE };\n\n\tprivate boolean barrierMatch(String callerFQCN, String candidateClassName) {\n\t\tif (candidateClassName.equals(callerFQCN))\n\t\t\treturn true;\n\t\tfor (String barrierClassName : BARRIER_CLASSES) {\n\t\t\tif (barrierClassName.equals(candidateClassName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tprivate static Level slf4jLevelIntToJULLevel(int levelInt) {\n\t\torg.slf4j.event.Level slf4jLevel = org.slf4j.event.Level.intToLevel(levelInt);\n\t\treturn slf4jLevelToJULLevel(slf4jLevel);\n\t}\n\n\tprivate static Level slf4jLevelToJULLevel(org.slf4j.event.Level slf4jLevel) {\n\t\tLevel julLevel;\n\t\tswitch (slf4jLevel) {\n\t\tcase TRACE:\n\t\t\tjulLevel = Level.FINEST;\n\t\t\tbreak;\n\t\tcase DEBUG:\n\t\t\tjulLevel = Level.FINE;\n\t\t\tbreak;\n\t\tcase INFO:\n\t\t\tjulLevel = Level.INFO;\n\t\t\tbreak;\n\t\tcase WARN:\n\t\t\tjulLevel = Level.WARNING;\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\t\tjulLevel = Level.SEVERE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Level \" + slf4jLevel + \" is not recognized.\");\n\t\t}\n\t\treturn julLevel;\n\t}\n\n\t/**\n\t * @since 1.7.15\n\t */\n\tpublic void log(LoggingEvent event) {\n\t\t// assumes that the invocation is made from a substitute logger\n\t\t// this assumption might change in the future with the advent of a fluent API\n\t\tLevel julLevel = slf4jLevelToJULLevel(event.getLevel());\n\t\tif (logger.isLoggable(julLevel)) {\n\t\t\tLogRecord record = eventToRecord(event, julLevel);\n\t\t\tlogger.log(record);\n\t\t}\n\t}\n\n\tprivate LogRecord eventToRecord(LoggingEvent event, Level julLevel) {\n\t\tString format = event.getMessage();\n\t\tObject[] arguments = event.getArgumentArray();\n\t\tFormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n\t\tif (ft.getThrowable() != null && event.getThrowable() != null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"both last element in argument array and last argument are of type Throwable\");\n\t\t}\n\n\t\tThrowable t = event.getThrowable();\n\t\tif (ft.getThrowable() != null) {\n\t\t\tt = ft.getThrowable();\n\t\t\tthrow new IllegalStateException(\"fix above code\");\n\t\t}\n\n\t\tLogRecord record = new LogRecord(julLevel, ft.getMessage());\n\t\trecord.setLoggerName(event.getLoggerName());\n\t\trecord.setMillis(event.getTimeStamp());\n\t\trecord.setSourceClassName(EventConstants.NA_SUBST);\n\t\trecord.setSourceMethodName(EventConstants.NA_SUBST);\n\n\t\trecord.setThrown(t);\n\t\treturn record;\n\t}\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.jul;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger {\n\n    private static final long serialVersionUID = -8053026990503422791L;\n\n    transient final java.util.logging.Logger logger;\n\n    // WARN: JDK14LoggerAdapter constructor should have only package access so\n    // that only JDK14LoggerFactory be able to create one.\n    JDK14LoggerAdapter(java.util.logging.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n    }\n\n    /**\n     * Is this logger instance enabled for the FINEST level?\n     * \n     * @return True if this Logger is enabled for level FINEST, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINEST);\n    }\n\n    /**\n     * Log a message object at level FINEST.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINEST.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void trace(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINEST with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the FINE level?\n     * \n     * @return True if this Logger is enabled for level FINE, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    /**\n     * Log a message object at level FINE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINE.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void debug(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the WARNING level?\n     * \n     * @return True if this Logger is enabled for the WARNING level, false\n     *         otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    /**\n     * Log a message object at the WARNING level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARNING according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARNING level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for level SEVERE?\n     * \n     * @return True if this Logger is enabled for level SEVERE, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n\n    /**\n     * Log a message object at the SEVERE level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level SEVERE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void error(String format, Object... arguments) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the SEVERE level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, t);\n        }\n    }\n\n    /**\n     * Log the message at the specified level with the specified throwable if any.\n     * This method creates a LogRecord and fills in caller date before calling\n     * this instance's JDK14 logger.\n     * \n     * See bug report #13 for more details.\n     * \n     * @param level\n     * @param msg\n     * @param t\n     */\n    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n        // millis and thread are filled by the constructor\n        LogRecord record = new LogRecord(level, msg);\n        record.setLoggerName(getName());\n        record.setThrown(t);\n        // Note: parameters in record are not set because SLF4J only\n        // supports a single formatting style\n        fillCallerData(callerFQCN, record);\n        logger.log(record);\n    }\n\n    static String SELF = JDK14LoggerAdapter.class.getName();\n    static String SUPER = MarkerIgnoringBase.class.getName();\n    static String SUBSTITUE = SubstituteLogger.class.getName();\n    \n    static String BARRIER_CLASSES[] = new String[] {SELF, SUPER, SUBSTITUE};\n  \n    /**\n     * Fill in caller data if possible.\n     * \n     * @param record\n     *          The record to update\n     */\n\tfinal private void fillCallerData(String callerFQCN, LogRecord record) {\n        StackTraceElement[] steArray = new Throwable().getStackTrace();\n\n        int selfIndex = -1;\n        for (int i = 0; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            \n            if (barrierMatch(callerFQCN, className)) {\n                selfIndex = i;\n                break;\n            }\n        }\n\n        int found = -1;\n        for (int i = selfIndex + 1; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            if (!(barrierMatch(callerFQCN, className))) {\n                found = i;\n                break;\n            }\n        }\n\n        if (found != -1) {\n            StackTraceElement ste = steArray[found];\n            // setting the class name has the side effect of setting\n            // the needToInferCaller variable to false.\n            record.setSourceClassName(ste.getClassName());\n            record.setSourceMethodName(ste.getMethodName());\n        }\n    }\n\n    private boolean barrierMatch(String callerFQCN, String candidateClassName) {\n    \tif(candidateClassName.equals(callerFQCN))\n    \t\treturn true;\n    \tfor(String barrierClassName: BARRIER_CLASSES) {\n    \t\tif(barrierClassName.equals(candidateClassName)) {\n    \t\t  return true;\n    \t\t}\n    \t}\n    \treturn false;\n\t}\n\n\tpublic void log(Marker marker, String callerFQCN, int level, String message, Object[] argArray, Throwable t) {\n        Level julLevel = slf4jLevelIntToJULLevel(level);\n        // the logger.isLoggable check avoids the unconditional\n        // construction of location data for disabled log\n        // statements. As of 2008-07-31, callers of this method\n        // do not perform this check. See also\n        // http://jira.qos.ch/browse/SLF4J-81\n        if (logger.isLoggable(julLevel)) {\n            log(callerFQCN, julLevel, message, t);\n        }\n    }\n\n    private Level slf4jLevelIntToJULLevel(int slf4jLevelInt) {\n        Level julLevel;\n        switch (slf4jLevelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            julLevel = Level.FINEST;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            julLevel = Level.FINE;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            julLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            julLevel = Level.WARNING;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            julLevel = Level.SEVERE;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + slf4jLevelInt + \" is not recognized.\");\n        }\n        return julLevel;\n    }\n\n    /**\n     * @since 1.7.15\n     */\n    public void log(LoggingEvent event) {\n    \t// assumes that the invocation is made from a substitute logger\n    \t// this assumption might change in the future with the advent of a fluent API\n        Level julLevel = slf4jLevelIntToJULLevel(event.getLevel().toInt());\n        if (logger.isLoggable(julLevel)) {\n            LogRecord record = eventToRecord(event, julLevel);\n            logger.log(record);\n        }\n    }\n\n    private LogRecord eventToRecord(LoggingEvent event, Level julLevel) {\n        String format = event.getMessage();\n        Object[] arguments = event.getArgumentArray();\n        FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n        if (ft.getThrowable() != null && event.getThrowable() != null) {\n            throw new IllegalArgumentException(\"both last element in argument array and last argument are of type Throwable\");\n        }\n\n        Throwable t = event.getThrowable();\n        if (ft.getThrowable() != null) {\n            t = ft.getThrowable();\n            throw new IllegalStateException(\"fix above code\");\n        }\n\n        LogRecord record = new LogRecord(julLevel, ft.getMessage());\n        record.setLoggerName(event.getLoggerName());\n        record.setMillis(event.getTimeStamp());\n        record.setSourceClassName(EventConstants.NA_SUBST);\n        record.setSourceMethodName(EventConstants.NA_SUBST);\n\n        record.setThrown(t);\n        return record;\n    }\n}\n","lineNo":149}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.log4j12;\n\nimport static org.slf4j.event.EventConstants.NA_SUBST;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Level;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.ThrowableInformation;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.LegacyAbstractLogger;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.NormalizedParameters;\nimport org.slf4j.helpers.ParameterNormalizer;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends LegacyAbstractLogger implements LocationAwareLogger, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n\n    @Override\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] arguments, Throwable t) {\n        Level log4jLevel = toLog4jLevel(level);\n        NormalizedParameters np = ParameterNormalizer.normalize(msg, arguments, t);\n        String formattedMessage = MessageFormatter.basicArrayFormat(np.getMessage(), np.getArguments());\n        logger.log(callerFQCN, log4jLevel, formattedMessage, np.getThrowable());\n    }\n\n\t@Override\n\tprotected void handleNormalizedLoggingCall(org.slf4j.event.Level level, Marker marker, String msg, Object[] arguments,\n\t\t\tThrowable throwable) {\n\t\tLevel log4jLevel = toLog4jLevel(level.toInt());\n\t\tString formattedMessage = MessageFormatter.basicArrayFormat(msg, arguments);\n\t\tlogger.log(getFullyQualifiedCallerName(), log4jLevel, formattedMessage, throwable);\n\t}\n\n\t/**\n\t * Called by {@link SubstituteLogger}\n\t * @param event\n\t */\n    public void log(LoggingEvent event) {\n        Level log4jLevel = toLog4jLevel(event.getLevel().toInt());\n        if (!logger.isEnabledFor(log4jLevel))\n            return;\n\n        org.apache.log4j.spi.LoggingEvent log4jevent = toLog4jEvent(event, log4jLevel);\n        logger.callAppenders(log4jevent);\n\n    }\n    \n    private org.apache.log4j.spi.LoggingEvent toLog4jEvent(LoggingEvent event, Level log4jLevel) {\n\n        String formattedMessage = MessageFormatter.basicArrayFormat(event.getMessage(), event.getArgumentArray());\n\n        LocationInfo locationInfo = new LocationInfo(NA_SUBST, NA_SUBST, NA_SUBST, \"0\");\n\n        ThrowableInformation ti = null;\n        Throwable t = event.getThrowable();\n        if (t != null)\n            ti = new ThrowableInformation(t);\n\n        org.apache.log4j.spi.LoggingEvent log4jEvent = new org.apache.log4j.spi.LoggingEvent(FQCN, logger, event.getTimeStamp(), log4jLevel, formattedMessage,\n                        event.getThreadName(), ti, null, locationInfo, null);\n\n        return log4jEvent;\n    }\n\n\n\t\n    private Level toLog4jLevel(int slf4jLevelInt) {\n        Level log4jLevel;\n        switch (slf4jLevelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + slf4jLevelInt + \" is not recognized.\");\n        }\n        return log4jLevel;\n    }\n\n\t@Override\n\tprotected String getFullyQualifiedCallerName() {\n\t\treturn FQCN;\n\t}\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.log4j12;\n\nimport static org.slf4j.event.EventConstants.NA_SUBST;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Level;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.ThrowableInformation;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Log a message object at level TRACE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level TRACE.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void trace(String format, Object... arguments) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level TRACE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    /**\n     * Log a message object at level DEBUG.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level DEBUG.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments an array of arguments\n     */\n    public void debug(String format, Object... arguments) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level DEBUG with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        logger.log(FQCN, Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        logger.log(FQCN, Level.INFO, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    /**\n     * Log a message object at the WARN level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARN according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARN level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        logger.log(FQCN, Level.WARN, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    /**\n     * Log a message object at the ERROR level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level ERROR according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void error(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the ERROR level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        logger.log(FQCN, Level.ERROR, msg, t);\n    }\n\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] argArray, Throwable t) {\n        Level log4jLevel = toLog4jLevel(level);\n        logger.log(callerFQCN, log4jLevel, msg, t);\n    }\n\n    private Level toLog4jLevel(int level) {\n        Level log4jLevel;\n        switch (level) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + level + \" is not recognized.\");\n        }\n        return log4jLevel;\n    }\n\n    public void log(LoggingEvent event) {\n        Level log4jLevel = toLog4jLevel(event.getLevel().toInt());\n        if (!logger.isEnabledFor(log4jLevel))\n            return;\n\n        org.apache.log4j.spi.LoggingEvent log4jevent = toLog4jEvent(event, log4jLevel);\n        logger.callAppenders(log4jevent);\n\n    }\n\n    private org.apache.log4j.spi.LoggingEvent toLog4jEvent(LoggingEvent event, Level log4jLevel) {\n\n        FormattingTuple ft = MessageFormatter.format(event.getMessage(), event.getArgumentArray(), event.getThrowable());\n\n        LocationInfo locationInfo = new LocationInfo(NA_SUBST, NA_SUBST, NA_SUBST, \"0\");\n\n        ThrowableInformation ti = null;\n        Throwable t = ft.getThrowable();\n        if (t != null)\n            ti = new ThrowableInformation(t);\n\n        org.apache.log4j.spi.LoggingEvent log4jEvent = new org.apache.log4j.spi.LoggingEvent(FQCN, logger, event.getTimeStamp(), log4jLevel, ft.getMessage(),\n                        event.getThreadName(), ti, null, locationInfo, null);\n\n        return log4jEvent;\n    }\n\n}\n","lineNo":151}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.log4j12;\n\nimport static org.slf4j.event.EventConstants.NA_SUBST;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Level;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.ThrowableInformation;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.LegacyAbstractLogger;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.NormalizedParameters;\nimport org.slf4j.helpers.ParameterNormalizer;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends LegacyAbstractLogger implements LocationAwareLogger, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n\n    @Override\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] arguments, Throwable t) {\n        Level log4jLevel = toLog4jLevel(level);\n        NormalizedParameters np = ParameterNormalizer.normalize(msg, arguments, t);\n        String formattedMessage = MessageFormatter.basicArrayFormat(np.getMessage(), np.getArguments());\n        logger.log(callerFQCN, log4jLevel, formattedMessage, np.getThrowable());\n    }\n\n\t@Override\n\tprotected void handleNormalizedLoggingCall(org.slf4j.event.Level level, Marker marker, String msg, Object[] arguments,\n\t\t\tThrowable throwable) {\n\t\tLevel log4jLevel = toLog4jLevel(level.toInt());\n\t\tString formattedMessage = MessageFormatter.basicArrayFormat(msg, arguments);\n\t\tlogger.log(getFullyQualifiedCallerName(), log4jLevel, formattedMessage, throwable);\n\t}\n\n\t/**\n\t * Called by {@link SubstituteLogger}\n\t * @param event\n\t */\n    public void log(LoggingEvent event) {\n        Level log4jLevel = toLog4jLevel(event.getLevel().toInt());\n        if (!logger.isEnabledFor(log4jLevel))\n            return;\n\n        org.apache.log4j.spi.LoggingEvent log4jevent = toLog4jEvent(event, log4jLevel);\n        logger.callAppenders(log4jevent);\n\n    }\n    \n    private org.apache.log4j.spi.LoggingEvent toLog4jEvent(LoggingEvent event, Level log4jLevel) {\n\n        String formattedMessage = MessageFormatter.basicArrayFormat(event.getMessage(), event.getArgumentArray());\n\n        LocationInfo locationInfo = new LocationInfo(NA_SUBST, NA_SUBST, NA_SUBST, \"0\");\n\n        ThrowableInformation ti = null;\n        Throwable t = event.getThrowable();\n        if (t != null)\n            ti = new ThrowableInformation(t);\n\n        org.apache.log4j.spi.LoggingEvent log4jEvent = new org.apache.log4j.spi.LoggingEvent(FQCN, logger, event.getTimeStamp(), log4jLevel, formattedMessage,\n                        event.getThreadName(), ti, null, locationInfo, null);\n\n        return log4jEvent;\n    }\n\n\n\t\n    private Level toLog4jLevel(int slf4jLevelInt) {\n        Level log4jLevel;\n        switch (slf4jLevelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + slf4jLevelInt + \" is not recognized.\");\n        }\n        return log4jLevel;\n    }\n\n\t@Override\n\tprotected String getFullyQualifiedCallerName() {\n\t\treturn FQCN;\n\t}\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.log4j12;\n\nimport static org.slf4j.event.EventConstants.NA_SUBST;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Level;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.ThrowableInformation;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Log a message object at level TRACE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level TRACE.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void trace(String format, Object... arguments) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level TRACE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    /**\n     * Log a message object at level DEBUG.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level DEBUG.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments an array of arguments\n     */\n    public void debug(String format, Object... arguments) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level DEBUG with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        logger.log(FQCN, Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        logger.log(FQCN, Level.INFO, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    /**\n     * Log a message object at the WARN level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARN according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARN level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        logger.log(FQCN, Level.WARN, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    /**\n     * Log a message object at the ERROR level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level ERROR according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void error(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the ERROR level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        logger.log(FQCN, Level.ERROR, msg, t);\n    }\n\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] argArray, Throwable t) {\n        Level log4jLevel = toLog4jLevel(level);\n        logger.log(callerFQCN, log4jLevel, msg, t);\n    }\n\n    private Level toLog4jLevel(int level) {\n        Level log4jLevel;\n        switch (level) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + level + \" is not recognized.\");\n        }\n        return log4jLevel;\n    }\n\n    public void log(LoggingEvent event) {\n        Level log4jLevel = toLog4jLevel(event.getLevel().toInt());\n        if (!logger.isEnabledFor(log4jLevel))\n            return;\n\n        org.apache.log4j.spi.LoggingEvent log4jevent = toLog4jEvent(event, log4jLevel);\n        logger.callAppenders(log4jevent);\n\n    }\n\n    private org.apache.log4j.spi.LoggingEvent toLog4jEvent(LoggingEvent event, Level log4jLevel) {\n\n        FormattingTuple ft = MessageFormatter.format(event.getMessage(), event.getArgumentArray(), event.getThrowable());\n\n        LocationInfo locationInfo = new LocationInfo(NA_SUBST, NA_SUBST, NA_SUBST, \"0\");\n\n        ThrowableInformation ti = null;\n        Throwable t = ft.getThrowable();\n        if (t != null)\n            ti = new ThrowableInformation(t);\n\n        org.apache.log4j.spi.LoggingEvent log4jEvent = new org.apache.log4j.spi.LoggingEvent(FQCN, logger, event.getTimeStamp(), log4jLevel, ft.getMessage(),\n                        event.getThreadName(), ti, null, locationInfo, null);\n\n        return log4jEvent;\n    }\n\n}\n","lineNo":152}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2012 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Properties;\n\nimport org.slf4j.Logger;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.Util;\nimport org.slf4j.impl.OutputChoice.OutputChoiceType;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * <p>Simple implementation of {@link Logger} that sends all enabled log messages,\n * for all defined loggers, to the console ({@code System.err}).\n * The following system properties are supported to configure the behavior of this logger:<\/p>\n *\n * <ul>\n * <li><code>org.slf4j.simpleLogger.logFile<\/code> - The output target which can be the <em>path<\/em> to a file, or\n * the special values \"System.out\" and \"System.err\". Default is \"System.err\".\n *\n * <li><code>org.slf4j.simpleLogger.defaultLogLevel<\/code> - Default log level for all instances of SimpleLogger.\n * Must be one of (\"trace\", \"debug\", \"info\", \"warn\", \"error\" or \"off\"). If not specified, defaults to \"info\". <\/li>\n *\n * <li><code>org.slf4j.simpleLogger.log.<em>a.b.c<\/em><\/code> - Logging detail level for a SimpleLogger instance\n * named \"a.b.c\". Right-side value must be one of \"trace\", \"debug\", \"info\", \"warn\", \"error\" or \"off\". When a SimpleLogger\n * named \"a.b.c\" is initialized, its level is assigned from this property. If unspecified, the level of nearest parent\n * logger will be used, and if none is set, then the value specified by\n * <code>org.slf4j.simpleLogger.defaultLogLevel<\/code> will be used.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.showDateTime<\/code> - Set to <code>true<\/code> if you want the current date and\n * time to be included in output messages. Default is <code>false<\/code><\/li>\n *\n * <li><code>org.slf4j.simpleLogger.dateTimeFormat<\/code> - The date and time format to be used in the output messages.\n * The pattern describing the date and time format is defined by\n * <a href=\"http://docs.oracle.com/javase/1.5.0/docs/api/java/text/SimpleDateFormat.html\"><code>SimpleDateFormat<\/code><\/a>.\n * If the format is not specified or is invalid, the number of milliseconds since start up will be output. <\/li>\n *\n * <li><code>org.slf4j.simpleLogger.showThreadName<\/code> -Set to <code>true<\/code> if you want to output the current\n * thread name. Defaults to <code>true<\/code>.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.showLogName<\/code> - Set to <code>true<\/code> if you want the Logger instance name\n * to be included in output messages. Defaults to <code>true<\/code>.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.showShortLogName<\/code> - Set to <code>true<\/code> if you want the last component\n * of the name to be included in output messages. Defaults to <code>false<\/code>.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.levelInBrackets<\/code> - Should the level string be output in brackets? Defaults\n * to <code>false<\/code>.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.warnLevelString<\/code> - The string value output for the warn level. Defaults\n * to <code>WARN<\/code>.<\/li>\n\n * <\/ul>\n *\n * <p>In addition to looking for system properties with the names specified above, this implementation also checks for\n * a class loader resource named <code>\"simplelogger.properties\"<\/code>, and includes any matching definitions\n * from this resource (if it exists).<\/p>\n *\n * <p>With no configuration, the default output includes the relative time in milliseconds, thread name, the level,\n * logger name, and the message followed by the line separator for the host.  In log4j terms it amounts to the \"%r [%t]\n * %level %logger - %m%n\" pattern. <\/p>\n * <p>Sample output follows.<\/p>\n * <pre>\n * 176 [main] INFO examples.Sort - Populating an array of 2 elements in reverse order.\n * 225 [main] INFO examples.SortAlgo - Entered the sort method.\n * 304 [main] INFO examples.SortAlgo - Dump of integer array:\n * 317 [main] INFO examples.SortAlgo - Element [0] = 0\n * 331 [main] INFO examples.SortAlgo - Element [1] = 1\n * 343 [main] INFO examples.Sort - The next log statement should be an error message.\n * 346 [main] ERROR examples.SortAlgo - Tried to dump an uninitialized array.\n *   at org.log4j.examples.SortAlgo.dump(SortAlgo.java:58)\n *   at org.log4j.examples.Sort.main(Sort.java:64)\n * 467 [main] INFO  examples.Sort - Exiting main method.\n * <\/pre>\n *\n * <p>This implementation is heavily inspired by\n * <a href=\"http://commons.apache.org/logging/\">Apache Commons Logging<\/a>'s SimpleLog.<\/p>\n *\n * @author Ceki G&uuml;lc&uuml;\n * @author <a href=\"mailto:sanders@apache.org\">Scott Sanders<\/a>\n * @author Rod Waldhoff\n * @author Robert Burrell Donkin\n * @author C&eacute;drik LIME\n */\npublic class SimpleLogger extends MarkerIgnoringBase {\n\n    private static final long serialVersionUID = -632788891211436180L;\n    private static final String CONFIGURATION_FILE = \"simplelogger.properties\";\n\n    private static long START_TIME = System.currentTimeMillis();\n    private static final Properties SIMPLE_LOGGER_PROPS = new Properties();\n\n    protected static final int LOG_LEVEL_TRACE = LocationAwareLogger.TRACE_INT;\n    protected static final int LOG_LEVEL_DEBUG = LocationAwareLogger.DEBUG_INT;\n    protected static final int LOG_LEVEL_INFO = LocationAwareLogger.INFO_INT;\n    protected static final int LOG_LEVEL_WARN = LocationAwareLogger.WARN_INT;\n    protected static final int LOG_LEVEL_ERROR = LocationAwareLogger.ERROR_INT;\n    // The OFF level can only be used in configuration files to disable logging. It has\n    // no printing method associated with it in o.s.Logger interface.\n    protected static final int LOG_LEVEL_OFF = LOG_LEVEL_ERROR + 10;\n\n    private static boolean INITIALIZED = false;\n\n    private static int DEFAULT_LOG_LEVEL = LOG_LEVEL_INFO;\n    private static boolean SHOW_DATE_TIME = false;\n    private static String DATE_TIME_FORMAT_STR = null;\n    private static DateFormat DATE_FORMATTER = null;\n    private static boolean SHOW_THREAD_NAME = true;\n    private static boolean SHOW_LOG_NAME = true;\n    private static boolean SHOW_SHORT_LOG_NAME = false;\n    private static String LOG_FILE = \"System.err\";\n    private static OutputChoice OUTPUT_CHOICE = null;\n    private static boolean LEVEL_IN_BRACKETS = false;\n    private static String WARN_LEVEL_STRING = \"WARN\";\n\n    /** All system properties used by <code>SimpleLogger<\/code> start with this prefix */\n    public static final String SYSTEM_PREFIX = \"org.slf4j.simpleLogger.\";\n\n    public static final String DEFAULT_LOG_LEVEL_KEY = SYSTEM_PREFIX + \"defaultLogLevel\";\n    public static final String SHOW_DATE_TIME_KEY = SYSTEM_PREFIX + \"showDateTime\";\n    public static final String DATE_TIME_FORMAT_KEY = SYSTEM_PREFIX + \"dateTimeFormat\";\n    public static final String SHOW_THREAD_NAME_KEY = SYSTEM_PREFIX + \"showThreadName\";\n    public static final String SHOW_LOG_NAME_KEY = SYSTEM_PREFIX + \"showLogName\";\n    public static final String SHOW_SHORT_LOG_NAME_KEY = SYSTEM_PREFIX + \"showShortLogName\";\n    public static final String LOG_FILE_KEY = SYSTEM_PREFIX + \"logFile\";\n    public static final String LEVEL_IN_BRACKETS_KEY = SYSTEM_PREFIX + \"levelInBrackets\";\n    public static final String WARN_LEVEL_STRING_KEY = SYSTEM_PREFIX + \"warnLevelString\";\n\n    public static final String LOG_KEY_PREFIX = SYSTEM_PREFIX + \"log.\";\n\n    private static String getStringProperty(String name) {\n        String prop = null;\n        try {\n            prop = System.getProperty(name);\n        } catch (SecurityException e) {\n            ; // Ignore\n        }\n        return (prop == null) ? SIMPLE_LOGGER_PROPS.getProperty(name) : prop;\n    }\n\n    private static String getStringProperty(String name, String defaultValue) {\n        String prop = getStringProperty(name);\n        return (prop == null) ? defaultValue : prop;\n    }\n\n    private static boolean getBooleanProperty(String name, boolean defaultValue) {\n        String prop = getStringProperty(name);\n        return (prop == null) ? defaultValue : \"true\".equalsIgnoreCase(prop);\n    }\n\n    static void lazyInit() {\n        if (INITIALIZED) {\n            return;\n        }\n        INITIALIZED = true;\n        init();\n    }\n    \n    static void init() {\n        loadProperties();\n\n        String defaultLogLevelString = getStringProperty(DEFAULT_LOG_LEVEL_KEY, null);\n        if (defaultLogLevelString != null)\n            DEFAULT_LOG_LEVEL = stringToLevel(defaultLogLevelString);\n\n        SHOW_LOG_NAME = getBooleanProperty(SHOW_LOG_NAME_KEY, SHOW_LOG_NAME);\n        SHOW_SHORT_LOG_NAME = getBooleanProperty(SHOW_SHORT_LOG_NAME_KEY, SHOW_SHORT_LOG_NAME);\n        SHOW_DATE_TIME = getBooleanProperty(SHOW_DATE_TIME_KEY, SHOW_DATE_TIME);\n        SHOW_THREAD_NAME = getBooleanProperty(SHOW_THREAD_NAME_KEY, SHOW_THREAD_NAME);\n        DATE_TIME_FORMAT_STR = getStringProperty(DATE_TIME_FORMAT_KEY, DATE_TIME_FORMAT_STR);\n        LEVEL_IN_BRACKETS = getBooleanProperty(LEVEL_IN_BRACKETS_KEY, LEVEL_IN_BRACKETS);\n        WARN_LEVEL_STRING = getStringProperty(WARN_LEVEL_STRING_KEY, WARN_LEVEL_STRING);\n\n        LOG_FILE = getStringProperty(LOG_FILE_KEY, LOG_FILE);\n        OUTPUT_CHOICE = computeOutputChoice(LOG_FILE);\n\n        if (DATE_TIME_FORMAT_STR != null) {\n            try {\n                DATE_FORMATTER = new SimpleDateFormat(DATE_TIME_FORMAT_STR);\n            } catch (IllegalArgumentException e) {\n                Util.report(\"Bad date format in \" + CONFIGURATION_FILE + \"; will output relative time\", e);\n            }\n        }\n    }\n\n    enum Target {\n    \tSysOut, SysErr;\n    }\n    \n    private static OutputChoice computeOutputChoice(String logFile) {\n        if (\"System.err\".equalsIgnoreCase(logFile))\n            return new OutputChoice(OutputChoiceType.SYS_ERR);\n        else if (\"System.out\".equalsIgnoreCase(logFile)) {\n            return  new OutputChoice(OutputChoiceType.SYS_OUT);\n        } else {\n            try {\n                FileOutputStream fos = new FileOutputStream(logFile);\n                PrintStream printStream = new PrintStream(fos);\n                return new OutputChoice(printStream);\n            } catch (FileNotFoundException e) {\n                Util.report(\"Could not open [\" + logFile + \"]. Defaulting to System.err\", e);\n                return new OutputChoice(OutputChoiceType.SYS_ERR);\n            }\n        }\n    }\n\n    private static void loadProperties() {\n        // Add props from the resource simplelogger.properties\n        InputStream in = AccessController.doPrivileged(new PrivilegedAction<InputStream>() {\n            public InputStream run() {\n                ClassLoader threadCL = Thread.currentThread().getContextClassLoader();\n                if (threadCL != null) {\n                    return threadCL.getResourceAsStream(CONFIGURATION_FILE);\n                } else {\n                    return ClassLoader.getSystemResourceAsStream(CONFIGURATION_FILE);\n                }\n            }\n        });\n        if (null != in) {\n            try {\n                SIMPLE_LOGGER_PROPS.load(in);\n            } catch (java.io.IOException e) {\n                // ignored\n            } finally {\n                try {\n                    in.close();\n                } catch (java.io.IOException e) {\n                    // ignored\n                }\n            }\n        }\n    }\n\n    /** The current log level */\n    protected int currentLogLevel = LOG_LEVEL_INFO;\n    /** The short name of this simple log instance */\n    private transient String shortLogName = null;\n\n    /**\n     * Package access allows only {@link SimpleLoggerFactory} to instantiate\n     * SimpleLogger instances.\n     */\n    SimpleLogger(String name) {\n        this.name = name;\n\n        String levelString = recursivelyComputeLevelString();\n        if (levelString != null) {\n            this.currentLogLevel = stringToLevel(levelString);\n        } else {\n            this.currentLogLevel = DEFAULT_LOG_LEVEL;\n        }\n    }\n\n    String recursivelyComputeLevelString() {\n        String tempName = name;\n        String levelString = null;\n        int indexOfLastDot = tempName.length();\n        while ((levelString == null) && (indexOfLastDot > -1)) {\n            tempName = tempName.substring(0, indexOfLastDot);\n            levelString = getStringProperty(LOG_KEY_PREFIX + tempName, null);\n            indexOfLastDot = String.valueOf(tempName).lastIndexOf(\".\");\n        }\n        return levelString;\n    }\n\n    private static int stringToLevel(String levelStr) {\n        if (\"trace\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_TRACE;\n        } else if (\"debug\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_DEBUG;\n        } else if (\"info\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_INFO;\n        } else if (\"warn\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_WARN;\n        } else if (\"error\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_ERROR;\n        } else if (\"off\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_OFF;\n        }\n        // assume INFO by default\n        return LOG_LEVEL_INFO;\n    }\n\n    /**\n     * This is our internal implementation for logging regular (non-parameterized)\n     * log messages.\n     *\n     * @param level   One of the LOG_LEVEL_XXX constants defining the log level\n     * @param message The message itself\n     * @param t       The exception whose stack trace should be logged\n     */\n    private void log(int level, String message, Throwable t) {\n        if (!isLevelEnabled(level)) {\n            return;\n        }\n\n        StringBuilder buf = new StringBuilder(32);\n\n        // Append date-time if so configured\n        if (SHOW_DATE_TIME) {\n            if (DATE_FORMATTER != null) {\n                buf.append(getFormattedDate());\n                buf.append(' ');\n            } else {\n                buf.append(System.currentTimeMillis() - START_TIME);\n                buf.append(' ');\n            }\n        }\n\n        // Append current thread name if so configured\n        if (SHOW_THREAD_NAME) {\n            buf.append('[');\n            buf.append(Thread.currentThread().getName());\n            buf.append(\"] \");\n        }\n\n        if (LEVEL_IN_BRACKETS)\n            buf.append('[');\n\n        // Append a readable representation of the log level\n        String levelStr = renderLevel(level);\n        buf.append(levelStr);\n        if (LEVEL_IN_BRACKETS)\n            buf.append(']');\n        buf.append(' ');\n\n        // Append the name of the log instance if so configured\n        if (SHOW_SHORT_LOG_NAME) {\n            if (shortLogName == null)\n                shortLogName = computeShortName();\n            buf.append(String.valueOf(shortLogName)).append(\" - \");\n        } else if (SHOW_LOG_NAME) {\n            buf.append(String.valueOf(name)).append(\" - \");\n        }\n\n        // Append the message\n        buf.append(message);\n\n        write(buf, t);\n\n    }\n\n\tprotected String renderLevel(int level) {\n\t\tswitch (level) {\n        case LOG_LEVEL_TRACE:\n            return \"TRACE\";\n        case LOG_LEVEL_DEBUG:\n        \treturn(\"DEBUG\");\n        case LOG_LEVEL_INFO:\n        \treturn \"INFO\";\n        case LOG_LEVEL_WARN:\n        \treturn WARN_LEVEL_STRING;\n        case LOG_LEVEL_ERROR:\n        \treturn \"ERROR\";\n        }\n        throw new IllegalStateException(\"Unrecognized level [\"+level+\"]\");\n\t}\n\n    void write(StringBuilder buf, Throwable t) {\n    \tPrintStream targetStream = OUTPUT_CHOICE.getTargetPrintStream();\n    \t\n    \ttargetStream.println(buf.toString());\n        writeThrowable(t, targetStream);\n        targetStream.flush();\n    }\n\n    protected void writeThrowable(Throwable t, PrintStream targetStream) {\n\t\tif (t != null) {\n            t.printStackTrace(targetStream);\n        }\n\t}\n\t\n\tprivate String getFormattedDate() {\n        Date now = new Date();\n        String dateText;\n        synchronized (DATE_FORMATTER) {\n            dateText = DATE_FORMATTER.format(now);\n        }\n        return dateText;\n    }\n\n    private String computeShortName() {\n        return name.substring(name.lastIndexOf(\".\") + 1);\n    }\n\n    /**\n     * For formatted messages, first substitute arguments and then log.\n     *\n     * @param level\n     * @param format\n     * @param arg1\n     * @param arg2\n     */\n    private void formatAndLog(int level, String format, Object arg1, Object arg2) {\n        if (!isLevelEnabled(level)) {\n            return;\n        }\n        FormattingTuple tp = MessageFormatter.format(format, arg1, arg2);\n        log(level, tp.getMessage(), tp.getThrowable());\n    }\n\n    /**\n     * For formatted messages, first substitute arguments and then log.\n     *\n     * @param level\n     * @param format\n     * @param arguments a list of 3 ore more arguments\n     */\n    private void formatAndLog(int level, String format, Object... arguments) {\n        if (!isLevelEnabled(level)) {\n            return;\n        }\n        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n        log(level, tp.getMessage(), tp.getThrowable());\n    }\n\n    /**\n     * Is the given log level currently enabled?\n     *\n     * @param logLevel is this level enabled?\n     */\n    protected boolean isLevelEnabled(int logLevel) {\n        // log level are numerically ordered so can use simple numeric\n        // comparison\n        return (logLevel >= currentLogLevel);\n    }\n\n    /** Are {@code trace} messages currently enabled? */\n    public boolean isTraceEnabled() {\n        return isLevelEnabled(LOG_LEVEL_TRACE);\n    }\n\n    /**\n     * A simple implementation which logs messages of level TRACE according\n     * to the format outlined above.\n     */\n    public void trace(String msg) {\n        log(LOG_LEVEL_TRACE, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * TRACE according to the format outlined above.\n     */\n    public void trace(String format, Object param1) {\n        formatAndLog(LOG_LEVEL_TRACE, format, param1, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * TRACE according to the format outlined above.\n     */\n    public void trace(String format, Object param1, Object param2) {\n        formatAndLog(LOG_LEVEL_TRACE, format, param1, param2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * TRACE according to the format outlined above.\n     */\n    public void trace(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_TRACE, format, argArray);\n    }\n\n    /** Log a message of level TRACE, including an exception. */\n    public void trace(String msg, Throwable t) {\n        log(LOG_LEVEL_TRACE, msg, t);\n    }\n\n    /** Are {@code debug} messages currently enabled? */\n    public boolean isDebugEnabled() {\n        return isLevelEnabled(LOG_LEVEL_DEBUG);\n    }\n\n    /**\n     * A simple implementation which logs messages of level DEBUG according\n     * to the format outlined above.\n     */\n    public void debug(String msg) {\n        log(LOG_LEVEL_DEBUG, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * DEBUG according to the format outlined above.\n     */\n    public void debug(String format, Object param1) {\n        formatAndLog(LOG_LEVEL_DEBUG, format, param1, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * DEBUG according to the format outlined above.\n     */\n    public void debug(String format, Object param1, Object param2) {\n        formatAndLog(LOG_LEVEL_DEBUG, format, param1, param2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * DEBUG according to the format outlined above.\n     */\n    public void debug(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_DEBUG, format, argArray);\n    }\n\n    /** Log a message of level DEBUG, including an exception. */\n    public void debug(String msg, Throwable t) {\n        log(LOG_LEVEL_DEBUG, msg, t);\n    }\n\n    /** Are {@code info} messages currently enabled? */\n    public boolean isInfoEnabled() {\n        return isLevelEnabled(LOG_LEVEL_INFO);\n    }\n\n    /**\n     * A simple implementation which logs messages of level INFO according\n     * to the format outlined above.\n     */\n    public void info(String msg) {\n        log(LOG_LEVEL_INFO, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * INFO according to the format outlined above.\n     */\n    public void info(String format, Object arg) {\n        formatAndLog(LOG_LEVEL_INFO, format, arg, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * INFO according to the format outlined above.\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        formatAndLog(LOG_LEVEL_INFO, format, arg1, arg2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * INFO according to the format outlined above.\n     */\n    public void info(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_INFO, format, argArray);\n    }\n\n    /** Log a message of level INFO, including an exception. */\n    public void info(String msg, Throwable t) {\n        log(LOG_LEVEL_INFO, msg, t);\n    }\n\n    /** Are {@code warn} messages currently enabled? */\n    public boolean isWarnEnabled() {\n        return isLevelEnabled(LOG_LEVEL_WARN);\n    }\n\n    /**\n     * A simple implementation which always logs messages of level WARN according\n     * to the format outlined above.\n     */\n    public void warn(String msg) {\n        log(LOG_LEVEL_WARN, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * WARN according to the format outlined above.\n     */\n    public void warn(String format, Object arg) {\n        formatAndLog(LOG_LEVEL_WARN, format, arg, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * WARN according to the format outlined above.\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        formatAndLog(LOG_LEVEL_WARN, format, arg1, arg2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * WARN according to the format outlined above.\n     */\n    public void warn(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_WARN, format, argArray);\n    }\n\n    /** Log a message of level WARN, including an exception. */\n    public void warn(String msg, Throwable t) {\n        log(LOG_LEVEL_WARN, msg, t);\n    }\n\n    /** Are {@code error} messages currently enabled? */\n    public boolean isErrorEnabled() {\n        return isLevelEnabled(LOG_LEVEL_ERROR);\n    }\n\n    /**\n     * A simple implementation which always logs messages of level ERROR according\n     * to the format outlined above.\n     */\n    public void error(String msg) {\n        log(LOG_LEVEL_ERROR, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * ERROR according to the format outlined above.\n     */\n    public void error(String format, Object arg) {\n        formatAndLog(LOG_LEVEL_ERROR, format, arg, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * ERROR according to the format outlined above.\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        formatAndLog(LOG_LEVEL_ERROR, format, arg1, arg2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * ERROR according to the format outlined above.\n     */\n    public void error(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_ERROR, format, argArray);\n    }\n\n    /** Log a message of level ERROR, including an exception. */\n    public void error(String msg, Throwable t) {\n        log(LOG_LEVEL_ERROR, msg, t);\n    }\n\n    public void log(LoggingEvent event) {\n        int levelInt = event.getLevel().toInt();\n\n        if (!isLevelEnabled(levelInt)) {\n            return;\n        }\n        FormattingTuple tp = MessageFormatter.arrayFormat(event.getMessage(), event.getArgumentArray(), event.getThrowable());\n        log(levelInt, tp.getMessage(), event.getThrowable());\n    }\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2012 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Properties;\n\nimport org.slf4j.Logger;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.Util;\nimport org.slf4j.impl.OutputChoice.OutputChoiceType;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * <p>Simple implementation of {@link Logger} that sends all enabled log messages,\n * for all defined loggers, to the console ({@code System.err}).\n * The following system properties are supported to configure the behavior of this logger:<\/p>\n *\n * <ul>\n * <li><code>org.slf4j.simpleLogger.logFile<\/code> - The output target which can be the <em>path<\/em> to a file, or\n * the special values \"System.out\" and \"System.err\". Default is \"System.err\".\n *\n * <li><code>org.slf4j.simpleLogger.defaultLogLevel<\/code> - Default log level for all instances of SimpleLogger.\n * Must be one of (\"trace\", \"debug\", \"info\", \"warn\", \"error\" or \"off\"). If not specified, defaults to \"info\". <\/li>\n *\n * <li><code>org.slf4j.simpleLogger.log.<em>a.b.c<\/em><\/code> - Logging detail level for a SimpleLogger instance\n * named \"a.b.c\". Right-side value must be one of \"trace\", \"debug\", \"info\", \"warn\", \"error\" or \"off\". When a SimpleLogger\n * named \"a.b.c\" is initialized, its level is assigned from this property. If unspecified, the level of nearest parent\n * logger will be used, and if none is set, then the value specified by\n * <code>org.slf4j.simpleLogger.defaultLogLevel<\/code> will be used.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.showDateTime<\/code> - Set to <code>true<\/code> if you want the current date and\n * time to be included in output messages. Default is <code>false<\/code><\/li>\n *\n * <li><code>org.slf4j.simpleLogger.dateTimeFormat<\/code> - The date and time format to be used in the output messages.\n * The pattern describing the date and time format is defined by\n * <a href=\"http://docs.oracle.com/javase/1.5.0/docs/api/java/text/SimpleDateFormat.html\"><code>SimpleDateFormat<\/code><\/a>.\n * If the format is not specified or is invalid, the number of milliseconds since start up will be output. <\/li>\n *\n * <li><code>org.slf4j.simpleLogger.showThreadName<\/code> -Set to <code>true<\/code> if you want to output the current\n * thread name. Defaults to <code>true<\/code>.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.showLogName<\/code> - Set to <code>true<\/code> if you want the Logger instance name\n * to be included in output messages. Defaults to <code>true<\/code>.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.showShortLogName<\/code> - Set to <code>true<\/code> if you want the last component\n * of the name to be included in output messages. Defaults to <code>false<\/code>.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.levelInBrackets<\/code> - Should the level string be output in brackets? Defaults\n * to <code>false<\/code>.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.warnLevelString<\/code> - The string value output for the warn level. Defaults\n * to <code>WARN<\/code>.<\/li>\n\n * <\/ul>\n *\n * <p>In addition to looking for system properties with the names specified above, this implementation also checks for\n * a class loader resource named <code>\"simplelogger.properties\"<\/code>, and includes any matching definitions\n * from this resource (if it exists).<\/p>\n *\n * <p>With no configuration, the default output includes the relative time in milliseconds, thread name, the level,\n * logger name, and the message followed by the line separator for the host.  In log4j terms it amounts to the \"%r [%t]\n * %level %logger - %m%n\" pattern. <\/p>\n * <p>Sample output follows.<\/p>\n * <pre>\n * 176 [main] INFO examples.Sort - Populating an array of 2 elements in reverse order.\n * 225 [main] INFO examples.SortAlgo - Entered the sort method.\n * 304 [main] INFO examples.SortAlgo - Dump of integer array:\n * 317 [main] INFO examples.SortAlgo - Element [0] = 0\n * 331 [main] INFO examples.SortAlgo - Element [1] = 1\n * 343 [main] INFO examples.Sort - The next log statement should be an error message.\n * 346 [main] ERROR examples.SortAlgo - Tried to dump an uninitialized array.\n *   at org.log4j.examples.SortAlgo.dump(SortAlgo.java:58)\n *   at org.log4j.examples.Sort.main(Sort.java:64)\n * 467 [main] INFO  examples.Sort - Exiting main method.\n * <\/pre>\n *\n * <p>This implementation is heavily inspired by\n * <a href=\"http://commons.apache.org/logging/\">Apache Commons Logging<\/a>'s SimpleLog.<\/p>\n *\n * @author Ceki G&uuml;lc&uuml;\n * @author <a href=\"mailto:sanders@apache.org\">Scott Sanders<\/a>\n * @author Rod Waldhoff\n * @author Robert Burrell Donkin\n * @author C&eacute;drik LIME\n */\npublic class SimpleLogger extends MarkerIgnoringBase {\n\n    private static final long serialVersionUID = -632788891211436180L;\n    private static final String CONFIGURATION_FILE = \"simplelogger.properties\";\n\n    private static long START_TIME = System.currentTimeMillis();\n    private static final Properties SIMPLE_LOGGER_PROPS = new Properties();\n\n    private static final int LOG_LEVEL_TRACE = LocationAwareLogger.TRACE_INT;\n    private static final int LOG_LEVEL_DEBUG = LocationAwareLogger.DEBUG_INT;\n    private static final int LOG_LEVEL_INFO = LocationAwareLogger.INFO_INT;\n    private static final int LOG_LEVEL_WARN = LocationAwareLogger.WARN_INT;\n    private static final int LOG_LEVEL_ERROR = LocationAwareLogger.ERROR_INT;\n    // The OFF level can only be used in configuration files to disable logging. It has\n    // no printing method associated with it in o.s.Logger interface.\n    private static final int LOG_LEVEL_OFF = LOG_LEVEL_ERROR + 10;\n\n    private static boolean INITIALIZED = false;\n\n    private static int DEFAULT_LOG_LEVEL = LOG_LEVEL_INFO;\n    private static boolean SHOW_DATE_TIME = false;\n    private static String DATE_TIME_FORMAT_STR = null;\n    private static DateFormat DATE_FORMATTER = null;\n    private static boolean SHOW_THREAD_NAME = true;\n    private static boolean SHOW_LOG_NAME = true;\n    private static boolean SHOW_SHORT_LOG_NAME = false;\n    private static String LOG_FILE = \"System.err\";\n    private static OutputChoice OUTPUT_CHOICE = null;\n    private static boolean LEVEL_IN_BRACKETS = false;\n    private static String WARN_LEVEL_STRING = \"WARN\";\n\n    /** All system properties used by <code>SimpleLogger<\/code> start with this prefix */\n    public static final String SYSTEM_PREFIX = \"org.slf4j.simpleLogger.\";\n\n    public static final String DEFAULT_LOG_LEVEL_KEY = SYSTEM_PREFIX + \"defaultLogLevel\";\n    public static final String SHOW_DATE_TIME_KEY = SYSTEM_PREFIX + \"showDateTime\";\n    public static final String DATE_TIME_FORMAT_KEY = SYSTEM_PREFIX + \"dateTimeFormat\";\n    public static final String SHOW_THREAD_NAME_KEY = SYSTEM_PREFIX + \"showThreadName\";\n    public static final String SHOW_LOG_NAME_KEY = SYSTEM_PREFIX + \"showLogName\";\n    public static final String SHOW_SHORT_LOG_NAME_KEY = SYSTEM_PREFIX + \"showShortLogName\";\n    public static final String LOG_FILE_KEY = SYSTEM_PREFIX + \"logFile\";\n    public static final String LEVEL_IN_BRACKETS_KEY = SYSTEM_PREFIX + \"levelInBrackets\";\n    public static final String WARN_LEVEL_STRING_KEY = SYSTEM_PREFIX + \"warnLevelString\";\n\n    public static final String LOG_KEY_PREFIX = SYSTEM_PREFIX + \"log.\";\n\n    private static String getStringProperty(String name) {\n        String prop = null;\n        try {\n            prop = System.getProperty(name);\n        } catch (SecurityException e) {\n            ; // Ignore\n        }\n        return (prop == null) ? SIMPLE_LOGGER_PROPS.getProperty(name) : prop;\n    }\n\n    private static String getStringProperty(String name, String defaultValue) {\n        String prop = getStringProperty(name);\n        return (prop == null) ? defaultValue : prop;\n    }\n\n    private static boolean getBooleanProperty(String name, boolean defaultValue) {\n        String prop = getStringProperty(name);\n        return (prop == null) ? defaultValue : \"true\".equalsIgnoreCase(prop);\n    }\n\n    static void lazyInit() {\n        if (INITIALIZED) {\n            return;\n        }\n        INITIALIZED = true;\n        init();\n    }\n    \n    static void init() {\n        loadProperties();\n\n        String defaultLogLevelString = getStringProperty(DEFAULT_LOG_LEVEL_KEY, null);\n        if (defaultLogLevelString != null)\n            DEFAULT_LOG_LEVEL = stringToLevel(defaultLogLevelString);\n\n        SHOW_LOG_NAME = getBooleanProperty(SHOW_LOG_NAME_KEY, SHOW_LOG_NAME);\n        SHOW_SHORT_LOG_NAME = getBooleanProperty(SHOW_SHORT_LOG_NAME_KEY, SHOW_SHORT_LOG_NAME);\n        SHOW_DATE_TIME = getBooleanProperty(SHOW_DATE_TIME_KEY, SHOW_DATE_TIME);\n        SHOW_THREAD_NAME = getBooleanProperty(SHOW_THREAD_NAME_KEY, SHOW_THREAD_NAME);\n        DATE_TIME_FORMAT_STR = getStringProperty(DATE_TIME_FORMAT_KEY, DATE_TIME_FORMAT_STR);\n        LEVEL_IN_BRACKETS = getBooleanProperty(LEVEL_IN_BRACKETS_KEY, LEVEL_IN_BRACKETS);\n        WARN_LEVEL_STRING = getStringProperty(WARN_LEVEL_STRING_KEY, WARN_LEVEL_STRING);\n\n        LOG_FILE = getStringProperty(LOG_FILE_KEY, LOG_FILE);\n        OUTPUT_CHOICE = computeOutputChoice(LOG_FILE);\n\n        if (DATE_TIME_FORMAT_STR != null) {\n            try {\n                DATE_FORMATTER = new SimpleDateFormat(DATE_TIME_FORMAT_STR);\n            } catch (IllegalArgumentException e) {\n                Util.report(\"Bad date format in \" + CONFIGURATION_FILE + \"; will output relative time\", e);\n            }\n        }\n    }\n\n    enum Target {\n    \tSysOut, SysErr;\n    }\n    \n    private static OutputChoice computeOutputChoice(String logFile) {\n        if (\"System.err\".equalsIgnoreCase(logFile))\n            return new OutputChoice(OutputChoiceType.SYS_ERR);\n        else if (\"System.out\".equalsIgnoreCase(logFile)) {\n            return  new OutputChoice(OutputChoiceType.SYS_OUT);\n        } else {\n            try {\n                FileOutputStream fos = new FileOutputStream(logFile);\n                PrintStream printStream = new PrintStream(fos);\n                return new OutputChoice(printStream);\n            } catch (FileNotFoundException e) {\n                Util.report(\"Could not open [\" + logFile + \"]. Defaulting to System.err\", e);\n                return new OutputChoice(OutputChoiceType.SYS_ERR);\n            }\n        }\n    }\n\n    private static void loadProperties() {\n        // Add props from the resource simplelogger.properties\n        InputStream in = AccessController.doPrivileged(new PrivilegedAction<InputStream>() {\n            public InputStream run() {\n                ClassLoader threadCL = Thread.currentThread().getContextClassLoader();\n                if (threadCL != null) {\n                    return threadCL.getResourceAsStream(CONFIGURATION_FILE);\n                } else {\n                    return ClassLoader.getSystemResourceAsStream(CONFIGURATION_FILE);\n                }\n            }\n        });\n        if (null != in) {\n            try {\n                SIMPLE_LOGGER_PROPS.load(in);\n            } catch (java.io.IOException e) {\n                // ignored\n            } finally {\n                try {\n                    in.close();\n                } catch (java.io.IOException e) {\n                    // ignored\n                }\n            }\n        }\n    }\n\n    /** The current log level */\n    protected int currentLogLevel = LOG_LEVEL_INFO;\n    /** The short name of this simple log instance */\n    private transient String shortLogName = null;\n\n    /**\n     * Package access allows only {@link SimpleLoggerFactory} to instantiate\n     * SimpleLogger instances.\n     */\n    SimpleLogger(String name) {\n        this.name = name;\n\n        String levelString = recursivelyComputeLevelString();\n        if (levelString != null) {\n            this.currentLogLevel = stringToLevel(levelString);\n        } else {\n            this.currentLogLevel = DEFAULT_LOG_LEVEL;\n        }\n    }\n\n    String recursivelyComputeLevelString() {\n        String tempName = name;\n        String levelString = null;\n        int indexOfLastDot = tempName.length();\n        while ((levelString == null) && (indexOfLastDot > -1)) {\n            tempName = tempName.substring(0, indexOfLastDot);\n            levelString = getStringProperty(LOG_KEY_PREFIX + tempName, null);\n            indexOfLastDot = String.valueOf(tempName).lastIndexOf(\".\");\n        }\n        return levelString;\n    }\n\n    private static int stringToLevel(String levelStr) {\n        if (\"trace\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_TRACE;\n        } else if (\"debug\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_DEBUG;\n        } else if (\"info\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_INFO;\n        } else if (\"warn\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_WARN;\n        } else if (\"error\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_ERROR;\n        } else if (\"off\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_OFF;\n        }\n        // assume INFO by default\n        return LOG_LEVEL_INFO;\n    }\n\n    /**\n     * This is our internal implementation for logging regular (non-parameterized)\n     * log messages.\n     *\n     * @param level   One of the LOG_LEVEL_XXX constants defining the log level\n     * @param message The message itself\n     * @param t       The exception whose stack trace should be logged\n     */\n    private void log(int level, String message, Throwable t) {\n        if (!isLevelEnabled(level)) {\n            return;\n        }\n\n        StringBuilder buf = new StringBuilder(32);\n\n        // Append date-time if so configured\n        if (SHOW_DATE_TIME) {\n            if (DATE_FORMATTER != null) {\n                buf.append(getFormattedDate());\n                buf.append(' ');\n            } else {\n                buf.append(System.currentTimeMillis() - START_TIME);\n                buf.append(' ');\n            }\n        }\n\n        // Append current thread name if so configured\n        if (SHOW_THREAD_NAME) {\n            buf.append('[');\n            buf.append(Thread.currentThread().getName());\n            buf.append(\"] \");\n        }\n\n        if (LEVEL_IN_BRACKETS)\n            buf.append('[');\n\n        // Append a readable representation of the log level\n        switch (level) {\n        case LOG_LEVEL_TRACE:\n            buf.append(\"TRACE\");\n            break;\n        case LOG_LEVEL_DEBUG:\n            buf.append(\"DEBUG\");\n            break;\n        case LOG_LEVEL_INFO:\n            buf.append(\"INFO\");\n            break;\n        case LOG_LEVEL_WARN:\n            buf.append(WARN_LEVEL_STRING);\n            break;\n        case LOG_LEVEL_ERROR:\n            buf.append(\"ERROR\");\n            break;\n        }\n        if (LEVEL_IN_BRACKETS)\n            buf.append(']');\n        buf.append(' ');\n\n        // Append the name of the log instance if so configured\n        if (SHOW_SHORT_LOG_NAME) {\n            if (shortLogName == null)\n                shortLogName = computeShortName();\n            buf.append(String.valueOf(shortLogName)).append(\" - \");\n        } else if (SHOW_LOG_NAME) {\n            buf.append(String.valueOf(name)).append(\" - \");\n        }\n\n        // Append the message\n        buf.append(message);\n\n        write(buf, t);\n\n    }\n\n    void write(StringBuilder buf, Throwable t) {\n    \tPrintStream targetStream = OUTPUT_CHOICE.getTargetPrintStream();\n    \t\n    \ttargetStream.println(buf.toString());\n        if (t != null) {\n            t.printStackTrace(targetStream);\n        }\n        targetStream.flush();\n    }\n\n\tObject t;\n\t\n\n\tprivate String getFormattedDate() {\n        Date now = new Date();\n        String dateText;\n        synchronized (DATE_FORMATTER) {\n            dateText = DATE_FORMATTER.format(now);\n        }\n        return dateText;\n    }\n\n    private String computeShortName() {\n        return name.substring(name.lastIndexOf(\".\") + 1);\n    }\n\n    /**\n     * For formatted messages, first substitute arguments and then log.\n     *\n     * @param level\n     * @param format\n     * @param arg1\n     * @param arg2\n     */\n    private void formatAndLog(int level, String format, Object arg1, Object arg2) {\n        if (!isLevelEnabled(level)) {\n            return;\n        }\n        FormattingTuple tp = MessageFormatter.format(format, arg1, arg2);\n        log(level, tp.getMessage(), tp.getThrowable());\n    }\n\n    /**\n     * For formatted messages, first substitute arguments and then log.\n     *\n     * @param level\n     * @param format\n     * @param arguments a list of 3 ore more arguments\n     */\n    private void formatAndLog(int level, String format, Object... arguments) {\n        if (!isLevelEnabled(level)) {\n            return;\n        }\n        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n        log(level, tp.getMessage(), tp.getThrowable());\n    }\n\n    /**\n     * Is the given log level currently enabled?\n     *\n     * @param logLevel is this level enabled?\n     */\n    protected boolean isLevelEnabled(int logLevel) {\n        // log level are numerically ordered so can use simple numeric\n        // comparison\n        return (logLevel >= currentLogLevel);\n    }\n\n    /** Are {@code trace} messages currently enabled? */\n    public boolean isTraceEnabled() {\n        return isLevelEnabled(LOG_LEVEL_TRACE);\n    }\n\n    /**\n     * A simple implementation which logs messages of level TRACE according\n     * to the format outlined above.\n     */\n    public void trace(String msg) {\n        log(LOG_LEVEL_TRACE, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * TRACE according to the format outlined above.\n     */\n    public void trace(String format, Object param1) {\n        formatAndLog(LOG_LEVEL_TRACE, format, param1, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * TRACE according to the format outlined above.\n     */\n    public void trace(String format, Object param1, Object param2) {\n        formatAndLog(LOG_LEVEL_TRACE, format, param1, param2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * TRACE according to the format outlined above.\n     */\n    public void trace(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_TRACE, format, argArray);\n    }\n\n    /** Log a message of level TRACE, including an exception. */\n    public void trace(String msg, Throwable t) {\n        log(LOG_LEVEL_TRACE, msg, t);\n    }\n\n    /** Are {@code debug} messages currently enabled? */\n    public boolean isDebugEnabled() {\n        return isLevelEnabled(LOG_LEVEL_DEBUG);\n    }\n\n    /**\n     * A simple implementation which logs messages of level DEBUG according\n     * to the format outlined above.\n     */\n    public void debug(String msg) {\n        log(LOG_LEVEL_DEBUG, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * DEBUG according to the format outlined above.\n     */\n    public void debug(String format, Object param1) {\n        formatAndLog(LOG_LEVEL_DEBUG, format, param1, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * DEBUG according to the format outlined above.\n     */\n    public void debug(String format, Object param1, Object param2) {\n        formatAndLog(LOG_LEVEL_DEBUG, format, param1, param2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * DEBUG according to the format outlined above.\n     */\n    public void debug(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_DEBUG, format, argArray);\n    }\n\n    /** Log a message of level DEBUG, including an exception. */\n    public void debug(String msg, Throwable t) {\n        log(LOG_LEVEL_DEBUG, msg, t);\n    }\n\n    /** Are {@code info} messages currently enabled? */\n    public boolean isInfoEnabled() {\n        return isLevelEnabled(LOG_LEVEL_INFO);\n    }\n\n    /**\n     * A simple implementation which logs messages of level INFO according\n     * to the format outlined above.\n     */\n    public void info(String msg) {\n        log(LOG_LEVEL_INFO, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * INFO according to the format outlined above.\n     */\n    public void info(String format, Object arg) {\n        formatAndLog(LOG_LEVEL_INFO, format, arg, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * INFO according to the format outlined above.\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        formatAndLog(LOG_LEVEL_INFO, format, arg1, arg2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * INFO according to the format outlined above.\n     */\n    public void info(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_INFO, format, argArray);\n    }\n\n    /** Log a message of level INFO, including an exception. */\n    public void info(String msg, Throwable t) {\n        log(LOG_LEVEL_INFO, msg, t);\n    }\n\n    /** Are {@code warn} messages currently enabled? */\n    public boolean isWarnEnabled() {\n        return isLevelEnabled(LOG_LEVEL_WARN);\n    }\n\n    /**\n     * A simple implementation which always logs messages of level WARN according\n     * to the format outlined above.\n     */\n    public void warn(String msg) {\n        log(LOG_LEVEL_WARN, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * WARN according to the format outlined above.\n     */\n    public void warn(String format, Object arg) {\n        formatAndLog(LOG_LEVEL_WARN, format, arg, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * WARN according to the format outlined above.\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        formatAndLog(LOG_LEVEL_WARN, format, arg1, arg2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * WARN according to the format outlined above.\n     */\n    public void warn(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_WARN, format, argArray);\n    }\n\n    /** Log a message of level WARN, including an exception. */\n    public void warn(String msg, Throwable t) {\n        log(LOG_LEVEL_WARN, msg, t);\n    }\n\n    /** Are {@code error} messages currently enabled? */\n    public boolean isErrorEnabled() {\n        return isLevelEnabled(LOG_LEVEL_ERROR);\n    }\n\n    /**\n     * A simple implementation which always logs messages of level ERROR according\n     * to the format outlined above.\n     */\n    public void error(String msg) {\n        log(LOG_LEVEL_ERROR, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * ERROR according to the format outlined above.\n     */\n    public void error(String format, Object arg) {\n        formatAndLog(LOG_LEVEL_ERROR, format, arg, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * ERROR according to the format outlined above.\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        formatAndLog(LOG_LEVEL_ERROR, format, arg1, arg2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * ERROR according to the format outlined above.\n     */\n    public void error(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_ERROR, format, argArray);\n    }\n\n    /** Log a message of level ERROR, including an exception. */\n    public void error(String msg, Throwable t) {\n        log(LOG_LEVEL_ERROR, msg, t);\n    }\n\n    public void log(LoggingEvent event) {\n        int levelInt = event.getLevel().toInt();\n\n        if (!isLevelEnabled(levelInt)) {\n            return;\n        }\n        FormattingTuple tp = MessageFormatter.arrayFormat(event.getMessage(), event.getArgumentArray(), event.getThrowable());\n        log(levelInt, tp.getMessage(), event.getThrowable());\n    }\n\n}\n","lineNo":356}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2016 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerAccessingThread;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.LoggerFactoryFriend;\n\npublic class SimpleLoggerMultithreadedInitializationTest {\n\n    final static int THREAD_COUNT = 4 + Runtime.getRuntime().availableProcessors() * 2;\n\n    private final AtomicLong eventCount = new AtomicLong(0);\n    private final PrintStream oldErr = System.err;\n    private final CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT + 1);\n\n    final int diff = new Random().nextInt(10000);\n    final String loggerName = this.getClass().getName();\n    StringPrintStream sps = new StringPrintStream(oldErr, true);\n\n    @Before\n    public void setup() {\n        System.out.println(\"THREAD_COUNT=\" + THREAD_COUNT);\n        System.setErr(sps);\n        System.setProperty(SimpleLogger.LOG_FILE_KEY, \"System.err\");\n        LoggerFactoryFriend.reset();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        LoggerFactoryFriend.reset();\n        System.clearProperty(SimpleLogger.LOG_FILE_KEY);\n        System.setErr(oldErr);\n    }\n\n    @Test\n    public void multiThreadedInitialization() throws InterruptedException, BrokenBarrierException {\n\n        @SuppressWarnings(\"unused\")\n        LoggerAccessingThread[] accessors = harness();\n\n        Logger logger = LoggerFactory.getLogger(loggerName + diff);\n        logger.info(\"hello\");\n        eventCount.getAndIncrement();\n\n        int NUM_LINES_IN_SLF4J_REPLAY_WARNING = 3;\n        \n        long expected = eventCount.get() + NUM_LINES_IN_SLF4J_REPLAY_WARNING;\n        int actual = sps.stringList.size();\n        assertTrue(expected + \" >= \" + actual, expected >= actual);\n        assertTrue(expected + \" < \" + actual + \" + 10\", expected < actual + 10);\n    }\n\n    private LoggerAccessingThread[] harness() throws InterruptedException, BrokenBarrierException {\n        final LoggerAccessingThread[] threads = new LoggerAccessingThread[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            LoggerAccessingThread simpleLoggerThread = new LoggerAccessingThread(barrier, i, eventCount);\n            threads[i] = simpleLoggerThread;\n            simpleLoggerThread.start();\n        }\n\n        barrier.await();\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            threads[i].join();\n        }\n        return threads;\n    }\n\n\n    static class StringPrintStream extends PrintStream {\n\n        public static final String LINE_SEP = System.getProperty(\"line.separator\");\n        PrintStream other;\n        boolean duplicate = false;\n\n        List<String> stringList = Collections.synchronizedList(new ArrayList<String>());\n\n        public StringPrintStream(PrintStream ps, boolean duplicate) {\n            super(ps);\n            other = ps;\n            this.duplicate = duplicate;\n        }\n\n        public StringPrintStream(PrintStream ps) {\n            this(ps, false);\n        }\n\n        public void print(String s) {\n            if (duplicate)\n                other.print(s);\n            stringList.add(s);\n        }\n\n        public void println(String s) {\n            if (duplicate)\n                other.println(s);\n            stringList.add(s);\n        }\n\n        public void println(Object o) {\n            if (duplicate)\n                other.println(o);\n            stringList.add(o.toString());\n        }\n    };\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2016 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerAccessingThread;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.LoggerFactoryFriend;\n\npublic class SimpleLoggerMultithreadedInitializationTest {\n\n    final static int THREAD_COUNT = 4 + Runtime.getRuntime().availableProcessors() * 2;\n\n    private final AtomicLong eventCount = new AtomicLong(0);\n    private final PrintStream oldErr = System.err;\n    private final CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT + 1);\n\n    final int diff = new Random().nextInt(10000);\n    final String loggerName = this.getClass().getName();\n    StringPrintStream sps = new StringPrintStream(oldErr, true);\n\n    @Before\n    public void setup() {\n        System.out.println(\"THREAD_COUNT=\" + THREAD_COUNT);\n        System.setErr(sps);\n        System.setProperty(SimpleLogger.LOG_FILE_KEY, \"System.err\");\n        LoggerFactoryFriend.reset();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        LoggerFactoryFriend.reset();\n        System.clearProperty(SimpleLogger.LOG_FILE_KEY);\n        System.setErr(oldErr);\n    }\n\n    @Test\n    public void multiThreadedInitialization() throws InterruptedException, BrokenBarrierException {\n\n        @SuppressWarnings(\"unused\")\n        LoggerAccessingThread[] accessors = harness();\n\n        Logger logger = LoggerFactory.getLogger(loggerName + diff);\n        logger.info(\"hello\");\n        eventCount.getAndIncrement();\n\n        int NUM_LINES_IN_SLF4J_REPLAY_WARNING = 3;\n        assertEquals(eventCount.get() + NUM_LINES_IN_SLF4J_REPLAY_WARNING, sps.stringList.size());\n    }\n\n    private LoggerAccessingThread[] harness() throws InterruptedException, BrokenBarrierException {\n        final LoggerAccessingThread[] threads = new LoggerAccessingThread[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            LoggerAccessingThread simpleLoggerThread = new LoggerAccessingThread(barrier, i, eventCount);\n            threads[i] = simpleLoggerThread;\n            simpleLoggerThread.start();\n        }\n\n        barrier.await();\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            threads[i].join();\n        }\n        return threads;\n    }\n\n\n    static class StringPrintStream extends PrintStream {\n\n        public static final String LINE_SEP = System.getProperty(\"line.separator\");\n        PrintStream other;\n        boolean duplicate = false;\n\n        List<String> stringList = Collections.synchronizedList(new ArrayList<String>());\n\n        public StringPrintStream(PrintStream ps, boolean duplicate) {\n            super(ps);\n            other = ps;\n            this.duplicate = duplicate;\n        }\n\n        public StringPrintStream(PrintStream ps) {\n            this(ps, false);\n        }\n\n        public void print(String s) {\n            if (duplicate)\n                other.print(s);\n            stringList.add(s);\n        }\n\n        public void println(String s) {\n            if (duplicate)\n                other.println(s);\n            stringList.add(s);\n        }\n\n        public void println(Object o) {\n            if (duplicate)\n                other.println(o);\n            stringList.add(o.toString());\n        }\n    };\n\n}\n","lineNo":85}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2016 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerAccessingThread;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.LoggerFactoryFriend;\n\npublic class SimpleLoggerMultithreadedInitializationTest {\n\n    final static int THREAD_COUNT = 4 + Runtime.getRuntime().availableProcessors() * 2;\n\n    private final AtomicLong eventCount = new AtomicLong(0);\n    private final PrintStream oldErr = System.err;\n    private final CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT + 1);\n\n    final int diff = new Random().nextInt(10000);\n    final String loggerName = this.getClass().getName();\n    StringPrintStream sps = new StringPrintStream(oldErr, true);\n\n    @Before\n    public void setup() {\n        System.out.println(\"THREAD_COUNT=\" + THREAD_COUNT);\n        System.setErr(sps);\n        System.setProperty(SimpleLogger.LOG_FILE_KEY, \"System.err\");\n        LoggerFactoryFriend.reset();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        LoggerFactoryFriend.reset();\n        System.clearProperty(SimpleLogger.LOG_FILE_KEY);\n        System.setErr(oldErr);\n    }\n\n    @Test\n    public void multiThreadedInitialization() throws InterruptedException, BrokenBarrierException {\n\n        @SuppressWarnings(\"unused\")\n        LoggerAccessingThread[] accessors = harness();\n\n        Logger logger = LoggerFactory.getLogger(loggerName + diff);\n        logger.info(\"hello\");\n        eventCount.getAndIncrement();\n\n        int NUM_LINES_IN_SLF4J_REPLAY_WARNING = 3;\n        \n        long expected = eventCount.get() + NUM_LINES_IN_SLF4J_REPLAY_WARNING;\n        int actual = sps.stringList.size();\n        assertTrue(expected + \" >= \" + actual, expected >= actual);\n        assertTrue(expected + \" < \" + actual + \" + 10\", expected < actual + 10);\n    }\n\n    private LoggerAccessingThread[] harness() throws InterruptedException, BrokenBarrierException {\n        final LoggerAccessingThread[] threads = new LoggerAccessingThread[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            LoggerAccessingThread simpleLoggerThread = new LoggerAccessingThread(barrier, i, eventCount);\n            threads[i] = simpleLoggerThread;\n            simpleLoggerThread.start();\n        }\n\n        barrier.await();\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            threads[i].join();\n        }\n        return threads;\n    }\n\n\n    static class StringPrintStream extends PrintStream {\n\n        public static final String LINE_SEP = System.getProperty(\"line.separator\");\n        PrintStream other;\n        boolean duplicate = false;\n\n        List<String> stringList = Collections.synchronizedList(new ArrayList<String>());\n\n        public StringPrintStream(PrintStream ps, boolean duplicate) {\n            super(ps);\n            other = ps;\n            this.duplicate = duplicate;\n        }\n\n        public StringPrintStream(PrintStream ps) {\n            this(ps, false);\n        }\n\n        public void print(String s) {\n            if (duplicate)\n                other.print(s);\n            stringList.add(s);\n        }\n\n        public void println(String s) {\n            if (duplicate)\n                other.println(s);\n            stringList.add(s);\n        }\n\n        public void println(Object o) {\n            if (duplicate)\n                other.println(o);\n            stringList.add(o.toString());\n        }\n    };\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2016 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerAccessingThread;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.LoggerFactoryFriend;\n\npublic class SimpleLoggerMultithreadedInitializationTest {\n\n    final static int THREAD_COUNT = 4 + Runtime.getRuntime().availableProcessors() * 2;\n\n    private final AtomicLong eventCount = new AtomicLong(0);\n    private final PrintStream oldErr = System.err;\n    private final CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT + 1);\n\n    final int diff = new Random().nextInt(10000);\n    final String loggerName = this.getClass().getName();\n    StringPrintStream sps = new StringPrintStream(oldErr, true);\n\n    @Before\n    public void setup() {\n        System.out.println(\"THREAD_COUNT=\" + THREAD_COUNT);\n        System.setErr(sps);\n        System.setProperty(SimpleLogger.LOG_FILE_KEY, \"System.err\");\n        LoggerFactoryFriend.reset();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        LoggerFactoryFriend.reset();\n        System.clearProperty(SimpleLogger.LOG_FILE_KEY);\n        System.setErr(oldErr);\n    }\n\n    @Test\n    public void multiThreadedInitialization() throws InterruptedException, BrokenBarrierException {\n\n        @SuppressWarnings(\"unused\")\n        LoggerAccessingThread[] accessors = harness();\n\n        Logger logger = LoggerFactory.getLogger(loggerName + diff);\n        logger.info(\"hello\");\n        eventCount.getAndIncrement();\n\n        int NUM_LINES_IN_SLF4J_REPLAY_WARNING = 3;\n        assertEquals(eventCount.get() + NUM_LINES_IN_SLF4J_REPLAY_WARNING, sps.stringList.size());\n    }\n\n    private LoggerAccessingThread[] harness() throws InterruptedException, BrokenBarrierException {\n        final LoggerAccessingThread[] threads = new LoggerAccessingThread[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            LoggerAccessingThread simpleLoggerThread = new LoggerAccessingThread(barrier, i, eventCount);\n            threads[i] = simpleLoggerThread;\n            simpleLoggerThread.start();\n        }\n\n        barrier.await();\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            threads[i].join();\n        }\n        return threads;\n    }\n\n\n    static class StringPrintStream extends PrintStream {\n\n        public static final String LINE_SEP = System.getProperty(\"line.separator\");\n        PrintStream other;\n        boolean duplicate = false;\n\n        List<String> stringList = Collections.synchronizedList(new ArrayList<String>());\n\n        public StringPrintStream(PrintStream ps, boolean duplicate) {\n            super(ps);\n            other = ps;\n            this.duplicate = duplicate;\n        }\n\n        public StringPrintStream(PrintStream ps) {\n            this(ps, false);\n        }\n\n        public void print(String s) {\n            if (duplicate)\n                other.print(s);\n            stringList.add(s);\n        }\n\n        public void println(String s) {\n            if (duplicate)\n                other.println(s);\n            stringList.add(s);\n        }\n\n        public void println(Object o) {\n            if (duplicate)\n                other.println(o);\n            stringList.add(o.toString());\n        }\n    };\n\n}\n","lineNo":86}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.slf4j.event.LoggingEventAware;\nimport org.slf4j.event.SubstituteLoggingEvent;\nimport org.slf4j.helpers.NOPLoggerFactory;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.helpers.SubstituteLoggerFactory;\nimport org.slf4j.helpers.Util;\nimport org.slf4j.impl.StaticLoggerBinder;\n\n/**\n * The <code>LoggerFactory<\/code> is a utility class producing Loggers for\n * various logging APIs, most notably for log4j, logback and JDK 1.4 logging.\n * Other implementations such as {@link org.slf4j.impl.NOPLogger NOPLogger} and\n * {@link org.slf4j.impl.SimpleLogger SimpleLogger} are also supported.\n * <p/>\n * <p/>\n * <code>LoggerFactory<\/code> is essentially a wrapper around an\n * {@link ILoggerFactory} instance bound with <code>LoggerFactory<\/code> at\n * compile time.\n * <p/>\n * <p/>\n * Please note that all methods in <code>LoggerFactory<\/code> are static.\n *\n *\n * @author Alexander Dorokhine\n * @author Robert Elliot\n * @author Ceki G&uuml;lc&uuml;\n *\n */\npublic final class LoggerFactory {\n\n    static final String CODES_PREFIX = \"http://www.slf4j.org/codes.html\";\n\n    static final String NO_STATICLOGGERBINDER_URL = CODES_PREFIX + \"#StaticLoggerBinder\";\n    static final String MULTIPLE_BINDINGS_URL = CODES_PREFIX + \"#multiple_bindings\";\n    static final String NULL_LF_URL = CODES_PREFIX + \"#null_LF\";\n    static final String VERSION_MISMATCH = CODES_PREFIX + \"#version_mismatch\";\n    static final String SUBSTITUTE_LOGGER_URL = CODES_PREFIX + \"#substituteLogger\";\n    static final String LOGGER_NAME_MISMATCH_URL = CODES_PREFIX + \"#loggerNameMismatch\";\n\n    static final String UNSUCCESSFUL_INIT_URL = CODES_PREFIX + \"#unsuccessfulInit\";\n    static final String UNSUCCESSFUL_INIT_MSG = \"org.slf4j.LoggerFactory could not be successfully initialized. See also \" + UNSUCCESSFUL_INIT_URL;\n\n    static final int UNINITIALIZED = 0;\n    static final int ONGOING_INITIALIZATION = 1;\n    static final int FAILED_INITIALIZATION = 2;\n    static final int SUCCESSFUL_INITIALIZATION = 3;\n    static final int NOP_FALLBACK_INITIALIZATION = 4;\n\n    static int INITIALIZATION_STATE = UNINITIALIZED;\n    static SubstituteLoggerFactory SUBST_FACTORY = new SubstituteLoggerFactory();\n    static NOPLoggerFactory NOP_FALLBACK_FACTORY = new NOPLoggerFactory();\n\n    // Support for detecting mismatched logger names.\n    static final String DETECT_LOGGER_NAME_MISMATCH_PROPERTY = \"slf4j.detectLoggerNameMismatch\";\n    static final String JAVA_VENDOR_PROPERTY = \"java.vendor.url\";\n\n    static boolean DETECT_LOGGER_NAME_MISMATCH = Util.safeGetBooleanSystemProperty(DETECT_LOGGER_NAME_MISMATCH_PROPERTY);\n\n    /**\n     * It is LoggerFactory's responsibility to track version changes and manage\n     * the compatibility list.\n     * <p/>\n     * <p/>\n     * It is assumed that all versions in the 1.6 are mutually compatible.\n     */\n    static private final String[] API_COMPATIBILITY_LIST = new String[] { \"1.6\", \"1.7\" };\n\n    // private constructor prevents instantiation\n    private LoggerFactory() {\n    }\n\n    /**\n     * Force LoggerFactory to consider itself uninitialized.\n     * <p/>\n     * <p/>\n     * This method is intended to be called by classes (in the same package) for\n     * testing purposes. This method is internal. It can be modified, renamed or\n     * removed at any time without notice.\n     * <p/>\n     * <p/>\n     * You are strongly discouraged from calling this method in production code.\n     */\n    static void reset() {\n        INITIALIZATION_STATE = UNINITIALIZED;\n        SUBST_FACTORY = new SubstituteLoggerFactory();\n    }\n\n    private final static void performInitialization() {\n        bind();\n        if (INITIALIZATION_STATE == SUCCESSFUL_INITIALIZATION) {\n            versionSanityCheck();\n        }\n    }\n\n    private static boolean messageContainsOrgSlf4jImplStaticLoggerBinder(String msg) {\n        if (msg == null)\n            return false;\n        if (msg.contains(\"org/slf4j/impl/StaticLoggerBinder\"))\n            return true;\n        if (msg.contains(\"org.slf4j.impl.StaticLoggerBinder\"))\n            return true;\n        return false;\n    }\n\n    private final static void bind() {\n        try {\n            Set<URL> staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();\n            reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);\n            // the next line does the binding\n            StaticLoggerBinder.getSingleton();\n            INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;\n            reportActualBinding(staticLoggerBinderPathSet);\n            fixSubstitutedLoggers();\n            playRecordedEvents();\n        } catch (NoClassDefFoundError ncde) {\n            String msg = ncde.getMessage();\n            if (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) {\n                INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;\n                Util.report(\"Failed to load class \\\"org.slf4j.impl.StaticLoggerBinder\\\".\");\n                Util.report(\"Defaulting to no-operation (NOP) logger implementation\");\n                Util.report(\"See \" + NO_STATICLOGGERBINDER_URL + \" for further details.\");\n            } else {\n                failedBinding(ncde);\n                throw ncde;\n            }\n        } catch (java.lang.NoSuchMethodError nsme) {\n            String msg = nsme.getMessage();\n            if (msg != null && msg.contains(\"org.slf4j.impl.StaticLoggerBinder.getSingleton()\")) {\n                INITIALIZATION_STATE = FAILED_INITIALIZATION;\n                Util.report(\"slf4j-api 1.6.x (or later) is incompatible with this binding.\");\n                Util.report(\"Your binding is version 1.5.5 or earlier.\");\n                Util.report(\"Upgrade your binding to version 1.6.x.\");\n            }\n            throw nsme;\n        } catch (Exception e) {\n            failedBinding(e);\n            throw new IllegalStateException(\"Unexpected initialization failure\", e);\n        }\n    }\n\n    static void failedBinding(Throwable t) {\n        INITIALIZATION_STATE = FAILED_INITIALIZATION;\n        Util.report(\"Failed to instantiate SLF4J LoggerFactory\", t);\n    }\n\n    private static void playRecordedEvents() {\n        List<SubstituteLoggingEvent> events = SUBST_FACTORY.getEventList();\n\n        for (SubstituteLoggingEvent event : events) {\n            SubstituteLogger substLogger = event.getLogger();\n            if (substLogger.isDelegateEventAware()) {\n                substLogger.log(event);\n            }\n        }\n    }\n\n    private final static void fixSubstitutedLoggers() {\n        List<SubstituteLogger> loggers = SUBST_FACTORY.getLoggers();\n\n        if (loggers.isEmpty()) {\n            return;\n        }\n\n        boolean substitutionWarningEmmitted = false;\n        for (SubstituteLogger subLogger : loggers) {\n            Logger logger = getLogger(subLogger.getName());\n            subLogger.setDelegate(logger);\n\n            if (!isEventAware(logger)) {\n                if (!substitutionWarningEmmitted) {\n                    emitSubstitutionWarning();\n                    substitutionWarningEmmitted = true;\n                }\n                Util.report(subLogger.getName());\n            }\n        }\n\n        SUBST_FACTORY.clear();\n    }\n\n    private static boolean isEventAware(Logger logger) {\n        return logger instanceof LoggingEventAware;\n    }\n\n    private static void emitSubstitutionWarning() {\n        Util.report(\"The following set of substitute loggers may have been accessed\");\n        Util.report(\"during the initialization phase. Logging calls during this\");\n        Util.report(\"phase were not honored. However, subsequent logging calls to these\");\n        Util.report(\"loggers will work as normally expected.\");\n        Util.report(\"See also \" + SUBSTITUTE_LOGGER_URL);\n    }\n\n    private final static void versionSanityCheck() {\n        try {\n            String requested = StaticLoggerBinder.REQUESTED_API_VERSION;\n\n            boolean match = false;\n            for (String aAPI_COMPATIBILITY_LIST : API_COMPATIBILITY_LIST) {\n                if (requested.startsWith(aAPI_COMPATIBILITY_LIST)) {\n                    match = true;\n                }\n            }\n            if (!match) {\n                Util.report(\"The requested version \" + requested + \" by your slf4j binding is not compatible with \"\n                                + Arrays.asList(API_COMPATIBILITY_LIST).toString());\n                Util.report(\"See \" + VERSION_MISMATCH + \" for further details.\");\n            }\n        } catch (java.lang.NoSuchFieldError nsfe) {\n            // given our large user base and SLF4J's commitment to backward\n            // compatibility, we cannot cry here. Only for implementations\n            // which willingly declare a REQUESTED_API_VERSION field do we\n            // emit compatibility warnings.\n        } catch (Throwable e) {\n            // we should never reach here\n            Util.report(\"Unexpected problem occured during version sanity check\", e);\n        }\n    }\n\n    // We need to use the name of the StaticLoggerBinder class, but we can't reference\n    // the class itself.\n    private static String STATIC_LOGGER_BINDER_PATH = \"org/slf4j/impl/StaticLoggerBinder.class\";\n\n    static Set<URL> findPossibleStaticLoggerBinderPathSet() {\n        // use Set instead of list in order to deal with bug #138\n        // LinkedHashSet appropriate here because it preserves insertion order during iteration\n        Set<URL> staticLoggerBinderPathSet = new LinkedHashSet<URL>();\n        try {\n            ClassLoader loggerFactoryClassLoader = LoggerFactory.class.getClassLoader();\n            Enumeration<URL> paths;\n            if (loggerFactoryClassLoader == null) {\n                paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);\n            } else {\n                paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);\n            }\n            while (paths.hasMoreElements()) {\n                URL path = paths.nextElement();\n                staticLoggerBinderPathSet.add(path);\n            }\n        } catch (IOException ioe) {\n            Util.report(\"Error getting resources from path\", ioe);\n        }\n        return staticLoggerBinderPathSet;\n    }\n\n    private static boolean isAmbiguousStaticLoggerBinderPathSet(Set<URL> staticLoggerBinderPathSet) {\n        return staticLoggerBinderPathSet.size() > 1;\n    }\n\n    /**\n     * Prints a warning message on the console if multiple bindings were found on the class path.\n     * No reporting is done otherwise.\n     *\n     */\n    private static void reportMultipleBindingAmbiguity(Set<URL> staticLoggerBinderPathSet) {\n        if (isAndroid()) {\n            // skip check under android, see also http://jira.qos.ch/browse/SLF4J-328\n            return;\n        }\n\n        if (isAmbiguousStaticLoggerBinderPathSet(staticLoggerBinderPathSet)) {\n            Util.report(\"Class path contains multiple SLF4J bindings.\");\n            for (URL path : staticLoggerBinderPathSet) {\n                Util.report(\"Found binding in [\" + path + \"]\");\n            }\n            Util.report(\"See \" + MULTIPLE_BINDINGS_URL + \" for an explanation.\");\n        }\n    }\n\n    private static boolean isAndroid() {\n        String vendor = Util.safeGetSystemProperty(JAVA_VENDOR_PROPERTY);\n        if (vendor == null)\n            return false;\n        return vendor.toLowerCase().contains(\"android\");\n    }\n\n    private static void reportActualBinding(Set<URL> staticLoggerBinderPathSet) {\n        if (isAmbiguousStaticLoggerBinderPathSet(staticLoggerBinderPathSet)) {\n            Util.report(\"Actual binding is of type [\" + StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr() + \"]\");\n        }\n    }\n\n    /**\n     * Return a logger named according to the name parameter using the statically\n     * bound {@link ILoggerFactory} instance.\n     *\n     * @param name The name of the logger.\n     * @return logger\n     */\n    public static Logger getLogger(String name) {\n        ILoggerFactory iLoggerFactory = getILoggerFactory();\n        return iLoggerFactory.getLogger(name);\n    }\n\n    /**\n     * Return a logger named corresponding to the class passed as parameter, using\n     * the statically bound {@link ILoggerFactory} instance.\n     *\n     * <p>In case the the <code>clazz<\/code> parameter differs from the name of\n     * the caller as computed internally by SLF4J, a logger name mismatch warning will be \n     * printed but only if the <code>slf4j.detectLoggerNameMismatch<\/code> system property is \n     * set to true. By default, this property is not set and no warnings will be printed\n     * even in case of a logger name mismatch.\n     * \n     * @param clazz the returned logger will be named after clazz\n     * @return logger\n     *\n     *\n     * @see <a href=\"http://www.slf4j.org/codes.html#loggerNameMismatch\">Detected logger name mismatch<\/a> \n     */\n    public static Logger getLogger(Class<?> clazz) {\n        Logger logger = getLogger(clazz.getName());\n        if (DETECT_LOGGER_NAME_MISMATCH) {\n            Class<?> autoComputedCallingClass = Util.getCallingClass();\n            if (autoComputedCallingClass != null && nonMatchingClasses(clazz, autoComputedCallingClass)) {\n                Util.report(String.format(\"Detected logger name mismatch. Given name: \\\"%s\\\"; computed name: \\\"%s\\\".\", logger.getName(),\n                                autoComputedCallingClass.getName()));\n                Util.report(\"See \" + LOGGER_NAME_MISMATCH_URL + \" for an explanation\");\n            }\n        }\n        return logger;\n    }\n\n    private static boolean nonMatchingClasses(Class<?> clazz, Class<?> autoComputedCallingClass) {\n        return !autoComputedCallingClass.isAssignableFrom(clazz);\n    }\n\n    /**\n     * Return the {@link ILoggerFactory} instance in use.\n     * <p/>\n     * <p/>\n     * ILoggerFactory instance is bound with this class at compile time.\n     *\n     * @return the ILoggerFactory instance in use\n     */\n    public static ILoggerFactory getILoggerFactory() {\n        if (INITIALIZATION_STATE == UNINITIALIZED) {\n            synchronized (LoggerFactory.class) {\n                if (INITIALIZATION_STATE == UNINITIALIZED) {\n                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;\n                    performInitialization();\n                }\n            }\n        }\n        switch (INITIALIZATION_STATE) {\n        case SUCCESSFUL_INITIALIZATION:\n            return StaticLoggerBinder.getSingleton().getLoggerFactory();\n        case NOP_FALLBACK_INITIALIZATION:\n            return NOP_FALLBACK_FACTORY;\n        case FAILED_INITIALIZATION:\n            throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);\n        case ONGOING_INITIALIZATION:\n            // support re-entrant behavior.\n            // See also http://jira.qos.ch/browse/SLF4J-97\n            return SUBST_FACTORY;\n        }\n        throw new IllegalStateException(\"Unreachable code\");\n    }\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.slf4j.helpers.NOPLoggerFactory;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.helpers.SubstituteLoggerFactory;\nimport org.slf4j.helpers.Util;\nimport org.slf4j.impl.StaticLoggerBinder;\n\n/**\n * The <code>LoggerFactory<\/code> is a utility class producing Loggers for\n * various logging APIs, most notably for log4j, logback and JDK 1.4 logging.\n * Other implementations such as {@link org.slf4j.impl.NOPLogger NOPLogger} and\n * {@link org.slf4j.impl.SimpleLogger SimpleLogger} are also supported.\n * <p/>\n * <p/>\n * <code>LoggerFactory<\/code> is essentially a wrapper around an\n * {@link ILoggerFactory} instance bound with <code>LoggerFactory<\/code> at\n * compile time.\n * <p/>\n * <p/>\n * Please note that all methods in <code>LoggerFactory<\/code> are static.\n *\n *\n * @author Alexander Dorokhine\n * @author Robert Elliot\n * @author Ceki G&uuml;lc&uuml;\n *\n */\npublic final class LoggerFactory {\n\n    static final String CODES_PREFIX = \"http://www.slf4j.org/codes.html\";\n\n    static final String NO_STATICLOGGERBINDER_URL = CODES_PREFIX + \"#StaticLoggerBinder\";\n    static final String MULTIPLE_BINDINGS_URL = CODES_PREFIX + \"#multiple_bindings\";\n    static final String NULL_LF_URL = CODES_PREFIX + \"#null_LF\";\n    static final String VERSION_MISMATCH = CODES_PREFIX + \"#version_mismatch\";\n    static final String SUBSTITUTE_LOGGER_URL = CODES_PREFIX + \"#substituteLogger\";\n    static final String LOGGER_NAME_MISMATCH_URL = CODES_PREFIX + \"#loggerNameMismatch\";\n\n    static final String UNSUCCESSFUL_INIT_URL = CODES_PREFIX + \"#unsuccessfulInit\";\n    static final String UNSUCCESSFUL_INIT_MSG = \"org.slf4j.LoggerFactory could not be successfully initialized. See also \" + UNSUCCESSFUL_INIT_URL;\n\n    static final int UNINITIALIZED = 0;\n    static final int ONGOING_INITIALIZATION = 1;\n    static final int FAILED_INITIALIZATION = 2;\n    static final int SUCCESSFUL_INITIALIZATION = 3;\n    static final int NOP_FALLBACK_INITIALIZATION = 4;\n\n    static int INITIALIZATION_STATE = UNINITIALIZED;\n    static SubstituteLoggerFactory TEMP_FACTORY = new SubstituteLoggerFactory();\n    static NOPLoggerFactory NOP_FALLBACK_FACTORY = new NOPLoggerFactory();\n\n    // Support for detecting mismatched logger names.\n    static final String DETECT_LOGGER_NAME_MISMATCH_PROPERTY = \"slf4j.detectLoggerNameMismatch\";\n    static final String JAVA_VENDOR_PROPERTY = \"java.vendor.url\";\n        \n    static boolean DETECT_LOGGER_NAME_MISMATCH = Util.safeGetBooleanSystemProperty(DETECT_LOGGER_NAME_MISMATCH_PROPERTY);\n\n    /**\n     * It is LoggerFactory's responsibility to track version changes and manage\n     * the compatibility list.\n     * <p/>\n     * <p/>\n     * It is assumed that all versions in the 1.6 are mutually compatible.\n     */\n    static private final String[] API_COMPATIBILITY_LIST = new String[] { \"1.6\", \"1.7\" };\n\n    // private constructor prevents instantiation\n    private LoggerFactory() {\n    }\n\n    /**\n     * Force LoggerFactory to consider itself uninitialized.\n     * <p/>\n     * <p/>\n     * This method is intended to be called by classes (in the same package) for\n     * testing purposes. This method is internal. It can be modified, renamed or\n     * removed at any time without notice.\n     * <p/>\n     * <p/>\n     * You are strongly discouraged from calling this method in production code.\n     */\n    static void reset() {\n        INITIALIZATION_STATE = UNINITIALIZED;\n        TEMP_FACTORY = new SubstituteLoggerFactory();\n    }\n\n    private final static void performInitialization() {\n        bind();\n        if (INITIALIZATION_STATE == SUCCESSFUL_INITIALIZATION) {\n            versionSanityCheck();\n        }\n    }\n\n    private static boolean messageContainsOrgSlf4jImplStaticLoggerBinder(String msg) {\n        if (msg == null)\n            return false;\n        if (msg.contains(\"org/slf4j/impl/StaticLoggerBinder\"))\n            return true;\n        if (msg.contains(\"org.slf4j.impl.StaticLoggerBinder\"))\n            return true;\n        return false;\n    }\n\n    private final static void bind() {\n        try {\n            Set<URL> staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();\n            reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);\n            // the next line does the binding\n            StaticLoggerBinder.getSingleton();\n            INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;\n            reportActualBinding(staticLoggerBinderPathSet);\n            fixSubstitutedLoggers();\n        } catch (NoClassDefFoundError ncde) {\n            String msg = ncde.getMessage();\n            if (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) {\n                INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;\n                Util.report(\"Failed to load class \\\"org.slf4j.impl.StaticLoggerBinder\\\".\");\n                Util.report(\"Defaulting to no-operation (NOP) logger implementation\");\n                Util.report(\"See \" + NO_STATICLOGGERBINDER_URL + \" for further details.\");\n            } else {\n                failedBinding(ncde);\n                throw ncde;\n            }\n        } catch (java.lang.NoSuchMethodError nsme) {\n            String msg = nsme.getMessage();\n            if (msg != null && msg.contains(\"org.slf4j.impl.StaticLoggerBinder.getSingleton()\")) {\n                INITIALIZATION_STATE = FAILED_INITIALIZATION;\n                Util.report(\"slf4j-api 1.6.x (or later) is incompatible with this binding.\");\n                Util.report(\"Your binding is version 1.5.5 or earlier.\");\n                Util.report(\"Upgrade your binding to version 1.6.x.\");\n            }\n            throw nsme;\n        } catch (Exception e) {\n            failedBinding(e);\n            throw new IllegalStateException(\"Unexpected initialization failure\", e);\n        }\n    }\n\n    static void failedBinding(Throwable t) {\n        INITIALIZATION_STATE = FAILED_INITIALIZATION;\n        Util.report(\"Failed to instantiate SLF4J LoggerFactory\", t);\n    }\n\n    private final static void fixSubstitutedLoggers() {\n        List<SubstituteLogger> loggers = TEMP_FACTORY.getLoggers();\n\n        if (loggers.isEmpty()) {\n            return;\n        }\n\n        Util.report(\"The following set of substitute loggers may have been accessed\");\n        Util.report(\"during the initialization phase. Logging calls during this\");\n        Util.report(\"phase were not honored. However, subsequent logging calls to these\");\n        Util.report(\"loggers will work as normally expected.\");\n        Util.report(\"See also \" + SUBSTITUTE_LOGGER_URL);\n        for (SubstituteLogger subLogger : loggers) {\n            subLogger.setDelegate(getLogger(subLogger.getName()));\n            Util.report(subLogger.getName());\n        }\n\n        TEMP_FACTORY.clear();\n    }\n\n    private final static void versionSanityCheck() {\n        try {\n            String requested = StaticLoggerBinder.REQUESTED_API_VERSION;\n\n            boolean match = false;\n            for (String aAPI_COMPATIBILITY_LIST : API_COMPATIBILITY_LIST) {\n                if (requested.startsWith(aAPI_COMPATIBILITY_LIST)) {\n                    match = true;\n                }\n            }\n            if (!match) {\n                Util.report(\"The requested version \" + requested + \" by your slf4j binding is not compatible with \"\n                                + Arrays.asList(API_COMPATIBILITY_LIST).toString());\n                Util.report(\"See \" + VERSION_MISMATCH + \" for further details.\");\n            }\n        } catch (java.lang.NoSuchFieldError nsfe) {\n            // given our large user base and SLF4J's commitment to backward\n            // compatibility, we cannot cry here. Only for implementations\n            // which willingly declare a REQUESTED_API_VERSION field do we\n            // emit compatibility warnings.\n        } catch (Throwable e) {\n            // we should never reach here\n            Util.report(\"Unexpected problem occured during version sanity check\", e);\n        }\n    }\n\n    // We need to use the name of the StaticLoggerBinder class, but we can't reference\n    // the class itself.\n    private static String STATIC_LOGGER_BINDER_PATH = \"org/slf4j/impl/StaticLoggerBinder.class\";\n\n    static Set<URL> findPossibleStaticLoggerBinderPathSet() {\n        // use Set instead of list in order to deal with bug #138\n        // LinkedHashSet appropriate here because it preserves insertion order during iteration\n        Set<URL> staticLoggerBinderPathSet = new LinkedHashSet<URL>();\n        try {\n            ClassLoader loggerFactoryClassLoader = LoggerFactory.class.getClassLoader();\n            Enumeration<URL> paths;\n            if (loggerFactoryClassLoader == null) {\n                paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);\n            } else {\n                paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);\n            }\n            while (paths.hasMoreElements()) {\n                URL path = paths.nextElement();\n                staticLoggerBinderPathSet.add(path);\n            }\n        } catch (IOException ioe) {\n            Util.report(\"Error getting resources from path\", ioe);\n        }\n        return staticLoggerBinderPathSet;\n    }\n\n    private static boolean isAmbiguousStaticLoggerBinderPathSet(Set<URL> staticLoggerBinderPathSet) {\n        return staticLoggerBinderPathSet.size() > 1;\n    }\n\n    /**\n     * Prints a warning message on the console if multiple bindings were found on the class path.\n     * No reporting is done otherwise.\n     *\n     */\n    private static void reportMultipleBindingAmbiguity(Set<URL> staticLoggerBinderPathSet) {\n        if(isAndroid()) {\n            // skip check under android, see also http://jira.qos.ch/browse/SLF4J-328\n            return;\n        }\n        \n        if (isAmbiguousStaticLoggerBinderPathSet(staticLoggerBinderPathSet)) {\n            Util.report(\"Class path contains multiple SLF4J bindings.\");\n            for (URL path : staticLoggerBinderPathSet) {\n                Util.report(\"Found binding in [\" + path + \"]\");\n            }\n            Util.report(\"See \" + MULTIPLE_BINDINGS_URL + \" for an explanation.\");\n        }\n    }\n\n    private static boolean isAndroid() {\n        String vendor = Util.safeGetSystemProperty(JAVA_VENDOR_PROPERTY);\n        if(vendor == null)\n            return false;\n        return vendor.toLowerCase().contains(\"android\");\n    }\n\n    private static void reportActualBinding(Set<URL> staticLoggerBinderPathSet) {\n        if (isAmbiguousStaticLoggerBinderPathSet(staticLoggerBinderPathSet)) {\n            Util.report(\"Actual binding is of type [\" + StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr() + \"]\");\n        }\n    }\n\n    /**\n     * Return a logger named according to the name parameter using the statically\n     * bound {@link ILoggerFactory} instance.\n     *\n     * @param name The name of the logger.\n     * @return logger\n     */\n    public static Logger getLogger(String name) {\n        ILoggerFactory iLoggerFactory = getILoggerFactory();\n        return iLoggerFactory.getLogger(name);\n    }\n\n    /**\n     * Return a logger named corresponding to the class passed as parameter, using\n     * the statically bound {@link ILoggerFactory} instance.\n     *\n     * <p>In case the the <code>clazz<\/code> parameter differs from the name of\n     * the caller as computed internally by SLF4J, a logger name mismatch warning will be \n     * printed but only if the <code>slf4j.detectLoggerNameMismatch<\/code> system property is \n     * set to true. By default, this property is not set and no warnings will be printed\n     * even in case of a logger name mismatch.\n     * \n     * @param clazz the returned logger will be named after clazz\n     * @return logger\n     *\n     *\n     * @see <a href=\"http://www.slf4j.org/codes.html#loggerNameMismatch\">Detected logger name mismatch<\/a> \n     */\n    public static Logger getLogger(Class<?> clazz) {\n        Logger logger = getLogger(clazz.getName());\n        if (DETECT_LOGGER_NAME_MISMATCH) {\n            Class<?> autoComputedCallingClass = Util.getCallingClass();\n            if (autoComputedCallingClass != null && nonMatchingClasses(clazz, autoComputedCallingClass)) {\n                Util.report(String.format(\"Detected logger name mismatch. Given name: \\\"%s\\\"; computed name: \\\"%s\\\".\", logger.getName(),\n                                autoComputedCallingClass.getName()));\n                Util.report(\"See \" + LOGGER_NAME_MISMATCH_URL + \" for an explanation\");\n            }\n        }\n        return logger;\n    }\n\n    private static boolean nonMatchingClasses(Class<?> clazz, Class<?> autoComputedCallingClass) {\n        return !autoComputedCallingClass.isAssignableFrom(clazz);\n    }\n\n    /**\n     * Return the {@link ILoggerFactory} instance in use.\n     * <p/>\n     * <p/>\n     * ILoggerFactory instance is bound with this class at compile time.\n     *\n     * @return the ILoggerFactory instance in use\n     */\n    public static ILoggerFactory getILoggerFactory() {\n        if (INITIALIZATION_STATE == UNINITIALIZED) {\n            synchronized (LoggerFactory.class) {\n                if (INITIALIZATION_STATE == UNINITIALIZED) {\n                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;\n                    performInitialization();\n                }\n            }\n        }\n        switch (INITIALIZATION_STATE) {\n        case SUCCESSFUL_INITIALIZATION:\n            return StaticLoggerBinder.getSingleton().getLoggerFactory();\n        case NOP_FALLBACK_INITIALIZATION:\n            return NOP_FALLBACK_FACTORY;\n        case FAILED_INITIALIZATION:\n            throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);\n        case ONGOING_INITIALIZATION:\n            // support re-entrant behavior.\n            // See also http://jira.qos.ch/browse/SLF4J-97\n            return TEMP_FACTORY;\n        }\n        throw new IllegalStateException(\"Unreachable code\");\n    }\n}\n","lineNo":200}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport java.text.MessageFormat;\nimport java.util.HashMap;\nimport java.util.Map;\n\n// contributors: lizongbo: proposed special treatment of array parameter values\n// Joern Huxhorn: pointed out double[] omission, suggested deep array copy\n/**\n * Formats messages according to very simple substitution rules. Substitutions\n * can be made 1, 2 or more arguments.\n * \n * <p>\n * For example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Hi {}.&quot;, &quot;there&quot;)\n * <\/pre>\n * \n * will return the string \"Hi there.\".\n * <p>\n * The {} pair is called the <em>formatting anchor<\/em>. It serves to designate\n * the location where arguments need to be substituted within the message\n * pattern.\n * <p>\n * In case your message contains the '{' or the '}' character, you do not have\n * to do anything special unless the '}' character immediately follows '{'. For\n * example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Set {1,2,3} is not equal to {}.&quot;, &quot;1,2&quot;);\n * <\/pre>\n * \n * will return the string \"Set {1,2,3} is not equal to 1,2.\".\n * \n * <p>\n * If for whatever reason you need to place the string \"{}\" in the message\n * without its <em>formatting anchor<\/em> meaning, then you need to escape the\n * '{' character with '\\', that is the backslash character. Only the '{'\n * character should be escaped. There is no need to escape the '}' character.\n * For example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Set \\\\{} is not equal to {}.&quot;, &quot;1,2&quot;);\n * <\/pre>\n * \n * will return the string \"Set {} is not equal to 1,2.\".\n * \n * <p>\n * The escaping behavior just described can be overridden by escaping the escape\n * character '\\'. Calling\n * \n * <pre>\n * MessageFormatter.format(&quot;File name is C:\\\\\\\\{}.&quot;, &quot;file.zip&quot;);\n * <\/pre>\n * \n * will return the string \"File name is C:\\file.zip\".\n * \n * <p>\n * The formatting conventions are different than those of {@link MessageFormat}\n * which ships with the Java platform. This is justified by the fact that\n * SLF4J's implementation is 10 times faster than that of {@link MessageFormat}.\n * This local performance difference is both measurable and significant in the\n * larger context of the complete logging processing chain.\n * \n * <p>\n * See also {@link #format(String, Object)},\n * {@link #format(String, Object, Object)} and\n * {@link #arrayFormat(String, Object[])} methods for more details.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Joern Huxhorn\n */\nfinal public class MessageFormatter {\n    static final char DELIM_START = '{';\n    static final char DELIM_STOP = '}';\n    static final String DELIM_STR = \"{}\";\n    private static final char ESCAPE_CHAR = '\\\\';\n\n    /**\n     * Performs single argument substitution for the 'messagePattern' passed as\n     * parameter.\n     * <p>\n     * For example,\n     * \n     * <pre>\n     * MessageFormatter.format(&quot;Hi {}.&quot;, &quot;there&quot;);\n     * <\/pre>\n     * \n     * will return the string \"Hi there.\".\n     * <p>\n     * \n     * @param messagePattern\n     *          The message pattern which will be parsed and formatted\n     * @param argument\n     *          The argument to be substituted in place of the formatting anchor\n     * @return The formatted message\n     */\n    final public static FormattingTuple format(String messagePattern, Object arg) {\n        return arrayFormat(messagePattern, new Object[] { arg });\n    }\n\n    /**\n     * \n     * Performs a two argument substitution for the 'messagePattern' passed as\n     * parameter.\n     * <p>\n     * For example,\n     * \n     * <pre>\n     * MessageFormatter.format(&quot;Hi {}. My name is {}.&quot;, &quot;Alice&quot;, &quot;Bob&quot;);\n     * <\/pre>\n     * \n     * will return the string \"Hi Alice. My name is Bob.\".\n     * \n     * @param messagePattern\n     *          The message pattern which will be parsed and formatted\n     * @param arg1\n     *          The argument to be substituted in place of the first formatting\n     *          anchor\n     * @param arg2\n     *          The argument to be substituted in place of the second formatting\n     *          anchor\n     * @return The formatted message\n     */\n    final public static FormattingTuple format(final String messagePattern, Object arg1, Object arg2) {\n        return arrayFormat(messagePattern, new Object[] { arg1, arg2 });\n    }\n\n    \n    static final Throwable getThrowableCandidate(Object[] argArray) {\n        if (argArray == null || argArray.length == 0) {\n            return null;\n        }\n\n        final Object lastEntry = argArray[argArray.length - 1];\n        if (lastEntry instanceof Throwable) {\n            return (Throwable) lastEntry;\n        }\n        return null;\n    }\n\n    final public static FormattingTuple arrayFormat(final String messagePattern, final Object[] argArray) {\n        Throwable throwableCandidate = getThrowableCandidate(argArray);\n        Object[] args = argArray;\n        if(throwableCandidate != null) {\n            args = trimmedCopy(argArray);\n        }\n        return arrayFormat(messagePattern, args, throwableCandidate);\n    }\n\n    private static Object[] trimmedCopy(Object[] argArray) {\n        if (argArray == null || argArray.length == 0) {\n            throw new IllegalStateException(\"non-sensical empty or null argument array\");\n        }\n        final int trimemdLen = argArray.length - 1;\n        Object[] trimmed = new Object[trimemdLen];\n        System.arraycopy(argArray, 0, trimmed, 0, trimemdLen);\n        return trimmed;\n    }\n\n\n    final public static FormattingTuple arrayFormat(final String messagePattern, final Object[] argArray, Throwable throwable) {\n\n        if (messagePattern == null) {\n            return new FormattingTuple(null, argArray, throwable);\n        }\n\n        if (argArray == null) {\n            return new FormattingTuple(messagePattern);\n        }\n\n        int i = 0;\n        int j;\n        // use string builder for better multicore performance\n        StringBuilder sbuf = new StringBuilder(messagePattern.length() + 50);\n\n        int L;\n        for (L = 0; L < argArray.length; L++) {\n\n            j = messagePattern.indexOf(DELIM_STR, i);\n\n            if (j == -1) {\n                // no more variables\n                if (i == 0) { // this is a simple string\n                    return new FormattingTuple(messagePattern, argArray, throwable);\n                } else { // add the tail string which contains no variables and return\n                    // the result.\n                    sbuf.append(messagePattern, i, messagePattern.length());\n                    return new FormattingTuple(sbuf.toString(), argArray, throwable);\n                }\n            } else {\n                if (isEscapedDelimeter(messagePattern, j)) {\n                    if (!isDoubleEscaped(messagePattern, j)) {\n                        L--; // DELIM_START was escaped, thus should not be incremented\n                        sbuf.append(messagePattern, i, j - 1);\n                        sbuf.append(DELIM_START);\n                        i = j + 1;\n                    } else {\n                        // The escape character preceding the delimiter start is\n                        // itself escaped: \"abc x:\\\\{}\"\n                        // we have to consume one backward slash\n                        sbuf.append(messagePattern, i, j - 1);\n                        deeplyAppendParameter(sbuf, argArray[L], new HashMap<Object[], Object>());\n                        i = j + 2;\n                    }\n                } else {\n                    // normal case\n                    sbuf.append(messagePattern, i, j);\n                    deeplyAppendParameter(sbuf, argArray[L], new HashMap<Object[], Object>());\n                    i = j + 2;\n                }\n            }\n        }\n        // append the characters following the last {} pair.\n        sbuf.append(messagePattern, i, messagePattern.length());\n        return new FormattingTuple(sbuf.toString(), argArray, throwable);\n    }\n\n    final static boolean isEscapedDelimeter(String messagePattern, int delimeterStartIndex) {\n\n        if (delimeterStartIndex == 0) {\n            return false;\n        }\n        char potentialEscape = messagePattern.charAt(delimeterStartIndex - 1);\n        if (potentialEscape == ESCAPE_CHAR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    final static boolean isDoubleEscaped(String messagePattern, int delimeterStartIndex) {\n        if (delimeterStartIndex >= 2 && messagePattern.charAt(delimeterStartIndex - 2) == ESCAPE_CHAR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // special treatment of array values was suggested by 'lizongbo'\n    private static void deeplyAppendParameter(StringBuilder sbuf, Object o, Map<Object[], Object> seenMap) {\n        if (o == null) {\n            sbuf.append(\"null\");\n            return;\n        }\n        if (!o.getClass().isArray()) {\n            safeObjectAppend(sbuf, o);\n        } else {\n            // check for primitive array types because they\n            // unfortunately cannot be cast to Object[]\n            if (o instanceof boolean[]) {\n                booleanArrayAppend(sbuf, (boolean[]) o);\n            } else if (o instanceof byte[]) {\n                byteArrayAppend(sbuf, (byte[]) o);\n            } else if (o instanceof char[]) {\n                charArrayAppend(sbuf, (char[]) o);\n            } else if (o instanceof short[]) {\n                shortArrayAppend(sbuf, (short[]) o);\n            } else if (o instanceof int[]) {\n                intArrayAppend(sbuf, (int[]) o);\n            } else if (o instanceof long[]) {\n                longArrayAppend(sbuf, (long[]) o);\n            } else if (o instanceof float[]) {\n                floatArrayAppend(sbuf, (float[]) o);\n            } else if (o instanceof double[]) {\n                doubleArrayAppend(sbuf, (double[]) o);\n            } else {\n                objectArrayAppend(sbuf, (Object[]) o, seenMap);\n            }\n        }\n    }\n\n    private static void safeObjectAppend(StringBuilder sbuf, Object o) {\n        try {\n            String oAsString = o.toString();\n            sbuf.append(oAsString);\n        } catch (Throwable t) {\n            Util.report(\"SLF4J: Failed toString() invocation on an object of type [\" + o.getClass().getName() + \"]\", t);\n            sbuf.append(\"[FAILED toString()]\");\n        }\n\n    }\n\n    private static void objectArrayAppend(StringBuilder sbuf, Object[] a, Map<Object[], Object> seenMap) {\n        sbuf.append('[');\n        if (!seenMap.containsKey(a)) {\n            seenMap.put(a, null);\n            final int len = a.length;\n            for (int i = 0; i < len; i++) {\n                deeplyAppendParameter(sbuf, a[i], seenMap);\n                if (i != len - 1)\n                    sbuf.append(\", \");\n            }\n            // allow repeats in siblings\n            seenMap.remove(a);\n        } else {\n            sbuf.append(\"...\");\n        }\n        sbuf.append(']');\n    }\n\n    private static void booleanArrayAppend(StringBuilder sbuf, boolean[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void byteArrayAppend(StringBuilder sbuf, byte[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void charArrayAppend(StringBuilder sbuf, char[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void shortArrayAppend(StringBuilder sbuf, short[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void intArrayAppend(StringBuilder sbuf, int[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void longArrayAppend(StringBuilder sbuf, long[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void floatArrayAppend(StringBuilder sbuf, float[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void doubleArrayAppend(StringBuilder sbuf, double[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport java.text.MessageFormat;\nimport java.util.HashMap;\nimport java.util.Map;\n\n// contributors: lizongbo: proposed special treatment of array parameter values\n// Joern Huxhorn: pointed out double[] omission, suggested deep array copy\n/**\n * Formats messages according to very simple substitution rules. Substitutions\n * can be made 1, 2 or more arguments.\n * \n * <p>\n * For example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Hi {}.&quot;, &quot;there&quot;)\n * <\/pre>\n * \n * will return the string \"Hi there.\".\n * <p>\n * The {} pair is called the <em>formatting anchor<\/em>. It serves to designate\n * the location where arguments need to be substituted within the message\n * pattern.\n * <p>\n * In case your message contains the '{' or the '}' character, you do not have\n * to do anything special unless the '}' character immediately follows '{'. For\n * example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Set {1,2,3} is not equal to {}.&quot;, &quot;1,2&quot;);\n * <\/pre>\n * \n * will return the string \"Set {1,2,3} is not equal to 1,2.\".\n * \n * <p>\n * If for whatever reason you need to place the string \"{}\" in the message\n * without its <em>formatting anchor<\/em> meaning, then you need to escape the\n * '{' character with '\\', that is the backslash character. Only the '{'\n * character should be escaped. There is no need to escape the '}' character.\n * For example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Set \\\\{} is not equal to {}.&quot;, &quot;1,2&quot;);\n * <\/pre>\n * \n * will return the string \"Set {} is not equal to 1,2.\".\n * \n * <p>\n * The escaping behavior just described can be overridden by escaping the escape\n * character '\\'. Calling\n * \n * <pre>\n * MessageFormatter.format(&quot;File name is C:\\\\\\\\{}.&quot;, &quot;file.zip&quot;);\n * <\/pre>\n * \n * will return the string \"File name is C:\\file.zip\".\n * \n * <p>\n * The formatting conventions are different than those of {@link MessageFormat}\n * which ships with the Java platform. This is justified by the fact that\n * SLF4J's implementation is 10 times faster than that of {@link MessageFormat}.\n * This local performance difference is both measurable and significant in the\n * larger context of the complete logging processing chain.\n * \n * <p>\n * See also {@link #format(String, Object)},\n * {@link #format(String, Object, Object)} and\n * {@link #arrayFormat(String, Object[])} methods for more details.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Joern Huxhorn\n */\nfinal public class MessageFormatter {\n    static final char DELIM_START = '{';\n    static final char DELIM_STOP = '}';\n    static final String DELIM_STR = \"{}\";\n    private static final char ESCAPE_CHAR = '\\\\';\n\n    /**\n     * Performs single argument substitution for the 'messagePattern' passed as\n     * parameter.\n     * <p>\n     * For example,\n     * \n     * <pre>\n     * MessageFormatter.format(&quot;Hi {}.&quot;, &quot;there&quot;);\n     * <\/pre>\n     * \n     * will return the string \"Hi there.\".\n     * <p>\n     * \n     * @param messagePattern\n     *          The message pattern which will be parsed and formatted\n     * @param argument\n     *          The argument to be substituted in place of the formatting anchor\n     * @return The formatted message\n     */\n    final public static FormattingTuple format(String messagePattern, Object arg) {\n        return arrayFormat(messagePattern, new Object[] { arg });\n    }\n\n    /**\n     * \n     * Performs a two argument substitution for the 'messagePattern' passed as\n     * parameter.\n     * <p>\n     * For example,\n     * \n     * <pre>\n     * MessageFormatter.format(&quot;Hi {}. My name is {}.&quot;, &quot;Alice&quot;, &quot;Bob&quot;);\n     * <\/pre>\n     * \n     * will return the string \"Hi Alice. My name is Bob.\".\n     * \n     * @param messagePattern\n     *          The message pattern which will be parsed and formatted\n     * @param arg1\n     *          The argument to be substituted in place of the first formatting\n     *          anchor\n     * @param arg2\n     *          The argument to be substituted in place of the second formatting\n     *          anchor\n     * @return The formatted message\n     */\n    final public static FormattingTuple format(final String messagePattern, Object arg1, Object arg2) {\n        return arrayFormat(messagePattern, new Object[] { arg1, arg2 });\n    }\n\n    static final Throwable getThrowableCandidate(Object[] argArray) {\n        if (argArray == null || argArray.length == 0) {\n            return null;\n        }\n\n        final Object lastEntry = argArray[argArray.length - 1];\n        if (lastEntry instanceof Throwable) {\n            return (Throwable) lastEntry;\n        }\n        return null;\n    }\n\n    /**\n     * Same principle as the {@link #format(String, Object)} and\n     * {@link #format(String, Object, Object)} methods except that any number of\n     * arguments can be passed in an array.\n     * \n     * @param messagePattern\n     *          The message pattern which will be parsed and formatted\n     * @param argArray\n     *          An array of arguments to be substituted in place of formatting\n     *          anchors\n     * @return The formatted message\n     */\n    final public static FormattingTuple arrayFormat(final String messagePattern, final Object[] argArray) {\n\n        Throwable throwableCandidate = getThrowableCandidate(argArray);\n\n        if (messagePattern == null) {\n            return new FormattingTuple(null, argArray, throwableCandidate);\n        }\n\n        if (argArray == null) {\n            return new FormattingTuple(messagePattern);\n        }\n\n        int i = 0;\n        int j;\n        // use string builder for better multicore performance\n        StringBuilder sbuf = new StringBuilder(messagePattern.length() + 50);\n\n        int L;\n        for (L = 0; L < argArray.length; L++) {\n\n            j = messagePattern.indexOf(DELIM_STR, i);\n\n            if (j == -1) {\n                // no more variables\n                if (i == 0) { // this is a simple string\n                    return new FormattingTuple(messagePattern, argArray, throwableCandidate);\n                } else { // add the tail string which contains no variables and return\n                    // the result.\n                    sbuf.append(messagePattern, i, messagePattern.length());\n                    return new FormattingTuple(sbuf.toString(), argArray, throwableCandidate);\n                }\n            } else {\n                if (isEscapedDelimeter(messagePattern, j)) {\n                    if (!isDoubleEscaped(messagePattern, j)) {\n                        L--; // DELIM_START was escaped, thus should not be incremented\n                        sbuf.append(messagePattern, i, j - 1);\n                        sbuf.append(DELIM_START);\n                        i = j + 1;\n                    } else {\n                        // The escape character preceding the delimiter start is\n                        // itself escaped: \"abc x:\\\\{}\"\n                        // we have to consume one backward slash\n                        sbuf.append(messagePattern, i, j - 1);\n                        deeplyAppendParameter(sbuf, argArray[L], new HashMap<Object[], Object>());\n                        i = j + 2;\n                    }\n                } else {\n                    // normal case\n                    sbuf.append(messagePattern, i, j);\n                    deeplyAppendParameter(sbuf, argArray[L], new HashMap<Object[], Object>());\n                    i = j + 2;\n                }\n            }\n        }\n        // append the characters following the last {} pair.\n        sbuf.append(messagePattern, i, messagePattern.length());\n        if (L < argArray.length - 1) {\n            return new FormattingTuple(sbuf.toString(), argArray, throwableCandidate);\n        } else {\n            return new FormattingTuple(sbuf.toString(), argArray, null);\n        }\n    }\n\n    final static boolean isEscapedDelimeter(String messagePattern, int delimeterStartIndex) {\n\n        if (delimeterStartIndex == 0) {\n            return false;\n        }\n        char potentialEscape = messagePattern.charAt(delimeterStartIndex - 1);\n        if (potentialEscape == ESCAPE_CHAR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    final static boolean isDoubleEscaped(String messagePattern, int delimeterStartIndex) {\n        if (delimeterStartIndex >= 2 && messagePattern.charAt(delimeterStartIndex - 2) == ESCAPE_CHAR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // special treatment of array values was suggested by 'lizongbo'\n    private static void deeplyAppendParameter(StringBuilder sbuf, Object o, Map<Object[], Object> seenMap) {\n        if (o == null) {\n            sbuf.append(\"null\");\n            return;\n        }\n        if (!o.getClass().isArray()) {\n            safeObjectAppend(sbuf, o);\n        } else {\n            // check for primitive array types because they\n            // unfortunately cannot be cast to Object[]\n            if (o instanceof boolean[]) {\n                booleanArrayAppend(sbuf, (boolean[]) o);\n            } else if (o instanceof byte[]) {\n                byteArrayAppend(sbuf, (byte[]) o);\n            } else if (o instanceof char[]) {\n                charArrayAppend(sbuf, (char[]) o);\n            } else if (o instanceof short[]) {\n                shortArrayAppend(sbuf, (short[]) o);\n            } else if (o instanceof int[]) {\n                intArrayAppend(sbuf, (int[]) o);\n            } else if (o instanceof long[]) {\n                longArrayAppend(sbuf, (long[]) o);\n            } else if (o instanceof float[]) {\n                floatArrayAppend(sbuf, (float[]) o);\n            } else if (o instanceof double[]) {\n                doubleArrayAppend(sbuf, (double[]) o);\n            } else {\n                objectArrayAppend(sbuf, (Object[]) o, seenMap);\n            }\n        }\n    }\n\n    private static void safeObjectAppend(StringBuilder sbuf, Object o) {\n        try {\n            String oAsString = o.toString();\n            sbuf.append(oAsString);\n        } catch (Throwable t) {\n            System.err.println(\"SLF4J: Failed toString() invocation on an object of type [\" + o.getClass().getName() + \"]\");\n            t.printStackTrace();\n            sbuf.append(\"[FAILED toString()]\");\n        }\n\n    }\n\n    private static void objectArrayAppend(StringBuilder sbuf, Object[] a, Map<Object[], Object> seenMap) {\n        sbuf.append('[');\n        if (!seenMap.containsKey(a)) {\n            seenMap.put(a, null);\n            final int len = a.length;\n            for (int i = 0; i < len; i++) {\n                deeplyAppendParameter(sbuf, a[i], seenMap);\n                if (i != len - 1)\n                    sbuf.append(\", \");\n            }\n            // allow repeats in siblings\n            seenMap.remove(a);\n        } else {\n            sbuf.append(\"...\");\n        }\n        sbuf.append(']');\n    }\n\n    private static void booleanArrayAppend(StringBuilder sbuf, boolean[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void byteArrayAppend(StringBuilder sbuf, byte[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void charArrayAppend(StringBuilder sbuf, char[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void shortArrayAppend(StringBuilder sbuf, short[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void intArrayAppend(StringBuilder sbuf, int[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void longArrayAppend(StringBuilder sbuf, long[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void floatArrayAppend(StringBuilder sbuf, float[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void doubleArrayAppend(StringBuilder sbuf, double[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n}\n","lineNo":169}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.event.LoggingEventAware;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger, LoggingEventAware {\n\n    private static final long serialVersionUID = -8053026990503422791L;\n\n    transient final java.util.logging.Logger logger;\n\n    // WARN: JDK14LoggerAdapter constructor should have only package access so\n    // that only JDK14LoggerFactory be able to create one.\n    JDK14LoggerAdapter(java.util.logging.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n    }\n\n    /**\n     * Is this logger instance enabled for the FINEST level?\n     * \n     * @return True if this Logger is enabled for level FINEST, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINEST);\n    }\n\n    /**\n     * Log a message object at level FINEST.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINEST.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void trace(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINEST with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the FINE level?\n     * \n     * @return True if this Logger is enabled for level FINE, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    /**\n     * Log a message object at level FINE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINE.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void debug(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the WARNING level?\n     * \n     * @return True if this Logger is enabled for the WARNING level, false\n     *         otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    /**\n     * Log a message object at the WARNING level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARNING according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARNING level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for level SEVERE?\n     * \n     * @return True if this Logger is enabled for level SEVERE, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n\n    /**\n     * Log a message object at the SEVERE level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level SEVERE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void error(String format, Object... arguments) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the SEVERE level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, t);\n        }\n    }\n\n    /**\n     * Log the message at the specified level with the specified throwable if any.\n     * This method creates a LogRecord and fills in caller date before calling\n     * this instance's JDK14 logger.\n     * \n     * See bug report #13 for more details.\n     * \n     * @param level\n     * @param msg\n     * @param t\n     */\n    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n        // millis and thread are filled by the constructor\n        LogRecord record = new LogRecord(level, msg);\n        record.setLoggerName(getName());\n        record.setThrown(t);\n        // Note: parameters in record are not set because SLF4J only \n        // supports a single formatting style\n        fillCallerData(callerFQCN, record);\n        logger.log(record);\n    }\n\n    static String SELF = JDK14LoggerAdapter.class.getName();\n    static String SUPER = MarkerIgnoringBase.class.getName();\n\n    /**\n     * Fill in caller data if possible.\n     * \n     * @param record\n     *          The record to update\n     */\n    final private void fillCallerData(String callerFQCN, LogRecord record) {\n        StackTraceElement[] steArray = new Throwable().getStackTrace();\n\n        int selfIndex = -1;\n        for (int i = 0; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            if (className.equals(callerFQCN) || className.equals(SUPER)) {\n                selfIndex = i;\n                break;\n            }\n        }\n\n        int found = -1;\n        for (int i = selfIndex + 1; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            if (!(className.equals(callerFQCN) || className.equals(SUPER))) {\n                found = i;\n                break;\n            }\n        }\n\n        if (found != -1) {\n            StackTraceElement ste = steArray[found];\n            // setting the class name has the side effect of setting\n            // the needToInferCaller variable to false.\n            record.setSourceClassName(ste.getClassName());\n            record.setSourceMethodName(ste.getMethodName());\n        }\n    }\n\n    public void log(Marker marker, String callerFQCN, int level, String message, Object[] argArray, Throwable t) {\n        Level julLevel = slf4jLevelIntToJULLevel(level);\n        // the logger.isLoggable check avoids the unconditional\n        // construction of location data for disabled log\n        // statements. As of 2008-07-31, callers of this method\n        // do not perform this check. See also\n        // http://jira.qos.ch/browse/SLF4J-81\n        if (logger.isLoggable(julLevel)) {\n            log(callerFQCN, julLevel, message, t);\n        }\n    }\n\n    private Level slf4jLevelIntToJULLevel(int slf4jLevelInt) {\n        Level julLevel;\n        switch (slf4jLevelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            julLevel = Level.FINEST;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            julLevel = Level.FINE;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            julLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            julLevel = Level.WARNING;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            julLevel = Level.SEVERE;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + slf4jLevelInt + \" is not recognized.\");\n        }\n        return julLevel;\n    }\n\n    /**\n     * @since 1.7.15\n     */\n    public void log(LoggingEvent event) {\n        Level julLevel = slf4jLevelIntToJULLevel(event.getLevel().toInt());\n        if (logger.isLoggable(julLevel)) {\n            LogRecord record = eventToRecord(event, julLevel);\n            logger.log(record);\n        }\n    }\n\n    private LogRecord eventToRecord(LoggingEvent event, Level julLevel) {\n        String format = event.getMessage();\n        Object[] arguments = event.getArgumentArray();\n        FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n        if(ft.getThrowable() != null && event.getThrowable() != null) {\n            throw new IllegalArgumentException(\"both last element in argument array and last argument are of type Throwable\");\n        }\n        \n        Throwable t = event.getThrowable();\n        if(ft.getThrowable() != null) {\n            t = ft.getThrowable();\n            throw new IllegalStateException(\"fix above code\");\n        }\n        \n        LogRecord record = new LogRecord(julLevel, ft.getMessage());\n        record.setLoggerName(event.getLoggerName());\n        record.setMillis(event.getTimeStamp());\n        record.setSourceClassName(EventConstants.NA_SUBST);\n        record.setSourceMethodName(EventConstants.NA_SUBST);\n        \n        record.setThrown(t);\n        return record;\n    }\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger {\n\n    private static final long serialVersionUID = -8053026990503422791L;\n\n    transient final java.util.logging.Logger logger;\n\n    // WARN: JDK14LoggerAdapter constructor should have only package access so\n    // that only JDK14LoggerFactory be able to create one.\n    JDK14LoggerAdapter(java.util.logging.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n    }\n\n    /**\n     * Is this logger instance enabled for the FINEST level?\n     * \n     * @return True if this Logger is enabled for level FINEST, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINEST);\n    }\n\n    /**\n     * Log a message object at level FINEST.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINEST.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void trace(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINEST with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the FINE level?\n     * \n     * @return True if this Logger is enabled for level FINE, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    /**\n     * Log a message object at level FINE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINE.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void debug(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the WARNING level?\n     * \n     * @return True if this Logger is enabled for the WARNING level, false\n     *         otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    /**\n     * Log a message object at the WARNING level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARNING according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARNING level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for level SEVERE?\n     * \n     * @return True if this Logger is enabled for level SEVERE, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n\n    /**\n     * Log a message object at the SEVERE level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level SEVERE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void error(String format, Object... arguments) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the SEVERE level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, t);\n        }\n    }\n\n    /**\n     * Log the message at the specified level with the specified throwable if any.\n     * This method creates a LogRecord and fills in caller date before calling\n     * this instance's JDK14 logger.\n     * \n     * See bug report #13 for more details.\n     * \n     * @param level\n     * @param msg\n     * @param t\n     */\n    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n        // millis and thread are filled by the constructor\n        LogRecord record = new LogRecord(level, msg);\n        record.setLoggerName(getName());\n        record.setThrown(t);\n        // Note: parameters in record are not set because SLF4J only \n        // supports a single formatting style\n        fillCallerData(callerFQCN, record);\n        logger.log(record);\n\n    }\n\n    static String SELF = JDK14LoggerAdapter.class.getName();\n    static String SUPER = MarkerIgnoringBase.class.getName();\n\n    /**\n     * Fill in caller data if possible.\n     * \n     * @param record\n     *          The record to update\n     */\n    final private void fillCallerData(String callerFQCN, LogRecord record) {\n        StackTraceElement[] steArray = new Throwable().getStackTrace();\n\n        int selfIndex = -1;\n        for (int i = 0; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            if (className.equals(callerFQCN) || className.equals(SUPER)) {\n                selfIndex = i;\n                break;\n            }\n        }\n\n        int found = -1;\n        for (int i = selfIndex + 1; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            if (!(className.equals(callerFQCN) || className.equals(SUPER))) {\n                found = i;\n                break;\n            }\n        }\n\n        if (found != -1) {\n            StackTraceElement ste = steArray[found];\n            // setting the class name has the side effect of setting\n            // the needToInferCaller variable to false.\n            record.setSourceClassName(ste.getClassName());\n            record.setSourceMethodName(ste.getMethodName());\n        }\n    }\n\n    public void log(Marker marker, String callerFQCN, int level, String message, Object[] argArray, Throwable t) {\n        Level julLevel;\n        switch (level) {\n        case LocationAwareLogger.TRACE_INT:\n            julLevel = Level.FINEST;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            julLevel = Level.FINE;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            julLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            julLevel = Level.WARNING;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            julLevel = Level.SEVERE;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + level + \" is not recognized.\");\n        }\n        // the logger.isLoggable check avoids the unconditional\n        // construction of location data for disabled log\n        // statements. As of 2008-07-31, callers of this method\n        // do not perform this check. See also\n        // http://jira.qos.ch/browse/SLF4J-81\n        if (logger.isLoggable(julLevel)) {\n            log(callerFQCN, julLevel, message, t);\n        }\n    }\n}\n","lineNo":626}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport static org.slf4j.event.EventConstants.NA_SUBST;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Category;\nimport org.apache.log4j.Level;\nimport org.apache.log4j.Priority;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.ThrowableInformation;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.event.LoggingEventAware;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger, LoggingEventAware, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Log a message object at level TRACE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level TRACE.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void trace(String format, Object... arguments) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level TRACE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    /**\n     * Log a message object at level DEBUG.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level DEBUG.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arguments an array of arguments\n     */\n    public void debug(String format, Object... arguments) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level DEBUG with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        logger.log(FQCN, Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        logger.log(FQCN, Level.INFO, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    /**\n     * Log a message object at the WARN level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARN according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARN level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        logger.log(FQCN, Level.WARN, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    /**\n     * Log a message object at the ERROR level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level ERROR according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void error(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the ERROR level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        logger.log(FQCN, Level.ERROR, msg, t);\n    }\n\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] argArray, Throwable t) {\n        Level log4jLevel = toLog4jLevel(level);\n        logger.log(callerFQCN, log4jLevel, msg, t);\n    }\n\n    private Level toLog4jLevel(int level) {\n        Level log4jLevel;\n        switch (level) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + level + \" is not recognized.\");\n        }\n        return log4jLevel;\n    }\n\n    public void log(LoggingEvent event) {\n        Level log4jLevel = toLog4jLevel(event.getLevel().toInt());\n        if (!logger.isEnabledFor(log4jLevel))\n            return;\n\n        org.apache.log4j.spi.LoggingEvent log4jevent = toLog4jEvent(event, log4jLevel);\n        logger.callAppenders(log4jevent);\n\n    }\n\n    private org.apache.log4j.spi.LoggingEvent toLog4jEvent(LoggingEvent event, Level log4jLevel) {\n\n        FormattingTuple ft = MessageFormatter.format(event.getMessage(), event.getArgumentArray(), event.getThrowable());\n\n        LocationInfo locationInfo = new LocationInfo(NA_SUBST, NA_SUBST, NA_SUBST, \"0\");\n\n        ThrowableInformation ti = null;\n        Throwable t = ft.getThrowable();\n        if (t != null)\n            ti = new ThrowableInformation(t);\n\n        org.apache.log4j.spi.LoggingEvent log4jEvent = new org.apache.log4j.spi.LoggingEvent(FQCN, logger, event.getTimeStamp(), log4jLevel, ft.getMessage(),\n                        event.getThreadName(), ti, null, locationInfo, null);\n\n        return log4jEvent;\n    }\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Level;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Log a message object at level TRACE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level TRACE.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void trace(String format, Object... arguments) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level TRACE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    /**\n     * Log a message object at level DEBUG.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level DEBUG.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arguments an array of arguments\n     */\n    public void debug(String format, Object... arguments) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level DEBUG with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        logger.log(FQCN, Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        logger.log(FQCN, Level.INFO, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    /**\n     * Log a message object at the WARN level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARN according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARN level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        logger.log(FQCN, Level.WARN, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    /**\n     * Log a message object at the ERROR level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level ERROR according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void error(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the ERROR level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        logger.log(FQCN, Level.ERROR, msg, t);\n    }\n\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] argArray, Throwable t) {\n        Level log4jLevel;\n        switch (level) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + level + \" is not recognized.\");\n        }\n        logger.log(callerFQCN, log4jLevel, msg, t);\n    }\n\n}\n","lineNo":584}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * Tests that detecting logger name mismatches works and doesn't cause problems\n * or trigger if disabled.\n * <p>\n * This test can't live inside slf4j-api because the NOP Logger doesn't\n * remember its name.\n *\n * @author Alexander Dorokhine\n * @author Ceki G&uuml;lc&uuml;\n */\npublic class DetectLoggerNameMismatchTest {\n\n    private static final String MISMATCH_STRING = \"Detected logger name mismatch\";\n\n    private final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n    private final PrintStream oldErr = System.err;\n\n    @Before\n    public void setUp() {\n        System.setErr(new PrintStream(byteArrayOutputStream));\n    }\n\n    @After\n    public void tearDown() {\n        setTrialEnabled(false);\n        System.setErr(oldErr);\n    }\n\n    /*\n     * Pass in the wrong class to the Logger with the check disabled, and make sure there are no errors.\n     */\n    @Test\n    public void testNoTriggerWithoutProperty() {\n        setTrialEnabled(false);\n        Logger logger = LoggerFactory.getLogger(String.class);\n        assertEquals(\"java.lang.String\", logger.getName());\n        assertMismatchDetected(false);\n    }\n\n    /*\n     * Pass in the wrong class to the Logger with the check enabled, and make sure there ARE errors.\n     */\n    @Test\n    public void testTriggerWithProperty() {\n        setTrialEnabled(true);\n        LoggerFactory.getLogger(String.class);\n        String s = String.valueOf(byteArrayOutputStream);\n        assertMismatchDetected(true);\n    }\n\n    /*\n     * Checks the whole error message to ensure all the names show up correctly.\n     */\n    @Test\n    public void testTriggerWholeMessage() {\n        setTrialEnabled(true);\n        LoggerFactory.getLogger(String.class);\n        boolean success = String.valueOf(byteArrayOutputStream).contains(\n                        \"Detected logger name mismatch. Given name: \\\"java.lang.String\\\"; \" + \"computed name: \\\"org.slf4j.DetectLoggerNameMismatchTest\\\".\");\n        assertTrue(\"Actual value of byteArrayOutputStream: \" + String.valueOf(byteArrayOutputStream), success);\n    }\n\n    /*\n     * Checks that there are no errors with the check enabled if the class matches.\n     */\n    @Test\n    public void testPassIfMatch() {\n        setTrialEnabled(true);\n        Logger logger = LoggerFactory.getLogger(DetectLoggerNameMismatchTest.class);\n        assertEquals(\"org.slf4j.DetectLoggerNameMismatchTest\", logger.getName());\n        assertMismatchDetected(false);\n    }\n\n    private void assertMismatchDetected(boolean mismatchDetected) {\n        assertEquals(mismatchDetected, String.valueOf(byteArrayOutputStream).contains(MISMATCH_STRING));\n    }\n\n    @Test\n    public void verifyLoggerDefinedInBaseWithOverridenGetClassMethod() {\n        setTrialEnabled(true);\n        Square square = new Square();\n        assertEquals(\"org.slf4j.Square\", square.logger.getName());\n        assertMismatchDetected(false);\n    }\n\n    private static void setTrialEnabled(boolean enabled) {\n        // The system property is read into a static variable at initialization time\n        // so we cannot just reset the system property to test this feature.\n        // Therefore we set the variable directly.\n        LoggerFactory.DETECT_LOGGER_NAME_MISMATCH = enabled;\n    }\n}\n\n// Used for testing that inheritance is ignored by the checker.\nclass ShapeBase {\n    public Logger logger = LoggerFactory.getLogger(getClass());\n}\n\nclass Square extends ShapeBase {\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * Tests that detecting logger name mismatches works and doesn't cause problems\n * or trigger if disabled.\n * <p>\n * This test can't live inside slf4j-api because the NOP Logger doesn't\n * remember its name.\n *\n * @author Alexander Dorokhine\n * @author Ceki G&uuml;lc&uuml;\n */\npublic class DetectLoggerNameMismatchTest {\n\n    private static final String MISMATCH_STRING = \"Detected logger name mismatch\";\n\n    private final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n    private final PrintStream oldErr = System.err;\n\n    @Before\n    public void setUp() {\n        System.setErr(new PrintStream(byteArrayOutputStream));\n    }\n\n    @After\n    public void tearDown() {\n        setTrialEnabled(false);\n        System.setErr(oldErr);\n    }\n\n    /*\n     * Pass in the wrong class to the Logger with the check disabled, and make sure there are no errors.\n     */\n    @Test\n    public void testNoTriggerWithoutProperty() {\n        setTrialEnabled(false);\n        Logger logger = LoggerFactory.getLogger(String.class);\n        assertEquals(\"java.lang.String\", logger.getName());\n        assertMismatchDetected(false);\n    }\n\n    /*\n     * Pass in the wrong class to the Logger with the check enabled, and make sure there ARE errors.\n     */\n    @Test\n    public void testTriggerWithProperty() {\n        setTrialEnabled(true);\n        LoggerFactory.getLogger(String.class);\n        assertMismatchDetected(true);\n    }\n\n    /*\n     * Checks the whole error message to ensure all the names show up correctly.\n     */\n    @Test\n    public void testTriggerWholeMessage() {\n        setTrialEnabled(true);\n        LoggerFactory.getLogger(String.class);\n        assertTrue(\"Actual value of byteArrayOutputStream: \" + String.valueOf(byteArrayOutputStream), String.valueOf(byteArrayOutputStream).contains(\n                        \"Detected logger name mismatch. Given name: \\\"java.lang.String\\\"; \" + \"computed name: \\\"org.slf4j.DetectLoggerNameMismatchTest\\\".\"));\n    }\n\n    /*\n     * Checks that there are no errors with the check enabled if the class matches.\n     */\n    @Test\n    public void testPassIfMatch() {\n        setTrialEnabled(true);\n        Logger logger = LoggerFactory.getLogger(DetectLoggerNameMismatchTest.class);\n        assertEquals(\"org.slf4j.DetectLoggerNameMismatchTest\", logger.getName());\n        assertMismatchDetected(false);\n    }\n\n    private void assertMismatchDetected(boolean mismatchDetected) {\n        assertEquals(mismatchDetected, String.valueOf(byteArrayOutputStream).contains(MISMATCH_STRING));\n    }\n\n    @Test\n    public void verifyLoggerDefinedInBaseWithOverridenGetClassMethod() {\n        setTrialEnabled(true);\n        Square square = new Square();\n        assertEquals(\"org.slf4j.Square\", square.logger.getName());\n        assertMismatchDetected(false);\n    }\n\n    private static void setTrialEnabled(boolean enabled) {\n        // The system property is read into a static variable at initialization time\n        // so we cannot just reset the system property to test this feature.\n        // Therefore we set the variable directly.\n        LoggerFactory.DETECT_LOGGER_NAME_MISMATCH = enabled;\n    }\n}\n\n// Used for testing that inheritance is ignored by the checker.\nclass ShapeBase {\n    public Logger logger = LoggerFactory.getLogger(getClass());\n}\n\nclass Square extends ShapeBase {\n}\n","lineNo":94}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.Logger;\n\n/**\n * SubstituteLoggerFactory manages instances of {@link SubstituteLogger}.\n * @author Ceki G&uuml;lc&uuml;\n */\npublic class SubstituteLoggerFactory implements ILoggerFactory {\n\n  final ConcurrentMap<String, SubstituteLogger> loggers = new ConcurrentHashMap<String, SubstituteLogger>();\n\n  public Logger getLogger(String name) {\n    SubstituteLogger logger = loggers.get(name);\n     if (logger == null) {\n        logger = new SubstituteLogger(name);\n        SubstituteLogger oldLogger = loggers.putIfAbsent(name, logger);\n        if (oldLogger != null)\n          logger = oldLogger;\n      }\n    return logger;\n  }\n\n  public List getLoggerNameList() {\n    return new ArrayList<String>(loggers.keySet());\n  }\n\n  public List<SubstituteLogger> getLoggers() {\n    return new ArrayList<SubstituteLogger>(loggers.values());\n  }\n\n  public void clear() {\n    loggers.clear();\n  }\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.Logger;\n\n/**\n * SubstituteLoggerFactory is an trivial implementation of\n * {@link ILoggerFactory} which always returns the unique instance of NOPLogger.\n * <p/>\n * <p>\n * It used as a temporary substitute for the real ILoggerFactory during its\n * auto-configuration which may re-enter LoggerFactory to obtain logger\n * instances. See also http://bugzilla.slf4j.org/show_bug.cgi?id=106\n * <p/>\n * <p>\n * Logger implementations can swap out the NOPLogger with actual Logger\n * implementation once they are properly configured by changing the delegate\n * in {@link org.slf4j.helpers.SubstitutableLogger}\n * <\/p>\n *\n * @author Ceki G&uuml;lc&uuml;\n */\npublic class SubstituteLoggerFactory implements ILoggerFactory {\n\n  // keep a record of requested logger names\n  final ConcurrentMap<String, SubstitutableLogger> loggers = new ConcurrentHashMap<String, SubstitutableLogger>();\n\n  public Logger getLogger(String name) {\n    SubstitutableLogger logger;\n    synchronized (loggers) {\n      logger = loggers.get(name);\n      if (logger == null) {\n        logger = new SubstitutableLogger(name);\n        loggers.put(name, logger);\n      }\n    }\n    return logger;\n  }\n\n  public List getLoggerNameList() {\n    return new ArrayList<String>(loggers.keySet());\n  }\n\n  public List<SubstitutableLogger> getLoggers() {\n    return new ArrayList<SubstitutableLogger>(loggers.values());\n  }\n\n  public void clear() {\n    loggers.clear();\n  }\n}\n","lineNo":44}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.Logger;\n\n/**\n * SubstituteLoggerFactory manages instances of {@link SubstituteLogger}.\n * @author Ceki G&uuml;lc&uuml;\n */\npublic class SubstituteLoggerFactory implements ILoggerFactory {\n\n  final ConcurrentMap<String, SubstituteLogger> loggers = new ConcurrentHashMap<String, SubstituteLogger>();\n\n  public Logger getLogger(String name) {\n    SubstituteLogger logger = loggers.get(name);\n     if (logger == null) {\n        logger = new SubstituteLogger(name);\n        SubstituteLogger oldLogger = loggers.putIfAbsent(name, logger);\n        if (oldLogger != null)\n          logger = oldLogger;\n      }\n    return logger;\n  }\n\n  public List getLoggerNameList() {\n    return new ArrayList<String>(loggers.keySet());\n  }\n\n  public List<SubstituteLogger> getLoggers() {\n    return new ArrayList<SubstituteLogger>(loggers.values());\n  }\n\n  public void clear() {\n    loggers.clear();\n  }\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.Logger;\n\n/**\n * SubstituteLoggerFactory is an trivial implementation of\n * {@link ILoggerFactory} which always returns the unique instance of NOPLogger.\n * <p/>\n * <p>\n * It used as a temporary substitute for the real ILoggerFactory during its\n * auto-configuration which may re-enter LoggerFactory to obtain logger\n * instances. See also http://bugzilla.slf4j.org/show_bug.cgi?id=106\n * <p/>\n * <p>\n * Logger implementations can swap out the NOPLogger with actual Logger\n * implementation once they are properly configured by changing the delegate\n * in {@link org.slf4j.helpers.SubstitutableLogger}\n * <\/p>\n *\n * @author Ceki G&uuml;lc&uuml;\n */\npublic class SubstituteLoggerFactory implements ILoggerFactory {\n\n  // keep a record of requested logger names\n  final ConcurrentMap<String, SubstitutableLogger> loggers = new ConcurrentHashMap<String, SubstitutableLogger>();\n\n  public Logger getLogger(String name) {\n    SubstitutableLogger logger;\n    synchronized (loggers) {\n      logger = loggers.get(name);\n      if (logger == null) {\n        logger = new SubstitutableLogger(name);\n        loggers.put(name, logger);\n      }\n    }\n    return logger;\n  }\n\n  public List getLoggerNameList() {\n    return new ArrayList<String>(loggers.keySet());\n  }\n\n  public List<SubstitutableLogger> getLoggers() {\n    return new ArrayList<SubstitutableLogger>(loggers.values());\n  }\n\n  public void clear() {\n    loggers.clear();\n  }\n}\n","lineNo":47}
{"Refactored Sample":"/*\n * Copyright (c) 2004-2013 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.Logger;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * AndroidLoggerFactory is an implementation of {@link ILoggerFactory} returning\n * the appropriately named {@link AndroidLoggerFactory} instance.\n *\n * @author Andrey Korzhevskiy <a.korzhevskiy@gmail.com>\n */\nclass AndroidLoggerFactory implements ILoggerFactory {\n    static final String ANONYMOUS_TAG = \"null\";\n    static final int TAG_MAX_LENGTH = 23;\n\n    private final ConcurrentMap<String, Logger> loggerMap = new ConcurrentHashMap<String, Logger>();\n\n    /**\n     * Return an appropriate {@link AndroidLoggerAdapter} instance by name.\n     */\n    public Logger getLogger(String name) {\n        String tag = loggerNameToTag(name);\n        Logger logger = loggerMap.get(tag);\n        if (logger == null) {\n            Logger newInstance = new AndroidLoggerAdapter(tag);\n            Logger oldInstance = loggerMap.putIfAbsent(tag, newInstance);\n            logger = oldInstance == null ? newInstance : oldInstance;\n        }\n        return logger;\n    }\n\n    /**\n     * Tag names cannot be longer than {@value #TAG_MAX_LENGTH} characters on Android platform.\n     *\n     * Returns the short logger tag (up to {@value #TAG_MAX_LENGTH} characters) for the given logger name.\n     * Traditionally loggers are named by fully-qualified Java classes; this\n     * method attempts to return a concise identifying part of such names.\n     *\n     * See also:\n     * android/system/core/include/cutils/property.h\n     * android/frameworks/base/core/jni/android_util_Log.cpp\n     * dalvik.system.DalvikLogging\n     *\n     */\n    static String loggerNameToTag(String loggerName) {\n        // Anonymous logger\n        if (loggerName == null) {\n            return ANONYMOUS_TAG;\n        }\n\n        int length = loggerName.length();\n        if (length <= TAG_MAX_LENGTH) {\n            return loggerName;\n        }\n\n        int tagLength = 0;\n        int lastTokenIndex = 0;\n        int lastPeriodIndex;\n        StringBuilder tagName = new StringBuilder(TAG_MAX_LENGTH + 3);\n        while ((lastPeriodIndex = loggerName.indexOf('.', lastTokenIndex)) != -1) {\n            tagName.append(loggerName.charAt(lastTokenIndex));\n            // token of one character appended as is otherwise truncate it to one character\n            int tokenLength = lastPeriodIndex - lastTokenIndex;\n            if (tokenLength > 1) {\n                tagName.append('*');\n            }\n            tagName.append('.');\n            lastTokenIndex = lastPeriodIndex + 1;\n\n            // check if name is already too long\n            tagLength = tagName.length();\n            if (tagLength > TAG_MAX_LENGTH) {\n                return getSimpleName(loggerName);\n            }\n        }\n\n        // Either we had no useful dot location at all\n        // or last token would exceed TAG_MAX_LENGTH\n        int tokenLength = length - lastTokenIndex;\n        if (tagLength == 0 || (tagLength + tokenLength) > TAG_MAX_LENGTH) {\n            return getSimpleName(loggerName);\n        }\n\n        // last token (usually class name) appended as is\n        tagName.append(loggerName, lastTokenIndex, length);\n        return tagName.toString();\n    }\n\n    private static String getSimpleName(String loggerName) {\n        // Take leading part and append '*' to indicate that it was truncated\n        int length = loggerName.length();\n        int lastPeriodIndex = loggerName.lastIndexOf('.');\n        return lastPeriodIndex != -1 && length - (lastPeriodIndex + 1) <= TAG_MAX_LENGTH\n            ? loggerName.substring(lastPeriodIndex + 1)\n            : '*' + loggerName.substring(length - TAG_MAX_LENGTH + 1);\n    }\n}\n","Smelly Sample":"/*\n * Copyright (c) 2004-2013 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.Logger;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * AndroidLoggerFactory is an implementation of {@link ILoggerFactory} returning\n * the appropriately named {@link AndroidLoggerFactory} instance.\n *\n * @author Andrey Korzhevskiy <a.korzhevskiy@gmail.com>\n */\nclass AndroidLoggerFactory implements ILoggerFactory {\n    static final String ANONYMOUS_TAG = \"null\";\n    static final int TAG_MAX_LENGTH = 23;\n\n    private final ConcurrentMap<String, Logger> loggerMap = new ConcurrentHashMap<String, Logger>();\n\n\n    /**\n     * Return an appropriate {@link AndroidLoggerAdapter} instance by name.\n     */\n    public Logger getLogger(String name) {\n        String tag = loggerNameToTag(name);\n        Logger logger = loggerMap.get(tag);\n        if (logger == null) {\n            Logger newInstance = new AndroidLoggerAdapter(tag);\n            Logger oldInstance = loggerMap.putIfAbsent(tag, newInstance);\n            logger = oldInstance == null ? newInstance : oldInstance;\n        }\n        return logger;\n    }\n\n    /**\n     * Tag names cannot be longer than {@value #TAG_MAX_LENGTH} characters on Android platform.\n     *\n     * Returns the short logger tag (up to {@value #TAG_MAX_LENGTH} characters) for the given logger name.\n     * Traditionally loggers are named by fully-qualified Java classes; this\n     * method attempts to return a concise identifying part of such names.\n     *\n     * See also:\n     * android/system/core/include/cutils/property.h\n     * android/frameworks/base/core/jni/android_util_Log.cpp\n     * dalvik.system.DalvikLogging\n     *\n     */\n    static String loggerNameToTag(String loggerName) {\n        // Anonymous logger\n        if (loggerName == null) {\n            return ANONYMOUS_TAG;\n        }\n\n        int length = loggerName.length();\n        if (length <= TAG_MAX_LENGTH) {\n            return loggerName;\n        }\n\n        int lastTokenIndex = 0;\n        int lastPeriodIndex;\n        StringBuilder tagName = new StringBuilder();\n        while ((lastPeriodIndex = loggerName.indexOf('.', lastTokenIndex)) != -1) {\n            tagName.append(loggerName.charAt(lastTokenIndex));\n            // token of one character appended as is otherwise truncate it to one character\n            int tokenLength = lastPeriodIndex - lastTokenIndex;\n            if (tokenLength > 1) {\n                tagName.append('*');\n            }\n            tagName.append('.');\n            lastTokenIndex = lastPeriodIndex + 1;\n        }\n        // last token (usually class name) appended as is\n        tagName.append(loggerName, lastTokenIndex, length);\n        if (tagName.length() <= TAG_MAX_LENGTH) {\n            return tagName.toString();\n        }\n\n        // Either we had no useful dot location at all or name still too long.\n        // Take leading part and append '*' to indicate that it was truncated\n        lastPeriodIndex = loggerName.lastIndexOf('.');\n        return lastPeriodIndex != -1 && length - (lastPeriodIndex + 1) <= TAG_MAX_LENGTH\n                ? loggerName.substring(lastPeriodIndex + 1)\n                : '*' + loggerName.substring(length - TAG_MAX_LENGTH + 1);\n    }\n}\n","lineNo":83}
{"Refactored Sample":"/*\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.Logger;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * AndroidLoggerFactory is an implementation of {@link ILoggerFactory} returning\n * the appropriately named {@link AndroidLoggerFactory} instance.\n *\n * @author Andrey Korzhevskiy <a.korzhevskiy@gmail.com>\n */\npublic class AndroidLoggerFactory implements ILoggerFactory {\n    private final ConcurrentMap<String, Logger> loggerMap;\n\n    static final String ANONYMOUS_TAG = \"null\"; //taken from dalvik.system.DalvikLogging\n    static final int TAG_MAX_LENGTH = 23; // tag names cannot be longer on Android platform\n    // see also android/system/core/include/cutils/property.h\n    // and android/frameworks/base/core/jni/android_util_Log.cpp\n\n    public AndroidLoggerFactory() {\n        loggerMap = new ConcurrentHashMap<String, Logger>();\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.slf4j.ILoggerFactory#getLogger(java.lang.String)\n     */\n    public Logger getLogger(String name) {\n        String tag = loggerNameToTag(name); // fix for bug #173\n/*\n        if (name != null && !name.equals(tag)) {\n            Log.i(AndroidLoggerFactory.class.getSimpleName(),\n                    \"Logger name '\" + name + \"' exceeds maximum length of \" + TAG_MAX_LENGTH +\n                            \" characters, using '\" + tag + \"' instead.\");\n        }\n*/\n\n        Logger logger = loggerMap.get(tag);\n        if (logger == null) {\n            Logger newInstance = new AndroidLoggerAdapter(tag);\n            Logger oldInstance = loggerMap.putIfAbsent(tag, newInstance);\n            logger = oldInstance == null ? newInstance : oldInstance;\n        }\n        return logger;\n    }\n\n    /**\n     * Returns the short logger tag (up to {@value #TAG_MAX_LENGTH} chars) for the given logger name.\n     * Traditionally loggers are named by fully-qualified Java classes; this\n     * method attempts to return a concise identifying part of such names.\n     */\n    static String loggerNameToTag(String loggerName) {\n        // Anonymous logger\n        if (loggerName == null) {\n            return ANONYMOUS_TAG;\n        }\n\n        int length = loggerName.length();\n        if (length <= TAG_MAX_LENGTH) {\n            return loggerName;\n        }\n\n        int lastTokenIndex = 0;\n        int lastPeriodIndex;\n        StringBuilder tagName = new StringBuilder();\n        while ((lastPeriodIndex = loggerName.indexOf('.', lastTokenIndex)) != -1) {\n            tagName.append(loggerName.charAt(lastTokenIndex));\n            // token of one character appended as is otherwise truncate it to one character\n            int tokenLength = lastPeriodIndex - lastTokenIndex;\n            if (tokenLength > 1) {\n                tagName.append(\"*\");\n            }\n            tagName.append(\".\");\n            lastTokenIndex = lastPeriodIndex + 1;\n        }\n        // last token (usually class name) appended as is\n        tagName.append(loggerName, lastTokenIndex, length);\n        if (tagName.length() <= TAG_MAX_LENGTH) {\n            return tagName.toString();\n        }\n\n        // Either we had no useful dot location at all or name still too long.\n        // Take leading part and append '*' to indicate that it was truncated\n        lastPeriodIndex = loggerName.lastIndexOf(\".\");\n        return lastPeriodIndex != -1 && length - (lastPeriodIndex + 1) <= TAG_MAX_LENGTH\n                ? loggerName.substring(lastPeriodIndex + 1)\n                : \"*\" + loggerName.substring(length - TAG_MAX_LENGTH + 1);\n    }\n}\n","Smelly Sample":"/*\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport android.util.Log;\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.Logger;\n\nimport java.util.StringTokenizer;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * AndroidLoggerFactory is an implementation of {@link ILoggerFactory} returning\n * the appropriately named {@link AndroidLoggerFactory} instance.\n *\n * @author Andrey Korzhevskiy <a.korzhevskiy@gmail.com>\n */\npublic class AndroidLoggerFactory implements ILoggerFactory {\n    private final ConcurrentMap<String, Logger> loggerMap;\n\n    static final int TAG_MAX_LENGTH = 23; // tag names cannot be longer on Android platform\n    // see also android/system/core/include/cutils/property.h\n    // and android/frameworks/base/core/jni/android_util_Log.cpp\n\n    public AndroidLoggerFactory() {\n        loggerMap = new ConcurrentHashMap<String, Logger>();\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.slf4j.ILoggerFactory#getLogger(java.lang.String)\n     */\n    public Logger getLogger(String name) {\n        final String passedName = name;\n        name = forceValidName(passedName); // fix for bug #173\n        if (!passedName.equals(name)) {\n            Log.i(AndroidLoggerFactory.class.getSimpleName(),\n                    \"Logger name '\" + passedName + \"' exceeds maximum length of \" + TAG_MAX_LENGTH +\n                            \" characters, using '\" + name + \"' instead.\");\n        }\n\n        Logger logger = loggerMap.get(name);\n        if (logger == null) {\n            Logger newInstance = new AndroidLoggerAdapter(name);\n            Logger oldInstance = loggerMap.putIfAbsent(name, newInstance);\n            logger = oldInstance == null ? newInstance : oldInstance;\n        }\n        return logger;\n    }\n\n    /**\n     * Trim name in case it exceeds maximum length of {@value #TAG_MAX_LENGTH} characters.\n     */\n    private static String forceValidName(String name) {\n        if (name != null && name.length() > TAG_MAX_LENGTH) {\n            final StringTokenizer st = new StringTokenizer(name, \".\");\n            if (st.hasMoreTokens()) { // note that empty tokens are skipped, i.e., \"aa..bb\" has tokens \"aa\", \"bb\"\n                final StringBuilder sb = new StringBuilder();\n                String token;\n                do {\n                    token = st.nextToken();\n                    if (token.length() == 1) { // token of one character appended as is\n                        sb.append(token);\n                        sb.append('.');\n                    } else if (st.hasMoreTokens()) { // truncate all but the last token\n                        sb.append(token.charAt(0));\n                        sb.append(\"*.\");\n                    } else { // last token (usually class name) appended as is\n                        sb.append(token);\n                    }\n                } while (st.hasMoreTokens());\n\n                name = sb.toString();\n            }\n\n            // Either we had no useful dot location at all or name still too long.\n            // Take leading part and append '*' to indicate that it was truncated\n            if (name.length() > TAG_MAX_LENGTH) {\n                name = name.substring(0, TAG_MAX_LENGTH - 1) + '*';\n            }\n        }\n        return name;\n    }\n}\n","lineNo":57}
{"Refactored Sample":"/*\n * Copyright 2001-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.log4j;\n\nimport org.apache.log4j.spi.LoggerFactory;\nimport org.slf4j.helpers.Util;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * This class is a factory that creates and maintains org.apache.log4j.Loggers\n * wrapping org.slf4j.Loggers.\n *\n * It keeps a hashtable of all created org.apache.log4j.Logger instances so that\n * all newly created instances are not duplicates of existing loggers.\n *\n * @author S&eacute;bastien Pennec\n */\nclass Log4jLoggerFactory {\n\n  // String, Logger\n  private static ConcurrentMap<String, Logger> log4jLoggers = new ConcurrentHashMap<String, Logger>();\n\n  private static final String LOG4J_DELEGATION_LOOP_URL = \"http://www.slf4j.org/codes.html#log4jDelegationLoop\";\n\n  // check for delegation loops\n  static {\n    try {\n      Class.forName(\"org.slf4j.impl.Log4jLoggerFactory\");\n      String part1 = \"Detected both log4j-over-slf4j.jar AND slf4j-log4j12.jar on the class path, preempting StackOverflowError. \";\n      String part2 = \"See also \" + LOG4J_DELEGATION_LOOP_URL\n              + \" for more details.\";\n\n      Util.report(part1);\n      Util.report(part2);\n      throw new IllegalStateException(part1 + part2);\n    } catch (ClassNotFoundException e) {\n      // this is the good case\n    }\n  }\n\n  public static Logger getLogger(String name) {\n    org.apache.log4j.Logger instance = log4jLoggers.get(name);\n    if (instance != null) {\n      return instance;\n    } else {\n      Logger newInstance = new Logger(name);\n      Logger oldInstance = log4jLoggers.putIfAbsent(name, newInstance);\n      return oldInstance == null ? newInstance : oldInstance;\n    }\n  }\n\n  public static Logger getLogger(String name, LoggerFactory loggerFactory) {\n    org.apache.log4j.Logger instance = log4jLoggers.get(name);\n    if (instance != null) {\n      return instance;\n    } else {\n      Logger newInstance = loggerFactory.makeNewLoggerInstance(name);\n      Logger oldInstance = log4jLoggers.putIfAbsent(name, newInstance);\n      return oldInstance == null ? newInstance : oldInstance;\n    }\n  }\n}\n","Smelly Sample":"/*\n * Copyright 2001-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.log4j;\n\nimport java.util.Hashtable;\n\nimport org.apache.log4j.spi.LoggerFactory;\nimport org.slf4j.helpers.Util;\n\n/**\n * This class is a factory that creates and maintains org.apache.log4j.Loggers\n * wrapping org.slf4j.Loggers.\n * \n * It keeps a hashtable of all created org.apache.log4j.Logger instances so that\n * all newly created instances are not dulpicates of existing loggers.\n * \n * @author S&eacute;bastien Pennec\n */\nclass Log4jLoggerFactory {\n\n  // String, Logger\n  private static Hashtable log4jLoggers = new Hashtable();\n\n  private static final String LOG4J_DELEGATION_LOOP_URL = \"http://www.slf4j.org/codes.html#log4jDelegationLoop\";\n  \n  // check for delegation loops\n  static {\n    try {\n      Class.forName(\"org.slf4j.impl.Log4jLoggerFactory\");\n      String part1 = \"Detected both log4j-over-slf4j.jar AND slf4j-log4j12.jar on the class path, preempting StackOverflowError. \";\n      String part2 = \"See also \" + LOG4J_DELEGATION_LOOP_URL\n          + \" for more details.\";\n\n      Util.report(part1);\n      Util.report(part2);\n            throw new IllegalStateException(part1 + part2);\n    } catch (ClassNotFoundException e) {\n      // this is the good case\n    }\n  }\n\n  public static synchronized Logger getLogger(String name) {\n    if (log4jLoggers.containsKey(name)) {\n      return (org.apache.log4j.Logger) log4jLoggers.get(name);\n    } else {\n      Logger log4jLogger = new Logger(name);\n\n      log4jLoggers.put(name, log4jLogger);\n      return log4jLogger;\n    }\n  }\n  \n  public static synchronized Logger getLogger(String name, LoggerFactory loggerFactory) {\n\t  if (log4jLoggers.containsKey(name)) {\n\t\t  return (org.apache.log4j.Logger) log4jLoggers.get(name);\n\t  } else {\n\t\t  Logger log4jLogger = loggerFactory.makeNewLoggerInstance(name);\n\n\t\t  log4jLoggers.put(name, log4jLogger);\n\t\t  return log4jLogger;\n\t  }\n  }\n\n}\n","lineNo":58}
{"Refactored Sample":"/*\n * Copyright 2001-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.log4j;\n\nimport org.apache.log4j.spi.LoggerFactory;\nimport org.slf4j.helpers.Util;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * This class is a factory that creates and maintains org.apache.log4j.Loggers\n * wrapping org.slf4j.Loggers.\n *\n * It keeps a hashtable of all created org.apache.log4j.Logger instances so that\n * all newly created instances are not duplicates of existing loggers.\n *\n * @author S&eacute;bastien Pennec\n */\nclass Log4jLoggerFactory {\n\n  // String, Logger\n  private static ConcurrentMap<String, Logger> log4jLoggers = new ConcurrentHashMap<String, Logger>();\n\n  private static final String LOG4J_DELEGATION_LOOP_URL = \"http://www.slf4j.org/codes.html#log4jDelegationLoop\";\n\n  // check for delegation loops\n  static {\n    try {\n      Class.forName(\"org.slf4j.impl.Log4jLoggerFactory\");\n      String part1 = \"Detected both log4j-over-slf4j.jar AND slf4j-log4j12.jar on the class path, preempting StackOverflowError. \";\n      String part2 = \"See also \" + LOG4J_DELEGATION_LOOP_URL\n              + \" for more details.\";\n\n      Util.report(part1);\n      Util.report(part2);\n      throw new IllegalStateException(part1 + part2);\n    } catch (ClassNotFoundException e) {\n      // this is the good case\n    }\n  }\n\n  public static Logger getLogger(String name) {\n    org.apache.log4j.Logger instance = log4jLoggers.get(name);\n    if (instance != null) {\n      return instance;\n    } else {\n      Logger newInstance = new Logger(name);\n      Logger oldInstance = log4jLoggers.putIfAbsent(name, newInstance);\n      return oldInstance == null ? newInstance : oldInstance;\n    }\n  }\n\n  public static Logger getLogger(String name, LoggerFactory loggerFactory) {\n    org.apache.log4j.Logger instance = log4jLoggers.get(name);\n    if (instance != null) {\n      return instance;\n    } else {\n      Logger newInstance = loggerFactory.makeNewLoggerInstance(name);\n      Logger oldInstance = log4jLoggers.putIfAbsent(name, newInstance);\n      return oldInstance == null ? newInstance : oldInstance;\n    }\n  }\n}\n","Smelly Sample":"/*\n * Copyright 2001-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.log4j;\n\nimport java.util.Hashtable;\n\nimport org.apache.log4j.spi.LoggerFactory;\nimport org.slf4j.helpers.Util;\n\n/**\n * This class is a factory that creates and maintains org.apache.log4j.Loggers\n * wrapping org.slf4j.Loggers.\n * \n * It keeps a hashtable of all created org.apache.log4j.Logger instances so that\n * all newly created instances are not dulpicates of existing loggers.\n * \n * @author S&eacute;bastien Pennec\n */\nclass Log4jLoggerFactory {\n\n  // String, Logger\n  private static Hashtable log4jLoggers = new Hashtable();\n\n  private static final String LOG4J_DELEGATION_LOOP_URL = \"http://www.slf4j.org/codes.html#log4jDelegationLoop\";\n  \n  // check for delegation loops\n  static {\n    try {\n      Class.forName(\"org.slf4j.impl.Log4jLoggerFactory\");\n      String part1 = \"Detected both log4j-over-slf4j.jar AND slf4j-log4j12.jar on the class path, preempting StackOverflowError. \";\n      String part2 = \"See also \" + LOG4J_DELEGATION_LOOP_URL\n          + \" for more details.\";\n\n      Util.report(part1);\n      Util.report(part2);\n            throw new IllegalStateException(part1 + part2);\n    } catch (ClassNotFoundException e) {\n      // this is the good case\n    }\n  }\n\n  public static synchronized Logger getLogger(String name) {\n    if (log4jLoggers.containsKey(name)) {\n      return (org.apache.log4j.Logger) log4jLoggers.get(name);\n    } else {\n      Logger log4jLogger = new Logger(name);\n\n      log4jLoggers.put(name, log4jLogger);\n      return log4jLogger;\n    }\n  }\n  \n  public static synchronized Logger getLogger(String name, LoggerFactory loggerFactory) {\n\t  if (log4jLoggers.containsKey(name)) {\n\t\t  return (org.apache.log4j.Logger) log4jLoggers.get(name);\n\t  } else {\n\t\t  Logger log4jLogger = loggerFactory.makeNewLoggerInstance(name);\n\n\t\t  log4jLoggers.put(name, log4jLogger);\n\t\t  return log4jLogger;\n\t  }\n  }\n\n}\n","lineNo":69}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.log4j;\n\nimport org.slf4j.MDC;\n\nimport java.util.Stack;\n\n/**\n * A log4j's NDC implemented in terms of SLF4J MDC primitives.\n *\n * @since SLF4J 1.6.0\n */\n\npublic class NDC {\n\n  public final static String PREFIX = \"NDC\";\n\n  public static void clear() {\n    int depth = getDepth();\n    for (int i = 0; i < depth; i++) {\n      String key = PREFIX + i;\n      MDC.remove(key);\n    }\n  }\n\n  public static Stack cloneStack() {\n    return null;\n  }\n\n  public static void inherit(Stack stack) {\n  }\n\n  static public String get() {\n    return null;\n  }\n\n  public static int getDepth() {\n    int i = 0;\n    while (true) {\n      String val = MDC.get(PREFIX + i);\n      if (val != null) {\n        i++;\n      } else {\n        break;\n      }\n    }\n    return i;\n  }\n\n  public static String pop() {\n    int next = getDepth();\n    if (next == 0) {\n      return \"\";\n    }\n    int last = next - 1;\n    String key = PREFIX + last;\n    String val = MDC.get(key);\n    MDC.remove(key);\n    return val;\n  }\n\n  public static String peek() {\n    int next = getDepth();\n    if (next == 0) {\n      return \"\";\n    }\n    int last = next - 1;\n    String key = PREFIX + last;\n    String val = MDC.get(key);\n    return val;\n  }\n\n  public static void push(String message) {\n    int next = getDepth();\n    MDC.put(PREFIX + next, message);\n  }\n\n  static public void remove() {\n    clear();\n  }\n\n  static public void setMaxDepth(int maxDepth) {\n  }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.log4j;\n\nimport java.util.Stack;\n\n/**\n * A bare-bones implementation of log4j's NDC which compiles and prevents run\n * time exceptions.\n * \n * @since SLF4J 1.6.0\n */\n\npublic class NDC {\n\n  public static void clear() {\n  }\n\n  public static Stack cloneStack() {\n    return null;\n  }\n\n  public static void inherit(Stack stack) {\n  }\n\n  static public String get() {\n    return null;\n  }\n\n  public static int getDepth() {\n    return 0;\n  }\n\n  public static String pop() {\n    return \"\";\n  }\n\n  public static String peek() {\n    return \"\";\n  }\n\n  public static void push(String message) {\n  }\n\n  static public void remove() {\n  }\n\n  static public void setMaxDepth(int maxDepth) {\n  }\n\n}\n","lineNo":54}
{"Refactored Sample":"package org.slf4j.helpers;\n\nimport java.text.MessageFormat;\n\nimport junit.framework.TestCase;\n\npublic class MessageFormatterPerfTest extends TestCase {\n\n  Integer i1 = new Integer(1);\n  Integer i2 = new Integer(2);\n  static long RUN_LENGTH = 200 * 1000;\n  // \n  static long REFERENCE_BIPS = 48416;\n\n  public MessageFormatterPerfTest(String name) {\n    super(name);\n  }\n\n  protected void setUp() throws Exception {\n  }\n\n  protected void tearDown() throws Exception {\n  }\n\n  public void XtestJDKFormatterPerf() {\n    jdkMessageFormatter(RUN_LENGTH);\n    double duration = jdkMessageFormatter(RUN_LENGTH);\n    System.out.println(\"jdk duration = \" + duration + \" nanos\");\n  }\n\n  public void testSLF4JPerf_OneArg() {\n    slf4jMessageFormatter_OneArg(RUN_LENGTH);\n    double duration = slf4jMessageFormatter_OneArg(RUN_LENGTH);\n    System.out.println(\"duration=\" + duration);\n    long referencePerf = 72;\n    BogoPerf.assertDuration(duration, referencePerf, REFERENCE_BIPS);\n  }\n\n  public void testSLF4JPerf_TwoArg() {\n    slf4jMessageFormatter_TwoArg(RUN_LENGTH);\n    double duration = slf4jMessageFormatter_TwoArg(RUN_LENGTH);\n    System.out.println(\"duration2=\" + duration);\n    long referencePerf = 120;\n    BogoPerf.assertDuration(duration, referencePerf, REFERENCE_BIPS);\n  }\n\n  public double slf4jMessageFormatter_OneArg(long len) {\n    long start = System.nanoTime();\n    for (int i = 0; i < len; i++) {\n      final FormattingTuple tp = MessageFormatter.format(\n          \"This is some rather short message {} \", i1);\n      tp.getMessage();\n      tp.getArgArray();\n      tp.getThrowable();\n    }\n    long end = System.nanoTime();\n    return (end - start) / (1000 * 1000.0);\n  }\n\n  public double slf4jMessageFormatter_TwoArg(long len) {\n    String s = \"\";\n    s += \"\"; // keep compiler happy\n    long start = System.nanoTime();\n    for (int i = 0; i < len; i++) {\n      final FormattingTuple tp = MessageFormatter.format(\n          \"This is some {} short message {} \", i1, i2);\n      tp.getMessage();\n      tp.getArgArray();\n      tp.getThrowable();\n    }\n    long end = System.nanoTime();\n    return (end - start) / (1000 * 1000.0);\n  }\n\n  public double jdkMessageFormatter(long len) {\n    String s = \"\";\n    s += \"\"; // keep compiler happy\n    long start = System.currentTimeMillis();\n    Object[] oa = new Object[] { i1 };\n    for (int i = 0; i < len; i++) {\n      s = MessageFormat.format(\"This is some rather short message {0}\", oa);\n    }\n    long end = System.currentTimeMillis();\n    return (1.0 * end - start);\n  }\n\n}\n","Smelly Sample":"package org.slf4j.helpers;\n\nimport java.text.MessageFormat;\n\nimport junit.framework.TestCase;\n\npublic class MessageFormatterPerfTest extends TestCase {\n\n  Integer i1 = new Integer(1);\n  static long RUN_LENGTH = 100000;\n  static long REFERENCE_BIPS = 9000;\n\n  public MessageFormatterPerfTest(String name) {\n    super(name);\n  }\n\n  protected void setUp() throws Exception {\n  }\n\n  protected void tearDown() throws Exception {\n  }\n\n  public void XtestJDKFormatterPerf() {\n    jdkMessageFormatter(RUN_LENGTH);\n    double duration = jdkMessageFormatter(RUN_LENGTH);\n    System.out.println(\"jdk duration = \" + duration + \" nanos\");\n  }\n\n  public void testSLF4JPerf() {\n    slf4jMessageFormatter(RUN_LENGTH);\n    double duration = slf4jMessageFormatter(RUN_LENGTH);\n    long referencePerf = 140;\n    System.out.println(\"duration=\"+duration);\n    BogoPerf.assertDuration(duration, referencePerf, REFERENCE_BIPS);\n  }\n\n  public double slf4jMessageFormatter(long len) {\n    String s = \"\";\n    s += \"\"; // keep compiler happy\n    long start = System.nanoTime();\n    for (int i = 0; i < len; i++) {\n      s = MessageFormatter.format(\"This is some rather short message {} \", i1)\n          .getMessage();\n    }\n    long end = System.nanoTime();\n    return (end - start)/(1000*1000.0);\n  }\n\n  public double jdkMessageFormatter(long len) {\n    String s = \"\";\n    s += \"\"; // keep compiler happy\n    long start = System.currentTimeMillis();\n    Object[] oa = new Object[] { i1 };\n    for (int i = 0; i < len; i++) {\n      s = MessageFormat.format(\"This is some rather short message {0}\", oa);\n    }\n    long end = System.currentTimeMillis();\n    return (1.0 * end - start);\n  }\n\n}\n","lineNo":50}
{"Refactored Sample":"/*\n * Copyright (c) 2004-2008 QOS.ch\n * All rights reserved.\n * \n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n * \n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n * \n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage org.slf4j;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.List;\n\nimport org.slf4j.helpers.SubstituteLoggerFactory;\nimport org.slf4j.helpers.Util;\nimport org.slf4j.impl.StaticLoggerBinder;\n\n/**\n * The <code>LoggerFactory<\/code> is a utility class producing Loggers for\n * various logging APIs, most notably for log4j, logback and JDK 1.4 logging.\n * Other implementations such as {@link org.slf4j.impl.NOPLogger NOPLogger} and\n * {@link org.slf4j.impl.SimpleLogger SimpleLogger} are also supported.\n * \n * <p>\n * <code>LoggerFactory<\/code> is essentially a wrapper around an\n * {@link ILoggerFactory} instance bound with <code>LoggerFactory<\/code> at\n * compile time.\n * \n * <p>\n * Please note that all methods in <code>LoggerFactory<\/code> are static.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Robert Elliot\n */\npublic final class LoggerFactory {\n\n  static final String NO_STATICLOGGERBINDER_URL = \"http://www.slf4j.org/codes.html#StaticLoggerBinder\";\n  static final String MULTIPLE_BINDINGS_URL = \"http://www.slf4j.org/codes.html#multiple_bindings\";\n  static final String NULL_LF_URL = \"http://www.slf4j.org/codes.html#null_LF\";\n  static final String VERSION_MISMATCH = \"http://www.slf4j.org/codes.html#version_mismatch\";\n  static final String SUBSTITUTE_LOGGER_URL = \"http://www.slf4j.org/codes.html#substituteLogger\";\n\n  static final String UNSUCCESSFUL_INIT_URL = \"http://www.slf4j.org/codes.html#unsuccessfulInit\";\n  static final String UNSUCCESSFUL_INIT_MSG = \"org.slf4j.LoggerFactory could not be successfully initialized. See also \"\n      + UNSUCCESSFUL_INIT_URL;\n\n  static final int UNINITIALIZED = 0;\n  static final int ONGOING_INITILIZATION = 1;\n  static final int FAILED_INITILIZATION = 2;\n  static final int SUCCESSFUL_INITILIZATION = 3;\n\n  static final int GET_SINGLETON_INEXISTENT = 1;\n  static final int GET_SINGLETON_EXISTS = 2;\n\n  static int INITIALIZATION_STATE = UNINITIALIZED;\n  static int GET_SINGLETON_METHOD = UNINITIALIZED;\n  static SubstituteLoggerFactory TEMP_FACTORY = new SubstituteLoggerFactory();\n\n  /**\n   * It is our responsibility to track version changes and manage the\n   * compatibility list.\n   * \n   * <p>\n   */\n  static private final String[] API_COMPATIBILITY_LIST = new String[] {\n      \"1.5.5\", \"1.5.6\", \"1.5.7\", \"1.5.8\", \"1.5.9\" };\n\n  // private constructor prevents instantiation\n  private LoggerFactory() {\n  }\n\n  /**\n   * Force LoggerFactory to consider itself uninitialized.\n   * \n   * <p>\n   * This method is intended to be called by classes (in the same package) for\n   * testing purposes. This method is internal. It can be modified, renamed or\n   * removed at any time without notice.\n   * \n   * <p>\n   * You are strongly discouraged from calling this method in production code.\n   */\n  static void reset() {\n    INITIALIZATION_STATE = UNINITIALIZED;\n    GET_SINGLETON_METHOD = UNINITIALIZED;\n    TEMP_FACTORY = new SubstituteLoggerFactory();\n  }\n\n  private final static void performInitialization() {\n    bind();\n    versionSanityCheck();\n    singleImplementationSanityCheck();\n\n  }\n\n  private final static void bind() {\n    try {\n      // the next line does the binding\n      getSingleton();\n      INITIALIZATION_STATE = SUCCESSFUL_INITILIZATION;\n      emitSubstituteLoggerWarning();\n    } catch (NoClassDefFoundError ncde) {\n      INITIALIZATION_STATE = FAILED_INITILIZATION;\n      String msg = ncde.getMessage();\n      if (msg != null && msg.indexOf(\"org/slf4j/impl/StaticLoggerBinder\") != -1) {\n        Util\n            .reportFailure(\"Failed to load class \\\"org.slf4j.impl.StaticLoggerBinder\\\".\");\n        Util.reportFailure(\"See \" + NO_STATICLOGGERBINDER_URL\n            + \" for further details.\");\n\n      }\n      throw ncde;\n    } catch (Exception e) {\n      INITIALIZATION_STATE = FAILED_INITILIZATION;\n      // we should never get here\n      Util.reportFailure(\"Failed to instantiate logger [\"\n          + getSingleton().getLoggerFactoryClassStr() + \"]\", e);\n    }\n  }\n\n  private final static void emitSubstituteLoggerWarning() {\n    List loggerNameList = TEMP_FACTORY.getLoggerNameList();\n    if (loggerNameList.size() == 0) {\n      return;\n    }\n    Util\n        .reportFailure(\"The following loggers will not work becasue they were created\");\n    Util\n        .reportFailure(\"during the default configuration phase of the underlying logging system.\");\n    Util.reportFailure(\"See also \" + SUBSTITUTE_LOGGER_URL);\n    for (int i = 0; i < loggerNameList.size(); i++) {\n      String loggerName = (String) loggerNameList.get(i);\n      Util.reportFailure(loggerName);\n    }\n  }\n\n  private final static void versionSanityCheck() {\n    try {\n      String requested = StaticLoggerBinder.REQUESTED_API_VERSION;\n\n      boolean match = false;\n      for (int i = 0; i < API_COMPATIBILITY_LIST.length; i++) {\n        if (API_COMPATIBILITY_LIST[i].equals(requested)) {\n          match = true;\n        }\n      }\n      if (!match) {\n        Util.reportFailure(\"The requested version \" + requested\n            + \" by your slf4j binding is not compatible with \"\n            + Arrays.asList(API_COMPATIBILITY_LIST).toString());\n        Util.reportFailure(\"See \" + VERSION_MISMATCH + \" for further details.\");\n      }\n    } catch (java.lang.NoSuchFieldError nsfe) {\n      // given our large user base and SLF4J's commitment to backward\n      // compatibility, we cannot cry here. Only for implementations\n      // which willingly declare a REQUESTED_API_VERSION field do we\n      // emit compatibility warnings.\n    } catch (Throwable e) {\n      // we should never reach here\n      Util.reportFailure(\n          \"Unexpected problem occured during version sanity check\", e);\n    }\n  }\n\n  // We need to use the name of the StaticLoggerBinder class, we can't reference\n  // the class itseld.\n  private static String STATIC_LOGGER_BINDER_PATH = \"org/slf4j/impl/StaticLoggerBinder.class\";\n\n  private static void singleImplementationSanityCheck() {\n    try {\n      ClassLoader loggerFactoryClassLoader = LoggerFactory.class.getClassLoader();\n      if(loggerFactoryClassLoader == null) {\n        // see http://bugzilla.slf4j.org/show_bug.cgi?id=146\n        return; // better than a null pointer exception\n      }\n      Enumeration paths = loggerFactoryClassLoader.getResources(\n          STATIC_LOGGER_BINDER_PATH);\n      List implementationList = new ArrayList();\n      while (paths.hasMoreElements()) {\n        URL path = (URL) paths.nextElement();\n        implementationList.add(path);\n      }\n      if (implementationList.size() > 1) {\n        Util\n            .reportFailure(\"Class path contains multiple SLF4J bindings.\");\n        for(int i = 0; i < implementationList.size(); i++) {\n          Util.reportFailure(\"Found binding in [\"+implementationList.get(i)+\"]\");\n        }\n        Util.reportFailure(\"See \" + MULTIPLE_BINDINGS_URL\n            + \" for an explanation.\");\n      }\n    } catch (IOException ioe) {\n      Util.reportFailure(\"Error getting resources from path\", ioe);\n    }\n  }\n\n  private final static StaticLoggerBinder getSingleton() {\n    if (GET_SINGLETON_METHOD == GET_SINGLETON_INEXISTENT) {\n      return StaticLoggerBinder.SINGLETON;\n    }\n\n    if (GET_SINGLETON_METHOD == GET_SINGLETON_EXISTS) {\n      return StaticLoggerBinder.getSingleton();\n    }\n\n    try {\n      StaticLoggerBinder singleton = StaticLoggerBinder.getSingleton();\n      GET_SINGLETON_METHOD = GET_SINGLETON_EXISTS;\n      return singleton;\n    } catch (NoSuchMethodError nsme) {\n      GET_SINGLETON_METHOD = GET_SINGLETON_INEXISTENT;\n      return StaticLoggerBinder.SINGLETON;\n    }\n\n  }\n\n  /**\n   * Return a logger named according to the name parameter using the statically\n   * bound {@link ILoggerFactory} instance.\n   * \n   * @param name\n   *                The name of the logger.\n   * @return logger\n   */\n  public static Logger getLogger(String name) {\n    ILoggerFactory iLoggerFactory = getILoggerFactory();\n    return iLoggerFactory.getLogger(name);\n  }\n\n  /**\n   * Return a logger named corresponding to the class passed as parameter, using\n   * the statically bound {@link ILoggerFactory} instance.\n   * \n   * @param clazz\n   *                the returned logger will be named after clazz\n   * @return logger\n   */\n  public static Logger getLogger(Class clazz) {\n    return getLogger(clazz.getName());\n  }\n\n  /**\n   * Return the {@link ILoggerFactory} instance in use.\n   * \n   * <p>\n   * ILoggerFactory instance is bound with this class at compile time.\n   * \n   * @return the ILoggerFactory instance in use\n   */\n  public static ILoggerFactory getILoggerFactory() {\n    if (INITIALIZATION_STATE == UNINITIALIZED) {\n      INITIALIZATION_STATE = ONGOING_INITILIZATION;\n      performInitialization();\n\n    }\n    switch (INITIALIZATION_STATE) {\n    case SUCCESSFUL_INITILIZATION:\n      return getSingleton().getLoggerFactory();\n    case FAILED_INITILIZATION:\n      throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);\n    case ONGOING_INITILIZATION:\n      // support re-entrant behavior.\n      // See also http://bugzilla.slf4j.org/show_bug.cgi?id=106\n      return TEMP_FACTORY;\n    }\n    throw new IllegalStateException(\"Unreachable code\");\n  }\n}\n","Smelly Sample":"/*\n * Copyright (c) 2004-2008 QOS.ch\n * All rights reserved.\n * \n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n * \n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n * \n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage org.slf4j;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.List;\n\nimport org.slf4j.helpers.SubstituteLoggerFactory;\nimport org.slf4j.helpers.Util;\nimport org.slf4j.impl.StaticLoggerBinder;\n\n/**\n * The <code>LoggerFactory<\/code> is a utility class producing Loggers for\n * various logging APIs, most notably for log4j, logback and JDK 1.4 logging.\n * Other implementations such as {@link org.slf4j.impl.NOPLogger NOPLogger} and\n * {@link org.slf4j.impl.SimpleLogger SimpleLogger} are also supported.\n * \n * <p>\n * <code>LoggerFactory<\/code> is essentially a wrapper around an\n * {@link ILoggerFactory} instance bound with <code>LoggerFactory<\/code> at\n * compile time.\n * \n * <p>\n * Please note that all methods in <code>LoggerFactory<\/code> are static.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Robert Elliot\n */\npublic final class LoggerFactory {\n\n  static final String NO_STATICLOGGERBINDER_URL = \"http://www.slf4j.org/codes.html#StaticLoggerBinder\";\n  static final String MULTIPLE_BINDINGS_URL = \"http://www.slf4j.org/codes.html#multiple_bindings\";\n  static final String NULL_LF_URL = \"http://www.slf4j.org/codes.html#null_LF\";\n  static final String VERSION_MISMATCH = \"http://www.slf4j.org/codes.html#version_mismatch\";\n  static final String SUBSTITUTE_LOGGER_URL = \"http://www.slf4j.org/codes.html#substituteLogger\";\n\n  static final String UNSUCCESSFUL_INIT_URL = \"http://www.slf4j.org/codes.html#unsuccessfulInit\";\n  static final String UNSUCCESSFUL_INIT_MSG = \"org.slf4j.LoggerFactory could not be successfully initialized. See also \"\n      + UNSUCCESSFUL_INIT_URL;\n\n  static final int UNINITIALIZED = 0;\n  static final int ONGOING_INITILIZATION = 1;\n  static final int FAILED_INITILIZATION = 2;\n  static final int SUCCESSFUL_INITILIZATION = 3;\n\n  static final int GET_SINGLETON_INEXISTENT = 1;\n  static final int GET_SINGLETON_EXISTS = 2;\n\n  static int INITIALIZATION_STATE = UNINITIALIZED;\n  static int GET_SINGLETON_METHOD = UNINITIALIZED;\n  static SubstituteLoggerFactory TEMP_FACTORY = new SubstituteLoggerFactory();\n\n  /**\n   * It is our responsibility to track version changes and manage the\n   * compatibility list.\n   * \n   * <p>\n   */\n  static private final String[] API_COMPATIBILITY_LIST = new String[] {\n      \"1.5.5\", \"1.5.6\", \"1.5.7\", \"1.5.8\", \"1.5.9\" };\n\n  // private constructor prevents instantiation\n  private LoggerFactory() {\n  }\n\n  /**\n   * Force LoggerFactory to consider itself uninitialized.\n   * \n   * <p>\n   * This method is intended to be called by classes (in the same package) for\n   * testing purposes. This method is internal. It can be modified, renamed or\n   * removed at any time without notice.\n   * \n   * <p>\n   * You are strongly discouraged from calling this method in production code.\n   */\n  static void reset() {\n    INITIALIZATION_STATE = UNINITIALIZED;\n    GET_SINGLETON_METHOD = UNINITIALIZED;\n    TEMP_FACTORY = new SubstituteLoggerFactory();\n  }\n\n  private final static void performInitialization() {\n    bind();\n    versionSanityCheck();\n    singleImplementationSanityCheck();\n\n  }\n\n  private final static void bind() {\n    try {\n      // the next line does the binding\n      getSingleton();\n      INITIALIZATION_STATE = SUCCESSFUL_INITILIZATION;\n      emitSubstituteLoggerWarning();\n    } catch (NoClassDefFoundError ncde) {\n      INITIALIZATION_STATE = FAILED_INITILIZATION;\n      String msg = ncde.getMessage();\n      if (msg != null && msg.indexOf(\"org/slf4j/impl/StaticLoggerBinder\") != -1) {\n        Util\n            .reportFailure(\"Failed to load class \\\"org.slf4j.impl.StaticLoggerBinder\\\".\");\n        Util.reportFailure(\"See \" + NO_STATICLOGGERBINDER_URL\n            + \" for further details.\");\n\n      }\n      throw ncde;\n    } catch (Exception e) {\n      INITIALIZATION_STATE = FAILED_INITILIZATION;\n      // we should never get here\n      Util.reportFailure(\"Failed to instantiate logger [\"\n          + getSingleton().getLoggerFactoryClassStr() + \"]\", e);\n    }\n  }\n\n  private final static void emitSubstituteLoggerWarning() {\n    List loggerNameList = TEMP_FACTORY.getLoggerNameList();\n    if (loggerNameList.size() == 0) {\n      return;\n    }\n    Util\n        .reportFailure(\"The following loggers will not work becasue they were created\");\n    Util\n        .reportFailure(\"during the default configuration phase of the underlying logging system.\");\n    Util.reportFailure(\"See also \" + SUBSTITUTE_LOGGER_URL);\n    for (int i = 0; i < loggerNameList.size(); i++) {\n      String loggerName = (String) loggerNameList.get(i);\n      Util.reportFailure(loggerName);\n    }\n  }\n\n  private final static void versionSanityCheck() {\n    try {\n      String requested = StaticLoggerBinder.REQUESTED_API_VERSION;\n\n      boolean match = false;\n      for (int i = 0; i < API_COMPATIBILITY_LIST.length; i++) {\n        if (API_COMPATIBILITY_LIST[i].equals(requested)) {\n          match = true;\n        }\n      }\n      if (!match) {\n        Util.reportFailure(\"The requested version \" + requested\n            + \" by your slf4j binding is not compatible with \"\n            + Arrays.asList(API_COMPATIBILITY_LIST).toString());\n        Util.reportFailure(\"See \" + VERSION_MISMATCH + \" for further details.\");\n      }\n    } catch (java.lang.NoSuchFieldError nsfe) {\n      // given our large user base and SLF4J's commitment to backward\n      // compatibility, we cannot cry here. Only for implementations\n      // which willingly declare a REQUESTED_API_VERSION field do we\n      // emit compatibility warnings.\n    } catch (Throwable e) {\n      // we should never reach here\n      Util.reportFailure(\n          \"Unexpected problem occured during version sanity check\", e);\n    }\n  }\n\n  // We need to use the name of the StaticLoggerBinder class, we can't reference\n  // the class itseld.\n  private static String STATIC_LOGGER_BINDER_PATH = \"org/slf4j/impl/StaticLoggerBinder.class\";\n\n  private static void singleImplementationSanityCheck() {\n    try {\n      Enumeration paths = LoggerFactory.class.getClassLoader().getResources(\n          STATIC_LOGGER_BINDER_PATH);\n      List implementationList = new ArrayList();\n      while (paths.hasMoreElements()) {\n        URL path = (URL) paths.nextElement();\n        implementationList.add(path);\n      }\n      if (implementationList.size() > 1) {\n        Util\n            .reportFailure(\"Class path contains multiple SLF4J bindings.\");\n        for(int i = 0; i < implementationList.size(); i++) {\n          Util.reportFailure(\"Found binding in [\"+implementationList.get(i)+\"]\");\n        }\n        Util.reportFailure(\"See \" + MULTIPLE_BINDINGS_URL\n            + \" for an explanation.\");\n      }\n    } catch (IOException ioe) {\n      Util.reportFailure(\"Error getting resources from path\", ioe);\n    }\n  }\n\n  private final static StaticLoggerBinder getSingleton() {\n    if (GET_SINGLETON_METHOD == GET_SINGLETON_INEXISTENT) {\n      return StaticLoggerBinder.SINGLETON;\n    }\n\n    if (GET_SINGLETON_METHOD == GET_SINGLETON_EXISTS) {\n      return StaticLoggerBinder.getSingleton();\n    }\n\n    try {\n      StaticLoggerBinder singleton = StaticLoggerBinder.getSingleton();\n      GET_SINGLETON_METHOD = GET_SINGLETON_EXISTS;\n      return singleton;\n    } catch (NoSuchMethodError nsme) {\n      GET_SINGLETON_METHOD = GET_SINGLETON_INEXISTENT;\n      return StaticLoggerBinder.SINGLETON;\n    }\n\n  }\n\n  /**\n   * Return a logger named according to the name parameter using the statically\n   * bound {@link ILoggerFactory} instance.\n   * \n   * @param name\n   *                The name of the logger.\n   * @return logger\n   */\n  public static Logger getLogger(String name) {\n    ILoggerFactory iLoggerFactory = getILoggerFactory();\n    return iLoggerFactory.getLogger(name);\n  }\n\n  /**\n   * Return a logger named corresponding to the class passed as parameter, using\n   * the statically bound {@link ILoggerFactory} instance.\n   * \n   * @param clazz\n   *                the returned logger will be named after clazz\n   * @return logger\n   */\n  public static Logger getLogger(Class clazz) {\n    return getLogger(clazz.getName());\n  }\n\n  /**\n   * Return the {@link ILoggerFactory} instance in use.\n   * \n   * <p>\n   * ILoggerFactory instance is bound with this class at compile time.\n   * \n   * @return the ILoggerFactory instance in use\n   */\n  public static ILoggerFactory getILoggerFactory() {\n    if (INITIALIZATION_STATE == UNINITIALIZED) {\n      INITIALIZATION_STATE = ONGOING_INITILIZATION;\n      performInitialization();\n\n    }\n    switch (INITIALIZATION_STATE) {\n    case SUCCESSFUL_INITILIZATION:\n      return getSingleton().getLoggerFactory();\n    case FAILED_INITILIZATION:\n      throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);\n    case ONGOING_INITILIZATION:\n      // support re-entrant behavior.\n      // See also http://bugzilla.slf4j.org/show_bug.cgi?id=106\n      return TEMP_FACTORY;\n    }\n    throw new IllegalStateException(\"Unreachable code\");\n  }\n}\n","lineNo":191}
{"Refactored Sample":"/* \n * Copyright (c) 2004-2007 QOS.ch\n * All rights reserved.\n * \n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n * \n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n * \n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage org.slf4j.helpers;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n// contributors: lizongbo: proposed special treatment of array parameter values\n// Jrn Huxhorn: pointed out double[] omission, suggested deep array copy\n/**\n * Formats messages according to very simple substitution rules. Substitutions\n * can be made 1, 2 or more arguments.\n * <p>\n * For example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Hi {}.&quot;, &quot;there&quot;)\n * <\/pre>\n * \n * will return the string \"Hi there.\".\n * <p>\n * The {} pair is called the <em>formatting anchor<\/em>. It serves to\n * designate the location where arguments need to be substituted within the\n * message pattern.\n * <p>\n * In case your message contains the '{' or the '}' character, you do not have\n * to do anything special unless the '}' character immediately follows '{'. For\n * example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Set {1,2,3} is not equal to {}.&quot;, &quot;1,2&quot;);\n * <\/pre>\n * \n * will return the string \"Set {1,2,3} is not equal to 1,2.\".\n * \n * <p>\n * If for whatever reason you need to place the string \"{}\" in the message\n * without its <em>formatting anchor<\/em> meaning, then you need to escape the\n * '{' character with '\\', that is the backslash character. Only the '{'\n * character should be escaped. There is no need to escape the '}' character.\n * For example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Set \\\\{} is not equal to {}.&quot;, &quot;1,2&quot;);\n * <\/pre>\n * \n * will return the string \"Set {} is not equal to 1,2.\".\n * \n * <p>\n * The escaping behavior just described can be overridden by escaping the escape\n * character '\\'. Calling\n * \n * <pre>\n * MessageFormatter.format(&quot;File name is C:\\\\\\\\{}.&quot;, &quot;file.zip&quot;);\n * <\/pre>\n * \n * will return the string \"File name is C:\\file.zip\".\n * \n * <p>\n * See {@link #format(String, Object)}, {@link #format(String, Object, Object)}\n * and {@link #arrayFormat(String, Object[])} methods for more details.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\nfinal public class MessageFormatter {\n  static final char DELIM_START = '{';\n  static final char DELIM_STOP = '}';\n  static final String DELIM_STR = \"{}\";\n  private static final char ESCAPE_CHAR = '\\\\';\n\n  /**\n   * Performs single argument substitution for the 'messagePattern' passed as\n   * parameter.\n   * <p>\n   * For example,\n   * \n   * <pre>\n   * MessageFormatter.format(&quot;Hi {}.&quot;, &quot;there&quot;);\n   * <\/pre>\n   * \n   * will return the string \"Hi there.\".\n   * <p>\n   * \n   * @param messagePattern\n   *                The message pattern which will be parsed and formatted\n   * @param argument\n   *                The argument to be substituted in place of the formatting\n   *                anchor\n   * @return The formatted message\n   */\n  final public static String format(String messagePattern, Object arg) {\n    return arrayFormat(messagePattern, new Object[] { arg });\n  }\n\n  /**\n   * \n   * Performs a two argument substitution for the 'messagePattern' passed as\n   * parameter.\n   * <p>\n   * For example,\n   * \n   * <pre>\n   * MessageFormatter.format(&quot;Hi {}. My name is {}.&quot;, &quot;Alice&quot;, &quot;Bob&quot;);\n   * <\/pre>\n   * \n   * will return the string \"Hi Alice. My name is Bob.\".\n   * \n   * @param messagePattern\n   *                The message pattern which will be parsed and formatted\n   * @param arg1\n   *                The argument to be substituted in place of the first\n   *                formatting anchor\n   * @param arg2\n   *                The argument to be substituted in place of the second\n   *                formatting anchor\n   * @return The formatted message\n   */\n  final public static String format(final String messagePattern, Object arg1,\n      Object arg2) {\n    return arrayFormat(messagePattern, new Object[] { arg1, arg2 });\n  }\n\n  /**\n   * Same principle as the {@link #format(String, Object)} and\n   * {@link #format(String, Object, Object)} methods except that any number of\n   * arguments can be passed in an array.\n   * \n   * @param messagePattern\n   *                The message pattern which will be parsed and formatted\n   * @param argArray\n   *                An array of arguments to be substituted in place of\n   *                formatting anchors\n   * @return The formatted message\n   */\n  final public static String arrayFormat(final String messagePattern,\n      final Object[] argArray) {\n    if (messagePattern == null) {\n      return null;\n    }\n    if (argArray == null) {\n      return messagePattern;\n    }\n    int i = 0;\n    int j;\n    StringBuffer sbuf = new StringBuffer(messagePattern.length() + 50);\n\n    for (int L = 0; L < argArray.length; L++) {\n\n      j = messagePattern.indexOf(DELIM_STR, i);\n\n      if (j == -1) {\n        // no more variables\n        if (i == 0) { // this is a simple string\n          return messagePattern;\n        } else { // add the tail string which contains no variables and return\n          // the result.\n          sbuf.append(messagePattern.substring(i, messagePattern.length()));\n          return sbuf.toString();\n        }\n      } else {\n        if (isEscapedDelimeter(messagePattern, j)) {\n          if (!isDoubleEscaped(messagePattern, j)) {\n            L--; // DELIM_START was escaped, thus should not be incremented\n            sbuf.append(messagePattern.substring(i, j - 1));\n            sbuf.append(DELIM_START);\n            i = j + 1;\n          } else {\n            // The escape character preceding the delimiter start is\n            // itself escaped: \"abc x:\\\\{}\"\n            // we have to consume one backward slash\n            sbuf.append(messagePattern.substring(i, j - 1));\n            deeplyAppendParameter(sbuf, argArray[L], new HashMap());\n            i = j + 2;\n          }\n        } else {\n          // normal case\n          sbuf.append(messagePattern.substring(i, j));\n          deeplyAppendParameter(sbuf, argArray[L], new HashMap());\n          i = j + 2;\n        }\n      }\n    }\n    // append the characters following the last {} pair.\n    sbuf.append(messagePattern.substring(i, messagePattern.length()));\n    return sbuf.toString();\n  }\n\n  final static boolean isEscapedDelimeter(String messagePattern,\n      int delimeterStartIndex) {\n\n    if (delimeterStartIndex == 0) {\n      return false;\n    }\n    char potentialEscape = messagePattern.charAt(delimeterStartIndex - 1);\n    if (potentialEscape == ESCAPE_CHAR) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  final static boolean isDoubleEscaped(String messagePattern,\n      int delimeterStartIndex) {\n    if (delimeterStartIndex >= 2\n        && messagePattern.charAt(delimeterStartIndex - 2) == ESCAPE_CHAR) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  // special treatment of array values was suggested by 'lizongbo'\n  private static void deeplyAppendParameter(StringBuffer sbuf, Object o,\n      Map seenMap) {\n    if (o == null) {\n      sbuf.append(\"null\");\n      return;\n    }\n    if (!o.getClass().isArray()) {\n      safeObjectAppend(sbuf, o);\n    } else {\n      // check for primitive array types because they\n      // unfortunately cannot be cast to Object[]\n      if (o instanceof boolean[]) {\n        booleanArrayAppend(sbuf, (boolean[]) o);\n      } else if (o instanceof byte[]) {\n        byteArrayAppend(sbuf, (byte[]) o);\n      } else if (o instanceof char[]) {\n        charArrayAppend(sbuf, (char[]) o);\n      } else if (o instanceof short[]) {\n        shortArrayAppend(sbuf, (short[]) o);\n      } else if (o instanceof int[]) {\n        intArrayAppend(sbuf, (int[]) o);\n      } else if (o instanceof long[]) {\n        longArrayAppend(sbuf, (long[]) o);\n      } else if (o instanceof float[]) {\n        floatArrayAppend(sbuf, (float[]) o);\n      } else if (o instanceof double[]) {\n        doubleArrayAppend(sbuf, (double[]) o);\n      } else {\n        objectArrayAppend(sbuf, (Object[]) o, seenMap);\n      }\n    }\n  }\n\n  private static void safeObjectAppend(StringBuffer sbuf, Object o) {\n    try {\n      String oAsString = o.toString();\n      sbuf.append(oAsString);\n    } catch( Throwable t) {\n      System.err.println(\"SLF4J: Failed toString() invocation on an object of type [\"+o.getClass().getName()+\"]\");\n      t.printStackTrace();\n      sbuf.append(\"[FAILED toString()]\");\n    }\n\n  }\n\n  private static void objectArrayAppend(StringBuffer sbuf, Object[] a,\n      Map seenMap) {\n    sbuf.append('[');\n    if (!seenMap.containsKey(a)) {\n      seenMap.put(a, null);\n      final int len = a.length;\n      for (int i = 0; i < len; i++) {\n        deeplyAppendParameter(sbuf, a[i], seenMap);\n        if (i != len - 1)\n          sbuf.append(\", \");\n      }\n      // allow repeats in siblings\n      seenMap.remove(a);\n    } else {\n      sbuf.append(\"...\");\n    }\n    sbuf.append(']');\n  }\n\n  private static void booleanArrayAppend(StringBuffer sbuf, boolean[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void byteArrayAppend(StringBuffer sbuf, byte[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void charArrayAppend(StringBuffer sbuf, char[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void shortArrayAppend(StringBuffer sbuf, short[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void intArrayAppend(StringBuffer sbuf, int[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void longArrayAppend(StringBuffer sbuf, long[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void floatArrayAppend(StringBuffer sbuf, float[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void doubleArrayAppend(StringBuffer sbuf, double[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n}\n","Smelly Sample":"/* \n * Copyright (c) 2004-2007 QOS.ch\n * All rights reserved.\n * \n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n * \n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n * \n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage org.slf4j.helpers;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n// contributors: lizongbo: proposed special treatment of array parameter values\n// Jrn Huxhorn: pointed out double[] omission, suggested deep array copy\n/**\n * Formats messages according to very simple substitution rules. Substitutions\n * can be made 1, 2 or more arguments.\n * <p>\n * For example,\n * \n * <pre>MessageFormatter.format(&quot;Hi {}.&quot;, &quot;there&quot;)<\/pre>\n * \n * will return the string \"Hi there.\".\n * <p>\n * The {} pair is called the <em>formatting anchor<\/em>. It serves to\n * designate the location where arguments need to be substituted within the\n * message pattern.\n * <p>\n * In case your message contains the '{' or the '}' character, you do not have\n * to do anything special unless the '}' character immediately follows '{'. For\n * example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Set {1,2,3} is not equal to {}.&quot;, &quot;1,2&quot;);\n * <\/pre>\n * \n * will return the string \"Set {1,2,3} is not equal to 1,2.\".\n * \n * <p>If for whatever reason you need to place the string \"{}\" in the message\n * without its <em>formatting anchor<\/em> meaning, then you need to escape the\n * '{' character with '\\', that is the backslash character. Only the '{'\n * character should be escaped. There is no need to escape the '}' character.\n * For example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Set \\\\{} is not equal to {}.&quot;, &quot;1,2&quot;);\n * <\/pre>\n * \n * will return the string \"Set {} is not equal to 1,2.\".\n * \n * <p>\n * The escaping behavior just described can be overridden by escaping the escape\n * character '\\'. Calling\n * \n * <pre>\n * MessageFormatter.format(&quot;File name is C:\\\\\\\\{}.&quot;, &quot;file.zip&quot;);\n * <\/pre>\n * \n * will return the string \"File name is C:\\file.zip\".\n * \n * <p>\n * See {@link #format(String, Object)}, {@link #format(String, Object, Object)}\n * and {@link #arrayFormat(String, Object[])} methods for more details.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\nfinal public class MessageFormatter {\n  static final char DELIM_START = '{';\n  static final char DELIM_STOP = '}';\n  static final String DELIM_STR = \"{}\";\n  private static final char ESCAPE_CHAR = '\\\\';\n\n  /**\n   * Performs single argument substitution for the 'messagePattern' passed as\n   * parameter.\n   * <p>\n   * For example,\n   * \n   * <pre>\n   * MessageFormatter.format(&quot;Hi {}.&quot;, &quot;there&quot;);\n   * <\/pre>\n   * \n   * will return the string \"Hi there.\".\n   * <p>\n   * \n   * @param messagePattern\n   *                The message pattern which will be parsed and formatted\n   * @param argument\n   *                The argument to be substituted in place of the formatting\n   *                anchor\n   * @return The formatted message\n   */\n  final public static String format(String messagePattern, Object arg) {\n    return arrayFormat(messagePattern, new Object[] { arg });\n  }\n\n  /**\n   * \n   * Performs a two argument substitution for the 'messagePattern' passed as\n   * parameter.\n   * <p>\n   * For example,\n   * \n   * <pre>\n   * MessageFormatter.format(&quot;Hi {}. My name is {}.&quot;, &quot;Alice&quot;, &quot;Bob&quot;);\n   * <\/pre>\n   * \n   * will return the string \"Hi Alice. My name is Bob.\".\n   * \n   * @param messagePattern\n   *                The message pattern which will be parsed and formatted\n   * @param arg1\n   *                The argument to be substituted in place of the first\n   *                formatting anchor\n   * @param arg2\n   *                The argument to be substituted in place of the second\n   *                formatting anchor\n   * @return The formatted message\n   */\n  final public static String format(final String messagePattern, Object arg1, Object arg2) {\n    return arrayFormat(messagePattern, new Object[] { arg1, arg2 });\n  }\n\n  /**\n   * Same principle as the {@link #format(String, Object)} and\n   * {@link #format(String, Object, Object)} methods except that any number of\n   * arguments can be passed in an array.\n   * \n   * @param messagePattern\n   *                The message pattern which will be parsed and formatted\n   * @param argArray\n   *                An array of arguments to be substituted in place of\n   *                formatting anchors\n   * @return The formatted message\n   */\n  final public static String arrayFormat(final String messagePattern,\n      final Object[] argArray) {\n    if (messagePattern == null) {\n      return null;\n    }\n    if (argArray == null) {\n      return messagePattern;\n    }\n    int i = 0;\n    int j;\n    StringBuffer sbuf = new StringBuffer(messagePattern.length() + 50);\n\n    for (int L = 0; L < argArray.length; L++) {\n\n      j = messagePattern.indexOf(DELIM_STR, i);\n\n      if (j == -1) {\n        // no more variables\n        if (i == 0) { // this is a simple string\n          return messagePattern;\n        } else { // add the tail string which contains no variables and return\n          // the result.\n          sbuf.append(messagePattern.substring(i, messagePattern.length()));\n          return sbuf.toString();\n        }\n      } else {\n        if (isEscapedDelimeter(messagePattern, j)) {\n          if (!isDoubleEscaped(messagePattern, j)) {\n            L--; // DELIM_START was escaped, thus should not be incremented\n            sbuf.append(messagePattern.substring(i, j - 1));\n            sbuf.append(DELIM_START);\n            i = j + 1;\n          } else {\n            // The escape character preceding the delemiter start is\n            // itself escaped: \"abc x:\\\\{}\"\n            // we have to consume one backward slash\n            sbuf.append(messagePattern.substring(i, j - 1));\n            deeplyAppendParameter(sbuf, argArray[L], new HashMap());\n            i = j + 2;\n          }\n        } else {\n          // normal case\n          sbuf.append(messagePattern.substring(i, j));\n          deeplyAppendParameter(sbuf, argArray[L], new HashMap());\n          i = j + 2;\n        }\n      }\n    }\n    // append the characters following the last {} pair.\n    sbuf.append(messagePattern.substring(i, messagePattern.length()));\n    return sbuf.toString();\n  }\n\n  final static boolean isEscapedDelimeter(String messagePattern,\n      int delimeterStartIndex) {\n\n    if (delimeterStartIndex == 0) {\n      return false;\n    }\n    char potentialEscape = messagePattern.charAt(delimeterStartIndex - 1);\n    if (potentialEscape == ESCAPE_CHAR) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  final static boolean isDoubleEscaped(String messagePattern, int delimeterStartIndex) {\n    if (delimeterStartIndex >= 2\n        && messagePattern.charAt(delimeterStartIndex - 2) == ESCAPE_CHAR) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  // special treatment of array values was suggested by 'lizongbo'\n  private static void deeplyAppendParameter(StringBuffer sbuf, Object o,\n      Map seenMap) {\n    if (o == null) {\n      sbuf.append(\"null\");\n      return;\n    }\n    if (!o.getClass().isArray()) {\n      sbuf.append(o);\n    } else {\n      // check for primitive array types because they\n      // unfortunately cannot be cast to Object[]\n      if (o instanceof boolean[]) {\n        booleanArrayAppend(sbuf, (boolean[]) o);\n      } else if (o instanceof byte[]) {\n        byteArrayAppend(sbuf, (byte[]) o);\n      } else if (o instanceof char[]) {\n        charArrayAppend(sbuf, (char[]) o);\n      } else if (o instanceof short[]) {\n        shortArrayAppend(sbuf, (short[]) o);\n      } else if (o instanceof int[]) {\n        intArrayAppend(sbuf, (int[]) o);\n      } else if (o instanceof long[]) {\n        longArrayAppend(sbuf, (long[]) o);\n      } else if (o instanceof float[]) {\n        floatArrayAppend(sbuf, (float[]) o);\n      } else if (o instanceof double[]) {\n        doubleArrayAppend(sbuf, (double[]) o);\n      } else {\n        objectArrayAppend(sbuf, (Object[]) o, seenMap);\n      }\n    }\n  }\n\n  private static void objectArrayAppend(StringBuffer sbuf, Object[] a,\n      Map seenMap) {\n    sbuf.append('[');\n    if (!seenMap.containsKey(a)) {\n      seenMap.put(a, null);\n      final int len = a.length;\n      for (int i = 0; i < len; i++) {\n        deeplyAppendParameter(sbuf, a[i], seenMap);\n        if (i != len - 1)\n          sbuf.append(\", \");\n      }\n      // allow repeats in siblings\n      seenMap.remove(a);\n    } else {\n      sbuf.append(\"...\");\n    }\n    sbuf.append(']');\n  }\n\n  private static void booleanArrayAppend(StringBuffer sbuf, boolean[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void byteArrayAppend(StringBuffer sbuf, byte[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void charArrayAppend(StringBuffer sbuf, char[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void shortArrayAppend(StringBuffer sbuf, short[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void intArrayAppend(StringBuffer sbuf, int[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void longArrayAppend(StringBuffer sbuf, long[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void floatArrayAppend(StringBuffer sbuf, float[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void doubleArrayAppend(StringBuffer sbuf, double[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n}\n","lineNo":270}
{"Refactored Sample":"package org.slf4j.instrumentation;\n\nimport java.util.Map;\nimport java.util.WeakHashMap;\n\npublic class ToStringHelper {\n\n\t/**\n\t * Prefix to use at the start of the representation. Always used.\n\t */\n\tprivate static final String ARRAY_PREFIX = \"[\";\n\n\t/**\n\t * Suffix to use at the end of the representation. Always used.\n\t */\n\tprivate static final String ARRAY_SUFFIX = \"]\";\n\n\t/**\n\t * String separating each element when rendering an array. To be compatible\n\t * with lists comma-space is used.\n\t */\n\n\tprivate static final String ELEMENT_SEPARATOR = \", \";\n\n\t/**\n\t * unrenderableClasses is essentially a Set of Class objects which has for\n\t * some reason failed to render properly when invoked through a toString\n\t * method call. To avoid memory leaks a data structure using weak references\n\t * is needed, but unfortunately the runtime library does not contain a\n\t * WeakHashSet class, so the behavior is emulated with a WeakHashmap with\n\t * the class as the key, and a Long containing the value of\n\t * System.currentTimeMilis when an instance of the class failed to render.\n\t */\n\n\tfinal static Map<Class<?>, Object> unrenderableClasses = new WeakHashMap<Class<?>, Object>();\n\n\t/**\n\t * Returns o.toString() unless it throws an exception (which causes it to be\n\t * stored in unrenderableClasses) or already was present in\n\t * unrenderableClasses. If so, the same string is returned as would have\n\t * been returned by Object.toString(). Arrays get special treatment as they\n\t * don't have usable toString methods.\n\t * \n\t * @param o\n\t *            incoming object to render.\n\t * @return\n\t */\n\n\tpublic static String render(Object o) {\n\t\tif (o == null) {\n\t\t\treturn String.valueOf(o);\n\t\t}\n\t\tClass<?> objectClass = o.getClass();\n\n\t\tif (unrenderableClasses.containsKey(objectClass) == false) {\n\t\t\ttry {\n\t\t\t\tif (objectClass.isArray()) {\n\t\t\t\t\treturn renderArray(o, objectClass).toString();\n\t\t\t\t} else {\n\t\t\t\t\treturn o.toString();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLong now = new Long(System.currentTimeMillis());\n\n\t\t\t\tSystem.err.println(\"Disabling exception throwing class \"\n\t\t\t\t\t\t+ objectClass.getName() + \", \" + e.getMessage());\n\n\t\t\t\tunrenderableClasses.put(objectClass, now);\n\t\t\t}\n\t\t}\n\t\tString name = o.getClass().getName();\n\t\treturn name + \"@\" + Integer.toHexString(o.hashCode());\n\t}\n\n\t/**\n\t * renderArray returns an array similar to a List. If the array type is an\n\t * object they are rendered with \"render(object)\" for each. If the array\n\t * type is a primitive each element is added directly to the string buffer\n\t * collecting the result.\n\t * \n\t * @param o\n\t * @param objectClass\n\t * @return\n\t */\n\tprivate static StringBuffer renderArray(Object o, Class<?> objectClass) {\n\t\tClass<?> componentType = objectClass.getComponentType();\n\t\tStringBuffer sb = new StringBuffer(ARRAY_PREFIX);\n\n\t\tif (componentType.isPrimitive() == false) {\n\t\t\tObject[] oa = (Object[]) o;\n\t\t\tfor (int i = 0; i < oa.length; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t}\n\t\t\t\tsb.append(render(oa[i]));\n\t\t\t}\n\t\t} else {\n\t\t\tif (Boolean.TYPE.equals(componentType)) {\n\t\t\t\tboolean[] ba = (boolean[]) o;\n\t\t\t\tfor (int i = 0; i < ba.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ba[i]);\n\t\t\t\t}\n\t\t\t} else if (Integer.TYPE.equals(componentType)) {\n\t\t\t\tint[] ia = (int[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\n\t\t\t} else if (Long.TYPE.equals(componentType)) {\n\t\t\t\tlong[] ia = (long[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Double.TYPE.equals(componentType)) {\n\t\t\t\tdouble[] ia = (double[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Float.TYPE.equals(componentType)) {\n\t\t\t\tfloat[] ia = (float[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Character.TYPE.equals(componentType)) {\n\t\t\t\tchar[] ia = (char[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Short.TYPE.equals(componentType)) {\n\t\t\t\tshort[] ia = (short[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Byte.TYPE.equals(componentType)) {\n\t\t\t\tbyte[] ia = (byte[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsb.append(ARRAY_SUFFIX);\n\t\treturn sb;\n\t}\n}\n","Smelly Sample":"package org.slf4j.instrumentation;\n\nimport java.util.Map;\nimport java.util.WeakHashMap;\n\npublic class ToStringHelper {\n\n\t/**\n\t * Prefix to use at the start of the representation. Always used.\n\t */\n\tprivate static final String ARRAY_PREFIX = \"[\";\n\n\t/**\n\t * Suffix to use at the end of the representation. Always used.\n\t */\n\tprivate static final String ARRAY_SUFFIX = \"]\";\n\n\t/**\n\t * String separating each element when rendering an array. To be compatible\n\t * with lists comma-space is used.\n\t */\n\n\tprivate static final String ELEMENT_SEPARATOR = \", \";\n\n\t/**\n\t * unrenderableClasses is essentially a Set of Class objects which has for\n\t * some reason failed to render properly when invoked through a toString\n\t * method call. To avoid memory leaks a data structure using weak references\n\t * is needed, but unfortunately the runtime library does not contain a\n\t * WeakHashSet class, so the behavior is emulated with a WeakHashmap with\n\t * the class as the key, and a Long containing the value of\n\t * System.currentTimeMilis when an instance of the class failed to render.\n\t */\n\n\tfinal static Map<Class<?>, Object> unrenderableClasses = new WeakHashMap<Class<?>, Object>();\n\n\t/**\n\t * Returns o.toString() unless it throws an exception (which causes it to be\n\t * stored in unrenderableClasses) or already was present in\n\t * unrenderableClasses. If so, the same string is returned as would have\n\t * been returned by Object.toString(). Arrays get special treatment as they\n\t * don't have usable toString methods.\n\t * \n\t * @param o\n\t * @return\n\t */\n\tpublic static String render(Object o) {\n\t\tif (o == null) {\n\t\t\treturn String.valueOf(o);\n\t\t}\n\t\tClass<?> objectClass = o.getClass();\n\t\tif (unrenderableClasses.containsKey(objectClass) == false) {\n\t\t\ttry {\n\t\t\t\tif (objectClass.isArray()) {\n\t\t\t\t\treturn renderArray(o, objectClass).toString();\n\t\t\t\t} else {\n\t\t\t\t\treturn o.toString();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLong now = new Long(System.currentTimeMillis());\n\t\t\t\tSystem.err.println(\"Disabling exception throwing class \"\n\t\t\t\t\t\t+ objectClass.getName() + \", \" + e.getMessage());\n\t\t\t\tunrenderableClasses.put(objectClass, now);\n\t\t\t}\n\t\t}\n\t\treturn o.getClass().getName() + \"@\" + Integer.toHexString(o.hashCode());\n\t}\n\n\t/**\n\t * renderArray returns an array similar to a List. If the array type is an\n\t * object they are rendered with \"render(object)\" for each. If the array\n\t * type is a primitive each element is added directly to the string buffer\n\t * collecting the result.\n\t * \n\t * @param o\n\t * @param objectClass\n\t * @return\n\t */\n\tprivate static StringBuffer renderArray(Object o, Class<?> objectClass) {\n\t\tClass<?> componentType = objectClass.getComponentType();\n\t\tStringBuffer sb = new StringBuffer(ARRAY_PREFIX);\n\n\t\tif (componentType.isPrimitive() == false) {\n\t\t\tObject[] oa = (Object[]) o;\n\t\t\tfor (int i = 0; i < oa.length; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t}\n\t\t\t\tsb.append(render(oa[i]));\n\t\t\t}\n\t\t} else {\n\t\t\tif (Boolean.TYPE.equals(componentType)) {\n\t\t\t\tboolean[] ba = (boolean[]) o;\n\t\t\t\tfor (int i = 0; i < ba.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ba[i]);\n\t\t\t\t}\n\t\t\t} else if (Integer.TYPE.equals(componentType)) {\n\t\t\t\tint[] ia = (int[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\n\t\t\t} else if (Long.TYPE.equals(componentType)) {\n\t\t\t\tlong[] ia = (long[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Double.TYPE.equals(componentType)) {\n\t\t\t\tdouble[] ia = (double[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Float.TYPE.equals(componentType)) {\n\t\t\t\tfloat[] ia = (float[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Character.TYPE.equals(componentType)) {\n\t\t\t\tchar[] ia = (char[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Short.TYPE.equals(componentType)) {\n\t\t\t\tshort[] ia = (short[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Byte.TYPE.equals(componentType)) {\n\t\t\t\tbyte[] ia = (byte[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsb.append(ARRAY_SUFFIX);\n\t\treturn sb;\n\t}\n}\n","lineNo":71}
{"Refactored Sample":"package org.slf4j.instrumentation;\n\nimport javassist.CtBehavior;\nimport javassist.CtClass;\nimport javassist.CtMethod;\nimport javassist.Modifier;\nimport javassist.NotFoundException;\nimport javassist.bytecode.AttributeInfo;\nimport javassist.bytecode.CodeAttribute;\nimport javassist.bytecode.LocalVariableAttribute;\n\n/**\n * Helper methods for Javassist functionality.\n * \n */\npublic class JavassistHelper {\n\n  /**\n   * Create a javaassist source snippet which either is empty (for anything\n   * which does not return a value) or a explanatory text around the $_\n   * javaassist return value variable.\n   * \n   * @param method\n   *          descriptor of method\n   * @return source snippet\n   * @throws NotFoundException\n   */\n  public static String returnValue(CtBehavior method) throws NotFoundException {\n\n    String returnValue = \"\";\n    if (methodReturnsValue(method)) {\n      returnValue = \" returns: \\\" + $_ + \\\".\";\n    }\n    return returnValue;\n  }\n\n  /**\n   * determine if the given method returns a value, and return true if so. false\n   * otherwise.\n   * \n   * @param method\n   * @return\n   * @throws NotFoundException\n   */\n  private static boolean methodReturnsValue(CtBehavior method)\n      throws NotFoundException {\n\n    if (method instanceof CtMethod == false) {\n      return false;\n    }\n\n    CtClass returnType = ((CtMethod) method).getReturnType();\n    String returnTypeName = returnType.getName();\n\n    boolean isVoidMethod = \"void\".equals(returnTypeName);\n\n    boolean methodReturnsValue = isVoidMethod == false;\n    return methodReturnsValue;\n  }\n\n  /**\n   * Return javaassist source snippet which lists all the parameters and their\n   * values. If available the source names are extracted from the debug\n   * information and used, otherwise just a number is shown.\n   * \n   * @param method\n   * @return\n   * @throws NotFoundException\n   */\n  public static String getSignature(CtBehavior method) throws NotFoundException {\n\n    CtClass parameterTypes[] = method.getParameterTypes();\n\n    CodeAttribute codeAttribute = method.getMethodInfo().getCodeAttribute();\n\n    LocalVariableAttribute locals = null;\n    \n\n    if (codeAttribute != null) {\n      AttributeInfo attribute;\n      attribute = codeAttribute.getAttribute(\"LocalVariableTable\");\n      locals = (LocalVariableAttribute) attribute;\n    }\n\n    String methodName = method.getName();\n\n    StringBuffer sb = new StringBuffer(methodName + \"(\\\" \");\n    for (int i = 0; i < parameterTypes.length; i++) {\n      if (i > 0) {\n        // add a comma and a space between printed values\n        sb.append(\" + \\\", \\\" \");\n      }\n\n      CtClass parameterType = parameterTypes[i];\n      boolean isArray = parameterType.isArray();\n      CtClass arrayType = parameterType.getComponentType();\n      if (isArray) {\n        while (arrayType.isArray()) {\n          arrayType = arrayType.getComponentType();\n        }\n      }\n\n      sb.append(\" + \\\"\");\n      sb.append(parameterNameFor(method, locals, i));\n      sb.append(\"\\\" + \\\"=\");\n\n      // use Arrays.asList() to render array of objects.\n      if (isArray && !arrayType.isPrimitive()) {\n        sb.append(\"\\\"+ java.util.Arrays.asList($\" + (i + 1) + \")\");\n      } else {\n        sb.append(\"\\\"+ $\" + (i + 1));\n      }\n    }\n    sb.append(\"+\\\")\");\n\n    String signature = sb.toString();\n    return signature;\n  }\n\n  /**\n   * Determine the name of parameter with index i in the given method. Use the\n   * locals attributes about local variables from the classfile. Note: This is\n   * still work in progress.\n   * \n   * @param method\n   * @param locals\n   * @param i\n   * @return the name of the parameter if available or a number if not.\n   */\n  static String parameterNameFor(CtBehavior method,\n      LocalVariableAttribute locals, int i) {\n\n    if (locals == null) {\n      return Integer.toString(i + 1);\n    }\n\n    int modifiers = method.getModifiers();\n\n    int j = i;\n\n    if (Modifier.isSynchronized(modifiers)) {\n      // skip object to synchronize upon.\n      j++;\n      // System.err.println(\"Synchronized\");\n    }\n    if (Modifier.isStatic(modifiers) == false) {\n      // skip \"this\"\n      j++;\n      // System.err.println(\"Instance\");\n    }\n    String variableName = locals.variableName(j);\n    if (variableName.equals(\"this\")) {\n      System.err.println(\"'this' returned as a parameter name for \"\n          + method.getName() + \" index \" + j + \", names are probably shifted.\");\n    }\n    return variableName;\n  }\n}\n","Smelly Sample":"package org.slf4j.instrumentation;\n\nimport javassist.CtBehavior;\nimport javassist.CtClass;\nimport javassist.CtMethod;\nimport javassist.Modifier;\nimport javassist.NotFoundException;\nimport javassist.bytecode.CodeAttribute;\nimport javassist.bytecode.LocalVariableAttribute;\n\n/**\n * Helper methods for Javassist functionality.\n * \n */\npublic class JavassistHelper {\n\n  /**\n   * Create a javaassist source snippet which either is empty (for anything\n   * which does not return a value) or a explanatory text around the $_\n   * javaassist return value variable.\n   * \n   * @param method\n   *          descriptor of method\n   * @return source snippet\n   * @throws NotFoundException\n   */\n  public static String returnValue(CtBehavior method) throws NotFoundException {\n\n    String returnValue = \"\";\n    if (methodReturnsValue(method)) {\n      returnValue = \" returns: \\\" + $_ + \\\".\";\n    }\n    return returnValue;\n  }\n\n  /**\n   * determine if the given method returns a value, and return true if so. false\n   * otherwise.\n   * \n   * @param method\n   * @return\n   * @throws NotFoundException\n   */\n  private static boolean methodReturnsValue(CtBehavior method)\n      throws NotFoundException {\n\n    if (method instanceof CtMethod == false) {\n      return false;\n    }\n\n    CtClass returnType = ((CtMethod) method).getReturnType();\n    String returnTypeName = returnType.getName();\n\n    boolean isVoidMethod = \"void\".equals(returnTypeName);\n\n    boolean methodReturnsValue = isVoidMethod == false;\n    return methodReturnsValue;\n  }\n\n  /**\n   * Return javaassist source snippet which lists all the parameters and their\n   * values. If available the source names are extracted from the debug\n   * information and used, otherwise just a number is shown.\n   * \n   * @param method\n   * @return\n   * @throws NotFoundException\n   */\n  public static String getSignature(CtBehavior method) throws NotFoundException {\n\n    CtClass parameterTypes[] = method.getParameterTypes();\n\n    CodeAttribute codeAttribute = method.getMethodInfo().getCodeAttribute();\n\n    LocalVariableAttribute locals = null;\n\n    if (codeAttribute != null) {\n      locals = (LocalVariableAttribute) codeAttribute\n          .getAttribute(\"LocalVariableTable\");\n    }\n\n    String methodName = method.getName();\n\n    StringBuffer sb = new StringBuffer(methodName + \"(\\\" \");\n    for (int i = 0; i < parameterTypes.length; i++) {\n      if (i > 0) {\n        // add a comma and a space between printed values\n        sb.append(\" + \\\", \\\" \");\n      }\n\n      CtClass parameterType = parameterTypes[i];\n      boolean isArray = parameterType.isArray();\n      CtClass arrayType = parameterType.getComponentType();\n      if (isArray) {\n        while (arrayType.isArray()) {\n          arrayType = arrayType.getComponentType();\n        }\n      }\n\n      sb.append(\" + \\\"\");\n      sb.append(parameterNameFor(method, locals, i));\n      sb.append(\"\\\" + \\\"=\");\n\n      // use Arrays.asList() to render array of objects.\n      if (isArray && !arrayType.isPrimitive()) {\n        sb.append(\"\\\"+ java.util.Arrays.asList($\" + (i + 1) + \")\");\n      } else {\n        sb.append(\"\\\"+ $\" + (i + 1));\n      }\n    }\n    sb.append(\"+\\\")\");\n\n    String signature = sb.toString();\n    return signature;\n  }\n\n  /**\n   * Determine the name of parameter with index i in the given method. Use the\n   * locals attributes about local variables from the classfile. Note: This is\n   * still work in progress.\n   * \n   * @param method\n   * @param locals\n   * @param i\n   * @return the name of the parameter if available or a number if not.\n   */\n  static String parameterNameFor(CtBehavior method,\n      LocalVariableAttribute locals, int i) {\n\n    if (locals == null) {\n      return Integer.toString(i + 1);\n    }\n\n    int modifiers = method.getModifiers();\n\n    int j = i;\n\n    if (Modifier.isSynchronized(modifiers)) {\n      // skip object to synchronize upon.\n      j++;\n      // System.err.println(\"Synchronized\");\n    }\n    if (Modifier.isStatic(modifiers) == false) {\n      // skip \"this\"\n      j++;\n      // System.err.println(\"Instance\");\n    }\n    String variableName = locals.variableName(j);\n    if (variableName.equals(\"this\")) {\n      System.err.println(\"'this' returned as a parameter name for \"\n          + method.getName() + \" index \" + j + \", names are probably shifted.\");\n    }\n    return variableName;\n  }\n}\n","lineNo":80}
{"Refactored Sample":"package org.slf4j.agent;\n\nimport static org.slf4j.helpers.MessageFormatter.format;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.lang.instrument.Instrumentation;\nimport java.util.Date;\nimport java.util.Properties;\n\nimport org.slf4j.instrumentation.LogTransformer;\n\npublic class AgentPremain {\n\n  private static final String START_MSG = \"Start at {}\";\n  private static final String STOP_MSG = \"Stop at {}, execution time = {} ms\";\n\n  /**\n   * JavaAgent premain entry point as specified in the MANIFEST.MF file. See\n   * {@link http://java.sun.com/javase/6/docs/api/java/lang/instrument/package-summary.html} for details.\n   * \n   * @param agentArgument\n   *          string provided after \"=\" up to first space\n   * @param instrumentation\n   */\n  public static void premain(String agentArgument,\n      Instrumentation instrumentation) {\n\n    System.err.println(\"THIS JAVAAGENT IS NOT RELEASED YET.  \"\n        + \"DO NOT USE IN PRODUCTION ENVIRONMENTS.\");\n\n    LogTransformer.Builder builder = new LogTransformer.Builder();\n    builder = builder.addEntryExit(true);\n\n    if (agentArgument != null) {\n      Properties args = parseArguments(agentArgument);\n\n      if (args.containsKey(\"verbose\")) {\n        builder = builder.verbose(true);\n      }\n\n      if (args.containsKey(\"time\")) {\n        printStartStopTimes();\n      }\n\n      if (args.containsKey(\"ignore\")) {\n        builder = builder.ignore(args.getProperty(\"ignore\").split(\",\"));\n      }\n\n      if (args.containsKey(\"level\")) {\n        builder = builder.level(args.getProperty(\"level\"));\n      }\n\n      // ... more agent option handling here\n    }\n\n    instrumentation.addTransformer(builder.build());\n  }\n\n  private static Properties parseArguments(String agentArgument) {\n    Properties p = new Properties();\n    try {\n      byte[] bytes = agentArgument.replaceAll(\";\", \"\\n\").getBytes();\n      p.load(new ByteArrayInputStream(bytes));\n    } catch (IOException e) {\n      String s = \"Could not load arguments as properties\";\n      throw new RuntimeException(s, e);\n    }\n    return p;\n  }\n\n  /**\n   * Print the start message with the time NOW, and register a shutdown hook\n   * which will print the stop message with the time then and the number of\n   * milliseconds passed since.\n   * \n   */\n  private static void printStartStopTimes() {\n    final long start = System.currentTimeMillis();\n    System.err.println(format(START_MSG, new Date()));\n\n    Thread hook = new Thread() {\n      @Override\n      public void run() {\n        long timePassed = System.currentTimeMillis() - start;\n        String message = format(STOP_MSG, new Date(), timePassed);\n        System.err.println(message);\n      }\n    };\n    Runtime.getRuntime().addShutdownHook(hook);\n  }\n}\n","Smelly Sample":"package org.slf4j.agent;\n\nimport static org.slf4j.helpers.MessageFormatter.format;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.lang.instrument.Instrumentation;\nimport java.util.Date;\nimport java.util.Properties;\n\nimport org.slf4j.instrumentation.LogTransformer;\n\npublic class AgentPremain {\n\n\tprivate static final String START_MSG = \"Start at {}\";\n\tprivate static final String STOP_MSG = \"Stop at {}, execution time = {} ms\";\n\n\tpublic static void premain(String agentArgument,\n\t\t\tInstrumentation instrumentation) {\n\n\t\tSystem.err.println(\"THIS JAVAAGENT IS NOT RELEASED YET.  DO NOT USE IN PRODUCTION ENVIRONMENTS.\");\n\t\tLogTransformer.Builder builder = new LogTransformer.Builder();\n\t\tbuilder = builder.addEntryExit(true);\n\n\t\tif (agentArgument != null) {\n\t\t\tProperties args = parseArguments(agentArgument);\n\n\t\t\tif (args.containsKey(\"verbose\")) {\n\t\t\t\tbuilder = builder.verbose(true);\n\t\t\t}\n\n\t\t\tif (args.containsKey(\"time\")) {\n\t\t\t\tprintStartStopTimes();\n\t\t\t}\n\n\t\t\tif (args.containsKey(\"ignore\")) {\n\t\t\t\tbuilder = builder.ignore(args.getProperty(\"ignore\").split(\",\"));\n\t\t\t}\n\t\t\t\n\t\t\tif (args.containsKey(\"level\")) {\n\t\t\t\tbuilder = builder.level(args.getProperty(\"level\"));\n\t\t\t}\n\n\t\t\t// ... more agent option handling here\n\t\t}\n\n\t\tinstrumentation.addTransformer(builder.build());\n\t}\n\n\tprivate static Properties parseArguments(String agentArgument) {\n\t\tProperties p = new Properties();\n\t\ttry {\n\t\t\tbyte[] bytes = agentArgument.replaceAll(\";\", \"\\n\").getBytes();\n\t\t\tp.load(new ByteArrayInputStream(bytes));\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Could not load arguments as properties\", e);\n\t\t}\n\t\treturn p;\n\t}\n\n\t/**\n\t * Print the start message with the time NOW, and register a shutdown hook\n\t * which will print the stop message with the time then and the number of\n\t * milliseconds passed since.\n\t * \n\t */\n\tprivate static void printStartStopTimes() {\n\t\tfinal long start = System.currentTimeMillis();\n\t\tSystem.err.println(format(START_MSG, new Date()));\n\n\t\tThread hook = new Thread() {\n\t\t\tpublic void run() {\n\t\t\t\tlong timePassed = System.currentTimeMillis() - start;\n\t\t\t\tString message = format(STOP_MSG, new Date(), timePassed);\n\t\t\t\tSystem.err.println(message);\n\t\t\t}\n\t\t};\n\t\tRuntime.getRuntime().addShutdownHook(hook);\n\t}\n\n}\n","lineNo":66}
{"Refactored Sample":"package org.slf4j.instrumentation;\n\nimport javassist.CtBehavior;\nimport javassist.CtClass;\nimport javassist.CtMethod;\nimport javassist.Modifier;\nimport javassist.NotFoundException;\nimport javassist.bytecode.CodeAttribute;\nimport javassist.bytecode.LocalVariableAttribute;\n\npublic class JavassistHelper {\n\n\tpublic static String returnValue(CtBehavior method)\n\t\t\tthrows NotFoundException {\n\t\t\n\t\tString returnValue = \"\";\n\t\tif (methodReturnsValue(method)) {\n\t\t\treturnValue = \" returns: \\\" + $_ + \\\"\";\n\t\t}\n\t\treturn returnValue;\n\t}\n\n\tprivate static boolean methodReturnsValue(CtBehavior method)\n\t\t\tthrows NotFoundException {\n\t\t\n\t\tif (method instanceof CtMethod == false) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tCtClass returnType = ((CtMethod) method).getReturnType();\n\t\tString returnTypeName = returnType.getName();\n\n\t\tboolean isVoidMethod = \"void\".equals(returnTypeName);\n\t\t\n\t\tboolean methodReturnsValue = isVoidMethod == false;\n\t\treturn methodReturnsValue;\n\t}\n\n\tpublic static String getSignature(CtBehavior method)\n\t\t\tthrows NotFoundException {\n\t\t\n\t\tCtClass parameterTypes[] = method.getParameterTypes();\n\n\t\tCodeAttribute codeAttribute = method.getMethodInfo().getCodeAttribute();\n\n\t\tLocalVariableAttribute locals = (LocalVariableAttribute) codeAttribute\n\t\t\t\t.getAttribute(\"LocalVariableTable\");\n\t\t\n\t\tString methodName = method.getName();\n\n\t\tStringBuffer sb = new StringBuffer(methodName + \"(\\\" \");\n\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\tsb.append(\" + \\\", \\\" \");\n\t\t\t}\n\n\t\t\tCtClass parameterType = parameterTypes[i];\n\t\t\tCtClass arrayOf = parameterType.getComponentType();\n\n\t\t\tsb.append(\" + \\\"\");\n\t\t\tsb.append(parameterNameFor(method, locals, i));\n\t\t\tsb.append(\"\\\" + \\\"=\");\n\n\t\t\t// use Arrays.asList() to render array of objects.\n\t\t\tif (arrayOf != null && !arrayOf.isPrimitive()) {\n\t\t\t\tsb.append(\"\\\"+ java.util.Arrays.asList($\" + (i + 1) + \")\");\n\t\t\t} else {\n\t\t\t\tsb.append(\"\\\"+ $\" + (i + 1));\n\t\t\t}\n\t\t}\n\t\tsb.append(\"+\\\")\");\n\n\t\tString signature = sb.toString();\n\t\treturn signature;\n\t}\n\n\tstatic String parameterNameFor(CtBehavior method,\n\t\t\tLocalVariableAttribute locals, int i) {\n\t\tif (locals == null) {\n\t\t\treturn Integer.toString(i + 1);\n\t\t}\n\t\t\n\n\t\tint modifiers = method.getModifiers();\n\t\t\n\t\tint j = i;\n\t\t\n\t\t\n\t\t\n\t\tif (Modifier.isStatic(modifiers) == false) {\n\t\t\t// skip #0 which is \"this\"\n\t\t\tj++;\n\t\t}\n\t\treturn locals.variableName(j);\n\t}\n}\n","Smelly Sample":"package org.slf4j.instrumentation;\n\nimport javassist.CtBehavior;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\nimport javassist.CtMethod;\nimport javassist.Modifier;\nimport javassist.NotFoundException;\nimport javassist.bytecode.CodeAttribute;\nimport javassist.bytecode.LocalVariableAttribute;\n\npublic class JavassistHelper {\n\n\tpublic static String returnValue(CtBehavior method)\n\t\t\tthrows NotFoundException {\n\t\t\n\t\tString returnValue = \"\";\n\t\tif (methodReturnsValue(method)) {\n\t\t\treturnValue = \"\\\" returns: \\\" + $_ \";\n\t\t}\n\t\treturn returnValue;\n\t}\n\n\tprivate static boolean methodReturnsValue(CtBehavior method)\n\t\t\tthrows NotFoundException {\n\t\t\n\t\tCtClass returnType = ((CtMethod) method).getReturnType();\n\t\tString returnTypeName = returnType.getName();\n\n\t\tboolean isVoidMethod = (method instanceof CtMethod)\n\t\t\t\t&& \"void\".equals(returnTypeName);\n\t\t\n\t\tboolean isConstructor = method instanceof CtConstructor;\n\n\t\tboolean methodReturnsValue = (isVoidMethod || isConstructor) == false;\n\t\treturn methodReturnsValue;\n\t}\n\n\tpublic static String getSignature(CtBehavior method)\n\t\t\tthrows NotFoundException {\n\t\t\n\t\tCtClass parameterTypes[] = method.getParameterTypes();\n\n\t\tCodeAttribute codeAttribute = method.getMethodInfo().getCodeAttribute();\n\n\t\tLocalVariableAttribute locals = (LocalVariableAttribute) codeAttribute\n\t\t\t\t.getAttribute(\"LocalVariableTable\");\n\t\t\n\t\tString methodName = method.getName();\n\n\t\tStringBuffer sb = new StringBuffer(methodName + \"(\\\" \");\n\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\tsb.append(\" + \\\", \\\" \");\n\t\t\t}\n\n\t\t\tCtClass parameterType = parameterTypes[i];\n\t\t\tCtClass arrayOf = parameterType.getComponentType();\n\n\t\t\tsb.append(\" + \\\"\");\n\t\t\tsb.append(parameterNameFor(method, locals, i));\n\t\t\tsb.append(\"\\\" + \\\"=\");\n\n\t\t\t// use Arrays.asList() to render array of objects.\n\t\t\tif (arrayOf != null && !arrayOf.isPrimitive()) {\n\t\t\t\tsb.append(\"\\\"+ java.util.Arrays.asList($\" + (i + 1) + \")\");\n\t\t\t} else {\n\t\t\t\tsb.append(\"\\\"+ $\" + (i + 1));\n\t\t\t}\n\t\t}\n\t\tsb.append(\"+\\\")\");\n\n\t\tString signature = sb.toString();\n\t\treturn signature;\n\t}\n\n\tstatic String parameterNameFor(CtBehavior method,\n\t\t\tLocalVariableAttribute locals, int i) {\n\t\tif (locals == null) {\n\t\t\treturn Integer.toString(i + 1);\n\t\t}\n\n\t\tif (Modifier.isStatic(method.getModifiers())) {\n\t\t\treturn locals.variableName(i);\n\t\t}\n\n\t\t// skip #0 which is reference to \"this\"\n\t\treturn locals.variableName(i + 1);\n\t}\n}\n","lineNo":86}
{"Refactored Sample":"/**\n * \n */\npackage org.slf4j.instrumentation;\n\nimport static org.slf4j.helpers.MessageFormatter.format;\n\nimport java.io.ByteArrayInputStream;\nimport java.lang.instrument.ClassFileTransformer;\nimport java.security.ProtectionDomain;\n\nimport javassist.CannotCompileException;\nimport javassist.ClassPool;\nimport javassist.CtBehavior;\nimport javassist.CtClass;\nimport javassist.CtField;\nimport javassist.NotFoundException;\n\npublic class AddEntryExitLoggingTransformer implements ClassFileTransformer {\n\n\tprivate static final String _LOG = \"_log\";\n\tString[] ignore = new String[] { \"sun/\", \"java/\", \"javax/\", \"org/slf4j/\",\n\t\t\t\"ch/qos/logback/\" };\n\n\tpublic byte[] transform(ClassLoader loader, String className,\n\t\t\tClass<?> clazz, ProtectionDomain domain, byte[] bytes) {\n\n\t\tfor (int i = 0; i < ignore.length; i++) {\n\t\t\tif (className.startsWith(ignore[i])) {\n\t\t\t\treturn bytes;\n\t\t\t}\n\t\t}\n\t\t// System.out.println(\"Adding to \" + className);\n\t\treturn doClass(className, clazz, bytes);\n\t}\n\n\t/**\n\t * The transform(...) method calls doClass(...) if the class name does not\n\t * start with any of the prefixes it has been told to ignore.\n\t * \n\t * doClass() first creates a class description from the byte codes. If it is\n\t * a class (i.e. not an interface) the methods defined have bodies, and a\n\t * static final logger object is added with the name of this class as an\n\t * argument, and each method then gets processed with doMethod(...) to have\n\t * logger calls added.\n\t * \n\t * \n\t * \n\t * @param name\n\t *            class name (slashes separate, not dots)\n\t * @param clazz\n\t * @param b\n\t * @return\n\t */\n\tprivate byte[] doClass(String name, Class<?> clazz, byte[] b) {\n\t\tClassPool pool = ClassPool.getDefault();\n\t\tCtClass cl = null;\n\t\ttry {\n\t\t\tcl = pool.makeClass(new ByteArrayInputStream(b));\n\t\t\tif (cl.isInterface() == false) {\n\n\t\t\t\tString pattern1 = \"private static org.slf4j.Logger {};\";\n\t\t\t\tString loggerDefinition = format(pattern1, _LOG);\n\t\t\t\tCtField field = CtField.make(loggerDefinition, cl);\n\n\t\t\t\tString pattern2 = \"org.slf4j.LoggerFactory.getLogger({}.class);\";\n\t\t\t\tString replace = name.replace('/', '.');\n\t\t\t\tString getLogger = format(pattern2, replace);\n\n\t\t\t\tcl.addField(field, getLogger);\n\t\t\t\tSystem.out.println(getLogger);\n\n\t\t\t\tCtBehavior[] methods = cl.getDeclaredBehaviors();\n\t\t\t\tfor (int i = 0; i < methods.length; i++) {\n\t\t\t\t\tif (methods[i].isEmpty() == false) {\n\t\t\t\t\t\tdoMethod(methods[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb = cl.toBytecode();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tString pattern = \"Could not instrument {},  exception : {}\";\n\t\t\tSystem.err.println(format(pattern, name, e.getMessage()));\n\t\t} finally {\n\t\t\tif (cl != null) {\n\t\t\t\tcl.detach();\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\n\tprivate void doMethod(CtBehavior method) throws NotFoundException,\n\t\t\tCannotCompileException {\n\n\t\tString signature = JavassistHelper.getSignature(method);\n\t\tString returnValue = JavassistHelper.returnValue(method);\n\n\t\tString messagePattern = \"if ({}.isDebugEnabled()) {}.info(\\\">> {}\\\");\";\n\t\tObject[] arg1 = new Object[] { _LOG, _LOG, signature };\n\t\tString before = format(messagePattern, arg1);\n\t\tmethod.insertBefore(before);\n\n\t\tString messagePattern2 = \"if ({}.isDebugEnabled()) {}.info(\\\"<< {}{}\\\");\";\n\t\tObject[] arg2 = new Object[] { _LOG, _LOG, signature, returnValue };\n\t\tString after = format(messagePattern2, arg2);\n\t\tmethod.insertAfter(after);\n\t}\n}\n","Smelly Sample":"/**\n * \n */\npackage org.slf4j.instrumentation;\n\nimport java.io.ByteArrayInputStream;\nimport java.lang.instrument.ClassFileTransformer;\n\nimport javassist.CannotCompileException;\nimport javassist.ClassPool;\nimport javassist.CtBehavior;\nimport javassist.CtClass;\nimport javassist.CtField;\nimport javassist.NotFoundException;\n\n\npublic class AddEntryExitLoggingTransformer implements\n\t\tClassFileTransformer {\n\t\n\tfinal String def = \"private static org.slf4j.Logger \" + \"_log\" + \";\";\n\tfinal String ifLog = \"if (_log.isDebugEnabled())\";\n\tString[] ignore = new String[] { \"sun/\", \"java/\", \"javax/\", \"org/slf4j/\",\n\t\t\t\"ch/qos/logback/\" };\n\n\tpublic byte[] transform(ClassLoader loader, String className, Class<?> clazz,\n\t\t\tjava.security.ProtectionDomain domain, byte[] bytes) {\n\n\t\tfor (int i = 0; i < ignore.length; i++) {\n\t\t\tif (className.startsWith(ignore[i])) {\n\t\t\t\treturn bytes;\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"Adding to \" + className);\n\t\treturn doClass(className, clazz, bytes);\n\t}\n\n\t//\n\t// The transform(...) method calls doClass(...) if the class name does not\n\t// start with any of the prefixes it has been told to ignore (note that the\n\t// separators are slashes, not dots).\n\n\tprivate byte[] doClass(String name, Class<?> clazz, byte[] b) {\n\t\tClassPool pool = ClassPool.getDefault();\n\t\tCtClass cl = null;\n\t\ttry {\n\t\t\tcl = pool.makeClass(new ByteArrayInputStream(b));\n\t\t\tif (cl.isInterface() == false) {\n\n\t\t\t\tCtField field = CtField.make(def, cl);\n\t\t\t\tString getLogger = \"org.slf4j.LoggerFactory.getLogger(\"\n\t\t\t\t\t\t+ name.replace('/', '.') + \".class);\";\n\t\t\t\tcl.addField(field, getLogger);\n\t\t\t\tSystem.out.println(getLogger);\n\n\t\t\t\tCtBehavior[] methods = cl.getDeclaredBehaviors();\n\t\t\t\tfor (int i = 0; i < methods.length; i++) {\n\t\t\t\t\tif (methods[i].isEmpty() == false) {\n\t\t\t\t\t\tdoMethod(methods[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb = cl.toBytecode();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tSystem.err.println(\"Could not instrument  \" + name\n\t\t\t\t\t+ \",  exception : \" + e.getMessage());\n\t\t} finally {\n\t\t\tif (cl != null) {\n\t\t\t\tcl.detach();\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\n\tprivate void doMethod(CtBehavior method) throws NotFoundException,\n\t\t\tCannotCompileException {\n\n\t\tString signature = JavassistHelper.getSignature(method);\n\t\tString returnValue = JavassistHelper.returnValue(method);\n\n\t\tmethod.insertBefore(ifLog + \"_log\" + \".info(\\\">> \" + signature + \");\");\n\n\t\tmethod.insertAfter(ifLog + \"_log\" + \".info(\\\"<< \" + signature\n\t\t\t\t+ returnValue + \");\");\n\t}\n}\n","lineNo":67}
{"Refactored Sample":"/* \n * Copyright (c) 2004-2005 SLF4J.ORG\n * Copyright (c) 2004-2005 QOS.CH\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute, and/or sell copies of  the Software, and to permit persons\n * to whom  the Software is furnished  to do so, provided  that the above\n * copyright notice(s) and this permission notice appear in all copies of\n * the  Software and  that both  the above  copyright notice(s)  and this\n * permission notice appear in supporting documentation.\n * \n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR  A PARTICULAR PURPOSE AND NONINFRINGEMENT\n * OF  THIRD PARTY  RIGHTS. IN  NO EVENT  SHALL THE  COPYRIGHT  HOLDER OR\n * HOLDERS  INCLUDED IN  THIS  NOTICE BE  LIABLE  FOR ANY  CLAIM, OR  ANY\n * SPECIAL INDIRECT  OR CONSEQUENTIAL DAMAGES, OR  ANY DAMAGES WHATSOEVER\n * RESULTING FROM LOSS  OF USE, DATA OR PROFITS, WHETHER  IN AN ACTION OF\n * CONTRACT, NEGLIGENCE  OR OTHER TORTIOUS  ACTION, ARISING OUT OF  OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n * \n * Except as  contained in  this notice, the  name of a  copyright holder\n * shall not be used in advertising or otherwise to promote the sale, use\n * or other dealings in this Software without prior written authorization\n * of the copyright holder.\n *\n */\n\npackage org.slf4j;\n\nimport junit.framework.TestCase;\n\n\n/**\n * Test whether invoking the SLF4J API causes problems or not.\n * \n * @author Ceki Gulcu\n *\n */\npublic class InvokingSLF4J extends TestCase {\n\n  public InvokingSLF4J (String arg0) {\n    super(arg0);\n  }\n\n  /*\n   * @see TestCase#setUp()\n   */\n  protected void setUp() throws Exception {\n    super.setUp();\n  }\n\n  /*\n   * @see TestCase#tearDown()\n   */\n  protected void tearDown() throws Exception {\n    super.tearDown();\n  }\n  \n  public void test1() {\n    Logger logger = LoggerFactory.getLogger(\"test1\");\n    logger.debug(\"Hello world.\");\n  }\n  \n  public void test2() {\n    Integer i1 = new Integer(1);\n    Integer i2 = new Integer(2);\n    Integer i3 = new Integer(3);\n    Exception e = new Exception(\"This is a test exception.\");\n    Logger logger = LoggerFactory.getLogger(\"test2\");\n    logger.debug(\"Hello world 1.\");\n    logger.debug(\"Hello world {}\", i1);\n    logger.debug(\"val={} val={}\", i1, i2);\n    logger.debug(\"val={} val={} val={}\", new Object[]{i1, i2, i3});\n    \n    logger.debug(\"Hello world 1\", e);\n    \n    logger.info(\"Hello world 2.\");\n    logger.info(\"Hello world {}\", new Integer(2)); \n    logger.warn(\"Hello world 3.\");\n    logger.warn(\"Hello world 3.\", e);\n    logger.warn(\"Hello world {}\", new Integer(3)); \n    logger.error(\"Hello world 4.\");\n    logger.error(\"Hello world {}\", new Integer(3)); \n    logger.error(\"Hello world 4.\", e);\n\n    \n  }\n}\n","Smelly Sample":"/* \n * Copyright (c) 2004-2005 SLF4J.ORG\n * Copyright (c) 2004-2005 QOS.CH\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute, and/or sell copies of  the Software, and to permit persons\n * to whom  the Software is furnished  to do so, provided  that the above\n * copyright notice(s) and this permission notice appear in all copies of\n * the  Software and  that both  the above  copyright notice(s)  and this\n * permission notice appear in supporting documentation.\n * \n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR  A PARTICULAR PURPOSE AND NONINFRINGEMENT\n * OF  THIRD PARTY  RIGHTS. IN  NO EVENT  SHALL THE  COPYRIGHT  HOLDER OR\n * HOLDERS  INCLUDED IN  THIS  NOTICE BE  LIABLE  FOR ANY  CLAIM, OR  ANY\n * SPECIAL INDIRECT  OR CONSEQUENTIAL DAMAGES, OR  ANY DAMAGES WHATSOEVER\n * RESULTING FROM LOSS  OF USE, DATA OR PROFITS, WHETHER  IN AN ACTION OF\n * CONTRACT, NEGLIGENCE  OR OTHER TORTIOUS  ACTION, ARISING OUT OF  OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n * \n * Except as  contained in  this notice, the  name of a  copyright holder\n * shall not be used in advertising or otherwise to promote the sale, use\n * or other dealings in this Software without prior written authorization\n * of the copyright holder.\n *\n */\n\npackage org.slf4j;\n\nimport junit.framework.TestCase;\n\n\n/**\n * Test whether invoking the SLF4J API causes problems or not.\n * \n * @author Ceki Gulcu\n *\n */\npublic class InvokingSLF4J extends TestCase {\n\n  public InvokingSLF4J (String arg0) {\n    super(arg0);\n  }\n\n  /*\n   * @see TestCase#setUp()\n   */\n  protected void setUp() throws Exception {\n    super.setUp();\n  }\n\n  /*\n   * @see TestCase#tearDown()\n   */\n  protected void tearDown() throws Exception {\n    super.tearDown();\n  }\n  \n  public void test1() {\n    Logger logger = LoggerFactory.getLogger(\"test1\");\n    logger.debug(\"Hello world.\");\n  }\n  \n  public void test2() {\n    Exception e = new Exception(\"This is a test exception.\");\n    Logger logger = LoggerFactory.getLogger(\"test2\");\n    logger.debug(\"Hello world 1.\");\n    logger.debug(\"Hello world {}\", new Integer(1));\n    logger.debug(\"Hello world 1\", e);\n    logger.info(\"Hello world 2.\");\n    logger.info(\"Hello world {}\", new Integer(2)); \n    logger.warn(\"Hello world 3.\");\n    logger.warn(\"Hello world 3.\", e);\n    logger.warn(\"Hello world {}\", new Integer(3)); \n    logger.error(\"Hello world 4.\");\n    logger.error(\"Hello world {}\", new Integer(3)); \n    logger.error(\"Hello world 4.\", e);\n\n    \n  }\n}\n","lineNo":71}
{"Refactored Sample":"/* \n * Copyright (c) 2004-2005 SLF4J.ORG\n * Copyright (c) 2004-2005 QOS.ch\n *\n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute, and/or sell copies of  the Software, and to permit persons\n * to whom  the Software is furnished  to do so, provided  that the above\n * copyright notice(s) and this permission notice appear in all copies of\n * the  Software and  that both  the above  copyright notice(s)  and this\n * permission notice appear in supporting documentation.\n * \n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR  A PARTICULAR PURPOSE AND NONINFRINGEMENT\n * OF  THIRD PARTY  RIGHTS. IN  NO EVENT  SHALL THE  COPYRIGHT  HOLDER OR\n * HOLDERS  INCLUDED IN  THIS  NOTICE BE  LIABLE  FOR ANY  CLAIM, OR  ANY\n * SPECIAL INDIRECT  OR CONSEQUENTIAL DAMAGES, OR  ANY DAMAGES WHATSOEVER\n * RESULTING FROM LOSS  OF USE, DATA OR PROFITS, WHETHER  IN AN ACTION OF\n * CONTRACT, NEGLIGENCE  OR OTHER TORTIOUS  ACTION, ARISING OUT OF  OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n * \n * Except as  contained in  this notice, the  name of a  copyright holder\n * shall not be used in advertising or otherwise to promote the sale, use\n * or other dealings in this Software without prior written authorization\n * of the copyright holder.\n *\n */\n\npackage org.slf4j.impl;\n\n\n/**\n * Formats messages according to very simple rules. \n * See {@link #format(String, Object)} and \n * {@link #format(String, Object, Object)} for more details.\n *\n * @author <a href=\"http://www.qos.ch/log4j/\">Ceki G&uuml;lc&uuml;<\/a>\n */\npublic class MessageFormatter {\n  static final char DELIM_START = '{';\n  static final char DELIM_STOP = '}';\n\n  /**\n   * Performs single argument substitution for the 'messagePattern' passed as\n   * parameter.\n   * <p>\n   * For example, <code>MessageFormatter.format(\"Hi {}.\", \"there\");<\/code> will\n   * return the string \"Hi there.\".\n   * <p>\n   * The {} pair is called the formatting element. It serves to designate the\n   * location where the argument needs to be inserted within the pattern.\n   * \n   * @param messagePattern The message pattern which will be parsed and formatted\n   * @param argument The argument to be inserted instead of the formatting element\n   * @return The formatted message\n   */\n  public static String format(String messagePattern, Object arg) {\n    return arrayFormat(messagePattern, new Object[] {arg});   \n   }\n  \n  /**\n   *\n   * Performs a two argument substitution for the 'messagePattern' passed as\n   * parameter.\n   * <p>\n   * For example, <code>MessageFormatter.format(\"Hi {}. My name is {}.\", \n   * \"there\", \"David\");<\/code> will return the string \"Hi there. My name is David.\".\n   * <p>\n   * The '{}' pair is called a formatting element. It serves to designate the\n   * location where the arguments need to be inserted within the message pattern.\n   * \n   * @param messagePattern The message pattern which will be parsed and formatted\n   * @param arg1 The first argument to replace the first formatting element\n   * @param arg2 The second argument to replace the second formatting element\n   * @return The formatted message\n   */\n  public static String format(String messagePattern, Object arg1, Object arg2) {\n   return arrayFormat(messagePattern, new Object[] {arg1, arg2});   \n  }\n  \n  public static String arrayFormat(String messagePattern, Object[] argArray) {\n    if(messagePattern == null) {\n      return null;\n    }\n    int i = 0;\n    int len = messagePattern.length();\n    int j = messagePattern.indexOf(DELIM_START);\n    \n    char escape = 'x';\n    \n    StringBuffer sbuf = new StringBuffer(messagePattern.length() + 50);\n\n    for (int L = 0; L < argArray.length; L++) {\n      j = messagePattern.indexOf(DELIM_START, i);\n\n      if (j == -1 || (j+1 == len)) {\n        // no more variables\n        if (i == 0) { // this is a simple string\n          return messagePattern;\n        } else { // add the tail string which contains no variables and return the result.\n          sbuf.append(messagePattern.substring(i, messagePattern.length()));\n          return sbuf.toString();\n        }\n      } else {\n        char delimStop = messagePattern.charAt(j + 1);\n        if (j > 0) {\n          escape = messagePattern.charAt(j - 1);\n        }\n        \n        if(escape == '\\\\') {\n          sbuf.append(messagePattern.substring(i, j));\n          sbuf.append(DELIM_START);\n          i = j + 1;\n        } else if ((delimStop != DELIM_STOP)) {\n          // invalid DELIM_START/DELIM_STOP pair\n          sbuf.append(messagePattern.substring(i, messagePattern.length()));\n          return sbuf.toString();\n        } else {\n          // normal case\n          sbuf.append(messagePattern.substring(i, j));\n          sbuf.append(argArray[L]);\n          i = j + 2;\n        }\n      }\n    }\n    // append the characters following the second {} pair.\n    sbuf.append(messagePattern.substring(i, messagePattern.length()));\n    return sbuf.toString();\n  }\n}\n","Smelly Sample":"/* \n * Copyright (c) 2004-2005 SLF4J.ORG\n * Copyright (c) 2004-2005 QOS.ch\n *\n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute, and/or sell copies of  the Software, and to permit persons\n * to whom  the Software is furnished  to do so, provided  that the above\n * copyright notice(s) and this permission notice appear in all copies of\n * the  Software and  that both  the above  copyright notice(s)  and this\n * permission notice appear in supporting documentation.\n * \n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR  A PARTICULAR PURPOSE AND NONINFRINGEMENT\n * OF  THIRD PARTY  RIGHTS. IN  NO EVENT  SHALL THE  COPYRIGHT  HOLDER OR\n * HOLDERS  INCLUDED IN  THIS  NOTICE BE  LIABLE  FOR ANY  CLAIM, OR  ANY\n * SPECIAL INDIRECT  OR CONSEQUENTIAL DAMAGES, OR  ANY DAMAGES WHATSOEVER\n * RESULTING FROM LOSS  OF USE, DATA OR PROFITS, WHETHER  IN AN ACTION OF\n * CONTRACT, NEGLIGENCE  OR OTHER TORTIOUS  ACTION, ARISING OUT OF  OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n * \n * Except as  contained in  this notice, the  name of a  copyright holder\n * shall not be used in advertising or otherwise to promote the sale, use\n * or other dealings in this Software without prior written authorization\n * of the copyright holder.\n *\n */\n\npackage org.slf4j.impl;\n\n\n/**\n * Formats messages according to very simple rules. \n * See {@link #format(String, Object)} and \n * {@link #format(String, Object, Object)} for more details.\n *\n * @author <a href=\"http://www.qos.ch/log4j/\">Ceki G&uuml;lc&uuml;<\/a>\n */\npublic class MessageFormatter {\n  static final char DELIM_START = '{';\n  static final char DELIM_STOP = '}';\n\n  /**\n   * Performs single argument substitution for the 'messagePattern' passed as\n   * parameter.\n   * <p>\n   * For example, <code>MessageFormatter.format(\"Hi {}.\", \"there\");<\/code> will\n   * return the string \"Hi there.\".\n   * <p>\n   * The {} pair is called the formatting element. It serves to designate the\n   * location where the argument needs to be inserted within the pattern.\n   * \n   * @param messagePattern The message pattern which will be parsed and formatted\n   * @param argument The argument to be inserted instead of the formatting element\n   * @return The formatted message\n   */\n  public static String format(String messagePattern, Object argument) {\n    int j = messagePattern.indexOf(DELIM_START);\n    int len = messagePattern.length();\n    char escape = 'x';\n\n    // if there are no { characters or { is the last character of the messsage\n    // then we just return messagePattern\n    if (j == -1 || (j+1 == len)) {\n      return messagePattern;\n    } else {\n      if(j+1 == len) {\n      }\n      \n      char delimStop = messagePattern.charAt(j + 1);\n      if (j > 0) {\n        escape = messagePattern.charAt(j - 1);\n      }\n      if ((delimStop != DELIM_STOP) || (escape == '\\\\')) {\n        // invalid DELIM_START/DELIM_STOP pair or espace character is\n        // present\n        return messagePattern;\n      } else {\n        StringBuffer sbuf = new StringBuffer(len + 20);\n        sbuf.append(messagePattern.substring(0, j));\n        sbuf.append(argument);\n        sbuf.append(messagePattern.substring(j + 2));\n        return sbuf.toString();\n      }\n    }\n  }\n\n  /**\n   * /**\n   * Performs a two argument substitution for the 'messagePattern' passed as\n   * parameter.\n   * <p>\n   * For example, <code>MessageFormatter.format(\"Hi {}. My name is {}.\", \n   * \"there\", \"David\");<\/code> will return the string \"Hi there. My name is David.\".\n   * <p>\n   * The '{}' pair is called a formatting element. It serves to designate the\n   * location where the arguments need to be inserted within the message pattern.\n   * \n   * @param messagePattern The message pattern which will be parsed and formatted\n   * @param arg1 The first argument to replace the first formatting element\n   * @param arg2 The second argument to replace the second formatting element\n   * @return The formatted message\n   */\n  public static String format(String messagePattern, Object arg1, Object arg2) {\n    int i = 0;\n    int len = messagePattern.length();\n    int j = messagePattern.indexOf(DELIM_START);\n\n    StringBuffer sbuf = new StringBuffer(messagePattern.length() + 50);\n\n    for (int L = 0; L < 2; L++) {\n      j = messagePattern.indexOf(DELIM_START, i);\n\n      if (j == -1 || (j+1 == len)) {\n        // no more variables\n        if (i == 0) { // this is a simple string\n          return messagePattern;\n        } else { // add the tail string which contains no variables and return the result.\n          sbuf.append(messagePattern.substring(i, messagePattern.length()));\n          return sbuf.toString();\n        }\n      } else {\n        char delimStop = messagePattern.charAt(j + 1);\n        if ((delimStop != DELIM_STOP)) {\n          // invalid DELIM_START/DELIM_STOP pair\n          sbuf.append(messagePattern.substring(i, messagePattern.length()));\n          return sbuf.toString();\n        }\n        sbuf.append(messagePattern.substring(i, j));\n        sbuf.append((L == 0) ? arg1 : arg2);\n        i = j + 2;\n      }\n    }\n    // append the characters following the second {} pair.\n    sbuf.append(messagePattern.substring(i, messagePattern.length()));\n    return sbuf.toString();\n  }\n}\n","lineNo":90}
{"Refactored Sample":"package org.slf4j;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.spi.MDCAdapter;\nimport org.slf4j.spi.SLF4JServiceProvider;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\n\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.Assert.*;\n\npublic class LoggerFactoryTest {\n    private PrintStream rawSyserr;\n    private ByteArrayOutputStream mockedSyserr;\n\n    final ClassLoader classLoaderOfLoggerFactory = LoggerFactory.class.getClassLoader();\n\n    @Before\n    public void setUp() {\n        rawSyserr = System.err;\n        mockedSyserr = new ByteArrayOutputStream();\n        System.setErr(new PrintStream(mockedSyserr));\n    }\n\n    @After\n    public void cleanUp() {\n        System.clearProperty(LoggerFactory.BINDING_PROP);\n        System.setErr(rawSyserr);\n    }\n\n    @Test\n    public void testExplicitlySpecified() {\n        System.setProperty(LoggerFactory.BINDING_PROP, \"org.slf4j.LoggerFactoryTest$TestingProvider\");\n        SLF4JServiceProvider provider = LoggerFactory.loadExplicitlySpecified(classLoaderOfLoggerFactory);\n        assertTrue(\"provider should be instance of TestingProvider class\", provider instanceof  TestingProvider);\n        assertTrue(mockedSyserr.toString().contains(\" Attempting to load provider \\\"org.slf4j.LoggerFactoryTest$TestingProvider\\\" specified via \\\"slf4j.binding\\\" system property\"));\n        System.out.println(mockedSyserr.toString());\n\n\n    }\n\n    @Test\n    public void testExplicitlySpecifiedNull() {\n        assertNull(LoggerFactory.loadExplicitlySpecified(classLoaderOfLoggerFactory));\n    }\n\n    @Test\n    public void testExplicitlySpecifyMissingServiceProvider() {\n        System.setProperty(LoggerFactory.BINDING_PROP, \"com.example.ServiceProvider\");\n        SLF4JServiceProvider provider = LoggerFactory.loadExplicitlySpecified(classLoaderOfLoggerFactory);\n        assertNull(provider);\n        assertTrue(mockedSyserr.toString().contains(\"Failed to instantiate the specified SLF4JServiceProvider (com.example.ServiceProvider)\"));\n    }\n\n    @Test\n    public void testExplicitlySpecifyNonServiceProvider() {\n        System.setProperty(LoggerFactory.BINDING_PROP, \"java.lang.String\");\n        assertNull(LoggerFactory.loadExplicitlySpecified(classLoaderOfLoggerFactory));\n        assertTrue(mockedSyserr.toString().contains(\"Specified SLF4JServiceProvider (java.lang.String) does not implement SLF4JServiceProvider interface\"));\n    }\n\n    public static class TestingProvider implements SLF4JServiceProvider {\n        @Override\n        public ILoggerFactory getLoggerFactory() {\n            return null;\n        }\n\n        @Override\n        public IMarkerFactory getMarkerFactory() {\n            return null;\n        }\n\n        @Override\n        public MDCAdapter getMDCAdapter() {\n            return null;\n        }\n\n        @Override\n        public String getRequestedApiVersion() {\n            return null;\n        }\n\n        @Override\n        public void initialize() {\n\n        }\n    }\n}\n","Smelly Sample":"package org.slf4j;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.spi.MDCAdapter;\nimport org.slf4j.spi.SLF4JServiceProvider;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\n\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertThat;\n\npublic class LoggerFactoryTest {\n    private PrintStream rawSyserr;\n    private ByteArrayOutputStream mockedSyserr;\n\n    @Before\n    public void setUp() {\n        rawSyserr = System.err;\n        mockedSyserr = new ByteArrayOutputStream();\n        System.setErr(new PrintStream(mockedSyserr));\n    }\n\n    @After\n    public void cleanUp() {\n        System.setErr(rawSyserr);\n    }\n\n    @Test\n    public void testExplicitlySpecified() {\n        assertThat(LoggerFactory.loadExplicitlySpecified(\"org.slf4j.LoggerFactoryTest$TestingProvider\"),\n                   is(instanceOf(TestingProvider.class)));\n    }\n\n    @Test\n    public void testExplicitlySpecifiedNull() {\n        assertNull(LoggerFactory.loadExplicitlySpecified(null));\n    }\n\n    @Test\n    public void testExplicitlySpecifyMissingServiceProvider() {\n        assertNull(LoggerFactory.loadExplicitlySpecified(\"com.example.ServiceProvider\"));\n        assertThat(mockedSyserr.toString(),\n                   containsString(\"Failed to instantiate the specified SLF4JServiceProvider (com.example.ServiceProvider)\"));\n    }\n\n    @Test\n    public void testExplicitlySpecifyNonServiceProvider() {\n        assertNull(LoggerFactory.loadExplicitlySpecified(\"java.lang.String\"));\n        assertThat(mockedSyserr.toString(),\n                   containsString(\"Specified SLF4JServiceProvider (java.lang.String) does not implement SLF4JServiceProvider interface\"));\n    }\n\n    public static class TestingProvider implements SLF4JServiceProvider {\n        @Override\n        public ILoggerFactory getLoggerFactory() {\n            return null;\n        }\n\n        @Override\n        public IMarkerFactory getMarkerFactory() {\n            return null;\n        }\n\n        @Override\n        public MDCAdapter getMDCAdapter() {\n            return null;\n        }\n\n        @Override\n        public String getRequesteApiVersion() {\n            return null;\n        }\n\n        @Override\n        public void initialize() {\n\n        }\n    }\n}\n","lineNo":55}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.ServiceConfigurationError;\nimport java.util.ServiceLoader;\nimport java.util.Set;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nimport org.slf4j.event.SubstituteLoggingEvent;\nimport org.slf4j.helpers.NOP_FallbackServiceProvider;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.helpers.SubstituteServiceProvider;\nimport org.slf4j.helpers.Util;\nimport org.slf4j.spi.SLF4JServiceProvider;\n\n/**\n * The <code>LoggerFactory<\/code> is a utility class producing Loggers for\n * various logging APIs, most notably for log4j, logback and JDK 1.4 logging.\n * Other implementations such as {@link org.slf4j.helpers.NOPLogger NOPLogger} and\n * SimpleLogger are also supported.\n * \n * <p><code>LoggerFactory<\/code> is essentially a wrapper around an\n * {@link ILoggerFactory} instance bound with <code>LoggerFactory<\/code> at\n * compile time.\n * \n * <p>\n * Please note that all methods in <code>LoggerFactory<\/code> are static.\n * \n * @author Alexander Dorokhine\n * @author Robert Elliot\n * @author Ceki G&uuml;lc&uuml;\n * \n */\npublic final class LoggerFactory {\n\n    static final String CODES_PREFIX = \"https://www.slf4j.org/codes.html\";\n\n    static final String NO_PROVIDERS_URL = CODES_PREFIX + \"#noProviders\";\n    static final String IGNORED_BINDINGS_URL = CODES_PREFIX + \"#ignoredBindings\";\n\n    static final String NO_STATICLOGGERBINDER_URL = CODES_PREFIX + \"#StaticLoggerBinder\";\n    static final String MULTIPLE_BINDINGS_URL = CODES_PREFIX + \"#multiple_bindings\";\n    static final String NULL_LF_URL = CODES_PREFIX + \"#null_LF\";\n    static final String VERSION_MISMATCH = CODES_PREFIX + \"#version_mismatch\";\n    static final String SUBSTITUTE_LOGGER_URL = CODES_PREFIX + \"#substituteLogger\";\n    static final String LOGGER_NAME_MISMATCH_URL = CODES_PREFIX + \"#loggerNameMismatch\";\n    static final String REPLAY_URL = CODES_PREFIX + \"#replay\";\n\n    static final String UNSUCCESSFUL_INIT_URL = CODES_PREFIX + \"#unsuccessfulInit\";\n    static final String UNSUCCESSFUL_INIT_MSG = \"org.slf4j.LoggerFactory in failed state. Original exception was thrown EARLIER. See also \"\n                    + UNSUCCESSFUL_INIT_URL;\n\n    static final int UNINITIALIZED = 0;\n    static final int ONGOING_INITIALIZATION = 1;\n    static final int FAILED_INITIALIZATION = 2;\n    static final int SUCCESSFUL_INITIALIZATION = 3;\n    static final int NOP_FALLBACK_INITIALIZATION = 4;\n\n    static volatile int INITIALIZATION_STATE = UNINITIALIZED;\n    static final SubstituteServiceProvider SUBST_PROVIDER = new SubstituteServiceProvider();\n    static final NOP_FallbackServiceProvider NOP_FALLBACK_SERVICE_PROVIDER = new NOP_FallbackServiceProvider();\n\n    // Support for detecting mismatched logger names.\n    static final String DETECT_LOGGER_NAME_MISMATCH_PROPERTY = \"slf4j.detectLoggerNameMismatch\";\n    static final String JAVA_VENDOR_PROPERTY = \"java.vendor.url\";\n\n    static boolean DETECT_LOGGER_NAME_MISMATCH = Util.safeGetBooleanSystemProperty(DETECT_LOGGER_NAME_MISMATCH_PROPERTY);\n\n    static volatile SLF4JServiceProvider PROVIDER;\n\n    // Package access for tests\n    static List<SLF4JServiceProvider> findServiceProviders() {\n        // retain behaviour similar to that of 1.7 series and earlier. More specifically, use the class loader that\n        // loaded the present class to search for services\n        final ClassLoader classLoaderOfLoggerFactory = LoggerFactory.class.getClassLoader();\n        ServiceLoader<SLF4JServiceProvider> serviceLoader = ServiceLoader.load(SLF4JServiceProvider.class, classLoaderOfLoggerFactory);\n        List<SLF4JServiceProvider> providerList = new ArrayList<>();\n        Iterator<SLF4JServiceProvider> iterator = serviceLoader.iterator();\n        while (iterator.hasNext()) {\n            safelyInstantiate(providerList, iterator);\n        }\n        return providerList;\n    }\n\n    private static void safelyInstantiate(List<SLF4JServiceProvider> providerList, Iterator<SLF4JServiceProvider> iterator) {\n        try {\n            SLF4JServiceProvider provider = iterator.next();\n            providerList.add(provider);\n        } catch (ServiceConfigurationError e) {\n            Util.report(\"A SLF4J service provider failed to instantiate:\\n\" + e.getMessage());\n        }\n    }\n\n    /**\n     * It is LoggerFactory's responsibility to track version changes and manage\n     * the compatibility list.\n     * <p>\n     * <p>\n     * It is assumed that all versions in the 1.6 are mutually compatible.\n     */\n    static private final String[] API_COMPATIBILITY_LIST = new String[] { \"2.0\" };\n\n    // private constructor prevents instantiation\n    private LoggerFactory() {\n    }\n\n    /**\n     * Force LoggerFactory to consider itself uninitialized.\n     * <p>\n     * <p>\n     * This method is intended to be called by classes (in the same package) for\n     * testing purposes. This method is internal. It can be modified, renamed or\n     * removed at any time without notice.\n     * <p>\n     * <p>\n     * You are strongly discouraged from calling this method in production code.\n     */\n    static void reset() {\n        INITIALIZATION_STATE = UNINITIALIZED;\n    }\n\n    private final static void performInitialization() {\n        bind();\n        if (INITIALIZATION_STATE == SUCCESSFUL_INITIALIZATION) {\n            versionSanityCheck();\n        }\n    }\n\n    private final static void bind() {\n        try {\n            List<SLF4JServiceProvider> providersList = findServiceProviders();\n            reportMultipleBindingAmbiguity(providersList);\n            if (providersList != null && !providersList.isEmpty()) {\n                PROVIDER = providersList.get(0);\n                // SLF4JServiceProvider.initialize() is intended to be called here and nowhere else.\n                PROVIDER.initialize();\n                INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;\n                reportActualBinding(providersList);\n            } else {\n                INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;\n                Util.report(\"No SLF4J providers were found.\");\n                Util.report(\"Defaulting to no-operation (NOP) logger implementation\");\n                Util.report(\"See \" + NO_PROVIDERS_URL + \" for further details.\");\n\n                Set<URL> staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();\n                reportIgnoredStaticLoggerBinders(staticLoggerBinderPathSet);\n            }\n            postBindCleanUp();\n        } catch (Exception e) {\n            failedBinding(e);\n            throw new IllegalStateException(\"Unexpected initialization failure\", e);\n        }\n    }\n\n    private static void reportIgnoredStaticLoggerBinders(Set<URL> staticLoggerBinderPathSet) {\n        if (staticLoggerBinderPathSet.isEmpty()) {\n            return;\n        }\n        Util.report(\"Class path contains SLF4J bindings targeting slf4j-api versions 1.7.x or earlier.\");\n\n        for (URL path : staticLoggerBinderPathSet) {\n            Util.report(\"Ignoring binding found at [\" + path + \"]\");\n        }\n        Util.report(\"See \" + IGNORED_BINDINGS_URL + \" for an explanation.\");\n\n    }\n\n    // We need to use the name of the StaticLoggerBinder class, but we can't\n    // reference the class itself.\n    private static final String STATIC_LOGGER_BINDER_PATH = \"org/slf4j/impl/StaticLoggerBinder.class\";\n\n    static Set<URL> findPossibleStaticLoggerBinderPathSet() {\n        // use Set instead of list in order to deal with bug #138\n        // LinkedHashSet appropriate here because it preserves insertion order\n        // during iteration\n        Set<URL> staticLoggerBinderPathSet = new LinkedHashSet<>();\n        try {\n            ClassLoader loggerFactoryClassLoader = LoggerFactory.class.getClassLoader();\n            Enumeration<URL> paths;\n            if (loggerFactoryClassLoader == null) {\n                paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);\n            } else {\n                paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);\n            }\n            while (paths.hasMoreElements()) {\n                URL path = paths.nextElement();\n                staticLoggerBinderPathSet.add(path);\n            }\n        } catch (IOException ioe) {\n            Util.report(\"Error getting resources from path\", ioe);\n        }\n        return staticLoggerBinderPathSet;\n    }\n\n    private static void postBindCleanUp() {\n        fixSubstituteLoggers();\n        replayEvents();\n        // release all resources in SUBST_FACTORY\n        SUBST_PROVIDER.getSubstituteLoggerFactory().clear();\n    }\n\n    private static void fixSubstituteLoggers() {\n        synchronized (SUBST_PROVIDER) {\n            SUBST_PROVIDER.getSubstituteLoggerFactory().postInitialization();\n            for (SubstituteLogger substLogger : SUBST_PROVIDER.getSubstituteLoggerFactory().getLoggers()) {\n                Logger logger = getLogger(substLogger.getName());\n                substLogger.setDelegate(logger);\n            }\n        }\n\n    }\n\n    static void failedBinding(Throwable t) {\n        INITIALIZATION_STATE = FAILED_INITIALIZATION;\n        Util.report(\"Failed to instantiate SLF4J LoggerFactory\", t);\n    }\n\n    private static void replayEvents() {\n        final LinkedBlockingQueue<SubstituteLoggingEvent> queue = SUBST_PROVIDER.getSubstituteLoggerFactory().getEventQueue();\n        final int queueSize = queue.size();\n        int count = 0;\n        final int maxDrain = 128;\n        List<SubstituteLoggingEvent> eventList = new ArrayList<>(maxDrain);\n        while (true) {\n            int numDrained = queue.drainTo(eventList, maxDrain);\n            if (numDrained == 0)\n                break;\n            for (SubstituteLoggingEvent event : eventList) {\n                replaySingleEvent(event);\n                if (count++ == 0)\n                    emitReplayOrSubstituionWarning(event, queueSize);\n            }\n            eventList.clear();\n        }\n    }\n\n    private static void emitReplayOrSubstituionWarning(SubstituteLoggingEvent event, int queueSize) {\n        if (event.getLogger().isDelegateEventAware()) {\n            emitReplayWarning(queueSize);\n        } else if (event.getLogger().isDelegateNOP()) {\n            // nothing to do\n        } else {\n            emitSubstitutionWarning();\n        }\n    }\n\n    private static void replaySingleEvent(SubstituteLoggingEvent event) {\n        if (event == null)\n            return;\n\n        SubstituteLogger substLogger = event.getLogger();\n        String loggerName = substLogger.getName();\n        if (substLogger.isDelegateNull()) {\n            throw new IllegalStateException(\"Delegate logger cannot be null at this state.\");\n        }\n\n        if (substLogger.isDelegateNOP()) {\n            // nothing to do\n        } else if (substLogger.isDelegateEventAware()) {\n            substLogger.log(event);\n        } else {\n            Util.report(loggerName);\n        }\n    }\n\n    private static void emitSubstitutionWarning() {\n        Util.report(\"The following set of substitute loggers may have been accessed\");\n        Util.report(\"during the initialization phase. Logging calls during this\");\n        Util.report(\"phase were not honored. However, subsequent logging calls to these\");\n        Util.report(\"loggers will work as normally expected.\");\n        Util.report(\"See also \" + SUBSTITUTE_LOGGER_URL);\n    }\n\n    private static void emitReplayWarning(int eventCount) {\n        Util.report(\"A number (\" + eventCount + \") of logging calls during the initialization phase have been intercepted and are\");\n        Util.report(\"now being replayed. These are subject to the filtering rules of the underlying logging system.\");\n        Util.report(\"See also \" + REPLAY_URL);\n    }\n\n    private final static void versionSanityCheck() {\n        try {\n            String requested = PROVIDER.getRequestedApiVersion();\n\n            boolean match = false;\n            for (String aAPI_COMPATIBILITY_LIST : API_COMPATIBILITY_LIST) {\n                if (requested.startsWith(aAPI_COMPATIBILITY_LIST)) {\n                    match = true;\n                }\n            }\n            if (!match) {\n                Util.report(\"The requested version \" + requested + \" by your slf4j binding is not compatible with \"\n                                + Arrays.asList(API_COMPATIBILITY_LIST).toString());\n                Util.report(\"See \" + VERSION_MISMATCH + \" for further details.\");\n            }\n        } catch (java.lang.NoSuchFieldError nsfe) {\n            // given our large user base and SLF4J's commitment to backward\n            // compatibility, we cannot cry here. Only for implementations\n            // which willingly declare a REQUESTED_API_VERSION field do we\n            // emit compatibility warnings.\n        } catch (Throwable e) {\n            // we should never reach here\n            Util.report(\"Unexpected problem occured during version sanity check\", e);\n        }\n    }\n\n    private static boolean isAmbiguousProviderList(List<SLF4JServiceProvider> providerList) {\n        return providerList.size() > 1;\n    }\n\n    /**\n     * Prints a warning message on the console if multiple bindings were found\n     * on the class path. No reporting is done otherwise.\n     * \n     */\n    private static void reportMultipleBindingAmbiguity(List<SLF4JServiceProvider> providerList) {\n        if (isAmbiguousProviderList(providerList)) {\n            Util.report(\"Class path contains multiple SLF4J providers.\");\n            for (SLF4JServiceProvider provider : providerList) {\n                Util.report(\"Found provider [\" + provider + \"]\");\n            }\n            Util.report(\"See \" + MULTIPLE_BINDINGS_URL + \" for an explanation.\");\n        }\n    }\n\n    private static void reportActualBinding(List<SLF4JServiceProvider> providerList) {\n        // binderPathSet can be null under Android\n        if (!providerList.isEmpty() && isAmbiguousProviderList(providerList)) {\n            Util.report(\"Actual provider is of type [\" + providerList.get(0) + \"]\");\n        }\n    }\n\n    /**\n     * Return a logger named according to the name parameter using the\n     * statically bound {@link ILoggerFactory} instance.\n     * \n     * @param name\n     *            The name of the logger.\n     * @return logger\n     */\n    public static Logger getLogger(String name) {\n        ILoggerFactory iLoggerFactory = getILoggerFactory();\n        return iLoggerFactory.getLogger(name);\n    }\n\n    /**\n     * Return a logger named corresponding to the class passed as parameter,\n     * using the statically bound {@link ILoggerFactory} instance.\n     * \n     * <p>\n     * In case the <code>clazz<\/code> parameter differs from the name of the\n     * caller as computed internally by SLF4J, a logger name mismatch warning\n     * will be printed but only if the\n     * <code>slf4j.detectLoggerNameMismatch<\/code> system property is set to\n     * true. By default, this property is not set and no warnings will be\n     * printed even in case of a logger name mismatch.\n     * \n     * @param clazz\n     *            the returned logger will be named after clazz\n     * @return logger\n     * \n     * \n     * @see <a\n     *      href=\"http://www.slf4j.org/codes.html#loggerNameMismatch\">Detected\n     *      logger name mismatch<\/a>\n     */\n    public static Logger getLogger(Class<?> clazz) {\n        Logger logger = getLogger(clazz.getName());\n        if (DETECT_LOGGER_NAME_MISMATCH) {\n            Class<?> autoComputedCallingClass = Util.getCallingClass();\n            if (autoComputedCallingClass != null && nonMatchingClasses(clazz, autoComputedCallingClass)) {\n                Util.report(String.format(\"Detected logger name mismatch. Given name: \\\"%s\\\"; computed name: \\\"%s\\\".\", logger.getName(),\n                                autoComputedCallingClass.getName()));\n                Util.report(\"See \" + LOGGER_NAME_MISMATCH_URL + \" for an explanation\");\n            }\n        }\n        return logger;\n    }\n\n    private static boolean nonMatchingClasses(Class<?> clazz, Class<?> autoComputedCallingClass) {\n        return !autoComputedCallingClass.isAssignableFrom(clazz);\n    }\n\n    /**\n     * Return the {@link ILoggerFactory} instance in use.\n     * <p>\n     * <p>\n     * ILoggerFactory instance is bound with this class at compile time.\n     * \n     * @return the ILoggerFactory instance in use\n     */\n    public static ILoggerFactory getILoggerFactory() {\n        return getProvider().getLoggerFactory();\n    }\n\n    /**\n     * Return the {@link SLF4JServiceProvider} in use.\n    \n     * @return provider in use\n     * @since 1.8.0\n     */\n    static SLF4JServiceProvider getProvider() {\n        if (INITIALIZATION_STATE == UNINITIALIZED) {\n            synchronized (LoggerFactory.class) {\n                if (INITIALIZATION_STATE == UNINITIALIZED) {\n                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;\n                    performInitialization();\n                }\n            }\n        }\n        switch (INITIALIZATION_STATE) {\n        case SUCCESSFUL_INITIALIZATION:\n            return PROVIDER;\n        case NOP_FALLBACK_INITIALIZATION:\n            return NOP_FALLBACK_SERVICE_PROVIDER;\n        case FAILED_INITIALIZATION:\n            throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);\n        case ONGOING_INITIALIZATION:\n            // support re-entrant behavior.\n            // See also http://jira.qos.ch/browse/SLF4J-97\n            return SUBST_PROVIDER;\n        }\n        throw new IllegalStateException(\"Unreachable code\");\n    }\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.security.AccessControlException;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.ServiceConfigurationError;\nimport java.util.ServiceLoader;\nimport java.util.Set;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nimport org.slf4j.event.SubstituteLoggingEvent;\nimport org.slf4j.helpers.NOP_FallbackServiceProvider;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.helpers.SubstituteServiceProvider;\nimport org.slf4j.helpers.Util;\nimport org.slf4j.spi.SLF4JServiceProvider;\n\n/**\n * The <code>LoggerFactory<\/code> is a utility class producing Loggers for\n * various logging APIs, most notably for log4j, logback and JDK 1.4 logging.\n * Other implementations such as {@link org.slf4j.helpers.NOPLogger NOPLogger} and\n * SimpleLogger are also supported.\n * \n * <p><code>LoggerFactory<\/code> is essentially a wrapper around an\n * {@link ILoggerFactory} instance bound with <code>LoggerFactory<\/code> at\n * compile time.\n * \n * <p>\n * Please note that all methods in <code>LoggerFactory<\/code> are static.\n * \n * @author Alexander Dorokhine\n * @author Robert Elliot\n * @author Ceki G&uuml;lc&uuml;\n * \n */\npublic final class LoggerFactory {\n\n    static final String CODES_PREFIX = \"https://www.slf4j.org/codes.html\";\n\n    static final String NO_PROVIDERS_URL = CODES_PREFIX + \"#noProviders\";\n    static final String IGNORED_BINDINGS_URL = CODES_PREFIX + \"#ignoredBindings\";\n\n    static final String NO_STATICLOGGERBINDER_URL = CODES_PREFIX + \"#StaticLoggerBinder\";\n    static final String MULTIPLE_BINDINGS_URL = CODES_PREFIX + \"#multiple_bindings\";\n    static final String NULL_LF_URL = CODES_PREFIX + \"#null_LF\";\n    static final String VERSION_MISMATCH = CODES_PREFIX + \"#version_mismatch\";\n    static final String SUBSTITUTE_LOGGER_URL = CODES_PREFIX + \"#substituteLogger\";\n    static final String LOGGER_NAME_MISMATCH_URL = CODES_PREFIX + \"#loggerNameMismatch\";\n    static final String REPLAY_URL = CODES_PREFIX + \"#replay\";\n\n    static final String UNSUCCESSFUL_INIT_URL = CODES_PREFIX + \"#unsuccessfulInit\";\n    static final String UNSUCCESSFUL_INIT_MSG = \"org.slf4j.LoggerFactory in failed state. Original exception was thrown EARLIER. See also \"\n                    + UNSUCCESSFUL_INIT_URL;\n\n    static final int UNINITIALIZED = 0;\n    static final int ONGOING_INITIALIZATION = 1;\n    static final int FAILED_INITIALIZATION = 2;\n    static final int SUCCESSFUL_INITIALIZATION = 3;\n    static final int NOP_FALLBACK_INITIALIZATION = 4;\n\n    static volatile int INITIALIZATION_STATE = UNINITIALIZED;\n    static final SubstituteServiceProvider SUBST_PROVIDER = new SubstituteServiceProvider();\n    static final NOP_FallbackServiceProvider NOP_FALLBACK_SERVICE_PROVIDER = new NOP_FallbackServiceProvider();\n\n    // Support for detecting mismatched logger names.\n    static final String DETECT_LOGGER_NAME_MISMATCH_PROPERTY = \"slf4j.detectLoggerNameMismatch\";\n    static final String JAVA_VENDOR_PROPERTY = \"java.vendor.url\";\n\n    static boolean DETECT_LOGGER_NAME_MISMATCH = Util.safeGetBooleanSystemProperty(DETECT_LOGGER_NAME_MISMATCH_PROPERTY);\n\n    static volatile SLF4JServiceProvider PROVIDER;\n\n    // Package access for tests\n    static List<SLF4JServiceProvider> findServiceProviders() {\n        final ClassLoader cl = LoggerFactory.class.getClassLoader();\n        final PrivilegedAction<ServiceLoader<SLF4JServiceProvider>> action = () -> ServiceLoader.load(SLF4JServiceProvider.class, cl);\n        final ServiceLoader<SLF4JServiceProvider> serviceLoader = System.getSecurityManager() != null\n                        ? AccessController.doPrivileged(action)\n                        : action.run();\n        List<SLF4JServiceProvider> providerList = new ArrayList<>();\n        Iterator<SLF4JServiceProvider> iterator = serviceLoader.iterator();\n        while (iterator.hasNext()) {\n            try {\n                providerList.add(iterator.next());\n            } catch (ServiceConfigurationError | AccessControlException e) {\n                // Short warning\n                Util.report(\"A SLF4J service provider failed to instantiate:\\n\" + e.getMessage());\n            }\n        }\n        return providerList;\n    }\n\n    /**\n     * It is LoggerFactory's responsibility to track version changes and manage\n     * the compatibility list.\n     * <p>\n     * <p>\n     * It is assumed that all versions in the 1.6 are mutually compatible.\n     */\n    static private final String[] API_COMPATIBILITY_LIST = new String[] { \"2.0\" };\n\n    // private constructor prevents instantiation\n    private LoggerFactory() {\n    }\n\n    /**\n     * Force LoggerFactory to consider itself uninitialized.\n     * <p>\n     * <p>\n     * This method is intended to be called by classes (in the same package) for\n     * testing purposes. This method is internal. It can be modified, renamed or\n     * removed at any time without notice.\n     * <p>\n     * <p>\n     * You are strongly discouraged from calling this method in production code.\n     */\n    static void reset() {\n        INITIALIZATION_STATE = UNINITIALIZED;\n    }\n\n    private final static void performInitialization() {\n        bind();\n        if (INITIALIZATION_STATE == SUCCESSFUL_INITIALIZATION) {\n            versionSanityCheck();\n        }\n    }\n\n    private final static void bind() {\n        try {\n            List<SLF4JServiceProvider> providersList = findServiceProviders();\n            reportMultipleBindingAmbiguity(providersList);\n            if (providersList != null && !providersList.isEmpty()) {\n                PROVIDER = providersList.get(0);\n                // SLF4JServiceProvider.initialize() is intended to be called here and nowhere else.\n                PROVIDER.initialize();\n                INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;\n                reportActualBinding(providersList);\n            } else {\n                INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;\n                Util.report(\"No SLF4J providers were found.\");\n                Util.report(\"Defaulting to no-operation (NOP) logger implementation\");\n                Util.report(\"See \" + NO_PROVIDERS_URL + \" for further details.\");\n\n                Set<URL> staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();\n                reportIgnoredStaticLoggerBinders(staticLoggerBinderPathSet);\n            }\n            postBindCleanUp();\n        } catch (Exception e) {\n            failedBinding(e);\n            throw new IllegalStateException(\"Unexpected initialization failure\", e);\n        }\n    }\n\n    private static void reportIgnoredStaticLoggerBinders(Set<URL> staticLoggerBinderPathSet) {\n        if (staticLoggerBinderPathSet.isEmpty()) {\n            return;\n        }\n        Util.report(\"Class path contains SLF4J bindings targeting slf4j-api versions 1.7.x or earlier.\");\n\n        for (URL path : staticLoggerBinderPathSet) {\n            Util.report(\"Ignoring binding found at [\" + path + \"]\");\n        }\n        Util.report(\"See \" + IGNORED_BINDINGS_URL + \" for an explanation.\");\n\n    }\n\n    // We need to use the name of the StaticLoggerBinder class, but we can't\n    // reference the class itself.\n    private static final String STATIC_LOGGER_BINDER_PATH = \"org/slf4j/impl/StaticLoggerBinder.class\";\n\n    static Set<URL> findPossibleStaticLoggerBinderPathSet() {\n        // use Set instead of list in order to deal with bug #138\n        // LinkedHashSet appropriate here because it preserves insertion order\n        // during iteration\n        Set<URL> staticLoggerBinderPathSet = new LinkedHashSet<>();\n        try {\n            ClassLoader loggerFactoryClassLoader = LoggerFactory.class.getClassLoader();\n            Enumeration<URL> paths;\n            if (loggerFactoryClassLoader == null) {\n                paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);\n            } else {\n                paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);\n            }\n            while (paths.hasMoreElements()) {\n                URL path = paths.nextElement();\n                staticLoggerBinderPathSet.add(path);\n            }\n        } catch (IOException ioe) {\n            Util.report(\"Error getting resources from path\", ioe);\n        }\n        return staticLoggerBinderPathSet;\n    }\n\n    private static void postBindCleanUp() {\n        fixSubstituteLoggers();\n        replayEvents();\n        // release all resources in SUBST_FACTORY\n        SUBST_PROVIDER.getSubstituteLoggerFactory().clear();\n    }\n\n    private static void fixSubstituteLoggers() {\n        synchronized (SUBST_PROVIDER) {\n            SUBST_PROVIDER.getSubstituteLoggerFactory().postInitialization();\n            for (SubstituteLogger substLogger : SUBST_PROVIDER.getSubstituteLoggerFactory().getLoggers()) {\n                Logger logger = getLogger(substLogger.getName());\n                substLogger.setDelegate(logger);\n            }\n        }\n\n    }\n\n    static void failedBinding(Throwable t) {\n        INITIALIZATION_STATE = FAILED_INITIALIZATION;\n        Util.report(\"Failed to instantiate SLF4J LoggerFactory\", t);\n    }\n\n    private static void replayEvents() {\n        final LinkedBlockingQueue<SubstituteLoggingEvent> queue = SUBST_PROVIDER.getSubstituteLoggerFactory().getEventQueue();\n        final int queueSize = queue.size();\n        int count = 0;\n        final int maxDrain = 128;\n        List<SubstituteLoggingEvent> eventList = new ArrayList<>(maxDrain);\n        while (true) {\n            int numDrained = queue.drainTo(eventList, maxDrain);\n            if (numDrained == 0)\n                break;\n            for (SubstituteLoggingEvent event : eventList) {\n                replaySingleEvent(event);\n                if (count++ == 0)\n                    emitReplayOrSubstituionWarning(event, queueSize);\n            }\n            eventList.clear();\n        }\n    }\n\n    private static void emitReplayOrSubstituionWarning(SubstituteLoggingEvent event, int queueSize) {\n        if (event.getLogger().isDelegateEventAware()) {\n            emitReplayWarning(queueSize);\n        } else if (event.getLogger().isDelegateNOP()) {\n            // nothing to do\n        } else {\n            emitSubstitutionWarning();\n        }\n    }\n\n    private static void replaySingleEvent(SubstituteLoggingEvent event) {\n        if (event == null)\n            return;\n\n        SubstituteLogger substLogger = event.getLogger();\n        String loggerName = substLogger.getName();\n        if (substLogger.isDelegateNull()) {\n            throw new IllegalStateException(\"Delegate logger cannot be null at this state.\");\n        }\n\n        if (substLogger.isDelegateNOP()) {\n            // nothing to do\n        } else if (substLogger.isDelegateEventAware()) {\n            substLogger.log(event);\n        } else {\n            Util.report(loggerName);\n        }\n    }\n\n    private static void emitSubstitutionWarning() {\n        Util.report(\"The following set of substitute loggers may have been accessed\");\n        Util.report(\"during the initialization phase. Logging calls during this\");\n        Util.report(\"phase were not honored. However, subsequent logging calls to these\");\n        Util.report(\"loggers will work as normally expected.\");\n        Util.report(\"See also \" + SUBSTITUTE_LOGGER_URL);\n    }\n\n    private static void emitReplayWarning(int eventCount) {\n        Util.report(\"A number (\" + eventCount + \") of logging calls during the initialization phase have been intercepted and are\");\n        Util.report(\"now being replayed. These are subject to the filtering rules of the underlying logging system.\");\n        Util.report(\"See also \" + REPLAY_URL);\n    }\n\n    private final static void versionSanityCheck() {\n        try {\n            String requested = PROVIDER.getRequestedApiVersion();\n\n            boolean match = false;\n            for (String aAPI_COMPATIBILITY_LIST : API_COMPATIBILITY_LIST) {\n                if (requested.startsWith(aAPI_COMPATIBILITY_LIST)) {\n                    match = true;\n                }\n            }\n            if (!match) {\n                Util.report(\"The requested version \" + requested + \" by your slf4j binding is not compatible with \"\n                                + Arrays.asList(API_COMPATIBILITY_LIST).toString());\n                Util.report(\"See \" + VERSION_MISMATCH + \" for further details.\");\n            }\n        } catch (java.lang.NoSuchFieldError nsfe) {\n            // given our large user base and SLF4J's commitment to backward\n            // compatibility, we cannot cry here. Only for implementations\n            // which willingly declare a REQUESTED_API_VERSION field do we\n            // emit compatibility warnings.\n        } catch (Throwable e) {\n            // we should never reach here\n            Util.report(\"Unexpected problem occured during version sanity check\", e);\n        }\n    }\n\n    private static boolean isAmbiguousProviderList(List<SLF4JServiceProvider> providerList) {\n        return providerList.size() > 1;\n    }\n\n    /**\n     * Prints a warning message on the console if multiple bindings were found\n     * on the class path. No reporting is done otherwise.\n     * \n     */\n    private static void reportMultipleBindingAmbiguity(List<SLF4JServiceProvider> providerList) {\n        if (isAmbiguousProviderList(providerList)) {\n            Util.report(\"Class path contains multiple SLF4J providers.\");\n            for (SLF4JServiceProvider provider : providerList) {\n                Util.report(\"Found provider [\" + provider + \"]\");\n            }\n            Util.report(\"See \" + MULTIPLE_BINDINGS_URL + \" for an explanation.\");\n        }\n    }\n\n    private static void reportActualBinding(List<SLF4JServiceProvider> providerList) {\n        // binderPathSet can be null under Android\n        if (!providerList.isEmpty() && isAmbiguousProviderList(providerList)) {\n            Util.report(\"Actual provider is of type [\" + providerList.get(0) + \"]\");\n        }\n    }\n\n    /**\n     * Return a logger named according to the name parameter using the\n     * statically bound {@link ILoggerFactory} instance.\n     * \n     * @param name\n     *            The name of the logger.\n     * @return logger\n     */\n    public static Logger getLogger(String name) {\n        ILoggerFactory iLoggerFactory = getILoggerFactory();\n        return iLoggerFactory.getLogger(name);\n    }\n\n    /**\n     * Return a logger named corresponding to the class passed as parameter,\n     * using the statically bound {@link ILoggerFactory} instance.\n     * \n     * <p>\n     * In case the <code>clazz<\/code> parameter differs from the name of the\n     * caller as computed internally by SLF4J, a logger name mismatch warning\n     * will be printed but only if the\n     * <code>slf4j.detectLoggerNameMismatch<\/code> system property is set to\n     * true. By default, this property is not set and no warnings will be\n     * printed even in case of a logger name mismatch.\n     * \n     * @param clazz\n     *            the returned logger will be named after clazz\n     * @return logger\n     * \n     * \n     * @see <a\n     *      href=\"http://www.slf4j.org/codes.html#loggerNameMismatch\">Detected\n     *      logger name mismatch<\/a>\n     */\n    public static Logger getLogger(Class<?> clazz) {\n        Logger logger = getLogger(clazz.getName());\n        if (DETECT_LOGGER_NAME_MISMATCH) {\n            Class<?> autoComputedCallingClass = Util.getCallingClass();\n            if (autoComputedCallingClass != null && nonMatchingClasses(clazz, autoComputedCallingClass)) {\n                Util.report(String.format(\"Detected logger name mismatch. Given name: \\\"%s\\\"; computed name: \\\"%s\\\".\", logger.getName(),\n                                autoComputedCallingClass.getName()));\n                Util.report(\"See \" + LOGGER_NAME_MISMATCH_URL + \" for an explanation\");\n            }\n        }\n        return logger;\n    }\n\n    private static boolean nonMatchingClasses(Class<?> clazz, Class<?> autoComputedCallingClass) {\n        return !autoComputedCallingClass.isAssignableFrom(clazz);\n    }\n\n    /**\n     * Return the {@link ILoggerFactory} instance in use.\n     * <p>\n     * <p>\n     * ILoggerFactory instance is bound with this class at compile time.\n     * \n     * @return the ILoggerFactory instance in use\n     */\n    public static ILoggerFactory getILoggerFactory() {\n        return getProvider().getLoggerFactory();\n    }\n\n    /**\n     * Return the {@link SLF4JServiceProvider} in use.\n    \n     * @return provider in use\n     * @since 1.8.0\n     */\n    static SLF4JServiceProvider getProvider() {\n        if (INITIALIZATION_STATE == UNINITIALIZED) {\n            synchronized (LoggerFactory.class) {\n                if (INITIALIZATION_STATE == UNINITIALIZED) {\n                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;\n                    performInitialization();\n                }\n            }\n        }\n        switch (INITIALIZATION_STATE) {\n        case SUCCESSFUL_INITIALIZATION:\n            return PROVIDER;\n        case NOP_FALLBACK_INITIALIZATION:\n            return NOP_FALLBACK_SERVICE_PROVIDER;\n        case FAILED_INITIALIZATION:\n            throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);\n        case ONGOING_INITIALIZATION:\n            // support re-entrant behavior.\n            // See also http://jira.qos.ch/browse/SLF4J-97\n            return SUBST_PROVIDER;\n        }\n        throw new IllegalStateException(\"Unreachable code\");\n    }\n}\n","lineNo":118}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport org.slf4j.spi.MDCAdapter;\n\nimport java.util.*;\nimport java.util.Map;\n\n/**\n * Basic MDC implementation, which can be used with logging systems that lack\n * out-of-the-box MDC support.\n *\n * This code was initially inspired by  logback's LogbackMDCAdapter. However,\n * LogbackMDCAdapter has evolved and is now considerably more sophisticated.\n *\n * @author Ceki Gulcu\n * @author Maarten Bosteels\n * @author Lukasz Cwik\n * \n * @since 1.5.0\n */\npublic class BasicMDCAdapter implements MDCAdapter {\n\n    private InheritableThreadLocal<Map<String, String>> inheritableThreadLocal = new InheritableThreadLocal<Map<String, String>>() {\n        @Override\n        protected Map<String, String> childValue(Map<String, String> parentValue) {\n            if (parentValue == null) {\n                return null;\n            }\n            return new HashMap<String, String>(parentValue);\n        }\n    };\n\n    /**\n     * Put a context value (the <code>val<\/code> parameter) as identified with\n     * the <code>key<\/code> parameter into the current thread's context map.\n     * Note that contrary to log4j, the <code>val<\/code> parameter can be null.\n     *\n     * <p>\n     * If the current thread does not have a context map it is created as a side\n     * effect of this call.\n     *\n     * @throws IllegalArgumentException\n     *                 in case the \"key\" parameter is null\n     */\n    public void put(String key, String val) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map == null) {\n            map = new HashMap<String, String>();\n            inheritableThreadLocal.set(map);\n        }\n        map.put(key, val);\n    }\n\n    /**\n     * Get the context identified by the <code>key<\/code> parameter.\n     */\n    public String get(String key) {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if ((map != null) && (key != null)) {\n            return map.get(key);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Remove the the context identified by the <code>key<\/code> parameter.\n     */\n    public void remove(String key) {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            map.remove(key);\n        }\n    }\n\n    /**\n     * Clear all entries in the MDC.\n     */\n    public void clear() {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            map.clear();\n            inheritableThreadLocal.remove();\n        }\n    }\n\n    /**\n     * Returns the keys in the MDC as a {@link Set} of {@link String}s The\n     * returned value can be null.\n     *\n     * @return the keys in the MDC\n     */\n    public Set<String> getKeys() {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            return map.keySet();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Return a copy of the current thread's context map.\n     * Returned value may be null.\n     *\n     */\n    public Map<String, String> getCopyOfContextMap() {\n        Map<String, String> oldMap = inheritableThreadLocal.get();\n        if (oldMap != null) {\n            return new HashMap<String, String>(oldMap);\n        } else {\n            return null;\n        }\n    }\n\n    public void setContextMap(Map<String, String> contextMap) {\n        Map<String, String> copy = null;\n        if(contextMap != null) {\n            copy = new HashMap<String, String>(contextMap);\n        }\n        inheritableThreadLocal.set(copy);\n    }\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport org.slf4j.spi.MDCAdapter;\n\nimport java.util.*;\nimport java.util.Map;\n\n/**\n * Basic MDC implementation, which can be used with logging systems that lack\n * out-of-the-box MDC support.\n *\n * This code was initially inspired by  logback's LogbackMDCAdapter. However,\n * LogbackMDCAdapter has evolved and is now considerably more sophisticated.\n *\n * @author Ceki Gulcu\n * @author Maarten Bosteels\n * @author Lukasz Cwik\n * \n * @since 1.5.0\n */\npublic class BasicMDCAdapter implements MDCAdapter {\n\n    private InheritableThreadLocal<Map<String, String>> inheritableThreadLocal = new InheritableThreadLocal<Map<String, String>>() {\n        @Override\n        protected Map<String, String> childValue(Map<String, String> parentValue) {\n            if (parentValue == null) {\n                return null;\n            }\n            return new HashMap<String, String>(parentValue);\n        }\n    };\n\n    /**\n     * Put a context value (the <code>val<\/code> parameter) as identified with\n     * the <code>key<\/code> parameter into the current thread's context map.\n     * Note that contrary to log4j, the <code>val<\/code> parameter can be null.\n     *\n     * <p>\n     * If the current thread does not have a context map it is created as a side\n     * effect of this call.\n     *\n     * @throws IllegalArgumentException\n     *                 in case the \"key\" parameter is null\n     */\n    public void put(String key, String val) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map == null) {\n            map = new HashMap<String, String>();\n            inheritableThreadLocal.set(map);\n        }\n        map.put(key, val);\n    }\n\n    /**\n     * Get the context identified by the <code>key<\/code> parameter.\n     */\n    public String get(String key) {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if ((map != null) && (key != null)) {\n            return map.get(key);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Remove the the context identified by the <code>key<\/code> parameter.\n     */\n    public void remove(String key) {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            map.remove(key);\n        }\n    }\n\n    /**\n     * Clear all entries in the MDC.\n     */\n    public void clear() {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            map.clear();\n            inheritableThreadLocal.remove();\n        }\n    }\n\n    /**\n     * Returns the keys in the MDC as a {@link Set} of {@link String}s The\n     * returned value can be null.\n     *\n     * @return the keys in the MDC\n     */\n    public Set<String> getKeys() {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            return map.keySet();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Return a copy of the current thread's context map.\n     * Returned value may be null.\n     *\n     */\n    public Map<String, String> getCopyOfContextMap() {\n        Map<String, String> oldMap = inheritableThreadLocal.get();\n        if (oldMap != null) {\n            return new HashMap<String, String>(oldMap);\n        } else {\n            return null;\n        }\n    }\n\n    public void setContextMap(Map<String, String> contextMap) {\n        inheritableThreadLocal.set(new HashMap<String, String>(contextMap));\n    }\n}\n","lineNo":144}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.jul;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.AbstractLogger;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.LegacyAbstractLogger;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.NormalizedParameters;\nimport org.slf4j.helpers.ParameterNormalizer;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends LegacyAbstractLogger implements LocationAwareLogger {\n\n\tprivate static final long serialVersionUID = -8053026990503422791L;\n\n\ttransient final java.util.logging.Logger logger;\n\n\t// WARN: JDK14LoggerAdapter constructor should have only package access so\n\t// that only JDK14LoggerFactory be able to create one.\n\tJDK14LoggerAdapter(java.util.logging.Logger logger) {\n\t\tthis.logger = logger;\n\t\tthis.name = logger.getName();\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the FINEST level?\n\t * \n\t * @return True if this Logger is enabled for level FINEST, false otherwise.\n\t */\n\tpublic boolean isTraceEnabled() {\n\t\treturn logger.isLoggable(Level.FINEST);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the FINE level?\n\t * \n\t * @return True if this Logger is enabled for level FINE, false otherwise.\n\t */\n\tpublic boolean isDebugEnabled() {\n\t\treturn logger.isLoggable(Level.FINE);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the INFO level?\n\t * \n\t * @return True if this Logger is enabled for the INFO level, false otherwise.\n\t */\n\tpublic boolean isInfoEnabled() {\n\t\treturn logger.isLoggable(Level.INFO);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the WARNING level?\n\t * \n\t * @return True if this Logger is enabled for the WARNING level, false\n\t *         otherwise.\n\t */\n\tpublic boolean isWarnEnabled() {\n\t\treturn logger.isLoggable(Level.WARNING);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for level SEVERE?\n\t * \n\t * @return True if this Logger is enabled for level SEVERE, false otherwise.\n\t */\n\tpublic boolean isErrorEnabled() {\n\t\treturn logger.isLoggable(Level.SEVERE);\n\t}\n\n//    /**\n//     * Log the message at the specified level with the specified throwable if any.\n//     * This method creates a LogRecord and fills in caller date before calling\n//     * this instance's JDK14 logger.\n//     * \n//     * See bug report #13 for more details.\n//     * \n//     * @param level\n//     * @param msg\n//     * @param t\n//     */\n//    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n//        // millis and thread are filled by the constructor\n//        LogRecord record = new LogRecord(level, msg);\n//        record.setLoggerName(getName());\n//        record.setThrown(t);\n//        // Note: parameters in record are not set because SLF4J only\n//        // supports a single formatting style\n//        fillCallerData(callerFQCN, record);\n//        logger.log(record);\n//    }\n\n\t/**\n\t * Log the message at the specified level with the specified throwable if any.\n\t * This method creates a LogRecord and fills in caller date before calling this\n\t * instance's JDK14 logger.\n\t */\n\t@Override\n\tprotected void handleNormalizedLoggingCall(org.slf4j.event.Level level, Marker marker, String msg, Object[] args,\n\t\t\tThrowable throwable) {\n\t\tinnerNormalizedLoggingCallHandler(getFullyQualifiedCallerName(), level, marker, msg, args, throwable);\n\t}\n\n\t\n\tprivate void innerNormalizedLoggingCallHandler(String fqcn, org.slf4j.event.Level level, Marker marker, String msg, Object[] args,\n\t\t\tThrowable throwable) {\n\t\t// millis and thread are filled by the constructor\n\t\tLevel julLevel = slf4jLevelToJULLevel(level);\n\t\tString formattedMessage = MessageFormatter.basicArrayFormat(msg, args);\n\t\tLogRecord record = new LogRecord(julLevel, formattedMessage);\n\n\t\t// https://jira.qos.ch/browse/SLF4J-13\n\t\trecord.setLoggerName(getName());\n\t\trecord.setThrown(throwable);\n\t\t// Note: parameters in record are not set because SLF4J only\n\t\t// supports a single formatting style\n\t\t// See also https://jira.qos.ch/browse/SLF4J-10\n\t\tfillCallerData(fqcn, record);\n\t\tlogger.log(record);\n\t}\n\n\t\n\t@Override\n\tprotected String getFullyQualifiedCallerName() {\n\t\treturn SELF;\n\t}\n\t\n\t\n\t@Override\n\tpublic void log(Marker marker, String callerFQCN, int slf4jLevelInt, String message, Object[] arguments,\n\t\t\tThrowable throwable) {\n\n\t\torg.slf4j.event.Level slf4jLevel = org.slf4j.event.Level.intToLevel(slf4jLevelInt);\n\t\tLevel julLevel = slf4jLevelIntToJULLevel(slf4jLevelInt);\n\t\t\n\t\tif (logger.isLoggable(julLevel)) {\n\t\t\tNormalizedParameters np = ParameterNormalizer.normalize(message, arguments, throwable);\n\t\t\tinnerNormalizedLoggingCallHandler(callerFQCN, slf4jLevel, marker, np.getMessage(), np.getArguments(), np.getThrowable());\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Fill in caller data if possible.\n\t * \n\t * @param record The record to update\n\t */\n\tfinal private void fillCallerData(String callerFQCN, LogRecord record) {\n\t\tStackTraceElement[] steArray = new Throwable().getStackTrace();\n\n\t\tint selfIndex = -1;\n\t\tfor (int i = 0; i < steArray.length; i++) {\n\t\t\tfinal String className = steArray[i].getClassName();\n\n\t\t\tif (barrierMatch(callerFQCN, className)) {\n\t\t\t\tselfIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint found = -1;\n\t\tfor (int i = selfIndex + 1; i < steArray.length; i++) {\n\t\t\tfinal String className = steArray[i].getClassName();\n\t\t\tif (!(barrierMatch(callerFQCN, className))) {\n\t\t\t\tfound = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found != -1) {\n\t\t\tStackTraceElement ste = steArray[found];\n\t\t\t// setting the class name has the side effect of setting\n\t\t\t// the needToInferCaller variable to false.\n\t\t\trecord.setSourceClassName(ste.getClassName());\n\t\t\trecord.setSourceMethodName(ste.getMethodName());\n\t\t}\n\t}\n\n\tstatic String SELF = JDK14LoggerAdapter.class.getName();\n\t\n\tstatic String SUPER = LegacyAbstractLogger.class.getName();\n\tstatic String SUPER_OF_SUPER = AbstractLogger.class.getName();\n\tstatic String SUBSTITUE = SubstituteLogger.class.getName();\n\n\tstatic String BARRIER_CLASSES[] = new String[] { SUPER_OF_SUPER, SUPER, SELF, SUBSTITUE };\n\n\tprivate boolean barrierMatch(String callerFQCN, String candidateClassName) {\n\t\tif (candidateClassName.equals(callerFQCN))\n\t\t\treturn true;\n\t\tfor (String barrierClassName : BARRIER_CLASSES) {\n\t\t\tif (barrierClassName.equals(candidateClassName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tprivate static Level slf4jLevelIntToJULLevel(int levelInt) {\n\t\torg.slf4j.event.Level slf4jLevel = org.slf4j.event.Level.intToLevel(levelInt);\n\t\treturn slf4jLevelToJULLevel(slf4jLevel);\n\t}\n\n\tprivate static Level slf4jLevelToJULLevel(org.slf4j.event.Level slf4jLevel) {\n\t\tLevel julLevel;\n\t\tswitch (slf4jLevel) {\n\t\tcase TRACE:\n\t\t\tjulLevel = Level.FINEST;\n\t\t\tbreak;\n\t\tcase DEBUG:\n\t\t\tjulLevel = Level.FINE;\n\t\t\tbreak;\n\t\tcase INFO:\n\t\t\tjulLevel = Level.INFO;\n\t\t\tbreak;\n\t\tcase WARN:\n\t\t\tjulLevel = Level.WARNING;\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\t\tjulLevel = Level.SEVERE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Level \" + slf4jLevel + \" is not recognized.\");\n\t\t}\n\t\treturn julLevel;\n\t}\n\n\t/**\n\t * @since 1.7.15\n\t */\n\tpublic void log(LoggingEvent event) {\n\t\t// assumes that the invocation is made from a substitute logger\n\t\t// this assumption might change in the future with the advent of a fluent API\n\t\tLevel julLevel = slf4jLevelToJULLevel(event.getLevel());\n\t\tif (logger.isLoggable(julLevel)) {\n\t\t\tLogRecord record = eventToRecord(event, julLevel);\n\t\t\tlogger.log(record);\n\t\t}\n\t}\n\n\tprivate LogRecord eventToRecord(LoggingEvent event, Level julLevel) {\n\t\tString format = event.getMessage();\n\t\tObject[] arguments = event.getArgumentArray();\n\t\tFormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n\t\tif (ft.getThrowable() != null && event.getThrowable() != null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"both last element in argument array and last argument are of type Throwable\");\n\t\t}\n\n\t\tThrowable t = event.getThrowable();\n\t\tif (ft.getThrowable() != null) {\n\t\t\tt = ft.getThrowable();\n\t\t\tthrow new IllegalStateException(\"fix above code\");\n\t\t}\n\n\t\tLogRecord record = new LogRecord(julLevel, ft.getMessage());\n\t\trecord.setLoggerName(event.getLoggerName());\n\t\trecord.setMillis(event.getTimeStamp());\n\t\trecord.setSourceClassName(EventConstants.NA_SUBST);\n\t\trecord.setSourceMethodName(EventConstants.NA_SUBST);\n\n\t\trecord.setThrown(t);\n\t\treturn record;\n\t}\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.jul;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger {\n\n    private static final long serialVersionUID = -8053026990503422791L;\n\n    transient final java.util.logging.Logger logger;\n\n    // WARN: JDK14LoggerAdapter constructor should have only package access so\n    // that only JDK14LoggerFactory be able to create one.\n    JDK14LoggerAdapter(java.util.logging.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n    }\n\n    /**\n     * Is this logger instance enabled for the FINEST level?\n     * \n     * @return True if this Logger is enabled for level FINEST, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINEST);\n    }\n\n    /**\n     * Log a message object at level FINEST.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINEST.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void trace(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINEST with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the FINE level?\n     * \n     * @return True if this Logger is enabled for level FINE, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    /**\n     * Log a message object at level FINE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINE.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void debug(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the WARNING level?\n     * \n     * @return True if this Logger is enabled for the WARNING level, false\n     *         otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    /**\n     * Log a message object at the WARNING level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARNING according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARNING level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for level SEVERE?\n     * \n     * @return True if this Logger is enabled for level SEVERE, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n\n    /**\n     * Log a message object at the SEVERE level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level SEVERE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void error(String format, Object... arguments) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the SEVERE level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, t);\n        }\n    }\n\n    /**\n     * Log the message at the specified level with the specified throwable if any.\n     * This method creates a LogRecord and fills in caller date before calling\n     * this instance's JDK14 logger.\n     * \n     * See bug report #13 for more details.\n     * \n     * @param level\n     * @param msg\n     * @param t\n     */\n    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n        // millis and thread are filled by the constructor\n        LogRecord record = new LogRecord(level, msg);\n        record.setLoggerName(getName());\n        record.setThrown(t);\n        // Note: parameters in record are not set because SLF4J only\n        // supports a single formatting style\n        fillCallerData(callerFQCN, record);\n        logger.log(record);\n    }\n\n    static String SELF = JDK14LoggerAdapter.class.getName();\n    static String SUPER = MarkerIgnoringBase.class.getName();\n    static String SUBSTITUE = SubstituteLogger.class.getName();\n    \n    static String BARRIER_CLASSES[] = new String[] {SELF, SUPER, SUBSTITUE};\n  \n    /**\n     * Fill in caller data if possible.\n     * \n     * @param record\n     *          The record to update\n     */\n\tfinal private void fillCallerData(String callerFQCN, LogRecord record) {\n        StackTraceElement[] steArray = new Throwable().getStackTrace();\n\n        int selfIndex = -1;\n        for (int i = 0; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            \n            if (barrierMatch(callerFQCN, className)) {\n                selfIndex = i;\n                break;\n            }\n        }\n\n        int found = -1;\n        for (int i = selfIndex + 1; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            if (!(barrierMatch(callerFQCN, className))) {\n                found = i;\n                break;\n            }\n        }\n\n        if (found != -1) {\n            StackTraceElement ste = steArray[found];\n            // setting the class name has the side effect of setting\n            // the needToInferCaller variable to false.\n            record.setSourceClassName(ste.getClassName());\n            record.setSourceMethodName(ste.getMethodName());\n        }\n    }\n\n    private boolean barrierMatch(String callerFQCN, String candidateClassName) {\n    \tif(candidateClassName.equals(callerFQCN))\n    \t\treturn true;\n    \tfor(String barrierClassName: BARRIER_CLASSES) {\n    \t\tif(barrierClassName.equals(candidateClassName)) {\n    \t\t  return true;\n    \t\t}\n    \t}\n    \treturn false;\n\t}\n\n\tpublic void log(Marker marker, String callerFQCN, int level, String message, Object[] argArray, Throwable t) {\n        Level julLevel = slf4jLevelIntToJULLevel(level);\n        // the logger.isLoggable check avoids the unconditional\n        // construction of location data for disabled log\n        // statements. As of 2008-07-31, callers of this method\n        // do not perform this check. See also\n        // http://jira.qos.ch/browse/SLF4J-81\n        if (logger.isLoggable(julLevel)) {\n            log(callerFQCN, julLevel, message, t);\n        }\n    }\n\n    private Level slf4jLevelIntToJULLevel(int slf4jLevelInt) {\n        Level julLevel;\n        switch (slf4jLevelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            julLevel = Level.FINEST;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            julLevel = Level.FINE;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            julLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            julLevel = Level.WARNING;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            julLevel = Level.SEVERE;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + slf4jLevelInt + \" is not recognized.\");\n        }\n        return julLevel;\n    }\n\n    /**\n     * @since 1.7.15\n     */\n    public void log(LoggingEvent event) {\n    \t// assumes that the invocation is made from a substitute logger\n    \t// this assumption might change in the future with the advent of a fluent API\n        Level julLevel = slf4jLevelIntToJULLevel(event.getLevel().toInt());\n        if (logger.isLoggable(julLevel)) {\n            LogRecord record = eventToRecord(event, julLevel);\n            logger.log(record);\n        }\n    }\n\n    private LogRecord eventToRecord(LoggingEvent event, Level julLevel) {\n        String format = event.getMessage();\n        Object[] arguments = event.getArgumentArray();\n        FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n        if (ft.getThrowable() != null && event.getThrowable() != null) {\n            throw new IllegalArgumentException(\"both last element in argument array and last argument are of type Throwable\");\n        }\n\n        Throwable t = event.getThrowable();\n        if (ft.getThrowable() != null) {\n            t = ft.getThrowable();\n            throw new IllegalStateException(\"fix above code\");\n        }\n\n        LogRecord record = new LogRecord(julLevel, ft.getMessage());\n        record.setLoggerName(event.getLoggerName());\n        record.setMillis(event.getTimeStamp());\n        record.setSourceClassName(EventConstants.NA_SUBST);\n        record.setSourceMethodName(EventConstants.NA_SUBST);\n\n        record.setThrown(t);\n        return record;\n    }\n}\n","lineNo":148}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.jul;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.AbstractLogger;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.LegacyAbstractLogger;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.NormalizedParameters;\nimport org.slf4j.helpers.ParameterNormalizer;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends LegacyAbstractLogger implements LocationAwareLogger {\n\n\tprivate static final long serialVersionUID = -8053026990503422791L;\n\n\ttransient final java.util.logging.Logger logger;\n\n\t// WARN: JDK14LoggerAdapter constructor should have only package access so\n\t// that only JDK14LoggerFactory be able to create one.\n\tJDK14LoggerAdapter(java.util.logging.Logger logger) {\n\t\tthis.logger = logger;\n\t\tthis.name = logger.getName();\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the FINEST level?\n\t * \n\t * @return True if this Logger is enabled for level FINEST, false otherwise.\n\t */\n\tpublic boolean isTraceEnabled() {\n\t\treturn logger.isLoggable(Level.FINEST);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the FINE level?\n\t * \n\t * @return True if this Logger is enabled for level FINE, false otherwise.\n\t */\n\tpublic boolean isDebugEnabled() {\n\t\treturn logger.isLoggable(Level.FINE);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the INFO level?\n\t * \n\t * @return True if this Logger is enabled for the INFO level, false otherwise.\n\t */\n\tpublic boolean isInfoEnabled() {\n\t\treturn logger.isLoggable(Level.INFO);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the WARNING level?\n\t * \n\t * @return True if this Logger is enabled for the WARNING level, false\n\t *         otherwise.\n\t */\n\tpublic boolean isWarnEnabled() {\n\t\treturn logger.isLoggable(Level.WARNING);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for level SEVERE?\n\t * \n\t * @return True if this Logger is enabled for level SEVERE, false otherwise.\n\t */\n\tpublic boolean isErrorEnabled() {\n\t\treturn logger.isLoggable(Level.SEVERE);\n\t}\n\n//    /**\n//     * Log the message at the specified level with the specified throwable if any.\n//     * This method creates a LogRecord and fills in caller date before calling\n//     * this instance's JDK14 logger.\n//     * \n//     * See bug report #13 for more details.\n//     * \n//     * @param level\n//     * @param msg\n//     * @param t\n//     */\n//    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n//        // millis and thread are filled by the constructor\n//        LogRecord record = new LogRecord(level, msg);\n//        record.setLoggerName(getName());\n//        record.setThrown(t);\n//        // Note: parameters in record are not set because SLF4J only\n//        // supports a single formatting style\n//        fillCallerData(callerFQCN, record);\n//        logger.log(record);\n//    }\n\n\t/**\n\t * Log the message at the specified level with the specified throwable if any.\n\t * This method creates a LogRecord and fills in caller date before calling this\n\t * instance's JDK14 logger.\n\t */\n\t@Override\n\tprotected void handleNormalizedLoggingCall(org.slf4j.event.Level level, Marker marker, String msg, Object[] args,\n\t\t\tThrowable throwable) {\n\t\tinnerNormalizedLoggingCallHandler(getFullyQualifiedCallerName(), level, marker, msg, args, throwable);\n\t}\n\n\t\n\tprivate void innerNormalizedLoggingCallHandler(String fqcn, org.slf4j.event.Level level, Marker marker, String msg, Object[] args,\n\t\t\tThrowable throwable) {\n\t\t// millis and thread are filled by the constructor\n\t\tLevel julLevel = slf4jLevelToJULLevel(level);\n\t\tString formattedMessage = MessageFormatter.basicArrayFormat(msg, args);\n\t\tLogRecord record = new LogRecord(julLevel, formattedMessage);\n\n\t\t// https://jira.qos.ch/browse/SLF4J-13\n\t\trecord.setLoggerName(getName());\n\t\trecord.setThrown(throwable);\n\t\t// Note: parameters in record are not set because SLF4J only\n\t\t// supports a single formatting style\n\t\t// See also https://jira.qos.ch/browse/SLF4J-10\n\t\tfillCallerData(fqcn, record);\n\t\tlogger.log(record);\n\t}\n\n\t\n\t@Override\n\tprotected String getFullyQualifiedCallerName() {\n\t\treturn SELF;\n\t}\n\t\n\t\n\t@Override\n\tpublic void log(Marker marker, String callerFQCN, int slf4jLevelInt, String message, Object[] arguments,\n\t\t\tThrowable throwable) {\n\n\t\torg.slf4j.event.Level slf4jLevel = org.slf4j.event.Level.intToLevel(slf4jLevelInt);\n\t\tLevel julLevel = slf4jLevelIntToJULLevel(slf4jLevelInt);\n\t\t\n\t\tif (logger.isLoggable(julLevel)) {\n\t\t\tNormalizedParameters np = ParameterNormalizer.normalize(message, arguments, throwable);\n\t\t\tinnerNormalizedLoggingCallHandler(callerFQCN, slf4jLevel, marker, np.getMessage(), np.getArguments(), np.getThrowable());\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Fill in caller data if possible.\n\t * \n\t * @param record The record to update\n\t */\n\tfinal private void fillCallerData(String callerFQCN, LogRecord record) {\n\t\tStackTraceElement[] steArray = new Throwable().getStackTrace();\n\n\t\tint selfIndex = -1;\n\t\tfor (int i = 0; i < steArray.length; i++) {\n\t\t\tfinal String className = steArray[i].getClassName();\n\n\t\t\tif (barrierMatch(callerFQCN, className)) {\n\t\t\t\tselfIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint found = -1;\n\t\tfor (int i = selfIndex + 1; i < steArray.length; i++) {\n\t\t\tfinal String className = steArray[i].getClassName();\n\t\t\tif (!(barrierMatch(callerFQCN, className))) {\n\t\t\t\tfound = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found != -1) {\n\t\t\tStackTraceElement ste = steArray[found];\n\t\t\t// setting the class name has the side effect of setting\n\t\t\t// the needToInferCaller variable to false.\n\t\t\trecord.setSourceClassName(ste.getClassName());\n\t\t\trecord.setSourceMethodName(ste.getMethodName());\n\t\t}\n\t}\n\n\tstatic String SELF = JDK14LoggerAdapter.class.getName();\n\t\n\tstatic String SUPER = LegacyAbstractLogger.class.getName();\n\tstatic String SUPER_OF_SUPER = AbstractLogger.class.getName();\n\tstatic String SUBSTITUE = SubstituteLogger.class.getName();\n\n\tstatic String BARRIER_CLASSES[] = new String[] { SUPER_OF_SUPER, SUPER, SELF, SUBSTITUE };\n\n\tprivate boolean barrierMatch(String callerFQCN, String candidateClassName) {\n\t\tif (candidateClassName.equals(callerFQCN))\n\t\t\treturn true;\n\t\tfor (String barrierClassName : BARRIER_CLASSES) {\n\t\t\tif (barrierClassName.equals(candidateClassName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tprivate static Level slf4jLevelIntToJULLevel(int levelInt) {\n\t\torg.slf4j.event.Level slf4jLevel = org.slf4j.event.Level.intToLevel(levelInt);\n\t\treturn slf4jLevelToJULLevel(slf4jLevel);\n\t}\n\n\tprivate static Level slf4jLevelToJULLevel(org.slf4j.event.Level slf4jLevel) {\n\t\tLevel julLevel;\n\t\tswitch (slf4jLevel) {\n\t\tcase TRACE:\n\t\t\tjulLevel = Level.FINEST;\n\t\t\tbreak;\n\t\tcase DEBUG:\n\t\t\tjulLevel = Level.FINE;\n\t\t\tbreak;\n\t\tcase INFO:\n\t\t\tjulLevel = Level.INFO;\n\t\t\tbreak;\n\t\tcase WARN:\n\t\t\tjulLevel = Level.WARNING;\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\t\tjulLevel = Level.SEVERE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Level \" + slf4jLevel + \" is not recognized.\");\n\t\t}\n\t\treturn julLevel;\n\t}\n\n\t/**\n\t * @since 1.7.15\n\t */\n\tpublic void log(LoggingEvent event) {\n\t\t// assumes that the invocation is made from a substitute logger\n\t\t// this assumption might change in the future with the advent of a fluent API\n\t\tLevel julLevel = slf4jLevelToJULLevel(event.getLevel());\n\t\tif (logger.isLoggable(julLevel)) {\n\t\t\tLogRecord record = eventToRecord(event, julLevel);\n\t\t\tlogger.log(record);\n\t\t}\n\t}\n\n\tprivate LogRecord eventToRecord(LoggingEvent event, Level julLevel) {\n\t\tString format = event.getMessage();\n\t\tObject[] arguments = event.getArgumentArray();\n\t\tFormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n\t\tif (ft.getThrowable() != null && event.getThrowable() != null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"both last element in argument array and last argument are of type Throwable\");\n\t\t}\n\n\t\tThrowable t = event.getThrowable();\n\t\tif (ft.getThrowable() != null) {\n\t\t\tt = ft.getThrowable();\n\t\t\tthrow new IllegalStateException(\"fix above code\");\n\t\t}\n\n\t\tLogRecord record = new LogRecord(julLevel, ft.getMessage());\n\t\trecord.setLoggerName(event.getLoggerName());\n\t\trecord.setMillis(event.getTimeStamp());\n\t\trecord.setSourceClassName(EventConstants.NA_SUBST);\n\t\trecord.setSourceMethodName(EventConstants.NA_SUBST);\n\n\t\trecord.setThrown(t);\n\t\treturn record;\n\t}\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.jul;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger {\n\n    private static final long serialVersionUID = -8053026990503422791L;\n\n    transient final java.util.logging.Logger logger;\n\n    // WARN: JDK14LoggerAdapter constructor should have only package access so\n    // that only JDK14LoggerFactory be able to create one.\n    JDK14LoggerAdapter(java.util.logging.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n    }\n\n    /**\n     * Is this logger instance enabled for the FINEST level?\n     * \n     * @return True if this Logger is enabled for level FINEST, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINEST);\n    }\n\n    /**\n     * Log a message object at level FINEST.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINEST.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void trace(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINEST with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the FINE level?\n     * \n     * @return True if this Logger is enabled for level FINE, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    /**\n     * Log a message object at level FINE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINE.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void debug(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the WARNING level?\n     * \n     * @return True if this Logger is enabled for the WARNING level, false\n     *         otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    /**\n     * Log a message object at the WARNING level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARNING according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARNING level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for level SEVERE?\n     * \n     * @return True if this Logger is enabled for level SEVERE, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n\n    /**\n     * Log a message object at the SEVERE level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level SEVERE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void error(String format, Object... arguments) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the SEVERE level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, t);\n        }\n    }\n\n    /**\n     * Log the message at the specified level with the specified throwable if any.\n     * This method creates a LogRecord and fills in caller date before calling\n     * this instance's JDK14 logger.\n     * \n     * See bug report #13 for more details.\n     * \n     * @param level\n     * @param msg\n     * @param t\n     */\n    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n        // millis and thread are filled by the constructor\n        LogRecord record = new LogRecord(level, msg);\n        record.setLoggerName(getName());\n        record.setThrown(t);\n        // Note: parameters in record are not set because SLF4J only\n        // supports a single formatting style\n        fillCallerData(callerFQCN, record);\n        logger.log(record);\n    }\n\n    static String SELF = JDK14LoggerAdapter.class.getName();\n    static String SUPER = MarkerIgnoringBase.class.getName();\n    static String SUBSTITUE = SubstituteLogger.class.getName();\n    \n    static String BARRIER_CLASSES[] = new String[] {SELF, SUPER, SUBSTITUE};\n  \n    /**\n     * Fill in caller data if possible.\n     * \n     * @param record\n     *          The record to update\n     */\n\tfinal private void fillCallerData(String callerFQCN, LogRecord record) {\n        StackTraceElement[] steArray = new Throwable().getStackTrace();\n\n        int selfIndex = -1;\n        for (int i = 0; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            \n            if (barrierMatch(callerFQCN, className)) {\n                selfIndex = i;\n                break;\n            }\n        }\n\n        int found = -1;\n        for (int i = selfIndex + 1; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            if (!(barrierMatch(callerFQCN, className))) {\n                found = i;\n                break;\n            }\n        }\n\n        if (found != -1) {\n            StackTraceElement ste = steArray[found];\n            // setting the class name has the side effect of setting\n            // the needToInferCaller variable to false.\n            record.setSourceClassName(ste.getClassName());\n            record.setSourceMethodName(ste.getMethodName());\n        }\n    }\n\n    private boolean barrierMatch(String callerFQCN, String candidateClassName) {\n    \tif(candidateClassName.equals(callerFQCN))\n    \t\treturn true;\n    \tfor(String barrierClassName: BARRIER_CLASSES) {\n    \t\tif(barrierClassName.equals(candidateClassName)) {\n    \t\t  return true;\n    \t\t}\n    \t}\n    \treturn false;\n\t}\n\n\tpublic void log(Marker marker, String callerFQCN, int level, String message, Object[] argArray, Throwable t) {\n        Level julLevel = slf4jLevelIntToJULLevel(level);\n        // the logger.isLoggable check avoids the unconditional\n        // construction of location data for disabled log\n        // statements. As of 2008-07-31, callers of this method\n        // do not perform this check. See also\n        // http://jira.qos.ch/browse/SLF4J-81\n        if (logger.isLoggable(julLevel)) {\n            log(callerFQCN, julLevel, message, t);\n        }\n    }\n\n    private Level slf4jLevelIntToJULLevel(int slf4jLevelInt) {\n        Level julLevel;\n        switch (slf4jLevelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            julLevel = Level.FINEST;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            julLevel = Level.FINE;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            julLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            julLevel = Level.WARNING;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            julLevel = Level.SEVERE;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + slf4jLevelInt + \" is not recognized.\");\n        }\n        return julLevel;\n    }\n\n    /**\n     * @since 1.7.15\n     */\n    public void log(LoggingEvent event) {\n    \t// assumes that the invocation is made from a substitute logger\n    \t// this assumption might change in the future with the advent of a fluent API\n        Level julLevel = slf4jLevelIntToJULLevel(event.getLevel().toInt());\n        if (logger.isLoggable(julLevel)) {\n            LogRecord record = eventToRecord(event, julLevel);\n            logger.log(record);\n        }\n    }\n\n    private LogRecord eventToRecord(LoggingEvent event, Level julLevel) {\n        String format = event.getMessage();\n        Object[] arguments = event.getArgumentArray();\n        FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n        if (ft.getThrowable() != null && event.getThrowable() != null) {\n            throw new IllegalArgumentException(\"both last element in argument array and last argument are of type Throwable\");\n        }\n\n        Throwable t = event.getThrowable();\n        if (ft.getThrowable() != null) {\n            t = ft.getThrowable();\n            throw new IllegalStateException(\"fix above code\");\n        }\n\n        LogRecord record = new LogRecord(julLevel, ft.getMessage());\n        record.setLoggerName(event.getLoggerName());\n        record.setMillis(event.getTimeStamp());\n        record.setSourceClassName(EventConstants.NA_SUBST);\n        record.setSourceMethodName(EventConstants.NA_SUBST);\n\n        record.setThrown(t);\n        return record;\n    }\n}\n","lineNo":149}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.log4j12;\n\nimport static org.slf4j.event.EventConstants.NA_SUBST;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Level;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.ThrowableInformation;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.LegacyAbstractLogger;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.NormalizedParameters;\nimport org.slf4j.helpers.ParameterNormalizer;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends LegacyAbstractLogger implements LocationAwareLogger, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n\n    @Override\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] arguments, Throwable t) {\n        Level log4jLevel = toLog4jLevel(level);\n        NormalizedParameters np = ParameterNormalizer.normalize(msg, arguments, t);\n        String formattedMessage = MessageFormatter.basicArrayFormat(np.getMessage(), np.getArguments());\n        logger.log(callerFQCN, log4jLevel, formattedMessage, np.getThrowable());\n    }\n\n\t@Override\n\tprotected void handleNormalizedLoggingCall(org.slf4j.event.Level level, Marker marker, String msg, Object[] arguments,\n\t\t\tThrowable throwable) {\n\t\tLevel log4jLevel = toLog4jLevel(level.toInt());\n\t\tString formattedMessage = MessageFormatter.basicArrayFormat(msg, arguments);\n\t\tlogger.log(getFullyQualifiedCallerName(), log4jLevel, formattedMessage, throwable);\n\t}\n\n\t/**\n\t * Called by {@link SubstituteLogger}\n\t * @param event\n\t */\n    public void log(LoggingEvent event) {\n        Level log4jLevel = toLog4jLevel(event.getLevel().toInt());\n        if (!logger.isEnabledFor(log4jLevel))\n            return;\n\n        org.apache.log4j.spi.LoggingEvent log4jevent = toLog4jEvent(event, log4jLevel);\n        logger.callAppenders(log4jevent);\n\n    }\n    \n    private org.apache.log4j.spi.LoggingEvent toLog4jEvent(LoggingEvent event, Level log4jLevel) {\n\n        String formattedMessage = MessageFormatter.basicArrayFormat(event.getMessage(), event.getArgumentArray());\n\n        LocationInfo locationInfo = new LocationInfo(NA_SUBST, NA_SUBST, NA_SUBST, \"0\");\n\n        ThrowableInformation ti = null;\n        Throwable t = event.getThrowable();\n        if (t != null)\n            ti = new ThrowableInformation(t);\n\n        org.apache.log4j.spi.LoggingEvent log4jEvent = new org.apache.log4j.spi.LoggingEvent(FQCN, logger, event.getTimeStamp(), log4jLevel, formattedMessage,\n                        event.getThreadName(), ti, null, locationInfo, null);\n\n        return log4jEvent;\n    }\n\n\n\t\n    private Level toLog4jLevel(int slf4jLevelInt) {\n        Level log4jLevel;\n        switch (slf4jLevelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + slf4jLevelInt + \" is not recognized.\");\n        }\n        return log4jLevel;\n    }\n\n\t@Override\n\tprotected String getFullyQualifiedCallerName() {\n\t\treturn FQCN;\n\t}\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.log4j12;\n\nimport static org.slf4j.event.EventConstants.NA_SUBST;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Level;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.ThrowableInformation;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Log a message object at level TRACE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level TRACE.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void trace(String format, Object... arguments) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level TRACE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    /**\n     * Log a message object at level DEBUG.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level DEBUG.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments an array of arguments\n     */\n    public void debug(String format, Object... arguments) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level DEBUG with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        logger.log(FQCN, Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        logger.log(FQCN, Level.INFO, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    /**\n     * Log a message object at the WARN level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARN according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARN level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        logger.log(FQCN, Level.WARN, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    /**\n     * Log a message object at the ERROR level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level ERROR according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void error(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the ERROR level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        logger.log(FQCN, Level.ERROR, msg, t);\n    }\n\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] argArray, Throwable t) {\n        Level log4jLevel = toLog4jLevel(level);\n        logger.log(callerFQCN, log4jLevel, msg, t);\n    }\n\n    private Level toLog4jLevel(int level) {\n        Level log4jLevel;\n        switch (level) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + level + \" is not recognized.\");\n        }\n        return log4jLevel;\n    }\n\n    public void log(LoggingEvent event) {\n        Level log4jLevel = toLog4jLevel(event.getLevel().toInt());\n        if (!logger.isEnabledFor(log4jLevel))\n            return;\n\n        org.apache.log4j.spi.LoggingEvent log4jevent = toLog4jEvent(event, log4jLevel);\n        logger.callAppenders(log4jevent);\n\n    }\n\n    private org.apache.log4j.spi.LoggingEvent toLog4jEvent(LoggingEvent event, Level log4jLevel) {\n\n        FormattingTuple ft = MessageFormatter.format(event.getMessage(), event.getArgumentArray(), event.getThrowable());\n\n        LocationInfo locationInfo = new LocationInfo(NA_SUBST, NA_SUBST, NA_SUBST, \"0\");\n\n        ThrowableInformation ti = null;\n        Throwable t = ft.getThrowable();\n        if (t != null)\n            ti = new ThrowableInformation(t);\n\n        org.apache.log4j.spi.LoggingEvent log4jEvent = new org.apache.log4j.spi.LoggingEvent(FQCN, logger, event.getTimeStamp(), log4jLevel, ft.getMessage(),\n                        event.getThreadName(), ti, null, locationInfo, null);\n\n        return log4jEvent;\n    }\n\n}\n","lineNo":151}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.log4j12;\n\nimport static org.slf4j.event.EventConstants.NA_SUBST;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Level;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.ThrowableInformation;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.LegacyAbstractLogger;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.NormalizedParameters;\nimport org.slf4j.helpers.ParameterNormalizer;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends LegacyAbstractLogger implements LocationAwareLogger, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n\n    @Override\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] arguments, Throwable t) {\n        Level log4jLevel = toLog4jLevel(level);\n        NormalizedParameters np = ParameterNormalizer.normalize(msg, arguments, t);\n        String formattedMessage = MessageFormatter.basicArrayFormat(np.getMessage(), np.getArguments());\n        logger.log(callerFQCN, log4jLevel, formattedMessage, np.getThrowable());\n    }\n\n\t@Override\n\tprotected void handleNormalizedLoggingCall(org.slf4j.event.Level level, Marker marker, String msg, Object[] arguments,\n\t\t\tThrowable throwable) {\n\t\tLevel log4jLevel = toLog4jLevel(level.toInt());\n\t\tString formattedMessage = MessageFormatter.basicArrayFormat(msg, arguments);\n\t\tlogger.log(getFullyQualifiedCallerName(), log4jLevel, formattedMessage, throwable);\n\t}\n\n\t/**\n\t * Called by {@link SubstituteLogger}\n\t * @param event\n\t */\n    public void log(LoggingEvent event) {\n        Level log4jLevel = toLog4jLevel(event.getLevel().toInt());\n        if (!logger.isEnabledFor(log4jLevel))\n            return;\n\n        org.apache.log4j.spi.LoggingEvent log4jevent = toLog4jEvent(event, log4jLevel);\n        logger.callAppenders(log4jevent);\n\n    }\n    \n    private org.apache.log4j.spi.LoggingEvent toLog4jEvent(LoggingEvent event, Level log4jLevel) {\n\n        String formattedMessage = MessageFormatter.basicArrayFormat(event.getMessage(), event.getArgumentArray());\n\n        LocationInfo locationInfo = new LocationInfo(NA_SUBST, NA_SUBST, NA_SUBST, \"0\");\n\n        ThrowableInformation ti = null;\n        Throwable t = event.getThrowable();\n        if (t != null)\n            ti = new ThrowableInformation(t);\n\n        org.apache.log4j.spi.LoggingEvent log4jEvent = new org.apache.log4j.spi.LoggingEvent(FQCN, logger, event.getTimeStamp(), log4jLevel, formattedMessage,\n                        event.getThreadName(), ti, null, locationInfo, null);\n\n        return log4jEvent;\n    }\n\n\n\t\n    private Level toLog4jLevel(int slf4jLevelInt) {\n        Level log4jLevel;\n        switch (slf4jLevelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + slf4jLevelInt + \" is not recognized.\");\n        }\n        return log4jLevel;\n    }\n\n\t@Override\n\tprotected String getFullyQualifiedCallerName() {\n\t\treturn FQCN;\n\t}\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.log4j12;\n\nimport static org.slf4j.event.EventConstants.NA_SUBST;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Level;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.ThrowableInformation;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Log a message object at level TRACE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level TRACE.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void trace(String format, Object... arguments) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level TRACE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    /**\n     * Log a message object at level DEBUG.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level DEBUG.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments an array of arguments\n     */\n    public void debug(String format, Object... arguments) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level DEBUG with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        logger.log(FQCN, Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        logger.log(FQCN, Level.INFO, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    /**\n     * Log a message object at the WARN level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARN according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARN level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        logger.log(FQCN, Level.WARN, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    /**\n     * Log a message object at the ERROR level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level ERROR according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void error(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the ERROR level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        logger.log(FQCN, Level.ERROR, msg, t);\n    }\n\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] argArray, Throwable t) {\n        Level log4jLevel = toLog4jLevel(level);\n        logger.log(callerFQCN, log4jLevel, msg, t);\n    }\n\n    private Level toLog4jLevel(int level) {\n        Level log4jLevel;\n        switch (level) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + level + \" is not recognized.\");\n        }\n        return log4jLevel;\n    }\n\n    public void log(LoggingEvent event) {\n        Level log4jLevel = toLog4jLevel(event.getLevel().toInt());\n        if (!logger.isEnabledFor(log4jLevel))\n            return;\n\n        org.apache.log4j.spi.LoggingEvent log4jevent = toLog4jEvent(event, log4jLevel);\n        logger.callAppenders(log4jevent);\n\n    }\n\n    private org.apache.log4j.spi.LoggingEvent toLog4jEvent(LoggingEvent event, Level log4jLevel) {\n\n        FormattingTuple ft = MessageFormatter.format(event.getMessage(), event.getArgumentArray(), event.getThrowable());\n\n        LocationInfo locationInfo = new LocationInfo(NA_SUBST, NA_SUBST, NA_SUBST, \"0\");\n\n        ThrowableInformation ti = null;\n        Throwable t = ft.getThrowable();\n        if (t != null)\n            ti = new ThrowableInformation(t);\n\n        org.apache.log4j.spi.LoggingEvent log4jEvent = new org.apache.log4j.spi.LoggingEvent(FQCN, logger, event.getTimeStamp(), log4jLevel, ft.getMessage(),\n                        event.getThreadName(), ti, null, locationInfo, null);\n\n        return log4jEvent;\n    }\n\n}\n","lineNo":152}
{"Refactored Sample":"package org.slf4j.jdk;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ResourceBundle;\n\nimport static java.util.Objects.requireNonNull;\n\n/**\n * Adapts {@link Logger} to {@link System.Logger}.\n */\nclass SLF4JSystemLogger implements System.Logger {\n\n    private static final Logger INTERNAL_LOGGER = LoggerFactory.getLogger(SLF4JSystemLogger.class);\n\n    private final Logger logger;\n\n    public SLF4JSystemLogger(Logger logger) {\n        this.logger = requireNonNull(logger);\n    }\n\n    @Override\n    public String getName() {\n        return logger.getName();\n    }\n\n    @Override\n    public boolean isLoggable(Level level) {\n        switch(level) {\n            case ALL:\n                // fall-through intended because `ALL` is loggable if the\n                // lowest level is enabled\n            case TRACE:\n                return logger.isTraceEnabled();\n            case DEBUG:\n                return logger.isDebugEnabled();\n            case INFO:\n                return logger.isInfoEnabled();\n            case WARNING:\n                return logger.isWarnEnabled();\n            case ERROR:\n                return logger.isErrorEnabled();\n            case OFF:\n                // all logging is disabled if the highest level is disabled\n                return !logger.isErrorEnabled();\n            default:\n                INTERNAL_LOGGER.error(\n                        \"SLF4J internal error: unknown log level {} passed to `isLoggable` (likely by the JDK).\", level);\n                return true;\n        }\n    }\n\n    @Override\n    public void log(Level level, ResourceBundle bundle, String msg, Throwable thrown) {\n        String message = bundle == null ? msg : bundle.getString(msg);\n        switch(level) {\n            case ALL:\n                // fall-through intended because a message is visible on all log levels\n                // if it is logged on the lowest level\n            case TRACE:\n                logger.trace(message, thrown);\n                break;\n            case DEBUG:\n                logger.debug(message, thrown);\n                break;\n            case INFO:\n                logger.info(message, thrown);\n                break;\n            case WARNING:\n                logger.warn(message, thrown);\n                break;\n            case ERROR:\n                logger.error(message, thrown);\n                break;\n            case OFF:\n                // don't do anything for a message on level `OFF`\n                break;\n            default:\n                INTERNAL_LOGGER.error(\n                        \"SLF4J internal error: unknown log level {} passed to `log` (likely by the JDK).\", level);\n        }\n    }\n\n    @Override\n    public void log(Level level, ResourceBundle bundle, String format, Object... params) {\n        String message = bundle == null ? format : bundle.getString(format);\n        switch(level) {\n            case ALL:\n                // fall-through intended because a message is visible on all log levels\n                // if it is logged on the lowest level\n            case TRACE:\n                logger.trace(message, params);\n                break;\n            case DEBUG:\n                logger.debug(message, params);\n                break;\n            case INFO:\n                logger.info(message, params);\n                break;\n            case WARNING:\n                logger.warn(message, params);\n                break;\n            case ERROR:\n                logger.error(message, params);\n                break;\n            case OFF:\n                // don't do anything for a message on level `OFF`\n                break;\n            default:\n                INTERNAL_LOGGER.error(\n                        \"SLF4J internal error: unknown log level {} passed to `log` (likely by the JDK).\", level);\n        }\n    }\n\n}\n","Smelly Sample":"package org.slf4j.jdk;\n\nimport org.slf4j.Logger;\n\nimport java.text.MessageFormat;\nimport java.util.ResourceBundle;\n\nimport static java.util.Objects.requireNonNull;\n\nclass SLF4JSystemLogger implements System.Logger {\n\n    private final Logger logger;\n\n    public SLF4JSystemLogger(Logger logger) {\n        this.logger = requireNonNull(logger);\n    }\n\n    @Override\n    public String getName() {\n        return logger.getName();\n    }\n\n    @Override\n    public boolean isLoggable(Level level) {\n        switch(level) {\n            case ALL:\n                throw new UnsupportedOperationException();\n            case TRACE:\n                return logger.isTraceEnabled();\n            case DEBUG:\n                return logger.isDebugEnabled();\n            case INFO:\n                return logger.isInfoEnabled();\n            case WARNING:\n                return logger.isWarnEnabled();\n            case ERROR:\n                return logger.isErrorEnabled();\n            case OFF:\n                throw new UnsupportedOperationException();\n        }\n        // TODO\n        return true;\n    }\n\n    @Override\n    public void log(Level level, ResourceBundle bundle, String msg, Throwable thrown) {\n        switch(level) {\n            case ALL:\n                throw new UnsupportedOperationException();\n            case TRACE:\n                logger.trace(msg, thrown);\n                break;\n            case DEBUG:\n                logger.debug(msg, thrown);\n                break;\n            case INFO:\n                logger.info(msg, thrown);\n                break;\n            case WARNING:\n                logger.warn(msg, thrown);\n                break;\n            case ERROR:\n                logger.error(msg, thrown);\n                break;\n            case OFF:\n                throw new UnsupportedOperationException();\n        }\n    }\n\n    @Override\n    public void log(Level level, ResourceBundle bundle, String format, Object... params) {\n        switch(level) {\n            case ALL:\n                throw new UnsupportedOperationException();\n            case TRACE:\n                logger.trace(MessageFormat.format(format, params));\n                break;\n            case DEBUG:\n                logger.debug(MessageFormat.format(format, params));\n                break;\n            case INFO:\n                logger.info(MessageFormat.format(format, params));\n                break;\n            case WARNING:\n                logger.warn(MessageFormat.format(format, params));\n                break;\n            case ERROR:\n                logger.error(MessageFormat.format(format, params));\n                break;\n            case OFF:\n                throw new UnsupportedOperationException();\n        }\n    }\n\n}\n","lineNo":56}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport org.slf4j.spi.MDCAdapter;\n\nimport java.util.*;\nimport java.util.Map;\n\n/**\n * Basic MDC implementation, which can be used with logging systems that lack\n * out-of-the-box MDC support.\n *\n * This code was initially inspired by  logback's LogbackMDCAdapter. However,\n * LogbackMDCAdapter has evolved and is now considerably more sophisticated.\n *\n * @author Ceki Gulcu\n * @author Maarten Bosteels\n * @author Lukasz Cwik\n * \n * @since 1.5.0\n */\npublic class BasicMDCAdapter implements MDCAdapter {\n\n    private InheritableThreadLocal<Map<String, String>> inheritableThreadLocal = new InheritableThreadLocal<Map<String, String>>() {\n        @Override\n        protected Map<String, String> childValue(Map<String, String> parentValue) {\n            if (parentValue == null) {\n                return null;\n            }\n            return new HashMap<String, String>(parentValue);\n        }\n    };\n\n    /**\n     * Put a context value (the <code>val<\/code> parameter) as identified with\n     * the <code>key<\/code> parameter into the current thread's context map.\n     * Note that contrary to log4j, the <code>val<\/code> parameter can be null.\n     *\n     * <p>\n     * If the current thread does not have a context map it is created as a side\n     * effect of this call.\n     *\n     * @throws IllegalArgumentException\n     *                 in case the \"key\" parameter is null\n     */\n    public void put(String key, String val) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map == null) {\n            map = new HashMap<String, String>();\n            inheritableThreadLocal.set(map);\n        }\n        map.put(key, val);\n    }\n\n    /**\n     * Get the context identified by the <code>key<\/code> parameter.\n     */\n    public String get(String key) {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if ((map != null) && (key != null)) {\n            return map.get(key);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Remove the the context identified by the <code>key<\/code> parameter.\n     */\n    public void remove(String key) {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            map.remove(key);\n        }\n    }\n\n    /**\n     * Clear all entries in the MDC.\n     */\n    public void clear() {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            map.clear();\n            inheritableThreadLocal.remove();\n        }\n    }\n\n    /**\n     * Returns the keys in the MDC as a {@link Set} of {@link String}s The\n     * returned value can be null.\n     *\n     * @return the keys in the MDC\n     */\n    public Set<String> getKeys() {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            return map.keySet();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Return a copy of the current thread's context map.\n     * Returned value may be null.\n     *\n     */\n    public Map<String, String> getCopyOfContextMap() {\n        Map<String, String> oldMap = inheritableThreadLocal.get();\n        if (oldMap != null) {\n            return new HashMap<String, String>(oldMap);\n        } else {\n            return null;\n        }\n    }\n\n    public void setContextMap(Map<String, String> contextMap) {\n        Map<String, String> copy = null;\n        if(contextMap != null) {\n            copy = new HashMap<String, String>(contextMap);\n        }\n        inheritableThreadLocal.set(copy);\n    }\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport org.slf4j.spi.MDCAdapter;\n\nimport java.util.*;\nimport java.util.Map;\n\n/**\n * Basic MDC implementation, which can be used with logging systems that lack\n * out-of-the-box MDC support.\n *\n * This code was initially inspired by  logback's LogbackMDCAdapter. However,\n * LogbackMDCAdapter has evolved and is now considerably more sophisticated.\n *\n * @author Ceki Gulcu\n * @author Maarten Bosteels\n * @author Lukasz Cwik\n * \n * @since 1.5.0\n */\npublic class BasicMDCAdapter implements MDCAdapter {\n\n    private InheritableThreadLocal<Map<String, String>> inheritableThreadLocal = new InheritableThreadLocal<Map<String, String>>() {\n        @Override\n        protected Map<String, String> childValue(Map<String, String> parentValue) {\n            if (parentValue == null) {\n                return null;\n            }\n            return new HashMap<String, String>(parentValue);\n        }\n    };\n\n    /**\n     * Put a context value (the <code>val<\/code> parameter) as identified with\n     * the <code>key<\/code> parameter into the current thread's context map.\n     * Note that contrary to log4j, the <code>val<\/code> parameter can be null.\n     *\n     * <p>\n     * If the current thread does not have a context map it is created as a side\n     * effect of this call.\n     *\n     * @throws IllegalArgumentException\n     *                 in case the \"key\" parameter is null\n     */\n    public void put(String key, String val) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map == null) {\n            map = new HashMap<String, String>();\n            inheritableThreadLocal.set(map);\n        }\n        map.put(key, val);\n    }\n\n    /**\n     * Get the context identified by the <code>key<\/code> parameter.\n     */\n    public String get(String key) {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if ((map != null) && (key != null)) {\n            return map.get(key);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Remove the the context identified by the <code>key<\/code> parameter.\n     */\n    public void remove(String key) {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            map.remove(key);\n        }\n    }\n\n    /**\n     * Clear all entries in the MDC.\n     */\n    public void clear() {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            map.clear();\n            inheritableThreadLocal.remove();\n        }\n    }\n\n    /**\n     * Returns the keys in the MDC as a {@link Set} of {@link String}s The\n     * returned value can be null.\n     *\n     * @return the keys in the MDC\n     */\n    public Set<String> getKeys() {\n        Map<String, String> map = inheritableThreadLocal.get();\n        if (map != null) {\n            return map.keySet();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Return a copy of the current thread's context map.\n     * Returned value may be null.\n     *\n     */\n    public Map<String, String> getCopyOfContextMap() {\n        Map<String, String> oldMap = inheritableThreadLocal.get();\n        if (oldMap != null) {\n            return new HashMap<String, String>(oldMap);\n        } else {\n            return null;\n        }\n    }\n\n    public void setContextMap(Map<String, String> contextMap) {\n        inheritableThreadLocal.set(new HashMap<String, String>(contextMap));\n    }\n}\n","lineNo":144}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.jul;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.AbstractLogger;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.LegacyAbstractLogger;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.NormalizedParameters;\nimport org.slf4j.helpers.ParameterNormalizer;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends LegacyAbstractLogger implements LocationAwareLogger {\n\n\tprivate static final long serialVersionUID = -8053026990503422791L;\n\n\ttransient final java.util.logging.Logger logger;\n\n\t// WARN: JDK14LoggerAdapter constructor should have only package access so\n\t// that only JDK14LoggerFactory be able to create one.\n\tJDK14LoggerAdapter(java.util.logging.Logger logger) {\n\t\tthis.logger = logger;\n\t\tthis.name = logger.getName();\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the FINEST level?\n\t * \n\t * @return True if this Logger is enabled for level FINEST, false otherwise.\n\t */\n\tpublic boolean isTraceEnabled() {\n\t\treturn logger.isLoggable(Level.FINEST);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the FINE level?\n\t * \n\t * @return True if this Logger is enabled for level FINE, false otherwise.\n\t */\n\tpublic boolean isDebugEnabled() {\n\t\treturn logger.isLoggable(Level.FINE);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the INFO level?\n\t * \n\t * @return True if this Logger is enabled for the INFO level, false otherwise.\n\t */\n\tpublic boolean isInfoEnabled() {\n\t\treturn logger.isLoggable(Level.INFO);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the WARNING level?\n\t * \n\t * @return True if this Logger is enabled for the WARNING level, false\n\t *         otherwise.\n\t */\n\tpublic boolean isWarnEnabled() {\n\t\treturn logger.isLoggable(Level.WARNING);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for level SEVERE?\n\t * \n\t * @return True if this Logger is enabled for level SEVERE, false otherwise.\n\t */\n\tpublic boolean isErrorEnabled() {\n\t\treturn logger.isLoggable(Level.SEVERE);\n\t}\n\n//    /**\n//     * Log the message at the specified level with the specified throwable if any.\n//     * This method creates a LogRecord and fills in caller date before calling\n//     * this instance's JDK14 logger.\n//     * \n//     * See bug report #13 for more details.\n//     * \n//     * @param level\n//     * @param msg\n//     * @param t\n//     */\n//    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n//        // millis and thread are filled by the constructor\n//        LogRecord record = new LogRecord(level, msg);\n//        record.setLoggerName(getName());\n//        record.setThrown(t);\n//        // Note: parameters in record are not set because SLF4J only\n//        // supports a single formatting style\n//        fillCallerData(callerFQCN, record);\n//        logger.log(record);\n//    }\n\n\t/**\n\t * Log the message at the specified level with the specified throwable if any.\n\t * This method creates a LogRecord and fills in caller date before calling this\n\t * instance's JDK14 logger.\n\t */\n\t@Override\n\tprotected void handleNormalizedLoggingCall(org.slf4j.event.Level level, Marker marker, String msg, Object[] args,\n\t\t\tThrowable throwable) {\n\t\tinnerNormalizedLoggingCallHandler(getFullyQualifiedCallerName(), level, marker, msg, args, throwable);\n\t}\n\n\t\n\tprivate void innerNormalizedLoggingCallHandler(String fqcn, org.slf4j.event.Level level, Marker marker, String msg, Object[] args,\n\t\t\tThrowable throwable) {\n\t\t// millis and thread are filled by the constructor\n\t\tLevel julLevel = slf4jLevelToJULLevel(level);\n\t\tString formattedMessage = MessageFormatter.basicArrayFormat(msg, args);\n\t\tLogRecord record = new LogRecord(julLevel, formattedMessage);\n\n\t\t// https://jira.qos.ch/browse/SLF4J-13\n\t\trecord.setLoggerName(getName());\n\t\trecord.setThrown(throwable);\n\t\t// Note: parameters in record are not set because SLF4J only\n\t\t// supports a single formatting style\n\t\t// See also https://jira.qos.ch/browse/SLF4J-10\n\t\tfillCallerData(fqcn, record);\n\t\tlogger.log(record);\n\t}\n\n\t\n\t@Override\n\tprotected String getFullyQualifiedCallerName() {\n\t\treturn SELF;\n\t}\n\t\n\t\n\t@Override\n\tpublic void log(Marker marker, String callerFQCN, int slf4jLevelInt, String message, Object[] arguments,\n\t\t\tThrowable throwable) {\n\n\t\torg.slf4j.event.Level slf4jLevel = org.slf4j.event.Level.intToLevel(slf4jLevelInt);\n\t\tLevel julLevel = slf4jLevelIntToJULLevel(slf4jLevelInt);\n\t\t\n\t\tif (logger.isLoggable(julLevel)) {\n\t\t\tNormalizedParameters np = ParameterNormalizer.normalize(message, arguments, throwable);\n\t\t\tinnerNormalizedLoggingCallHandler(callerFQCN, slf4jLevel, marker, np.getMessage(), np.getArguments(), np.getThrowable());\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Fill in caller data if possible.\n\t * \n\t * @param record The record to update\n\t */\n\tfinal private void fillCallerData(String callerFQCN, LogRecord record) {\n\t\tStackTraceElement[] steArray = new Throwable().getStackTrace();\n\n\t\tint selfIndex = -1;\n\t\tfor (int i = 0; i < steArray.length; i++) {\n\t\t\tfinal String className = steArray[i].getClassName();\n\n\t\t\tif (barrierMatch(callerFQCN, className)) {\n\t\t\t\tselfIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint found = -1;\n\t\tfor (int i = selfIndex + 1; i < steArray.length; i++) {\n\t\t\tfinal String className = steArray[i].getClassName();\n\t\t\tif (!(barrierMatch(callerFQCN, className))) {\n\t\t\t\tfound = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found != -1) {\n\t\t\tStackTraceElement ste = steArray[found];\n\t\t\t// setting the class name has the side effect of setting\n\t\t\t// the needToInferCaller variable to false.\n\t\t\trecord.setSourceClassName(ste.getClassName());\n\t\t\trecord.setSourceMethodName(ste.getMethodName());\n\t\t}\n\t}\n\n\tstatic String SELF = JDK14LoggerAdapter.class.getName();\n\t\n\tstatic String SUPER = LegacyAbstractLogger.class.getName();\n\tstatic String SUPER_OF_SUPER = AbstractLogger.class.getName();\n\tstatic String SUBSTITUE = SubstituteLogger.class.getName();\n\n\tstatic String BARRIER_CLASSES[] = new String[] { SUPER_OF_SUPER, SUPER, SELF, SUBSTITUE };\n\n\tprivate boolean barrierMatch(String callerFQCN, String candidateClassName) {\n\t\tif (candidateClassName.equals(callerFQCN))\n\t\t\treturn true;\n\t\tfor (String barrierClassName : BARRIER_CLASSES) {\n\t\t\tif (barrierClassName.equals(candidateClassName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tprivate static Level slf4jLevelIntToJULLevel(int levelInt) {\n\t\torg.slf4j.event.Level slf4jLevel = org.slf4j.event.Level.intToLevel(levelInt);\n\t\treturn slf4jLevelToJULLevel(slf4jLevel);\n\t}\n\n\tprivate static Level slf4jLevelToJULLevel(org.slf4j.event.Level slf4jLevel) {\n\t\tLevel julLevel;\n\t\tswitch (slf4jLevel) {\n\t\tcase TRACE:\n\t\t\tjulLevel = Level.FINEST;\n\t\t\tbreak;\n\t\tcase DEBUG:\n\t\t\tjulLevel = Level.FINE;\n\t\t\tbreak;\n\t\tcase INFO:\n\t\t\tjulLevel = Level.INFO;\n\t\t\tbreak;\n\t\tcase WARN:\n\t\t\tjulLevel = Level.WARNING;\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\t\tjulLevel = Level.SEVERE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Level \" + slf4jLevel + \" is not recognized.\");\n\t\t}\n\t\treturn julLevel;\n\t}\n\n\t/**\n\t * @since 1.7.15\n\t */\n\tpublic void log(LoggingEvent event) {\n\t\t// assumes that the invocation is made from a substitute logger\n\t\t// this assumption might change in the future with the advent of a fluent API\n\t\tLevel julLevel = slf4jLevelToJULLevel(event.getLevel());\n\t\tif (logger.isLoggable(julLevel)) {\n\t\t\tLogRecord record = eventToRecord(event, julLevel);\n\t\t\tlogger.log(record);\n\t\t}\n\t}\n\n\tprivate LogRecord eventToRecord(LoggingEvent event, Level julLevel) {\n\t\tString format = event.getMessage();\n\t\tObject[] arguments = event.getArgumentArray();\n\t\tFormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n\t\tif (ft.getThrowable() != null && event.getThrowable() != null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"both last element in argument array and last argument are of type Throwable\");\n\t\t}\n\n\t\tThrowable t = event.getThrowable();\n\t\tif (ft.getThrowable() != null) {\n\t\t\tt = ft.getThrowable();\n\t\t\tthrow new IllegalStateException(\"fix above code\");\n\t\t}\n\n\t\tLogRecord record = new LogRecord(julLevel, ft.getMessage());\n\t\trecord.setLoggerName(event.getLoggerName());\n\t\trecord.setMillis(event.getTimeStamp());\n\t\trecord.setSourceClassName(EventConstants.NA_SUBST);\n\t\trecord.setSourceMethodName(EventConstants.NA_SUBST);\n\n\t\trecord.setThrown(t);\n\t\treturn record;\n\t}\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.jul;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger {\n\n    private static final long serialVersionUID = -8053026990503422791L;\n\n    transient final java.util.logging.Logger logger;\n\n    // WARN: JDK14LoggerAdapter constructor should have only package access so\n    // that only JDK14LoggerFactory be able to create one.\n    JDK14LoggerAdapter(java.util.logging.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n    }\n\n    /**\n     * Is this logger instance enabled for the FINEST level?\n     * \n     * @return True if this Logger is enabled for level FINEST, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINEST);\n    }\n\n    /**\n     * Log a message object at level FINEST.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINEST.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void trace(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINEST with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the FINE level?\n     * \n     * @return True if this Logger is enabled for level FINE, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    /**\n     * Log a message object at level FINE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINE.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void debug(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the WARNING level?\n     * \n     * @return True if this Logger is enabled for the WARNING level, false\n     *         otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    /**\n     * Log a message object at the WARNING level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARNING according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARNING level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for level SEVERE?\n     * \n     * @return True if this Logger is enabled for level SEVERE, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n\n    /**\n     * Log a message object at the SEVERE level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level SEVERE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void error(String format, Object... arguments) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the SEVERE level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, t);\n        }\n    }\n\n    /**\n     * Log the message at the specified level with the specified throwable if any.\n     * This method creates a LogRecord and fills in caller date before calling\n     * this instance's JDK14 logger.\n     * \n     * See bug report #13 for more details.\n     * \n     * @param level\n     * @param msg\n     * @param t\n     */\n    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n        // millis and thread are filled by the constructor\n        LogRecord record = new LogRecord(level, msg);\n        record.setLoggerName(getName());\n        record.setThrown(t);\n        // Note: parameters in record are not set because SLF4J only\n        // supports a single formatting style\n        fillCallerData(callerFQCN, record);\n        logger.log(record);\n    }\n\n    static String SELF = JDK14LoggerAdapter.class.getName();\n    static String SUPER = MarkerIgnoringBase.class.getName();\n    static String SUBSTITUE = SubstituteLogger.class.getName();\n    \n    static String BARRIER_CLASSES[] = new String[] {SELF, SUPER, SUBSTITUE};\n  \n    /**\n     * Fill in caller data if possible.\n     * \n     * @param record\n     *          The record to update\n     */\n\tfinal private void fillCallerData(String callerFQCN, LogRecord record) {\n        StackTraceElement[] steArray = new Throwable().getStackTrace();\n\n        int selfIndex = -1;\n        for (int i = 0; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            \n            if (barrierMatch(callerFQCN, className)) {\n                selfIndex = i;\n                break;\n            }\n        }\n\n        int found = -1;\n        for (int i = selfIndex + 1; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            if (!(barrierMatch(callerFQCN, className))) {\n                found = i;\n                break;\n            }\n        }\n\n        if (found != -1) {\n            StackTraceElement ste = steArray[found];\n            // setting the class name has the side effect of setting\n            // the needToInferCaller variable to false.\n            record.setSourceClassName(ste.getClassName());\n            record.setSourceMethodName(ste.getMethodName());\n        }\n    }\n\n    private boolean barrierMatch(String callerFQCN, String candidateClassName) {\n    \tif(candidateClassName.equals(callerFQCN))\n    \t\treturn true;\n    \tfor(String barrierClassName: BARRIER_CLASSES) {\n    \t\tif(barrierClassName.equals(candidateClassName)) {\n    \t\t  return true;\n    \t\t}\n    \t}\n    \treturn false;\n\t}\n\n\tpublic void log(Marker marker, String callerFQCN, int level, String message, Object[] argArray, Throwable t) {\n        Level julLevel = slf4jLevelIntToJULLevel(level);\n        // the logger.isLoggable check avoids the unconditional\n        // construction of location data for disabled log\n        // statements. As of 2008-07-31, callers of this method\n        // do not perform this check. See also\n        // http://jira.qos.ch/browse/SLF4J-81\n        if (logger.isLoggable(julLevel)) {\n            log(callerFQCN, julLevel, message, t);\n        }\n    }\n\n    private Level slf4jLevelIntToJULLevel(int slf4jLevelInt) {\n        Level julLevel;\n        switch (slf4jLevelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            julLevel = Level.FINEST;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            julLevel = Level.FINE;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            julLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            julLevel = Level.WARNING;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            julLevel = Level.SEVERE;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + slf4jLevelInt + \" is not recognized.\");\n        }\n        return julLevel;\n    }\n\n    /**\n     * @since 1.7.15\n     */\n    public void log(LoggingEvent event) {\n    \t// assumes that the invocation is made from a substitute logger\n    \t// this assumption might change in the future with the advent of a fluent API\n        Level julLevel = slf4jLevelIntToJULLevel(event.getLevel().toInt());\n        if (logger.isLoggable(julLevel)) {\n            LogRecord record = eventToRecord(event, julLevel);\n            logger.log(record);\n        }\n    }\n\n    private LogRecord eventToRecord(LoggingEvent event, Level julLevel) {\n        String format = event.getMessage();\n        Object[] arguments = event.getArgumentArray();\n        FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n        if (ft.getThrowable() != null && event.getThrowable() != null) {\n            throw new IllegalArgumentException(\"both last element in argument array and last argument are of type Throwable\");\n        }\n\n        Throwable t = event.getThrowable();\n        if (ft.getThrowable() != null) {\n            t = ft.getThrowable();\n            throw new IllegalStateException(\"fix above code\");\n        }\n\n        LogRecord record = new LogRecord(julLevel, ft.getMessage());\n        record.setLoggerName(event.getLoggerName());\n        record.setMillis(event.getTimeStamp());\n        record.setSourceClassName(EventConstants.NA_SUBST);\n        record.setSourceMethodName(EventConstants.NA_SUBST);\n\n        record.setThrown(t);\n        return record;\n    }\n}\n","lineNo":148}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.jul;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.AbstractLogger;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.LegacyAbstractLogger;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.NormalizedParameters;\nimport org.slf4j.helpers.ParameterNormalizer;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends LegacyAbstractLogger implements LocationAwareLogger {\n\n\tprivate static final long serialVersionUID = -8053026990503422791L;\n\n\ttransient final java.util.logging.Logger logger;\n\n\t// WARN: JDK14LoggerAdapter constructor should have only package access so\n\t// that only JDK14LoggerFactory be able to create one.\n\tJDK14LoggerAdapter(java.util.logging.Logger logger) {\n\t\tthis.logger = logger;\n\t\tthis.name = logger.getName();\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the FINEST level?\n\t * \n\t * @return True if this Logger is enabled for level FINEST, false otherwise.\n\t */\n\tpublic boolean isTraceEnabled() {\n\t\treturn logger.isLoggable(Level.FINEST);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the FINE level?\n\t * \n\t * @return True if this Logger is enabled for level FINE, false otherwise.\n\t */\n\tpublic boolean isDebugEnabled() {\n\t\treturn logger.isLoggable(Level.FINE);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the INFO level?\n\t * \n\t * @return True if this Logger is enabled for the INFO level, false otherwise.\n\t */\n\tpublic boolean isInfoEnabled() {\n\t\treturn logger.isLoggable(Level.INFO);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for the WARNING level?\n\t * \n\t * @return True if this Logger is enabled for the WARNING level, false\n\t *         otherwise.\n\t */\n\tpublic boolean isWarnEnabled() {\n\t\treturn logger.isLoggable(Level.WARNING);\n\t}\n\n\t/**\n\t * Is this logger instance enabled for level SEVERE?\n\t * \n\t * @return True if this Logger is enabled for level SEVERE, false otherwise.\n\t */\n\tpublic boolean isErrorEnabled() {\n\t\treturn logger.isLoggable(Level.SEVERE);\n\t}\n\n//    /**\n//     * Log the message at the specified level with the specified throwable if any.\n//     * This method creates a LogRecord and fills in caller date before calling\n//     * this instance's JDK14 logger.\n//     * \n//     * See bug report #13 for more details.\n//     * \n//     * @param level\n//     * @param msg\n//     * @param t\n//     */\n//    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n//        // millis and thread are filled by the constructor\n//        LogRecord record = new LogRecord(level, msg);\n//        record.setLoggerName(getName());\n//        record.setThrown(t);\n//        // Note: parameters in record are not set because SLF4J only\n//        // supports a single formatting style\n//        fillCallerData(callerFQCN, record);\n//        logger.log(record);\n//    }\n\n\t/**\n\t * Log the message at the specified level with the specified throwable if any.\n\t * This method creates a LogRecord and fills in caller date before calling this\n\t * instance's JDK14 logger.\n\t */\n\t@Override\n\tprotected void handleNormalizedLoggingCall(org.slf4j.event.Level level, Marker marker, String msg, Object[] args,\n\t\t\tThrowable throwable) {\n\t\tinnerNormalizedLoggingCallHandler(getFullyQualifiedCallerName(), level, marker, msg, args, throwable);\n\t}\n\n\t\n\tprivate void innerNormalizedLoggingCallHandler(String fqcn, org.slf4j.event.Level level, Marker marker, String msg, Object[] args,\n\t\t\tThrowable throwable) {\n\t\t// millis and thread are filled by the constructor\n\t\tLevel julLevel = slf4jLevelToJULLevel(level);\n\t\tString formattedMessage = MessageFormatter.basicArrayFormat(msg, args);\n\t\tLogRecord record = new LogRecord(julLevel, formattedMessage);\n\n\t\t// https://jira.qos.ch/browse/SLF4J-13\n\t\trecord.setLoggerName(getName());\n\t\trecord.setThrown(throwable);\n\t\t// Note: parameters in record are not set because SLF4J only\n\t\t// supports a single formatting style\n\t\t// See also https://jira.qos.ch/browse/SLF4J-10\n\t\tfillCallerData(fqcn, record);\n\t\tlogger.log(record);\n\t}\n\n\t\n\t@Override\n\tprotected String getFullyQualifiedCallerName() {\n\t\treturn SELF;\n\t}\n\t\n\t\n\t@Override\n\tpublic void log(Marker marker, String callerFQCN, int slf4jLevelInt, String message, Object[] arguments,\n\t\t\tThrowable throwable) {\n\n\t\torg.slf4j.event.Level slf4jLevel = org.slf4j.event.Level.intToLevel(slf4jLevelInt);\n\t\tLevel julLevel = slf4jLevelIntToJULLevel(slf4jLevelInt);\n\t\t\n\t\tif (logger.isLoggable(julLevel)) {\n\t\t\tNormalizedParameters np = ParameterNormalizer.normalize(message, arguments, throwable);\n\t\t\tinnerNormalizedLoggingCallHandler(callerFQCN, slf4jLevel, marker, np.getMessage(), np.getArguments(), np.getThrowable());\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Fill in caller data if possible.\n\t * \n\t * @param record The record to update\n\t */\n\tfinal private void fillCallerData(String callerFQCN, LogRecord record) {\n\t\tStackTraceElement[] steArray = new Throwable().getStackTrace();\n\n\t\tint selfIndex = -1;\n\t\tfor (int i = 0; i < steArray.length; i++) {\n\t\t\tfinal String className = steArray[i].getClassName();\n\n\t\t\tif (barrierMatch(callerFQCN, className)) {\n\t\t\t\tselfIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint found = -1;\n\t\tfor (int i = selfIndex + 1; i < steArray.length; i++) {\n\t\t\tfinal String className = steArray[i].getClassName();\n\t\t\tif (!(barrierMatch(callerFQCN, className))) {\n\t\t\t\tfound = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found != -1) {\n\t\t\tStackTraceElement ste = steArray[found];\n\t\t\t// setting the class name has the side effect of setting\n\t\t\t// the needToInferCaller variable to false.\n\t\t\trecord.setSourceClassName(ste.getClassName());\n\t\t\trecord.setSourceMethodName(ste.getMethodName());\n\t\t}\n\t}\n\n\tstatic String SELF = JDK14LoggerAdapter.class.getName();\n\t\n\tstatic String SUPER = LegacyAbstractLogger.class.getName();\n\tstatic String SUPER_OF_SUPER = AbstractLogger.class.getName();\n\tstatic String SUBSTITUE = SubstituteLogger.class.getName();\n\n\tstatic String BARRIER_CLASSES[] = new String[] { SUPER_OF_SUPER, SUPER, SELF, SUBSTITUE };\n\n\tprivate boolean barrierMatch(String callerFQCN, String candidateClassName) {\n\t\tif (candidateClassName.equals(callerFQCN))\n\t\t\treturn true;\n\t\tfor (String barrierClassName : BARRIER_CLASSES) {\n\t\t\tif (barrierClassName.equals(candidateClassName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tprivate static Level slf4jLevelIntToJULLevel(int levelInt) {\n\t\torg.slf4j.event.Level slf4jLevel = org.slf4j.event.Level.intToLevel(levelInt);\n\t\treturn slf4jLevelToJULLevel(slf4jLevel);\n\t}\n\n\tprivate static Level slf4jLevelToJULLevel(org.slf4j.event.Level slf4jLevel) {\n\t\tLevel julLevel;\n\t\tswitch (slf4jLevel) {\n\t\tcase TRACE:\n\t\t\tjulLevel = Level.FINEST;\n\t\t\tbreak;\n\t\tcase DEBUG:\n\t\t\tjulLevel = Level.FINE;\n\t\t\tbreak;\n\t\tcase INFO:\n\t\t\tjulLevel = Level.INFO;\n\t\t\tbreak;\n\t\tcase WARN:\n\t\t\tjulLevel = Level.WARNING;\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\t\tjulLevel = Level.SEVERE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Level \" + slf4jLevel + \" is not recognized.\");\n\t\t}\n\t\treturn julLevel;\n\t}\n\n\t/**\n\t * @since 1.7.15\n\t */\n\tpublic void log(LoggingEvent event) {\n\t\t// assumes that the invocation is made from a substitute logger\n\t\t// this assumption might change in the future with the advent of a fluent API\n\t\tLevel julLevel = slf4jLevelToJULLevel(event.getLevel());\n\t\tif (logger.isLoggable(julLevel)) {\n\t\t\tLogRecord record = eventToRecord(event, julLevel);\n\t\t\tlogger.log(record);\n\t\t}\n\t}\n\n\tprivate LogRecord eventToRecord(LoggingEvent event, Level julLevel) {\n\t\tString format = event.getMessage();\n\t\tObject[] arguments = event.getArgumentArray();\n\t\tFormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n\t\tif (ft.getThrowable() != null && event.getThrowable() != null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"both last element in argument array and last argument are of type Throwable\");\n\t\t}\n\n\t\tThrowable t = event.getThrowable();\n\t\tif (ft.getThrowable() != null) {\n\t\t\tt = ft.getThrowable();\n\t\t\tthrow new IllegalStateException(\"fix above code\");\n\t\t}\n\n\t\tLogRecord record = new LogRecord(julLevel, ft.getMessage());\n\t\trecord.setLoggerName(event.getLoggerName());\n\t\trecord.setMillis(event.getTimeStamp());\n\t\trecord.setSourceClassName(EventConstants.NA_SUBST);\n\t\trecord.setSourceMethodName(EventConstants.NA_SUBST);\n\n\t\trecord.setThrown(t);\n\t\treturn record;\n\t}\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.jul;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger {\n\n    private static final long serialVersionUID = -8053026990503422791L;\n\n    transient final java.util.logging.Logger logger;\n\n    // WARN: JDK14LoggerAdapter constructor should have only package access so\n    // that only JDK14LoggerFactory be able to create one.\n    JDK14LoggerAdapter(java.util.logging.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n    }\n\n    /**\n     * Is this logger instance enabled for the FINEST level?\n     * \n     * @return True if this Logger is enabled for level FINEST, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINEST);\n    }\n\n    /**\n     * Log a message object at level FINEST.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINEST.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void trace(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINEST with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the FINE level?\n     * \n     * @return True if this Logger is enabled for level FINE, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    /**\n     * Log a message object at level FINE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINE.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void debug(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the WARNING level?\n     * \n     * @return True if this Logger is enabled for the WARNING level, false\n     *         otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    /**\n     * Log a message object at the WARNING level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARNING according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARNING level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for level SEVERE?\n     * \n     * @return True if this Logger is enabled for level SEVERE, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n\n    /**\n     * Log a message object at the SEVERE level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level SEVERE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void error(String format, Object... arguments) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the SEVERE level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, t);\n        }\n    }\n\n    /**\n     * Log the message at the specified level with the specified throwable if any.\n     * This method creates a LogRecord and fills in caller date before calling\n     * this instance's JDK14 logger.\n     * \n     * See bug report #13 for more details.\n     * \n     * @param level\n     * @param msg\n     * @param t\n     */\n    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n        // millis and thread are filled by the constructor\n        LogRecord record = new LogRecord(level, msg);\n        record.setLoggerName(getName());\n        record.setThrown(t);\n        // Note: parameters in record are not set because SLF4J only\n        // supports a single formatting style\n        fillCallerData(callerFQCN, record);\n        logger.log(record);\n    }\n\n    static String SELF = JDK14LoggerAdapter.class.getName();\n    static String SUPER = MarkerIgnoringBase.class.getName();\n    static String SUBSTITUE = SubstituteLogger.class.getName();\n    \n    static String BARRIER_CLASSES[] = new String[] {SELF, SUPER, SUBSTITUE};\n  \n    /**\n     * Fill in caller data if possible.\n     * \n     * @param record\n     *          The record to update\n     */\n\tfinal private void fillCallerData(String callerFQCN, LogRecord record) {\n        StackTraceElement[] steArray = new Throwable().getStackTrace();\n\n        int selfIndex = -1;\n        for (int i = 0; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            \n            if (barrierMatch(callerFQCN, className)) {\n                selfIndex = i;\n                break;\n            }\n        }\n\n        int found = -1;\n        for (int i = selfIndex + 1; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            if (!(barrierMatch(callerFQCN, className))) {\n                found = i;\n                break;\n            }\n        }\n\n        if (found != -1) {\n            StackTraceElement ste = steArray[found];\n            // setting the class name has the side effect of setting\n            // the needToInferCaller variable to false.\n            record.setSourceClassName(ste.getClassName());\n            record.setSourceMethodName(ste.getMethodName());\n        }\n    }\n\n    private boolean barrierMatch(String callerFQCN, String candidateClassName) {\n    \tif(candidateClassName.equals(callerFQCN))\n    \t\treturn true;\n    \tfor(String barrierClassName: BARRIER_CLASSES) {\n    \t\tif(barrierClassName.equals(candidateClassName)) {\n    \t\t  return true;\n    \t\t}\n    \t}\n    \treturn false;\n\t}\n\n\tpublic void log(Marker marker, String callerFQCN, int level, String message, Object[] argArray, Throwable t) {\n        Level julLevel = slf4jLevelIntToJULLevel(level);\n        // the logger.isLoggable check avoids the unconditional\n        // construction of location data for disabled log\n        // statements. As of 2008-07-31, callers of this method\n        // do not perform this check. See also\n        // http://jira.qos.ch/browse/SLF4J-81\n        if (logger.isLoggable(julLevel)) {\n            log(callerFQCN, julLevel, message, t);\n        }\n    }\n\n    private Level slf4jLevelIntToJULLevel(int slf4jLevelInt) {\n        Level julLevel;\n        switch (slf4jLevelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            julLevel = Level.FINEST;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            julLevel = Level.FINE;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            julLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            julLevel = Level.WARNING;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            julLevel = Level.SEVERE;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + slf4jLevelInt + \" is not recognized.\");\n        }\n        return julLevel;\n    }\n\n    /**\n     * @since 1.7.15\n     */\n    public void log(LoggingEvent event) {\n    \t// assumes that the invocation is made from a substitute logger\n    \t// this assumption might change in the future with the advent of a fluent API\n        Level julLevel = slf4jLevelIntToJULLevel(event.getLevel().toInt());\n        if (logger.isLoggable(julLevel)) {\n            LogRecord record = eventToRecord(event, julLevel);\n            logger.log(record);\n        }\n    }\n\n    private LogRecord eventToRecord(LoggingEvent event, Level julLevel) {\n        String format = event.getMessage();\n        Object[] arguments = event.getArgumentArray();\n        FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n        if (ft.getThrowable() != null && event.getThrowable() != null) {\n            throw new IllegalArgumentException(\"both last element in argument array and last argument are of type Throwable\");\n        }\n\n        Throwable t = event.getThrowable();\n        if (ft.getThrowable() != null) {\n            t = ft.getThrowable();\n            throw new IllegalStateException(\"fix above code\");\n        }\n\n        LogRecord record = new LogRecord(julLevel, ft.getMessage());\n        record.setLoggerName(event.getLoggerName());\n        record.setMillis(event.getTimeStamp());\n        record.setSourceClassName(EventConstants.NA_SUBST);\n        record.setSourceMethodName(EventConstants.NA_SUBST);\n\n        record.setThrown(t);\n        return record;\n    }\n}\n","lineNo":149}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.log4j12;\n\nimport static org.slf4j.event.EventConstants.NA_SUBST;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Level;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.ThrowableInformation;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.LegacyAbstractLogger;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.NormalizedParameters;\nimport org.slf4j.helpers.ParameterNormalizer;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends LegacyAbstractLogger implements LocationAwareLogger, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n\n    @Override\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] arguments, Throwable t) {\n        Level log4jLevel = toLog4jLevel(level);\n        NormalizedParameters np = ParameterNormalizer.normalize(msg, arguments, t);\n        String formattedMessage = MessageFormatter.basicArrayFormat(np.getMessage(), np.getArguments());\n        logger.log(callerFQCN, log4jLevel, formattedMessage, np.getThrowable());\n    }\n\n\t@Override\n\tprotected void handleNormalizedLoggingCall(org.slf4j.event.Level level, Marker marker, String msg, Object[] arguments,\n\t\t\tThrowable throwable) {\n\t\tLevel log4jLevel = toLog4jLevel(level.toInt());\n\t\tString formattedMessage = MessageFormatter.basicArrayFormat(msg, arguments);\n\t\tlogger.log(getFullyQualifiedCallerName(), log4jLevel, formattedMessage, throwable);\n\t}\n\n\t/**\n\t * Called by {@link SubstituteLogger}\n\t * @param event\n\t */\n    public void log(LoggingEvent event) {\n        Level log4jLevel = toLog4jLevel(event.getLevel().toInt());\n        if (!logger.isEnabledFor(log4jLevel))\n            return;\n\n        org.apache.log4j.spi.LoggingEvent log4jevent = toLog4jEvent(event, log4jLevel);\n        logger.callAppenders(log4jevent);\n\n    }\n    \n    private org.apache.log4j.spi.LoggingEvent toLog4jEvent(LoggingEvent event, Level log4jLevel) {\n\n        String formattedMessage = MessageFormatter.basicArrayFormat(event.getMessage(), event.getArgumentArray());\n\n        LocationInfo locationInfo = new LocationInfo(NA_SUBST, NA_SUBST, NA_SUBST, \"0\");\n\n        ThrowableInformation ti = null;\n        Throwable t = event.getThrowable();\n        if (t != null)\n            ti = new ThrowableInformation(t);\n\n        org.apache.log4j.spi.LoggingEvent log4jEvent = new org.apache.log4j.spi.LoggingEvent(FQCN, logger, event.getTimeStamp(), log4jLevel, formattedMessage,\n                        event.getThreadName(), ti, null, locationInfo, null);\n\n        return log4jEvent;\n    }\n\n\n\t\n    private Level toLog4jLevel(int slf4jLevelInt) {\n        Level log4jLevel;\n        switch (slf4jLevelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + slf4jLevelInt + \" is not recognized.\");\n        }\n        return log4jLevel;\n    }\n\n\t@Override\n\tprotected String getFullyQualifiedCallerName() {\n\t\treturn FQCN;\n\t}\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.log4j12;\n\nimport static org.slf4j.event.EventConstants.NA_SUBST;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Level;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.ThrowableInformation;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Log a message object at level TRACE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level TRACE.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void trace(String format, Object... arguments) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level TRACE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    /**\n     * Log a message object at level DEBUG.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level DEBUG.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments an array of arguments\n     */\n    public void debug(String format, Object... arguments) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level DEBUG with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        logger.log(FQCN, Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        logger.log(FQCN, Level.INFO, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    /**\n     * Log a message object at the WARN level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARN according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARN level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        logger.log(FQCN, Level.WARN, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    /**\n     * Log a message object at the ERROR level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level ERROR according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void error(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the ERROR level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        logger.log(FQCN, Level.ERROR, msg, t);\n    }\n\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] argArray, Throwable t) {\n        Level log4jLevel = toLog4jLevel(level);\n        logger.log(callerFQCN, log4jLevel, msg, t);\n    }\n\n    private Level toLog4jLevel(int level) {\n        Level log4jLevel;\n        switch (level) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + level + \" is not recognized.\");\n        }\n        return log4jLevel;\n    }\n\n    public void log(LoggingEvent event) {\n        Level log4jLevel = toLog4jLevel(event.getLevel().toInt());\n        if (!logger.isEnabledFor(log4jLevel))\n            return;\n\n        org.apache.log4j.spi.LoggingEvent log4jevent = toLog4jEvent(event, log4jLevel);\n        logger.callAppenders(log4jevent);\n\n    }\n\n    private org.apache.log4j.spi.LoggingEvent toLog4jEvent(LoggingEvent event, Level log4jLevel) {\n\n        FormattingTuple ft = MessageFormatter.format(event.getMessage(), event.getArgumentArray(), event.getThrowable());\n\n        LocationInfo locationInfo = new LocationInfo(NA_SUBST, NA_SUBST, NA_SUBST, \"0\");\n\n        ThrowableInformation ti = null;\n        Throwable t = ft.getThrowable();\n        if (t != null)\n            ti = new ThrowableInformation(t);\n\n        org.apache.log4j.spi.LoggingEvent log4jEvent = new org.apache.log4j.spi.LoggingEvent(FQCN, logger, event.getTimeStamp(), log4jLevel, ft.getMessage(),\n                        event.getThreadName(), ti, null, locationInfo, null);\n\n        return log4jEvent;\n    }\n\n}\n","lineNo":151}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.log4j12;\n\nimport static org.slf4j.event.EventConstants.NA_SUBST;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Level;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.ThrowableInformation;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.LegacyAbstractLogger;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.NormalizedParameters;\nimport org.slf4j.helpers.ParameterNormalizer;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends LegacyAbstractLogger implements LocationAwareLogger, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n\n    @Override\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] arguments, Throwable t) {\n        Level log4jLevel = toLog4jLevel(level);\n        NormalizedParameters np = ParameterNormalizer.normalize(msg, arguments, t);\n        String formattedMessage = MessageFormatter.basicArrayFormat(np.getMessage(), np.getArguments());\n        logger.log(callerFQCN, log4jLevel, formattedMessage, np.getThrowable());\n    }\n\n\t@Override\n\tprotected void handleNormalizedLoggingCall(org.slf4j.event.Level level, Marker marker, String msg, Object[] arguments,\n\t\t\tThrowable throwable) {\n\t\tLevel log4jLevel = toLog4jLevel(level.toInt());\n\t\tString formattedMessage = MessageFormatter.basicArrayFormat(msg, arguments);\n\t\tlogger.log(getFullyQualifiedCallerName(), log4jLevel, formattedMessage, throwable);\n\t}\n\n\t/**\n\t * Called by {@link SubstituteLogger}\n\t * @param event\n\t */\n    public void log(LoggingEvent event) {\n        Level log4jLevel = toLog4jLevel(event.getLevel().toInt());\n        if (!logger.isEnabledFor(log4jLevel))\n            return;\n\n        org.apache.log4j.spi.LoggingEvent log4jevent = toLog4jEvent(event, log4jLevel);\n        logger.callAppenders(log4jevent);\n\n    }\n    \n    private org.apache.log4j.spi.LoggingEvent toLog4jEvent(LoggingEvent event, Level log4jLevel) {\n\n        String formattedMessage = MessageFormatter.basicArrayFormat(event.getMessage(), event.getArgumentArray());\n\n        LocationInfo locationInfo = new LocationInfo(NA_SUBST, NA_SUBST, NA_SUBST, \"0\");\n\n        ThrowableInformation ti = null;\n        Throwable t = event.getThrowable();\n        if (t != null)\n            ti = new ThrowableInformation(t);\n\n        org.apache.log4j.spi.LoggingEvent log4jEvent = new org.apache.log4j.spi.LoggingEvent(FQCN, logger, event.getTimeStamp(), log4jLevel, formattedMessage,\n                        event.getThreadName(), ti, null, locationInfo, null);\n\n        return log4jEvent;\n    }\n\n\n\t\n    private Level toLog4jLevel(int slf4jLevelInt) {\n        Level log4jLevel;\n        switch (slf4jLevelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + slf4jLevelInt + \" is not recognized.\");\n        }\n        return log4jLevel;\n    }\n\n\t@Override\n\tprotected String getFullyQualifiedCallerName() {\n\t\treturn FQCN;\n\t}\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.log4j12;\n\nimport static org.slf4j.event.EventConstants.NA_SUBST;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Level;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.ThrowableInformation;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Log a message object at level TRACE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level TRACE.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void trace(String format, Object... arguments) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level TRACE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    /**\n     * Log a message object at level DEBUG.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level DEBUG.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arguments an array of arguments\n     */\n    public void debug(String format, Object... arguments) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level DEBUG with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        logger.log(FQCN, Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        logger.log(FQCN, Level.INFO, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    /**\n     * Log a message object at the WARN level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARN according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARN level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        logger.log(FQCN, Level.WARN, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    /**\n     * Log a message object at the ERROR level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level ERROR according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * \n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void error(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the ERROR level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        logger.log(FQCN, Level.ERROR, msg, t);\n    }\n\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] argArray, Throwable t) {\n        Level log4jLevel = toLog4jLevel(level);\n        logger.log(callerFQCN, log4jLevel, msg, t);\n    }\n\n    private Level toLog4jLevel(int level) {\n        Level log4jLevel;\n        switch (level) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + level + \" is not recognized.\");\n        }\n        return log4jLevel;\n    }\n\n    public void log(LoggingEvent event) {\n        Level log4jLevel = toLog4jLevel(event.getLevel().toInt());\n        if (!logger.isEnabledFor(log4jLevel))\n            return;\n\n        org.apache.log4j.spi.LoggingEvent log4jevent = toLog4jEvent(event, log4jLevel);\n        logger.callAppenders(log4jevent);\n\n    }\n\n    private org.apache.log4j.spi.LoggingEvent toLog4jEvent(LoggingEvent event, Level log4jLevel) {\n\n        FormattingTuple ft = MessageFormatter.format(event.getMessage(), event.getArgumentArray(), event.getThrowable());\n\n        LocationInfo locationInfo = new LocationInfo(NA_SUBST, NA_SUBST, NA_SUBST, \"0\");\n\n        ThrowableInformation ti = null;\n        Throwable t = ft.getThrowable();\n        if (t != null)\n            ti = new ThrowableInformation(t);\n\n        org.apache.log4j.spi.LoggingEvent log4jEvent = new org.apache.log4j.spi.LoggingEvent(FQCN, logger, event.getTimeStamp(), log4jLevel, ft.getMessage(),\n                        event.getThreadName(), ti, null, locationInfo, null);\n\n        return log4jEvent;\n    }\n\n}\n","lineNo":152}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2012 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Properties;\n\nimport org.slf4j.Logger;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.Util;\nimport org.slf4j.impl.OutputChoice.OutputChoiceType;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * <p>Simple implementation of {@link Logger} that sends all enabled log messages,\n * for all defined loggers, to the console ({@code System.err}).\n * The following system properties are supported to configure the behavior of this logger:<\/p>\n *\n * <ul>\n * <li><code>org.slf4j.simpleLogger.logFile<\/code> - The output target which can be the <em>path<\/em> to a file, or\n * the special values \"System.out\" and \"System.err\". Default is \"System.err\".\n *\n * <li><code>org.slf4j.simpleLogger.defaultLogLevel<\/code> - Default log level for all instances of SimpleLogger.\n * Must be one of (\"trace\", \"debug\", \"info\", \"warn\", \"error\" or \"off\"). If not specified, defaults to \"info\". <\/li>\n *\n * <li><code>org.slf4j.simpleLogger.log.<em>a.b.c<\/em><\/code> - Logging detail level for a SimpleLogger instance\n * named \"a.b.c\". Right-side value must be one of \"trace\", \"debug\", \"info\", \"warn\", \"error\" or \"off\". When a SimpleLogger\n * named \"a.b.c\" is initialized, its level is assigned from this property. If unspecified, the level of nearest parent\n * logger will be used, and if none is set, then the value specified by\n * <code>org.slf4j.simpleLogger.defaultLogLevel<\/code> will be used.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.showDateTime<\/code> - Set to <code>true<\/code> if you want the current date and\n * time to be included in output messages. Default is <code>false<\/code><\/li>\n *\n * <li><code>org.slf4j.simpleLogger.dateTimeFormat<\/code> - The date and time format to be used in the output messages.\n * The pattern describing the date and time format is defined by\n * <a href=\"http://docs.oracle.com/javase/1.5.0/docs/api/java/text/SimpleDateFormat.html\"><code>SimpleDateFormat<\/code><\/a>.\n * If the format is not specified or is invalid, the number of milliseconds since start up will be output. <\/li>\n *\n * <li><code>org.slf4j.simpleLogger.showThreadName<\/code> -Set to <code>true<\/code> if you want to output the current\n * thread name. Defaults to <code>true<\/code>.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.showLogName<\/code> - Set to <code>true<\/code> if you want the Logger instance name\n * to be included in output messages. Defaults to <code>true<\/code>.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.showShortLogName<\/code> - Set to <code>true<\/code> if you want the last component\n * of the name to be included in output messages. Defaults to <code>false<\/code>.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.levelInBrackets<\/code> - Should the level string be output in brackets? Defaults\n * to <code>false<\/code>.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.warnLevelString<\/code> - The string value output for the warn level. Defaults\n * to <code>WARN<\/code>.<\/li>\n\n * <\/ul>\n *\n * <p>In addition to looking for system properties with the names specified above, this implementation also checks for\n * a class loader resource named <code>\"simplelogger.properties\"<\/code>, and includes any matching definitions\n * from this resource (if it exists).<\/p>\n *\n * <p>With no configuration, the default output includes the relative time in milliseconds, thread name, the level,\n * logger name, and the message followed by the line separator for the host.  In log4j terms it amounts to the \"%r [%t]\n * %level %logger - %m%n\" pattern. <\/p>\n * <p>Sample output follows.<\/p>\n * <pre>\n * 176 [main] INFO examples.Sort - Populating an array of 2 elements in reverse order.\n * 225 [main] INFO examples.SortAlgo - Entered the sort method.\n * 304 [main] INFO examples.SortAlgo - Dump of integer array:\n * 317 [main] INFO examples.SortAlgo - Element [0] = 0\n * 331 [main] INFO examples.SortAlgo - Element [1] = 1\n * 343 [main] INFO examples.Sort - The next log statement should be an error message.\n * 346 [main] ERROR examples.SortAlgo - Tried to dump an uninitialized array.\n *   at org.log4j.examples.SortAlgo.dump(SortAlgo.java:58)\n *   at org.log4j.examples.Sort.main(Sort.java:64)\n * 467 [main] INFO  examples.Sort - Exiting main method.\n * <\/pre>\n *\n * <p>This implementation is heavily inspired by\n * <a href=\"http://commons.apache.org/logging/\">Apache Commons Logging<\/a>'s SimpleLog.<\/p>\n *\n * @author Ceki G&uuml;lc&uuml;\n * @author <a href=\"mailto:sanders@apache.org\">Scott Sanders<\/a>\n * @author Rod Waldhoff\n * @author Robert Burrell Donkin\n * @author C&eacute;drik LIME\n */\npublic class SimpleLogger extends MarkerIgnoringBase {\n\n    private static final long serialVersionUID = -632788891211436180L;\n    private static final String CONFIGURATION_FILE = \"simplelogger.properties\";\n\n    private static long START_TIME = System.currentTimeMillis();\n    private static final Properties SIMPLE_LOGGER_PROPS = new Properties();\n\n    protected static final int LOG_LEVEL_TRACE = LocationAwareLogger.TRACE_INT;\n    protected static final int LOG_LEVEL_DEBUG = LocationAwareLogger.DEBUG_INT;\n    protected static final int LOG_LEVEL_INFO = LocationAwareLogger.INFO_INT;\n    protected static final int LOG_LEVEL_WARN = LocationAwareLogger.WARN_INT;\n    protected static final int LOG_LEVEL_ERROR = LocationAwareLogger.ERROR_INT;\n    // The OFF level can only be used in configuration files to disable logging. It has\n    // no printing method associated with it in o.s.Logger interface.\n    protected static final int LOG_LEVEL_OFF = LOG_LEVEL_ERROR + 10;\n\n    private static boolean INITIALIZED = false;\n\n    private static int DEFAULT_LOG_LEVEL = LOG_LEVEL_INFO;\n    private static boolean SHOW_DATE_TIME = false;\n    private static String DATE_TIME_FORMAT_STR = null;\n    private static DateFormat DATE_FORMATTER = null;\n    private static boolean SHOW_THREAD_NAME = true;\n    private static boolean SHOW_LOG_NAME = true;\n    private static boolean SHOW_SHORT_LOG_NAME = false;\n    private static String LOG_FILE = \"System.err\";\n    private static OutputChoice OUTPUT_CHOICE = null;\n    private static boolean LEVEL_IN_BRACKETS = false;\n    private static String WARN_LEVEL_STRING = \"WARN\";\n\n    /** All system properties used by <code>SimpleLogger<\/code> start with this prefix */\n    public static final String SYSTEM_PREFIX = \"org.slf4j.simpleLogger.\";\n\n    public static final String DEFAULT_LOG_LEVEL_KEY = SYSTEM_PREFIX + \"defaultLogLevel\";\n    public static final String SHOW_DATE_TIME_KEY = SYSTEM_PREFIX + \"showDateTime\";\n    public static final String DATE_TIME_FORMAT_KEY = SYSTEM_PREFIX + \"dateTimeFormat\";\n    public static final String SHOW_THREAD_NAME_KEY = SYSTEM_PREFIX + \"showThreadName\";\n    public static final String SHOW_LOG_NAME_KEY = SYSTEM_PREFIX + \"showLogName\";\n    public static final String SHOW_SHORT_LOG_NAME_KEY = SYSTEM_PREFIX + \"showShortLogName\";\n    public static final String LOG_FILE_KEY = SYSTEM_PREFIX + \"logFile\";\n    public static final String LEVEL_IN_BRACKETS_KEY = SYSTEM_PREFIX + \"levelInBrackets\";\n    public static final String WARN_LEVEL_STRING_KEY = SYSTEM_PREFIX + \"warnLevelString\";\n\n    public static final String LOG_KEY_PREFIX = SYSTEM_PREFIX + \"log.\";\n\n    private static String getStringProperty(String name) {\n        String prop = null;\n        try {\n            prop = System.getProperty(name);\n        } catch (SecurityException e) {\n            ; // Ignore\n        }\n        return (prop == null) ? SIMPLE_LOGGER_PROPS.getProperty(name) : prop;\n    }\n\n    private static String getStringProperty(String name, String defaultValue) {\n        String prop = getStringProperty(name);\n        return (prop == null) ? defaultValue : prop;\n    }\n\n    private static boolean getBooleanProperty(String name, boolean defaultValue) {\n        String prop = getStringProperty(name);\n        return (prop == null) ? defaultValue : \"true\".equalsIgnoreCase(prop);\n    }\n\n    static void lazyInit() {\n        if (INITIALIZED) {\n            return;\n        }\n        INITIALIZED = true;\n        init();\n    }\n    \n    static void init() {\n        loadProperties();\n\n        String defaultLogLevelString = getStringProperty(DEFAULT_LOG_LEVEL_KEY, null);\n        if (defaultLogLevelString != null)\n            DEFAULT_LOG_LEVEL = stringToLevel(defaultLogLevelString);\n\n        SHOW_LOG_NAME = getBooleanProperty(SHOW_LOG_NAME_KEY, SHOW_LOG_NAME);\n        SHOW_SHORT_LOG_NAME = getBooleanProperty(SHOW_SHORT_LOG_NAME_KEY, SHOW_SHORT_LOG_NAME);\n        SHOW_DATE_TIME = getBooleanProperty(SHOW_DATE_TIME_KEY, SHOW_DATE_TIME);\n        SHOW_THREAD_NAME = getBooleanProperty(SHOW_THREAD_NAME_KEY, SHOW_THREAD_NAME);\n        DATE_TIME_FORMAT_STR = getStringProperty(DATE_TIME_FORMAT_KEY, DATE_TIME_FORMAT_STR);\n        LEVEL_IN_BRACKETS = getBooleanProperty(LEVEL_IN_BRACKETS_KEY, LEVEL_IN_BRACKETS);\n        WARN_LEVEL_STRING = getStringProperty(WARN_LEVEL_STRING_KEY, WARN_LEVEL_STRING);\n\n        LOG_FILE = getStringProperty(LOG_FILE_KEY, LOG_FILE);\n        OUTPUT_CHOICE = computeOutputChoice(LOG_FILE);\n\n        if (DATE_TIME_FORMAT_STR != null) {\n            try {\n                DATE_FORMATTER = new SimpleDateFormat(DATE_TIME_FORMAT_STR);\n            } catch (IllegalArgumentException e) {\n                Util.report(\"Bad date format in \" + CONFIGURATION_FILE + \"; will output relative time\", e);\n            }\n        }\n    }\n\n    enum Target {\n    \tSysOut, SysErr;\n    }\n    \n    private static OutputChoice computeOutputChoice(String logFile) {\n        if (\"System.err\".equalsIgnoreCase(logFile))\n            return new OutputChoice(OutputChoiceType.SYS_ERR);\n        else if (\"System.out\".equalsIgnoreCase(logFile)) {\n            return  new OutputChoice(OutputChoiceType.SYS_OUT);\n        } else {\n            try {\n                FileOutputStream fos = new FileOutputStream(logFile);\n                PrintStream printStream = new PrintStream(fos);\n                return new OutputChoice(printStream);\n            } catch (FileNotFoundException e) {\n                Util.report(\"Could not open [\" + logFile + \"]. Defaulting to System.err\", e);\n                return new OutputChoice(OutputChoiceType.SYS_ERR);\n            }\n        }\n    }\n\n    private static void loadProperties() {\n        // Add props from the resource simplelogger.properties\n        InputStream in = AccessController.doPrivileged(new PrivilegedAction<InputStream>() {\n            public InputStream run() {\n                ClassLoader threadCL = Thread.currentThread().getContextClassLoader();\n                if (threadCL != null) {\n                    return threadCL.getResourceAsStream(CONFIGURATION_FILE);\n                } else {\n                    return ClassLoader.getSystemResourceAsStream(CONFIGURATION_FILE);\n                }\n            }\n        });\n        if (null != in) {\n            try {\n                SIMPLE_LOGGER_PROPS.load(in);\n            } catch (java.io.IOException e) {\n                // ignored\n            } finally {\n                try {\n                    in.close();\n                } catch (java.io.IOException e) {\n                    // ignored\n                }\n            }\n        }\n    }\n\n    /** The current log level */\n    protected int currentLogLevel = LOG_LEVEL_INFO;\n    /** The short name of this simple log instance */\n    private transient String shortLogName = null;\n\n    /**\n     * Package access allows only {@link SimpleLoggerFactory} to instantiate\n     * SimpleLogger instances.\n     */\n    SimpleLogger(String name) {\n        this.name = name;\n\n        String levelString = recursivelyComputeLevelString();\n        if (levelString != null) {\n            this.currentLogLevel = stringToLevel(levelString);\n        } else {\n            this.currentLogLevel = DEFAULT_LOG_LEVEL;\n        }\n    }\n\n    String recursivelyComputeLevelString() {\n        String tempName = name;\n        String levelString = null;\n        int indexOfLastDot = tempName.length();\n        while ((levelString == null) && (indexOfLastDot > -1)) {\n            tempName = tempName.substring(0, indexOfLastDot);\n            levelString = getStringProperty(LOG_KEY_PREFIX + tempName, null);\n            indexOfLastDot = String.valueOf(tempName).lastIndexOf(\".\");\n        }\n        return levelString;\n    }\n\n    private static int stringToLevel(String levelStr) {\n        if (\"trace\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_TRACE;\n        } else if (\"debug\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_DEBUG;\n        } else if (\"info\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_INFO;\n        } else if (\"warn\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_WARN;\n        } else if (\"error\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_ERROR;\n        } else if (\"off\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_OFF;\n        }\n        // assume INFO by default\n        return LOG_LEVEL_INFO;\n    }\n\n    /**\n     * This is our internal implementation for logging regular (non-parameterized)\n     * log messages.\n     *\n     * @param level   One of the LOG_LEVEL_XXX constants defining the log level\n     * @param message The message itself\n     * @param t       The exception whose stack trace should be logged\n     */\n    private void log(int level, String message, Throwable t) {\n        if (!isLevelEnabled(level)) {\n            return;\n        }\n\n        StringBuilder buf = new StringBuilder(32);\n\n        // Append date-time if so configured\n        if (SHOW_DATE_TIME) {\n            if (DATE_FORMATTER != null) {\n                buf.append(getFormattedDate());\n                buf.append(' ');\n            } else {\n                buf.append(System.currentTimeMillis() - START_TIME);\n                buf.append(' ');\n            }\n        }\n\n        // Append current thread name if so configured\n        if (SHOW_THREAD_NAME) {\n            buf.append('[');\n            buf.append(Thread.currentThread().getName());\n            buf.append(\"] \");\n        }\n\n        if (LEVEL_IN_BRACKETS)\n            buf.append('[');\n\n        // Append a readable representation of the log level\n        String levelStr = renderLevel(level);\n        buf.append(levelStr);\n        if (LEVEL_IN_BRACKETS)\n            buf.append(']');\n        buf.append(' ');\n\n        // Append the name of the log instance if so configured\n        if (SHOW_SHORT_LOG_NAME) {\n            if (shortLogName == null)\n                shortLogName = computeShortName();\n            buf.append(String.valueOf(shortLogName)).append(\" - \");\n        } else if (SHOW_LOG_NAME) {\n            buf.append(String.valueOf(name)).append(\" - \");\n        }\n\n        // Append the message\n        buf.append(message);\n\n        write(buf, t);\n\n    }\n\n\tprotected String renderLevel(int level) {\n\t\tswitch (level) {\n        case LOG_LEVEL_TRACE:\n            return \"TRACE\";\n        case LOG_LEVEL_DEBUG:\n        \treturn(\"DEBUG\");\n        case LOG_LEVEL_INFO:\n        \treturn \"INFO\";\n        case LOG_LEVEL_WARN:\n        \treturn WARN_LEVEL_STRING;\n        case LOG_LEVEL_ERROR:\n        \treturn \"ERROR\";\n        }\n        throw new IllegalStateException(\"Unrecognized level [\"+level+\"]\");\n\t}\n\n    void write(StringBuilder buf, Throwable t) {\n    \tPrintStream targetStream = OUTPUT_CHOICE.getTargetPrintStream();\n    \t\n    \ttargetStream.println(buf.toString());\n        writeThrowable(t, targetStream);\n        targetStream.flush();\n    }\n\n    protected void writeThrowable(Throwable t, PrintStream targetStream) {\n\t\tif (t != null) {\n            t.printStackTrace(targetStream);\n        }\n\t}\n\t\n\tprivate String getFormattedDate() {\n        Date now = new Date();\n        String dateText;\n        synchronized (DATE_FORMATTER) {\n            dateText = DATE_FORMATTER.format(now);\n        }\n        return dateText;\n    }\n\n    private String computeShortName() {\n        return name.substring(name.lastIndexOf(\".\") + 1);\n    }\n\n    /**\n     * For formatted messages, first substitute arguments and then log.\n     *\n     * @param level\n     * @param format\n     * @param arg1\n     * @param arg2\n     */\n    private void formatAndLog(int level, String format, Object arg1, Object arg2) {\n        if (!isLevelEnabled(level)) {\n            return;\n        }\n        FormattingTuple tp = MessageFormatter.format(format, arg1, arg2);\n        log(level, tp.getMessage(), tp.getThrowable());\n    }\n\n    /**\n     * For formatted messages, first substitute arguments and then log.\n     *\n     * @param level\n     * @param format\n     * @param arguments a list of 3 ore more arguments\n     */\n    private void formatAndLog(int level, String format, Object... arguments) {\n        if (!isLevelEnabled(level)) {\n            return;\n        }\n        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n        log(level, tp.getMessage(), tp.getThrowable());\n    }\n\n    /**\n     * Is the given log level currently enabled?\n     *\n     * @param logLevel is this level enabled?\n     */\n    protected boolean isLevelEnabled(int logLevel) {\n        // log level are numerically ordered so can use simple numeric\n        // comparison\n        return (logLevel >= currentLogLevel);\n    }\n\n    /** Are {@code trace} messages currently enabled? */\n    public boolean isTraceEnabled() {\n        return isLevelEnabled(LOG_LEVEL_TRACE);\n    }\n\n    /**\n     * A simple implementation which logs messages of level TRACE according\n     * to the format outlined above.\n     */\n    public void trace(String msg) {\n        log(LOG_LEVEL_TRACE, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * TRACE according to the format outlined above.\n     */\n    public void trace(String format, Object param1) {\n        formatAndLog(LOG_LEVEL_TRACE, format, param1, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * TRACE according to the format outlined above.\n     */\n    public void trace(String format, Object param1, Object param2) {\n        formatAndLog(LOG_LEVEL_TRACE, format, param1, param2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * TRACE according to the format outlined above.\n     */\n    public void trace(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_TRACE, format, argArray);\n    }\n\n    /** Log a message of level TRACE, including an exception. */\n    public void trace(String msg, Throwable t) {\n        log(LOG_LEVEL_TRACE, msg, t);\n    }\n\n    /** Are {@code debug} messages currently enabled? */\n    public boolean isDebugEnabled() {\n        return isLevelEnabled(LOG_LEVEL_DEBUG);\n    }\n\n    /**\n     * A simple implementation which logs messages of level DEBUG according\n     * to the format outlined above.\n     */\n    public void debug(String msg) {\n        log(LOG_LEVEL_DEBUG, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * DEBUG according to the format outlined above.\n     */\n    public void debug(String format, Object param1) {\n        formatAndLog(LOG_LEVEL_DEBUG, format, param1, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * DEBUG according to the format outlined above.\n     */\n    public void debug(String format, Object param1, Object param2) {\n        formatAndLog(LOG_LEVEL_DEBUG, format, param1, param2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * DEBUG according to the format outlined above.\n     */\n    public void debug(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_DEBUG, format, argArray);\n    }\n\n    /** Log a message of level DEBUG, including an exception. */\n    public void debug(String msg, Throwable t) {\n        log(LOG_LEVEL_DEBUG, msg, t);\n    }\n\n    /** Are {@code info} messages currently enabled? */\n    public boolean isInfoEnabled() {\n        return isLevelEnabled(LOG_LEVEL_INFO);\n    }\n\n    /**\n     * A simple implementation which logs messages of level INFO according\n     * to the format outlined above.\n     */\n    public void info(String msg) {\n        log(LOG_LEVEL_INFO, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * INFO according to the format outlined above.\n     */\n    public void info(String format, Object arg) {\n        formatAndLog(LOG_LEVEL_INFO, format, arg, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * INFO according to the format outlined above.\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        formatAndLog(LOG_LEVEL_INFO, format, arg1, arg2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * INFO according to the format outlined above.\n     */\n    public void info(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_INFO, format, argArray);\n    }\n\n    /** Log a message of level INFO, including an exception. */\n    public void info(String msg, Throwable t) {\n        log(LOG_LEVEL_INFO, msg, t);\n    }\n\n    /** Are {@code warn} messages currently enabled? */\n    public boolean isWarnEnabled() {\n        return isLevelEnabled(LOG_LEVEL_WARN);\n    }\n\n    /**\n     * A simple implementation which always logs messages of level WARN according\n     * to the format outlined above.\n     */\n    public void warn(String msg) {\n        log(LOG_LEVEL_WARN, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * WARN according to the format outlined above.\n     */\n    public void warn(String format, Object arg) {\n        formatAndLog(LOG_LEVEL_WARN, format, arg, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * WARN according to the format outlined above.\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        formatAndLog(LOG_LEVEL_WARN, format, arg1, arg2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * WARN according to the format outlined above.\n     */\n    public void warn(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_WARN, format, argArray);\n    }\n\n    /** Log a message of level WARN, including an exception. */\n    public void warn(String msg, Throwable t) {\n        log(LOG_LEVEL_WARN, msg, t);\n    }\n\n    /** Are {@code error} messages currently enabled? */\n    public boolean isErrorEnabled() {\n        return isLevelEnabled(LOG_LEVEL_ERROR);\n    }\n\n    /**\n     * A simple implementation which always logs messages of level ERROR according\n     * to the format outlined above.\n     */\n    public void error(String msg) {\n        log(LOG_LEVEL_ERROR, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * ERROR according to the format outlined above.\n     */\n    public void error(String format, Object arg) {\n        formatAndLog(LOG_LEVEL_ERROR, format, arg, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * ERROR according to the format outlined above.\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        formatAndLog(LOG_LEVEL_ERROR, format, arg1, arg2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * ERROR according to the format outlined above.\n     */\n    public void error(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_ERROR, format, argArray);\n    }\n\n    /** Log a message of level ERROR, including an exception. */\n    public void error(String msg, Throwable t) {\n        log(LOG_LEVEL_ERROR, msg, t);\n    }\n\n    public void log(LoggingEvent event) {\n        int levelInt = event.getLevel().toInt();\n\n        if (!isLevelEnabled(levelInt)) {\n            return;\n        }\n        FormattingTuple tp = MessageFormatter.arrayFormat(event.getMessage(), event.getArgumentArray(), event.getThrowable());\n        log(levelInt, tp.getMessage(), event.getThrowable());\n    }\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2012 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Properties;\n\nimport org.slf4j.Logger;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.Util;\nimport org.slf4j.impl.OutputChoice.OutputChoiceType;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * <p>Simple implementation of {@link Logger} that sends all enabled log messages,\n * for all defined loggers, to the console ({@code System.err}).\n * The following system properties are supported to configure the behavior of this logger:<\/p>\n *\n * <ul>\n * <li><code>org.slf4j.simpleLogger.logFile<\/code> - The output target which can be the <em>path<\/em> to a file, or\n * the special values \"System.out\" and \"System.err\". Default is \"System.err\".\n *\n * <li><code>org.slf4j.simpleLogger.defaultLogLevel<\/code> - Default log level for all instances of SimpleLogger.\n * Must be one of (\"trace\", \"debug\", \"info\", \"warn\", \"error\" or \"off\"). If not specified, defaults to \"info\". <\/li>\n *\n * <li><code>org.slf4j.simpleLogger.log.<em>a.b.c<\/em><\/code> - Logging detail level for a SimpleLogger instance\n * named \"a.b.c\". Right-side value must be one of \"trace\", \"debug\", \"info\", \"warn\", \"error\" or \"off\". When a SimpleLogger\n * named \"a.b.c\" is initialized, its level is assigned from this property. If unspecified, the level of nearest parent\n * logger will be used, and if none is set, then the value specified by\n * <code>org.slf4j.simpleLogger.defaultLogLevel<\/code> will be used.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.showDateTime<\/code> - Set to <code>true<\/code> if you want the current date and\n * time to be included in output messages. Default is <code>false<\/code><\/li>\n *\n * <li><code>org.slf4j.simpleLogger.dateTimeFormat<\/code> - The date and time format to be used in the output messages.\n * The pattern describing the date and time format is defined by\n * <a href=\"http://docs.oracle.com/javase/1.5.0/docs/api/java/text/SimpleDateFormat.html\"><code>SimpleDateFormat<\/code><\/a>.\n * If the format is not specified or is invalid, the number of milliseconds since start up will be output. <\/li>\n *\n * <li><code>org.slf4j.simpleLogger.showThreadName<\/code> -Set to <code>true<\/code> if you want to output the current\n * thread name. Defaults to <code>true<\/code>.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.showLogName<\/code> - Set to <code>true<\/code> if you want the Logger instance name\n * to be included in output messages. Defaults to <code>true<\/code>.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.showShortLogName<\/code> - Set to <code>true<\/code> if you want the last component\n * of the name to be included in output messages. Defaults to <code>false<\/code>.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.levelInBrackets<\/code> - Should the level string be output in brackets? Defaults\n * to <code>false<\/code>.<\/li>\n *\n * <li><code>org.slf4j.simpleLogger.warnLevelString<\/code> - The string value output for the warn level. Defaults\n * to <code>WARN<\/code>.<\/li>\n\n * <\/ul>\n *\n * <p>In addition to looking for system properties with the names specified above, this implementation also checks for\n * a class loader resource named <code>\"simplelogger.properties\"<\/code>, and includes any matching definitions\n * from this resource (if it exists).<\/p>\n *\n * <p>With no configuration, the default output includes the relative time in milliseconds, thread name, the level,\n * logger name, and the message followed by the line separator for the host.  In log4j terms it amounts to the \"%r [%t]\n * %level %logger - %m%n\" pattern. <\/p>\n * <p>Sample output follows.<\/p>\n * <pre>\n * 176 [main] INFO examples.Sort - Populating an array of 2 elements in reverse order.\n * 225 [main] INFO examples.SortAlgo - Entered the sort method.\n * 304 [main] INFO examples.SortAlgo - Dump of integer array:\n * 317 [main] INFO examples.SortAlgo - Element [0] = 0\n * 331 [main] INFO examples.SortAlgo - Element [1] = 1\n * 343 [main] INFO examples.Sort - The next log statement should be an error message.\n * 346 [main] ERROR examples.SortAlgo - Tried to dump an uninitialized array.\n *   at org.log4j.examples.SortAlgo.dump(SortAlgo.java:58)\n *   at org.log4j.examples.Sort.main(Sort.java:64)\n * 467 [main] INFO  examples.Sort - Exiting main method.\n * <\/pre>\n *\n * <p>This implementation is heavily inspired by\n * <a href=\"http://commons.apache.org/logging/\">Apache Commons Logging<\/a>'s SimpleLog.<\/p>\n *\n * @author Ceki G&uuml;lc&uuml;\n * @author <a href=\"mailto:sanders@apache.org\">Scott Sanders<\/a>\n * @author Rod Waldhoff\n * @author Robert Burrell Donkin\n * @author C&eacute;drik LIME\n */\npublic class SimpleLogger extends MarkerIgnoringBase {\n\n    private static final long serialVersionUID = -632788891211436180L;\n    private static final String CONFIGURATION_FILE = \"simplelogger.properties\";\n\n    private static long START_TIME = System.currentTimeMillis();\n    private static final Properties SIMPLE_LOGGER_PROPS = new Properties();\n\n    private static final int LOG_LEVEL_TRACE = LocationAwareLogger.TRACE_INT;\n    private static final int LOG_LEVEL_DEBUG = LocationAwareLogger.DEBUG_INT;\n    private static final int LOG_LEVEL_INFO = LocationAwareLogger.INFO_INT;\n    private static final int LOG_LEVEL_WARN = LocationAwareLogger.WARN_INT;\n    private static final int LOG_LEVEL_ERROR = LocationAwareLogger.ERROR_INT;\n    // The OFF level can only be used in configuration files to disable logging. It has\n    // no printing method associated with it in o.s.Logger interface.\n    private static final int LOG_LEVEL_OFF = LOG_LEVEL_ERROR + 10;\n\n    private static boolean INITIALIZED = false;\n\n    private static int DEFAULT_LOG_LEVEL = LOG_LEVEL_INFO;\n    private static boolean SHOW_DATE_TIME = false;\n    private static String DATE_TIME_FORMAT_STR = null;\n    private static DateFormat DATE_FORMATTER = null;\n    private static boolean SHOW_THREAD_NAME = true;\n    private static boolean SHOW_LOG_NAME = true;\n    private static boolean SHOW_SHORT_LOG_NAME = false;\n    private static String LOG_FILE = \"System.err\";\n    private static OutputChoice OUTPUT_CHOICE = null;\n    private static boolean LEVEL_IN_BRACKETS = false;\n    private static String WARN_LEVEL_STRING = \"WARN\";\n\n    /** All system properties used by <code>SimpleLogger<\/code> start with this prefix */\n    public static final String SYSTEM_PREFIX = \"org.slf4j.simpleLogger.\";\n\n    public static final String DEFAULT_LOG_LEVEL_KEY = SYSTEM_PREFIX + \"defaultLogLevel\";\n    public static final String SHOW_DATE_TIME_KEY = SYSTEM_PREFIX + \"showDateTime\";\n    public static final String DATE_TIME_FORMAT_KEY = SYSTEM_PREFIX + \"dateTimeFormat\";\n    public static final String SHOW_THREAD_NAME_KEY = SYSTEM_PREFIX + \"showThreadName\";\n    public static final String SHOW_LOG_NAME_KEY = SYSTEM_PREFIX + \"showLogName\";\n    public static final String SHOW_SHORT_LOG_NAME_KEY = SYSTEM_PREFIX + \"showShortLogName\";\n    public static final String LOG_FILE_KEY = SYSTEM_PREFIX + \"logFile\";\n    public static final String LEVEL_IN_BRACKETS_KEY = SYSTEM_PREFIX + \"levelInBrackets\";\n    public static final String WARN_LEVEL_STRING_KEY = SYSTEM_PREFIX + \"warnLevelString\";\n\n    public static final String LOG_KEY_PREFIX = SYSTEM_PREFIX + \"log.\";\n\n    private static String getStringProperty(String name) {\n        String prop = null;\n        try {\n            prop = System.getProperty(name);\n        } catch (SecurityException e) {\n            ; // Ignore\n        }\n        return (prop == null) ? SIMPLE_LOGGER_PROPS.getProperty(name) : prop;\n    }\n\n    private static String getStringProperty(String name, String defaultValue) {\n        String prop = getStringProperty(name);\n        return (prop == null) ? defaultValue : prop;\n    }\n\n    private static boolean getBooleanProperty(String name, boolean defaultValue) {\n        String prop = getStringProperty(name);\n        return (prop == null) ? defaultValue : \"true\".equalsIgnoreCase(prop);\n    }\n\n    static void lazyInit() {\n        if (INITIALIZED) {\n            return;\n        }\n        INITIALIZED = true;\n        init();\n    }\n    \n    static void init() {\n        loadProperties();\n\n        String defaultLogLevelString = getStringProperty(DEFAULT_LOG_LEVEL_KEY, null);\n        if (defaultLogLevelString != null)\n            DEFAULT_LOG_LEVEL = stringToLevel(defaultLogLevelString);\n\n        SHOW_LOG_NAME = getBooleanProperty(SHOW_LOG_NAME_KEY, SHOW_LOG_NAME);\n        SHOW_SHORT_LOG_NAME = getBooleanProperty(SHOW_SHORT_LOG_NAME_KEY, SHOW_SHORT_LOG_NAME);\n        SHOW_DATE_TIME = getBooleanProperty(SHOW_DATE_TIME_KEY, SHOW_DATE_TIME);\n        SHOW_THREAD_NAME = getBooleanProperty(SHOW_THREAD_NAME_KEY, SHOW_THREAD_NAME);\n        DATE_TIME_FORMAT_STR = getStringProperty(DATE_TIME_FORMAT_KEY, DATE_TIME_FORMAT_STR);\n        LEVEL_IN_BRACKETS = getBooleanProperty(LEVEL_IN_BRACKETS_KEY, LEVEL_IN_BRACKETS);\n        WARN_LEVEL_STRING = getStringProperty(WARN_LEVEL_STRING_KEY, WARN_LEVEL_STRING);\n\n        LOG_FILE = getStringProperty(LOG_FILE_KEY, LOG_FILE);\n        OUTPUT_CHOICE = computeOutputChoice(LOG_FILE);\n\n        if (DATE_TIME_FORMAT_STR != null) {\n            try {\n                DATE_FORMATTER = new SimpleDateFormat(DATE_TIME_FORMAT_STR);\n            } catch (IllegalArgumentException e) {\n                Util.report(\"Bad date format in \" + CONFIGURATION_FILE + \"; will output relative time\", e);\n            }\n        }\n    }\n\n    enum Target {\n    \tSysOut, SysErr;\n    }\n    \n    private static OutputChoice computeOutputChoice(String logFile) {\n        if (\"System.err\".equalsIgnoreCase(logFile))\n            return new OutputChoice(OutputChoiceType.SYS_ERR);\n        else if (\"System.out\".equalsIgnoreCase(logFile)) {\n            return  new OutputChoice(OutputChoiceType.SYS_OUT);\n        } else {\n            try {\n                FileOutputStream fos = new FileOutputStream(logFile);\n                PrintStream printStream = new PrintStream(fos);\n                return new OutputChoice(printStream);\n            } catch (FileNotFoundException e) {\n                Util.report(\"Could not open [\" + logFile + \"]. Defaulting to System.err\", e);\n                return new OutputChoice(OutputChoiceType.SYS_ERR);\n            }\n        }\n    }\n\n    private static void loadProperties() {\n        // Add props from the resource simplelogger.properties\n        InputStream in = AccessController.doPrivileged(new PrivilegedAction<InputStream>() {\n            public InputStream run() {\n                ClassLoader threadCL = Thread.currentThread().getContextClassLoader();\n                if (threadCL != null) {\n                    return threadCL.getResourceAsStream(CONFIGURATION_FILE);\n                } else {\n                    return ClassLoader.getSystemResourceAsStream(CONFIGURATION_FILE);\n                }\n            }\n        });\n        if (null != in) {\n            try {\n                SIMPLE_LOGGER_PROPS.load(in);\n            } catch (java.io.IOException e) {\n                // ignored\n            } finally {\n                try {\n                    in.close();\n                } catch (java.io.IOException e) {\n                    // ignored\n                }\n            }\n        }\n    }\n\n    /** The current log level */\n    protected int currentLogLevel = LOG_LEVEL_INFO;\n    /** The short name of this simple log instance */\n    private transient String shortLogName = null;\n\n    /**\n     * Package access allows only {@link SimpleLoggerFactory} to instantiate\n     * SimpleLogger instances.\n     */\n    SimpleLogger(String name) {\n        this.name = name;\n\n        String levelString = recursivelyComputeLevelString();\n        if (levelString != null) {\n            this.currentLogLevel = stringToLevel(levelString);\n        } else {\n            this.currentLogLevel = DEFAULT_LOG_LEVEL;\n        }\n    }\n\n    String recursivelyComputeLevelString() {\n        String tempName = name;\n        String levelString = null;\n        int indexOfLastDot = tempName.length();\n        while ((levelString == null) && (indexOfLastDot > -1)) {\n            tempName = tempName.substring(0, indexOfLastDot);\n            levelString = getStringProperty(LOG_KEY_PREFIX + tempName, null);\n            indexOfLastDot = String.valueOf(tempName).lastIndexOf(\".\");\n        }\n        return levelString;\n    }\n\n    private static int stringToLevel(String levelStr) {\n        if (\"trace\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_TRACE;\n        } else if (\"debug\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_DEBUG;\n        } else if (\"info\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_INFO;\n        } else if (\"warn\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_WARN;\n        } else if (\"error\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_ERROR;\n        } else if (\"off\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_OFF;\n        }\n        // assume INFO by default\n        return LOG_LEVEL_INFO;\n    }\n\n    /**\n     * This is our internal implementation for logging regular (non-parameterized)\n     * log messages.\n     *\n     * @param level   One of the LOG_LEVEL_XXX constants defining the log level\n     * @param message The message itself\n     * @param t       The exception whose stack trace should be logged\n     */\n    private void log(int level, String message, Throwable t) {\n        if (!isLevelEnabled(level)) {\n            return;\n        }\n\n        StringBuilder buf = new StringBuilder(32);\n\n        // Append date-time if so configured\n        if (SHOW_DATE_TIME) {\n            if (DATE_FORMATTER != null) {\n                buf.append(getFormattedDate());\n                buf.append(' ');\n            } else {\n                buf.append(System.currentTimeMillis() - START_TIME);\n                buf.append(' ');\n            }\n        }\n\n        // Append current thread name if so configured\n        if (SHOW_THREAD_NAME) {\n            buf.append('[');\n            buf.append(Thread.currentThread().getName());\n            buf.append(\"] \");\n        }\n\n        if (LEVEL_IN_BRACKETS)\n            buf.append('[');\n\n        // Append a readable representation of the log level\n        switch (level) {\n        case LOG_LEVEL_TRACE:\n            buf.append(\"TRACE\");\n            break;\n        case LOG_LEVEL_DEBUG:\n            buf.append(\"DEBUG\");\n            break;\n        case LOG_LEVEL_INFO:\n            buf.append(\"INFO\");\n            break;\n        case LOG_LEVEL_WARN:\n            buf.append(WARN_LEVEL_STRING);\n            break;\n        case LOG_LEVEL_ERROR:\n            buf.append(\"ERROR\");\n            break;\n        }\n        if (LEVEL_IN_BRACKETS)\n            buf.append(']');\n        buf.append(' ');\n\n        // Append the name of the log instance if so configured\n        if (SHOW_SHORT_LOG_NAME) {\n            if (shortLogName == null)\n                shortLogName = computeShortName();\n            buf.append(String.valueOf(shortLogName)).append(\" - \");\n        } else if (SHOW_LOG_NAME) {\n            buf.append(String.valueOf(name)).append(\" - \");\n        }\n\n        // Append the message\n        buf.append(message);\n\n        write(buf, t);\n\n    }\n\n    void write(StringBuilder buf, Throwable t) {\n    \tPrintStream targetStream = OUTPUT_CHOICE.getTargetPrintStream();\n    \t\n    \ttargetStream.println(buf.toString());\n        if (t != null) {\n            t.printStackTrace(targetStream);\n        }\n        targetStream.flush();\n    }\n\n\tObject t;\n\t\n\n\tprivate String getFormattedDate() {\n        Date now = new Date();\n        String dateText;\n        synchronized (DATE_FORMATTER) {\n            dateText = DATE_FORMATTER.format(now);\n        }\n        return dateText;\n    }\n\n    private String computeShortName() {\n        return name.substring(name.lastIndexOf(\".\") + 1);\n    }\n\n    /**\n     * For formatted messages, first substitute arguments and then log.\n     *\n     * @param level\n     * @param format\n     * @param arg1\n     * @param arg2\n     */\n    private void formatAndLog(int level, String format, Object arg1, Object arg2) {\n        if (!isLevelEnabled(level)) {\n            return;\n        }\n        FormattingTuple tp = MessageFormatter.format(format, arg1, arg2);\n        log(level, tp.getMessage(), tp.getThrowable());\n    }\n\n    /**\n     * For formatted messages, first substitute arguments and then log.\n     *\n     * @param level\n     * @param format\n     * @param arguments a list of 3 ore more arguments\n     */\n    private void formatAndLog(int level, String format, Object... arguments) {\n        if (!isLevelEnabled(level)) {\n            return;\n        }\n        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n        log(level, tp.getMessage(), tp.getThrowable());\n    }\n\n    /**\n     * Is the given log level currently enabled?\n     *\n     * @param logLevel is this level enabled?\n     */\n    protected boolean isLevelEnabled(int logLevel) {\n        // log level are numerically ordered so can use simple numeric\n        // comparison\n        return (logLevel >= currentLogLevel);\n    }\n\n    /** Are {@code trace} messages currently enabled? */\n    public boolean isTraceEnabled() {\n        return isLevelEnabled(LOG_LEVEL_TRACE);\n    }\n\n    /**\n     * A simple implementation which logs messages of level TRACE according\n     * to the format outlined above.\n     */\n    public void trace(String msg) {\n        log(LOG_LEVEL_TRACE, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * TRACE according to the format outlined above.\n     */\n    public void trace(String format, Object param1) {\n        formatAndLog(LOG_LEVEL_TRACE, format, param1, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * TRACE according to the format outlined above.\n     */\n    public void trace(String format, Object param1, Object param2) {\n        formatAndLog(LOG_LEVEL_TRACE, format, param1, param2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * TRACE according to the format outlined above.\n     */\n    public void trace(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_TRACE, format, argArray);\n    }\n\n    /** Log a message of level TRACE, including an exception. */\n    public void trace(String msg, Throwable t) {\n        log(LOG_LEVEL_TRACE, msg, t);\n    }\n\n    /** Are {@code debug} messages currently enabled? */\n    public boolean isDebugEnabled() {\n        return isLevelEnabled(LOG_LEVEL_DEBUG);\n    }\n\n    /**\n     * A simple implementation which logs messages of level DEBUG according\n     * to the format outlined above.\n     */\n    public void debug(String msg) {\n        log(LOG_LEVEL_DEBUG, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * DEBUG according to the format outlined above.\n     */\n    public void debug(String format, Object param1) {\n        formatAndLog(LOG_LEVEL_DEBUG, format, param1, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * DEBUG according to the format outlined above.\n     */\n    public void debug(String format, Object param1, Object param2) {\n        formatAndLog(LOG_LEVEL_DEBUG, format, param1, param2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * DEBUG according to the format outlined above.\n     */\n    public void debug(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_DEBUG, format, argArray);\n    }\n\n    /** Log a message of level DEBUG, including an exception. */\n    public void debug(String msg, Throwable t) {\n        log(LOG_LEVEL_DEBUG, msg, t);\n    }\n\n    /** Are {@code info} messages currently enabled? */\n    public boolean isInfoEnabled() {\n        return isLevelEnabled(LOG_LEVEL_INFO);\n    }\n\n    /**\n     * A simple implementation which logs messages of level INFO according\n     * to the format outlined above.\n     */\n    public void info(String msg) {\n        log(LOG_LEVEL_INFO, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * INFO according to the format outlined above.\n     */\n    public void info(String format, Object arg) {\n        formatAndLog(LOG_LEVEL_INFO, format, arg, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * INFO according to the format outlined above.\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        formatAndLog(LOG_LEVEL_INFO, format, arg1, arg2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * INFO according to the format outlined above.\n     */\n    public void info(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_INFO, format, argArray);\n    }\n\n    /** Log a message of level INFO, including an exception. */\n    public void info(String msg, Throwable t) {\n        log(LOG_LEVEL_INFO, msg, t);\n    }\n\n    /** Are {@code warn} messages currently enabled? */\n    public boolean isWarnEnabled() {\n        return isLevelEnabled(LOG_LEVEL_WARN);\n    }\n\n    /**\n     * A simple implementation which always logs messages of level WARN according\n     * to the format outlined above.\n     */\n    public void warn(String msg) {\n        log(LOG_LEVEL_WARN, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * WARN according to the format outlined above.\n     */\n    public void warn(String format, Object arg) {\n        formatAndLog(LOG_LEVEL_WARN, format, arg, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * WARN according to the format outlined above.\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        formatAndLog(LOG_LEVEL_WARN, format, arg1, arg2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * WARN according to the format outlined above.\n     */\n    public void warn(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_WARN, format, argArray);\n    }\n\n    /** Log a message of level WARN, including an exception. */\n    public void warn(String msg, Throwable t) {\n        log(LOG_LEVEL_WARN, msg, t);\n    }\n\n    /** Are {@code error} messages currently enabled? */\n    public boolean isErrorEnabled() {\n        return isLevelEnabled(LOG_LEVEL_ERROR);\n    }\n\n    /**\n     * A simple implementation which always logs messages of level ERROR according\n     * to the format outlined above.\n     */\n    public void error(String msg) {\n        log(LOG_LEVEL_ERROR, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * ERROR according to the format outlined above.\n     */\n    public void error(String format, Object arg) {\n        formatAndLog(LOG_LEVEL_ERROR, format, arg, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * ERROR according to the format outlined above.\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        formatAndLog(LOG_LEVEL_ERROR, format, arg1, arg2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * ERROR according to the format outlined above.\n     */\n    public void error(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_ERROR, format, argArray);\n    }\n\n    /** Log a message of level ERROR, including an exception. */\n    public void error(String msg, Throwable t) {\n        log(LOG_LEVEL_ERROR, msg, t);\n    }\n\n    public void log(LoggingEvent event) {\n        int levelInt = event.getLevel().toInt();\n\n        if (!isLevelEnabled(levelInt)) {\n            return;\n        }\n        FormattingTuple tp = MessageFormatter.arrayFormat(event.getMessage(), event.getArgumentArray(), event.getThrowable());\n        log(levelInt, tp.getMessage(), event.getThrowable());\n    }\n\n}\n","lineNo":356}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2016 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerAccessingThread;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.LoggerFactoryFriend;\n\npublic class SimpleLoggerMultithreadedInitializationTest {\n\n    final static int THREAD_COUNT = 4 + Runtime.getRuntime().availableProcessors() * 2;\n\n    private final AtomicLong eventCount = new AtomicLong(0);\n    private final PrintStream oldErr = System.err;\n    private final CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT + 1);\n\n    final int diff = new Random().nextInt(10000);\n    final String loggerName = this.getClass().getName();\n    StringPrintStream sps = new StringPrintStream(oldErr, true);\n\n    @Before\n    public void setup() {\n        System.out.println(\"THREAD_COUNT=\" + THREAD_COUNT);\n        System.setErr(sps);\n        System.setProperty(SimpleLogger.LOG_FILE_KEY, \"System.err\");\n        LoggerFactoryFriend.reset();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        LoggerFactoryFriend.reset();\n        System.clearProperty(SimpleLogger.LOG_FILE_KEY);\n        System.setErr(oldErr);\n    }\n\n    @Test\n    public void multiThreadedInitialization() throws InterruptedException, BrokenBarrierException {\n\n        @SuppressWarnings(\"unused\")\n        LoggerAccessingThread[] accessors = harness();\n\n        Logger logger = LoggerFactory.getLogger(loggerName + diff);\n        logger.info(\"hello\");\n        eventCount.getAndIncrement();\n\n        int NUM_LINES_IN_SLF4J_REPLAY_WARNING = 3;\n        \n        long expected = eventCount.get() + NUM_LINES_IN_SLF4J_REPLAY_WARNING;\n        int actual = sps.stringList.size();\n        assertTrue(expected + \" >= \" + actual, expected >= actual);\n        assertTrue(expected + \" < \" + actual + \" + 10\", expected < actual + 10);\n    }\n\n    private LoggerAccessingThread[] harness() throws InterruptedException, BrokenBarrierException {\n        final LoggerAccessingThread[] threads = new LoggerAccessingThread[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            LoggerAccessingThread simpleLoggerThread = new LoggerAccessingThread(barrier, i, eventCount);\n            threads[i] = simpleLoggerThread;\n            simpleLoggerThread.start();\n        }\n\n        barrier.await();\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            threads[i].join();\n        }\n        return threads;\n    }\n\n\n    static class StringPrintStream extends PrintStream {\n\n        public static final String LINE_SEP = System.getProperty(\"line.separator\");\n        PrintStream other;\n        boolean duplicate = false;\n\n        List<String> stringList = Collections.synchronizedList(new ArrayList<String>());\n\n        public StringPrintStream(PrintStream ps, boolean duplicate) {\n            super(ps);\n            other = ps;\n            this.duplicate = duplicate;\n        }\n\n        public StringPrintStream(PrintStream ps) {\n            this(ps, false);\n        }\n\n        public void print(String s) {\n            if (duplicate)\n                other.print(s);\n            stringList.add(s);\n        }\n\n        public void println(String s) {\n            if (duplicate)\n                other.println(s);\n            stringList.add(s);\n        }\n\n        public void println(Object o) {\n            if (duplicate)\n                other.println(o);\n            stringList.add(o.toString());\n        }\n    };\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2016 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerAccessingThread;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.LoggerFactoryFriend;\n\npublic class SimpleLoggerMultithreadedInitializationTest {\n\n    final static int THREAD_COUNT = 4 + Runtime.getRuntime().availableProcessors() * 2;\n\n    private final AtomicLong eventCount = new AtomicLong(0);\n    private final PrintStream oldErr = System.err;\n    private final CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT + 1);\n\n    final int diff = new Random().nextInt(10000);\n    final String loggerName = this.getClass().getName();\n    StringPrintStream sps = new StringPrintStream(oldErr, true);\n\n    @Before\n    public void setup() {\n        System.out.println(\"THREAD_COUNT=\" + THREAD_COUNT);\n        System.setErr(sps);\n        System.setProperty(SimpleLogger.LOG_FILE_KEY, \"System.err\");\n        LoggerFactoryFriend.reset();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        LoggerFactoryFriend.reset();\n        System.clearProperty(SimpleLogger.LOG_FILE_KEY);\n        System.setErr(oldErr);\n    }\n\n    @Test\n    public void multiThreadedInitialization() throws InterruptedException, BrokenBarrierException {\n\n        @SuppressWarnings(\"unused\")\n        LoggerAccessingThread[] accessors = harness();\n\n        Logger logger = LoggerFactory.getLogger(loggerName + diff);\n        logger.info(\"hello\");\n        eventCount.getAndIncrement();\n\n        int NUM_LINES_IN_SLF4J_REPLAY_WARNING = 3;\n        assertEquals(eventCount.get() + NUM_LINES_IN_SLF4J_REPLAY_WARNING, sps.stringList.size());\n    }\n\n    private LoggerAccessingThread[] harness() throws InterruptedException, BrokenBarrierException {\n        final LoggerAccessingThread[] threads = new LoggerAccessingThread[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            LoggerAccessingThread simpleLoggerThread = new LoggerAccessingThread(barrier, i, eventCount);\n            threads[i] = simpleLoggerThread;\n            simpleLoggerThread.start();\n        }\n\n        barrier.await();\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            threads[i].join();\n        }\n        return threads;\n    }\n\n\n    static class StringPrintStream extends PrintStream {\n\n        public static final String LINE_SEP = System.getProperty(\"line.separator\");\n        PrintStream other;\n        boolean duplicate = false;\n\n        List<String> stringList = Collections.synchronizedList(new ArrayList<String>());\n\n        public StringPrintStream(PrintStream ps, boolean duplicate) {\n            super(ps);\n            other = ps;\n            this.duplicate = duplicate;\n        }\n\n        public StringPrintStream(PrintStream ps) {\n            this(ps, false);\n        }\n\n        public void print(String s) {\n            if (duplicate)\n                other.print(s);\n            stringList.add(s);\n        }\n\n        public void println(String s) {\n            if (duplicate)\n                other.println(s);\n            stringList.add(s);\n        }\n\n        public void println(Object o) {\n            if (duplicate)\n                other.println(o);\n            stringList.add(o.toString());\n        }\n    };\n\n}\n","lineNo":85}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2016 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerAccessingThread;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.LoggerFactoryFriend;\n\npublic class SimpleLoggerMultithreadedInitializationTest {\n\n    final static int THREAD_COUNT = 4 + Runtime.getRuntime().availableProcessors() * 2;\n\n    private final AtomicLong eventCount = new AtomicLong(0);\n    private final PrintStream oldErr = System.err;\n    private final CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT + 1);\n\n    final int diff = new Random().nextInt(10000);\n    final String loggerName = this.getClass().getName();\n    StringPrintStream sps = new StringPrintStream(oldErr, true);\n\n    @Before\n    public void setup() {\n        System.out.println(\"THREAD_COUNT=\" + THREAD_COUNT);\n        System.setErr(sps);\n        System.setProperty(SimpleLogger.LOG_FILE_KEY, \"System.err\");\n        LoggerFactoryFriend.reset();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        LoggerFactoryFriend.reset();\n        System.clearProperty(SimpleLogger.LOG_FILE_KEY);\n        System.setErr(oldErr);\n    }\n\n    @Test\n    public void multiThreadedInitialization() throws InterruptedException, BrokenBarrierException {\n\n        @SuppressWarnings(\"unused\")\n        LoggerAccessingThread[] accessors = harness();\n\n        Logger logger = LoggerFactory.getLogger(loggerName + diff);\n        logger.info(\"hello\");\n        eventCount.getAndIncrement();\n\n        int NUM_LINES_IN_SLF4J_REPLAY_WARNING = 3;\n        \n        long expected = eventCount.get() + NUM_LINES_IN_SLF4J_REPLAY_WARNING;\n        int actual = sps.stringList.size();\n        assertTrue(expected + \" >= \" + actual, expected >= actual);\n        assertTrue(expected + \" < \" + actual + \" + 10\", expected < actual + 10);\n    }\n\n    private LoggerAccessingThread[] harness() throws InterruptedException, BrokenBarrierException {\n        final LoggerAccessingThread[] threads = new LoggerAccessingThread[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            LoggerAccessingThread simpleLoggerThread = new LoggerAccessingThread(barrier, i, eventCount);\n            threads[i] = simpleLoggerThread;\n            simpleLoggerThread.start();\n        }\n\n        barrier.await();\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            threads[i].join();\n        }\n        return threads;\n    }\n\n\n    static class StringPrintStream extends PrintStream {\n\n        public static final String LINE_SEP = System.getProperty(\"line.separator\");\n        PrintStream other;\n        boolean duplicate = false;\n\n        List<String> stringList = Collections.synchronizedList(new ArrayList<String>());\n\n        public StringPrintStream(PrintStream ps, boolean duplicate) {\n            super(ps);\n            other = ps;\n            this.duplicate = duplicate;\n        }\n\n        public StringPrintStream(PrintStream ps) {\n            this(ps, false);\n        }\n\n        public void print(String s) {\n            if (duplicate)\n                other.print(s);\n            stringList.add(s);\n        }\n\n        public void println(String s) {\n            if (duplicate)\n                other.println(s);\n            stringList.add(s);\n        }\n\n        public void println(Object o) {\n            if (duplicate)\n                other.println(o);\n            stringList.add(o.toString());\n        }\n    };\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2016 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerAccessingThread;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.LoggerFactoryFriend;\n\npublic class SimpleLoggerMultithreadedInitializationTest {\n\n    final static int THREAD_COUNT = 4 + Runtime.getRuntime().availableProcessors() * 2;\n\n    private final AtomicLong eventCount = new AtomicLong(0);\n    private final PrintStream oldErr = System.err;\n    private final CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT + 1);\n\n    final int diff = new Random().nextInt(10000);\n    final String loggerName = this.getClass().getName();\n    StringPrintStream sps = new StringPrintStream(oldErr, true);\n\n    @Before\n    public void setup() {\n        System.out.println(\"THREAD_COUNT=\" + THREAD_COUNT);\n        System.setErr(sps);\n        System.setProperty(SimpleLogger.LOG_FILE_KEY, \"System.err\");\n        LoggerFactoryFriend.reset();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        LoggerFactoryFriend.reset();\n        System.clearProperty(SimpleLogger.LOG_FILE_KEY);\n        System.setErr(oldErr);\n    }\n\n    @Test\n    public void multiThreadedInitialization() throws InterruptedException, BrokenBarrierException {\n\n        @SuppressWarnings(\"unused\")\n        LoggerAccessingThread[] accessors = harness();\n\n        Logger logger = LoggerFactory.getLogger(loggerName + diff);\n        logger.info(\"hello\");\n        eventCount.getAndIncrement();\n\n        int NUM_LINES_IN_SLF4J_REPLAY_WARNING = 3;\n        assertEquals(eventCount.get() + NUM_LINES_IN_SLF4J_REPLAY_WARNING, sps.stringList.size());\n    }\n\n    private LoggerAccessingThread[] harness() throws InterruptedException, BrokenBarrierException {\n        final LoggerAccessingThread[] threads = new LoggerAccessingThread[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            LoggerAccessingThread simpleLoggerThread = new LoggerAccessingThread(barrier, i, eventCount);\n            threads[i] = simpleLoggerThread;\n            simpleLoggerThread.start();\n        }\n\n        barrier.await();\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            threads[i].join();\n        }\n        return threads;\n    }\n\n\n    static class StringPrintStream extends PrintStream {\n\n        public static final String LINE_SEP = System.getProperty(\"line.separator\");\n        PrintStream other;\n        boolean duplicate = false;\n\n        List<String> stringList = Collections.synchronizedList(new ArrayList<String>());\n\n        public StringPrintStream(PrintStream ps, boolean duplicate) {\n            super(ps);\n            other = ps;\n            this.duplicate = duplicate;\n        }\n\n        public StringPrintStream(PrintStream ps) {\n            this(ps, false);\n        }\n\n        public void print(String s) {\n            if (duplicate)\n                other.print(s);\n            stringList.add(s);\n        }\n\n        public void println(String s) {\n            if (duplicate)\n                other.println(s);\n            stringList.add(s);\n        }\n\n        public void println(Object o) {\n            if (duplicate)\n                other.println(o);\n            stringList.add(o.toString());\n        }\n    };\n\n}\n","lineNo":86}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.slf4j.event.LoggingEventAware;\nimport org.slf4j.event.SubstituteLoggingEvent;\nimport org.slf4j.helpers.NOPLoggerFactory;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.helpers.SubstituteLoggerFactory;\nimport org.slf4j.helpers.Util;\nimport org.slf4j.impl.StaticLoggerBinder;\n\n/**\n * The <code>LoggerFactory<\/code> is a utility class producing Loggers for\n * various logging APIs, most notably for log4j, logback and JDK 1.4 logging.\n * Other implementations such as {@link org.slf4j.impl.NOPLogger NOPLogger} and\n * {@link org.slf4j.impl.SimpleLogger SimpleLogger} are also supported.\n * <p/>\n * <p/>\n * <code>LoggerFactory<\/code> is essentially a wrapper around an\n * {@link ILoggerFactory} instance bound with <code>LoggerFactory<\/code> at\n * compile time.\n * <p/>\n * <p/>\n * Please note that all methods in <code>LoggerFactory<\/code> are static.\n *\n *\n * @author Alexander Dorokhine\n * @author Robert Elliot\n * @author Ceki G&uuml;lc&uuml;\n *\n */\npublic final class LoggerFactory {\n\n    static final String CODES_PREFIX = \"http://www.slf4j.org/codes.html\";\n\n    static final String NO_STATICLOGGERBINDER_URL = CODES_PREFIX + \"#StaticLoggerBinder\";\n    static final String MULTIPLE_BINDINGS_URL = CODES_PREFIX + \"#multiple_bindings\";\n    static final String NULL_LF_URL = CODES_PREFIX + \"#null_LF\";\n    static final String VERSION_MISMATCH = CODES_PREFIX + \"#version_mismatch\";\n    static final String SUBSTITUTE_LOGGER_URL = CODES_PREFIX + \"#substituteLogger\";\n    static final String LOGGER_NAME_MISMATCH_URL = CODES_PREFIX + \"#loggerNameMismatch\";\n\n    static final String UNSUCCESSFUL_INIT_URL = CODES_PREFIX + \"#unsuccessfulInit\";\n    static final String UNSUCCESSFUL_INIT_MSG = \"org.slf4j.LoggerFactory could not be successfully initialized. See also \" + UNSUCCESSFUL_INIT_URL;\n\n    static final int UNINITIALIZED = 0;\n    static final int ONGOING_INITIALIZATION = 1;\n    static final int FAILED_INITIALIZATION = 2;\n    static final int SUCCESSFUL_INITIALIZATION = 3;\n    static final int NOP_FALLBACK_INITIALIZATION = 4;\n\n    static int INITIALIZATION_STATE = UNINITIALIZED;\n    static SubstituteLoggerFactory SUBST_FACTORY = new SubstituteLoggerFactory();\n    static NOPLoggerFactory NOP_FALLBACK_FACTORY = new NOPLoggerFactory();\n\n    // Support for detecting mismatched logger names.\n    static final String DETECT_LOGGER_NAME_MISMATCH_PROPERTY = \"slf4j.detectLoggerNameMismatch\";\n    static final String JAVA_VENDOR_PROPERTY = \"java.vendor.url\";\n\n    static boolean DETECT_LOGGER_NAME_MISMATCH = Util.safeGetBooleanSystemProperty(DETECT_LOGGER_NAME_MISMATCH_PROPERTY);\n\n    /**\n     * It is LoggerFactory's responsibility to track version changes and manage\n     * the compatibility list.\n     * <p/>\n     * <p/>\n     * It is assumed that all versions in the 1.6 are mutually compatible.\n     */\n    static private final String[] API_COMPATIBILITY_LIST = new String[] { \"1.6\", \"1.7\" };\n\n    // private constructor prevents instantiation\n    private LoggerFactory() {\n    }\n\n    /**\n     * Force LoggerFactory to consider itself uninitialized.\n     * <p/>\n     * <p/>\n     * This method is intended to be called by classes (in the same package) for\n     * testing purposes. This method is internal. It can be modified, renamed or\n     * removed at any time without notice.\n     * <p/>\n     * <p/>\n     * You are strongly discouraged from calling this method in production code.\n     */\n    static void reset() {\n        INITIALIZATION_STATE = UNINITIALIZED;\n        SUBST_FACTORY = new SubstituteLoggerFactory();\n    }\n\n    private final static void performInitialization() {\n        bind();\n        if (INITIALIZATION_STATE == SUCCESSFUL_INITIALIZATION) {\n            versionSanityCheck();\n        }\n    }\n\n    private static boolean messageContainsOrgSlf4jImplStaticLoggerBinder(String msg) {\n        if (msg == null)\n            return false;\n        if (msg.contains(\"org/slf4j/impl/StaticLoggerBinder\"))\n            return true;\n        if (msg.contains(\"org.slf4j.impl.StaticLoggerBinder\"))\n            return true;\n        return false;\n    }\n\n    private final static void bind() {\n        try {\n            Set<URL> staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();\n            reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);\n            // the next line does the binding\n            StaticLoggerBinder.getSingleton();\n            INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;\n            reportActualBinding(staticLoggerBinderPathSet);\n            fixSubstitutedLoggers();\n            playRecordedEvents();\n        } catch (NoClassDefFoundError ncde) {\n            String msg = ncde.getMessage();\n            if (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) {\n                INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;\n                Util.report(\"Failed to load class \\\"org.slf4j.impl.StaticLoggerBinder\\\".\");\n                Util.report(\"Defaulting to no-operation (NOP) logger implementation\");\n                Util.report(\"See \" + NO_STATICLOGGERBINDER_URL + \" for further details.\");\n            } else {\n                failedBinding(ncde);\n                throw ncde;\n            }\n        } catch (java.lang.NoSuchMethodError nsme) {\n            String msg = nsme.getMessage();\n            if (msg != null && msg.contains(\"org.slf4j.impl.StaticLoggerBinder.getSingleton()\")) {\n                INITIALIZATION_STATE = FAILED_INITIALIZATION;\n                Util.report(\"slf4j-api 1.6.x (or later) is incompatible with this binding.\");\n                Util.report(\"Your binding is version 1.5.5 or earlier.\");\n                Util.report(\"Upgrade your binding to version 1.6.x.\");\n            }\n            throw nsme;\n        } catch (Exception e) {\n            failedBinding(e);\n            throw new IllegalStateException(\"Unexpected initialization failure\", e);\n        }\n    }\n\n    static void failedBinding(Throwable t) {\n        INITIALIZATION_STATE = FAILED_INITIALIZATION;\n        Util.report(\"Failed to instantiate SLF4J LoggerFactory\", t);\n    }\n\n    private static void playRecordedEvents() {\n        List<SubstituteLoggingEvent> events = SUBST_FACTORY.getEventList();\n\n        for (SubstituteLoggingEvent event : events) {\n            SubstituteLogger substLogger = event.getLogger();\n            if (substLogger.isDelegateEventAware()) {\n                substLogger.log(event);\n            }\n        }\n    }\n\n    private final static void fixSubstitutedLoggers() {\n        List<SubstituteLogger> loggers = SUBST_FACTORY.getLoggers();\n\n        if (loggers.isEmpty()) {\n            return;\n        }\n\n        boolean substitutionWarningEmmitted = false;\n        for (SubstituteLogger subLogger : loggers) {\n            Logger logger = getLogger(subLogger.getName());\n            subLogger.setDelegate(logger);\n\n            if (!isEventAware(logger)) {\n                if (!substitutionWarningEmmitted) {\n                    emitSubstitutionWarning();\n                    substitutionWarningEmmitted = true;\n                }\n                Util.report(subLogger.getName());\n            }\n        }\n\n        SUBST_FACTORY.clear();\n    }\n\n    private static boolean isEventAware(Logger logger) {\n        return logger instanceof LoggingEventAware;\n    }\n\n    private static void emitSubstitutionWarning() {\n        Util.report(\"The following set of substitute loggers may have been accessed\");\n        Util.report(\"during the initialization phase. Logging calls during this\");\n        Util.report(\"phase were not honored. However, subsequent logging calls to these\");\n        Util.report(\"loggers will work as normally expected.\");\n        Util.report(\"See also \" + SUBSTITUTE_LOGGER_URL);\n    }\n\n    private final static void versionSanityCheck() {\n        try {\n            String requested = StaticLoggerBinder.REQUESTED_API_VERSION;\n\n            boolean match = false;\n            for (String aAPI_COMPATIBILITY_LIST : API_COMPATIBILITY_LIST) {\n                if (requested.startsWith(aAPI_COMPATIBILITY_LIST)) {\n                    match = true;\n                }\n            }\n            if (!match) {\n                Util.report(\"The requested version \" + requested + \" by your slf4j binding is not compatible with \"\n                                + Arrays.asList(API_COMPATIBILITY_LIST).toString());\n                Util.report(\"See \" + VERSION_MISMATCH + \" for further details.\");\n            }\n        } catch (java.lang.NoSuchFieldError nsfe) {\n            // given our large user base and SLF4J's commitment to backward\n            // compatibility, we cannot cry here. Only for implementations\n            // which willingly declare a REQUESTED_API_VERSION field do we\n            // emit compatibility warnings.\n        } catch (Throwable e) {\n            // we should never reach here\n            Util.report(\"Unexpected problem occured during version sanity check\", e);\n        }\n    }\n\n    // We need to use the name of the StaticLoggerBinder class, but we can't reference\n    // the class itself.\n    private static String STATIC_LOGGER_BINDER_PATH = \"org/slf4j/impl/StaticLoggerBinder.class\";\n\n    static Set<URL> findPossibleStaticLoggerBinderPathSet() {\n        // use Set instead of list in order to deal with bug #138\n        // LinkedHashSet appropriate here because it preserves insertion order during iteration\n        Set<URL> staticLoggerBinderPathSet = new LinkedHashSet<URL>();\n        try {\n            ClassLoader loggerFactoryClassLoader = LoggerFactory.class.getClassLoader();\n            Enumeration<URL> paths;\n            if (loggerFactoryClassLoader == null) {\n                paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);\n            } else {\n                paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);\n            }\n            while (paths.hasMoreElements()) {\n                URL path = paths.nextElement();\n                staticLoggerBinderPathSet.add(path);\n            }\n        } catch (IOException ioe) {\n            Util.report(\"Error getting resources from path\", ioe);\n        }\n        return staticLoggerBinderPathSet;\n    }\n\n    private static boolean isAmbiguousStaticLoggerBinderPathSet(Set<URL> staticLoggerBinderPathSet) {\n        return staticLoggerBinderPathSet.size() > 1;\n    }\n\n    /**\n     * Prints a warning message on the console if multiple bindings were found on the class path.\n     * No reporting is done otherwise.\n     *\n     */\n    private static void reportMultipleBindingAmbiguity(Set<URL> staticLoggerBinderPathSet) {\n        if (isAndroid()) {\n            // skip check under android, see also http://jira.qos.ch/browse/SLF4J-328\n            return;\n        }\n\n        if (isAmbiguousStaticLoggerBinderPathSet(staticLoggerBinderPathSet)) {\n            Util.report(\"Class path contains multiple SLF4J bindings.\");\n            for (URL path : staticLoggerBinderPathSet) {\n                Util.report(\"Found binding in [\" + path + \"]\");\n            }\n            Util.report(\"See \" + MULTIPLE_BINDINGS_URL + \" for an explanation.\");\n        }\n    }\n\n    private static boolean isAndroid() {\n        String vendor = Util.safeGetSystemProperty(JAVA_VENDOR_PROPERTY);\n        if (vendor == null)\n            return false;\n        return vendor.toLowerCase().contains(\"android\");\n    }\n\n    private static void reportActualBinding(Set<URL> staticLoggerBinderPathSet) {\n        if (isAmbiguousStaticLoggerBinderPathSet(staticLoggerBinderPathSet)) {\n            Util.report(\"Actual binding is of type [\" + StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr() + \"]\");\n        }\n    }\n\n    /**\n     * Return a logger named according to the name parameter using the statically\n     * bound {@link ILoggerFactory} instance.\n     *\n     * @param name The name of the logger.\n     * @return logger\n     */\n    public static Logger getLogger(String name) {\n        ILoggerFactory iLoggerFactory = getILoggerFactory();\n        return iLoggerFactory.getLogger(name);\n    }\n\n    /**\n     * Return a logger named corresponding to the class passed as parameter, using\n     * the statically bound {@link ILoggerFactory} instance.\n     *\n     * <p>In case the the <code>clazz<\/code> parameter differs from the name of\n     * the caller as computed internally by SLF4J, a logger name mismatch warning will be \n     * printed but only if the <code>slf4j.detectLoggerNameMismatch<\/code> system property is \n     * set to true. By default, this property is not set and no warnings will be printed\n     * even in case of a logger name mismatch.\n     * \n     * @param clazz the returned logger will be named after clazz\n     * @return logger\n     *\n     *\n     * @see <a href=\"http://www.slf4j.org/codes.html#loggerNameMismatch\">Detected logger name mismatch<\/a> \n     */\n    public static Logger getLogger(Class<?> clazz) {\n        Logger logger = getLogger(clazz.getName());\n        if (DETECT_LOGGER_NAME_MISMATCH) {\n            Class<?> autoComputedCallingClass = Util.getCallingClass();\n            if (autoComputedCallingClass != null && nonMatchingClasses(clazz, autoComputedCallingClass)) {\n                Util.report(String.format(\"Detected logger name mismatch. Given name: \\\"%s\\\"; computed name: \\\"%s\\\".\", logger.getName(),\n                                autoComputedCallingClass.getName()));\n                Util.report(\"See \" + LOGGER_NAME_MISMATCH_URL + \" for an explanation\");\n            }\n        }\n        return logger;\n    }\n\n    private static boolean nonMatchingClasses(Class<?> clazz, Class<?> autoComputedCallingClass) {\n        return !autoComputedCallingClass.isAssignableFrom(clazz);\n    }\n\n    /**\n     * Return the {@link ILoggerFactory} instance in use.\n     * <p/>\n     * <p/>\n     * ILoggerFactory instance is bound with this class at compile time.\n     *\n     * @return the ILoggerFactory instance in use\n     */\n    public static ILoggerFactory getILoggerFactory() {\n        if (INITIALIZATION_STATE == UNINITIALIZED) {\n            synchronized (LoggerFactory.class) {\n                if (INITIALIZATION_STATE == UNINITIALIZED) {\n                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;\n                    performInitialization();\n                }\n            }\n        }\n        switch (INITIALIZATION_STATE) {\n        case SUCCESSFUL_INITIALIZATION:\n            return StaticLoggerBinder.getSingleton().getLoggerFactory();\n        case NOP_FALLBACK_INITIALIZATION:\n            return NOP_FALLBACK_FACTORY;\n        case FAILED_INITIALIZATION:\n            throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);\n        case ONGOING_INITIALIZATION:\n            // support re-entrant behavior.\n            // See also http://jira.qos.ch/browse/SLF4J-97\n            return SUBST_FACTORY;\n        }\n        throw new IllegalStateException(\"Unreachable code\");\n    }\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.slf4j.helpers.NOPLoggerFactory;\nimport org.slf4j.helpers.SubstituteLogger;\nimport org.slf4j.helpers.SubstituteLoggerFactory;\nimport org.slf4j.helpers.Util;\nimport org.slf4j.impl.StaticLoggerBinder;\n\n/**\n * The <code>LoggerFactory<\/code> is a utility class producing Loggers for\n * various logging APIs, most notably for log4j, logback and JDK 1.4 logging.\n * Other implementations such as {@link org.slf4j.impl.NOPLogger NOPLogger} and\n * {@link org.slf4j.impl.SimpleLogger SimpleLogger} are also supported.\n * <p/>\n * <p/>\n * <code>LoggerFactory<\/code> is essentially a wrapper around an\n * {@link ILoggerFactory} instance bound with <code>LoggerFactory<\/code> at\n * compile time.\n * <p/>\n * <p/>\n * Please note that all methods in <code>LoggerFactory<\/code> are static.\n *\n *\n * @author Alexander Dorokhine\n * @author Robert Elliot\n * @author Ceki G&uuml;lc&uuml;\n *\n */\npublic final class LoggerFactory {\n\n    static final String CODES_PREFIX = \"http://www.slf4j.org/codes.html\";\n\n    static final String NO_STATICLOGGERBINDER_URL = CODES_PREFIX + \"#StaticLoggerBinder\";\n    static final String MULTIPLE_BINDINGS_URL = CODES_PREFIX + \"#multiple_bindings\";\n    static final String NULL_LF_URL = CODES_PREFIX + \"#null_LF\";\n    static final String VERSION_MISMATCH = CODES_PREFIX + \"#version_mismatch\";\n    static final String SUBSTITUTE_LOGGER_URL = CODES_PREFIX + \"#substituteLogger\";\n    static final String LOGGER_NAME_MISMATCH_URL = CODES_PREFIX + \"#loggerNameMismatch\";\n\n    static final String UNSUCCESSFUL_INIT_URL = CODES_PREFIX + \"#unsuccessfulInit\";\n    static final String UNSUCCESSFUL_INIT_MSG = \"org.slf4j.LoggerFactory could not be successfully initialized. See also \" + UNSUCCESSFUL_INIT_URL;\n\n    static final int UNINITIALIZED = 0;\n    static final int ONGOING_INITIALIZATION = 1;\n    static final int FAILED_INITIALIZATION = 2;\n    static final int SUCCESSFUL_INITIALIZATION = 3;\n    static final int NOP_FALLBACK_INITIALIZATION = 4;\n\n    static int INITIALIZATION_STATE = UNINITIALIZED;\n    static SubstituteLoggerFactory TEMP_FACTORY = new SubstituteLoggerFactory();\n    static NOPLoggerFactory NOP_FALLBACK_FACTORY = new NOPLoggerFactory();\n\n    // Support for detecting mismatched logger names.\n    static final String DETECT_LOGGER_NAME_MISMATCH_PROPERTY = \"slf4j.detectLoggerNameMismatch\";\n    static final String JAVA_VENDOR_PROPERTY = \"java.vendor.url\";\n        \n    static boolean DETECT_LOGGER_NAME_MISMATCH = Util.safeGetBooleanSystemProperty(DETECT_LOGGER_NAME_MISMATCH_PROPERTY);\n\n    /**\n     * It is LoggerFactory's responsibility to track version changes and manage\n     * the compatibility list.\n     * <p/>\n     * <p/>\n     * It is assumed that all versions in the 1.6 are mutually compatible.\n     */\n    static private final String[] API_COMPATIBILITY_LIST = new String[] { \"1.6\", \"1.7\" };\n\n    // private constructor prevents instantiation\n    private LoggerFactory() {\n    }\n\n    /**\n     * Force LoggerFactory to consider itself uninitialized.\n     * <p/>\n     * <p/>\n     * This method is intended to be called by classes (in the same package) for\n     * testing purposes. This method is internal. It can be modified, renamed or\n     * removed at any time without notice.\n     * <p/>\n     * <p/>\n     * You are strongly discouraged from calling this method in production code.\n     */\n    static void reset() {\n        INITIALIZATION_STATE = UNINITIALIZED;\n        TEMP_FACTORY = new SubstituteLoggerFactory();\n    }\n\n    private final static void performInitialization() {\n        bind();\n        if (INITIALIZATION_STATE == SUCCESSFUL_INITIALIZATION) {\n            versionSanityCheck();\n        }\n    }\n\n    private static boolean messageContainsOrgSlf4jImplStaticLoggerBinder(String msg) {\n        if (msg == null)\n            return false;\n        if (msg.contains(\"org/slf4j/impl/StaticLoggerBinder\"))\n            return true;\n        if (msg.contains(\"org.slf4j.impl.StaticLoggerBinder\"))\n            return true;\n        return false;\n    }\n\n    private final static void bind() {\n        try {\n            Set<URL> staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();\n            reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);\n            // the next line does the binding\n            StaticLoggerBinder.getSingleton();\n            INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;\n            reportActualBinding(staticLoggerBinderPathSet);\n            fixSubstitutedLoggers();\n        } catch (NoClassDefFoundError ncde) {\n            String msg = ncde.getMessage();\n            if (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) {\n                INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;\n                Util.report(\"Failed to load class \\\"org.slf4j.impl.StaticLoggerBinder\\\".\");\n                Util.report(\"Defaulting to no-operation (NOP) logger implementation\");\n                Util.report(\"See \" + NO_STATICLOGGERBINDER_URL + \" for further details.\");\n            } else {\n                failedBinding(ncde);\n                throw ncde;\n            }\n        } catch (java.lang.NoSuchMethodError nsme) {\n            String msg = nsme.getMessage();\n            if (msg != null && msg.contains(\"org.slf4j.impl.StaticLoggerBinder.getSingleton()\")) {\n                INITIALIZATION_STATE = FAILED_INITIALIZATION;\n                Util.report(\"slf4j-api 1.6.x (or later) is incompatible with this binding.\");\n                Util.report(\"Your binding is version 1.5.5 or earlier.\");\n                Util.report(\"Upgrade your binding to version 1.6.x.\");\n            }\n            throw nsme;\n        } catch (Exception e) {\n            failedBinding(e);\n            throw new IllegalStateException(\"Unexpected initialization failure\", e);\n        }\n    }\n\n    static void failedBinding(Throwable t) {\n        INITIALIZATION_STATE = FAILED_INITIALIZATION;\n        Util.report(\"Failed to instantiate SLF4J LoggerFactory\", t);\n    }\n\n    private final static void fixSubstitutedLoggers() {\n        List<SubstituteLogger> loggers = TEMP_FACTORY.getLoggers();\n\n        if (loggers.isEmpty()) {\n            return;\n        }\n\n        Util.report(\"The following set of substitute loggers may have been accessed\");\n        Util.report(\"during the initialization phase. Logging calls during this\");\n        Util.report(\"phase were not honored. However, subsequent logging calls to these\");\n        Util.report(\"loggers will work as normally expected.\");\n        Util.report(\"See also \" + SUBSTITUTE_LOGGER_URL);\n        for (SubstituteLogger subLogger : loggers) {\n            subLogger.setDelegate(getLogger(subLogger.getName()));\n            Util.report(subLogger.getName());\n        }\n\n        TEMP_FACTORY.clear();\n    }\n\n    private final static void versionSanityCheck() {\n        try {\n            String requested = StaticLoggerBinder.REQUESTED_API_VERSION;\n\n            boolean match = false;\n            for (String aAPI_COMPATIBILITY_LIST : API_COMPATIBILITY_LIST) {\n                if (requested.startsWith(aAPI_COMPATIBILITY_LIST)) {\n                    match = true;\n                }\n            }\n            if (!match) {\n                Util.report(\"The requested version \" + requested + \" by your slf4j binding is not compatible with \"\n                                + Arrays.asList(API_COMPATIBILITY_LIST).toString());\n                Util.report(\"See \" + VERSION_MISMATCH + \" for further details.\");\n            }\n        } catch (java.lang.NoSuchFieldError nsfe) {\n            // given our large user base and SLF4J's commitment to backward\n            // compatibility, we cannot cry here. Only for implementations\n            // which willingly declare a REQUESTED_API_VERSION field do we\n            // emit compatibility warnings.\n        } catch (Throwable e) {\n            // we should never reach here\n            Util.report(\"Unexpected problem occured during version sanity check\", e);\n        }\n    }\n\n    // We need to use the name of the StaticLoggerBinder class, but we can't reference\n    // the class itself.\n    private static String STATIC_LOGGER_BINDER_PATH = \"org/slf4j/impl/StaticLoggerBinder.class\";\n\n    static Set<URL> findPossibleStaticLoggerBinderPathSet() {\n        // use Set instead of list in order to deal with bug #138\n        // LinkedHashSet appropriate here because it preserves insertion order during iteration\n        Set<URL> staticLoggerBinderPathSet = new LinkedHashSet<URL>();\n        try {\n            ClassLoader loggerFactoryClassLoader = LoggerFactory.class.getClassLoader();\n            Enumeration<URL> paths;\n            if (loggerFactoryClassLoader == null) {\n                paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);\n            } else {\n                paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);\n            }\n            while (paths.hasMoreElements()) {\n                URL path = paths.nextElement();\n                staticLoggerBinderPathSet.add(path);\n            }\n        } catch (IOException ioe) {\n            Util.report(\"Error getting resources from path\", ioe);\n        }\n        return staticLoggerBinderPathSet;\n    }\n\n    private static boolean isAmbiguousStaticLoggerBinderPathSet(Set<URL> staticLoggerBinderPathSet) {\n        return staticLoggerBinderPathSet.size() > 1;\n    }\n\n    /**\n     * Prints a warning message on the console if multiple bindings were found on the class path.\n     * No reporting is done otherwise.\n     *\n     */\n    private static void reportMultipleBindingAmbiguity(Set<URL> staticLoggerBinderPathSet) {\n        if(isAndroid()) {\n            // skip check under android, see also http://jira.qos.ch/browse/SLF4J-328\n            return;\n        }\n        \n        if (isAmbiguousStaticLoggerBinderPathSet(staticLoggerBinderPathSet)) {\n            Util.report(\"Class path contains multiple SLF4J bindings.\");\n            for (URL path : staticLoggerBinderPathSet) {\n                Util.report(\"Found binding in [\" + path + \"]\");\n            }\n            Util.report(\"See \" + MULTIPLE_BINDINGS_URL + \" for an explanation.\");\n        }\n    }\n\n    private static boolean isAndroid() {\n        String vendor = Util.safeGetSystemProperty(JAVA_VENDOR_PROPERTY);\n        if(vendor == null)\n            return false;\n        return vendor.toLowerCase().contains(\"android\");\n    }\n\n    private static void reportActualBinding(Set<URL> staticLoggerBinderPathSet) {\n        if (isAmbiguousStaticLoggerBinderPathSet(staticLoggerBinderPathSet)) {\n            Util.report(\"Actual binding is of type [\" + StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr() + \"]\");\n        }\n    }\n\n    /**\n     * Return a logger named according to the name parameter using the statically\n     * bound {@link ILoggerFactory} instance.\n     *\n     * @param name The name of the logger.\n     * @return logger\n     */\n    public static Logger getLogger(String name) {\n        ILoggerFactory iLoggerFactory = getILoggerFactory();\n        return iLoggerFactory.getLogger(name);\n    }\n\n    /**\n     * Return a logger named corresponding to the class passed as parameter, using\n     * the statically bound {@link ILoggerFactory} instance.\n     *\n     * <p>In case the the <code>clazz<\/code> parameter differs from the name of\n     * the caller as computed internally by SLF4J, a logger name mismatch warning will be \n     * printed but only if the <code>slf4j.detectLoggerNameMismatch<\/code> system property is \n     * set to true. By default, this property is not set and no warnings will be printed\n     * even in case of a logger name mismatch.\n     * \n     * @param clazz the returned logger will be named after clazz\n     * @return logger\n     *\n     *\n     * @see <a href=\"http://www.slf4j.org/codes.html#loggerNameMismatch\">Detected logger name mismatch<\/a> \n     */\n    public static Logger getLogger(Class<?> clazz) {\n        Logger logger = getLogger(clazz.getName());\n        if (DETECT_LOGGER_NAME_MISMATCH) {\n            Class<?> autoComputedCallingClass = Util.getCallingClass();\n            if (autoComputedCallingClass != null && nonMatchingClasses(clazz, autoComputedCallingClass)) {\n                Util.report(String.format(\"Detected logger name mismatch. Given name: \\\"%s\\\"; computed name: \\\"%s\\\".\", logger.getName(),\n                                autoComputedCallingClass.getName()));\n                Util.report(\"See \" + LOGGER_NAME_MISMATCH_URL + \" for an explanation\");\n            }\n        }\n        return logger;\n    }\n\n    private static boolean nonMatchingClasses(Class<?> clazz, Class<?> autoComputedCallingClass) {\n        return !autoComputedCallingClass.isAssignableFrom(clazz);\n    }\n\n    /**\n     * Return the {@link ILoggerFactory} instance in use.\n     * <p/>\n     * <p/>\n     * ILoggerFactory instance is bound with this class at compile time.\n     *\n     * @return the ILoggerFactory instance in use\n     */\n    public static ILoggerFactory getILoggerFactory() {\n        if (INITIALIZATION_STATE == UNINITIALIZED) {\n            synchronized (LoggerFactory.class) {\n                if (INITIALIZATION_STATE == UNINITIALIZED) {\n                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;\n                    performInitialization();\n                }\n            }\n        }\n        switch (INITIALIZATION_STATE) {\n        case SUCCESSFUL_INITIALIZATION:\n            return StaticLoggerBinder.getSingleton().getLoggerFactory();\n        case NOP_FALLBACK_INITIALIZATION:\n            return NOP_FALLBACK_FACTORY;\n        case FAILED_INITIALIZATION:\n            throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);\n        case ONGOING_INITIALIZATION:\n            // support re-entrant behavior.\n            // See also http://jira.qos.ch/browse/SLF4J-97\n            return TEMP_FACTORY;\n        }\n        throw new IllegalStateException(\"Unreachable code\");\n    }\n}\n","lineNo":200}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport java.text.MessageFormat;\nimport java.util.HashMap;\nimport java.util.Map;\n\n// contributors: lizongbo: proposed special treatment of array parameter values\n// Joern Huxhorn: pointed out double[] omission, suggested deep array copy\n/**\n * Formats messages according to very simple substitution rules. Substitutions\n * can be made 1, 2 or more arguments.\n * \n * <p>\n * For example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Hi {}.&quot;, &quot;there&quot;)\n * <\/pre>\n * \n * will return the string \"Hi there.\".\n * <p>\n * The {} pair is called the <em>formatting anchor<\/em>. It serves to designate\n * the location where arguments need to be substituted within the message\n * pattern.\n * <p>\n * In case your message contains the '{' or the '}' character, you do not have\n * to do anything special unless the '}' character immediately follows '{'. For\n * example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Set {1,2,3} is not equal to {}.&quot;, &quot;1,2&quot;);\n * <\/pre>\n * \n * will return the string \"Set {1,2,3} is not equal to 1,2.\".\n * \n * <p>\n * If for whatever reason you need to place the string \"{}\" in the message\n * without its <em>formatting anchor<\/em> meaning, then you need to escape the\n * '{' character with '\\', that is the backslash character. Only the '{'\n * character should be escaped. There is no need to escape the '}' character.\n * For example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Set \\\\{} is not equal to {}.&quot;, &quot;1,2&quot;);\n * <\/pre>\n * \n * will return the string \"Set {} is not equal to 1,2.\".\n * \n * <p>\n * The escaping behavior just described can be overridden by escaping the escape\n * character '\\'. Calling\n * \n * <pre>\n * MessageFormatter.format(&quot;File name is C:\\\\\\\\{}.&quot;, &quot;file.zip&quot;);\n * <\/pre>\n * \n * will return the string \"File name is C:\\file.zip\".\n * \n * <p>\n * The formatting conventions are different than those of {@link MessageFormat}\n * which ships with the Java platform. This is justified by the fact that\n * SLF4J's implementation is 10 times faster than that of {@link MessageFormat}.\n * This local performance difference is both measurable and significant in the\n * larger context of the complete logging processing chain.\n * \n * <p>\n * See also {@link #format(String, Object)},\n * {@link #format(String, Object, Object)} and\n * {@link #arrayFormat(String, Object[])} methods for more details.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Joern Huxhorn\n */\nfinal public class MessageFormatter {\n    static final char DELIM_START = '{';\n    static final char DELIM_STOP = '}';\n    static final String DELIM_STR = \"{}\";\n    private static final char ESCAPE_CHAR = '\\\\';\n\n    /**\n     * Performs single argument substitution for the 'messagePattern' passed as\n     * parameter.\n     * <p>\n     * For example,\n     * \n     * <pre>\n     * MessageFormatter.format(&quot;Hi {}.&quot;, &quot;there&quot;);\n     * <\/pre>\n     * \n     * will return the string \"Hi there.\".\n     * <p>\n     * \n     * @param messagePattern\n     *          The message pattern which will be parsed and formatted\n     * @param argument\n     *          The argument to be substituted in place of the formatting anchor\n     * @return The formatted message\n     */\n    final public static FormattingTuple format(String messagePattern, Object arg) {\n        return arrayFormat(messagePattern, new Object[] { arg });\n    }\n\n    /**\n     * \n     * Performs a two argument substitution for the 'messagePattern' passed as\n     * parameter.\n     * <p>\n     * For example,\n     * \n     * <pre>\n     * MessageFormatter.format(&quot;Hi {}. My name is {}.&quot;, &quot;Alice&quot;, &quot;Bob&quot;);\n     * <\/pre>\n     * \n     * will return the string \"Hi Alice. My name is Bob.\".\n     * \n     * @param messagePattern\n     *          The message pattern which will be parsed and formatted\n     * @param arg1\n     *          The argument to be substituted in place of the first formatting\n     *          anchor\n     * @param arg2\n     *          The argument to be substituted in place of the second formatting\n     *          anchor\n     * @return The formatted message\n     */\n    final public static FormattingTuple format(final String messagePattern, Object arg1, Object arg2) {\n        return arrayFormat(messagePattern, new Object[] { arg1, arg2 });\n    }\n\n    \n    static final Throwable getThrowableCandidate(Object[] argArray) {\n        if (argArray == null || argArray.length == 0) {\n            return null;\n        }\n\n        final Object lastEntry = argArray[argArray.length - 1];\n        if (lastEntry instanceof Throwable) {\n            return (Throwable) lastEntry;\n        }\n        return null;\n    }\n\n    final public static FormattingTuple arrayFormat(final String messagePattern, final Object[] argArray) {\n        Throwable throwableCandidate = getThrowableCandidate(argArray);\n        Object[] args = argArray;\n        if(throwableCandidate != null) {\n            args = trimmedCopy(argArray);\n        }\n        return arrayFormat(messagePattern, args, throwableCandidate);\n    }\n\n    private static Object[] trimmedCopy(Object[] argArray) {\n        if (argArray == null || argArray.length == 0) {\n            throw new IllegalStateException(\"non-sensical empty or null argument array\");\n        }\n        final int trimemdLen = argArray.length - 1;\n        Object[] trimmed = new Object[trimemdLen];\n        System.arraycopy(argArray, 0, trimmed, 0, trimemdLen);\n        return trimmed;\n    }\n\n\n    final public static FormattingTuple arrayFormat(final String messagePattern, final Object[] argArray, Throwable throwable) {\n\n        if (messagePattern == null) {\n            return new FormattingTuple(null, argArray, throwable);\n        }\n\n        if (argArray == null) {\n            return new FormattingTuple(messagePattern);\n        }\n\n        int i = 0;\n        int j;\n        // use string builder for better multicore performance\n        StringBuilder sbuf = new StringBuilder(messagePattern.length() + 50);\n\n        int L;\n        for (L = 0; L < argArray.length; L++) {\n\n            j = messagePattern.indexOf(DELIM_STR, i);\n\n            if (j == -1) {\n                // no more variables\n                if (i == 0) { // this is a simple string\n                    return new FormattingTuple(messagePattern, argArray, throwable);\n                } else { // add the tail string which contains no variables and return\n                    // the result.\n                    sbuf.append(messagePattern, i, messagePattern.length());\n                    return new FormattingTuple(sbuf.toString(), argArray, throwable);\n                }\n            } else {\n                if (isEscapedDelimeter(messagePattern, j)) {\n                    if (!isDoubleEscaped(messagePattern, j)) {\n                        L--; // DELIM_START was escaped, thus should not be incremented\n                        sbuf.append(messagePattern, i, j - 1);\n                        sbuf.append(DELIM_START);\n                        i = j + 1;\n                    } else {\n                        // The escape character preceding the delimiter start is\n                        // itself escaped: \"abc x:\\\\{}\"\n                        // we have to consume one backward slash\n                        sbuf.append(messagePattern, i, j - 1);\n                        deeplyAppendParameter(sbuf, argArray[L], new HashMap<Object[], Object>());\n                        i = j + 2;\n                    }\n                } else {\n                    // normal case\n                    sbuf.append(messagePattern, i, j);\n                    deeplyAppendParameter(sbuf, argArray[L], new HashMap<Object[], Object>());\n                    i = j + 2;\n                }\n            }\n        }\n        // append the characters following the last {} pair.\n        sbuf.append(messagePattern, i, messagePattern.length());\n        return new FormattingTuple(sbuf.toString(), argArray, throwable);\n    }\n\n    final static boolean isEscapedDelimeter(String messagePattern, int delimeterStartIndex) {\n\n        if (delimeterStartIndex == 0) {\n            return false;\n        }\n        char potentialEscape = messagePattern.charAt(delimeterStartIndex - 1);\n        if (potentialEscape == ESCAPE_CHAR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    final static boolean isDoubleEscaped(String messagePattern, int delimeterStartIndex) {\n        if (delimeterStartIndex >= 2 && messagePattern.charAt(delimeterStartIndex - 2) == ESCAPE_CHAR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // special treatment of array values was suggested by 'lizongbo'\n    private static void deeplyAppendParameter(StringBuilder sbuf, Object o, Map<Object[], Object> seenMap) {\n        if (o == null) {\n            sbuf.append(\"null\");\n            return;\n        }\n        if (!o.getClass().isArray()) {\n            safeObjectAppend(sbuf, o);\n        } else {\n            // check for primitive array types because they\n            // unfortunately cannot be cast to Object[]\n            if (o instanceof boolean[]) {\n                booleanArrayAppend(sbuf, (boolean[]) o);\n            } else if (o instanceof byte[]) {\n                byteArrayAppend(sbuf, (byte[]) o);\n            } else if (o instanceof char[]) {\n                charArrayAppend(sbuf, (char[]) o);\n            } else if (o instanceof short[]) {\n                shortArrayAppend(sbuf, (short[]) o);\n            } else if (o instanceof int[]) {\n                intArrayAppend(sbuf, (int[]) o);\n            } else if (o instanceof long[]) {\n                longArrayAppend(sbuf, (long[]) o);\n            } else if (o instanceof float[]) {\n                floatArrayAppend(sbuf, (float[]) o);\n            } else if (o instanceof double[]) {\n                doubleArrayAppend(sbuf, (double[]) o);\n            } else {\n                objectArrayAppend(sbuf, (Object[]) o, seenMap);\n            }\n        }\n    }\n\n    private static void safeObjectAppend(StringBuilder sbuf, Object o) {\n        try {\n            String oAsString = o.toString();\n            sbuf.append(oAsString);\n        } catch (Throwable t) {\n            Util.report(\"SLF4J: Failed toString() invocation on an object of type [\" + o.getClass().getName() + \"]\", t);\n            sbuf.append(\"[FAILED toString()]\");\n        }\n\n    }\n\n    private static void objectArrayAppend(StringBuilder sbuf, Object[] a, Map<Object[], Object> seenMap) {\n        sbuf.append('[');\n        if (!seenMap.containsKey(a)) {\n            seenMap.put(a, null);\n            final int len = a.length;\n            for (int i = 0; i < len; i++) {\n                deeplyAppendParameter(sbuf, a[i], seenMap);\n                if (i != len - 1)\n                    sbuf.append(\", \");\n            }\n            // allow repeats in siblings\n            seenMap.remove(a);\n        } else {\n            sbuf.append(\"...\");\n        }\n        sbuf.append(']');\n    }\n\n    private static void booleanArrayAppend(StringBuilder sbuf, boolean[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void byteArrayAppend(StringBuilder sbuf, byte[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void charArrayAppend(StringBuilder sbuf, char[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void shortArrayAppend(StringBuilder sbuf, short[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void intArrayAppend(StringBuilder sbuf, int[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void longArrayAppend(StringBuilder sbuf, long[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void floatArrayAppend(StringBuilder sbuf, float[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void doubleArrayAppend(StringBuilder sbuf, double[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport java.text.MessageFormat;\nimport java.util.HashMap;\nimport java.util.Map;\n\n// contributors: lizongbo: proposed special treatment of array parameter values\n// Joern Huxhorn: pointed out double[] omission, suggested deep array copy\n/**\n * Formats messages according to very simple substitution rules. Substitutions\n * can be made 1, 2 or more arguments.\n * \n * <p>\n * For example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Hi {}.&quot;, &quot;there&quot;)\n * <\/pre>\n * \n * will return the string \"Hi there.\".\n * <p>\n * The {} pair is called the <em>formatting anchor<\/em>. It serves to designate\n * the location where arguments need to be substituted within the message\n * pattern.\n * <p>\n * In case your message contains the '{' or the '}' character, you do not have\n * to do anything special unless the '}' character immediately follows '{'. For\n * example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Set {1,2,3} is not equal to {}.&quot;, &quot;1,2&quot;);\n * <\/pre>\n * \n * will return the string \"Set {1,2,3} is not equal to 1,2.\".\n * \n * <p>\n * If for whatever reason you need to place the string \"{}\" in the message\n * without its <em>formatting anchor<\/em> meaning, then you need to escape the\n * '{' character with '\\', that is the backslash character. Only the '{'\n * character should be escaped. There is no need to escape the '}' character.\n * For example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Set \\\\{} is not equal to {}.&quot;, &quot;1,2&quot;);\n * <\/pre>\n * \n * will return the string \"Set {} is not equal to 1,2.\".\n * \n * <p>\n * The escaping behavior just described can be overridden by escaping the escape\n * character '\\'. Calling\n * \n * <pre>\n * MessageFormatter.format(&quot;File name is C:\\\\\\\\{}.&quot;, &quot;file.zip&quot;);\n * <\/pre>\n * \n * will return the string \"File name is C:\\file.zip\".\n * \n * <p>\n * The formatting conventions are different than those of {@link MessageFormat}\n * which ships with the Java platform. This is justified by the fact that\n * SLF4J's implementation is 10 times faster than that of {@link MessageFormat}.\n * This local performance difference is both measurable and significant in the\n * larger context of the complete logging processing chain.\n * \n * <p>\n * See also {@link #format(String, Object)},\n * {@link #format(String, Object, Object)} and\n * {@link #arrayFormat(String, Object[])} methods for more details.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Joern Huxhorn\n */\nfinal public class MessageFormatter {\n    static final char DELIM_START = '{';\n    static final char DELIM_STOP = '}';\n    static final String DELIM_STR = \"{}\";\n    private static final char ESCAPE_CHAR = '\\\\';\n\n    /**\n     * Performs single argument substitution for the 'messagePattern' passed as\n     * parameter.\n     * <p>\n     * For example,\n     * \n     * <pre>\n     * MessageFormatter.format(&quot;Hi {}.&quot;, &quot;there&quot;);\n     * <\/pre>\n     * \n     * will return the string \"Hi there.\".\n     * <p>\n     * \n     * @param messagePattern\n     *          The message pattern which will be parsed and formatted\n     * @param argument\n     *          The argument to be substituted in place of the formatting anchor\n     * @return The formatted message\n     */\n    final public static FormattingTuple format(String messagePattern, Object arg) {\n        return arrayFormat(messagePattern, new Object[] { arg });\n    }\n\n    /**\n     * \n     * Performs a two argument substitution for the 'messagePattern' passed as\n     * parameter.\n     * <p>\n     * For example,\n     * \n     * <pre>\n     * MessageFormatter.format(&quot;Hi {}. My name is {}.&quot;, &quot;Alice&quot;, &quot;Bob&quot;);\n     * <\/pre>\n     * \n     * will return the string \"Hi Alice. My name is Bob.\".\n     * \n     * @param messagePattern\n     *          The message pattern which will be parsed and formatted\n     * @param arg1\n     *          The argument to be substituted in place of the first formatting\n     *          anchor\n     * @param arg2\n     *          The argument to be substituted in place of the second formatting\n     *          anchor\n     * @return The formatted message\n     */\n    final public static FormattingTuple format(final String messagePattern, Object arg1, Object arg2) {\n        return arrayFormat(messagePattern, new Object[] { arg1, arg2 });\n    }\n\n    static final Throwable getThrowableCandidate(Object[] argArray) {\n        if (argArray == null || argArray.length == 0) {\n            return null;\n        }\n\n        final Object lastEntry = argArray[argArray.length - 1];\n        if (lastEntry instanceof Throwable) {\n            return (Throwable) lastEntry;\n        }\n        return null;\n    }\n\n    /**\n     * Same principle as the {@link #format(String, Object)} and\n     * {@link #format(String, Object, Object)} methods except that any number of\n     * arguments can be passed in an array.\n     * \n     * @param messagePattern\n     *          The message pattern which will be parsed and formatted\n     * @param argArray\n     *          An array of arguments to be substituted in place of formatting\n     *          anchors\n     * @return The formatted message\n     */\n    final public static FormattingTuple arrayFormat(final String messagePattern, final Object[] argArray) {\n\n        Throwable throwableCandidate = getThrowableCandidate(argArray);\n\n        if (messagePattern == null) {\n            return new FormattingTuple(null, argArray, throwableCandidate);\n        }\n\n        if (argArray == null) {\n            return new FormattingTuple(messagePattern);\n        }\n\n        int i = 0;\n        int j;\n        // use string builder for better multicore performance\n        StringBuilder sbuf = new StringBuilder(messagePattern.length() + 50);\n\n        int L;\n        for (L = 0; L < argArray.length; L++) {\n\n            j = messagePattern.indexOf(DELIM_STR, i);\n\n            if (j == -1) {\n                // no more variables\n                if (i == 0) { // this is a simple string\n                    return new FormattingTuple(messagePattern, argArray, throwableCandidate);\n                } else { // add the tail string which contains no variables and return\n                    // the result.\n                    sbuf.append(messagePattern, i, messagePattern.length());\n                    return new FormattingTuple(sbuf.toString(), argArray, throwableCandidate);\n                }\n            } else {\n                if (isEscapedDelimeter(messagePattern, j)) {\n                    if (!isDoubleEscaped(messagePattern, j)) {\n                        L--; // DELIM_START was escaped, thus should not be incremented\n                        sbuf.append(messagePattern, i, j - 1);\n                        sbuf.append(DELIM_START);\n                        i = j + 1;\n                    } else {\n                        // The escape character preceding the delimiter start is\n                        // itself escaped: \"abc x:\\\\{}\"\n                        // we have to consume one backward slash\n                        sbuf.append(messagePattern, i, j - 1);\n                        deeplyAppendParameter(sbuf, argArray[L], new HashMap<Object[], Object>());\n                        i = j + 2;\n                    }\n                } else {\n                    // normal case\n                    sbuf.append(messagePattern, i, j);\n                    deeplyAppendParameter(sbuf, argArray[L], new HashMap<Object[], Object>());\n                    i = j + 2;\n                }\n            }\n        }\n        // append the characters following the last {} pair.\n        sbuf.append(messagePattern, i, messagePattern.length());\n        if (L < argArray.length - 1) {\n            return new FormattingTuple(sbuf.toString(), argArray, throwableCandidate);\n        } else {\n            return new FormattingTuple(sbuf.toString(), argArray, null);\n        }\n    }\n\n    final static boolean isEscapedDelimeter(String messagePattern, int delimeterStartIndex) {\n\n        if (delimeterStartIndex == 0) {\n            return false;\n        }\n        char potentialEscape = messagePattern.charAt(delimeterStartIndex - 1);\n        if (potentialEscape == ESCAPE_CHAR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    final static boolean isDoubleEscaped(String messagePattern, int delimeterStartIndex) {\n        if (delimeterStartIndex >= 2 && messagePattern.charAt(delimeterStartIndex - 2) == ESCAPE_CHAR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // special treatment of array values was suggested by 'lizongbo'\n    private static void deeplyAppendParameter(StringBuilder sbuf, Object o, Map<Object[], Object> seenMap) {\n        if (o == null) {\n            sbuf.append(\"null\");\n            return;\n        }\n        if (!o.getClass().isArray()) {\n            safeObjectAppend(sbuf, o);\n        } else {\n            // check for primitive array types because they\n            // unfortunately cannot be cast to Object[]\n            if (o instanceof boolean[]) {\n                booleanArrayAppend(sbuf, (boolean[]) o);\n            } else if (o instanceof byte[]) {\n                byteArrayAppend(sbuf, (byte[]) o);\n            } else if (o instanceof char[]) {\n                charArrayAppend(sbuf, (char[]) o);\n            } else if (o instanceof short[]) {\n                shortArrayAppend(sbuf, (short[]) o);\n            } else if (o instanceof int[]) {\n                intArrayAppend(sbuf, (int[]) o);\n            } else if (o instanceof long[]) {\n                longArrayAppend(sbuf, (long[]) o);\n            } else if (o instanceof float[]) {\n                floatArrayAppend(sbuf, (float[]) o);\n            } else if (o instanceof double[]) {\n                doubleArrayAppend(sbuf, (double[]) o);\n            } else {\n                objectArrayAppend(sbuf, (Object[]) o, seenMap);\n            }\n        }\n    }\n\n    private static void safeObjectAppend(StringBuilder sbuf, Object o) {\n        try {\n            String oAsString = o.toString();\n            sbuf.append(oAsString);\n        } catch (Throwable t) {\n            System.err.println(\"SLF4J: Failed toString() invocation on an object of type [\" + o.getClass().getName() + \"]\");\n            t.printStackTrace();\n            sbuf.append(\"[FAILED toString()]\");\n        }\n\n    }\n\n    private static void objectArrayAppend(StringBuilder sbuf, Object[] a, Map<Object[], Object> seenMap) {\n        sbuf.append('[');\n        if (!seenMap.containsKey(a)) {\n            seenMap.put(a, null);\n            final int len = a.length;\n            for (int i = 0; i < len; i++) {\n                deeplyAppendParameter(sbuf, a[i], seenMap);\n                if (i != len - 1)\n                    sbuf.append(\", \");\n            }\n            // allow repeats in siblings\n            seenMap.remove(a);\n        } else {\n            sbuf.append(\"...\");\n        }\n        sbuf.append(']');\n    }\n\n    private static void booleanArrayAppend(StringBuilder sbuf, boolean[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void byteArrayAppend(StringBuilder sbuf, byte[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void charArrayAppend(StringBuilder sbuf, char[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void shortArrayAppend(StringBuilder sbuf, short[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void intArrayAppend(StringBuilder sbuf, int[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void longArrayAppend(StringBuilder sbuf, long[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void floatArrayAppend(StringBuilder sbuf, float[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n\n    private static void doubleArrayAppend(StringBuilder sbuf, double[] a) {\n        sbuf.append('[');\n        final int len = a.length;\n        for (int i = 0; i < len; i++) {\n            sbuf.append(a[i]);\n            if (i != len - 1)\n                sbuf.append(\", \");\n        }\n        sbuf.append(']');\n    }\n}\n","lineNo":169}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.event.LoggingEventAware;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger, LoggingEventAware {\n\n    private static final long serialVersionUID = -8053026990503422791L;\n\n    transient final java.util.logging.Logger logger;\n\n    // WARN: JDK14LoggerAdapter constructor should have only package access so\n    // that only JDK14LoggerFactory be able to create one.\n    JDK14LoggerAdapter(java.util.logging.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n    }\n\n    /**\n     * Is this logger instance enabled for the FINEST level?\n     * \n     * @return True if this Logger is enabled for level FINEST, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINEST);\n    }\n\n    /**\n     * Log a message object at level FINEST.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINEST.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void trace(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINEST with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the FINE level?\n     * \n     * @return True if this Logger is enabled for level FINE, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    /**\n     * Log a message object at level FINE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINE.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void debug(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the WARNING level?\n     * \n     * @return True if this Logger is enabled for the WARNING level, false\n     *         otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    /**\n     * Log a message object at the WARNING level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARNING according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARNING level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for level SEVERE?\n     * \n     * @return True if this Logger is enabled for level SEVERE, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n\n    /**\n     * Log a message object at the SEVERE level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level SEVERE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void error(String format, Object... arguments) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the SEVERE level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, t);\n        }\n    }\n\n    /**\n     * Log the message at the specified level with the specified throwable if any.\n     * This method creates a LogRecord and fills in caller date before calling\n     * this instance's JDK14 logger.\n     * \n     * See bug report #13 for more details.\n     * \n     * @param level\n     * @param msg\n     * @param t\n     */\n    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n        // millis and thread are filled by the constructor\n        LogRecord record = new LogRecord(level, msg);\n        record.setLoggerName(getName());\n        record.setThrown(t);\n        // Note: parameters in record are not set because SLF4J only \n        // supports a single formatting style\n        fillCallerData(callerFQCN, record);\n        logger.log(record);\n    }\n\n    static String SELF = JDK14LoggerAdapter.class.getName();\n    static String SUPER = MarkerIgnoringBase.class.getName();\n\n    /**\n     * Fill in caller data if possible.\n     * \n     * @param record\n     *          The record to update\n     */\n    final private void fillCallerData(String callerFQCN, LogRecord record) {\n        StackTraceElement[] steArray = new Throwable().getStackTrace();\n\n        int selfIndex = -1;\n        for (int i = 0; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            if (className.equals(callerFQCN) || className.equals(SUPER)) {\n                selfIndex = i;\n                break;\n            }\n        }\n\n        int found = -1;\n        for (int i = selfIndex + 1; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            if (!(className.equals(callerFQCN) || className.equals(SUPER))) {\n                found = i;\n                break;\n            }\n        }\n\n        if (found != -1) {\n            StackTraceElement ste = steArray[found];\n            // setting the class name has the side effect of setting\n            // the needToInferCaller variable to false.\n            record.setSourceClassName(ste.getClassName());\n            record.setSourceMethodName(ste.getMethodName());\n        }\n    }\n\n    public void log(Marker marker, String callerFQCN, int level, String message, Object[] argArray, Throwable t) {\n        Level julLevel = slf4jLevelIntToJULLevel(level);\n        // the logger.isLoggable check avoids the unconditional\n        // construction of location data for disabled log\n        // statements. As of 2008-07-31, callers of this method\n        // do not perform this check. See also\n        // http://jira.qos.ch/browse/SLF4J-81\n        if (logger.isLoggable(julLevel)) {\n            log(callerFQCN, julLevel, message, t);\n        }\n    }\n\n    private Level slf4jLevelIntToJULLevel(int slf4jLevelInt) {\n        Level julLevel;\n        switch (slf4jLevelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            julLevel = Level.FINEST;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            julLevel = Level.FINE;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            julLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            julLevel = Level.WARNING;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            julLevel = Level.SEVERE;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + slf4jLevelInt + \" is not recognized.\");\n        }\n        return julLevel;\n    }\n\n    /**\n     * @since 1.7.15\n     */\n    public void log(LoggingEvent event) {\n        Level julLevel = slf4jLevelIntToJULLevel(event.getLevel().toInt());\n        if (logger.isLoggable(julLevel)) {\n            LogRecord record = eventToRecord(event, julLevel);\n            logger.log(record);\n        }\n    }\n\n    private LogRecord eventToRecord(LoggingEvent event, Level julLevel) {\n        String format = event.getMessage();\n        Object[] arguments = event.getArgumentArray();\n        FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n        if(ft.getThrowable() != null && event.getThrowable() != null) {\n            throw new IllegalArgumentException(\"both last element in argument array and last argument are of type Throwable\");\n        }\n        \n        Throwable t = event.getThrowable();\n        if(ft.getThrowable() != null) {\n            t = ft.getThrowable();\n            throw new IllegalStateException(\"fix above code\");\n        }\n        \n        LogRecord record = new LogRecord(julLevel, ft.getMessage());\n        record.setLoggerName(event.getLoggerName());\n        record.setMillis(event.getTimeStamp());\n        record.setSourceClassName(EventConstants.NA_SUBST);\n        record.setSourceMethodName(EventConstants.NA_SUBST);\n        \n        record.setThrown(t);\n        return record;\n    }\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in\n * conformity with the {@link Logger} interface. Note that the logging levels\n * mentioned in this class refer to those defined in the java.util.logging\n * package.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Peter Royal\n */\npublic final class JDK14LoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger {\n\n    private static final long serialVersionUID = -8053026990503422791L;\n\n    transient final java.util.logging.Logger logger;\n\n    // WARN: JDK14LoggerAdapter constructor should have only package access so\n    // that only JDK14LoggerFactory be able to create one.\n    JDK14LoggerAdapter(java.util.logging.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n    }\n\n    /**\n     * Is this logger instance enabled for the FINEST level?\n     * \n     * @return True if this Logger is enabled for level FINEST, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINEST);\n    }\n\n    /**\n     * Log a message object at level FINEST.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINEST.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINEST according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINEST level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void trace(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINEST)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINEST with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINEST)) {\n            log(SELF, Level.FINEST, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the FINE level?\n     * \n     * @return True if this Logger is enabled for level FINE, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    /**\n     * Log a message object at level FINE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level FINE.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level FINE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the FINE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void debug(String format, Object... argArray) {\n        if (logger.isLoggable(Level.FINE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level FINE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        if (logger.isLoggable(Level.FINE)) {\n            log(SELF, Level.FINE, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isLoggable(Level.INFO)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        if (logger.isLoggable(Level.INFO)) {\n            log(SELF, Level.INFO, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the WARNING level?\n     * \n     * @return True if this Logger is enabled for the WARNING level, false\n     *         otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    /**\n     * Log a message object at the WARNING level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARNING level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARNING according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARNING level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isLoggable(Level.WARNING)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARNING level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        if (logger.isLoggable(Level.WARNING)) {\n            log(SELF, Level.WARNING, msg, t);\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for level SEVERE?\n     * \n     * @return True if this Logger is enabled for level SEVERE, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n\n    /**\n     * Log a message object at the SEVERE level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, null);\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the SEVERE level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level SEVERE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the SEVERE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void error(String format, Object... arguments) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the SEVERE level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        if (logger.isLoggable(Level.SEVERE)) {\n            log(SELF, Level.SEVERE, msg, t);\n        }\n    }\n\n    /**\n     * Log the message at the specified level with the specified throwable if any.\n     * This method creates a LogRecord and fills in caller date before calling\n     * this instance's JDK14 logger.\n     * \n     * See bug report #13 for more details.\n     * \n     * @param level\n     * @param msg\n     * @param t\n     */\n    private void log(String callerFQCN, Level level, String msg, Throwable t) {\n        // millis and thread are filled by the constructor\n        LogRecord record = new LogRecord(level, msg);\n        record.setLoggerName(getName());\n        record.setThrown(t);\n        // Note: parameters in record are not set because SLF4J only \n        // supports a single formatting style\n        fillCallerData(callerFQCN, record);\n        logger.log(record);\n\n    }\n\n    static String SELF = JDK14LoggerAdapter.class.getName();\n    static String SUPER = MarkerIgnoringBase.class.getName();\n\n    /**\n     * Fill in caller data if possible.\n     * \n     * @param record\n     *          The record to update\n     */\n    final private void fillCallerData(String callerFQCN, LogRecord record) {\n        StackTraceElement[] steArray = new Throwable().getStackTrace();\n\n        int selfIndex = -1;\n        for (int i = 0; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            if (className.equals(callerFQCN) || className.equals(SUPER)) {\n                selfIndex = i;\n                break;\n            }\n        }\n\n        int found = -1;\n        for (int i = selfIndex + 1; i < steArray.length; i++) {\n            final String className = steArray[i].getClassName();\n            if (!(className.equals(callerFQCN) || className.equals(SUPER))) {\n                found = i;\n                break;\n            }\n        }\n\n        if (found != -1) {\n            StackTraceElement ste = steArray[found];\n            // setting the class name has the side effect of setting\n            // the needToInferCaller variable to false.\n            record.setSourceClassName(ste.getClassName());\n            record.setSourceMethodName(ste.getMethodName());\n        }\n    }\n\n    public void log(Marker marker, String callerFQCN, int level, String message, Object[] argArray, Throwable t) {\n        Level julLevel;\n        switch (level) {\n        case LocationAwareLogger.TRACE_INT:\n            julLevel = Level.FINEST;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            julLevel = Level.FINE;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            julLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            julLevel = Level.WARNING;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            julLevel = Level.SEVERE;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + level + \" is not recognized.\");\n        }\n        // the logger.isLoggable check avoids the unconditional\n        // construction of location data for disabled log\n        // statements. As of 2008-07-31, callers of this method\n        // do not perform this check. See also\n        // http://jira.qos.ch/browse/SLF4J-81\n        if (logger.isLoggable(julLevel)) {\n            log(callerFQCN, julLevel, message, t);\n        }\n    }\n}\n","lineNo":626}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport static org.slf4j.event.EventConstants.NA_SUBST;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Category;\nimport org.apache.log4j.Level;\nimport org.apache.log4j.Priority;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.ThrowableInformation;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.EventConstants;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.event.LoggingEventAware;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger, LoggingEventAware, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Log a message object at level TRACE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level TRACE.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void trace(String format, Object... arguments) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level TRACE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    /**\n     * Log a message object at level DEBUG.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level DEBUG.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arguments an array of arguments\n     */\n    public void debug(String format, Object... arguments) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level DEBUG with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        logger.log(FQCN, Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        logger.log(FQCN, Level.INFO, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    /**\n     * Log a message object at the WARN level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARN according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARN level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        logger.log(FQCN, Level.WARN, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    /**\n     * Log a message object at the ERROR level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level ERROR according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void error(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the ERROR level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        logger.log(FQCN, Level.ERROR, msg, t);\n    }\n\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] argArray, Throwable t) {\n        Level log4jLevel = toLog4jLevel(level);\n        logger.log(callerFQCN, log4jLevel, msg, t);\n    }\n\n    private Level toLog4jLevel(int level) {\n        Level log4jLevel;\n        switch (level) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + level + \" is not recognized.\");\n        }\n        return log4jLevel;\n    }\n\n    public void log(LoggingEvent event) {\n        Level log4jLevel = toLog4jLevel(event.getLevel().toInt());\n        if (!logger.isEnabledFor(log4jLevel))\n            return;\n\n        org.apache.log4j.spi.LoggingEvent log4jevent = toLog4jEvent(event, log4jLevel);\n        logger.callAppenders(log4jevent);\n\n    }\n\n    private org.apache.log4j.spi.LoggingEvent toLog4jEvent(LoggingEvent event, Level log4jLevel) {\n\n        FormattingTuple ft = MessageFormatter.format(event.getMessage(), event.getArgumentArray(), event.getThrowable());\n\n        LocationInfo locationInfo = new LocationInfo(NA_SUBST, NA_SUBST, NA_SUBST, \"0\");\n\n        ThrowableInformation ti = null;\n        Throwable t = ft.getThrowable();\n        if (t != null)\n            ti = new ThrowableInformation(t);\n\n        org.apache.log4j.spi.LoggingEvent log4jEvent = new org.apache.log4j.spi.LoggingEvent(FQCN, logger, event.getTimeStamp(), log4jLevel, ft.getMessage(),\n                        event.getThreadName(), ti, null, locationInfo, null);\n\n        return log4jEvent;\n    }\n\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport java.io.Serializable;\n\nimport org.apache.log4j.Level;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * A wrapper over {@link org.apache.log4j.Logger org.apache.log4j.Logger} in\n * conforming to the {@link Logger} interface.\n * \n * <p>\n * Note that the logging levels mentioned in this class refer to those defined\n * in the <a\n * href=\"http://logging.apache.org/log4j/docs/api/org/apache/log4j/Level.html\">\n * <code>org.apache.log4j.Level<\/code><\/a> class.\n * \n * <p>\n * The TRACE level was introduced in log4j version 1.2.12. In order to avoid\n * crashing the host application, in the case the log4j version in use predates\n * 1.2.12, the TRACE level will be mapped as DEBUG. See also <a\n * href=\"http://jira.qos.ch/browse/SLF4J-59\">SLF4J-59<\/a>.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger, Serializable {\n\n    private static final long serialVersionUID = 6182834493563598289L;\n\n    final transient org.apache.log4j.Logger logger;\n\n    /**\n     * Following the pattern discussed in pages 162 through 168 of \"The complete\n     * log4j manual\".\n     */\n    final static String FQCN = Log4jLoggerAdapter.class.getName();\n\n    // Does the log4j version in use recognize the TRACE level?\n    // The trace level was introduced in log4j 1.2.12.\n    final boolean traceCapable;\n\n    // WARN: Log4jLoggerAdapter constructor should have only package access so\n    // that\n    // only Log4jLoggerFactory be able to create one.\n    Log4jLoggerAdapter(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n        this.name = logger.getName();\n        traceCapable = isTraceCapable();\n    }\n\n    private boolean isTraceCapable() {\n        try {\n            logger.isTraceEnabled();\n            return true;\n        } catch (NoSuchMethodError e) {\n            return false;\n        }\n    }\n\n    /**\n     * Is this logger instance enabled for the TRACE level?\n     * \n     * @return True if this Logger is enabled for level TRACE, false otherwise.\n     */\n    public boolean isTraceEnabled() {\n        if (traceCapable) {\n            return logger.isTraceEnabled();\n        } else {\n            return logger.isDebugEnabled();\n        }\n    }\n\n    /**\n     * Log a message object at level TRACE.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void trace(String msg) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level TRACE.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void trace(String format, Object arg) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void trace(String format, Object arg1, Object arg2) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level TRACE according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the TRACE level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arguments\n     *          an array of arguments\n     */\n    public void trace(String format, Object... arguments) {\n        if (isTraceEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level TRACE with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void trace(String msg, Throwable t) {\n        logger.log(FQCN, traceCapable ? Level.TRACE : Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the DEBUG level?\n     * \n     * @return True if this Logger is enabled for level DEBUG, false otherwise.\n     */\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    /**\n     * Log a message object at level DEBUG.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for level DEBUG.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void debug(String format, Object arg) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void debug(String format, Object arg1, Object arg2) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level DEBUG according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the DEBUG level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arguments an array of arguments\n     */\n    public void debug(String format, Object... arguments) {\n        if (logger.isDebugEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);\n            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at level DEBUG with an accompanying message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void debug(String msg, Throwable t) {\n        logger.log(FQCN, Level.DEBUG, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the INFO level?\n     * \n     * @return True if this Logger is enabled for the INFO level, false otherwise.\n     */\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    /**\n     * Log a message object at the INFO level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void info(String format, Object arg) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the INFO level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level INFO according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the INFO level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void info(String format, Object... argArray) {\n        if (logger.isInfoEnabled()) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.INFO, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the INFO level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void info(String msg, Throwable t) {\n        logger.log(FQCN, Level.INFO, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for the WARN level?\n     * \n     * @return True if this Logger is enabled for the WARN level, false otherwise.\n     */\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    /**\n     * Log a message object at the WARN level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void warn(String format, Object arg) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the WARN level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level WARN according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the WARN level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void warn(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.WARN)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.WARN, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the WARN level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void warn(String msg, Throwable t) {\n        logger.log(FQCN, Level.WARN, msg, t);\n    }\n\n    /**\n     * Is this logger instance enabled for level ERROR?\n     * \n     * @return True if this Logger is enabled for level ERROR, false otherwise.\n     */\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    /**\n     * Log a message object at the ERROR level.\n     * \n     * @param msg\n     *          - the message object to be logged\n     */\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * argument.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg\n     *          the argument\n     */\n    public void error(String format, Object arg) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at the ERROR level according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param arg1\n     *          the first argument\n     * @param arg2\n     *          the second argument\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log a message at level ERROR according to the specified format and\n     * arguments.\n     * \n     * <p>\n     * This form avoids superfluous object creation when the logger is disabled\n     * for the ERROR level.\n     * <\/p>\n     * \n     * @param format\n     *          the format string\n     * @param argArray\n     *          an array of arguments\n     */\n    public void error(String format, Object... argArray) {\n        if (logger.isEnabledFor(Level.ERROR)) {\n            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n            logger.log(FQCN, Level.ERROR, ft.getMessage(), ft.getThrowable());\n        }\n    }\n\n    /**\n     * Log an exception (throwable) at the ERROR level with an accompanying\n     * message.\n     * \n     * @param msg\n     *          the message accompanying the exception\n     * @param t\n     *          the exception (throwable) to log\n     */\n    public void error(String msg, Throwable t) {\n        logger.log(FQCN, Level.ERROR, msg, t);\n    }\n\n    public void log(Marker marker, String callerFQCN, int level, String msg, Object[] argArray, Throwable t) {\n        Level log4jLevel;\n        switch (level) {\n        case LocationAwareLogger.TRACE_INT:\n            log4jLevel = traceCapable ? Level.TRACE : Level.DEBUG;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            log4jLevel = Level.DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            log4jLevel = Level.INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            log4jLevel = Level.WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            log4jLevel = Level.ERROR;\n            break;\n        default:\n            throw new IllegalStateException(\"Level number \" + level + \" is not recognized.\");\n        }\n        logger.log(callerFQCN, log4jLevel, msg, t);\n    }\n\n}\n","lineNo":584}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * Tests that detecting logger name mismatches works and doesn't cause problems\n * or trigger if disabled.\n * <p>\n * This test can't live inside slf4j-api because the NOP Logger doesn't\n * remember its name.\n *\n * @author Alexander Dorokhine\n * @author Ceki G&uuml;lc&uuml;\n */\npublic class DetectLoggerNameMismatchTest {\n\n    private static final String MISMATCH_STRING = \"Detected logger name mismatch\";\n\n    private final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n    private final PrintStream oldErr = System.err;\n\n    @Before\n    public void setUp() {\n        System.setErr(new PrintStream(byteArrayOutputStream));\n    }\n\n    @After\n    public void tearDown() {\n        setTrialEnabled(false);\n        System.setErr(oldErr);\n    }\n\n    /*\n     * Pass in the wrong class to the Logger with the check disabled, and make sure there are no errors.\n     */\n    @Test\n    public void testNoTriggerWithoutProperty() {\n        setTrialEnabled(false);\n        Logger logger = LoggerFactory.getLogger(String.class);\n        assertEquals(\"java.lang.String\", logger.getName());\n        assertMismatchDetected(false);\n    }\n\n    /*\n     * Pass in the wrong class to the Logger with the check enabled, and make sure there ARE errors.\n     */\n    @Test\n    public void testTriggerWithProperty() {\n        setTrialEnabled(true);\n        LoggerFactory.getLogger(String.class);\n        String s = String.valueOf(byteArrayOutputStream);\n        assertMismatchDetected(true);\n    }\n\n    /*\n     * Checks the whole error message to ensure all the names show up correctly.\n     */\n    @Test\n    public void testTriggerWholeMessage() {\n        setTrialEnabled(true);\n        LoggerFactory.getLogger(String.class);\n        boolean success = String.valueOf(byteArrayOutputStream).contains(\n                        \"Detected logger name mismatch. Given name: \\\"java.lang.String\\\"; \" + \"computed name: \\\"org.slf4j.DetectLoggerNameMismatchTest\\\".\");\n        assertTrue(\"Actual value of byteArrayOutputStream: \" + String.valueOf(byteArrayOutputStream), success);\n    }\n\n    /*\n     * Checks that there are no errors with the check enabled if the class matches.\n     */\n    @Test\n    public void testPassIfMatch() {\n        setTrialEnabled(true);\n        Logger logger = LoggerFactory.getLogger(DetectLoggerNameMismatchTest.class);\n        assertEquals(\"org.slf4j.DetectLoggerNameMismatchTest\", logger.getName());\n        assertMismatchDetected(false);\n    }\n\n    private void assertMismatchDetected(boolean mismatchDetected) {\n        assertEquals(mismatchDetected, String.valueOf(byteArrayOutputStream).contains(MISMATCH_STRING));\n    }\n\n    @Test\n    public void verifyLoggerDefinedInBaseWithOverridenGetClassMethod() {\n        setTrialEnabled(true);\n        Square square = new Square();\n        assertEquals(\"org.slf4j.Square\", square.logger.getName());\n        assertMismatchDetected(false);\n    }\n\n    private static void setTrialEnabled(boolean enabled) {\n        // The system property is read into a static variable at initialization time\n        // so we cannot just reset the system property to test this feature.\n        // Therefore we set the variable directly.\n        LoggerFactory.DETECT_LOGGER_NAME_MISMATCH = enabled;\n    }\n}\n\n// Used for testing that inheritance is ignored by the checker.\nclass ShapeBase {\n    public Logger logger = LoggerFactory.getLogger(getClass());\n}\n\nclass Square extends ShapeBase {\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * Tests that detecting logger name mismatches works and doesn't cause problems\n * or trigger if disabled.\n * <p>\n * This test can't live inside slf4j-api because the NOP Logger doesn't\n * remember its name.\n *\n * @author Alexander Dorokhine\n * @author Ceki G&uuml;lc&uuml;\n */\npublic class DetectLoggerNameMismatchTest {\n\n    private static final String MISMATCH_STRING = \"Detected logger name mismatch\";\n\n    private final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n    private final PrintStream oldErr = System.err;\n\n    @Before\n    public void setUp() {\n        System.setErr(new PrintStream(byteArrayOutputStream));\n    }\n\n    @After\n    public void tearDown() {\n        setTrialEnabled(false);\n        System.setErr(oldErr);\n    }\n\n    /*\n     * Pass in the wrong class to the Logger with the check disabled, and make sure there are no errors.\n     */\n    @Test\n    public void testNoTriggerWithoutProperty() {\n        setTrialEnabled(false);\n        Logger logger = LoggerFactory.getLogger(String.class);\n        assertEquals(\"java.lang.String\", logger.getName());\n        assertMismatchDetected(false);\n    }\n\n    /*\n     * Pass in the wrong class to the Logger with the check enabled, and make sure there ARE errors.\n     */\n    @Test\n    public void testTriggerWithProperty() {\n        setTrialEnabled(true);\n        LoggerFactory.getLogger(String.class);\n        assertMismatchDetected(true);\n    }\n\n    /*\n     * Checks the whole error message to ensure all the names show up correctly.\n     */\n    @Test\n    public void testTriggerWholeMessage() {\n        setTrialEnabled(true);\n        LoggerFactory.getLogger(String.class);\n        assertTrue(\"Actual value of byteArrayOutputStream: \" + String.valueOf(byteArrayOutputStream), String.valueOf(byteArrayOutputStream).contains(\n                        \"Detected logger name mismatch. Given name: \\\"java.lang.String\\\"; \" + \"computed name: \\\"org.slf4j.DetectLoggerNameMismatchTest\\\".\"));\n    }\n\n    /*\n     * Checks that there are no errors with the check enabled if the class matches.\n     */\n    @Test\n    public void testPassIfMatch() {\n        setTrialEnabled(true);\n        Logger logger = LoggerFactory.getLogger(DetectLoggerNameMismatchTest.class);\n        assertEquals(\"org.slf4j.DetectLoggerNameMismatchTest\", logger.getName());\n        assertMismatchDetected(false);\n    }\n\n    private void assertMismatchDetected(boolean mismatchDetected) {\n        assertEquals(mismatchDetected, String.valueOf(byteArrayOutputStream).contains(MISMATCH_STRING));\n    }\n\n    @Test\n    public void verifyLoggerDefinedInBaseWithOverridenGetClassMethod() {\n        setTrialEnabled(true);\n        Square square = new Square();\n        assertEquals(\"org.slf4j.Square\", square.logger.getName());\n        assertMismatchDetected(false);\n    }\n\n    private static void setTrialEnabled(boolean enabled) {\n        // The system property is read into a static variable at initialization time\n        // so we cannot just reset the system property to test this feature.\n        // Therefore we set the variable directly.\n        LoggerFactory.DETECT_LOGGER_NAME_MISMATCH = enabled;\n    }\n}\n\n// Used for testing that inheritance is ignored by the checker.\nclass ShapeBase {\n    public Logger logger = LoggerFactory.getLogger(getClass());\n}\n\nclass Square extends ShapeBase {\n}\n","lineNo":94}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.Logger;\n\n/**\n * SubstituteLoggerFactory manages instances of {@link SubstituteLogger}.\n * @author Ceki G&uuml;lc&uuml;\n */\npublic class SubstituteLoggerFactory implements ILoggerFactory {\n\n  final ConcurrentMap<String, SubstituteLogger> loggers = new ConcurrentHashMap<String, SubstituteLogger>();\n\n  public Logger getLogger(String name) {\n    SubstituteLogger logger = loggers.get(name);\n     if (logger == null) {\n        logger = new SubstituteLogger(name);\n        SubstituteLogger oldLogger = loggers.putIfAbsent(name, logger);\n        if (oldLogger != null)\n          logger = oldLogger;\n      }\n    return logger;\n  }\n\n  public List getLoggerNameList() {\n    return new ArrayList<String>(loggers.keySet());\n  }\n\n  public List<SubstituteLogger> getLoggers() {\n    return new ArrayList<SubstituteLogger>(loggers.values());\n  }\n\n  public void clear() {\n    loggers.clear();\n  }\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.Logger;\n\n/**\n * SubstituteLoggerFactory is an trivial implementation of\n * {@link ILoggerFactory} which always returns the unique instance of NOPLogger.\n * <p/>\n * <p>\n * It used as a temporary substitute for the real ILoggerFactory during its\n * auto-configuration which may re-enter LoggerFactory to obtain logger\n * instances. See also http://bugzilla.slf4j.org/show_bug.cgi?id=106\n * <p/>\n * <p>\n * Logger implementations can swap out the NOPLogger with actual Logger\n * implementation once they are properly configured by changing the delegate\n * in {@link org.slf4j.helpers.SubstitutableLogger}\n * <\/p>\n *\n * @author Ceki G&uuml;lc&uuml;\n */\npublic class SubstituteLoggerFactory implements ILoggerFactory {\n\n  // keep a record of requested logger names\n  final ConcurrentMap<String, SubstitutableLogger> loggers = new ConcurrentHashMap<String, SubstitutableLogger>();\n\n  public Logger getLogger(String name) {\n    SubstitutableLogger logger;\n    synchronized (loggers) {\n      logger = loggers.get(name);\n      if (logger == null) {\n        logger = new SubstitutableLogger(name);\n        loggers.put(name, logger);\n      }\n    }\n    return logger;\n  }\n\n  public List getLoggerNameList() {\n    return new ArrayList<String>(loggers.keySet());\n  }\n\n  public List<SubstitutableLogger> getLoggers() {\n    return new ArrayList<SubstitutableLogger>(loggers.values());\n  }\n\n  public void clear() {\n    loggers.clear();\n  }\n}\n","lineNo":44}
{"Refactored Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.Logger;\n\n/**\n * SubstituteLoggerFactory manages instances of {@link SubstituteLogger}.\n * @author Ceki G&uuml;lc&uuml;\n */\npublic class SubstituteLoggerFactory implements ILoggerFactory {\n\n  final ConcurrentMap<String, SubstituteLogger> loggers = new ConcurrentHashMap<String, SubstituteLogger>();\n\n  public Logger getLogger(String name) {\n    SubstituteLogger logger = loggers.get(name);\n     if (logger == null) {\n        logger = new SubstituteLogger(name);\n        SubstituteLogger oldLogger = loggers.putIfAbsent(name, logger);\n        if (oldLogger != null)\n          logger = oldLogger;\n      }\n    return logger;\n  }\n\n  public List getLoggerNameList() {\n    return new ArrayList<String>(loggers.keySet());\n  }\n\n  public List<SubstituteLogger> getLoggers() {\n    return new ArrayList<SubstituteLogger>(loggers.values());\n  }\n\n  public void clear() {\n    loggers.clear();\n  }\n}\n","Smelly Sample":"/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.helpers;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.Logger;\n\n/**\n * SubstituteLoggerFactory is an trivial implementation of\n * {@link ILoggerFactory} which always returns the unique instance of NOPLogger.\n * <p/>\n * <p>\n * It used as a temporary substitute for the real ILoggerFactory during its\n * auto-configuration which may re-enter LoggerFactory to obtain logger\n * instances. See also http://bugzilla.slf4j.org/show_bug.cgi?id=106\n * <p/>\n * <p>\n * Logger implementations can swap out the NOPLogger with actual Logger\n * implementation once they are properly configured by changing the delegate\n * in {@link org.slf4j.helpers.SubstitutableLogger}\n * <\/p>\n *\n * @author Ceki G&uuml;lc&uuml;\n */\npublic class SubstituteLoggerFactory implements ILoggerFactory {\n\n  // keep a record of requested logger names\n  final ConcurrentMap<String, SubstitutableLogger> loggers = new ConcurrentHashMap<String, SubstitutableLogger>();\n\n  public Logger getLogger(String name) {\n    SubstitutableLogger logger;\n    synchronized (loggers) {\n      logger = loggers.get(name);\n      if (logger == null) {\n        logger = new SubstitutableLogger(name);\n        loggers.put(name, logger);\n      }\n    }\n    return logger;\n  }\n\n  public List getLoggerNameList() {\n    return new ArrayList<String>(loggers.keySet());\n  }\n\n  public List<SubstitutableLogger> getLoggers() {\n    return new ArrayList<SubstitutableLogger>(loggers.values());\n  }\n\n  public void clear() {\n    loggers.clear();\n  }\n}\n","lineNo":47}
{"Refactored Sample":"/*\n * Copyright (c) 2004-2013 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.Logger;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * AndroidLoggerFactory is an implementation of {@link ILoggerFactory} returning\n * the appropriately named {@link AndroidLoggerFactory} instance.\n *\n * @author Andrey Korzhevskiy <a.korzhevskiy@gmail.com>\n */\nclass AndroidLoggerFactory implements ILoggerFactory {\n    static final String ANONYMOUS_TAG = \"null\";\n    static final int TAG_MAX_LENGTH = 23;\n\n    private final ConcurrentMap<String, Logger> loggerMap = new ConcurrentHashMap<String, Logger>();\n\n    /**\n     * Return an appropriate {@link AndroidLoggerAdapter} instance by name.\n     */\n    public Logger getLogger(String name) {\n        String tag = loggerNameToTag(name);\n        Logger logger = loggerMap.get(tag);\n        if (logger == null) {\n            Logger newInstance = new AndroidLoggerAdapter(tag);\n            Logger oldInstance = loggerMap.putIfAbsent(tag, newInstance);\n            logger = oldInstance == null ? newInstance : oldInstance;\n        }\n        return logger;\n    }\n\n    /**\n     * Tag names cannot be longer than {@value #TAG_MAX_LENGTH} characters on Android platform.\n     *\n     * Returns the short logger tag (up to {@value #TAG_MAX_LENGTH} characters) for the given logger name.\n     * Traditionally loggers are named by fully-qualified Java classes; this\n     * method attempts to return a concise identifying part of such names.\n     *\n     * See also:\n     * android/system/core/include/cutils/property.h\n     * android/frameworks/base/core/jni/android_util_Log.cpp\n     * dalvik.system.DalvikLogging\n     *\n     */\n    static String loggerNameToTag(String loggerName) {\n        // Anonymous logger\n        if (loggerName == null) {\n            return ANONYMOUS_TAG;\n        }\n\n        int length = loggerName.length();\n        if (length <= TAG_MAX_LENGTH) {\n            return loggerName;\n        }\n\n        int tagLength = 0;\n        int lastTokenIndex = 0;\n        int lastPeriodIndex;\n        StringBuilder tagName = new StringBuilder(TAG_MAX_LENGTH + 3);\n        while ((lastPeriodIndex = loggerName.indexOf('.', lastTokenIndex)) != -1) {\n            tagName.append(loggerName.charAt(lastTokenIndex));\n            // token of one character appended as is otherwise truncate it to one character\n            int tokenLength = lastPeriodIndex - lastTokenIndex;\n            if (tokenLength > 1) {\n                tagName.append('*');\n            }\n            tagName.append('.');\n            lastTokenIndex = lastPeriodIndex + 1;\n\n            // check if name is already too long\n            tagLength = tagName.length();\n            if (tagLength > TAG_MAX_LENGTH) {\n                return getSimpleName(loggerName);\n            }\n        }\n\n        // Either we had no useful dot location at all\n        // or last token would exceed TAG_MAX_LENGTH\n        int tokenLength = length - lastTokenIndex;\n        if (tagLength == 0 || (tagLength + tokenLength) > TAG_MAX_LENGTH) {\n            return getSimpleName(loggerName);\n        }\n\n        // last token (usually class name) appended as is\n        tagName.append(loggerName, lastTokenIndex, length);\n        return tagName.toString();\n    }\n\n    private static String getSimpleName(String loggerName) {\n        // Take leading part and append '*' to indicate that it was truncated\n        int length = loggerName.length();\n        int lastPeriodIndex = loggerName.lastIndexOf('.');\n        return lastPeriodIndex != -1 && length - (lastPeriodIndex + 1) <= TAG_MAX_LENGTH\n            ? loggerName.substring(lastPeriodIndex + 1)\n            : '*' + loggerName.substring(length - TAG_MAX_LENGTH + 1);\n    }\n}\n","Smelly Sample":"/*\n * Copyright (c) 2004-2013 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.Logger;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * AndroidLoggerFactory is an implementation of {@link ILoggerFactory} returning\n * the appropriately named {@link AndroidLoggerFactory} instance.\n *\n * @author Andrey Korzhevskiy <a.korzhevskiy@gmail.com>\n */\nclass AndroidLoggerFactory implements ILoggerFactory {\n    static final String ANONYMOUS_TAG = \"null\";\n    static final int TAG_MAX_LENGTH = 23;\n\n    private final ConcurrentMap<String, Logger> loggerMap = new ConcurrentHashMap<String, Logger>();\n\n\n    /**\n     * Return an appropriate {@link AndroidLoggerAdapter} instance by name.\n     */\n    public Logger getLogger(String name) {\n        String tag = loggerNameToTag(name);\n        Logger logger = loggerMap.get(tag);\n        if (logger == null) {\n            Logger newInstance = new AndroidLoggerAdapter(tag);\n            Logger oldInstance = loggerMap.putIfAbsent(tag, newInstance);\n            logger = oldInstance == null ? newInstance : oldInstance;\n        }\n        return logger;\n    }\n\n    /**\n     * Tag names cannot be longer than {@value #TAG_MAX_LENGTH} characters on Android platform.\n     *\n     * Returns the short logger tag (up to {@value #TAG_MAX_LENGTH} characters) for the given logger name.\n     * Traditionally loggers are named by fully-qualified Java classes; this\n     * method attempts to return a concise identifying part of such names.\n     *\n     * See also:\n     * android/system/core/include/cutils/property.h\n     * android/frameworks/base/core/jni/android_util_Log.cpp\n     * dalvik.system.DalvikLogging\n     *\n     */\n    static String loggerNameToTag(String loggerName) {\n        // Anonymous logger\n        if (loggerName == null) {\n            return ANONYMOUS_TAG;\n        }\n\n        int length = loggerName.length();\n        if (length <= TAG_MAX_LENGTH) {\n            return loggerName;\n        }\n\n        int lastTokenIndex = 0;\n        int lastPeriodIndex;\n        StringBuilder tagName = new StringBuilder();\n        while ((lastPeriodIndex = loggerName.indexOf('.', lastTokenIndex)) != -1) {\n            tagName.append(loggerName.charAt(lastTokenIndex));\n            // token of one character appended as is otherwise truncate it to one character\n            int tokenLength = lastPeriodIndex - lastTokenIndex;\n            if (tokenLength > 1) {\n                tagName.append('*');\n            }\n            tagName.append('.');\n            lastTokenIndex = lastPeriodIndex + 1;\n        }\n        // last token (usually class name) appended as is\n        tagName.append(loggerName, lastTokenIndex, length);\n        if (tagName.length() <= TAG_MAX_LENGTH) {\n            return tagName.toString();\n        }\n\n        // Either we had no useful dot location at all or name still too long.\n        // Take leading part and append '*' to indicate that it was truncated\n        lastPeriodIndex = loggerName.lastIndexOf('.');\n        return lastPeriodIndex != -1 && length - (lastPeriodIndex + 1) <= TAG_MAX_LENGTH\n                ? loggerName.substring(lastPeriodIndex + 1)\n                : '*' + loggerName.substring(length - TAG_MAX_LENGTH + 1);\n    }\n}\n","lineNo":83}
{"Refactored Sample":"/*\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.Logger;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * AndroidLoggerFactory is an implementation of {@link ILoggerFactory} returning\n * the appropriately named {@link AndroidLoggerFactory} instance.\n *\n * @author Andrey Korzhevskiy <a.korzhevskiy@gmail.com>\n */\npublic class AndroidLoggerFactory implements ILoggerFactory {\n    private final ConcurrentMap<String, Logger> loggerMap;\n\n    static final String ANONYMOUS_TAG = \"null\"; //taken from dalvik.system.DalvikLogging\n    static final int TAG_MAX_LENGTH = 23; // tag names cannot be longer on Android platform\n    // see also android/system/core/include/cutils/property.h\n    // and android/frameworks/base/core/jni/android_util_Log.cpp\n\n    public AndroidLoggerFactory() {\n        loggerMap = new ConcurrentHashMap<String, Logger>();\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.slf4j.ILoggerFactory#getLogger(java.lang.String)\n     */\n    public Logger getLogger(String name) {\n        String tag = loggerNameToTag(name); // fix for bug #173\n/*\n        if (name != null && !name.equals(tag)) {\n            Log.i(AndroidLoggerFactory.class.getSimpleName(),\n                    \"Logger name '\" + name + \"' exceeds maximum length of \" + TAG_MAX_LENGTH +\n                            \" characters, using '\" + tag + \"' instead.\");\n        }\n*/\n\n        Logger logger = loggerMap.get(tag);\n        if (logger == null) {\n            Logger newInstance = new AndroidLoggerAdapter(tag);\n            Logger oldInstance = loggerMap.putIfAbsent(tag, newInstance);\n            logger = oldInstance == null ? newInstance : oldInstance;\n        }\n        return logger;\n    }\n\n    /**\n     * Returns the short logger tag (up to {@value #TAG_MAX_LENGTH} chars) for the given logger name.\n     * Traditionally loggers are named by fully-qualified Java classes; this\n     * method attempts to return a concise identifying part of such names.\n     */\n    static String loggerNameToTag(String loggerName) {\n        // Anonymous logger\n        if (loggerName == null) {\n            return ANONYMOUS_TAG;\n        }\n\n        int length = loggerName.length();\n        if (length <= TAG_MAX_LENGTH) {\n            return loggerName;\n        }\n\n        int lastTokenIndex = 0;\n        int lastPeriodIndex;\n        StringBuilder tagName = new StringBuilder();\n        while ((lastPeriodIndex = loggerName.indexOf('.', lastTokenIndex)) != -1) {\n            tagName.append(loggerName.charAt(lastTokenIndex));\n            // token of one character appended as is otherwise truncate it to one character\n            int tokenLength = lastPeriodIndex - lastTokenIndex;\n            if (tokenLength > 1) {\n                tagName.append(\"*\");\n            }\n            tagName.append(\".\");\n            lastTokenIndex = lastPeriodIndex + 1;\n        }\n        // last token (usually class name) appended as is\n        tagName.append(loggerName, lastTokenIndex, length);\n        if (tagName.length() <= TAG_MAX_LENGTH) {\n            return tagName.toString();\n        }\n\n        // Either we had no useful dot location at all or name still too long.\n        // Take leading part and append '*' to indicate that it was truncated\n        lastPeriodIndex = loggerName.lastIndexOf(\".\");\n        return lastPeriodIndex != -1 && length - (lastPeriodIndex + 1) <= TAG_MAX_LENGTH\n                ? loggerName.substring(lastPeriodIndex + 1)\n                : \"*\" + loggerName.substring(length - TAG_MAX_LENGTH + 1);\n    }\n}\n","Smelly Sample":"/*\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport android.util.Log;\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.Logger;\n\nimport java.util.StringTokenizer;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * AndroidLoggerFactory is an implementation of {@link ILoggerFactory} returning\n * the appropriately named {@link AndroidLoggerFactory} instance.\n *\n * @author Andrey Korzhevskiy <a.korzhevskiy@gmail.com>\n */\npublic class AndroidLoggerFactory implements ILoggerFactory {\n    private final ConcurrentMap<String, Logger> loggerMap;\n\n    static final int TAG_MAX_LENGTH = 23; // tag names cannot be longer on Android platform\n    // see also android/system/core/include/cutils/property.h\n    // and android/frameworks/base/core/jni/android_util_Log.cpp\n\n    public AndroidLoggerFactory() {\n        loggerMap = new ConcurrentHashMap<String, Logger>();\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.slf4j.ILoggerFactory#getLogger(java.lang.String)\n     */\n    public Logger getLogger(String name) {\n        final String passedName = name;\n        name = forceValidName(passedName); // fix for bug #173\n        if (!passedName.equals(name)) {\n            Log.i(AndroidLoggerFactory.class.getSimpleName(),\n                    \"Logger name '\" + passedName + \"' exceeds maximum length of \" + TAG_MAX_LENGTH +\n                            \" characters, using '\" + name + \"' instead.\");\n        }\n\n        Logger logger = loggerMap.get(name);\n        if (logger == null) {\n            Logger newInstance = new AndroidLoggerAdapter(name);\n            Logger oldInstance = loggerMap.putIfAbsent(name, newInstance);\n            logger = oldInstance == null ? newInstance : oldInstance;\n        }\n        return logger;\n    }\n\n    /**\n     * Trim name in case it exceeds maximum length of {@value #TAG_MAX_LENGTH} characters.\n     */\n    private static String forceValidName(String name) {\n        if (name != null && name.length() > TAG_MAX_LENGTH) {\n            final StringTokenizer st = new StringTokenizer(name, \".\");\n            if (st.hasMoreTokens()) { // note that empty tokens are skipped, i.e., \"aa..bb\" has tokens \"aa\", \"bb\"\n                final StringBuilder sb = new StringBuilder();\n                String token;\n                do {\n                    token = st.nextToken();\n                    if (token.length() == 1) { // token of one character appended as is\n                        sb.append(token);\n                        sb.append('.');\n                    } else if (st.hasMoreTokens()) { // truncate all but the last token\n                        sb.append(token.charAt(0));\n                        sb.append(\"*.\");\n                    } else { // last token (usually class name) appended as is\n                        sb.append(token);\n                    }\n                } while (st.hasMoreTokens());\n\n                name = sb.toString();\n            }\n\n            // Either we had no useful dot location at all or name still too long.\n            // Take leading part and append '*' to indicate that it was truncated\n            if (name.length() > TAG_MAX_LENGTH) {\n                name = name.substring(0, TAG_MAX_LENGTH - 1) + '*';\n            }\n        }\n        return name;\n    }\n}\n","lineNo":57}
{"Refactored Sample":"/*\n * Copyright 2001-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.log4j;\n\nimport org.apache.log4j.spi.LoggerFactory;\nimport org.slf4j.helpers.Util;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * This class is a factory that creates and maintains org.apache.log4j.Loggers\n * wrapping org.slf4j.Loggers.\n *\n * It keeps a hashtable of all created org.apache.log4j.Logger instances so that\n * all newly created instances are not duplicates of existing loggers.\n *\n * @author S&eacute;bastien Pennec\n */\nclass Log4jLoggerFactory {\n\n  // String, Logger\n  private static ConcurrentMap<String, Logger> log4jLoggers = new ConcurrentHashMap<String, Logger>();\n\n  private static final String LOG4J_DELEGATION_LOOP_URL = \"http://www.slf4j.org/codes.html#log4jDelegationLoop\";\n\n  // check for delegation loops\n  static {\n    try {\n      Class.forName(\"org.slf4j.impl.Log4jLoggerFactory\");\n      String part1 = \"Detected both log4j-over-slf4j.jar AND slf4j-log4j12.jar on the class path, preempting StackOverflowError. \";\n      String part2 = \"See also \" + LOG4J_DELEGATION_LOOP_URL\n              + \" for more details.\";\n\n      Util.report(part1);\n      Util.report(part2);\n      throw new IllegalStateException(part1 + part2);\n    } catch (ClassNotFoundException e) {\n      // this is the good case\n    }\n  }\n\n  public static Logger getLogger(String name) {\n    org.apache.log4j.Logger instance = log4jLoggers.get(name);\n    if (instance != null) {\n      return instance;\n    } else {\n      Logger newInstance = new Logger(name);\n      Logger oldInstance = log4jLoggers.putIfAbsent(name, newInstance);\n      return oldInstance == null ? newInstance : oldInstance;\n    }\n  }\n\n  public static Logger getLogger(String name, LoggerFactory loggerFactory) {\n    org.apache.log4j.Logger instance = log4jLoggers.get(name);\n    if (instance != null) {\n      return instance;\n    } else {\n      Logger newInstance = loggerFactory.makeNewLoggerInstance(name);\n      Logger oldInstance = log4jLoggers.putIfAbsent(name, newInstance);\n      return oldInstance == null ? newInstance : oldInstance;\n    }\n  }\n}\n","Smelly Sample":"/*\n * Copyright 2001-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.log4j;\n\nimport java.util.Hashtable;\n\nimport org.apache.log4j.spi.LoggerFactory;\nimport org.slf4j.helpers.Util;\n\n/**\n * This class is a factory that creates and maintains org.apache.log4j.Loggers\n * wrapping org.slf4j.Loggers.\n * \n * It keeps a hashtable of all created org.apache.log4j.Logger instances so that\n * all newly created instances are not dulpicates of existing loggers.\n * \n * @author S&eacute;bastien Pennec\n */\nclass Log4jLoggerFactory {\n\n  // String, Logger\n  private static Hashtable log4jLoggers = new Hashtable();\n\n  private static final String LOG4J_DELEGATION_LOOP_URL = \"http://www.slf4j.org/codes.html#log4jDelegationLoop\";\n  \n  // check for delegation loops\n  static {\n    try {\n      Class.forName(\"org.slf4j.impl.Log4jLoggerFactory\");\n      String part1 = \"Detected both log4j-over-slf4j.jar AND slf4j-log4j12.jar on the class path, preempting StackOverflowError. \";\n      String part2 = \"See also \" + LOG4J_DELEGATION_LOOP_URL\n          + \" for more details.\";\n\n      Util.report(part1);\n      Util.report(part2);\n            throw new IllegalStateException(part1 + part2);\n    } catch (ClassNotFoundException e) {\n      // this is the good case\n    }\n  }\n\n  public static synchronized Logger getLogger(String name) {\n    if (log4jLoggers.containsKey(name)) {\n      return (org.apache.log4j.Logger) log4jLoggers.get(name);\n    } else {\n      Logger log4jLogger = new Logger(name);\n\n      log4jLoggers.put(name, log4jLogger);\n      return log4jLogger;\n    }\n  }\n  \n  public static synchronized Logger getLogger(String name, LoggerFactory loggerFactory) {\n\t  if (log4jLoggers.containsKey(name)) {\n\t\t  return (org.apache.log4j.Logger) log4jLoggers.get(name);\n\t  } else {\n\t\t  Logger log4jLogger = loggerFactory.makeNewLoggerInstance(name);\n\n\t\t  log4jLoggers.put(name, log4jLogger);\n\t\t  return log4jLogger;\n\t  }\n  }\n\n}\n","lineNo":58}
{"Refactored Sample":"/*\n * Copyright 2001-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.log4j;\n\nimport org.apache.log4j.spi.LoggerFactory;\nimport org.slf4j.helpers.Util;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * This class is a factory that creates and maintains org.apache.log4j.Loggers\n * wrapping org.slf4j.Loggers.\n *\n * It keeps a hashtable of all created org.apache.log4j.Logger instances so that\n * all newly created instances are not duplicates of existing loggers.\n *\n * @author S&eacute;bastien Pennec\n */\nclass Log4jLoggerFactory {\n\n  // String, Logger\n  private static ConcurrentMap<String, Logger> log4jLoggers = new ConcurrentHashMap<String, Logger>();\n\n  private static final String LOG4J_DELEGATION_LOOP_URL = \"http://www.slf4j.org/codes.html#log4jDelegationLoop\";\n\n  // check for delegation loops\n  static {\n    try {\n      Class.forName(\"org.slf4j.impl.Log4jLoggerFactory\");\n      String part1 = \"Detected both log4j-over-slf4j.jar AND slf4j-log4j12.jar on the class path, preempting StackOverflowError. \";\n      String part2 = \"See also \" + LOG4J_DELEGATION_LOOP_URL\n              + \" for more details.\";\n\n      Util.report(part1);\n      Util.report(part2);\n      throw new IllegalStateException(part1 + part2);\n    } catch (ClassNotFoundException e) {\n      // this is the good case\n    }\n  }\n\n  public static Logger getLogger(String name) {\n    org.apache.log4j.Logger instance = log4jLoggers.get(name);\n    if (instance != null) {\n      return instance;\n    } else {\n      Logger newInstance = new Logger(name);\n      Logger oldInstance = log4jLoggers.putIfAbsent(name, newInstance);\n      return oldInstance == null ? newInstance : oldInstance;\n    }\n  }\n\n  public static Logger getLogger(String name, LoggerFactory loggerFactory) {\n    org.apache.log4j.Logger instance = log4jLoggers.get(name);\n    if (instance != null) {\n      return instance;\n    } else {\n      Logger newInstance = loggerFactory.makeNewLoggerInstance(name);\n      Logger oldInstance = log4jLoggers.putIfAbsent(name, newInstance);\n      return oldInstance == null ? newInstance : oldInstance;\n    }\n  }\n}\n","Smelly Sample":"/*\n * Copyright 2001-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.log4j;\n\nimport java.util.Hashtable;\n\nimport org.apache.log4j.spi.LoggerFactory;\nimport org.slf4j.helpers.Util;\n\n/**\n * This class is a factory that creates and maintains org.apache.log4j.Loggers\n * wrapping org.slf4j.Loggers.\n * \n * It keeps a hashtable of all created org.apache.log4j.Logger instances so that\n * all newly created instances are not dulpicates of existing loggers.\n * \n * @author S&eacute;bastien Pennec\n */\nclass Log4jLoggerFactory {\n\n  // String, Logger\n  private static Hashtable log4jLoggers = new Hashtable();\n\n  private static final String LOG4J_DELEGATION_LOOP_URL = \"http://www.slf4j.org/codes.html#log4jDelegationLoop\";\n  \n  // check for delegation loops\n  static {\n    try {\n      Class.forName(\"org.slf4j.impl.Log4jLoggerFactory\");\n      String part1 = \"Detected both log4j-over-slf4j.jar AND slf4j-log4j12.jar on the class path, preempting StackOverflowError. \";\n      String part2 = \"See also \" + LOG4J_DELEGATION_LOOP_URL\n          + \" for more details.\";\n\n      Util.report(part1);\n      Util.report(part2);\n            throw new IllegalStateException(part1 + part2);\n    } catch (ClassNotFoundException e) {\n      // this is the good case\n    }\n  }\n\n  public static synchronized Logger getLogger(String name) {\n    if (log4jLoggers.containsKey(name)) {\n      return (org.apache.log4j.Logger) log4jLoggers.get(name);\n    } else {\n      Logger log4jLogger = new Logger(name);\n\n      log4jLoggers.put(name, log4jLogger);\n      return log4jLogger;\n    }\n  }\n  \n  public static synchronized Logger getLogger(String name, LoggerFactory loggerFactory) {\n\t  if (log4jLoggers.containsKey(name)) {\n\t\t  return (org.apache.log4j.Logger) log4jLoggers.get(name);\n\t  } else {\n\t\t  Logger log4jLogger = loggerFactory.makeNewLoggerInstance(name);\n\n\t\t  log4jLoggers.put(name, log4jLogger);\n\t\t  return log4jLogger;\n\t  }\n  }\n\n}\n","lineNo":69}
{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.log4j;\n\nimport org.slf4j.MDC;\n\nimport java.util.Stack;\n\n/**\n * A log4j's NDC implemented in terms of SLF4J MDC primitives.\n *\n * @since SLF4J 1.6.0\n */\n\npublic class NDC {\n\n  public final static String PREFIX = \"NDC\";\n\n  public static void clear() {\n    int depth = getDepth();\n    for (int i = 0; i < depth; i++) {\n      String key = PREFIX + i;\n      MDC.remove(key);\n    }\n  }\n\n  public static Stack cloneStack() {\n    return null;\n  }\n\n  public static void inherit(Stack stack) {\n  }\n\n  static public String get() {\n    return null;\n  }\n\n  public static int getDepth() {\n    int i = 0;\n    while (true) {\n      String val = MDC.get(PREFIX + i);\n      if (val != null) {\n        i++;\n      } else {\n        break;\n      }\n    }\n    return i;\n  }\n\n  public static String pop() {\n    int next = getDepth();\n    if (next == 0) {\n      return \"\";\n    }\n    int last = next - 1;\n    String key = PREFIX + last;\n    String val = MDC.get(key);\n    MDC.remove(key);\n    return val;\n  }\n\n  public static String peek() {\n    int next = getDepth();\n    if (next == 0) {\n      return \"\";\n    }\n    int last = next - 1;\n    String key = PREFIX + last;\n    String val = MDC.get(key);\n    return val;\n  }\n\n  public static void push(String message) {\n    int next = getDepth();\n    MDC.put(PREFIX + next, message);\n  }\n\n  static public void remove() {\n    clear();\n  }\n\n  static public void setMaxDepth(int maxDepth) {\n  }\n\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.log4j;\n\nimport java.util.Stack;\n\n/**\n * A bare-bones implementation of log4j's NDC which compiles and prevents run\n * time exceptions.\n * \n * @since SLF4J 1.6.0\n */\n\npublic class NDC {\n\n  public static void clear() {\n  }\n\n  public static Stack cloneStack() {\n    return null;\n  }\n\n  public static void inherit(Stack stack) {\n  }\n\n  static public String get() {\n    return null;\n  }\n\n  public static int getDepth() {\n    return 0;\n  }\n\n  public static String pop() {\n    return \"\";\n  }\n\n  public static String peek() {\n    return \"\";\n  }\n\n  public static void push(String message) {\n  }\n\n  static public void remove() {\n  }\n\n  static public void setMaxDepth(int maxDepth) {\n  }\n\n}\n","lineNo":54}
{"Refactored Sample":"package org.slf4j.helpers;\n\nimport java.text.MessageFormat;\n\nimport junit.framework.TestCase;\n\npublic class MessageFormatterPerfTest extends TestCase {\n\n  Integer i1 = new Integer(1);\n  Integer i2 = new Integer(2);\n  static long RUN_LENGTH = 200 * 1000;\n  // \n  static long REFERENCE_BIPS = 48416;\n\n  public MessageFormatterPerfTest(String name) {\n    super(name);\n  }\n\n  protected void setUp() throws Exception {\n  }\n\n  protected void tearDown() throws Exception {\n  }\n\n  public void XtestJDKFormatterPerf() {\n    jdkMessageFormatter(RUN_LENGTH);\n    double duration = jdkMessageFormatter(RUN_LENGTH);\n    System.out.println(\"jdk duration = \" + duration + \" nanos\");\n  }\n\n  public void testSLF4JPerf_OneArg() {\n    slf4jMessageFormatter_OneArg(RUN_LENGTH);\n    double duration = slf4jMessageFormatter_OneArg(RUN_LENGTH);\n    System.out.println(\"duration=\" + duration);\n    long referencePerf = 72;\n    BogoPerf.assertDuration(duration, referencePerf, REFERENCE_BIPS);\n  }\n\n  public void testSLF4JPerf_TwoArg() {\n    slf4jMessageFormatter_TwoArg(RUN_LENGTH);\n    double duration = slf4jMessageFormatter_TwoArg(RUN_LENGTH);\n    System.out.println(\"duration2=\" + duration);\n    long referencePerf = 120;\n    BogoPerf.assertDuration(duration, referencePerf, REFERENCE_BIPS);\n  }\n\n  public double slf4jMessageFormatter_OneArg(long len) {\n    long start = System.nanoTime();\n    for (int i = 0; i < len; i++) {\n      final FormattingTuple tp = MessageFormatter.format(\n          \"This is some rather short message {} \", i1);\n      tp.getMessage();\n      tp.getArgArray();\n      tp.getThrowable();\n    }\n    long end = System.nanoTime();\n    return (end - start) / (1000 * 1000.0);\n  }\n\n  public double slf4jMessageFormatter_TwoArg(long len) {\n    String s = \"\";\n    s += \"\"; // keep compiler happy\n    long start = System.nanoTime();\n    for (int i = 0; i < len; i++) {\n      final FormattingTuple tp = MessageFormatter.format(\n          \"This is some {} short message {} \", i1, i2);\n      tp.getMessage();\n      tp.getArgArray();\n      tp.getThrowable();\n    }\n    long end = System.nanoTime();\n    return (end - start) / (1000 * 1000.0);\n  }\n\n  public double jdkMessageFormatter(long len) {\n    String s = \"\";\n    s += \"\"; // keep compiler happy\n    long start = System.currentTimeMillis();\n    Object[] oa = new Object[] { i1 };\n    for (int i = 0; i < len; i++) {\n      s = MessageFormat.format(\"This is some rather short message {0}\", oa);\n    }\n    long end = System.currentTimeMillis();\n    return (1.0 * end - start);\n  }\n\n}\n","Smelly Sample":"package org.slf4j.helpers;\n\nimport java.text.MessageFormat;\n\nimport junit.framework.TestCase;\n\npublic class MessageFormatterPerfTest extends TestCase {\n\n  Integer i1 = new Integer(1);\n  static long RUN_LENGTH = 100000;\n  static long REFERENCE_BIPS = 9000;\n\n  public MessageFormatterPerfTest(String name) {\n    super(name);\n  }\n\n  protected void setUp() throws Exception {\n  }\n\n  protected void tearDown() throws Exception {\n  }\n\n  public void XtestJDKFormatterPerf() {\n    jdkMessageFormatter(RUN_LENGTH);\n    double duration = jdkMessageFormatter(RUN_LENGTH);\n    System.out.println(\"jdk duration = \" + duration + \" nanos\");\n  }\n\n  public void testSLF4JPerf() {\n    slf4jMessageFormatter(RUN_LENGTH);\n    double duration = slf4jMessageFormatter(RUN_LENGTH);\n    long referencePerf = 140;\n    System.out.println(\"duration=\"+duration);\n    BogoPerf.assertDuration(duration, referencePerf, REFERENCE_BIPS);\n  }\n\n  public double slf4jMessageFormatter(long len) {\n    String s = \"\";\n    s += \"\"; // keep compiler happy\n    long start = System.nanoTime();\n    for (int i = 0; i < len; i++) {\n      s = MessageFormatter.format(\"This is some rather short message {} \", i1)\n          .getMessage();\n    }\n    long end = System.nanoTime();\n    return (end - start)/(1000*1000.0);\n  }\n\n  public double jdkMessageFormatter(long len) {\n    String s = \"\";\n    s += \"\"; // keep compiler happy\n    long start = System.currentTimeMillis();\n    Object[] oa = new Object[] { i1 };\n    for (int i = 0; i < len; i++) {\n      s = MessageFormat.format(\"This is some rather short message {0}\", oa);\n    }\n    long end = System.currentTimeMillis();\n    return (1.0 * end - start);\n  }\n\n}\n","lineNo":50}
{"Refactored Sample":"/*\n * Copyright (c) 2004-2008 QOS.ch\n * All rights reserved.\n * \n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n * \n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n * \n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage org.slf4j;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.List;\n\nimport org.slf4j.helpers.SubstituteLoggerFactory;\nimport org.slf4j.helpers.Util;\nimport org.slf4j.impl.StaticLoggerBinder;\n\n/**\n * The <code>LoggerFactory<\/code> is a utility class producing Loggers for\n * various logging APIs, most notably for log4j, logback and JDK 1.4 logging.\n * Other implementations such as {@link org.slf4j.impl.NOPLogger NOPLogger} and\n * {@link org.slf4j.impl.SimpleLogger SimpleLogger} are also supported.\n * \n * <p>\n * <code>LoggerFactory<\/code> is essentially a wrapper around an\n * {@link ILoggerFactory} instance bound with <code>LoggerFactory<\/code> at\n * compile time.\n * \n * <p>\n * Please note that all methods in <code>LoggerFactory<\/code> are static.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Robert Elliot\n */\npublic final class LoggerFactory {\n\n  static final String NO_STATICLOGGERBINDER_URL = \"http://www.slf4j.org/codes.html#StaticLoggerBinder\";\n  static final String MULTIPLE_BINDINGS_URL = \"http://www.slf4j.org/codes.html#multiple_bindings\";\n  static final String NULL_LF_URL = \"http://www.slf4j.org/codes.html#null_LF\";\n  static final String VERSION_MISMATCH = \"http://www.slf4j.org/codes.html#version_mismatch\";\n  static final String SUBSTITUTE_LOGGER_URL = \"http://www.slf4j.org/codes.html#substituteLogger\";\n\n  static final String UNSUCCESSFUL_INIT_URL = \"http://www.slf4j.org/codes.html#unsuccessfulInit\";\n  static final String UNSUCCESSFUL_INIT_MSG = \"org.slf4j.LoggerFactory could not be successfully initialized. See also \"\n      + UNSUCCESSFUL_INIT_URL;\n\n  static final int UNINITIALIZED = 0;\n  static final int ONGOING_INITILIZATION = 1;\n  static final int FAILED_INITILIZATION = 2;\n  static final int SUCCESSFUL_INITILIZATION = 3;\n\n  static final int GET_SINGLETON_INEXISTENT = 1;\n  static final int GET_SINGLETON_EXISTS = 2;\n\n  static int INITIALIZATION_STATE = UNINITIALIZED;\n  static int GET_SINGLETON_METHOD = UNINITIALIZED;\n  static SubstituteLoggerFactory TEMP_FACTORY = new SubstituteLoggerFactory();\n\n  /**\n   * It is our responsibility to track version changes and manage the\n   * compatibility list.\n   * \n   * <p>\n   */\n  static private final String[] API_COMPATIBILITY_LIST = new String[] {\n      \"1.5.5\", \"1.5.6\", \"1.5.7\", \"1.5.8\", \"1.5.9\" };\n\n  // private constructor prevents instantiation\n  private LoggerFactory() {\n  }\n\n  /**\n   * Force LoggerFactory to consider itself uninitialized.\n   * \n   * <p>\n   * This method is intended to be called by classes (in the same package) for\n   * testing purposes. This method is internal. It can be modified, renamed or\n   * removed at any time without notice.\n   * \n   * <p>\n   * You are strongly discouraged from calling this method in production code.\n   */\n  static void reset() {\n    INITIALIZATION_STATE = UNINITIALIZED;\n    GET_SINGLETON_METHOD = UNINITIALIZED;\n    TEMP_FACTORY = new SubstituteLoggerFactory();\n  }\n\n  private final static void performInitialization() {\n    bind();\n    versionSanityCheck();\n    singleImplementationSanityCheck();\n\n  }\n\n  private final static void bind() {\n    try {\n      // the next line does the binding\n      getSingleton();\n      INITIALIZATION_STATE = SUCCESSFUL_INITILIZATION;\n      emitSubstituteLoggerWarning();\n    } catch (NoClassDefFoundError ncde) {\n      INITIALIZATION_STATE = FAILED_INITILIZATION;\n      String msg = ncde.getMessage();\n      if (msg != null && msg.indexOf(\"org/slf4j/impl/StaticLoggerBinder\") != -1) {\n        Util\n            .reportFailure(\"Failed to load class \\\"org.slf4j.impl.StaticLoggerBinder\\\".\");\n        Util.reportFailure(\"See \" + NO_STATICLOGGERBINDER_URL\n            + \" for further details.\");\n\n      }\n      throw ncde;\n    } catch (Exception e) {\n      INITIALIZATION_STATE = FAILED_INITILIZATION;\n      // we should never get here\n      Util.reportFailure(\"Failed to instantiate logger [\"\n          + getSingleton().getLoggerFactoryClassStr() + \"]\", e);\n    }\n  }\n\n  private final static void emitSubstituteLoggerWarning() {\n    List loggerNameList = TEMP_FACTORY.getLoggerNameList();\n    if (loggerNameList.size() == 0) {\n      return;\n    }\n    Util\n        .reportFailure(\"The following loggers will not work becasue they were created\");\n    Util\n        .reportFailure(\"during the default configuration phase of the underlying logging system.\");\n    Util.reportFailure(\"See also \" + SUBSTITUTE_LOGGER_URL);\n    for (int i = 0; i < loggerNameList.size(); i++) {\n      String loggerName = (String) loggerNameList.get(i);\n      Util.reportFailure(loggerName);\n    }\n  }\n\n  private final static void versionSanityCheck() {\n    try {\n      String requested = StaticLoggerBinder.REQUESTED_API_VERSION;\n\n      boolean match = false;\n      for (int i = 0; i < API_COMPATIBILITY_LIST.length; i++) {\n        if (API_COMPATIBILITY_LIST[i].equals(requested)) {\n          match = true;\n        }\n      }\n      if (!match) {\n        Util.reportFailure(\"The requested version \" + requested\n            + \" by your slf4j binding is not compatible with \"\n            + Arrays.asList(API_COMPATIBILITY_LIST).toString());\n        Util.reportFailure(\"See \" + VERSION_MISMATCH + \" for further details.\");\n      }\n    } catch (java.lang.NoSuchFieldError nsfe) {\n      // given our large user base and SLF4J's commitment to backward\n      // compatibility, we cannot cry here. Only for implementations\n      // which willingly declare a REQUESTED_API_VERSION field do we\n      // emit compatibility warnings.\n    } catch (Throwable e) {\n      // we should never reach here\n      Util.reportFailure(\n          \"Unexpected problem occured during version sanity check\", e);\n    }\n  }\n\n  // We need to use the name of the StaticLoggerBinder class, we can't reference\n  // the class itseld.\n  private static String STATIC_LOGGER_BINDER_PATH = \"org/slf4j/impl/StaticLoggerBinder.class\";\n\n  private static void singleImplementationSanityCheck() {\n    try {\n      ClassLoader loggerFactoryClassLoader = LoggerFactory.class.getClassLoader();\n      if(loggerFactoryClassLoader == null) {\n        // see http://bugzilla.slf4j.org/show_bug.cgi?id=146\n        return; // better than a null pointer exception\n      }\n      Enumeration paths = loggerFactoryClassLoader.getResources(\n          STATIC_LOGGER_BINDER_PATH);\n      List implementationList = new ArrayList();\n      while (paths.hasMoreElements()) {\n        URL path = (URL) paths.nextElement();\n        implementationList.add(path);\n      }\n      if (implementationList.size() > 1) {\n        Util\n            .reportFailure(\"Class path contains multiple SLF4J bindings.\");\n        for(int i = 0; i < implementationList.size(); i++) {\n          Util.reportFailure(\"Found binding in [\"+implementationList.get(i)+\"]\");\n        }\n        Util.reportFailure(\"See \" + MULTIPLE_BINDINGS_URL\n            + \" for an explanation.\");\n      }\n    } catch (IOException ioe) {\n      Util.reportFailure(\"Error getting resources from path\", ioe);\n    }\n  }\n\n  private final static StaticLoggerBinder getSingleton() {\n    if (GET_SINGLETON_METHOD == GET_SINGLETON_INEXISTENT) {\n      return StaticLoggerBinder.SINGLETON;\n    }\n\n    if (GET_SINGLETON_METHOD == GET_SINGLETON_EXISTS) {\n      return StaticLoggerBinder.getSingleton();\n    }\n\n    try {\n      StaticLoggerBinder singleton = StaticLoggerBinder.getSingleton();\n      GET_SINGLETON_METHOD = GET_SINGLETON_EXISTS;\n      return singleton;\n    } catch (NoSuchMethodError nsme) {\n      GET_SINGLETON_METHOD = GET_SINGLETON_INEXISTENT;\n      return StaticLoggerBinder.SINGLETON;\n    }\n\n  }\n\n  /**\n   * Return a logger named according to the name parameter using the statically\n   * bound {@link ILoggerFactory} instance.\n   * \n   * @param name\n   *                The name of the logger.\n   * @return logger\n   */\n  public static Logger getLogger(String name) {\n    ILoggerFactory iLoggerFactory = getILoggerFactory();\n    return iLoggerFactory.getLogger(name);\n  }\n\n  /**\n   * Return a logger named corresponding to the class passed as parameter, using\n   * the statically bound {@link ILoggerFactory} instance.\n   * \n   * @param clazz\n   *                the returned logger will be named after clazz\n   * @return logger\n   */\n  public static Logger getLogger(Class clazz) {\n    return getLogger(clazz.getName());\n  }\n\n  /**\n   * Return the {@link ILoggerFactory} instance in use.\n   * \n   * <p>\n   * ILoggerFactory instance is bound with this class at compile time.\n   * \n   * @return the ILoggerFactory instance in use\n   */\n  public static ILoggerFactory getILoggerFactory() {\n    if (INITIALIZATION_STATE == UNINITIALIZED) {\n      INITIALIZATION_STATE = ONGOING_INITILIZATION;\n      performInitialization();\n\n    }\n    switch (INITIALIZATION_STATE) {\n    case SUCCESSFUL_INITILIZATION:\n      return getSingleton().getLoggerFactory();\n    case FAILED_INITILIZATION:\n      throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);\n    case ONGOING_INITILIZATION:\n      // support re-entrant behavior.\n      // See also http://bugzilla.slf4j.org/show_bug.cgi?id=106\n      return TEMP_FACTORY;\n    }\n    throw new IllegalStateException(\"Unreachable code\");\n  }\n}\n","Smelly Sample":"/*\n * Copyright (c) 2004-2008 QOS.ch\n * All rights reserved.\n * \n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n * \n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n * \n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage org.slf4j;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.List;\n\nimport org.slf4j.helpers.SubstituteLoggerFactory;\nimport org.slf4j.helpers.Util;\nimport org.slf4j.impl.StaticLoggerBinder;\n\n/**\n * The <code>LoggerFactory<\/code> is a utility class producing Loggers for\n * various logging APIs, most notably for log4j, logback and JDK 1.4 logging.\n * Other implementations such as {@link org.slf4j.impl.NOPLogger NOPLogger} and\n * {@link org.slf4j.impl.SimpleLogger SimpleLogger} are also supported.\n * \n * <p>\n * <code>LoggerFactory<\/code> is essentially a wrapper around an\n * {@link ILoggerFactory} instance bound with <code>LoggerFactory<\/code> at\n * compile time.\n * \n * <p>\n * Please note that all methods in <code>LoggerFactory<\/code> are static.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @author Robert Elliot\n */\npublic final class LoggerFactory {\n\n  static final String NO_STATICLOGGERBINDER_URL = \"http://www.slf4j.org/codes.html#StaticLoggerBinder\";\n  static final String MULTIPLE_BINDINGS_URL = \"http://www.slf4j.org/codes.html#multiple_bindings\";\n  static final String NULL_LF_URL = \"http://www.slf4j.org/codes.html#null_LF\";\n  static final String VERSION_MISMATCH = \"http://www.slf4j.org/codes.html#version_mismatch\";\n  static final String SUBSTITUTE_LOGGER_URL = \"http://www.slf4j.org/codes.html#substituteLogger\";\n\n  static final String UNSUCCESSFUL_INIT_URL = \"http://www.slf4j.org/codes.html#unsuccessfulInit\";\n  static final String UNSUCCESSFUL_INIT_MSG = \"org.slf4j.LoggerFactory could not be successfully initialized. See also \"\n      + UNSUCCESSFUL_INIT_URL;\n\n  static final int UNINITIALIZED = 0;\n  static final int ONGOING_INITILIZATION = 1;\n  static final int FAILED_INITILIZATION = 2;\n  static final int SUCCESSFUL_INITILIZATION = 3;\n\n  static final int GET_SINGLETON_INEXISTENT = 1;\n  static final int GET_SINGLETON_EXISTS = 2;\n\n  static int INITIALIZATION_STATE = UNINITIALIZED;\n  static int GET_SINGLETON_METHOD = UNINITIALIZED;\n  static SubstituteLoggerFactory TEMP_FACTORY = new SubstituteLoggerFactory();\n\n  /**\n   * It is our responsibility to track version changes and manage the\n   * compatibility list.\n   * \n   * <p>\n   */\n  static private final String[] API_COMPATIBILITY_LIST = new String[] {\n      \"1.5.5\", \"1.5.6\", \"1.5.7\", \"1.5.8\", \"1.5.9\" };\n\n  // private constructor prevents instantiation\n  private LoggerFactory() {\n  }\n\n  /**\n   * Force LoggerFactory to consider itself uninitialized.\n   * \n   * <p>\n   * This method is intended to be called by classes (in the same package) for\n   * testing purposes. This method is internal. It can be modified, renamed or\n   * removed at any time without notice.\n   * \n   * <p>\n   * You are strongly discouraged from calling this method in production code.\n   */\n  static void reset() {\n    INITIALIZATION_STATE = UNINITIALIZED;\n    GET_SINGLETON_METHOD = UNINITIALIZED;\n    TEMP_FACTORY = new SubstituteLoggerFactory();\n  }\n\n  private final static void performInitialization() {\n    bind();\n    versionSanityCheck();\n    singleImplementationSanityCheck();\n\n  }\n\n  private final static void bind() {\n    try {\n      // the next line does the binding\n      getSingleton();\n      INITIALIZATION_STATE = SUCCESSFUL_INITILIZATION;\n      emitSubstituteLoggerWarning();\n    } catch (NoClassDefFoundError ncde) {\n      INITIALIZATION_STATE = FAILED_INITILIZATION;\n      String msg = ncde.getMessage();\n      if (msg != null && msg.indexOf(\"org/slf4j/impl/StaticLoggerBinder\") != -1) {\n        Util\n            .reportFailure(\"Failed to load class \\\"org.slf4j.impl.StaticLoggerBinder\\\".\");\n        Util.reportFailure(\"See \" + NO_STATICLOGGERBINDER_URL\n            + \" for further details.\");\n\n      }\n      throw ncde;\n    } catch (Exception e) {\n      INITIALIZATION_STATE = FAILED_INITILIZATION;\n      // we should never get here\n      Util.reportFailure(\"Failed to instantiate logger [\"\n          + getSingleton().getLoggerFactoryClassStr() + \"]\", e);\n    }\n  }\n\n  private final static void emitSubstituteLoggerWarning() {\n    List loggerNameList = TEMP_FACTORY.getLoggerNameList();\n    if (loggerNameList.size() == 0) {\n      return;\n    }\n    Util\n        .reportFailure(\"The following loggers will not work becasue they were created\");\n    Util\n        .reportFailure(\"during the default configuration phase of the underlying logging system.\");\n    Util.reportFailure(\"See also \" + SUBSTITUTE_LOGGER_URL);\n    for (int i = 0; i < loggerNameList.size(); i++) {\n      String loggerName = (String) loggerNameList.get(i);\n      Util.reportFailure(loggerName);\n    }\n  }\n\n  private final static void versionSanityCheck() {\n    try {\n      String requested = StaticLoggerBinder.REQUESTED_API_VERSION;\n\n      boolean match = false;\n      for (int i = 0; i < API_COMPATIBILITY_LIST.length; i++) {\n        if (API_COMPATIBILITY_LIST[i].equals(requested)) {\n          match = true;\n        }\n      }\n      if (!match) {\n        Util.reportFailure(\"The requested version \" + requested\n            + \" by your slf4j binding is not compatible with \"\n            + Arrays.asList(API_COMPATIBILITY_LIST).toString());\n        Util.reportFailure(\"See \" + VERSION_MISMATCH + \" for further details.\");\n      }\n    } catch (java.lang.NoSuchFieldError nsfe) {\n      // given our large user base and SLF4J's commitment to backward\n      // compatibility, we cannot cry here. Only for implementations\n      // which willingly declare a REQUESTED_API_VERSION field do we\n      // emit compatibility warnings.\n    } catch (Throwable e) {\n      // we should never reach here\n      Util.reportFailure(\n          \"Unexpected problem occured during version sanity check\", e);\n    }\n  }\n\n  // We need to use the name of the StaticLoggerBinder class, we can't reference\n  // the class itseld.\n  private static String STATIC_LOGGER_BINDER_PATH = \"org/slf4j/impl/StaticLoggerBinder.class\";\n\n  private static void singleImplementationSanityCheck() {\n    try {\n      Enumeration paths = LoggerFactory.class.getClassLoader().getResources(\n          STATIC_LOGGER_BINDER_PATH);\n      List implementationList = new ArrayList();\n      while (paths.hasMoreElements()) {\n        URL path = (URL) paths.nextElement();\n        implementationList.add(path);\n      }\n      if (implementationList.size() > 1) {\n        Util\n            .reportFailure(\"Class path contains multiple SLF4J bindings.\");\n        for(int i = 0; i < implementationList.size(); i++) {\n          Util.reportFailure(\"Found binding in [\"+implementationList.get(i)+\"]\");\n        }\n        Util.reportFailure(\"See \" + MULTIPLE_BINDINGS_URL\n            + \" for an explanation.\");\n      }\n    } catch (IOException ioe) {\n      Util.reportFailure(\"Error getting resources from path\", ioe);\n    }\n  }\n\n  private final static StaticLoggerBinder getSingleton() {\n    if (GET_SINGLETON_METHOD == GET_SINGLETON_INEXISTENT) {\n      return StaticLoggerBinder.SINGLETON;\n    }\n\n    if (GET_SINGLETON_METHOD == GET_SINGLETON_EXISTS) {\n      return StaticLoggerBinder.getSingleton();\n    }\n\n    try {\n      StaticLoggerBinder singleton = StaticLoggerBinder.getSingleton();\n      GET_SINGLETON_METHOD = GET_SINGLETON_EXISTS;\n      return singleton;\n    } catch (NoSuchMethodError nsme) {\n      GET_SINGLETON_METHOD = GET_SINGLETON_INEXISTENT;\n      return StaticLoggerBinder.SINGLETON;\n    }\n\n  }\n\n  /**\n   * Return a logger named according to the name parameter using the statically\n   * bound {@link ILoggerFactory} instance.\n   * \n   * @param name\n   *                The name of the logger.\n   * @return logger\n   */\n  public static Logger getLogger(String name) {\n    ILoggerFactory iLoggerFactory = getILoggerFactory();\n    return iLoggerFactory.getLogger(name);\n  }\n\n  /**\n   * Return a logger named corresponding to the class passed as parameter, using\n   * the statically bound {@link ILoggerFactory} instance.\n   * \n   * @param clazz\n   *                the returned logger will be named after clazz\n   * @return logger\n   */\n  public static Logger getLogger(Class clazz) {\n    return getLogger(clazz.getName());\n  }\n\n  /**\n   * Return the {@link ILoggerFactory} instance in use.\n   * \n   * <p>\n   * ILoggerFactory instance is bound with this class at compile time.\n   * \n   * @return the ILoggerFactory instance in use\n   */\n  public static ILoggerFactory getILoggerFactory() {\n    if (INITIALIZATION_STATE == UNINITIALIZED) {\n      INITIALIZATION_STATE = ONGOING_INITILIZATION;\n      performInitialization();\n\n    }\n    switch (INITIALIZATION_STATE) {\n    case SUCCESSFUL_INITILIZATION:\n      return getSingleton().getLoggerFactory();\n    case FAILED_INITILIZATION:\n      throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);\n    case ONGOING_INITILIZATION:\n      // support re-entrant behavior.\n      // See also http://bugzilla.slf4j.org/show_bug.cgi?id=106\n      return TEMP_FACTORY;\n    }\n    throw new IllegalStateException(\"Unreachable code\");\n  }\n}\n","lineNo":191}
{"Refactored Sample":"/* \n * Copyright (c) 2004-2007 QOS.ch\n * All rights reserved.\n * \n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n * \n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n * \n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage org.slf4j.helpers;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n// contributors: lizongbo: proposed special treatment of array parameter values\n// Jrn Huxhorn: pointed out double[] omission, suggested deep array copy\n/**\n * Formats messages according to very simple substitution rules. Substitutions\n * can be made 1, 2 or more arguments.\n * <p>\n * For example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Hi {}.&quot;, &quot;there&quot;)\n * <\/pre>\n * \n * will return the string \"Hi there.\".\n * <p>\n * The {} pair is called the <em>formatting anchor<\/em>. It serves to\n * designate the location where arguments need to be substituted within the\n * message pattern.\n * <p>\n * In case your message contains the '{' or the '}' character, you do not have\n * to do anything special unless the '}' character immediately follows '{'. For\n * example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Set {1,2,3} is not equal to {}.&quot;, &quot;1,2&quot;);\n * <\/pre>\n * \n * will return the string \"Set {1,2,3} is not equal to 1,2.\".\n * \n * <p>\n * If for whatever reason you need to place the string \"{}\" in the message\n * without its <em>formatting anchor<\/em> meaning, then you need to escape the\n * '{' character with '\\', that is the backslash character. Only the '{'\n * character should be escaped. There is no need to escape the '}' character.\n * For example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Set \\\\{} is not equal to {}.&quot;, &quot;1,2&quot;);\n * <\/pre>\n * \n * will return the string \"Set {} is not equal to 1,2.\".\n * \n * <p>\n * The escaping behavior just described can be overridden by escaping the escape\n * character '\\'. Calling\n * \n * <pre>\n * MessageFormatter.format(&quot;File name is C:\\\\\\\\{}.&quot;, &quot;file.zip&quot;);\n * <\/pre>\n * \n * will return the string \"File name is C:\\file.zip\".\n * \n * <p>\n * See {@link #format(String, Object)}, {@link #format(String, Object, Object)}\n * and {@link #arrayFormat(String, Object[])} methods for more details.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\nfinal public class MessageFormatter {\n  static final char DELIM_START = '{';\n  static final char DELIM_STOP = '}';\n  static final String DELIM_STR = \"{}\";\n  private static final char ESCAPE_CHAR = '\\\\';\n\n  /**\n   * Performs single argument substitution for the 'messagePattern' passed as\n   * parameter.\n   * <p>\n   * For example,\n   * \n   * <pre>\n   * MessageFormatter.format(&quot;Hi {}.&quot;, &quot;there&quot;);\n   * <\/pre>\n   * \n   * will return the string \"Hi there.\".\n   * <p>\n   * \n   * @param messagePattern\n   *                The message pattern which will be parsed and formatted\n   * @param argument\n   *                The argument to be substituted in place of the formatting\n   *                anchor\n   * @return The formatted message\n   */\n  final public static String format(String messagePattern, Object arg) {\n    return arrayFormat(messagePattern, new Object[] { arg });\n  }\n\n  /**\n   * \n   * Performs a two argument substitution for the 'messagePattern' passed as\n   * parameter.\n   * <p>\n   * For example,\n   * \n   * <pre>\n   * MessageFormatter.format(&quot;Hi {}. My name is {}.&quot;, &quot;Alice&quot;, &quot;Bob&quot;);\n   * <\/pre>\n   * \n   * will return the string \"Hi Alice. My name is Bob.\".\n   * \n   * @param messagePattern\n   *                The message pattern which will be parsed and formatted\n   * @param arg1\n   *                The argument to be substituted in place of the first\n   *                formatting anchor\n   * @param arg2\n   *                The argument to be substituted in place of the second\n   *                formatting anchor\n   * @return The formatted message\n   */\n  final public static String format(final String messagePattern, Object arg1,\n      Object arg2) {\n    return arrayFormat(messagePattern, new Object[] { arg1, arg2 });\n  }\n\n  /**\n   * Same principle as the {@link #format(String, Object)} and\n   * {@link #format(String, Object, Object)} methods except that any number of\n   * arguments can be passed in an array.\n   * \n   * @param messagePattern\n   *                The message pattern which will be parsed and formatted\n   * @param argArray\n   *                An array of arguments to be substituted in place of\n   *                formatting anchors\n   * @return The formatted message\n   */\n  final public static String arrayFormat(final String messagePattern,\n      final Object[] argArray) {\n    if (messagePattern == null) {\n      return null;\n    }\n    if (argArray == null) {\n      return messagePattern;\n    }\n    int i = 0;\n    int j;\n    StringBuffer sbuf = new StringBuffer(messagePattern.length() + 50);\n\n    for (int L = 0; L < argArray.length; L++) {\n\n      j = messagePattern.indexOf(DELIM_STR, i);\n\n      if (j == -1) {\n        // no more variables\n        if (i == 0) { // this is a simple string\n          return messagePattern;\n        } else { // add the tail string which contains no variables and return\n          // the result.\n          sbuf.append(messagePattern.substring(i, messagePattern.length()));\n          return sbuf.toString();\n        }\n      } else {\n        if (isEscapedDelimeter(messagePattern, j)) {\n          if (!isDoubleEscaped(messagePattern, j)) {\n            L--; // DELIM_START was escaped, thus should not be incremented\n            sbuf.append(messagePattern.substring(i, j - 1));\n            sbuf.append(DELIM_START);\n            i = j + 1;\n          } else {\n            // The escape character preceding the delimiter start is\n            // itself escaped: \"abc x:\\\\{}\"\n            // we have to consume one backward slash\n            sbuf.append(messagePattern.substring(i, j - 1));\n            deeplyAppendParameter(sbuf, argArray[L], new HashMap());\n            i = j + 2;\n          }\n        } else {\n          // normal case\n          sbuf.append(messagePattern.substring(i, j));\n          deeplyAppendParameter(sbuf, argArray[L], new HashMap());\n          i = j + 2;\n        }\n      }\n    }\n    // append the characters following the last {} pair.\n    sbuf.append(messagePattern.substring(i, messagePattern.length()));\n    return sbuf.toString();\n  }\n\n  final static boolean isEscapedDelimeter(String messagePattern,\n      int delimeterStartIndex) {\n\n    if (delimeterStartIndex == 0) {\n      return false;\n    }\n    char potentialEscape = messagePattern.charAt(delimeterStartIndex - 1);\n    if (potentialEscape == ESCAPE_CHAR) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  final static boolean isDoubleEscaped(String messagePattern,\n      int delimeterStartIndex) {\n    if (delimeterStartIndex >= 2\n        && messagePattern.charAt(delimeterStartIndex - 2) == ESCAPE_CHAR) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  // special treatment of array values was suggested by 'lizongbo'\n  private static void deeplyAppendParameter(StringBuffer sbuf, Object o,\n      Map seenMap) {\n    if (o == null) {\n      sbuf.append(\"null\");\n      return;\n    }\n    if (!o.getClass().isArray()) {\n      safeObjectAppend(sbuf, o);\n    } else {\n      // check for primitive array types because they\n      // unfortunately cannot be cast to Object[]\n      if (o instanceof boolean[]) {\n        booleanArrayAppend(sbuf, (boolean[]) o);\n      } else if (o instanceof byte[]) {\n        byteArrayAppend(sbuf, (byte[]) o);\n      } else if (o instanceof char[]) {\n        charArrayAppend(sbuf, (char[]) o);\n      } else if (o instanceof short[]) {\n        shortArrayAppend(sbuf, (short[]) o);\n      } else if (o instanceof int[]) {\n        intArrayAppend(sbuf, (int[]) o);\n      } else if (o instanceof long[]) {\n        longArrayAppend(sbuf, (long[]) o);\n      } else if (o instanceof float[]) {\n        floatArrayAppend(sbuf, (float[]) o);\n      } else if (o instanceof double[]) {\n        doubleArrayAppend(sbuf, (double[]) o);\n      } else {\n        objectArrayAppend(sbuf, (Object[]) o, seenMap);\n      }\n    }\n  }\n\n  private static void safeObjectAppend(StringBuffer sbuf, Object o) {\n    try {\n      String oAsString = o.toString();\n      sbuf.append(oAsString);\n    } catch( Throwable t) {\n      System.err.println(\"SLF4J: Failed toString() invocation on an object of type [\"+o.getClass().getName()+\"]\");\n      t.printStackTrace();\n      sbuf.append(\"[FAILED toString()]\");\n    }\n\n  }\n\n  private static void objectArrayAppend(StringBuffer sbuf, Object[] a,\n      Map seenMap) {\n    sbuf.append('[');\n    if (!seenMap.containsKey(a)) {\n      seenMap.put(a, null);\n      final int len = a.length;\n      for (int i = 0; i < len; i++) {\n        deeplyAppendParameter(sbuf, a[i], seenMap);\n        if (i != len - 1)\n          sbuf.append(\", \");\n      }\n      // allow repeats in siblings\n      seenMap.remove(a);\n    } else {\n      sbuf.append(\"...\");\n    }\n    sbuf.append(']');\n  }\n\n  private static void booleanArrayAppend(StringBuffer sbuf, boolean[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void byteArrayAppend(StringBuffer sbuf, byte[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void charArrayAppend(StringBuffer sbuf, char[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void shortArrayAppend(StringBuffer sbuf, short[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void intArrayAppend(StringBuffer sbuf, int[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void longArrayAppend(StringBuffer sbuf, long[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void floatArrayAppend(StringBuffer sbuf, float[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void doubleArrayAppend(StringBuffer sbuf, double[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n}\n","Smelly Sample":"/* \n * Copyright (c) 2004-2007 QOS.ch\n * All rights reserved.\n * \n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n * \n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n * \n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage org.slf4j.helpers;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n// contributors: lizongbo: proposed special treatment of array parameter values\n// Jrn Huxhorn: pointed out double[] omission, suggested deep array copy\n/**\n * Formats messages according to very simple substitution rules. Substitutions\n * can be made 1, 2 or more arguments.\n * <p>\n * For example,\n * \n * <pre>MessageFormatter.format(&quot;Hi {}.&quot;, &quot;there&quot;)<\/pre>\n * \n * will return the string \"Hi there.\".\n * <p>\n * The {} pair is called the <em>formatting anchor<\/em>. It serves to\n * designate the location where arguments need to be substituted within the\n * message pattern.\n * <p>\n * In case your message contains the '{' or the '}' character, you do not have\n * to do anything special unless the '}' character immediately follows '{'. For\n * example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Set {1,2,3} is not equal to {}.&quot;, &quot;1,2&quot;);\n * <\/pre>\n * \n * will return the string \"Set {1,2,3} is not equal to 1,2.\".\n * \n * <p>If for whatever reason you need to place the string \"{}\" in the message\n * without its <em>formatting anchor<\/em> meaning, then you need to escape the\n * '{' character with '\\', that is the backslash character. Only the '{'\n * character should be escaped. There is no need to escape the '}' character.\n * For example,\n * \n * <pre>\n * MessageFormatter.format(&quot;Set \\\\{} is not equal to {}.&quot;, &quot;1,2&quot;);\n * <\/pre>\n * \n * will return the string \"Set {} is not equal to 1,2.\".\n * \n * <p>\n * The escaping behavior just described can be overridden by escaping the escape\n * character '\\'. Calling\n * \n * <pre>\n * MessageFormatter.format(&quot;File name is C:\\\\\\\\{}.&quot;, &quot;file.zip&quot;);\n * <\/pre>\n * \n * will return the string \"File name is C:\\file.zip\".\n * \n * <p>\n * See {@link #format(String, Object)}, {@link #format(String, Object, Object)}\n * and {@link #arrayFormat(String, Object[])} methods for more details.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\nfinal public class MessageFormatter {\n  static final char DELIM_START = '{';\n  static final char DELIM_STOP = '}';\n  static final String DELIM_STR = \"{}\";\n  private static final char ESCAPE_CHAR = '\\\\';\n\n  /**\n   * Performs single argument substitution for the 'messagePattern' passed as\n   * parameter.\n   * <p>\n   * For example,\n   * \n   * <pre>\n   * MessageFormatter.format(&quot;Hi {}.&quot;, &quot;there&quot;);\n   * <\/pre>\n   * \n   * will return the string \"Hi there.\".\n   * <p>\n   * \n   * @param messagePattern\n   *                The message pattern which will be parsed and formatted\n   * @param argument\n   *                The argument to be substituted in place of the formatting\n   *                anchor\n   * @return The formatted message\n   */\n  final public static String format(String messagePattern, Object arg) {\n    return arrayFormat(messagePattern, new Object[] { arg });\n  }\n\n  /**\n   * \n   * Performs a two argument substitution for the 'messagePattern' passed as\n   * parameter.\n   * <p>\n   * For example,\n   * \n   * <pre>\n   * MessageFormatter.format(&quot;Hi {}. My name is {}.&quot;, &quot;Alice&quot;, &quot;Bob&quot;);\n   * <\/pre>\n   * \n   * will return the string \"Hi Alice. My name is Bob.\".\n   * \n   * @param messagePattern\n   *                The message pattern which will be parsed and formatted\n   * @param arg1\n   *                The argument to be substituted in place of the first\n   *                formatting anchor\n   * @param arg2\n   *                The argument to be substituted in place of the second\n   *                formatting anchor\n   * @return The formatted message\n   */\n  final public static String format(final String messagePattern, Object arg1, Object arg2) {\n    return arrayFormat(messagePattern, new Object[] { arg1, arg2 });\n  }\n\n  /**\n   * Same principle as the {@link #format(String, Object)} and\n   * {@link #format(String, Object, Object)} methods except that any number of\n   * arguments can be passed in an array.\n   * \n   * @param messagePattern\n   *                The message pattern which will be parsed and formatted\n   * @param argArray\n   *                An array of arguments to be substituted in place of\n   *                formatting anchors\n   * @return The formatted message\n   */\n  final public static String arrayFormat(final String messagePattern,\n      final Object[] argArray) {\n    if (messagePattern == null) {\n      return null;\n    }\n    if (argArray == null) {\n      return messagePattern;\n    }\n    int i = 0;\n    int j;\n    StringBuffer sbuf = new StringBuffer(messagePattern.length() + 50);\n\n    for (int L = 0; L < argArray.length; L++) {\n\n      j = messagePattern.indexOf(DELIM_STR, i);\n\n      if (j == -1) {\n        // no more variables\n        if (i == 0) { // this is a simple string\n          return messagePattern;\n        } else { // add the tail string which contains no variables and return\n          // the result.\n          sbuf.append(messagePattern.substring(i, messagePattern.length()));\n          return sbuf.toString();\n        }\n      } else {\n        if (isEscapedDelimeter(messagePattern, j)) {\n          if (!isDoubleEscaped(messagePattern, j)) {\n            L--; // DELIM_START was escaped, thus should not be incremented\n            sbuf.append(messagePattern.substring(i, j - 1));\n            sbuf.append(DELIM_START);\n            i = j + 1;\n          } else {\n            // The escape character preceding the delemiter start is\n            // itself escaped: \"abc x:\\\\{}\"\n            // we have to consume one backward slash\n            sbuf.append(messagePattern.substring(i, j - 1));\n            deeplyAppendParameter(sbuf, argArray[L], new HashMap());\n            i = j + 2;\n          }\n        } else {\n          // normal case\n          sbuf.append(messagePattern.substring(i, j));\n          deeplyAppendParameter(sbuf, argArray[L], new HashMap());\n          i = j + 2;\n        }\n      }\n    }\n    // append the characters following the last {} pair.\n    sbuf.append(messagePattern.substring(i, messagePattern.length()));\n    return sbuf.toString();\n  }\n\n  final static boolean isEscapedDelimeter(String messagePattern,\n      int delimeterStartIndex) {\n\n    if (delimeterStartIndex == 0) {\n      return false;\n    }\n    char potentialEscape = messagePattern.charAt(delimeterStartIndex - 1);\n    if (potentialEscape == ESCAPE_CHAR) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  final static boolean isDoubleEscaped(String messagePattern, int delimeterStartIndex) {\n    if (delimeterStartIndex >= 2\n        && messagePattern.charAt(delimeterStartIndex - 2) == ESCAPE_CHAR) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  // special treatment of array values was suggested by 'lizongbo'\n  private static void deeplyAppendParameter(StringBuffer sbuf, Object o,\n      Map seenMap) {\n    if (o == null) {\n      sbuf.append(\"null\");\n      return;\n    }\n    if (!o.getClass().isArray()) {\n      sbuf.append(o);\n    } else {\n      // check for primitive array types because they\n      // unfortunately cannot be cast to Object[]\n      if (o instanceof boolean[]) {\n        booleanArrayAppend(sbuf, (boolean[]) o);\n      } else if (o instanceof byte[]) {\n        byteArrayAppend(sbuf, (byte[]) o);\n      } else if (o instanceof char[]) {\n        charArrayAppend(sbuf, (char[]) o);\n      } else if (o instanceof short[]) {\n        shortArrayAppend(sbuf, (short[]) o);\n      } else if (o instanceof int[]) {\n        intArrayAppend(sbuf, (int[]) o);\n      } else if (o instanceof long[]) {\n        longArrayAppend(sbuf, (long[]) o);\n      } else if (o instanceof float[]) {\n        floatArrayAppend(sbuf, (float[]) o);\n      } else if (o instanceof double[]) {\n        doubleArrayAppend(sbuf, (double[]) o);\n      } else {\n        objectArrayAppend(sbuf, (Object[]) o, seenMap);\n      }\n    }\n  }\n\n  private static void objectArrayAppend(StringBuffer sbuf, Object[] a,\n      Map seenMap) {\n    sbuf.append('[');\n    if (!seenMap.containsKey(a)) {\n      seenMap.put(a, null);\n      final int len = a.length;\n      for (int i = 0; i < len; i++) {\n        deeplyAppendParameter(sbuf, a[i], seenMap);\n        if (i != len - 1)\n          sbuf.append(\", \");\n      }\n      // allow repeats in siblings\n      seenMap.remove(a);\n    } else {\n      sbuf.append(\"...\");\n    }\n    sbuf.append(']');\n  }\n\n  private static void booleanArrayAppend(StringBuffer sbuf, boolean[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void byteArrayAppend(StringBuffer sbuf, byte[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void charArrayAppend(StringBuffer sbuf, char[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void shortArrayAppend(StringBuffer sbuf, short[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void intArrayAppend(StringBuffer sbuf, int[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void longArrayAppend(StringBuffer sbuf, long[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void floatArrayAppend(StringBuffer sbuf, float[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n\n  private static void doubleArrayAppend(StringBuffer sbuf, double[] a) {\n    sbuf.append('[');\n    final int len = a.length;\n    for (int i = 0; i < len; i++) {\n      sbuf.append(a[i]);\n      if (i != len - 1)\n        sbuf.append(\", \");\n    }\n    sbuf.append(']');\n  }\n}\n","lineNo":270}
{"Refactored Sample":"package org.slf4j.instrumentation;\n\nimport java.util.Map;\nimport java.util.WeakHashMap;\n\npublic class ToStringHelper {\n\n\t/**\n\t * Prefix to use at the start of the representation. Always used.\n\t */\n\tprivate static final String ARRAY_PREFIX = \"[\";\n\n\t/**\n\t * Suffix to use at the end of the representation. Always used.\n\t */\n\tprivate static final String ARRAY_SUFFIX = \"]\";\n\n\t/**\n\t * String separating each element when rendering an array. To be compatible\n\t * with lists comma-space is used.\n\t */\n\n\tprivate static final String ELEMENT_SEPARATOR = \", \";\n\n\t/**\n\t * unrenderableClasses is essentially a Set of Class objects which has for\n\t * some reason failed to render properly when invoked through a toString\n\t * method call. To avoid memory leaks a data structure using weak references\n\t * is needed, but unfortunately the runtime library does not contain a\n\t * WeakHashSet class, so the behavior is emulated with a WeakHashmap with\n\t * the class as the key, and a Long containing the value of\n\t * System.currentTimeMilis when an instance of the class failed to render.\n\t */\n\n\tfinal static Map<Class<?>, Object> unrenderableClasses = new WeakHashMap<Class<?>, Object>();\n\n\t/**\n\t * Returns o.toString() unless it throws an exception (which causes it to be\n\t * stored in unrenderableClasses) or already was present in\n\t * unrenderableClasses. If so, the same string is returned as would have\n\t * been returned by Object.toString(). Arrays get special treatment as they\n\t * don't have usable toString methods.\n\t * \n\t * @param o\n\t *            incoming object to render.\n\t * @return\n\t */\n\n\tpublic static String render(Object o) {\n\t\tif (o == null) {\n\t\t\treturn String.valueOf(o);\n\t\t}\n\t\tClass<?> objectClass = o.getClass();\n\n\t\tif (unrenderableClasses.containsKey(objectClass) == false) {\n\t\t\ttry {\n\t\t\t\tif (objectClass.isArray()) {\n\t\t\t\t\treturn renderArray(o, objectClass).toString();\n\t\t\t\t} else {\n\t\t\t\t\treturn o.toString();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLong now = new Long(System.currentTimeMillis());\n\n\t\t\t\tSystem.err.println(\"Disabling exception throwing class \"\n\t\t\t\t\t\t+ objectClass.getName() + \", \" + e.getMessage());\n\n\t\t\t\tunrenderableClasses.put(objectClass, now);\n\t\t\t}\n\t\t}\n\t\tString name = o.getClass().getName();\n\t\treturn name + \"@\" + Integer.toHexString(o.hashCode());\n\t}\n\n\t/**\n\t * renderArray returns an array similar to a List. If the array type is an\n\t * object they are rendered with \"render(object)\" for each. If the array\n\t * type is a primitive each element is added directly to the string buffer\n\t * collecting the result.\n\t * \n\t * @param o\n\t * @param objectClass\n\t * @return\n\t */\n\tprivate static StringBuffer renderArray(Object o, Class<?> objectClass) {\n\t\tClass<?> componentType = objectClass.getComponentType();\n\t\tStringBuffer sb = new StringBuffer(ARRAY_PREFIX);\n\n\t\tif (componentType.isPrimitive() == false) {\n\t\t\tObject[] oa = (Object[]) o;\n\t\t\tfor (int i = 0; i < oa.length; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t}\n\t\t\t\tsb.append(render(oa[i]));\n\t\t\t}\n\t\t} else {\n\t\t\tif (Boolean.TYPE.equals(componentType)) {\n\t\t\t\tboolean[] ba = (boolean[]) o;\n\t\t\t\tfor (int i = 0; i < ba.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ba[i]);\n\t\t\t\t}\n\t\t\t} else if (Integer.TYPE.equals(componentType)) {\n\t\t\t\tint[] ia = (int[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\n\t\t\t} else if (Long.TYPE.equals(componentType)) {\n\t\t\t\tlong[] ia = (long[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Double.TYPE.equals(componentType)) {\n\t\t\t\tdouble[] ia = (double[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Float.TYPE.equals(componentType)) {\n\t\t\t\tfloat[] ia = (float[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Character.TYPE.equals(componentType)) {\n\t\t\t\tchar[] ia = (char[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Short.TYPE.equals(componentType)) {\n\t\t\t\tshort[] ia = (short[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Byte.TYPE.equals(componentType)) {\n\t\t\t\tbyte[] ia = (byte[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsb.append(ARRAY_SUFFIX);\n\t\treturn sb;\n\t}\n}\n","Smelly Sample":"package org.slf4j.instrumentation;\n\nimport java.util.Map;\nimport java.util.WeakHashMap;\n\npublic class ToStringHelper {\n\n\t/**\n\t * Prefix to use at the start of the representation. Always used.\n\t */\n\tprivate static final String ARRAY_PREFIX = \"[\";\n\n\t/**\n\t * Suffix to use at the end of the representation. Always used.\n\t */\n\tprivate static final String ARRAY_SUFFIX = \"]\";\n\n\t/**\n\t * String separating each element when rendering an array. To be compatible\n\t * with lists comma-space is used.\n\t */\n\n\tprivate static final String ELEMENT_SEPARATOR = \", \";\n\n\t/**\n\t * unrenderableClasses is essentially a Set of Class objects which has for\n\t * some reason failed to render properly when invoked through a toString\n\t * method call. To avoid memory leaks a data structure using weak references\n\t * is needed, but unfortunately the runtime library does not contain a\n\t * WeakHashSet class, so the behavior is emulated with a WeakHashmap with\n\t * the class as the key, and a Long containing the value of\n\t * System.currentTimeMilis when an instance of the class failed to render.\n\t */\n\n\tfinal static Map<Class<?>, Object> unrenderableClasses = new WeakHashMap<Class<?>, Object>();\n\n\t/**\n\t * Returns o.toString() unless it throws an exception (which causes it to be\n\t * stored in unrenderableClasses) or already was present in\n\t * unrenderableClasses. If so, the same string is returned as would have\n\t * been returned by Object.toString(). Arrays get special treatment as they\n\t * don't have usable toString methods.\n\t * \n\t * @param o\n\t * @return\n\t */\n\tpublic static String render(Object o) {\n\t\tif (o == null) {\n\t\t\treturn String.valueOf(o);\n\t\t}\n\t\tClass<?> objectClass = o.getClass();\n\t\tif (unrenderableClasses.containsKey(objectClass) == false) {\n\t\t\ttry {\n\t\t\t\tif (objectClass.isArray()) {\n\t\t\t\t\treturn renderArray(o, objectClass).toString();\n\t\t\t\t} else {\n\t\t\t\t\treturn o.toString();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLong now = new Long(System.currentTimeMillis());\n\t\t\t\tSystem.err.println(\"Disabling exception throwing class \"\n\t\t\t\t\t\t+ objectClass.getName() + \", \" + e.getMessage());\n\t\t\t\tunrenderableClasses.put(objectClass, now);\n\t\t\t}\n\t\t}\n\t\treturn o.getClass().getName() + \"@\" + Integer.toHexString(o.hashCode());\n\t}\n\n\t/**\n\t * renderArray returns an array similar to a List. If the array type is an\n\t * object they are rendered with \"render(object)\" for each. If the array\n\t * type is a primitive each element is added directly to the string buffer\n\t * collecting the result.\n\t * \n\t * @param o\n\t * @param objectClass\n\t * @return\n\t */\n\tprivate static StringBuffer renderArray(Object o, Class<?> objectClass) {\n\t\tClass<?> componentType = objectClass.getComponentType();\n\t\tStringBuffer sb = new StringBuffer(ARRAY_PREFIX);\n\n\t\tif (componentType.isPrimitive() == false) {\n\t\t\tObject[] oa = (Object[]) o;\n\t\t\tfor (int i = 0; i < oa.length; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t}\n\t\t\t\tsb.append(render(oa[i]));\n\t\t\t}\n\t\t} else {\n\t\t\tif (Boolean.TYPE.equals(componentType)) {\n\t\t\t\tboolean[] ba = (boolean[]) o;\n\t\t\t\tfor (int i = 0; i < ba.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ba[i]);\n\t\t\t\t}\n\t\t\t} else if (Integer.TYPE.equals(componentType)) {\n\t\t\t\tint[] ia = (int[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\n\t\t\t} else if (Long.TYPE.equals(componentType)) {\n\t\t\t\tlong[] ia = (long[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Double.TYPE.equals(componentType)) {\n\t\t\t\tdouble[] ia = (double[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Float.TYPE.equals(componentType)) {\n\t\t\t\tfloat[] ia = (float[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Character.TYPE.equals(componentType)) {\n\t\t\t\tchar[] ia = (char[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Short.TYPE.equals(componentType)) {\n\t\t\t\tshort[] ia = (short[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t} else if (Byte.TYPE.equals(componentType)) {\n\t\t\t\tbyte[] ia = (byte[]) o;\n\t\t\t\tfor (int i = 0; i < ia.length; i++) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tsb.append(ELEMENT_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(ia[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsb.append(ARRAY_SUFFIX);\n\t\treturn sb;\n\t}\n}\n","lineNo":71}
{"Refactored Sample":"package org.slf4j.instrumentation;\n\nimport javassist.CtBehavior;\nimport javassist.CtClass;\nimport javassist.CtMethod;\nimport javassist.Modifier;\nimport javassist.NotFoundException;\nimport javassist.bytecode.AttributeInfo;\nimport javassist.bytecode.CodeAttribute;\nimport javassist.bytecode.LocalVariableAttribute;\n\n/**\n * Helper methods for Javassist functionality.\n * \n */\npublic class JavassistHelper {\n\n  /**\n   * Create a javaassist source snippet which either is empty (for anything\n   * which does not return a value) or a explanatory text around the $_\n   * javaassist return value variable.\n   * \n   * @param method\n   *          descriptor of method\n   * @return source snippet\n   * @throws NotFoundException\n   */\n  public static String returnValue(CtBehavior method) throws NotFoundException {\n\n    String returnValue = \"\";\n    if (methodReturnsValue(method)) {\n      returnValue = \" returns: \\\" + $_ + \\\".\";\n    }\n    return returnValue;\n  }\n\n  /**\n   * determine if the given method returns a value, and return true if so. false\n   * otherwise.\n   * \n   * @param method\n   * @return\n   * @throws NotFoundException\n   */\n  private static boolean methodReturnsValue(CtBehavior method)\n      throws NotFoundException {\n\n    if (method instanceof CtMethod == false) {\n      return false;\n    }\n\n    CtClass returnType = ((CtMethod) method).getReturnType();\n    String returnTypeName = returnType.getName();\n\n    boolean isVoidMethod = \"void\".equals(returnTypeName);\n\n    boolean methodReturnsValue = isVoidMethod == false;\n    return methodReturnsValue;\n  }\n\n  /**\n   * Return javaassist source snippet which lists all the parameters and their\n   * values. If available the source names are extracted from the debug\n   * information and used, otherwise just a number is shown.\n   * \n   * @param method\n   * @return\n   * @throws NotFoundException\n   */\n  public static String getSignature(CtBehavior method) throws NotFoundException {\n\n    CtClass parameterTypes[] = method.getParameterTypes();\n\n    CodeAttribute codeAttribute = method.getMethodInfo().getCodeAttribute();\n\n    LocalVariableAttribute locals = null;\n    \n\n    if (codeAttribute != null) {\n      AttributeInfo attribute;\n      attribute = codeAttribute.getAttribute(\"LocalVariableTable\");\n      locals = (LocalVariableAttribute) attribute;\n    }\n\n    String methodName = method.getName();\n\n    StringBuffer sb = new StringBuffer(methodName + \"(\\\" \");\n    for (int i = 0; i < parameterTypes.length; i++) {\n      if (i > 0) {\n        // add a comma and a space between printed values\n        sb.append(\" + \\\", \\\" \");\n      }\n\n      CtClass parameterType = parameterTypes[i];\n      boolean isArray = parameterType.isArray();\n      CtClass arrayType = parameterType.getComponentType();\n      if (isArray) {\n        while (arrayType.isArray()) {\n          arrayType = arrayType.getComponentType();\n        }\n      }\n\n      sb.append(\" + \\\"\");\n      sb.append(parameterNameFor(method, locals, i));\n      sb.append(\"\\\" + \\\"=\");\n\n      // use Arrays.asList() to render array of objects.\n      if (isArray && !arrayType.isPrimitive()) {\n        sb.append(\"\\\"+ java.util.Arrays.asList($\" + (i + 1) + \")\");\n      } else {\n        sb.append(\"\\\"+ $\" + (i + 1));\n      }\n    }\n    sb.append(\"+\\\")\");\n\n    String signature = sb.toString();\n    return signature;\n  }\n\n  /**\n   * Determine the name of parameter with index i in the given method. Use the\n   * locals attributes about local variables from the classfile. Note: This is\n   * still work in progress.\n   * \n   * @param method\n   * @param locals\n   * @param i\n   * @return the name of the parameter if available or a number if not.\n   */\n  static String parameterNameFor(CtBehavior method,\n      LocalVariableAttribute locals, int i) {\n\n    if (locals == null) {\n      return Integer.toString(i + 1);\n    }\n\n    int modifiers = method.getModifiers();\n\n    int j = i;\n\n    if (Modifier.isSynchronized(modifiers)) {\n      // skip object to synchronize upon.\n      j++;\n      // System.err.println(\"Synchronized\");\n    }\n    if (Modifier.isStatic(modifiers) == false) {\n      // skip \"this\"\n      j++;\n      // System.err.println(\"Instance\");\n    }\n    String variableName = locals.variableName(j);\n    if (variableName.equals(\"this\")) {\n      System.err.println(\"'this' returned as a parameter name for \"\n          + method.getName() + \" index \" + j + \", names are probably shifted.\");\n    }\n    return variableName;\n  }\n}\n","Smelly Sample":"package org.slf4j.instrumentation;\n\nimport javassist.CtBehavior;\nimport javassist.CtClass;\nimport javassist.CtMethod;\nimport javassist.Modifier;\nimport javassist.NotFoundException;\nimport javassist.bytecode.CodeAttribute;\nimport javassist.bytecode.LocalVariableAttribute;\n\n/**\n * Helper methods for Javassist functionality.\n * \n */\npublic class JavassistHelper {\n\n  /**\n   * Create a javaassist source snippet which either is empty (for anything\n   * which does not return a value) or a explanatory text around the $_\n   * javaassist return value variable.\n   * \n   * @param method\n   *          descriptor of method\n   * @return source snippet\n   * @throws NotFoundException\n   */\n  public static String returnValue(CtBehavior method) throws NotFoundException {\n\n    String returnValue = \"\";\n    if (methodReturnsValue(method)) {\n      returnValue = \" returns: \\\" + $_ + \\\".\";\n    }\n    return returnValue;\n  }\n\n  /**\n   * determine if the given method returns a value, and return true if so. false\n   * otherwise.\n   * \n   * @param method\n   * @return\n   * @throws NotFoundException\n   */\n  private static boolean methodReturnsValue(CtBehavior method)\n      throws NotFoundException {\n\n    if (method instanceof CtMethod == false) {\n      return false;\n    }\n\n    CtClass returnType = ((CtMethod) method).getReturnType();\n    String returnTypeName = returnType.getName();\n\n    boolean isVoidMethod = \"void\".equals(returnTypeName);\n\n    boolean methodReturnsValue = isVoidMethod == false;\n    return methodReturnsValue;\n  }\n\n  /**\n   * Return javaassist source snippet which lists all the parameters and their\n   * values. If available the source names are extracted from the debug\n   * information and used, otherwise just a number is shown.\n   * \n   * @param method\n   * @return\n   * @throws NotFoundException\n   */\n  public static String getSignature(CtBehavior method) throws NotFoundException {\n\n    CtClass parameterTypes[] = method.getParameterTypes();\n\n    CodeAttribute codeAttribute = method.getMethodInfo().getCodeAttribute();\n\n    LocalVariableAttribute locals = null;\n\n    if (codeAttribute != null) {\n      locals = (LocalVariableAttribute) codeAttribute\n          .getAttribute(\"LocalVariableTable\");\n    }\n\n    String methodName = method.getName();\n\n    StringBuffer sb = new StringBuffer(methodName + \"(\\\" \");\n    for (int i = 0; i < parameterTypes.length; i++) {\n      if (i > 0) {\n        // add a comma and a space between printed values\n        sb.append(\" + \\\", \\\" \");\n      }\n\n      CtClass parameterType = parameterTypes[i];\n      boolean isArray = parameterType.isArray();\n      CtClass arrayType = parameterType.getComponentType();\n      if (isArray) {\n        while (arrayType.isArray()) {\n          arrayType = arrayType.getComponentType();\n        }\n      }\n\n      sb.append(\" + \\\"\");\n      sb.append(parameterNameFor(method, locals, i));\n      sb.append(\"\\\" + \\\"=\");\n\n      // use Arrays.asList() to render array of objects.\n      if (isArray && !arrayType.isPrimitive()) {\n        sb.append(\"\\\"+ java.util.Arrays.asList($\" + (i + 1) + \")\");\n      } else {\n        sb.append(\"\\\"+ $\" + (i + 1));\n      }\n    }\n    sb.append(\"+\\\")\");\n\n    String signature = sb.toString();\n    return signature;\n  }\n\n  /**\n   * Determine the name of parameter with index i in the given method. Use the\n   * locals attributes about local variables from the classfile. Note: This is\n   * still work in progress.\n   * \n   * @param method\n   * @param locals\n   * @param i\n   * @return the name of the parameter if available or a number if not.\n   */\n  static String parameterNameFor(CtBehavior method,\n      LocalVariableAttribute locals, int i) {\n\n    if (locals == null) {\n      return Integer.toString(i + 1);\n    }\n\n    int modifiers = method.getModifiers();\n\n    int j = i;\n\n    if (Modifier.isSynchronized(modifiers)) {\n      // skip object to synchronize upon.\n      j++;\n      // System.err.println(\"Synchronized\");\n    }\n    if (Modifier.isStatic(modifiers) == false) {\n      // skip \"this\"\n      j++;\n      // System.err.println(\"Instance\");\n    }\n    String variableName = locals.variableName(j);\n    if (variableName.equals(\"this\")) {\n      System.err.println(\"'this' returned as a parameter name for \"\n          + method.getName() + \" index \" + j + \", names are probably shifted.\");\n    }\n    return variableName;\n  }\n}\n","lineNo":80}
{"Refactored Sample":"package org.slf4j.agent;\n\nimport static org.slf4j.helpers.MessageFormatter.format;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.lang.instrument.Instrumentation;\nimport java.util.Date;\nimport java.util.Properties;\n\nimport org.slf4j.instrumentation.LogTransformer;\n\npublic class AgentPremain {\n\n  private static final String START_MSG = \"Start at {}\";\n  private static final String STOP_MSG = \"Stop at {}, execution time = {} ms\";\n\n  /**\n   * JavaAgent premain entry point as specified in the MANIFEST.MF file. See\n   * {@link http://java.sun.com/javase/6/docs/api/java/lang/instrument/package-summary.html} for details.\n   * \n   * @param agentArgument\n   *          string provided after \"=\" up to first space\n   * @param instrumentation\n   */\n  public static void premain(String agentArgument,\n      Instrumentation instrumentation) {\n\n    System.err.println(\"THIS JAVAAGENT IS NOT RELEASED YET.  \"\n        + \"DO NOT USE IN PRODUCTION ENVIRONMENTS.\");\n\n    LogTransformer.Builder builder = new LogTransformer.Builder();\n    builder = builder.addEntryExit(true);\n\n    if (agentArgument != null) {\n      Properties args = parseArguments(agentArgument);\n\n      if (args.containsKey(\"verbose\")) {\n        builder = builder.verbose(true);\n      }\n\n      if (args.containsKey(\"time\")) {\n        printStartStopTimes();\n      }\n\n      if (args.containsKey(\"ignore\")) {\n        builder = builder.ignore(args.getProperty(\"ignore\").split(\",\"));\n      }\n\n      if (args.containsKey(\"level\")) {\n        builder = builder.level(args.getProperty(\"level\"));\n      }\n\n      // ... more agent option handling here\n    }\n\n    instrumentation.addTransformer(builder.build());\n  }\n\n  private static Properties parseArguments(String agentArgument) {\n    Properties p = new Properties();\n    try {\n      byte[] bytes = agentArgument.replaceAll(\";\", \"\\n\").getBytes();\n      p.load(new ByteArrayInputStream(bytes));\n    } catch (IOException e) {\n      String s = \"Could not load arguments as properties\";\n      throw new RuntimeException(s, e);\n    }\n    return p;\n  }\n\n  /**\n   * Print the start message with the time NOW, and register a shutdown hook\n   * which will print the stop message with the time then and the number of\n   * milliseconds passed since.\n   * \n   */\n  private static void printStartStopTimes() {\n    final long start = System.currentTimeMillis();\n    System.err.println(format(START_MSG, new Date()));\n\n    Thread hook = new Thread() {\n      @Override\n      public void run() {\n        long timePassed = System.currentTimeMillis() - start;\n        String message = format(STOP_MSG, new Date(), timePassed);\n        System.err.println(message);\n      }\n    };\n    Runtime.getRuntime().addShutdownHook(hook);\n  }\n}\n","Smelly Sample":"package org.slf4j.agent;\n\nimport static org.slf4j.helpers.MessageFormatter.format;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.lang.instrument.Instrumentation;\nimport java.util.Date;\nimport java.util.Properties;\n\nimport org.slf4j.instrumentation.LogTransformer;\n\npublic class AgentPremain {\n\n\tprivate static final String START_MSG = \"Start at {}\";\n\tprivate static final String STOP_MSG = \"Stop at {}, execution time = {} ms\";\n\n\tpublic static void premain(String agentArgument,\n\t\t\tInstrumentation instrumentation) {\n\n\t\tSystem.err.println(\"THIS JAVAAGENT IS NOT RELEASED YET.  DO NOT USE IN PRODUCTION ENVIRONMENTS.\");\n\t\tLogTransformer.Builder builder = new LogTransformer.Builder();\n\t\tbuilder = builder.addEntryExit(true);\n\n\t\tif (agentArgument != null) {\n\t\t\tProperties args = parseArguments(agentArgument);\n\n\t\t\tif (args.containsKey(\"verbose\")) {\n\t\t\t\tbuilder = builder.verbose(true);\n\t\t\t}\n\n\t\t\tif (args.containsKey(\"time\")) {\n\t\t\t\tprintStartStopTimes();\n\t\t\t}\n\n\t\t\tif (args.containsKey(\"ignore\")) {\n\t\t\t\tbuilder = builder.ignore(args.getProperty(\"ignore\").split(\",\"));\n\t\t\t}\n\t\t\t\n\t\t\tif (args.containsKey(\"level\")) {\n\t\t\t\tbuilder = builder.level(args.getProperty(\"level\"));\n\t\t\t}\n\n\t\t\t// ... more agent option handling here\n\t\t}\n\n\t\tinstrumentation.addTransformer(builder.build());\n\t}\n\n\tprivate static Properties parseArguments(String agentArgument) {\n\t\tProperties p = new Properties();\n\t\ttry {\n\t\t\tbyte[] bytes = agentArgument.replaceAll(\";\", \"\\n\").getBytes();\n\t\t\tp.load(new ByteArrayInputStream(bytes));\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Could not load arguments as properties\", e);\n\t\t}\n\t\treturn p;\n\t}\n\n\t/**\n\t * Print the start message with the time NOW, and register a shutdown hook\n\t * which will print the stop message with the time then and the number of\n\t * milliseconds passed since.\n\t * \n\t */\n\tprivate static void printStartStopTimes() {\n\t\tfinal long start = System.currentTimeMillis();\n\t\tSystem.err.println(format(START_MSG, new Date()));\n\n\t\tThread hook = new Thread() {\n\t\t\tpublic void run() {\n\t\t\t\tlong timePassed = System.currentTimeMillis() - start;\n\t\t\t\tString message = format(STOP_MSG, new Date(), timePassed);\n\t\t\t\tSystem.err.println(message);\n\t\t\t}\n\t\t};\n\t\tRuntime.getRuntime().addShutdownHook(hook);\n\t}\n\n}\n","lineNo":66}
{"Refactored Sample":"package org.slf4j.instrumentation;\n\nimport javassist.CtBehavior;\nimport javassist.CtClass;\nimport javassist.CtMethod;\nimport javassist.Modifier;\nimport javassist.NotFoundException;\nimport javassist.bytecode.CodeAttribute;\nimport javassist.bytecode.LocalVariableAttribute;\n\npublic class JavassistHelper {\n\n\tpublic static String returnValue(CtBehavior method)\n\t\t\tthrows NotFoundException {\n\t\t\n\t\tString returnValue = \"\";\n\t\tif (methodReturnsValue(method)) {\n\t\t\treturnValue = \" returns: \\\" + $_ + \\\"\";\n\t\t}\n\t\treturn returnValue;\n\t}\n\n\tprivate static boolean methodReturnsValue(CtBehavior method)\n\t\t\tthrows NotFoundException {\n\t\t\n\t\tif (method instanceof CtMethod == false) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tCtClass returnType = ((CtMethod) method).getReturnType();\n\t\tString returnTypeName = returnType.getName();\n\n\t\tboolean isVoidMethod = \"void\".equals(returnTypeName);\n\t\t\n\t\tboolean methodReturnsValue = isVoidMethod == false;\n\t\treturn methodReturnsValue;\n\t}\n\n\tpublic static String getSignature(CtBehavior method)\n\t\t\tthrows NotFoundException {\n\t\t\n\t\tCtClass parameterTypes[] = method.getParameterTypes();\n\n\t\tCodeAttribute codeAttribute = method.getMethodInfo().getCodeAttribute();\n\n\t\tLocalVariableAttribute locals = (LocalVariableAttribute) codeAttribute\n\t\t\t\t.getAttribute(\"LocalVariableTable\");\n\t\t\n\t\tString methodName = method.getName();\n\n\t\tStringBuffer sb = new StringBuffer(methodName + \"(\\\" \");\n\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\tsb.append(\" + \\\", \\\" \");\n\t\t\t}\n\n\t\t\tCtClass parameterType = parameterTypes[i];\n\t\t\tCtClass arrayOf = parameterType.getComponentType();\n\n\t\t\tsb.append(\" + \\\"\");\n\t\t\tsb.append(parameterNameFor(method, locals, i));\n\t\t\tsb.append(\"\\\" + \\\"=\");\n\n\t\t\t// use Arrays.asList() to render array of objects.\n\t\t\tif (arrayOf != null && !arrayOf.isPrimitive()) {\n\t\t\t\tsb.append(\"\\\"+ java.util.Arrays.asList($\" + (i + 1) + \")\");\n\t\t\t} else {\n\t\t\t\tsb.append(\"\\\"+ $\" + (i + 1));\n\t\t\t}\n\t\t}\n\t\tsb.append(\"+\\\")\");\n\n\t\tString signature = sb.toString();\n\t\treturn signature;\n\t}\n\n\tstatic String parameterNameFor(CtBehavior method,\n\t\t\tLocalVariableAttribute locals, int i) {\n\t\tif (locals == null) {\n\t\t\treturn Integer.toString(i + 1);\n\t\t}\n\t\t\n\n\t\tint modifiers = method.getModifiers();\n\t\t\n\t\tint j = i;\n\t\t\n\t\t\n\t\t\n\t\tif (Modifier.isStatic(modifiers) == false) {\n\t\t\t// skip #0 which is \"this\"\n\t\t\tj++;\n\t\t}\n\t\treturn locals.variableName(j);\n\t}\n}\n","Smelly Sample":"package org.slf4j.instrumentation;\n\nimport javassist.CtBehavior;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\nimport javassist.CtMethod;\nimport javassist.Modifier;\nimport javassist.NotFoundException;\nimport javassist.bytecode.CodeAttribute;\nimport javassist.bytecode.LocalVariableAttribute;\n\npublic class JavassistHelper {\n\n\tpublic static String returnValue(CtBehavior method)\n\t\t\tthrows NotFoundException {\n\t\t\n\t\tString returnValue = \"\";\n\t\tif (methodReturnsValue(method)) {\n\t\t\treturnValue = \"\\\" returns: \\\" + $_ \";\n\t\t}\n\t\treturn returnValue;\n\t}\n\n\tprivate static boolean methodReturnsValue(CtBehavior method)\n\t\t\tthrows NotFoundException {\n\t\t\n\t\tCtClass returnType = ((CtMethod) method).getReturnType();\n\t\tString returnTypeName = returnType.getName();\n\n\t\tboolean isVoidMethod = (method instanceof CtMethod)\n\t\t\t\t&& \"void\".equals(returnTypeName);\n\t\t\n\t\tboolean isConstructor = method instanceof CtConstructor;\n\n\t\tboolean methodReturnsValue = (isVoidMethod || isConstructor) == false;\n\t\treturn methodReturnsValue;\n\t}\n\n\tpublic static String getSignature(CtBehavior method)\n\t\t\tthrows NotFoundException {\n\t\t\n\t\tCtClass parameterTypes[] = method.getParameterTypes();\n\n\t\tCodeAttribute codeAttribute = method.getMethodInfo().getCodeAttribute();\n\n\t\tLocalVariableAttribute locals = (LocalVariableAttribute) codeAttribute\n\t\t\t\t.getAttribute(\"LocalVariableTable\");\n\t\t\n\t\tString methodName = method.getName();\n\n\t\tStringBuffer sb = new StringBuffer(methodName + \"(\\\" \");\n\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\tsb.append(\" + \\\", \\\" \");\n\t\t\t}\n\n\t\t\tCtClass parameterType = parameterTypes[i];\n\t\t\tCtClass arrayOf = parameterType.getComponentType();\n\n\t\t\tsb.append(\" + \\\"\");\n\t\t\tsb.append(parameterNameFor(method, locals, i));\n\t\t\tsb.append(\"\\\" + \\\"=\");\n\n\t\t\t// use Arrays.asList() to render array of objects.\n\t\t\tif (arrayOf != null && !arrayOf.isPrimitive()) {\n\t\t\t\tsb.append(\"\\\"+ java.util.Arrays.asList($\" + (i + 1) + \")\");\n\t\t\t} else {\n\t\t\t\tsb.append(\"\\\"+ $\" + (i + 1));\n\t\t\t}\n\t\t}\n\t\tsb.append(\"+\\\")\");\n\n\t\tString signature = sb.toString();\n\t\treturn signature;\n\t}\n\n\tstatic String parameterNameFor(CtBehavior method,\n\t\t\tLocalVariableAttribute locals, int i) {\n\t\tif (locals == null) {\n\t\t\treturn Integer.toString(i + 1);\n\t\t}\n\n\t\tif (Modifier.isStatic(method.getModifiers())) {\n\t\t\treturn locals.variableName(i);\n\t\t}\n\n\t\t// skip #0 which is reference to \"this\"\n\t\treturn locals.variableName(i + 1);\n\t}\n}\n","lineNo":86}
{"Refactored Sample":"/**\n * \n */\npackage org.slf4j.instrumentation;\n\nimport static org.slf4j.helpers.MessageFormatter.format;\n\nimport java.io.ByteArrayInputStream;\nimport java.lang.instrument.ClassFileTransformer;\nimport java.security.ProtectionDomain;\n\nimport javassist.CannotCompileException;\nimport javassist.ClassPool;\nimport javassist.CtBehavior;\nimport javassist.CtClass;\nimport javassist.CtField;\nimport javassist.NotFoundException;\n\npublic class AddEntryExitLoggingTransformer implements ClassFileTransformer {\n\n\tprivate static final String _LOG = \"_log\";\n\tString[] ignore = new String[] { \"sun/\", \"java/\", \"javax/\", \"org/slf4j/\",\n\t\t\t\"ch/qos/logback/\" };\n\n\tpublic byte[] transform(ClassLoader loader, String className,\n\t\t\tClass<?> clazz, ProtectionDomain domain, byte[] bytes) {\n\n\t\tfor (int i = 0; i < ignore.length; i++) {\n\t\t\tif (className.startsWith(ignore[i])) {\n\t\t\t\treturn bytes;\n\t\t\t}\n\t\t}\n\t\t// System.out.println(\"Adding to \" + className);\n\t\treturn doClass(className, clazz, bytes);\n\t}\n\n\t/**\n\t * The transform(...) method calls doClass(...) if the class name does not\n\t * start with any of the prefixes it has been told to ignore.\n\t * \n\t * doClass() first creates a class description from the byte codes. If it is\n\t * a class (i.e. not an interface) the methods defined have bodies, and a\n\t * static final logger object is added with the name of this class as an\n\t * argument, and each method then gets processed with doMethod(...) to have\n\t * logger calls added.\n\t * \n\t * \n\t * \n\t * @param name\n\t *            class name (slashes separate, not dots)\n\t * @param clazz\n\t * @param b\n\t * @return\n\t */\n\tprivate byte[] doClass(String name, Class<?> clazz, byte[] b) {\n\t\tClassPool pool = ClassPool.getDefault();\n\t\tCtClass cl = null;\n\t\ttry {\n\t\t\tcl = pool.makeClass(new ByteArrayInputStream(b));\n\t\t\tif (cl.isInterface() == false) {\n\n\t\t\t\tString pattern1 = \"private static org.slf4j.Logger {};\";\n\t\t\t\tString loggerDefinition = format(pattern1, _LOG);\n\t\t\t\tCtField field = CtField.make(loggerDefinition, cl);\n\n\t\t\t\tString pattern2 = \"org.slf4j.LoggerFactory.getLogger({}.class);\";\n\t\t\t\tString replace = name.replace('/', '.');\n\t\t\t\tString getLogger = format(pattern2, replace);\n\n\t\t\t\tcl.addField(field, getLogger);\n\t\t\t\tSystem.out.println(getLogger);\n\n\t\t\t\tCtBehavior[] methods = cl.getDeclaredBehaviors();\n\t\t\t\tfor (int i = 0; i < methods.length; i++) {\n\t\t\t\t\tif (methods[i].isEmpty() == false) {\n\t\t\t\t\t\tdoMethod(methods[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb = cl.toBytecode();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tString pattern = \"Could not instrument {},  exception : {}\";\n\t\t\tSystem.err.println(format(pattern, name, e.getMessage()));\n\t\t} finally {\n\t\t\tif (cl != null) {\n\t\t\t\tcl.detach();\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\n\tprivate void doMethod(CtBehavior method) throws NotFoundException,\n\t\t\tCannotCompileException {\n\n\t\tString signature = JavassistHelper.getSignature(method);\n\t\tString returnValue = JavassistHelper.returnValue(method);\n\n\t\tString messagePattern = \"if ({}.isDebugEnabled()) {}.info(\\\">> {}\\\");\";\n\t\tObject[] arg1 = new Object[] { _LOG, _LOG, signature };\n\t\tString before = format(messagePattern, arg1);\n\t\tmethod.insertBefore(before);\n\n\t\tString messagePattern2 = \"if ({}.isDebugEnabled()) {}.info(\\\"<< {}{}\\\");\";\n\t\tObject[] arg2 = new Object[] { _LOG, _LOG, signature, returnValue };\n\t\tString after = format(messagePattern2, arg2);\n\t\tmethod.insertAfter(after);\n\t}\n}\n","Smelly Sample":"/**\n * \n */\npackage org.slf4j.instrumentation;\n\nimport java.io.ByteArrayInputStream;\nimport java.lang.instrument.ClassFileTransformer;\n\nimport javassist.CannotCompileException;\nimport javassist.ClassPool;\nimport javassist.CtBehavior;\nimport javassist.CtClass;\nimport javassist.CtField;\nimport javassist.NotFoundException;\n\n\npublic class AddEntryExitLoggingTransformer implements\n\t\tClassFileTransformer {\n\t\n\tfinal String def = \"private static org.slf4j.Logger \" + \"_log\" + \";\";\n\tfinal String ifLog = \"if (_log.isDebugEnabled())\";\n\tString[] ignore = new String[] { \"sun/\", \"java/\", \"javax/\", \"org/slf4j/\",\n\t\t\t\"ch/qos/logback/\" };\n\n\tpublic byte[] transform(ClassLoader loader, String className, Class<?> clazz,\n\t\t\tjava.security.ProtectionDomain domain, byte[] bytes) {\n\n\t\tfor (int i = 0; i < ignore.length; i++) {\n\t\t\tif (className.startsWith(ignore[i])) {\n\t\t\t\treturn bytes;\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"Adding to \" + className);\n\t\treturn doClass(className, clazz, bytes);\n\t}\n\n\t//\n\t// The transform(...) method calls doClass(...) if the class name does not\n\t// start with any of the prefixes it has been told to ignore (note that the\n\t// separators are slashes, not dots).\n\n\tprivate byte[] doClass(String name, Class<?> clazz, byte[] b) {\n\t\tClassPool pool = ClassPool.getDefault();\n\t\tCtClass cl = null;\n\t\ttry {\n\t\t\tcl = pool.makeClass(new ByteArrayInputStream(b));\n\t\t\tif (cl.isInterface() == false) {\n\n\t\t\t\tCtField field = CtField.make(def, cl);\n\t\t\t\tString getLogger = \"org.slf4j.LoggerFactory.getLogger(\"\n\t\t\t\t\t\t+ name.replace('/', '.') + \".class);\";\n\t\t\t\tcl.addField(field, getLogger);\n\t\t\t\tSystem.out.println(getLogger);\n\n\t\t\t\tCtBehavior[] methods = cl.getDeclaredBehaviors();\n\t\t\t\tfor (int i = 0; i < methods.length; i++) {\n\t\t\t\t\tif (methods[i].isEmpty() == false) {\n\t\t\t\t\t\tdoMethod(methods[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb = cl.toBytecode();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tSystem.err.println(\"Could not instrument  \" + name\n\t\t\t\t\t+ \",  exception : \" + e.getMessage());\n\t\t} finally {\n\t\t\tif (cl != null) {\n\t\t\t\tcl.detach();\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\n\tprivate void doMethod(CtBehavior method) throws NotFoundException,\n\t\t\tCannotCompileException {\n\n\t\tString signature = JavassistHelper.getSignature(method);\n\t\tString returnValue = JavassistHelper.returnValue(method);\n\n\t\tmethod.insertBefore(ifLog + \"_log\" + \".info(\\\">> \" + signature + \");\");\n\n\t\tmethod.insertAfter(ifLog + \"_log\" + \".info(\\\"<< \" + signature\n\t\t\t\t+ returnValue + \");\");\n\t}\n}\n","lineNo":67}
{"Refactored Sample":"/* \n * Copyright (c) 2004-2005 SLF4J.ORG\n * Copyright (c) 2004-2005 QOS.CH\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute, and/or sell copies of  the Software, and to permit persons\n * to whom  the Software is furnished  to do so, provided  that the above\n * copyright notice(s) and this permission notice appear in all copies of\n * the  Software and  that both  the above  copyright notice(s)  and this\n * permission notice appear in supporting documentation.\n * \n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR  A PARTICULAR PURPOSE AND NONINFRINGEMENT\n * OF  THIRD PARTY  RIGHTS. IN  NO EVENT  SHALL THE  COPYRIGHT  HOLDER OR\n * HOLDERS  INCLUDED IN  THIS  NOTICE BE  LIABLE  FOR ANY  CLAIM, OR  ANY\n * SPECIAL INDIRECT  OR CONSEQUENTIAL DAMAGES, OR  ANY DAMAGES WHATSOEVER\n * RESULTING FROM LOSS  OF USE, DATA OR PROFITS, WHETHER  IN AN ACTION OF\n * CONTRACT, NEGLIGENCE  OR OTHER TORTIOUS  ACTION, ARISING OUT OF  OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n * \n * Except as  contained in  this notice, the  name of a  copyright holder\n * shall not be used in advertising or otherwise to promote the sale, use\n * or other dealings in this Software without prior written authorization\n * of the copyright holder.\n *\n */\n\npackage org.slf4j;\n\nimport junit.framework.TestCase;\n\n\n/**\n * Test whether invoking the SLF4J API causes problems or not.\n * \n * @author Ceki Gulcu\n *\n */\npublic class InvokingSLF4J extends TestCase {\n\n  public InvokingSLF4J (String arg0) {\n    super(arg0);\n  }\n\n  /*\n   * @see TestCase#setUp()\n   */\n  protected void setUp() throws Exception {\n    super.setUp();\n  }\n\n  /*\n   * @see TestCase#tearDown()\n   */\n  protected void tearDown() throws Exception {\n    super.tearDown();\n  }\n  \n  public void test1() {\n    Logger logger = LoggerFactory.getLogger(\"test1\");\n    logger.debug(\"Hello world.\");\n  }\n  \n  public void test2() {\n    Integer i1 = new Integer(1);\n    Integer i2 = new Integer(2);\n    Integer i3 = new Integer(3);\n    Exception e = new Exception(\"This is a test exception.\");\n    Logger logger = LoggerFactory.getLogger(\"test2\");\n    logger.debug(\"Hello world 1.\");\n    logger.debug(\"Hello world {}\", i1);\n    logger.debug(\"val={} val={}\", i1, i2);\n    logger.debug(\"val={} val={} val={}\", new Object[]{i1, i2, i3});\n    \n    logger.debug(\"Hello world 1\", e);\n    \n    logger.info(\"Hello world 2.\");\n    logger.info(\"Hello world {}\", new Integer(2)); \n    logger.warn(\"Hello world 3.\");\n    logger.warn(\"Hello world 3.\", e);\n    logger.warn(\"Hello world {}\", new Integer(3)); \n    logger.error(\"Hello world 4.\");\n    logger.error(\"Hello world {}\", new Integer(3)); \n    logger.error(\"Hello world 4.\", e);\n\n    \n  }\n}\n","Smelly Sample":"/* \n * Copyright (c) 2004-2005 SLF4J.ORG\n * Copyright (c) 2004-2005 QOS.CH\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute, and/or sell copies of  the Software, and to permit persons\n * to whom  the Software is furnished  to do so, provided  that the above\n * copyright notice(s) and this permission notice appear in all copies of\n * the  Software and  that both  the above  copyright notice(s)  and this\n * permission notice appear in supporting documentation.\n * \n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR  A PARTICULAR PURPOSE AND NONINFRINGEMENT\n * OF  THIRD PARTY  RIGHTS. IN  NO EVENT  SHALL THE  COPYRIGHT  HOLDER OR\n * HOLDERS  INCLUDED IN  THIS  NOTICE BE  LIABLE  FOR ANY  CLAIM, OR  ANY\n * SPECIAL INDIRECT  OR CONSEQUENTIAL DAMAGES, OR  ANY DAMAGES WHATSOEVER\n * RESULTING FROM LOSS  OF USE, DATA OR PROFITS, WHETHER  IN AN ACTION OF\n * CONTRACT, NEGLIGENCE  OR OTHER TORTIOUS  ACTION, ARISING OUT OF  OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n * \n * Except as  contained in  this notice, the  name of a  copyright holder\n * shall not be used in advertising or otherwise to promote the sale, use\n * or other dealings in this Software without prior written authorization\n * of the copyright holder.\n *\n */\n\npackage org.slf4j;\n\nimport junit.framework.TestCase;\n\n\n/**\n * Test whether invoking the SLF4J API causes problems or not.\n * \n * @author Ceki Gulcu\n *\n */\npublic class InvokingSLF4J extends TestCase {\n\n  public InvokingSLF4J (String arg0) {\n    super(arg0);\n  }\n\n  /*\n   * @see TestCase#setUp()\n   */\n  protected void setUp() throws Exception {\n    super.setUp();\n  }\n\n  /*\n   * @see TestCase#tearDown()\n   */\n  protected void tearDown() throws Exception {\n    super.tearDown();\n  }\n  \n  public void test1() {\n    Logger logger = LoggerFactory.getLogger(\"test1\");\n    logger.debug(\"Hello world.\");\n  }\n  \n  public void test2() {\n    Exception e = new Exception(\"This is a test exception.\");\n    Logger logger = LoggerFactory.getLogger(\"test2\");\n    logger.debug(\"Hello world 1.\");\n    logger.debug(\"Hello world {}\", new Integer(1));\n    logger.debug(\"Hello world 1\", e);\n    logger.info(\"Hello world 2.\");\n    logger.info(\"Hello world {}\", new Integer(2)); \n    logger.warn(\"Hello world 3.\");\n    logger.warn(\"Hello world 3.\", e);\n    logger.warn(\"Hello world {}\", new Integer(3)); \n    logger.error(\"Hello world 4.\");\n    logger.error(\"Hello world {}\", new Integer(3)); \n    logger.error(\"Hello world 4.\", e);\n\n    \n  }\n}\n","lineNo":71}
{"Refactored Sample":"/* \n * Copyright (c) 2004-2005 SLF4J.ORG\n * Copyright (c) 2004-2005 QOS.ch\n *\n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute, and/or sell copies of  the Software, and to permit persons\n * to whom  the Software is furnished  to do so, provided  that the above\n * copyright notice(s) and this permission notice appear in all copies of\n * the  Software and  that both  the above  copyright notice(s)  and this\n * permission notice appear in supporting documentation.\n * \n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR  A PARTICULAR PURPOSE AND NONINFRINGEMENT\n * OF  THIRD PARTY  RIGHTS. IN  NO EVENT  SHALL THE  COPYRIGHT  HOLDER OR\n * HOLDERS  INCLUDED IN  THIS  NOTICE BE  LIABLE  FOR ANY  CLAIM, OR  ANY\n * SPECIAL INDIRECT  OR CONSEQUENTIAL DAMAGES, OR  ANY DAMAGES WHATSOEVER\n * RESULTING FROM LOSS  OF USE, DATA OR PROFITS, WHETHER  IN AN ACTION OF\n * CONTRACT, NEGLIGENCE  OR OTHER TORTIOUS  ACTION, ARISING OUT OF  OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n * \n * Except as  contained in  this notice, the  name of a  copyright holder\n * shall not be used in advertising or otherwise to promote the sale, use\n * or other dealings in this Software without prior written authorization\n * of the copyright holder.\n *\n */\n\npackage org.slf4j.impl;\n\n\n/**\n * Formats messages according to very simple rules. \n * See {@link #format(String, Object)} and \n * {@link #format(String, Object, Object)} for more details.\n *\n * @author <a href=\"http://www.qos.ch/log4j/\">Ceki G&uuml;lc&uuml;<\/a>\n */\npublic class MessageFormatter {\n  static final char DELIM_START = '{';\n  static final char DELIM_STOP = '}';\n\n  /**\n   * Performs single argument substitution for the 'messagePattern' passed as\n   * parameter.\n   * <p>\n   * For example, <code>MessageFormatter.format(\"Hi {}.\", \"there\");<\/code> will\n   * return the string \"Hi there.\".\n   * <p>\n   * The {} pair is called the formatting element. It serves to designate the\n   * location where the argument needs to be inserted within the pattern.\n   * \n   * @param messagePattern The message pattern which will be parsed and formatted\n   * @param argument The argument to be inserted instead of the formatting element\n   * @return The formatted message\n   */\n  public static String format(String messagePattern, Object arg) {\n    return arrayFormat(messagePattern, new Object[] {arg});   \n   }\n  \n  /**\n   *\n   * Performs a two argument substitution for the 'messagePattern' passed as\n   * parameter.\n   * <p>\n   * For example, <code>MessageFormatter.format(\"Hi {}. My name is {}.\", \n   * \"there\", \"David\");<\/code> will return the string \"Hi there. My name is David.\".\n   * <p>\n   * The '{}' pair is called a formatting element. It serves to designate the\n   * location where the arguments need to be inserted within the message pattern.\n   * \n   * @param messagePattern The message pattern which will be parsed and formatted\n   * @param arg1 The first argument to replace the first formatting element\n   * @param arg2 The second argument to replace the second formatting element\n   * @return The formatted message\n   */\n  public static String format(String messagePattern, Object arg1, Object arg2) {\n   return arrayFormat(messagePattern, new Object[] {arg1, arg2});   \n  }\n  \n  public static String arrayFormat(String messagePattern, Object[] argArray) {\n    if(messagePattern == null) {\n      return null;\n    }\n    int i = 0;\n    int len = messagePattern.length();\n    int j = messagePattern.indexOf(DELIM_START);\n    \n    char escape = 'x';\n    \n    StringBuffer sbuf = new StringBuffer(messagePattern.length() + 50);\n\n    for (int L = 0; L < argArray.length; L++) {\n      j = messagePattern.indexOf(DELIM_START, i);\n\n      if (j == -1 || (j+1 == len)) {\n        // no more variables\n        if (i == 0) { // this is a simple string\n          return messagePattern;\n        } else { // add the tail string which contains no variables and return the result.\n          sbuf.append(messagePattern.substring(i, messagePattern.length()));\n          return sbuf.toString();\n        }\n      } else {\n        char delimStop = messagePattern.charAt(j + 1);\n        if (j > 0) {\n          escape = messagePattern.charAt(j - 1);\n        }\n        \n        if(escape == '\\\\') {\n          sbuf.append(messagePattern.substring(i, j));\n          sbuf.append(DELIM_START);\n          i = j + 1;\n        } else if ((delimStop != DELIM_STOP)) {\n          // invalid DELIM_START/DELIM_STOP pair\n          sbuf.append(messagePattern.substring(i, messagePattern.length()));\n          return sbuf.toString();\n        } else {\n          // normal case\n          sbuf.append(messagePattern.substring(i, j));\n          sbuf.append(argArray[L]);\n          i = j + 2;\n        }\n      }\n    }\n    // append the characters following the second {} pair.\n    sbuf.append(messagePattern.substring(i, messagePattern.length()));\n    return sbuf.toString();\n  }\n}\n","Smelly Sample":"/* \n * Copyright (c) 2004-2005 SLF4J.ORG\n * Copyright (c) 2004-2005 QOS.ch\n *\n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute, and/or sell copies of  the Software, and to permit persons\n * to whom  the Software is furnished  to do so, provided  that the above\n * copyright notice(s) and this permission notice appear in all copies of\n * the  Software and  that both  the above  copyright notice(s)  and this\n * permission notice appear in supporting documentation.\n * \n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR  A PARTICULAR PURPOSE AND NONINFRINGEMENT\n * OF  THIRD PARTY  RIGHTS. IN  NO EVENT  SHALL THE  COPYRIGHT  HOLDER OR\n * HOLDERS  INCLUDED IN  THIS  NOTICE BE  LIABLE  FOR ANY  CLAIM, OR  ANY\n * SPECIAL INDIRECT  OR CONSEQUENTIAL DAMAGES, OR  ANY DAMAGES WHATSOEVER\n * RESULTING FROM LOSS  OF USE, DATA OR PROFITS, WHETHER  IN AN ACTION OF\n * CONTRACT, NEGLIGENCE  OR OTHER TORTIOUS  ACTION, ARISING OUT OF  OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n * \n * Except as  contained in  this notice, the  name of a  copyright holder\n * shall not be used in advertising or otherwise to promote the sale, use\n * or other dealings in this Software without prior written authorization\n * of the copyright holder.\n *\n */\n\npackage org.slf4j.impl;\n\n\n/**\n * Formats messages according to very simple rules. \n * See {@link #format(String, Object)} and \n * {@link #format(String, Object, Object)} for more details.\n *\n * @author <a href=\"http://www.qos.ch/log4j/\">Ceki G&uuml;lc&uuml;<\/a>\n */\npublic class MessageFormatter {\n  static final char DELIM_START = '{';\n  static final char DELIM_STOP = '}';\n\n  /**\n   * Performs single argument substitution for the 'messagePattern' passed as\n   * parameter.\n   * <p>\n   * For example, <code>MessageFormatter.format(\"Hi {}.\", \"there\");<\/code> will\n   * return the string \"Hi there.\".\n   * <p>\n   * The {} pair is called the formatting element. It serves to designate the\n   * location where the argument needs to be inserted within the pattern.\n   * \n   * @param messagePattern The message pattern which will be parsed and formatted\n   * @param argument The argument to be inserted instead of the formatting element\n   * @return The formatted message\n   */\n  public static String format(String messagePattern, Object argument) {\n    int j = messagePattern.indexOf(DELIM_START);\n    int len = messagePattern.length();\n    char escape = 'x';\n\n    // if there are no { characters or { is the last character of the messsage\n    // then we just return messagePattern\n    if (j == -1 || (j+1 == len)) {\n      return messagePattern;\n    } else {\n      if(j+1 == len) {\n      }\n      \n      char delimStop = messagePattern.charAt(j + 1);\n      if (j > 0) {\n        escape = messagePattern.charAt(j - 1);\n      }\n      if ((delimStop != DELIM_STOP) || (escape == '\\\\')) {\n        // invalid DELIM_START/DELIM_STOP pair or espace character is\n        // present\n        return messagePattern;\n      } else {\n        StringBuffer sbuf = new StringBuffer(len + 20);\n        sbuf.append(messagePattern.substring(0, j));\n        sbuf.append(argument);\n        sbuf.append(messagePattern.substring(j + 2));\n        return sbuf.toString();\n      }\n    }\n  }\n\n  /**\n   * /**\n   * Performs a two argument substitution for the 'messagePattern' passed as\n   * parameter.\n   * <p>\n   * For example, <code>MessageFormatter.format(\"Hi {}. My name is {}.\", \n   * \"there\", \"David\");<\/code> will return the string \"Hi there. My name is David.\".\n   * <p>\n   * The '{}' pair is called a formatting element. It serves to designate the\n   * location where the arguments need to be inserted within the message pattern.\n   * \n   * @param messagePattern The message pattern which will be parsed and formatted\n   * @param arg1 The first argument to replace the first formatting element\n   * @param arg2 The second argument to replace the second formatting element\n   * @return The formatted message\n   */\n  public static String format(String messagePattern, Object arg1, Object arg2) {\n    int i = 0;\n    int len = messagePattern.length();\n    int j = messagePattern.indexOf(DELIM_START);\n\n    StringBuffer sbuf = new StringBuffer(messagePattern.length() + 50);\n\n    for (int L = 0; L < 2; L++) {\n      j = messagePattern.indexOf(DELIM_START, i);\n\n      if (j == -1 || (j+1 == len)) {\n        // no more variables\n        if (i == 0) { // this is a simple string\n          return messagePattern;\n        } else { // add the tail string which contains no variables and return the result.\n          sbuf.append(messagePattern.substring(i, messagePattern.length()));\n          return sbuf.toString();\n        }\n      } else {\n        char delimStop = messagePattern.charAt(j + 1);\n        if ((delimStop != DELIM_STOP)) {\n          // invalid DELIM_START/DELIM_STOP pair\n          sbuf.append(messagePattern.substring(i, messagePattern.length()));\n          return sbuf.toString();\n        }\n        sbuf.append(messagePattern.substring(i, j));\n        sbuf.append((L == 0) ? arg1 : arg2);\n        i = j + 2;\n      }\n    }\n    // append the characters following the second {} pair.\n    sbuf.append(messagePattern.substring(i, messagePattern.length()));\n    return sbuf.toString();\n  }\n}\n","lineNo":90}
