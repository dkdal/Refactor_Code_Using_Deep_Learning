{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n * <p>\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n * <p>\n * or (per the licensee's choosing)\n * <p>\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.rolling;\n\nimport ch.qos.logback.classic.ClassicTestConstants;\nimport ch.qos.logback.classic.Logger;\nimport ch.qos.logback.classic.LoggerContext;\nimport ch.qos.logback.classic.joran.JoranConfigurator;\nimport ch.qos.logback.classic.spi.ILoggingEvent;\nimport ch.qos.logback.classic.util.LogbackMDCAdapter;\nimport ch.qos.logback.core.CoreConstants;\nimport ch.qos.logback.core.joran.spi.JoranException;\nimport ch.qos.logback.core.rolling.RollingFileAppender;\nimport ch.qos.logback.core.rolling.TimeBasedFileNamingAndTriggeringPolicy;\nimport ch.qos.logback.core.rolling.TimeBasedRollingPolicy;\nimport ch.qos.logback.core.rolling.testUtil.ScaffoldingForRollingTests;\nimport ch.qos.logback.core.status.Status;\nimport ch.qos.logback.core.status.testUtil.StatusChecker;\nimport ch.qos.logback.core.util.StatusPrinter;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Date;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class TimeBasedRollingWithConfigFileTest extends ScaffoldingForRollingTests {\n\n    LoggerContext loggerContext = new LoggerContext();\n    LogbackMDCAdapter logbackMDCAdapter = new LogbackMDCAdapter();\n    StatusChecker statusChecker = new StatusChecker(loggerContext);\n    Logger logger = loggerContext.getLogger(this.getClass());\n    int fileSize = 0;\n    int fileIndexCounter = -1;\n    int sizeThreshold;\n\n    @BeforeEach\n    @Override\n    public void setUp() {\n        loggerContext.setName(\"test\");\n        loggerContext.setMDCAdapter(logbackMDCAdapter);\n        super.setUp();\n        loggerContext.putProperty(\"randomOutputDir\", randomOutputDir);\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception {\n    }\n\n    void loadConfig(String confifFile) throws JoranException {\n        JoranConfigurator jc = new JoranConfigurator();\n        jc.setContext(loggerContext);\n        jc.doConfigure(confifFile);\n        currentTime = System.currentTimeMillis();\n        recomputeRolloverThreshold(currentTime);\n    }\n\n    @Test\n    public void basic() throws Exception {\n        String testId = \"basic\";\n        loggerContext.putProperty(\"testId\", testId);\n        loadConfig(ClassicTestConstants.JORAN_INPUT_PREFIX + \"rolling/\" + testId + \".xml\");\n        statusChecker.assertIsErrorFree();\n\n        Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n\n        expectedFilenameList.add(randomOutputDir + \"z\" + testId);\n\n        RollingFileAppender<ILoggingEvent> rfa = (RollingFileAppender<ILoggingEvent>) root.getAppender(\"ROLLING\");\n\n        TimeBasedRollingPolicy<ILoggingEvent> tprp = (TimeBasedRollingPolicy<ILoggingEvent>) rfa.getTriggeringPolicy();\n        TimeBasedFileNamingAndTriggeringPolicy<ILoggingEvent> tbnatp = tprp.getTimeBasedFileNamingAndTriggeringPolicy();\n\n        String prefix = \"Hello---\";\n        int runLength = 4;\n        for (int i = 0; i < runLength; i++) {\n            logger.debug(prefix + i);\n            addExpectedFileNamedIfItsTime_ByDate(randomOutputDir, testId, false);\n            incCurrentTime(500);\n            tbnatp.setCurrentTime(currentTime);\n        }\n\n        existenceCheck(expectedFilenameList);\n        sortedContentCheck(randomOutputDir, runLength, prefix);\n    }\n\n    @Test\n    public void depratedSizeAndTimeBasedFNATPWarning() throws Exception {\n        String testId = \"depratedSizeAndTimeBasedFNATPWarning\";\n        loggerContext.putProperty(\"testId\", testId);\n        loadConfig(ClassicTestConstants.JORAN_INPUT_PREFIX + \"rolling/\" + testId + \".xml\");\n        StatusPrinter.print(loggerContext);\n        statusChecker.assertContainsMatch(Status.WARN, CoreConstants.SIZE_AND_TIME_BASED_FNATP_IS_DEPRECATED);\n    }\n\n    @Test\n    public void timeAndSize() throws Exception {\n        String testId = \"timeAndSize\";\n        loggerContext.putProperty(\"testId\", testId);\n        String prefix = \"Hello-----\";\n\n        // the number of times the log file will be written to before time based\n        // roll-over occurs\n        int approxWritesPerPeriod = 64;\n        sizeThreshold = prefix.length() * approxWritesPerPeriod;\n        loggerContext.putProperty(\"sizeThreshold\", \"\" + sizeThreshold);\n        System.out.println(\"timeAndSize.sizeThreshold=\"+sizeThreshold);\n        loadConfig(ClassicTestConstants.JORAN_INPUT_PREFIX + \"rolling/\" + testId + \".xml\");\n\n        StatusPrinter.print(loggerContext);\n        // Test http://jira.qos.ch/browse/LOGBACK-1236\n        statusChecker.assertNoMatch(CoreConstants.SIZE_AND_TIME_BASED_FNATP_IS_DEPRECATED);\n\n        Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n\n        expectedFilenameList.add(randomOutputDir + \"z\" + testId);\n\n        RollingFileAppender<ILoggingEvent> rfa = (RollingFileAppender<ILoggingEvent>) root.getAppender(\"ROLLING\");\n\n        statusChecker.assertIsErrorFree();\n\n        TimeBasedRollingPolicy<ILoggingEvent> tprp = (TimeBasedRollingPolicy<ILoggingEvent>) rfa.getTriggeringPolicy();\n        TimeBasedFileNamingAndTriggeringPolicy<ILoggingEvent> tbnatp = tprp.getTimeBasedFileNamingAndTriggeringPolicy();\n\n        int timeIncrement = 1000 / approxWritesPerPeriod;\n        int targetPeriodCount = 3;\n        int runLength = approxWritesPerPeriod * targetPeriodCount;\n        for (int i = 0; i < runLength; i++) {\n            String msg = prefix + i;\n            logger.debug(msg);\n            addExpectedFileNamedIfItsTime(testId, msg, false);\n            incCurrentTime(timeIncrement);\n            tbnatp.setCurrentTime(currentTime);\n        }\n\n        sortedContentCheck(randomOutputDir, runLength, prefix);\n        int eCount = existenceCount(expectedFilenameList);\n        // for various reasons, it is extremely difficult to have the files\n        // match exactly the expected archive files. Thus, we aim for\n        // an approximate match\n        assertTrue(eCount >= targetPeriodCount || eCount >= expectedFilenameList.size() / 2,\n                \"existenceCount=\" + eCount + \", expectedFilenameList.size=\" + expectedFilenameList.size());\n    }\n\n    @Test\n    public void timeAndSizeWithoutIntegerToken() throws Exception {\n        String testId = \"timeAndSizeWithoutIntegerToken\";\n        loadConfig(ClassicTestConstants.JORAN_INPUT_PREFIX + \"rolling/\" + testId + \".xml\");\n        Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n        expectedFilenameList.add(randomOutputDir + \"z\" + testId);\n        RollingFileAppender<ILoggingEvent> rfa = (RollingFileAppender<ILoggingEvent>) root.getAppender(\"ROLLING\");\n        StatusPrinter.print(loggerContext);\n\n        statusChecker.assertContainsMatch(\"Missing integer token\");\n        assertFalse(rfa.isStarted());\n    }\n\n    // see also LOGBACK-1176\n    @Test\n    public void timeAndSizeWithoutMaxFileSize() throws Exception {\n        String testId = \"timeAndSizeWithoutMaxFileSize\";\n        loadConfig(ClassicTestConstants.JORAN_INPUT_PREFIX + \"rolling/\" + testId + \".xml\");\n        Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n        // expectedFilenameList.add(randomOutputDir + \"z\" + testId);\n        RollingFileAppender<ILoggingEvent> rfa = (RollingFileAppender<ILoggingEvent>) root.getAppender(\"ROLLING\");\n\n        // statusChecker.assertContainsMatch(\"Missing integer token\");\n        assertFalse(rfa.isStarted());\n        StatusPrinter.print(loggerContext);\n    }\n\n    @Test\n    public void totalSizeCapSmallerThanMaxFileSize() throws Exception {\n        String testId = \"totalSizeCapSmallerThanMaxFileSize\";\n        loggerContext.putProperty(\"testId\", testId);\n        loadConfig(ClassicTestConstants.JORAN_INPUT_PREFIX + \"rolling/\" + testId + \".xml\");\n        Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n        // expectedFilenameList.add(randomOutputDir + \"z\" + testId);\n        RollingFileAppender<ILoggingEvent> rfa = (RollingFileAppender<ILoggingEvent>) root.getAppender(\"ROLLING\");\n\n        statusChecker.assertContainsMatch(\n                \"totalSizeCap of \\\\[\\\\d* \\\\w*\\\\] is smaller than maxFileSize \\\\[\\\\d* \\\\w*\\\\] which is non-sensical\");\n        assertFalse(rfa.isStarted());\n\n    }\n\n    void addExpectedFileNamedIfItsTime(String testId, String msg, boolean gzExtension) {\n        fileSize += msg.getBytes().length;\n\n        if (passThresholdTime(nextRolloverThreshold)) {\n            fileIndexCounter = 0;\n            fileSize = 0;\n            addExpectedFileName(testId, getDateOfPreviousPeriodsStart(), fileIndexCounter, gzExtension);\n            recomputeRolloverThreshold(currentTime);\n            return;\n        }\n\n        // windows can delay file size changes, so we only allow for\n        // fileIndexCounter 0 and 1\n        if ((fileIndexCounter < 1) && fileSize > sizeThreshold) {\n            addExpectedFileName(testId, getDateOfPreviousPeriodsStart(), ++fileIndexCounter, gzExtension);\n            fileSize = -1;\n            return;\n        }\n    }\n\n    void addExpectedFileName(String testId, Date date, int fileIndexCounter, boolean gzExtension) {\n\n        String fn = randomOutputDir + testId + \"-\" + SDF.format(date) + \".\" + fileIndexCounter;\n        if (gzExtension) {\n            fn += \".gz\";\n        }\n        System.out.println(\"Adding \" + fn);\n        expectedFilenameList.add(fn);\n    }\n\n    @Override\n    protected void addExpectedFileNamedIfItsTime_ByDate(String outputDir, String testId, boolean gzExtension) {\n        if (passThresholdTime(nextRolloverThreshold)) {\n            addExpectedFileName_ByDate(outputDir, testId, getDateOfPreviousPeriodsStart(), gzExtension);\n            recomputeRolloverThreshold(currentTime);\n        }\n    }\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n * <p>\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n * <p>\n * or (per the licensee's choosing)\n * <p>\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.rolling;\n\nimport ch.qos.logback.classic.ClassicTestConstants;\nimport ch.qos.logback.classic.Logger;\nimport ch.qos.logback.classic.LoggerContext;\nimport ch.qos.logback.classic.joran.JoranConfigurator;\nimport ch.qos.logback.classic.spi.ILoggingEvent;\nimport ch.qos.logback.classic.util.LogbackMDCAdapter;\nimport ch.qos.logback.core.CoreConstants;\nimport ch.qos.logback.core.joran.spi.JoranException;\nimport ch.qos.logback.core.rolling.RollingFileAppender;\nimport ch.qos.logback.core.rolling.TimeBasedFileNamingAndTriggeringPolicy;\nimport ch.qos.logback.core.rolling.TimeBasedRollingPolicy;\nimport ch.qos.logback.core.rolling.testUtil.ScaffoldingForRollingTests;\nimport ch.qos.logback.core.status.Status;\nimport ch.qos.logback.core.status.testUtil.StatusChecker;\nimport ch.qos.logback.core.util.StatusPrinter;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Date;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class TimeBasedRollingWithConfigFileTest extends ScaffoldingForRollingTests {\n\n    LoggerContext loggerContext = new LoggerContext();\n    LogbackMDCAdapter logbackMDCAdapter = new LogbackMDCAdapter();\n    StatusChecker statusChecker = new StatusChecker(loggerContext);\n    Logger logger = loggerContext.getLogger(this.getClass());\n    int fileSize = 0;\n    int fileIndexCounter = -1;\n    int sizeThreshold;\n\n    @BeforeEach\n    @Override\n    public void setUp() {\n        loggerContext.setName(\"test\");\n        loggerContext.setMDCAdapter(logbackMDCAdapter);\n        super.setUp();\n        loggerContext.putProperty(\"randomOutputDir\", randomOutputDir);\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception {\n    }\n\n    void loadConfig(String confifFile) throws JoranException {\n        JoranConfigurator jc = new JoranConfigurator();\n        jc.setContext(loggerContext);\n        jc.doConfigure(confifFile);\n        currentTime = System.currentTimeMillis();\n        recomputeRolloverThreshold(currentTime);\n    }\n\n    @Test\n    public void basic() throws Exception {\n        String testId = \"basic\";\n        loggerContext.putProperty(\"testId\", testId);\n        loadConfig(ClassicTestConstants.JORAN_INPUT_PREFIX + \"rolling/\" + testId + \".xml\");\n        statusChecker.assertIsErrorFree();\n\n        Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n\n        expectedFilenameList.add(randomOutputDir + \"z\" + testId);\n\n        RollingFileAppender<ILoggingEvent> rfa = (RollingFileAppender<ILoggingEvent>) root.getAppender(\"ROLLING\");\n\n        TimeBasedRollingPolicy<ILoggingEvent> tprp = (TimeBasedRollingPolicy<ILoggingEvent>) rfa.getTriggeringPolicy();\n        TimeBasedFileNamingAndTriggeringPolicy<ILoggingEvent> tbnatp = tprp.getTimeBasedFileNamingAndTriggeringPolicy();\n\n        String prefix = \"Hello---\";\n        int runLength = 4;\n        for (int i = 0; i < runLength; i++) {\n            logger.debug(prefix + i);\n            addExpectedFileNamedIfItsTime_ByDate(randomOutputDir, testId, false);\n            incCurrentTime(500);\n            tbnatp.setCurrentTime(currentTime);\n        }\n\n        existenceCheck(expectedFilenameList);\n        sortedContentCheck(randomOutputDir, runLength, prefix);\n    }\n\n    @Test\n    public void depratedSizeAndTimeBasedFNATPWarning() throws Exception {\n        String testId = \"depratedSizeAndTimeBasedFNATPWarning\";\n        loggerContext.putProperty(\"testId\", testId);\n        loadConfig(ClassicTestConstants.JORAN_INPUT_PREFIX + \"rolling/\" + testId + \".xml\");\n        StatusPrinter.print(loggerContext);\n        statusChecker.assertContainsMatch(Status.WARN, CoreConstants.SIZE_AND_TIME_BASED_FNATP_IS_DEPRECATED);\n    }\n\n    @Test\n    public void timeAndSize() throws Exception {\n        String testId = \"timeAndSize\";\n        loggerContext.putProperty(\"testId\", testId);\n        String prefix = \"Hello-----\";\n\n        // the number of times the log file will be written to before time based\n        // roll-over occurs\n        int approxWritesPerPeriod = 64;\n        sizeThreshold = prefix.length() * approxWritesPerPeriod;\n        loggerContext.putProperty(\"sizeThreshold\", \"\" + sizeThreshold);\n        loadConfig(ClassicTestConstants.JORAN_INPUT_PREFIX + \"rolling/\" + testId + \".xml\");\n\n        StatusPrinter.print(loggerContext);\n        // Test http://jira.qos.ch/browse/LOGBACK-1236\n        statusChecker.assertNoMatch(CoreConstants.SIZE_AND_TIME_BASED_FNATP_IS_DEPRECATED);\n\n        Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n\n        expectedFilenameList.add(randomOutputDir + \"z\" + testId);\n\n        RollingFileAppender<ILoggingEvent> rfa = (RollingFileAppender<ILoggingEvent>) root.getAppender(\"ROLLING\");\n\n        statusChecker.assertIsErrorFree();\n\n        TimeBasedRollingPolicy<ILoggingEvent> tprp = (TimeBasedRollingPolicy<ILoggingEvent>) rfa.getTriggeringPolicy();\n        TimeBasedFileNamingAndTriggeringPolicy<ILoggingEvent> tbnatp = tprp.getTimeBasedFileNamingAndTriggeringPolicy();\n\n        int timeIncrement = 1000 / approxWritesPerPeriod;\n        int runLength = approxWritesPerPeriod * 3;\n        for (int i = 0; i < runLength; i++) {\n            String msg = prefix + i;\n            logger.debug(msg);\n            addExpectedFileNamedIfItsTime(testId, msg, false);\n            incCurrentTime(timeIncrement);\n            tbnatp.setCurrentTime(currentTime);\n        }\n\n        sortedContentCheck(randomOutputDir, runLength, prefix);\n        int eCount = existenceCount(expectedFilenameList);\n        // for various reasons, it is extremely difficult to have the files\n        // match exactly the expected archive files. Thus, we aim for\n        // an approximate match\n        assertTrue(eCount >= 4 && eCount > expectedFilenameList.size() / 2,\n                \"existenceCount=\" + eCount + \", expectedFilenameList.size=\" + expectedFilenameList.size());\n    }\n\n    @Test\n    public void timeAndSizeWithoutIntegerToken() throws Exception {\n        String testId = \"timeAndSizeWithoutIntegerToken\";\n        loadConfig(ClassicTestConstants.JORAN_INPUT_PREFIX + \"rolling/\" + testId + \".xml\");\n        Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n        expectedFilenameList.add(randomOutputDir + \"z\" + testId);\n        RollingFileAppender<ILoggingEvent> rfa = (RollingFileAppender<ILoggingEvent>) root.getAppender(\"ROLLING\");\n        StatusPrinter.print(loggerContext);\n\n        statusChecker.assertContainsMatch(\"Missing integer token\");\n        assertFalse(rfa.isStarted());\n    }\n\n    // see also LOGBACK-1176\n    @Test\n    public void timeAndSizeWithoutMaxFileSize() throws Exception {\n        String testId = \"timeAndSizeWithoutMaxFileSize\";\n        loadConfig(ClassicTestConstants.JORAN_INPUT_PREFIX + \"rolling/\" + testId + \".xml\");\n        Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n        // expectedFilenameList.add(randomOutputDir + \"z\" + testId);\n        RollingFileAppender<ILoggingEvent> rfa = (RollingFileAppender<ILoggingEvent>) root.getAppender(\"ROLLING\");\n\n        // statusChecker.assertContainsMatch(\"Missing integer token\");\n        assertFalse(rfa.isStarted());\n        StatusPrinter.print(loggerContext);\n    }\n\n    @Test\n    public void totalSizeCapSmallerThanMaxFileSize() throws Exception {\n        String testId = \"totalSizeCapSmallerThanMaxFileSize\";\n        loggerContext.putProperty(\"testId\", testId);\n        loadConfig(ClassicTestConstants.JORAN_INPUT_PREFIX + \"rolling/\" + testId + \".xml\");\n        Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n        // expectedFilenameList.add(randomOutputDir + \"z\" + testId);\n        RollingFileAppender<ILoggingEvent> rfa = (RollingFileAppender<ILoggingEvent>) root.getAppender(\"ROLLING\");\n\n        statusChecker.assertContainsMatch(\n                \"totalSizeCap of \\\\[\\\\d* \\\\w*\\\\] is smaller than maxFileSize \\\\[\\\\d* \\\\w*\\\\] which is non-sensical\");\n        assertFalse(rfa.isStarted());\n\n    }\n\n    void addExpectedFileNamedIfItsTime(String testId, String msg, boolean gzExtension) {\n        fileSize += msg.getBytes().length;\n\n        if (passThresholdTime(nextRolloverThreshold)) {\n            fileIndexCounter = 0;\n            fileSize = 0;\n            addExpectedFileName(testId, getDateOfPreviousPeriodsStart(), fileIndexCounter, gzExtension);\n            recomputeRolloverThreshold(currentTime);\n            return;\n        }\n\n        // windows can delay file size changes, so we only allow for\n        // fileIndexCounter 0 and 1\n        if ((fileIndexCounter < 1) && fileSize > sizeThreshold) {\n            addExpectedFileName(testId, getDateOfPreviousPeriodsStart(), ++fileIndexCounter, gzExtension);\n            fileSize = -1;\n            return;\n        }\n    }\n\n    void addExpectedFileName(String testId, Date date, int fileIndexCounter, boolean gzExtension) {\n\n        String fn = randomOutputDir + testId + \"-\" + SDF.format(date) + \".\" + fileIndexCounter;\n        System.out.println(\"Adding \" + fn);\n        if (gzExtension) {\n            fn += \".gz\";\n        }\n        expectedFilenameList.add(fn);\n    }\n\n    @Override\n    protected void addExpectedFileNamedIfItsTime_ByDate(String outputDir, String testId, boolean gzExtension) {\n        if (passThresholdTime(nextRolloverThreshold)) {\n            addExpectedFileName_ByDate(outputDir, testId, getDateOfPreviousPeriodsStart(), gzExtension);\n            recomputeRolloverThreshold(currentTime);\n        }\n    }\n}\n","lineNo":139}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.util;\n\nimport static ch.qos.logback.core.subst.NodeToStringTransformer.CIRCULAR_VARIABLE_REFERENCE_DETECTED;\nimport static ch.qos.logback.core.subst.Parser.EXPECTING_DATA_AFTER_LEFT_ACCOLADE;\nimport static java.util.concurrent.TimeUnit.SECONDS;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport ch.qos.logback.core.testUtil.RandomUtil;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\n\nimport ch.qos.logback.core.Context;\nimport ch.qos.logback.core.ContextBase;\nimport ch.qos.logback.core.joran.spi.JoranException;\nimport ch.qos.logback.core.spi.ScanException;\nimport org.junit.jupiter.api.Timeout;\n\npublic class OptionHelperTest {\n\n    String text = \"Testing ${v1} variable substitution ${v2}\";\n    String expected = \"Testing if variable substitution works\";\n    Context context = new ContextBase();\n    Map<String, String> secondaryMap;\n\n    int diff = RandomUtil.getPositiveInt();\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        secondaryMap = new HashMap<String, String>();\n    }\n\n    @Test\n    public void testLiteral() throws ScanException {\n        String noSubst = \"hello world\";\n        String result = OptionHelper.substVars(noSubst, context);\n        assertEquals(noSubst, result);\n    }\n\n    @Test\n    public void testUndefinedValues() throws ScanException {\n        String withUndefinedValues = \"${axyz}\";\n\n        String result = OptionHelper.substVars(withUndefinedValues, context);\n        assertEquals(\"axyz\" + OptionHelper._IS_UNDEFINED, result);\n    }\n\n    @Test\n    public void testSubstVarsVariableNotClosed() throws ScanException {\n        String noSubst = \"testing if ${v1 works\";\n\n        try {\n            @SuppressWarnings(\"unused\")\n            String result = OptionHelper.substVars(noSubst, context);\n            fail();\n        } catch (IllegalArgumentException e) {\n            // ok\n        }\n    }\n\n    @Test\n    public void testSubstVarsContextOnly() throws ScanException {\n        context.putProperty(\"v1\", \"if\");\n        context.putProperty(\"v2\", \"works\");\n\n        String result = OptionHelper.substVars(text, context);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testSubstVarsSystemProperties() throws ScanException {\n        System.setProperty(\"v1\", \"if\");\n        System.setProperty(\"v2\", \"works\");\n\n        String result = OptionHelper.substVars(text, context);\n        assertEquals(expected, result);\n\n        System.clearProperty(\"v1\");\n        System.clearProperty(\"v2\");\n    }\n\n    @Test\n    public void testSubstVarsWithDefault() throws ScanException {\n        context.putProperty(\"v1\", \"if\");\n        String textWithDefault = \"Testing ${v1} variable substitution ${v2:-toto}\";\n        String resultWithDefault = \"Testing if variable substitution toto\";\n\n        String result = OptionHelper.substVars(textWithDefault, context);\n        assertEquals(resultWithDefault, result);\n    }\n\n    @Test\n    public void testSubstVarsRecursive() throws ScanException {\n        context.putProperty(\"v1\", \"if\");\n        context.putProperty(\"v2\", \"${v3}\");\n        context.putProperty(\"v3\", \"works\");\n\n        String result = OptionHelper.substVars(text, context);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testSubstVarsTwoLevelsDeep() throws ScanException {\n        context.putProperty(\"v1\", \"if\");\n        context.putProperty(\"v2\", \"${v3}\");\n        context.putProperty(\"v3\", \"${v4}\");\n        context.putProperty(\"v4\", \"works\");\n\n        String result = OptionHelper.substVars(text, context);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testSubstVarsTwoLevelsWithDefault() throws ScanException {\n        // Example input taken from LOGBCK-943 bug report\n        context.putProperty(\"APP_NAME\", \"LOGBACK\");\n        context.putProperty(\"ARCHIVE_SUFFIX\", \"archive.log\");\n        context.putProperty(\"LOG_HOME\", \"${logfilepath.default:-logs}\");\n        context.putProperty(\"ARCHIVE_PATH\", \"${LOG_HOME}/archive/${APP_NAME}\");\n\n        String result = OptionHelper.substVars(\"${ARCHIVE_PATH}_trace_${ARCHIVE_SUFFIX}\", context);\n        assertEquals(\"logs/archive/LOGBACK_trace_archive.log\", result);\n    }\n\n    @Test\n    @Timeout(value = 1, unit = SECONDS)\n    public void stubstVarsShouldNotGoIntoInfiniteLoop() throws ScanException {\n        context.putProperty(\"v1\", \"if\");\n        context.putProperty(\"v2\", \"${v3}\");\n        context.putProperty(\"v3\", \"${v4}\");\n        context.putProperty(\"v4\", \"${v2}c\");\n\n        Exception e = assertThrows(Exception.class, () -> {\n            OptionHelper.substVars(text, context);\n        });\n        String expectedMessage =  CIRCULAR_VARIABLE_REFERENCE_DETECTED+\"${v2} --> ${v3} --> ${v4} --> ${v2}]\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n    \n    @Test\n    public void nonCircularGraphShouldWork() throws ScanException {\n        context.putProperty(\"A\", \"${B} and ${C}\");\n        context.putProperty(\"B\", \"${B1}\");\n        context.putProperty(\"B1\", \"B1-value\");\n        context.putProperty(\"C\", \"${C1} and ${B}\");\n        context.putProperty(\"C1\", \"C1-value\");\n\n        String result = OptionHelper.substVars(\"${A}\", context);\n        assertEquals(\"B1-value and C1-value and B1-value\", result);\n    }\n\n    @Test\n    @Timeout(value = 1, unit = SECONDS)\n    public void detectCircularReferences0() throws ScanException {\n        context.putProperty(\"A\", \"${A}\");\n        Exception e = assertThrows(IllegalArgumentException.class, () -> {\n           OptionHelper.substVars(\"${A}\", context);\n        });\n        String expectedMessage = CIRCULAR_VARIABLE_REFERENCE_DETECTED+\"${A} --> ${A}]\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n\n    @Test\n    @Timeout(value = 1, unit = SECONDS)\n    public void detectCircularReferences1() throws ScanException {\n        context.putProperty(\"A\", \"${A}a\");\n\n        Exception e = assertThrows(IllegalArgumentException.class, () -> {\n            OptionHelper.substVars(\"${A}\", context);\n        });\n        \n        String expectedMessage = CIRCULAR_VARIABLE_REFERENCE_DETECTED+\"${A} --> ${A}]\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n\n    @Test\n    @Timeout(value = 1, unit = SECONDS)\n    public void detectCircularReferences2() throws ScanException {\n        context.putProperty(\"A\", \"${B}\");\n        context.putProperty(\"B\", \"${C}\");\n        context.putProperty(\"C\", \"${A}\");\n\n        Exception e = assertThrows(IllegalArgumentException.class, () -> {\n           OptionHelper.substVars(\"${A}\", context);\n        });\n        String expectedMessage = CIRCULAR_VARIABLE_REFERENCE_DETECTED+\"${A} --> ${B} --> ${C} --> ${A}]\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n\n    // https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=46755\n    @Test\n    public void recursionErrorWithNullLiteralPayload() throws ScanException {\n\n        Exception e = assertThrows(IllegalArgumentException.class, () -> {\n           OptionHelper.substVars(\"abc${AA$AA${}}}xyz\", context);\n        });\n        String expectedMessage = CIRCULAR_VARIABLE_REFERENCE_DETECTED+\"${AA} --> ${}]\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n\n    // https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=46892\n    @Test\n    public void leftAccoladeFollowedByDefaultStateWithNoLiteral() throws ScanException {\n        Exception e = assertThrows(ScanException.class, () -> {\n            OptionHelper.substVars(\"x{:-a}\", context);\n        });\n        String expectedMessage = EXPECTING_DATA_AFTER_LEFT_ACCOLADE;\n        assertEquals(expectedMessage, e.getMessage());\n    }\n\n    // https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=46966\n    @Test\n    public void nestedEmptyVariables() throws ScanException {\n\n        Exception e = assertThrows(Exception.class, () -> {\n            OptionHelper.substVars(\"${${${}}}\", context);\n        });\n        String expectedMessage =  CIRCULAR_VARIABLE_REFERENCE_DETECTED+\"${ ?  ? } --> ${ ? } --> ${}]\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n    \n    \n    \n    @Test\n    public void detectCircularReferencesInDefault() throws ScanException {\n        context.putProperty(\"A\", \"${B:-${A}}\");\n     \n\n        Exception e = assertThrows(IllegalArgumentException.class, () -> {\n            OptionHelper.substVars(\"${A}\", context);\n        });\n\n        String expectedMessage = CIRCULAR_VARIABLE_REFERENCE_DETECTED+\"${A} --> ${B} --> ${A}]\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n\n    @Test\n    @Timeout(value = 1, unit = SECONDS)\n    public void detectCircularReferences3() throws ScanException {\n        context.putProperty(\"A\", \"${B}\");\n        context.putProperty(\"B\", \"${C}\");\n        context.putProperty(\"C\", \"${A}\");\n\n        Exception e = assertThrows(IllegalArgumentException.class, () -> {\n            OptionHelper.substVars(\"${B} \", context);\n        });\n        String expectedMessage = CIRCULAR_VARIABLE_REFERENCE_DETECTED + \"${B} --> ${C} --> ${A} --> ${B}]\";\n        assertEquals(expectedMessage, e.getMessage());\n\n    }\n\n    @Test\n    @Timeout(value = 1, unit = SECONDS)\n    public void detectCircularReferences4() throws ScanException {\n        context.putProperty(\"A\", \"${B}\");\n        context.putProperty(\"B\", \"${C}\");\n        context.putProperty(\"C\", \"${A}\");\n\n        \n        Exception e = assertThrows(IllegalArgumentException.class, () -> {\n            OptionHelper.substVars(\"${C} and ${A}\", context);\n        });\n        String expectedMessage = CIRCULAR_VARIABLE_REFERENCE_DETECTED+\"${C} --> ${A} --> ${B} --> ${C}]\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n\n    @Test\n    public void detectCircularReferences5() throws ScanException {\n        context.putProperty(\"A\", \"${B} and ${C}\");\n        context.putProperty(\"B\", \"${B1}\");\n        context.putProperty(\"B1\", \"B1-value\");\n        context.putProperty(\"C\", \"${C1}\");\n        context.putProperty(\"C1\", \"here's the loop: ${A}\");\n\n        \n        Exception e = assertThrows(IllegalArgumentException.class, () -> {\n            OptionHelper.substVars(\"${A}\", context);\n        });\n        String expectedMessage = CIRCULAR_VARIABLE_REFERENCE_DETECTED+\"${A} --> ${C} --> ${C1} --> ${A}]\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n\n    @Test\n    public void defaultValueReferencingAVariable() throws ScanException {\n        context.putProperty(\"v1\", \"k1\");\n        String result = OptionHelper.substVars(\"${undef:-${v1}}\", context);\n        assertEquals(\"k1\", result);\n    }\n\n    @Test\n    public void jackrabbit_standalone() throws ScanException {\n        String r = OptionHelper.substVars(\"${jackrabbit.log:-${repo:-jackrabbit}/log/jackrabbit.log}\", context);\n        assertEquals(\"jackrabbit/log/jackrabbit.log\", r);\n    }\n\n    @Test\n    public void emptyVariableIsAccepted() throws JoranException, ScanException {\n        String varName = \"var\"+diff;\n        context.putProperty(varName, \"\");\n        String r = OptionHelper.substVars(\"x ${\"+varName+\"} b\", context);\n        assertEquals(\"x  b\", r);\n    }\n\n    // https://jira.qos.ch/browse/LOGBACK-1012\n    // conflicts with the idea that variables assigned the empty string are valid\n    @Disabled\n    @Test\n    public void defaultExpansionForEmptyVariables() throws JoranException, ScanException {\n        String varName = \"var\"+diff;\n        context.putProperty(varName, \"\");\n\n        String r = OptionHelper.substVars(\"x ${\"+varName+\":-def} b\", context);\n        assertEquals(\"x def b\", r);\n    }\n\n    @Test\n    public void emptyDefault() throws ScanException {\n        String r = OptionHelper.substVars(\"a${undefinedX:-}b\", context);\n        assertEquals(\"ab\", r);\n    }\n\n    @Test\n    public void openBraceAsLastCharacter() throws JoranException, ScanException {\n        Exception e = assertThrows(IllegalArgumentException.class, () -> {\n            OptionHelper.substVars(\"a{a{\", context);\n        });\n        String expectedMessage = \"All tokens consumed but was expecting \\\"}\\\"\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n\n    \n    @Test\n    public void trailingColon_LOGBACK_1140() throws ScanException {\n        String prefix = \"c:\";\n        String suffix = \"/tmp\";\n        context.putProperty(\"var\", prefix);\n        String r = OptionHelper.substVars(\"${var}\" + suffix, context);\n        assertEquals(prefix + suffix, r);\n    }\n\n\n\n\n    @Test\n    public void curlyBraces_LOGBACK_1101() throws ScanException {\n        {\n            String input = \"foo{bar}\";\n            String r = OptionHelper.substVars(input, context);\n            assertEquals(input, r);\n        }\n        {\n            String input = \"{foo{\\\"bar\\\"}}\";\n            String r = OptionHelper.substVars(input, context);\n            assertEquals(input, r);\n        }\n        {\n            String input = \"a:{y}\";\n            String r = OptionHelper.substVars(input, context);\n            assertEquals(input, r);\n        }\n        {\n            String input = \"{world:{yay}}\";\n            String r = OptionHelper.substVars(input, context);\n            assertEquals(input, r);\n        }\n        {\n            String input = \"{hello:{world:yay}}\";\n            String r = OptionHelper.substVars(input, context);\n            assertEquals(input, r);\n        }\n        {\n            String input = \"{\\\"hello\\\":{\\\"world\\\":\\\"yay\\\"}}\";\n            String r = OptionHelper.substVars(input, context);\n            assertEquals(input, r);\n        }\n    }\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.util;\n\nimport static ch.qos.logback.core.subst.NodeToStringTransformer.CIRCULAR_VARIABLE_REFERENCE_DETECTED;\nimport static ch.qos.logback.core.subst.Parser.EXPECTING_DATA_AFTER_LEFT_ACCOLADE;\nimport static java.util.concurrent.TimeUnit.SECONDS;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport ch.qos.logback.core.Context;\nimport ch.qos.logback.core.ContextBase;\nimport ch.qos.logback.core.joran.spi.JoranException;\nimport ch.qos.logback.core.spi.ScanException;\nimport org.junit.jupiter.api.Timeout;\n\npublic class OptionHelperTest {\n\n    String text = \"Testing ${v1} variable substitution ${v2}\";\n    String expected = \"Testing if variable substitution works\";\n    Context context = new ContextBase();\n    Map<String, String> secondaryMap;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        secondaryMap = new HashMap<String, String>();\n    }\n\n    @Test\n    public void testLiteral() throws ScanException {\n        String noSubst = \"hello world\";\n        String result = OptionHelper.substVars(noSubst, context);\n        assertEquals(noSubst, result);\n    }\n\n    @Test\n    public void testUndefinedValues() throws ScanException {\n        String withUndefinedValues = \"${axyz}\";\n\n        String result = OptionHelper.substVars(withUndefinedValues, context);\n        assertEquals(\"axyz\" + OptionHelper._IS_UNDEFINED, result);\n    }\n\n    @Test\n    public void testSubstVarsVariableNotClosed() throws ScanException {\n        String noSubst = \"testing if ${v1 works\";\n\n        try {\n            @SuppressWarnings(\"unused\")\n            String result = OptionHelper.substVars(noSubst, context);\n            fail();\n        } catch (IllegalArgumentException e) {\n            // ok\n        }\n    }\n\n    @Test\n    public void testSubstVarsContextOnly() throws ScanException {\n        context.putProperty(\"v1\", \"if\");\n        context.putProperty(\"v2\", \"works\");\n\n        String result = OptionHelper.substVars(text, context);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testSubstVarsSystemProperties() throws ScanException {\n        System.setProperty(\"v1\", \"if\");\n        System.setProperty(\"v2\", \"works\");\n\n        String result = OptionHelper.substVars(text, context);\n        assertEquals(expected, result);\n\n        System.clearProperty(\"v1\");\n        System.clearProperty(\"v2\");\n    }\n\n    @Test\n    public void testSubstVarsWithDefault() throws ScanException {\n        context.putProperty(\"v1\", \"if\");\n        String textWithDefault = \"Testing ${v1} variable substitution ${v2:-toto}\";\n        String resultWithDefault = \"Testing if variable substitution toto\";\n\n        String result = OptionHelper.substVars(textWithDefault, context);\n        assertEquals(resultWithDefault, result);\n    }\n\n    @Test\n    public void testSubstVarsRecursive() throws ScanException {\n        context.putProperty(\"v1\", \"if\");\n        context.putProperty(\"v2\", \"${v3}\");\n        context.putProperty(\"v3\", \"works\");\n\n        String result = OptionHelper.substVars(text, context);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testSubstVarsTwoLevelsDeep() throws ScanException {\n        context.putProperty(\"v1\", \"if\");\n        context.putProperty(\"v2\", \"${v3}\");\n        context.putProperty(\"v3\", \"${v4}\");\n        context.putProperty(\"v4\", \"works\");\n\n        String result = OptionHelper.substVars(text, context);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testSubstVarsTwoLevelsWithDefault() throws ScanException {\n        // Example input taken from LOGBCK-943 bug report\n        context.putProperty(\"APP_NAME\", \"LOGBACK\");\n        context.putProperty(\"ARCHIVE_SUFFIX\", \"archive.log\");\n        context.putProperty(\"LOG_HOME\", \"${logfilepath.default:-logs}\");\n        context.putProperty(\"ARCHIVE_PATH\", \"${LOG_HOME}/archive/${APP_NAME}\");\n\n        String result = OptionHelper.substVars(\"${ARCHIVE_PATH}_trace_${ARCHIVE_SUFFIX}\", context);\n        assertEquals(\"logs/archive/LOGBACK_trace_archive.log\", result);\n    }\n\n    @Test\n    @Timeout(value = 1, unit = SECONDS)\n    public void stubstVarsShouldNotGoIntoInfiniteLoop() throws ScanException {\n        context.putProperty(\"v1\", \"if\");\n        context.putProperty(\"v2\", \"${v3}\");\n        context.putProperty(\"v3\", \"${v4}\");\n        context.putProperty(\"v4\", \"${v2}c\");\n\n        Exception e = assertThrows(Exception.class, () -> {\n            OptionHelper.substVars(text, context);\n        });\n        String expectedMessage =  CIRCULAR_VARIABLE_REFERENCE_DETECTED+\"${v2} --> ${v3} --> ${v4} --> ${v2}]\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n    \n    @Test\n    public void nonCircularGraphShouldWork() throws ScanException {\n        context.putProperty(\"A\", \"${B} and ${C}\");\n        context.putProperty(\"B\", \"${B1}\");\n        context.putProperty(\"B1\", \"B1-value\");\n        context.putProperty(\"C\", \"${C1} and ${B}\");\n        context.putProperty(\"C1\", \"C1-value\");\n\n        String result = OptionHelper.substVars(\"${A}\", context);\n        assertEquals(\"B1-value and C1-value and B1-value\", result);\n    }\n\n    @Test\n    @Timeout(value = 1, unit = SECONDS)\n    public void detectCircularReferences0() throws ScanException {\n        context.putProperty(\"A\", \"${A}\");\n        Exception e = assertThrows(IllegalArgumentException.class, () -> {\n           OptionHelper.substVars(\"${A}\", context);\n        });\n        String expectedMessage = CIRCULAR_VARIABLE_REFERENCE_DETECTED+\"${A} --> ${A}]\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n\n    @Test\n    @Timeout(value = 1, unit = SECONDS)\n    public void detectCircularReferences1() throws ScanException {\n        context.putProperty(\"A\", \"${A}a\");\n\n        Exception e = assertThrows(IllegalArgumentException.class, () -> {\n            OptionHelper.substVars(\"${A}\", context);\n        });\n        \n        String expectedMessage = CIRCULAR_VARIABLE_REFERENCE_DETECTED+\"${A} --> ${A}]\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n\n    @Test\n    @Timeout(value = 1, unit = SECONDS)\n    public void detectCircularReferences2() throws ScanException {\n        context.putProperty(\"A\", \"${B}\");\n        context.putProperty(\"B\", \"${C}\");\n        context.putProperty(\"C\", \"${A}\");\n\n        Exception e = assertThrows(IllegalArgumentException.class, () -> {\n           OptionHelper.substVars(\"${A}\", context);\n        });\n        String expectedMessage = CIRCULAR_VARIABLE_REFERENCE_DETECTED+\"${A} --> ${B} --> ${C} --> ${A}]\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n\n    // https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=46755\n    @Test\n    public void recursionErrorWithNullLiteralPayload() throws ScanException {\n\n        Exception e = assertThrows(IllegalArgumentException.class, () -> {\n           OptionHelper.substVars(\"abc${AA$AA${}}}xyz\", context);\n        });\n        String expectedMessage = CIRCULAR_VARIABLE_REFERENCE_DETECTED+\"${AA} --> ${}]\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n\n    // https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=46892\n    @Test\n    public void leftAccoladeFollowedByDefaultStateWithNoLiteral() throws ScanException {\n        Exception e = assertThrows(ScanException.class, () -> {\n            OptionHelper.substVars(\"x{:-a}\", context);\n        });\n        String expectedMessage = EXPECTING_DATA_AFTER_LEFT_ACCOLADE;\n        assertEquals(expectedMessage, e.getMessage());\n    }\n\n    // https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=46966\n    @Test\n    public void nestedEmptyVariables() throws ScanException {\n\n        Exception e = assertThrows(Exception.class, () -> {\n            OptionHelper.substVars(\"${${${}}}\", context);\n        });\n        String expectedMessage =  CIRCULAR_VARIABLE_REFERENCE_DETECTED+\"${ ?  ? } --> ${ ? } --> ${}]\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n    \n    \n    \n    @Test\n    public void detectCircularReferencesInDefault() throws ScanException {\n        context.putProperty(\"A\", \"${B:-${A}}\");\n     \n\n        Exception e = assertThrows(IllegalArgumentException.class, () -> {\n            OptionHelper.substVars(\"${A}\", context);\n        });\n\n        String expectedMessage = CIRCULAR_VARIABLE_REFERENCE_DETECTED+\"${A} --> ${B} --> ${A}]\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n\n    @Test\n    @Timeout(value = 1, unit = SECONDS)\n    public void detectCircularReferences3() throws ScanException {\n        context.putProperty(\"A\", \"${B}\");\n        context.putProperty(\"B\", \"${C}\");\n        context.putProperty(\"C\", \"${A}\");\n\n        Exception e = assertThrows(IllegalArgumentException.class, () -> {\n            OptionHelper.substVars(\"${B} \", context);\n        });\n        String expectedMessage = CIRCULAR_VARIABLE_REFERENCE_DETECTED + \"${B} --> ${C} --> ${A} --> ${B}]\";\n        assertEquals(expectedMessage, e.getMessage());\n\n    }\n\n    @Test\n    @Timeout(value = 1, unit = SECONDS)\n    public void detectCircularReferences4() throws ScanException {\n        context.putProperty(\"A\", \"${B}\");\n        context.putProperty(\"B\", \"${C}\");\n        context.putProperty(\"C\", \"${A}\");\n\n        \n        Exception e = assertThrows(IllegalArgumentException.class, () -> {\n            OptionHelper.substVars(\"${C} and ${A}\", context);\n        });\n        String expectedMessage = CIRCULAR_VARIABLE_REFERENCE_DETECTED+\"${C} --> ${A} --> ${B} --> ${C}]\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n\n    @Test\n    public void detectCircularReferences5() throws ScanException {\n        context.putProperty(\"A\", \"${B} and ${C}\");\n        context.putProperty(\"B\", \"${B1}\");\n        context.putProperty(\"B1\", \"B1-value\");\n        context.putProperty(\"C\", \"${C1}\");\n        context.putProperty(\"C1\", \"here's the loop: ${A}\");\n\n        \n        Exception e = assertThrows(IllegalArgumentException.class, () -> {\n            OptionHelper.substVars(\"${A}\", context);\n        });\n        String expectedMessage = CIRCULAR_VARIABLE_REFERENCE_DETECTED+\"${A} --> ${C} --> ${C1} --> ${A}]\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n\n    @Test\n    public void defaultValueReferencingAVariable() throws ScanException {\n        context.putProperty(\"v1\", \"k1\");\n        String result = OptionHelper.substVars(\"${undef:-${v1}}\", context);\n        assertEquals(\"k1\", result);\n    }\n\n    @Test\n    public void jackrabbit_standalone() throws ScanException {\n        String r = OptionHelper.substVars(\"${jackrabbit.log:-${repo:-jackrabbit}/log/jackrabbit.log}\", context);\n        assertEquals(\"jackrabbit/log/jackrabbit.log\", r);\n    }\n\n    @Test\n    public void doesNotThrowNullPointerExceptionForEmptyVariable() throws JoranException, ScanException {\n        context.putProperty(\"var\", \"\");\n        OptionHelper.substVars(\"${var}\", context);\n    }\n\n    @Test\n    public void openBraceAsLastCharacter() throws JoranException, ScanException {\n        Exception e = assertThrows(IllegalArgumentException.class, () -> {\n            OptionHelper.substVars(\"a{a{\", context);\n        });\n        String expectedMessage = \"All tokens consumed but was expecting \\\"}\\\"\";\n        assertEquals(expectedMessage, e.getMessage());\n    }\n\n    \n    @Test\n    public void trailingColon_LOGBACK_1140() throws ScanException {\n        String prefix = \"c:\";\n        String suffix = \"/tmp\";\n        context.putProperty(\"var\", prefix);\n        String r = OptionHelper.substVars(\"${var}\" + suffix, context);\n        assertEquals(prefix + suffix, r);\n    }\n\n    @Test\n    public void curlyBraces_LOGBACK_1101() throws ScanException {\n        {\n            String input = \"foo{bar}\";\n            String r = OptionHelper.substVars(input, context);\n            assertEquals(input, r);\n        }\n        {\n            String input = \"{foo{\\\"bar\\\"}}\";\n            String r = OptionHelper.substVars(input, context);\n            assertEquals(input, r);\n        }\n        {\n            String input = \"a:{y}\";\n            String r = OptionHelper.substVars(input, context);\n            assertEquals(input, r);\n        }\n        {\n            String input = \"{world:{yay}}\";\n            String r = OptionHelper.substVars(input, context);\n            assertEquals(input, r);\n        }\n        {\n            String input = \"{hello:{world:yay}}\";\n            String r = OptionHelper.substVars(input, context);\n            assertEquals(input, r);\n        }\n        {\n            String input = \"{\\\"hello\\\":{\\\"world\\\":\\\"yay\\\"}}\";\n            String r = OptionHelper.substVars(input, context);\n            assertEquals(input, r);\n        }\n    }\n}\n","lineNo":316}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.issue.lbclassic135;\n\nimport ch.qos.logback.classic.Logger;\nimport ch.qos.logback.classic.LoggerContext;\nimport ch.qos.logback.classic.encoder.PatternLayoutEncoder;\nimport ch.qos.logback.classic.spi.ILoggingEvent;\nimport ch.qos.logback.core.FileAppender;\nimport ch.qos.logback.core.contention.RunnableWithCounterAndDone;\nimport ch.qos.logback.core.contention.ThreadedThroughputCalculator;\n\n/**\n * Short sample code testing the throughput of a fair lock.\n * \n * @author Ceki Gulcu\n */\npublic class LoggingToFileThroughput {\n\n    static int THREAD_COUNT = 1;\n    static long OVERALL_DURATION_IN_MILLIS = 5000;\n\n    public static void main(String args[]) throws InterruptedException {\n\n        ThreadedThroughputCalculator tp = new ThreadedThroughputCalculator(OVERALL_DURATION_IN_MILLIS);\n        tp.printEnvironmentInfo(\"lbclassic135  LoggingToFileThrouhput\");\n\n        LoggerContext lc = new LoggerContext();\n        Logger logger = buildLoggerContext(lc);\n\n        for (int i = 0; i < 2; i++) {\n            tp.execute(buildArray(logger));\n        }\n\n        RunnableWithCounterAndDone[] runnnableArray = buildArray(logger);\n        tp.execute(runnnableArray);\n        tp.printThroughput(runnnableArray, \"File:   \");\n        lc.stop();\n    }\n\n    static Logger buildLoggerContext(LoggerContext lc) {\n        Logger root = lc.getLogger(Logger.ROOT_LOGGER_NAME);\n\n        PatternLayoutEncoder patternLayout = new PatternLayoutEncoder();\n        patternLayout.setContext(lc);\n        patternLayout.setPattern(\"%d %l [%t] - %msg%n\");\n        patternLayout.start();\n        FileAppender<ILoggingEvent> fileAppender = new FileAppender<ILoggingEvent>();\n        fileAppender.setContext(lc);\n        fileAppender.setFile(\"target/lbclassic135.log\");\n        fileAppender.setEncoder(patternLayout);\n        fileAppender.setAppend(false);\n        fileAppender.start();\n        root.addAppender(fileAppender);\n        return lc.getLogger(LoggingToFileThroughput.class);\n    }\n\n    static LoggingRunnable[] buildArray(Logger logger) {\n\n        LoggingRunnable[] array = new LoggingRunnable[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            array[i] = new LoggingRunnable(logger);\n        }\n        return array;\n    }\n}\n\n// === lbclassic135 LoggingToFileThrouhput ===\n// ******** 10 Threads *****\n// synchronized doAppend() method\n//\n// java.runtime.version = 1.6.0_05-b13\n// java.vendor = Sun Microsystems Inc.\n// os.name = Windows XP\n//\n// Threads 1: total of 485077 operations, or 97 operations per millisecond\n// Threads 10: total of 309402 operations, or 61 operations per millisecond\n\n// * After revision 2310\n// * Threads 1: total of 462465 operations, or 92 operations per millisecond\n// * Threads 10: total of 243362 operations, or 48 operations per millisecond\n\n// ==================== Linux ========================\n\n// java.runtime.version = 1.6.0_11-b03\n// java.vendor = Sun Microsystems Inc.\n// os.name = Linux\n// os.version = 2.6.25-gentoo-r6\n// Threads 1: total of 356355 operations, or 71 operations per millisecond\n// Threads 10: total of 287943 operations, or 57 operations per millisecond\n\n// * After revision 2310\n// * Threads 1: total of 331494 operations, or 66 operations per millisecond\n// * Threads 10: total of 311104 operations, or 58 operations per millisecond\n\n// java.runtime.version = jvmxa6460-20081105_25433\n// java.vendor = IBM Corporation\n// java.version = 1.6.0\n// os.name = Linux\n// os.version = 2.6.25-gentoo-r6\n// Threads 1: total of 280381 operations, or 56 operations per millisecond\n// Threads 10 total of 142989 operations, or 28 operations per millisecond\n\n// * After revision 2310\n// * Threads 1: total of 305638 operations, or 61 operations per millisecond\n// * Threads 10: total of 147660 operations, or 29 operations per millisecond\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.issue.lbclassic135;\n\nimport ch.qos.logback.classic.Logger;\nimport ch.qos.logback.classic.LoggerContext;\nimport ch.qos.logback.classic.encoder.PatternLayoutEncoder;\nimport ch.qos.logback.classic.spi.ILoggingEvent;\nimport ch.qos.logback.core.FileAppender;\nimport ch.qos.logback.core.contention.ThreadedThroughputCalculator;\n\n/**\n * Short sample code testing the throughput of a fair lock.\n * \n * @author Ceki Gulcu\n */\npublic class LoggingToFileThroughput {\n\n    static int THREAD_COUNT = 1;\n    static long OVERALL_DURATION_IN_MILLIS = 5000;\n\n    public static void main(String args[]) throws InterruptedException {\n\n        ThreadedThroughputCalculator tp = new ThreadedThroughputCalculator(OVERALL_DURATION_IN_MILLIS);\n        tp.printEnvironmentInfo(\"lbclassic135  LoggingToFileThrouhput\");\n\n        LoggerContext lc = new LoggerContext();\n        Logger logger = buildLoggerContext(lc);\n\n        for (int i = 0; i < 2; i++) {\n            tp.execute(buildArray(logger));\n        }\n\n        tp.execute(buildArray(logger));\n        tp.printThroughput(\"File:   \");\n        lc.stop();\n    }\n\n    static Logger buildLoggerContext(LoggerContext lc) {\n        Logger root = lc.getLogger(Logger.ROOT_LOGGER_NAME);\n\n        PatternLayoutEncoder patternLayout = new PatternLayoutEncoder();\n        patternLayout.setContext(lc);\n        patternLayout.setPattern(\"%d %l [%t] - %msg%n\");\n        patternLayout.start();\n        FileAppender<ILoggingEvent> fileAppender = new FileAppender<ILoggingEvent>();\n        fileAppender.setContext(lc);\n        fileAppender.setFile(\"target/lbclassic135.log\");\n        fileAppender.setEncoder(patternLayout);\n        fileAppender.setAppend(false);\n        fileAppender.start();\n        root.addAppender(fileAppender);\n        return lc.getLogger(LoggingToFileThroughput.class);\n    }\n\n    static LoggingRunnable[] buildArray(Logger logger) {\n\n        LoggingRunnable[] array = new LoggingRunnable[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            array[i] = new LoggingRunnable(logger);\n        }\n        return array;\n    }\n}\n\n// === lbclassic135 LoggingToFileThrouhput ===\n// ******** 10 Threads *****\n// synchronized doAppend() method\n//\n// java.runtime.version = 1.6.0_05-b13\n// java.vendor = Sun Microsystems Inc.\n// os.name = Windows XP\n//\n// Threads 1: total of 485077 operations, or 97 operations per millisecond\n// Threads 10: total of 309402 operations, or 61 operations per millisecond\n\n// * After revision 2310\n// * Threads 1: total of 462465 operations, or 92 operations per millisecond\n// * Threads 10: total of 243362 operations, or 48 operations per millisecond\n\n// ==================== Linux ========================\n\n// java.runtime.version = 1.6.0_11-b03\n// java.vendor = Sun Microsystems Inc.\n// os.name = Linux\n// os.version = 2.6.25-gentoo-r6\n// Threads 1: total of 356355 operations, or 71 operations per millisecond\n// Threads 10: total of 287943 operations, or 57 operations per millisecond\n\n// * After revision 2310\n// * Threads 1: total of 331494 operations, or 66 operations per millisecond\n// * Threads 10: total of 311104 operations, or 58 operations per millisecond\n\n// java.runtime.version = jvmxa6460-20081105_25433\n// java.vendor = IBM Corporation\n// java.version = 1.6.0\n// os.name = Linux\n// os.version = 2.6.25-gentoo-r6\n// Threads 1: total of 280381 operations, or 56 operations per millisecond\n// Threads 10 total of 142989 operations, or 28 operations per millisecond\n\n// * After revision 2310\n// * Threads 1: total of 305638 operations, or 61 operations per millisecond\n// * Threads 10: total of 147660 operations, or 29 operations per millisecond\n","lineNo":46}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.issue.lbclassic36;\n\nimport ch.qos.logback.classic.issue.lbclassic36.SelectiveDateFormattingRunnable.FormattingModel;\nimport ch.qos.logback.core.contention.ThreadedThroughputCalculator;\n\n/**\n * Measure the threaded throughput of date formatting operations\n * \n * @author Joern Huxhorn\n * @author Ceki Gulcu\n */\npublic class DateFormattingThreadedThroughputCalculator {\n\n    static int THREAD_COUNT = 16;\n    static long OVERALL_DURATION_IN_MILLIS = 3000;\n\n    public static void main(String args[]) throws InterruptedException {\n\n        ThreadedThroughputCalculator tp = new ThreadedThroughputCalculator(OVERALL_DURATION_IN_MILLIS);\n        tp.printEnvironmentInfo(\"DateFormatting\");\n\n        for (int i = 0; i < 2; i++) {\n            tp.execute(buildArray(FormattingModel.SDF));\n            tp.execute(buildArray(FormattingModel.JODA));\n        }\n\n        SelectiveDateFormattingRunnable[] runnnableArrayJODA = buildArray(FormattingModel.JODA);\n        tp.execute(runnnableArrayJODA);\n        tp.printThroughput(runnnableArrayJODA, \"JODA: \");\n\n        SelectiveDateFormattingRunnable[] runnnableArraySDF =  buildArray(FormattingModel.JODA);\n        tp.execute(runnnableArraySDF);\n        tp.printThroughput(runnnableArraySDF, \"SDF:  \");\n\n    }\n\n    static SelectiveDateFormattingRunnable[] buildArray(FormattingModel model) {\n        SelectiveDateFormattingRunnable[] array = new SelectiveDateFormattingRunnable[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            array[i] = new SelectiveDateFormattingRunnable(model);\n        }\n        return array;\n    }\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.issue.lbclassic36;\n\nimport ch.qos.logback.classic.issue.lbclassic36.SelectiveDateFormattingRunnable.FormattingModel;\nimport ch.qos.logback.core.contention.ThreadedThroughputCalculator;\n\n/**\n * Measure the threaded throughput of date formatting operations\n * \n * @author Joern Huxhorn\n * @author Ceki Gulcu\n */\npublic class DateFormattingThreadedThroughputCalculator {\n\n    static int THREAD_COUNT = 16;\n    static long OVERALL_DURATION_IN_MILLIS = 3000;\n\n    public static void main(String args[]) throws InterruptedException {\n\n        ThreadedThroughputCalculator tp = new ThreadedThroughputCalculator(OVERALL_DURATION_IN_MILLIS);\n        tp.printEnvironmentInfo(\"DateFormatting\");\n\n        for (int i = 0; i < 2; i++) {\n            tp.execute(buildArray(FormattingModel.SDF));\n            tp.execute(buildArray(FormattingModel.JODA));\n        }\n\n        tp.execute(buildArray(FormattingModel.JODA));\n        tp.printThroughput(\"JODA: \");\n\n        tp.execute(buildArray(FormattingModel.SDF));\n        tp.printThroughput(\"SDF:  \");\n\n    }\n\n    static SelectiveDateFormattingRunnable[] buildArray(FormattingModel model) {\n        SelectiveDateFormattingRunnable[] array = new SelectiveDateFormattingRunnable[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            array[i] = new SelectiveDateFormattingRunnable(model);\n        }\n        return array;\n    }\n\n}\n","lineNo":40}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.issue.lbclassic36;\n\nimport ch.qos.logback.classic.issue.lbclassic36.SelectiveDateFormattingRunnable.FormattingModel;\nimport ch.qos.logback.core.contention.ThreadedThroughputCalculator;\n\n/**\n * Measure the threaded throughput of date formatting operations\n * \n * @author Joern Huxhorn\n * @author Ceki Gulcu\n */\npublic class DateFormattingThreadedThroughputCalculator {\n\n    static int THREAD_COUNT = 16;\n    static long OVERALL_DURATION_IN_MILLIS = 3000;\n\n    public static void main(String args[]) throws InterruptedException {\n\n        ThreadedThroughputCalculator tp = new ThreadedThroughputCalculator(OVERALL_DURATION_IN_MILLIS);\n        tp.printEnvironmentInfo(\"DateFormatting\");\n\n        for (int i = 0; i < 2; i++) {\n            tp.execute(buildArray(FormattingModel.SDF));\n            tp.execute(buildArray(FormattingModel.JODA));\n        }\n\n        SelectiveDateFormattingRunnable[] runnnableArrayJODA = buildArray(FormattingModel.JODA);\n        tp.execute(runnnableArrayJODA);\n        tp.printThroughput(runnnableArrayJODA, \"JODA: \");\n\n        SelectiveDateFormattingRunnable[] runnnableArraySDF =  buildArray(FormattingModel.JODA);\n        tp.execute(runnnableArraySDF);\n        tp.printThroughput(runnnableArraySDF, \"SDF:  \");\n\n    }\n\n    static SelectiveDateFormattingRunnable[] buildArray(FormattingModel model) {\n        SelectiveDateFormattingRunnable[] array = new SelectiveDateFormattingRunnable[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            array[i] = new SelectiveDateFormattingRunnable(model);\n        }\n        return array;\n    }\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.issue.lbclassic36;\n\nimport ch.qos.logback.classic.issue.lbclassic36.SelectiveDateFormattingRunnable.FormattingModel;\nimport ch.qos.logback.core.contention.ThreadedThroughputCalculator;\n\n/**\n * Measure the threaded throughput of date formatting operations\n * \n * @author Joern Huxhorn\n * @author Ceki Gulcu\n */\npublic class DateFormattingThreadedThroughputCalculator {\n\n    static int THREAD_COUNT = 16;\n    static long OVERALL_DURATION_IN_MILLIS = 3000;\n\n    public static void main(String args[]) throws InterruptedException {\n\n        ThreadedThroughputCalculator tp = new ThreadedThroughputCalculator(OVERALL_DURATION_IN_MILLIS);\n        tp.printEnvironmentInfo(\"DateFormatting\");\n\n        for (int i = 0; i < 2; i++) {\n            tp.execute(buildArray(FormattingModel.SDF));\n            tp.execute(buildArray(FormattingModel.JODA));\n        }\n\n        tp.execute(buildArray(FormattingModel.JODA));\n        tp.printThroughput(\"JODA: \");\n\n        tp.execute(buildArray(FormattingModel.SDF));\n        tp.printThroughput(\"SDF:  \");\n\n    }\n\n    static SelectiveDateFormattingRunnable[] buildArray(FormattingModel model) {\n        SelectiveDateFormattingRunnable[] array = new SelectiveDateFormattingRunnable[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            array[i] = new SelectiveDateFormattingRunnable(model);\n        }\n        return array;\n    }\n\n}\n","lineNo":44}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework. Copyright (C) 1999-2015, QOS.ch. All rights\n * reserved.\n *\n * This program and the accompanying materials are dual-licensed under either the terms of the Eclipse Public License\n * v1.0 as published by the Eclipse Foundation\n *\n * or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1 as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.joran;\n\nimport static ch.qos.logback.classic.ClassicTestConstants.JORAN_INPUT_PREFIX;\nimport static ch.qos.logback.classic.joran.ReconfigureOnChangeTask.DETECTED_CHANGE_IN_CONFIGURATION_FILES;\nimport static ch.qos.logback.classic.joran.ReconfigureOnChangeTask.FALLING_BACK_TO_SAFE_CONFIGURATION;\nimport static ch.qos.logback.classic.joran.ReconfigureOnChangeTask.RE_REGISTERING_PREVIOUS_SAFE_CONFIGURATION;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport ch.qos.logback.core.spi.ConfigurationEvent;\nimport ch.qos.logback.core.spi.ConfigurationEventListener;\nimport ch.qos.logback.core.status.OnConsoleStatusListener;\nimport ch.qos.logback.core.status.WarnStatus;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\n\nimport ch.qos.logback.classic.Logger;\nimport ch.qos.logback.classic.LoggerContext;\nimport ch.qos.logback.classic.issue.lbclassic135.LoggingRunnable;\nimport ch.qos.logback.core.CoreConstants;\nimport ch.qos.logback.core.contention.RunnableWithCounterAndDone;\nimport ch.qos.logback.core.joran.spi.ConfigurationWatchList;\nimport ch.qos.logback.core.joran.spi.JoranException;\nimport ch.qos.logback.core.joran.util.ConfigurationWatchListUtil;\nimport ch.qos.logback.core.status.InfoStatus;\nimport ch.qos.logback.core.status.Status;\nimport ch.qos.logback.core.testUtil.CoreTestConstants;\nimport ch.qos.logback.core.testUtil.FileTestUtil;\nimport ch.qos.logback.core.testUtil.RandomUtil;\nimport ch.qos.logback.core.status.testUtil.StatusChecker;\nimport ch.qos.logback.core.util.StatusPrinter;\nimport org.junit.jupiter.api.Timeout;\n\npublic class ReconfigureOnChangeTaskTest {\n    final static int THREAD_COUNT = 5;\n\n    final static int TIMEOUT = 4;\n\n    int diff = RandomUtil.getPositiveInt();\n\n    // the space in the file name mandated by\n    // http://jira.qos.ch/browse/LOGBACK-67\n    final static String SCAN1_FILE_AS_STR = JORAN_INPUT_PREFIX + \"roct/scan 1.xml\";\n\n    final static String SCAN_LOGBACK_474_FILE_AS_STR = JORAN_INPUT_PREFIX + \"roct/scan_logback_474.xml\";\n\n    final static String INCLUSION_SCAN_TOPLEVEL0_AS_STR = JORAN_INPUT_PREFIX + \"roct/inclusion/topLevel0.xml\";\n\n    final static String INCLUSION_SCAN_TOP_BY_RESOURCE_AS_STR = JORAN_INPUT_PREFIX + \"roct/inclusion/topByResource.xml\";\n\n    final static String INCLUSION_SCAN_INNER0_AS_STR = JORAN_INPUT_PREFIX + \"roct/inclusion/inner0.xml\";\n\n    final static String INCLUSION_SCAN_INNER1_AS_STR = \"target/test-classes/asResource/inner1.xml\";\n\n    private static final String SCAN_PERIOD_DEFAULT_FILE_AS_STR = JORAN_INPUT_PREFIX + \"roct/scan_period_default.xml\";\n\n    LoggerContext loggerContext = new LoggerContext();\n    Logger logger = loggerContext.getLogger(this.getClass());\n    StatusChecker statusChecker = new StatusChecker(loggerContext);\n\n    @BeforeAll\n    static public void classSetup() {\n        FileTestUtil.makeTestOutputDir();\n    }\n\n    @BeforeEach\n    public void before() {\n        loggerContext.setName(\"ROCTTest-context\" + diff);\n    }\n\n    void configure(File file) throws JoranException {\n        JoranConfigurator jc = new JoranConfigurator();\n        jc.setContext(loggerContext);\n        jc.doConfigure(file);\n    }\n\n    void configure(InputStream is) throws JoranException {\n        JoranConfigurator jc = new JoranConfigurator();\n        jc.setContext(loggerContext);\n        jc.doConfigure(is);\n    }\n\n    @Test\n    @Timeout(value = TIMEOUT, unit = TimeUnit.SECONDS)\n    public void checkBasicLifecyle() throws JoranException, IOException, InterruptedException {\n        File file = new File(SCAN1_FILE_AS_STR);\n        configure(file);\n        List<File> fileList = getConfigurationWatchList(loggerContext);\n        assertThatListContainsFile(fileList, file);\n        checkThatTaskHasRan();\n        checkThatTaskCanBeStopped();\n    }\n\n    private void checkThatTaskCanBeStopped() {\n        ScheduledFuture<?> future = loggerContext.getCopyOfScheduledFutures().get(0);\n        loggerContext.stop();\n        assertTrue(future.isCancelled());\n    }\n\n    private void checkThatTaskHasRan() throws InterruptedException {\n        waitForReconfigureOnChangeTaskToRun();\n    }\n\n    List<File> getConfigurationWatchList(LoggerContext lc) {\n        ConfigurationWatchList configurationWatchList = ConfigurationWatchListUtil.getConfigurationWatchList(lc);\n        return configurationWatchList.getCopyOfFileWatchList();\n    }\n\n    @Test\n    @Timeout(value = TIMEOUT, unit = TimeUnit.SECONDS)\n    public void scanWithFileInclusion() throws JoranException, IOException, InterruptedException {\n        File topLevelFile = new File(INCLUSION_SCAN_TOPLEVEL0_AS_STR);\n        File innerFile = new File(INCLUSION_SCAN_INNER0_AS_STR);\n        configure(topLevelFile);\n        List<File> fileList = getConfigurationWatchList(loggerContext);\n        assertThatListContainsFile(fileList, topLevelFile);\n        assertThatListContainsFile(fileList, innerFile);\n        checkThatTaskHasRan();\n        checkThatTaskCanBeStopped();\n    }\n\n    @Test\n    @Timeout(value = TIMEOUT, unit = TimeUnit.SECONDS)\n    public void scanWithResourceInclusion() throws JoranException, IOException, InterruptedException {\n        File topLevelFile = new File(INCLUSION_SCAN_TOP_BY_RESOURCE_AS_STR);\n        File innerFile = new File(INCLUSION_SCAN_INNER1_AS_STR);\n        configure(topLevelFile);\n        List<File> fileList = getConfigurationWatchList(loggerContext);\n        assertThatListContainsFile(fileList, topLevelFile);\n        assertThatListContainsFile(fileList, innerFile);\n    }\n\n    // See also http://jira.qos.ch/browse/LOGBACK-338\n    @Test\n    @Timeout(value = TIMEOUT, unit = TimeUnit.SECONDS)\n    public void reconfigurationIsNotPossibleInTheAbsenceOfATopFile()\n            throws IOException, JoranException, InterruptedException {\n\n        ReconfigurationTaskRegisteredConfigEventListener listener = new ReconfigurationTaskRegisteredConfigEventListener();\n        loggerContext.addConfigurationEventListener(listener);\n        String configurationStr = \"<configuration scan=\\\"true\\\" scanPeriod=\\\"50 millisecond\\\"><include resource=\\\"asResource/inner1.xml\\\"/><\/configuration>\";\n        configure(new ByteArrayInputStream(configurationStr.getBytes(\"UTF-8\")));\n\n        ConfigurationWatchList configurationWatchList = ConfigurationWatchListUtil.getConfigurationWatchList(\n                loggerContext);\n        assertNull(configurationWatchList);\n        // assertNull(configurationWatchList.getMainURL());\n\n        statusChecker.containsMatch(Status.WARN, \"Due to missing top level\");\n        //StatusPrinter.print(loggerContext);\n\n        assertFalse(listener.changeDetectorRegisteredEventOccurred);\n        assertEquals(0, loggerContext.getCopyOfScheduledFutures().size());\n    }\n\n    @Test\n    @Timeout(value = TIMEOUT, unit = TimeUnit.SECONDS)\n    public void fallbackToSafe_FollowedByRecovery() throws IOException, JoranException, InterruptedException {\n        String path = CoreTestConstants.OUTPUT_DIR_PREFIX + \"reconfigureOnChangeConfig_fallbackToSafe-\" + diff + \".xml\";\n        File topLevelFile = new File(path);\n        writeToFile(topLevelFile,\n                \"<configuration scan=\\\"true\\\" scanPeriod=\\\"25 millisecond\\\"><root level=\\\"ERROR\\\"/><\/configuration> \");\n\n        addResetResistantOnConsoleStatusListener();\n        configure(topLevelFile);\n\n        long afterFirstConfiguration = System.currentTimeMillis();\n        CountDownLatch changeDetectedLatch = registerChangeDetectedListener();\n        CountDownLatch configurationDoneLatch = registerNewReconfigurationDoneListener();\n\n        String badXML = \"<configuration scan=\\\"true\\\" scanPeriod=\\\"5 millisecond\\\">\\n\" + \"  <root><\/configuration>\";\n        writeToFile(topLevelFile, badXML);\n        changeDetectedLatch.await();\n        configurationDoneLatch.await();\n        addInfo(\"Woke from configurationDoneLatch.await()\", this);\n\n        statusChecker.assertContainsMatch(Status.ERROR, CoreConstants.XML_PARSING);\n        statusChecker.assertContainsMatch(Status.WARN, FALLING_BACK_TO_SAFE_CONFIGURATION);\n        statusChecker.assertContainsMatch(Status.INFO, RE_REGISTERING_PREVIOUS_SAFE_CONFIGURATION);\n\n        loggerContext.getStatusManager().clear();\n\n        addInfo(\"after loggerContext.getStatusManager().clear() \", this);\n        CountDownLatch secondConfigEndedLatch = registerNewReconfigurationDoneListener();\n\n        writeToFile(topLevelFile,\n                \"<configuration scan=\\\"true\\\" scanPeriod=\\\"5 millisecond\\\"><root level=\\\"ERROR\\\"/><\/configuration> \");\n\n        secondConfigEndedLatch.await();\n        try {\n            statusChecker.assertIsErrorFree();\n            statusChecker.containsMatch(DETECTED_CHANGE_IN_CONFIGURATION_FILES);\n        } finally {\n            StatusPrinter.print(loggerContext);\n        }\n    }\n\n    private void addResetResistantOnConsoleStatusListener() {\n        if(1==1)\n            return;\n        OnConsoleStatusListener ocs = new OnConsoleStatusListener();\n        ocs.setContext(loggerContext);\n        ocs.setResetResistant(true);\n        ocs.start();\n        loggerContext.getStatusManager().add(ocs);\n    }\n\n    @Test\n    @Timeout(value = TIMEOUT, unit = TimeUnit.SECONDS)\n    public void fallbackToSafeWithIncludedFile_FollowedByRecovery()\n            throws IOException, JoranException, InterruptedException, ExecutionException {\n        String topLevelFileAsStr =\n                CoreTestConstants.OUTPUT_DIR_PREFIX + \"reconfigureOnChangeConfig_top-\" + diff + \".xml\";\n        String innerFileAsStr =\n                CoreTestConstants.OUTPUT_DIR_PREFIX + \"reconfigureOnChangeConfig_inner-\" + diff + \".xml\";\n        File topLevelFile = new File(topLevelFileAsStr);\n        writeToFile(topLevelFile,\n                \"<configuration xdebug=\\\"true\\\" scan=\\\"true\\\" scanPeriod=\\\"5 millisecond\\\"><include file=\\\"\"\n                        + innerFileAsStr + \"\\\"/><\/configuration> \");\n\n        File innerFile = new File(innerFileAsStr);\n        writeToFile(innerFile, \"<included><root level=\\\"ERROR\\\"/><\/included> \");\n        addResetResistantOnConsoleStatusListener();\n\n        ReconfigurationTaskRegisteredConfigEventListener roctRegisteredListener = new ReconfigurationTaskRegisteredConfigEventListener();\n        loggerContext.addConfigurationEventListener(roctRegisteredListener);\n\n\n        configure(topLevelFile);\n\n        ReconfigureOnChangeTask roct = roctRegisteredListener.reconfigureOnChangeTask;\n\n\n        System.out.println(\"===================================================\");\n\n        CountDownLatch changeDetectedLatch = registerChangeDetectedListener();\n        CountDownLatch configurationDoneLatch = registerNewReconfigurationDoneListener(roct);\n\n        writeToFile(innerFile, \"<included>\\n<root>\\n<\/included>\");\n        changeDetectedLatch.await();\n        configurationDoneLatch.await();\n        addInfo(\"Woke from configurationDoneLatch.await()\", this);\n\n        statusChecker.assertContainsMatch(Status.ERROR, CoreConstants.XML_PARSING);\n        statusChecker.assertContainsMatch(Status.WARN, FALLING_BACK_TO_SAFE_CONFIGURATION);\n        statusChecker.assertContainsMatch(Status.INFO, RE_REGISTERING_PREVIOUS_SAFE_CONFIGURATION);\n\n        loggerContext.getStatusManager().clear();\n\n        CountDownLatch secondDoneLatch = registerNewReconfigurationDoneListener();\n        writeToFile(innerFile, \"<included><root level=\\\"ERROR\\\"/><\/included> \");\n        secondDoneLatch.await();\n\n        statusChecker.assertIsErrorFree();\n        statusChecker.containsMatch(DETECTED_CHANGE_IN_CONFIGURATION_FILES);\n\n    }\n\n    CountDownLatch registerNewReconfigurationDoneListener() {\n        return registerNewReconfigurationDoneListener(null);\n    }\n\n    CountDownLatch registerNewReconfigurationDoneListener(ReconfigureOnChangeTask roct) {\n        CountDownLatch latch = new CountDownLatch(1);\n        ReconfigurationDoneListener reconfigurationDoneListener = new ReconfigurationDoneListener(latch, roct);\n        loggerContext.addConfigurationEventListener(reconfigurationDoneListener);\n        return latch;\n    }\n\n\n    CountDownLatch registerChangeDetectedListener() {\n        CountDownLatch latch = new CountDownLatch(1);\n        ChangeDetectedListener changeDetectedListener = new ChangeDetectedListener(latch);\n        loggerContext.addConfigurationEventListener(changeDetectedListener);\n        return latch;\n    }\n\n\n    class RunMethodInvokedListener implements ConfigurationEventListener {\n        CountDownLatch countDownLatch;\n        ReconfigureOnChangeTask reconfigureOnChangeTask;\n\n        RunMethodInvokedListener(CountDownLatch countDownLatch) {\n            this.countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void listen(ConfigurationEvent configurationEvent) {\n            switch (configurationEvent.getEventType()) {\n            case CHANGE_DETECTOR_RUNNING:\n                countDownLatch.countDown();\n                Object data = configurationEvent.getData();\n                if (data instanceof ReconfigureOnChangeTask) {\n                    reconfigureOnChangeTask = (ReconfigureOnChangeTask) data;\n                }\n                break;\n            default:\n            }\n        }\n    }\n\n    private ReconfigureOnChangeTask waitForReconfigureOnChangeTaskToRun() throws InterruptedException {\n        addInfo(\"entering waitForReconfigureOnChangeTaskToRun\", this);\n\n        CountDownLatch countDownLatch = new CountDownLatch(1);\n        RunMethodInvokedListener runMethodInvokedListener = new RunMethodInvokedListener(countDownLatch);\n\n        loggerContext.addConfigurationEventListener(runMethodInvokedListener);\n        countDownLatch.await();\n        return runMethodInvokedListener.reconfigureOnChangeTask;\n    }\n\n    private RunnableWithCounterAndDone[] buildRunnableArray(File configFile, UpdateType updateType) {\n        RunnableWithCounterAndDone[] rArray = new RunnableWithCounterAndDone[THREAD_COUNT];\n        rArray[0] = new Updater(configFile, updateType);\n        for (int i = 1; i < THREAD_COUNT; i++) {\n            rArray[i] = new LoggingRunnable(logger);\n        }\n        return rArray;\n    }\n\n    @Test\n    public void checkReconfigureTaskScheduledWhenDefaultScanPeriodUsed() throws JoranException {\n        File file = new File(SCAN_PERIOD_DEFAULT_FILE_AS_STR);\n        configure(file);\n\n        final List<ScheduledFuture<?>> scheduledFutures = loggerContext.getCopyOfScheduledFutures();\n        //StatusPrinter.print(loggerContext);\n        assertFalse(scheduledFutures.isEmpty());\n        statusChecker.containsMatch(\"No 'scanPeriod' specified. Defaulting to\");\n\n    }\n\n    // check for deadlocks\n    @Test\n    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n    public void scan_LOGBACK_474() throws JoranException, IOException, InterruptedException {\n        File file = new File(SCAN_LOGBACK_474_FILE_AS_STR);\n        addResetResistantOnConsoleStatusListener();\n        configure(file);\n\n        // ReconfigureOnChangeTask roct = waitForReconfigureOnChangeTaskToRun();\n        System.out.println(\" ------------ creating ReconfigureOnChangeTaskHarness\");\n\n        int expectedResets = 2;\n        ReconfigureOnChangeTaskHarness harness = new ReconfigureOnChangeTaskHarness(loggerContext, expectedResets);\n\n        RunnableWithCounterAndDone[] runnableArray = buildRunnableArray(file, UpdateType.TOUCH);\n        harness.execute(runnableArray);\n\n        addInfo(\"scan_LOGBACK_474 end of execution \", this);\n        checkResetCount(expectedResets);\n    }\n\n    private void assertThatListContainsFile(List<File> fileList, File file) {\n        // conversion to absolute file seems to work nicely\n        assertTrue(fileList.contains(file.getAbsoluteFile()));\n    }\n\n    private void checkResetCount(int expected) {\n        StatusChecker checker = new StatusChecker(loggerContext);\n        checker.assertIsErrorFree();\n\n        int effectiveResets = checker.matchCount(CoreConstants.RESET_MSG_PREFIX);\n        assertEquals(expected, effectiveResets);\n\n        // String failMsg = \"effective=\" + effectiveResets + \", expected=\" + expected;\n        //\n        // there might be more effective resets than the expected amount\n        // since the harness may be sleeping while a reset occurs\n        // assertTrue(failMsg, expected <= effectiveResets && (expected + 2) >=\n        // effectiveResets);\n\n    }\n\n    void addInfo(String msg, Object o) {\n        loggerContext.getStatusManager().add(new InfoStatus(msg, o));\n    }\n\n    void addWarn(String msg, Object o) {\n        loggerContext.getStatusManager().add(new WarnStatus(msg, o));\n    }\n\n    enum UpdateType {\n        TOUCH, MALFORMED, MALFORMED_INNER\n    }\n\n    void writeToFile(File file, String contents) throws IOException {\n        FileWriter fw = new FileWriter(file);\n        fw.write(contents);\n        fw.close();\n        // on linux changes to last modified are not propagated if the\n        // time stamp is near the previous time stamp hence the random delta\n        boolean success = file.setLastModified(System.currentTimeMillis() + RandomUtil.getPositiveInt());\n        if (!success) {\n            addWarn(\"failed to setLastModified on file \" + file, this);\n        }\n    }\n\n    class Updater extends RunnableWithCounterAndDone {\n        File configFile;\n        UpdateType updateType;\n\n        // it actually takes time for Windows to propagate file modification changes\n        // values below 100 milliseconds can be problematic the same propagation\n        // latency occurs in Linux but is even larger (>600 ms)\n        // final static int DEFAULT_SLEEP_BETWEEN_UPDATES = 60;\n\n        final int sleepBetweenUpdates = 100;\n\n        Updater(File configFile, UpdateType updateType) {\n            this.configFile = configFile;\n            this.updateType = updateType;\n        }\n\n        Updater(File configFile) {\n            this(configFile, UpdateType.TOUCH);\n        }\n\n        public void run() {\n            while (!isDone()) {\n                try {\n                    Thread.sleep(sleepBetweenUpdates);\n                } catch (InterruptedException e) {\n                }\n                if (isDone()) {\n                    ReconfigureOnChangeTaskTest.this.addInfo(\"Exiting Updater.run()\", this);\n                    return;\n                }\n                counter++;\n                ReconfigureOnChangeTaskTest.this.addInfo(\"Touching [\" + configFile + \"]\", this);\n                switch (updateType) {\n                case TOUCH:\n                    touchFile();\n                    break;\n                case MALFORMED:\n                    try {\n                        malformedUpdate();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                        fail(\"malformedUpdate failed\");\n                    }\n                    break;\n                case MALFORMED_INNER:\n                    try {\n                        malformedInnerUpdate();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                        fail(\"malformedInnerUpdate failed\");\n                    }\n                }\n            }\n            ReconfigureOnChangeTaskTest.this.addInfo(\"Exiting Updater.run()\", this);\n        }\n\n        private void malformedUpdate() throws IOException {\n            writeToFile(configFile,\n                    \"<configuration scan=\\\"true\\\" scanPeriod=\\\"50 millisecond\\\">\\n\" + \"  <root level=\\\"ERROR\\\">\\n\"\n                            + \"<\/configuration>\");\n        }\n\n        private void malformedInnerUpdate() throws IOException {\n            writeToFile(configFile, \"<included>\\n\" + \"  <root>\\n\" + \"<\/included>\");\n        }\n\n        void touchFile() {\n\n            boolean result = configFile.setLastModified(System.currentTimeMillis());\n            if (!result)\n                addWarn(this.getClass().getName() + \".touchFile on \" + configFile.toString() + \" FAILED\", this);\n        }\n    }\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.joran;\n\nimport static ch.qos.logback.classic.ClassicTestConstants.JORAN_INPUT_PREFIX;\nimport static ch.qos.logback.classic.joran.ReconfigureOnChangeTask.DETECTED_CHANGE_IN_CONFIGURATION_FILES;\nimport static ch.qos.logback.classic.joran.ReconfigureOnChangeTask.FALLING_BACK_TO_SAFE_CONFIGURATION;\nimport static ch.qos.logback.classic.joran.ReconfigureOnChangeTask.RE_REGISTERING_PREVIOUS_SAFE_CONFIGURATION;\nimport static ch.qos.logback.core.CoreConstants.RECONFIGURE_ON_CHANGE_TASK;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\nimport ch.qos.logback.classic.Logger;\nimport ch.qos.logback.classic.LoggerContext;\nimport ch.qos.logback.classic.issue.lbclassic135.LoggingRunnable;\nimport ch.qos.logback.core.CoreConstants;\nimport ch.qos.logback.core.contention.AbstractMultiThreadedHarness;\nimport ch.qos.logback.core.contention.RunnableWithCounterAndDone;\nimport ch.qos.logback.core.joran.spi.ConfigurationWatchList;\nimport ch.qos.logback.core.joran.spi.JoranException;\nimport ch.qos.logback.core.joran.util.ConfigurationWatchListUtil;\nimport ch.qos.logback.core.status.InfoStatus;\nimport ch.qos.logback.core.status.Status;\nimport ch.qos.logback.core.testUtil.CoreTestConstants;\nimport ch.qos.logback.core.testUtil.FileTestUtil;\nimport ch.qos.logback.core.testUtil.RandomUtil;\nimport ch.qos.logback.core.status.testUtil.StatusChecker;\nimport ch.qos.logback.core.util.StatusPrinter;\nimport org.junit.jupiter.api.Timeout;\n\npublic class ReconfigureOnChangeTaskTest {\n    final static int THREAD_COUNT = 5;\n\n    int diff = RandomUtil.getPositiveInt();\n\n    // the space in the file name mandated by\n    // http://jira.qos.ch/browse/LBCORE-119\n    final static String SCAN1_FILE_AS_STR = JORAN_INPUT_PREFIX + \"roct/scan 1.xml\";\n\n    final static String G_SCAN1_FILE_AS_STR = JORAN_INPUT_PREFIX + \"roct/scan 1.groovy\";\n\n    final static String SCAN_LOGBACK_474_FILE_AS_STR = JORAN_INPUT_PREFIX + \"roct/scan_logback_474.xml\";\n\n    final static String INCLUSION_SCAN_TOPLEVEL0_AS_STR = JORAN_INPUT_PREFIX + \"roct/inclusion/topLevel0.xml\";\n\n    final static String INCLUSION_SCAN_TOP_BY_RESOURCE_AS_STR = JORAN_INPUT_PREFIX + \"roct/inclusion/topByResource.xml\";\n\n    final static String INCLUSION_SCAN_INNER0_AS_STR = JORAN_INPUT_PREFIX + \"roct/inclusion/inner0.xml\";\n\n    final static String INCLUSION_SCAN_INNER1_AS_STR = \"target/test-classes/asResource/inner1.xml\";\n\n    private static final String SCAN_PERIOD_DEFAULT_FILE_AS_STR = JORAN_INPUT_PREFIX + \"roct/scan_period_default.xml\";\n\n    LoggerContext loggerContext = new LoggerContext();\n    Logger logger = loggerContext.getLogger(this.getClass());\n    StatusChecker statusChecker = new StatusChecker(loggerContext);\n\n    @BeforeAll\n    static public void classSetup() {\n        FileTestUtil.makeTestOutputDir();\n    }\n\n    void configure(File file) throws JoranException {\n        JoranConfigurator jc = new JoranConfigurator();\n        jc.setContext(loggerContext);\n        jc.doConfigure(file);\n    }\n\n    void configure(InputStream is) throws JoranException {\n        JoranConfigurator jc = new JoranConfigurator();\n        jc.setContext(loggerContext);\n        jc.doConfigure(is);\n    }\n\n\n    @BeforeEach\n    public void before() {\n        System.out.println(this.getClass().getName()+\"#before\");\n    }\n//    void gConfigure(File file) throws JoranException {\n//        GafferConfigurator gc = new GafferConfigurator(loggerContext);\n//        gc.run(file);\n//    }\n\n    @Test\n    @Timeout(value = 4, unit= TimeUnit.SECONDS)\n    public void checkBasicLifecyle() throws JoranException, IOException, InterruptedException {\n        File file = new File(SCAN1_FILE_AS_STR);\n        configure(file);\n        List<File> fileList = getConfigurationWatchList(loggerContext);\n        assertThatListContainsFile(fileList, file);\n        checkThatTaskHasRan();\n        checkThatTaskCanBeStopped();\n    }\n\n    private void checkThatTaskCanBeStopped() {\n        ScheduledFuture<?> future = loggerContext.getCopyOfScheduledFutures().get(0);\n        loggerContext.stop();\n        assertTrue(future.isCancelled());\n    }\n\n    private void checkThatTaskHasRan() throws InterruptedException {\n        waitForReconfigureOnChangeTaskToRun();\n    }\n\n    List<File> getConfigurationWatchList(LoggerContext context) {\n        ConfigurationWatchList configurationWatchList = ConfigurationWatchListUtil\n                .getConfigurationWatchList(loggerContext);\n        return configurationWatchList.getCopyOfFileWatchList();\n    }\n\n    @Test\n    @Timeout(value = 4, unit= TimeUnit.SECONDS)\n    public void scanWithFileInclusion() throws JoranException, IOException, InterruptedException {\n        File topLevelFile = new File(INCLUSION_SCAN_TOPLEVEL0_AS_STR);\n        File innerFile = new File(INCLUSION_SCAN_INNER0_AS_STR);\n        configure(topLevelFile);\n        List<File> fileList = getConfigurationWatchList(loggerContext);\n        assertThatListContainsFile(fileList, topLevelFile);\n        assertThatListContainsFile(fileList, innerFile);\n        checkThatTaskHasRan();\n        checkThatTaskCanBeStopped();\n    }\n\n    @Test\n    @Timeout(value = 4, unit= TimeUnit.SECONDS)\n    public void scanWithResourceInclusion() throws JoranException, IOException, InterruptedException {\n        File topLevelFile = new File(INCLUSION_SCAN_TOP_BY_RESOURCE_AS_STR);\n        File innerFile = new File(INCLUSION_SCAN_INNER1_AS_STR);\n        configure(topLevelFile);\n        List<File> fileList = getConfigurationWatchList(loggerContext);\n        assertThatListContainsFile(fileList, topLevelFile);\n        assertThatListContainsFile(fileList, innerFile);\n    }\n\n    // See also http://jira.qos.ch/browse/LOGBACK-338\n    @Test\n    @Timeout(value = 4, unit= TimeUnit.SECONDS)\n    public void reconfigurationIsNotPossibleInTheAbsenceOfATopFile()\n            throws IOException, JoranException, InterruptedException {\n        String configurationStr = \"<configuration scan=\\\"true\\\" scanPeriod=\\\"50 millisecond\\\"><include resource=\\\"asResource/inner1.xml\\\"/><\/configuration>\";\n        configure(new ByteArrayInputStream(configurationStr.getBytes(\"UTF-8\")));\n\n        ConfigurationWatchList configurationWatchList = ConfigurationWatchListUtil\n                .getConfigurationWatchList(loggerContext);\n        assertNull(configurationWatchList);\n        // assertNull(configurationWatchList.getMainURL());\n\n        statusChecker.containsMatch(Status.WARN, \"Due to missing top level\");\n        StatusPrinter.print(loggerContext);\n        ReconfigureOnChangeTask roct = getRegisteredReconfigureTask();\n        assertNull(roct);\n        assertEquals(0, loggerContext.getCopyOfScheduledFutures().size());\n    }\n\n    @Test\n    @Timeout(value = 3, unit= TimeUnit.SECONDS)\n    public void fallbackToSafe_FollowedByRecovery() throws IOException, JoranException, InterruptedException {\n        String path = CoreTestConstants.OUTPUT_DIR_PREFIX + \"reconfigureOnChangeConfig_fallbackToSafe-\" + diff + \".xml\";\n        File topLevelFile = new File(path);\n        writeToFile(topLevelFile,\n                \"<configuration scan=\\\"true\\\" scanPeriod=\\\"5 millisecond\\\"><root level=\\\"ERROR\\\"/><\/configuration> \");\n        configure(topLevelFile);\n        StatusPrinter.print(loggerContext);\n        CountDownLatch changeDetectedLatch = registerNewReconfigurationDoneListener_WithNewROCT(null);\n        ReconfigureOnChangeTask oldRoct = getRegisteredReconfigureTask();\n\n        addInfo(\"registered ReconfigureOnChangeTask \", oldRoct);\n        assertNotNull(oldRoct);\n\n        String badXML = \"<configuration scan=\\\"true\\\" scanPeriod=\\\"5 millisecond\\\">\\n\" + \"  <root><\/configuration>\";\n        writeToFile(topLevelFile, badXML);\n        addInfo(\"Waiting for changeDetectedLatch.await()\", this);\n        changeDetectedLatch.await();\n        addInfo(\"Woke from changeDetectedLatch.await()\", this);\n        StatusPrinter.print(loggerContext);\n        \n        try {\n            statusChecker.assertContainsMatch(Status.WARN, FALLING_BACK_TO_SAFE_CONFIGURATION);\n            statusChecker.assertContainsMatch(Status.INFO, RE_REGISTERING_PREVIOUS_SAFE_CONFIGURATION);\n\n            loggerContext.getStatusManager().clear();\n\n            addInfo(\"after loggerContext.getStatusManager().clear() oldRoct=\"+ oldRoct, this);\n            CountDownLatch secondDoneLatch = registerNewReconfigurationDoneListener_WithNewROCT(oldRoct);\n            writeToFile(topLevelFile,\n                    \"<configuration scan=\\\"true\\\" scanPeriod=\\\"5 millisecond\\\"><root level=\\\"ERROR\\\"/><\/configuration> \");\n\n            secondDoneLatch.await();\n            StatusPrinter.print(loggerContext);\n            statusChecker.assertIsErrorFree();\n            statusChecker.containsMatch(DETECTED_CHANGE_IN_CONFIGURATION_FILES);\n\n        } finally {\n            StatusPrinter.print(loggerContext);\n        }\n    }\n\n    @Test\n    @Timeout(value = 3, unit= TimeUnit.SECONDS)\n    public void fallbackToSafeWithIncludedFile_FollowedByRecovery()\n            throws IOException, JoranException, InterruptedException, ExecutionException {\n        String topLevelFileAsStr = CoreTestConstants.OUTPUT_DIR_PREFIX + \"reconfigureOnChangeConfig_top-\" + diff\n                + \".xml\";\n        String innerFileAsStr = CoreTestConstants.OUTPUT_DIR_PREFIX + \"reconfigureOnChangeConfig_inner-\" + diff\n                + \".xml\";\n        File topLevelFile = new File(topLevelFileAsStr);\n        writeToFile(topLevelFile,\n                \"<configuration xdebug=\\\"true\\\" scan=\\\"true\\\" scanPeriod=\\\"5 millisecond\\\"><include file=\\\"\"\n                        + innerFileAsStr + \"\\\"/><\/configuration> \");\n\n        File innerFile = new File(innerFileAsStr);\n        writeToFile(innerFile, \"<included><root level=\\\"ERROR\\\"/><\/included> \");\n        configure(topLevelFile);\n\n        CountDownLatch doneLatch = registerNewReconfigurationDoneListener_WithNewROCT(null);\n        ReconfigureOnChangeTask oldRoct = getRegisteredReconfigureTask();\n        assertNotNull(oldRoct);\n\n        writeToFile(innerFile, \"<included>\\n<root>\\n<\/included>\");\n        doneLatch.await(2000, TimeUnit.MILLISECONDS);\n\n        statusChecker.assertContainsMatch(Status.WARN, FALLING_BACK_TO_SAFE_CONFIGURATION);\n        statusChecker.assertContainsMatch(Status.INFO, RE_REGISTERING_PREVIOUS_SAFE_CONFIGURATION);\n\n        loggerContext.getStatusManager().clear();\n\n        try {\n            CountDownLatch secondDoneLatch = registerNewReconfigurationDoneListener_WithNewROCT(oldRoct);\n            writeToFile(innerFile, \"<included><root level=\\\"ERROR\\\"/><\/included> \");\n            secondDoneLatch.await();\n\n            statusChecker.assertIsErrorFree();\n            statusChecker.containsMatch(DETECTED_CHANGE_IN_CONFIGURATION_FILES);\n        } finally {\n            StatusPrinter.print(loggerContext);\n        }\n\n    }\n\n    private ReconfigureOnChangeTask getRegisteredReconfigureTask() {\n        return (ReconfigureOnChangeTask) loggerContext.getObject(RECONFIGURE_ON_CHANGE_TASK);\n    }\n\n    class RunMethodInvokedListener extends ReconfigureOnChangeTaskListener {\n        CountDownLatch countDownLatch;\n\n        RunMethodInvokedListener(CountDownLatch countDownLatch) {\n            this.countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void enteredRunMethod() {\n            countDownLatch.countDown();\n        }\n    };\n\n    class ChangeDetectedListener extends ReconfigureOnChangeTaskListener {\n        CountDownLatch countDownLatch;\n\n        ChangeDetectedListener(CountDownLatch countDownLatch) {\n            this.countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void changeDetected() {\n            countDownLatch.countDown();\n        }\n    };\n\n    class ReconfigurationDoneListener extends ReconfigureOnChangeTaskListener {\n        CountDownLatch countDownLatch;\n\n        ReconfigurationDoneListener(CountDownLatch countDownLatch) {\n            this.countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void doneReconfiguring() {\n            System.out.println(\"ReconfigurationDoneListener now invoking countDownLatch.countDown()\");\n            countDownLatch.countDown();\n        }\n    };\n\n    private ReconfigureOnChangeTask waitForReconfigureOnChangeTaskToRun() throws InterruptedException {\n        ReconfigureOnChangeTask roct = null;\n        while (roct == null) {\n            roct = getRegisteredReconfigureTask();\n            Thread.yield();\n        }\n\n        CountDownLatch countDownLatch = new CountDownLatch(1);\n        roct.addListener(new RunMethodInvokedListener(countDownLatch));\n        countDownLatch.await();\n        return roct;\n    }\n\n    private CountDownLatch registerNewReconfigurationDoneListener_WithNewROCT(ReconfigureOnChangeTask oldTask) throws InterruptedException {\n\n        addInfo(\"waitForReconfigurationToBeDone oldTask=\" + oldTask, this);\n        ReconfigureOnChangeTask roct = oldTask;\n        while (roct == oldTask) {\n            roct = getRegisteredReconfigureTask();\n            Thread.yield();\n            Thread.sleep(10);\n        }\n\n        CountDownLatch countDownLatch = new CountDownLatch(1);\n        if (roct == null) {\n            addInfo(\"roct is null\", oldTask);\n        } else {\n            roct.addListener(new ReconfigurationDoneListener(countDownLatch));\n        }\n        return countDownLatch;\n    }\n\n    private RunnableWithCounterAndDone[] buildRunnableArray(File configFile, UpdateType updateType) {\n        RunnableWithCounterAndDone[] rArray = new RunnableWithCounterAndDone[THREAD_COUNT];\n        rArray[0] = new Updater(configFile, updateType);\n        for (int i = 1; i < THREAD_COUNT; i++) {\n            rArray[i] = new LoggingRunnable(logger);\n        }\n        return rArray;\n    }\n\n    @Test\n    public void checkReconfigureTaskScheduledWhenDefaultScanPeriodUsed() throws JoranException {\n        File file = new File(SCAN_PERIOD_DEFAULT_FILE_AS_STR);\n        configure(file);\n\n        final List<ScheduledFuture<?>> scheduledFutures = loggerContext.getCopyOfScheduledFutures();\n        StatusPrinter.print(loggerContext);\n        assertFalse(scheduledFutures.isEmpty());\n        statusChecker.containsMatch(\"No 'scanPeriod' specified. Defaulting to\");\n\n    }\n\n    // check for deadlocks\n    @Test\n    @Timeout(value = 4, unit= TimeUnit.SECONDS)\n    public void scan_LOGBACK_474() throws JoranException, IOException, InterruptedException {\n        loggerContext.setName(\"scan_LOGBACK_474\");\n        File file = new File(SCAN_LOGBACK_474_FILE_AS_STR);\n        // StatusListenerConfigHelper.addOnConsoleListenerInstance(loggerContext, new\n        // OnConsoleStatusListener());\n        configure(file);\n\n        // ReconfigureOnChangeTask roct = waitForReconfigureOnChangeTaskToRun();\n\n        int expectedResets = 2;\n        Harness harness = new Harness(expectedResets);\n\n        RunnableWithCounterAndDone[] runnableArray = buildRunnableArray(file, UpdateType.TOUCH);\n        harness.execute(runnableArray);\n\n        loggerContext.getStatusManager().add(new InfoStatus(\"end of execution \", this));\n        StatusPrinter.print(loggerContext);\n        checkResetCount(expectedResets);\n    }\n\n    private void assertThatListContainsFile(List<File> fileList, File file) {\n        // conversion to absolute file seems to work nicely\n        assertTrue(fileList.contains(file.getAbsoluteFile()));\n    }\n\n    private void checkResetCount(int expected) {\n        StatusChecker checker = new StatusChecker(loggerContext);\n        checker.assertIsErrorFree();\n\n        int effectiveResets = checker.matchCount(CoreConstants.RESET_MSG_PREFIX);\n        assertEquals(expected, effectiveResets);\n\n        // String failMsg = \"effective=\" + effectiveResets + \", expected=\" + expected;\n        //\n        // there might be more effective resets than the expected amount\n        // since the harness may be sleeping while a reset occurs\n        // assertTrue(failMsg, expected <= effectiveResets && (expected + 2) >=\n        // effectiveResets);\n\n    }\n\n    void addInfo(String msg, Object o) {\n        loggerContext.getStatusManager().add(new InfoStatus(msg, o));\n    }\n\n    enum UpdateType {\n        TOUCH, MALFORMED, MALFORMED_INNER\n    }\n\n    void writeToFile(File file, String contents) throws IOException {\n        FileWriter fw = new FileWriter(file);\n        fw.write(contents);\n        fw.close();\n        // on linux changes to last modified are not propagated if the\n        // time stamp is near the previous time stamp hence the random delta\n        file.setLastModified(System.currentTimeMillis() + RandomUtil.getPositiveInt());\n    }\n\n    class Harness extends AbstractMultiThreadedHarness {\n        int changeCountLimit;\n\n        Harness(int changeCount) {\n            this.changeCountLimit = changeCount;\n        }\n\n        public void waitUntilEndCondition() throws InterruptedException {\n            ReconfigureOnChangeTaskTest.this.addInfo(\"Entering \" + this.getClass() + \".waitUntilEndCondition()\", this);\n\n            int changeCount = 0;\n            ReconfigureOnChangeTask lastRoct = null;\n            CountDownLatch countDownLatch = null;\n\n            while (changeCount < changeCountLimit) {\n                ReconfigureOnChangeTask roct = (ReconfigureOnChangeTask) loggerContext\n                        .getObject(RECONFIGURE_ON_CHANGE_TASK);\n                if (lastRoct != roct && roct != null) {\n                    lastRoct = roct;\n                    countDownLatch = new CountDownLatch(1);\n                    roct.addListener(new ChangeDetectedListener(countDownLatch));\n                } else if (countDownLatch != null) {\n                    countDownLatch.await();\n                    countDownLatch = null;\n                    changeCount++;\n                }\n                Thread.yield();\n            }\n            ReconfigureOnChangeTaskTest.this.addInfo(\"*****Exiting \" + this.getClass() + \".waitUntilEndCondition()\",\n                    this);\n        }\n\n    }\n\n    class Updater extends RunnableWithCounterAndDone {\n        File configFile;\n        UpdateType updateType;\n\n        // it actually takes time for Windows to propagate file modification changes\n        // values below 100 milliseconds can be problematic the same propagation\n        // latency occurs in Linux but is even larger (>600 ms)\n        // final static int DEFAULT_SLEEP_BETWEEN_UPDATES = 60;\n\n        int sleepBetweenUpdates = 100;\n\n        Updater(File configFile, UpdateType updateType) {\n            this.configFile = configFile;\n            this.updateType = updateType;\n        }\n\n        Updater(File configFile) {\n            this(configFile, UpdateType.TOUCH);\n        }\n\n        public void run() {\n            while (!isDone()) {\n                try {\n                    Thread.sleep(sleepBetweenUpdates);\n                } catch (InterruptedException e) {\n                }\n                if (isDone()) {\n                    ReconfigureOnChangeTaskTest.this.addInfo(\"Exiting Updater.run()\", this);\n                    return;\n                }\n                counter++;\n                ReconfigureOnChangeTaskTest.this.addInfo(\"Touching [\" + configFile + \"]\", this);\n                switch (updateType) {\n                case TOUCH:\n                    touchFile();\n                    break;\n                case MALFORMED:\n                    try {\n                        malformedUpdate();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                        fail(\"malformedUpdate failed\");\n                    }\n                    break;\n                case MALFORMED_INNER:\n                    try {\n                        malformedInnerUpdate();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                        fail(\"malformedInnerUpdate failed\");\n                    }\n                }\n            }\n            ReconfigureOnChangeTaskTest.this.addInfo(\"Exiting Updater.run()\", this);\n        }\n\n        private void malformedUpdate() throws IOException {\n            writeToFile(configFile, \"<configuration scan=\\\"true\\\" scanPeriod=\\\"50 millisecond\\\">\\n\"\n                    + \"  <root level=\\\"ERROR\\\">\\n\" + \"<\/configuration>\");\n        }\n\n        private void malformedInnerUpdate() throws IOException {\n            writeToFile(configFile, \"<included>\\n\" + \"  <root>\\n\" + \"<\/included>\");\n        }\n\n        void touchFile() {\n            configFile.setLastModified(System.currentTimeMillis());\n        }\n    }\n\n}\n","lineNo":334}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.issue;\n\nimport ch.qos.logback.core.contention.RunnableWithCounterAndDone;\nimport ch.qos.logback.core.contention.ThreadedThroughputCalculator;\nimport ch.qos.logback.core.issue.SelectiveLockRunnable.LockingModel;\n\n/**\n * Short sample code testing the throughput of a fair lock.\n * \n * @author Joern Huxhorn\n * @author Ceki Gulcu\n */\npublic class LockThroughput {\n\n    static int THREAD_COUNT = 10;\n    static long OVERALL_DURATION_IN_MILLIS = 5000;\n\n    public static void main(String args[]) throws InterruptedException {\n\n        ThreadedThroughputCalculator tp = new ThreadedThroughputCalculator(OVERALL_DURATION_IN_MILLIS);\n        tp.printEnvironmentInfo(\"LockThroughput\");\n\n        for (int i = 0; i < 2; i++) {\n            tp.execute(buildArray(LockingModel.SYNC));\n            tp.execute(buildArray(LockingModel.UNFAIR));\n            tp.execute(buildArray(LockingModel.FAIR));\n        }\n\n\n        RunnableWithCounterAndDone[] runnableArraySync = buildArray(LockingModel.SYNC);\n        tp.execute(runnableArraySync);\n        tp.printThroughput(runnableArraySync, \"Sync:   \");\n\n\n        RunnableWithCounterAndDone[] runnableArrayUnfair = buildArray(LockingModel.UNFAIR);\n        tp.execute(runnableArrayUnfair);\n        tp.printThroughput(runnableArrayUnfair, \"Unfair: \");\n\n        RunnableWithCounterAndDone[] runnableArrayFair = buildArray(LockingModel.FAIR);\n        tp.execute(runnableArrayFair);\n        tp.printThroughput(runnableArrayFair, \"Fair:   \");\n    }\n\n    static SelectiveLockRunnable[] buildArray(LockingModel model) {\n        SelectiveLockRunnable[] array = new SelectiveLockRunnable[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            array[i] = new SelectiveLockRunnable(model);\n        }\n        return array;\n    }\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.issue;\n\nimport ch.qos.logback.core.contention.ThreadedThroughputCalculator;\nimport ch.qos.logback.core.issue.SelectiveLockRunnable.LockingModel;\n\n/**\n * Short sample code testing the throughput of a fair lock.\n * \n * @author Joern Huxhorn\n * @author Ceki Gulcu\n */\npublic class LockThroughput {\n\n    static int THREAD_COUNT = 10;\n    static long OVERALL_DURATION_IN_MILLIS = 5000;\n\n    public static void main(String args[]) throws InterruptedException {\n\n        ThreadedThroughputCalculator tp = new ThreadedThroughputCalculator(OVERALL_DURATION_IN_MILLIS);\n        tp.printEnvironmentInfo(\"LockThroughput\");\n\n        for (int i = 0; i < 2; i++) {\n            tp.execute(buildArray(LockingModel.SYNC));\n            tp.execute(buildArray(LockingModel.UNFAIR));\n            tp.execute(buildArray(LockingModel.FAIR));\n        }\n\n        tp.execute(buildArray(LockingModel.SYNC));\n        tp.printThroughput(\"Sync:   \");\n\n        tp.execute(buildArray(LockingModel.UNFAIR));\n        tp.printThroughput(\"Unfair: \");\n\n        tp.execute(buildArray(LockingModel.FAIR));\n        tp.printThroughput(\"Fair:   \");\n    }\n\n    static SelectiveLockRunnable[] buildArray(LockingModel model) {\n        SelectiveLockRunnable[] array = new SelectiveLockRunnable[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            array[i] = new SelectiveLockRunnable(model);\n        }\n        return array;\n    }\n\n}\n","lineNo":43}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.issue;\n\nimport ch.qos.logback.core.contention.RunnableWithCounterAndDone;\nimport ch.qos.logback.core.contention.ThreadedThroughputCalculator;\nimport ch.qos.logback.core.issue.SelectiveLockRunnable.LockingModel;\n\n/**\n * Short sample code testing the throughput of a fair lock.\n * \n * @author Joern Huxhorn\n * @author Ceki Gulcu\n */\npublic class LockThroughput {\n\n    static int THREAD_COUNT = 10;\n    static long OVERALL_DURATION_IN_MILLIS = 5000;\n\n    public static void main(String args[]) throws InterruptedException {\n\n        ThreadedThroughputCalculator tp = new ThreadedThroughputCalculator(OVERALL_DURATION_IN_MILLIS);\n        tp.printEnvironmentInfo(\"LockThroughput\");\n\n        for (int i = 0; i < 2; i++) {\n            tp.execute(buildArray(LockingModel.SYNC));\n            tp.execute(buildArray(LockingModel.UNFAIR));\n            tp.execute(buildArray(LockingModel.FAIR));\n        }\n\n\n        RunnableWithCounterAndDone[] runnableArraySync = buildArray(LockingModel.SYNC);\n        tp.execute(runnableArraySync);\n        tp.printThroughput(runnableArraySync, \"Sync:   \");\n\n\n        RunnableWithCounterAndDone[] runnableArrayUnfair = buildArray(LockingModel.UNFAIR);\n        tp.execute(runnableArrayUnfair);\n        tp.printThroughput(runnableArrayUnfair, \"Unfair: \");\n\n        RunnableWithCounterAndDone[] runnableArrayFair = buildArray(LockingModel.FAIR);\n        tp.execute(runnableArrayFair);\n        tp.printThroughput(runnableArrayFair, \"Fair:   \");\n    }\n\n    static SelectiveLockRunnable[] buildArray(LockingModel model) {\n        SelectiveLockRunnable[] array = new SelectiveLockRunnable[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            array[i] = new SelectiveLockRunnable(model);\n        }\n        return array;\n    }\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.issue;\n\nimport ch.qos.logback.core.contention.ThreadedThroughputCalculator;\nimport ch.qos.logback.core.issue.SelectiveLockRunnable.LockingModel;\n\n/**\n * Short sample code testing the throughput of a fair lock.\n * \n * @author Joern Huxhorn\n * @author Ceki Gulcu\n */\npublic class LockThroughput {\n\n    static int THREAD_COUNT = 10;\n    static long OVERALL_DURATION_IN_MILLIS = 5000;\n\n    public static void main(String args[]) throws InterruptedException {\n\n        ThreadedThroughputCalculator tp = new ThreadedThroughputCalculator(OVERALL_DURATION_IN_MILLIS);\n        tp.printEnvironmentInfo(\"LockThroughput\");\n\n        for (int i = 0; i < 2; i++) {\n            tp.execute(buildArray(LockingModel.SYNC));\n            tp.execute(buildArray(LockingModel.UNFAIR));\n            tp.execute(buildArray(LockingModel.FAIR));\n        }\n\n        tp.execute(buildArray(LockingModel.SYNC));\n        tp.printThroughput(\"Sync:   \");\n\n        tp.execute(buildArray(LockingModel.UNFAIR));\n        tp.printThroughput(\"Unfair: \");\n\n        tp.execute(buildArray(LockingModel.FAIR));\n        tp.printThroughput(\"Fair:   \");\n    }\n\n    static SelectiveLockRunnable[] buildArray(LockingModel model) {\n        SelectiveLockRunnable[] array = new SelectiveLockRunnable[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            array[i] = new SelectiveLockRunnable(model);\n        }\n        return array;\n    }\n\n}\n","lineNo":48}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.issue;\n\nimport ch.qos.logback.core.contention.RunnableWithCounterAndDone;\nimport ch.qos.logback.core.contention.ThreadedThroughputCalculator;\nimport ch.qos.logback.core.issue.SelectiveLockRunnable.LockingModel;\n\n/**\n * Short sample code testing the throughput of a fair lock.\n * \n * @author Joern Huxhorn\n * @author Ceki Gulcu\n */\npublic class LockThroughput {\n\n    static int THREAD_COUNT = 10;\n    static long OVERALL_DURATION_IN_MILLIS = 5000;\n\n    public static void main(String args[]) throws InterruptedException {\n\n        ThreadedThroughputCalculator tp = new ThreadedThroughputCalculator(OVERALL_DURATION_IN_MILLIS);\n        tp.printEnvironmentInfo(\"LockThroughput\");\n\n        for (int i = 0; i < 2; i++) {\n            tp.execute(buildArray(LockingModel.SYNC));\n            tp.execute(buildArray(LockingModel.UNFAIR));\n            tp.execute(buildArray(LockingModel.FAIR));\n        }\n\n\n        RunnableWithCounterAndDone[] runnableArraySync = buildArray(LockingModel.SYNC);\n        tp.execute(runnableArraySync);\n        tp.printThroughput(runnableArraySync, \"Sync:   \");\n\n\n        RunnableWithCounterAndDone[] runnableArrayUnfair = buildArray(LockingModel.UNFAIR);\n        tp.execute(runnableArrayUnfair);\n        tp.printThroughput(runnableArrayUnfair, \"Unfair: \");\n\n        RunnableWithCounterAndDone[] runnableArrayFair = buildArray(LockingModel.FAIR);\n        tp.execute(runnableArrayFair);\n        tp.printThroughput(runnableArrayFair, \"Fair:   \");\n    }\n\n    static SelectiveLockRunnable[] buildArray(LockingModel model) {\n        SelectiveLockRunnable[] array = new SelectiveLockRunnable[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            array[i] = new SelectiveLockRunnable(model);\n        }\n        return array;\n    }\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.issue;\n\nimport ch.qos.logback.core.contention.ThreadedThroughputCalculator;\nimport ch.qos.logback.core.issue.SelectiveLockRunnable.LockingModel;\n\n/**\n * Short sample code testing the throughput of a fair lock.\n * \n * @author Joern Huxhorn\n * @author Ceki Gulcu\n */\npublic class LockThroughput {\n\n    static int THREAD_COUNT = 10;\n    static long OVERALL_DURATION_IN_MILLIS = 5000;\n\n    public static void main(String args[]) throws InterruptedException {\n\n        ThreadedThroughputCalculator tp = new ThreadedThroughputCalculator(OVERALL_DURATION_IN_MILLIS);\n        tp.printEnvironmentInfo(\"LockThroughput\");\n\n        for (int i = 0; i < 2; i++) {\n            tp.execute(buildArray(LockingModel.SYNC));\n            tp.execute(buildArray(LockingModel.UNFAIR));\n            tp.execute(buildArray(LockingModel.FAIR));\n        }\n\n        tp.execute(buildArray(LockingModel.SYNC));\n        tp.printThroughput(\"Sync:   \");\n\n        tp.execute(buildArray(LockingModel.UNFAIR));\n        tp.printThroughput(\"Unfair: \");\n\n        tp.execute(buildArray(LockingModel.FAIR));\n        tp.printThroughput(\"Fair:   \");\n    }\n\n    static SelectiveLockRunnable[] buildArray(LockingModel model) {\n        SelectiveLockRunnable[] array = new SelectiveLockRunnable[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            array[i] = new SelectiveLockRunnable(model);\n        }\n        return array;\n    }\n\n}\n","lineNo":52}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.issue;\n\nimport ch.qos.logback.core.contention.RunnableWithCounterAndDone;\nimport ch.qos.logback.core.contention.ThreadedThroughputCalculator;\nimport ch.qos.logback.core.issue.SelectiveLockRunnable.LockingModel;\n\n/**\n * Short sample code testing the throughput of a fair lock.\n * \n * @author Joern Huxhorn\n * @author Ceki Gulcu\n */\npublic class NoLockThroughput {\n\n    static int THREAD_COUNT = 3;\n    static long OVERALL_DURATION_IN_MILLIS = 2000;\n\n    public static void main(String args[]) throws InterruptedException {\n\n        ThreadedThroughputCalculator tp = new ThreadedThroughputCalculator(OVERALL_DURATION_IN_MILLIS);\n        tp.printEnvironmentInfo(\"NoLockThroughput\");\n\n        for (int i = 0; i < 2; i++) {\n            tp.execute(buildArray(LockingModel.NOLOCK));\n        }\n\n        RunnableWithCounterAndDone[] runnableArray = buildArray(LockingModel.NOLOCK);\n        tp.execute(runnableArray);\n        tp.printThroughput(runnableArray,\"No lock:   \", true);\n    }\n\n    static SelectiveLockRunnable[] buildArray(LockingModel model) {\n        SelectiveLockRunnable[] array = new SelectiveLockRunnable[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            array[i] = new SelectiveLockRunnable(model);\n        }\n        return array;\n    }\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.issue;\n\nimport ch.qos.logback.core.contention.ThreadedThroughputCalculator;\nimport ch.qos.logback.core.issue.SelectiveLockRunnable.LockingModel;\n\n/**\n * Short sample code testing the throughput of a fair lock.\n * \n * @author Joern Huxhorn\n * @author Ceki Gulcu\n */\npublic class NoLockThroughput {\n\n    static int THREAD_COUNT = 3;\n    static long OVERALL_DURATION_IN_MILLIS = 2000;\n\n    public static void main(String args[]) throws InterruptedException {\n\n        ThreadedThroughputCalculator tp = new ThreadedThroughputCalculator(OVERALL_DURATION_IN_MILLIS);\n        tp.printEnvironmentInfo(\"NoLockThroughput\");\n\n        for (int i = 0; i < 2; i++) {\n            tp.execute(buildArray(LockingModel.NOLOCK));\n        }\n\n        tp.execute(buildArray(LockingModel.NOLOCK));\n        tp.printThroughput(\"No lock:   \", true);\n    }\n\n    static SelectiveLockRunnable[] buildArray(LockingModel model) {\n        SelectiveLockRunnable[] array = new SelectiveLockRunnable[THREAD_COUNT];\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            array[i] = new SelectiveLockRunnable(model);\n        }\n        return array;\n    }\n\n}\n","lineNo":40}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core;\n\nimport static ch.qos.logback.core.BasicStatusManager.MAX_HEADER_COUNT;\nimport static ch.qos.logback.core.BasicStatusManager.TAIL_SIZE;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport ch.qos.logback.core.status.OnConsoleStatusListener;\nimport ch.qos.logback.core.status.StatusListener;\n\nimport org.junit.jupiter.api.Test;\n\nimport ch.qos.logback.core.status.ErrorStatus;\nimport ch.qos.logback.core.status.Status;\n\npublic class BasicStatusManagerTest {\n\n    BasicStatusManager bsm = new BasicStatusManager();\n\n    @Test\n    public void smoke() {\n        bsm.add(new ErrorStatus(\"hello\", this));\n        assertEquals(Status.ERROR, bsm.getLevel());\n\n        List<Status> statusList = bsm.getCopyOfStatusList();\n        assertNotNull(statusList);\n        assertEquals(1, statusList.size());\n        assertEquals(\"hello\", statusList.get(0).getMessage());\n    }\n\n    @Test\n    public void many() {\n        int margin = 300;\n        int len = MAX_HEADER_COUNT + TAIL_SIZE + margin;\n        List<Status> witness = new ArrayList<Status>();\n        for (int i = 0; i < len; i++) {\n            Status s = new ErrorStatus(\"\" + i, this);\n            bsm.add(s);\n            if(i < MAX_HEADER_COUNT) {\n                witness.add(new ErrorStatus(\"\" + i, this));\n            }\n            if(i >= MAX_HEADER_COUNT + margin) {\n                witness.add(s);\n            }\n        }\n\n        List<Status> statusList = bsm.getCopyOfStatusList();\n        assertNotNull(statusList);\n        assertEquals(MAX_HEADER_COUNT + TAIL_SIZE, statusList.size());\n\n        assertEquals(witness, statusList);\n    }\n\n    @Test\n    public void duplicateInstallationsOfOnConsoleListener() {\n        OnConsoleStatusListener sl0 = new OnConsoleStatusListener();\n        sl0.start();\n        OnConsoleStatusListener sl1 = new OnConsoleStatusListener();\n        sl1.start();\n\n        assertTrue(bsm.add(sl0));\n\n        {\n            List<StatusListener> listeners = bsm.getCopyOfStatusListenerList();\n            assertEquals(1, listeners.size());\n        }\n\n        assertFalse(bsm.add(sl1));\n        {\n            List<StatusListener> listeners = bsm.getCopyOfStatusListenerList();\n            assertEquals(1, listeners.size());\n        }\n    }\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core;\n\nimport static ch.qos.logback.core.BasicStatusManager.MAX_HEADER_COUNT;\nimport static ch.qos.logback.core.BasicStatusManager.TAIL_SIZE;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport ch.qos.logback.core.status.OnConsoleStatusListener;\nimport ch.qos.logback.core.status.StatusListener;\n\nimport org.junit.jupiter.api.Test;\n\nimport ch.qos.logback.core.status.ErrorStatus;\nimport ch.qos.logback.core.status.Status;\n\npublic class BasicStatusManagerTest {\n\n    BasicStatusManager bsm = new BasicStatusManager();\n\n    @Test\n    public void smoke() {\n        bsm.add(new ErrorStatus(\"hello\", this));\n        assertEquals(Status.ERROR, bsm.getLevel());\n\n        List<Status> statusList = bsm.getCopyOfStatusList();\n        assertNotNull(statusList);\n        assertEquals(1, statusList.size());\n        assertEquals(\"hello\", statusList.get(0).getMessage());\n    }\n\n    @Test\n    public void many() {\n        int margin = 300;\n        int len = MAX_HEADER_COUNT + TAIL_SIZE + margin;\n        for (int i = 0; i < len; i++) {\n            bsm.add(new ErrorStatus(\"\" + i, this));\n        }\n\n        List<Status> statusList = bsm.getCopyOfStatusList();\n        assertNotNull(statusList);\n        assertEquals(MAX_HEADER_COUNT + TAIL_SIZE, statusList.size());\n        List<Status> witness = new ArrayList<Status>();\n        for (int i = 0; i < MAX_HEADER_COUNT; i++) {\n            witness.add(new ErrorStatus(\"\" + i, this));\n        }\n        for (int i = 0; i < TAIL_SIZE; i++) {\n            witness.add(new ErrorStatus(\"\" + (MAX_HEADER_COUNT + margin + i), this));\n        }\n        assertEquals(witness, statusList);\n    }\n\n    @Test\n    public void duplicateInstallationsOfOnConsoleListener() {\n        OnConsoleStatusListener sl0 = new OnConsoleStatusListener();\n        sl0.start();\n        OnConsoleStatusListener sl1 = new OnConsoleStatusListener();\n        sl1.start();\n\n        assertTrue(bsm.add(sl0));\n\n        {\n            List<StatusListener> listeners = bsm.getCopyOfStatusListenerList();\n            assertEquals(1, listeners.size());\n        }\n\n        assertFalse(bsm.add(sl1));\n        {\n            List<StatusListener> listeners = bsm.getCopyOfStatusListenerList();\n            assertEquals(1, listeners.size());\n        }\n    }\n\n}\n","lineNo":55}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2022, QOS.ch. All rights reserved.\n * <p>\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n * <p>\n * or (per the licensee's choosing)\n * <p>\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.joran.sanity;\n\nimport ch.qos.logback.core.model.AppenderModel;\nimport ch.qos.logback.core.model.Model;\nimport ch.qos.logback.core.spi.ContextAwareBase;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class AppenderWithinAppenderSanityChecker extends ContextAwareBase implements SanityChecker  {\n\n    static public String NESTED_APPENDERS_WARNING = \"As of logback version 1.3, nested appenders are not allowed.\";\n\n    @Override\n    public void check(Model model) {\n        if (model == null)\n            return;\n\n        List<Model> appenderModels = new ArrayList<>();\n        deepFindAllModelsOfType(AppenderModel.class, appenderModels, model);\n\n        List<Pair<Model, Model>> nestedPairs = deepFindNestedSubModelsOfType(AppenderModel.class, appenderModels);\n\n        List<Pair<Model, Model>> filteredNestedPairs = nestedPairs.stream().filter(pair -> !isSiftingAppender(pair.first)).collect(Collectors.toList());\n\n        if(filteredNestedPairs.isEmpty()) {\n            return;\n        }\n        addWarn(NESTED_APPENDERS_WARNING);\n        for(Pair<Model, Model> pair: filteredNestedPairs) {\n            addWarn(\"Appender at line \"+pair.first.getLineNumber() + \" contains a nested appender at line \"+pair.second.getLineNumber());\n        }\n    }\n\n    private boolean isSiftingAppender(Model first) {\n        if(first instanceof  AppenderModel) {\n            AppenderModel appenderModel = (AppenderModel) first;\n            String classname = appenderModel.getClassName();\n            if(classname == null)\n                return false;\n            return appenderModel.getClassName().contains(\"SiftingAppender\");\n        }\n        return false;\n    }\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2022, QOS.ch. All rights reserved.\n * <p>\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n * <p>\n * or (per the licensee's choosing)\n * <p>\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.joran.sanity;\n\nimport ch.qos.logback.core.model.AppenderModel;\nimport ch.qos.logback.core.model.Model;\nimport ch.qos.logback.core.spi.ContextAwareBase;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class AppenderWithinAppenderSanityChecker extends ContextAwareBase implements SanityChecker  {\n\n    static public String NESTED_APPENDERS_WARNING = \"As of logback version 1.3, nested appenders are not allowed.\";\n\n    @Override\n    public void check(Model model) {\n        if (model == null)\n            return;\n\n        List<Model> appenderModels = new ArrayList<>();\n        deepFindAllModelsOfType(AppenderModel.class, appenderModels, model);\n\n        List<Pair<Model, Model>> nestedPairs = deepFindNestedSubModelsOfType(AppenderModel.class, appenderModels);\n\n        if(nestedPairs.isEmpty())\n            return;\n\n        addWarn(NESTED_APPENDERS_WARNING);\n        for(Pair<Model, Model> pair: nestedPairs) {\n            addWarn(\"Appender at line \"+pair.first.getLineNumber() + \" contains a nested appender at line \"+pair.second.getLineNumber());\n        }\n    }\n\n}\n","lineNo":38}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.util;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ServiceLoader;\n\nimport ch.qos.logback.core.util.EnvUtil;\nimport ch.qos.logback.core.util.Loader;\n\n/**\n * @author Ceki G&uuml;lc&uuml;\n */\npublic class ClassicEnvUtil {\n\n    /*\n     * Used to replace the ClassLoader that the ServiceLoader uses for unit testing.\n     * We need this to mock the resources the ServiceLoader attempts to load from\n     * /META-INF/services thus keeping the projects src/test/resources clean (see\n     * src/test/resources/README.txt).\n     */\n    //static ClassLoader testServiceLoaderClassLoader = null;\n\n    static public boolean isGroovyAvailable() {\n        return EnvUtil.isClassAvailable(ClassicEnvUtil.class, \"groovy.lang.Binding\");\n    }\n//\n//    private static ClassLoader getServiceLoaderClassLoader() {\n//        return testServiceLoaderClassLoader == null ? Loader.getClassLoaderOfClass(ClassicEnvUtil.class)\n//                : testServiceLoaderClassLoader;\n//    }\n\n    public static <T> List<T> loadFromServiceLoader(Class<T> c, ClassLoader classLoader) {\n        ServiceLoader<T> loader = ServiceLoader.load(c, classLoader);\n        List<T> listOfT = new ArrayList<>();\n        Iterator<T> it = loader.iterator();\n        while(it.hasNext()) {\n            T t = it.next();\n            System.out.println(\"loaded \"+t);\n            listOfT.add(t);\n        }\n        return listOfT;\n    }\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.util;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ServiceLoader;\n\nimport ch.qos.logback.core.util.EnvUtil;\nimport ch.qos.logback.core.util.Loader;\n\n/**\n * @author Ceki G&uuml;lc&uuml;\n */\npublic class ClassicEnvUtil {\n\n    /*\n     * Used to replace the ClassLoader that the ServiceLoader uses for unit testing.\n     * We need this to mock the resources the ServiceLoader attempts to load from\n     * /META-INF/services thus keeping the projects src/test/resources clean (see\n     * src/test/resources/README.txt).\n     */\n    //static ClassLoader testServiceLoaderClassLoader = null;\n\n    static public boolean isGroovyAvailable() {\n        return EnvUtil.isClassAvailable(ClassicEnvUtil.class, \"groovy.lang.Binding\");\n    }\n//\n//    private static ClassLoader getServiceLoaderClassLoader() {\n//        return testServiceLoaderClassLoader == null ? Loader.getClassLoaderOfClass(ClassicEnvUtil.class)\n//                : testServiceLoaderClassLoader;\n//    }\n\n    public static <T> List<T> loadFromServiceLoader(Class<T> c, ClassLoader classLoader) {\n        ServiceLoader<T> loader = ServiceLoader.load(c, classLoader);\n        List<T> listOfT = new ArrayList<>();\n        Iterator<T> it = loader.iterator();\n        while(it.hasNext()) {\n            listOfT.add(it.next());\n        }\n        return listOfT;\n    }\n\n}\n","lineNo":51}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.joran;\n\nimport static ch.qos.logback.core.model.processor.ImplicitModelHandler.IGNORING_UNKNOWN_PROP;\nimport static ch.qos.logback.core.model.processor.ShutdownHookModelHandler.RENAME_WARNING;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport ch.qos.logback.core.model.ShutdownHookModel;\nimport ch.qos.logback.core.model.processor.ImplicitModelHandler;\nimport ch.qos.logback.core.model.processor.ShutdownHookModelHandler;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.slf4j.MDC;\nimport org.slf4j.event.KeyValuePair;\n\nimport ch.qos.logback.classic.AsyncAppender;\nimport ch.qos.logback.classic.ClassicTestConstants;\nimport ch.qos.logback.classic.Level;\nimport ch.qos.logback.classic.Logger;\nimport ch.qos.logback.classic.LoggerContext;\nimport ch.qos.logback.classic.jul.JULHelper;\nimport ch.qos.logback.classic.spi.ILoggingEvent;\nimport ch.qos.logback.classic.turbo.DebugUsersTurboFilter;\nimport ch.qos.logback.classic.turbo.NOPTurboFilter;\nimport ch.qos.logback.classic.turbo.TurboFilter;\nimport ch.qos.logback.core.ConsoleAppender;\nimport ch.qos.logback.core.CoreConstants;\nimport ch.qos.logback.core.encoder.LayoutWrappingEncoder;\nimport ch.qos.logback.core.joran.action.ParamAction;\nimport ch.qos.logback.core.joran.spi.ActionException;\nimport ch.qos.logback.core.joran.spi.JoranException;\nimport ch.qos.logback.core.pattern.parser.Parser;\nimport ch.qos.logback.core.read.ListAppender;\nimport ch.qos.logback.core.spi.ErrorCodes;\nimport ch.qos.logback.core.spi.ScanException;\nimport ch.qos.logback.core.status.Status;\nimport ch.qos.logback.core.testUtil.RandomUtil;\nimport ch.qos.logback.core.testUtil.StatusChecker;\nimport ch.qos.logback.core.testUtil.StringListAppender;\nimport ch.qos.logback.core.util.CachingDateFormatter;\nimport ch.qos.logback.core.util.StatusPrinter;\n\npublic class JoranConfiguratorTest {\n\n    LoggerContext loggerContext = new LoggerContext();\n    Logger logger = loggerContext.getLogger(this.getClass().getName());\n    Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n    StatusChecker checker = new StatusChecker(loggerContext);\n    int diff = RandomUtil.getPositiveInt();\n\n    void configure(String file) throws JoranException {\n        JoranConfigurator jc = new JoranConfigurator();\n        jc.setContext(loggerContext);\n        loggerContext.putProperty(\"diff\", \"\" + diff);\n        jc.doConfigure(file);\n\n    }\n\n    @Test\n    public void simpleList() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"simpleList.xml\");\n        Logger logger = loggerContext.getLogger(this.getClass().getName());\n        Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(listAppender);\n        assertEquals(0, listAppender.list.size());\n        String msg = \"hello world\";\n        logger.debug(msg);\n        assertEquals(1, listAppender.list.size());\n        ILoggingEvent le = (ILoggingEvent) listAppender.list.get(0);\n        assertEquals(msg, le.getMessage());\n    }\n\n\n    @Test\n    public void asyncWithMultipleAppendersInRoot() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"async/logback_1614.xml\");\n        Logger logger = loggerContext.getLogger(this.getClass().getName());\n        Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n        AsyncAppender asyncAppender = (AsyncAppender) root.getAppender(\"ASYNC\");\n        assertNotNull(asyncAppender);\n        ConsoleAppender<ILoggingEvent> console = (ConsoleAppender<ILoggingEvent>) root.getAppender(\"CONSOLE\");\n        assertNotNull(console);\n        assertTrue(console.isStarted());\n        //assertEquals(0, listAppender.list.size());\n        String msg = \"hello world\";\n        logger.warn(msg);\n        StatusPrinter.print(loggerContext);\n    }\n    \n    @Test\n    public void simpleListWithImports() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"simpleListWithImports.xml\");\n        Logger logger = loggerContext.getLogger(this.getClass().getName());\n        Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(listAppender);\n        assertEquals(0, listAppender.list.size());\n        String msg = \"hello world\";\n        logger.debug(msg);\n        assertEquals(1, listAppender.list.size());\n        ILoggingEvent le = (ILoggingEvent) listAppender.list.get(0);\n        assertEquals(msg, le.getMessage());\n    }\n\n    @Test\n    public void level() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"simpleLevel.xml\");\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertEquals(0, listAppender.list.size());\n        String msg = \"hello world\";\n        logger.debug(msg);\n        assertEquals(0, listAppender.list.size());\n    }\n\n    @Test\n    public void additivity() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"additivity.xml\");\n        Logger logger = loggerContext.getLogger(\"additivityTest\");\n        assertFalse(logger.isAdditive());\n    }\n\n    @Test\n    public void rootLoggerLevelSettingBySystemProperty() throws JoranException {\n        String propertyName = \"logback.level\";\n\n        System.setProperty(propertyName, \"INFO\");\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"rootLevelByProperty.xml\");\n        // StatusPrinter.print(loggerContext);\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertEquals(0, listAppender.list.size());\n        String msg = \"hello world\";\n        logger.debug(msg);\n        assertEquals(0, listAppender.list.size());\n        System.clearProperty(propertyName);\n    }\n\n    @Test\n    public void loggerLevelSettingBySystemProperty() throws JoranException {\n        String propertyName = \"logback.level\";\n        System.setProperty(propertyName, \"DEBUG\");\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"loggerLevelByProperty.xml\");\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertEquals(0, listAppender.list.size());\n        String msg = \"hello world\";\n        logger.debug(msg);\n        assertEquals(1, listAppender.list.size());\n        System.clearProperty(propertyName);\n    }\n\n    @Test\n    public void appenderRefSettingBySystemProperty() throws JoranException {\n        final String propertyName = \"logback.appenderRef\";\n        System.setProperty(propertyName, \"A\");\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"appenderRefByProperty.xml\");\n        final Logger logger = loggerContext.getLogger(\"ch.qos.logback.classic.joran\");\n        final ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) logger.getAppender(\"A\");\n        assertEquals(0, listAppender.list.size());\n        final String msg = \"hello world\";\n        logger.info(msg);\n\n        assertEquals(1, listAppender.list.size());\n        System.clearProperty(propertyName);\n    }\n\n    @Test\n    public void statusListener() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"statusListener.xml\");\n        StatusPrinter.print(loggerContext);\n        checker.assertIsErrorFree();\n        checker.assertContainsMatch(Status.WARN,\n                \"Please use \\\"level\\\" attribute within <logger> or <root> elements instead.\");\n    }\n\n    @Test\n    public void statusListenerWithImports() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"statusListenerWithImports.xml\");\n        //StatusPrinter.print(loggerContext);\n        checker.assertIsErrorFree();\n        checker.assertContainsMatch(Status.WARN,\n                \"Please use \\\"level\\\" attribute within <logger> or <root> elements instead.\");\n    }\n\n    @Test\n    public void contextRename() throws JoranException {\n        loggerContext.setName(CoreConstants.DEFAULT_CONTEXT_NAME);\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"contextRename.xml\");\n        assertEquals(\"wombat\", loggerContext.getName());\n    }\n\n    @Test\n    public void eval() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"callerData.xml\");\n        String msg = \"hello world\";\n        logger.debug(\"toto\");\n        logger.debug(msg);\n\n        StringListAppender<ILoggingEvent> slAppender = (StringListAppender<ILoggingEvent>) loggerContext\n                .getLogger(\"root\").getAppender(\"STR_LIST\");\n        assertNotNull(slAppender);\n        assertEquals(2, slAppender.strList.size());\n        assertTrue(slAppender.strList.get(0).contains(\" DEBUG - toto\"));\n\n        String str1 = slAppender.strList.get(1);\n        assertTrue(str1.contains(\"Caller+0\"));\n        assertTrue(str1.contains(\" DEBUG - hello world\"));\n    }\n\n    \n    @Test\n    public void missingConfigurationElement() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/noConfig.xml\");\n        \n        String msg1 = \"Exception in body\\\\(\\\\) method for action \\\\[\"+ParamAction.class.getName()+\"\\\\]\";\n        checker.assertContainsMatch(Status.ERROR, msg1);\n        \n        String msg2 = \"current model is null. Is <configuration> element missing?\";\n        checker.assertContainsException(ActionException.class, msg2 );\n    }\n\n    @Test\n    public void ignoreUnknownProperty() throws JoranException {\n        \n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/unknownProperty.xml\");\n        String msg = IGNORING_UNKNOWN_PROP+\" \\\\[a\\\\] in \\\\[ch.qos.logback.classic.LoggerContext\\\\]\";\n        checker.assertContainsMatch(Status.WARN, msg);\n    }\n    \n    // https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=46995\n    @Test\n    public void complexCollectionWihhNoKnownClass() throws JoranException {\n        \n       configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/nestedComplexWithNoKnownClass.xml\");\n       String msg = \"Could not find an appropriate class for property \\\\[listener\\\\]\";\n       checker.assertContainsMatch(Status.ERROR, msg);\n    }\n    \n    @Test\n    public void turboFilter() throws JoranException {\n        // Although this test uses turbo filters, it only checks\n        // that Joran can see the xml element and create\n        // and place the relevant object correctly.\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"turbo.xml\");\n\n        TurboFilter filter = loggerContext.getTurboFilterList().get(0);\n        assertTrue(filter instanceof NOPTurboFilter);\n    }\n\n    @Test\n    public void testTurboFilterWithStringList() throws JoranException {\n        // Although this test uses turbo filters, it only checks\n        // that Joran can see <user> elements, and behave correctly\n        // that is call the addUser method and pass the correct values\n        // to that method.\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"turbo2.xml\");\n\n        // StatusPrinter.print(loggerContext.getStatusManager());\n\n        TurboFilter filter = loggerContext.getTurboFilterList().get(0);\n        assertTrue(filter instanceof DebugUsersTurboFilter);\n        DebugUsersTurboFilter dutf = (DebugUsersTurboFilter) filter;\n        assertEquals(2, dutf.getUsers().size());\n    }\n\n    @Test\n    public void testLevelFilter() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"levelFilter.xml\");\n\n        // StatusPrinter.print(loggerContext);\n\n        logger.warn(\"hello\");\n        logger.error(\"to be ignored\");\n\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n\n        assertNotNull(listAppender);\n        assertEquals(1, listAppender.list.size());\n        ILoggingEvent back = listAppender.list.get(0);\n        assertEquals(Level.WARN, back.getLevel());\n        assertEquals(\"hello\", back.getMessage());\n    }\n\n    @Test\n    public void testEvaluatorFilter() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"evaluatorFilter.xml\");\n\n        // StatusPrinter.print(loggerContext);\n\n        logger.warn(\"hello\");\n        logger.error(\"to be ignored\");\n\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n\n        assertNotNull(listAppender);\n        assertEquals(1, listAppender.list.size());\n        ILoggingEvent back = listAppender.list.get(0);\n        assertEquals(Level.WARN, back.getLevel());\n        assertEquals(\"hello\", back.getMessage());\n    }\n\n    @Test\n    public void testEvaluatorFilterWithImports() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"evaluatorFilterWithImports.xml\");\n\n        // StatusPrinter.print(loggerContext);\n\n        logger.warn(\"hello\");\n        logger.error(\"to be ignored\");\n\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n\n        assertNotNull(listAppender);\n        assertEquals(1, listAppender.list.size());\n        ILoggingEvent back = listAppender.list.get(0);\n        assertEquals(Level.WARN, back.getLevel());\n        assertEquals(\"hello\", back.getMessage());\n    }\n\n    @Test\n    public void testTurboDynamicThreshold() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"turboDynamicThreshold.xml\");\n\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertEquals(0, listAppender.list.size());\n\n        // this one should be denied\n        MDC.put(\"userId\", \"user1\");\n        logger.debug(\"hello user1\");\n        // this one should log\n        MDC.put(\"userId\", \"user2\");\n        logger.debug(\"hello user2\");\n\n        assertEquals(1, listAppender.list.size());\n        ILoggingEvent le = (ILoggingEvent) listAppender.list.get(0);\n        assertEquals(\"hello user2\", le.getMessage());\n    }\n\n    @Test\n    public void testTurboDynamicThreshold2() throws JoranException {\n\n        try {\n            configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"turboDynamicThreshold2.xml\");\n        } finally {\n            // StatusPrinter.print(loggerContext);\n        }\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertEquals(0, listAppender.list.size());\n\n        // this one should log\n        MDC.put(\"userId\", \"user1\");\n        logger.debug(\"hello user1\");\n        // this one should log\n        MDC.put(\"userId\", \"user2\");\n        logger.debug(\"hello user2\");\n        // this one should fail\n        MDC.put(\"userId\", \"user3\");\n        logger.debug(\"hello user3\");\n\n        assertEquals(2, listAppender.list.size());\n        ILoggingEvent le = (ILoggingEvent) listAppender.list.get(0);\n        assertEquals(\"hello user1\", le.getMessage());\n        le = (ILoggingEvent) listAppender.list.get(1);\n        assertEquals(\"hello user2\", le.getMessage());\n    }\n\n    @Test\n    public void timestamp() throws JoranException, IOException, InterruptedException {\n\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"timestamp-context.xml\";\n        configure(configFileAsStr);\n\n        String r = loggerContext.getProperty(\"testTimestamp\");\n        assertNotNull(r);\n        CachingDateFormatter sdf = new CachingDateFormatter(\"yyyy-MM\");\n        String expected = sdf.format(System.currentTimeMillis());\n        assertEquals(\"expected \\\"\" + expected + \"\\\" but got \" + r, expected, r);\n    }\n\n    @Test\n    public void timestampLocal() throws JoranException, IOException, InterruptedException {\n\n        String sysProp = \"ch.qos.logback.classic.joran.JoranConfiguratorTest.timestampLocal\";\n        System.setProperty(sysProp, \"\");\n\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"timestamp-local.xml\";\n        configure(configFileAsStr);\n\n        // It's hard to test the local variable has been set, as it's not\n        // visible from here. But instead we test that it's not set in the\n        // context. And check that a system property has been replaced with the\n        // contents of the local variable\n\n        String r = loggerContext.getProperty(\"testTimestamp\");\n        assertNull(r);\n\n        String expected = \"today is \" + new SimpleDateFormat(\"yyyy-MM\").format(new Date());\n        String sysPropValue = System.getProperty(sysProp);\n        assertEquals(expected, sysPropValue);\n    }\n\n    @Test\n    public void encoderCharset() throws JoranException, IOException, InterruptedException {\n\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"encoderCharset.xml\";\n        configure(configFileAsStr);\n\n        ConsoleAppender<ILoggingEvent> consoleAppender = (ConsoleAppender<ILoggingEvent>) root.getAppender(\"CONSOLE\");\n        assertNotNull(consoleAppender);\n        LayoutWrappingEncoder<ILoggingEvent> encoder = (LayoutWrappingEncoder<ILoggingEvent>) consoleAppender\n                .getEncoder();\n\n        assertEquals(\"UTF-8\", encoder.getCharset().displayName());\n\n        checker.assertIsErrorFree();\n    }\n\n    void verifyJULLevel(String loggerName, Level expectedLevel) {\n        java.util.logging.Logger julLogger = JULHelper.asJULLogger(loggerName);\n        java.util.logging.Level julLevel = julLogger.getLevel();\n\n        if (expectedLevel == null) {\n            assertNull(julLevel);\n        } else {\n            assertEquals(JULHelper.asJULLevel(expectedLevel), julLevel);\n        }\n\n    }\n\n    @Test\n    public void levelChangePropagator0() throws JoranException, IOException, InterruptedException {\n        String loggerName = \"changePropagator0\" + diff;\n        java.util.logging.Logger.getLogger(loggerName).setLevel(java.util.logging.Level.INFO);\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"/jul/levelChangePropagator0.xml\";\n        configure(configFileAsStr);\n\n        checker.assertIsErrorFree();\n        verifyJULLevel(loggerName, null);\n        verifyJULLevel(\"a.b.c.\" + diff, Level.WARN);\n        verifyJULLevel(Logger.ROOT_LOGGER_NAME, Level.TRACE);\n    }\n\n    @Test\n    public void levelChangePropagator1() throws JoranException, IOException, InterruptedException {\n        String loggerName = \"changePropagator1\" + diff;\n        java.util.logging.Logger logger1 = java.util.logging.Logger.getLogger(loggerName);\n        logger1.setLevel(java.util.logging.Level.INFO);\n        verifyJULLevel(loggerName, Level.INFO);\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"/jul/levelChangePropagator1.xml\";\n        configure(configFileAsStr);\n\n        checker.assertIsErrorFree();\n        verifyJULLevel(loggerName, Level.INFO); //\n        verifyJULLevel(\"a.b.c.\" + diff, Level.WARN);\n        verifyJULLevel(Logger.ROOT_LOGGER_NAME, Level.TRACE);\n    }\n\n    @Test\n    @Ignore\n    public void onConsoleRetro() throws JoranException, IOException, InterruptedException {\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"/onConsoleRetro.xml\";\n        configure(configFileAsStr);\n        Thread.sleep(400);\n\n        loggerContext.reset();\n        configure(configFileAsStr);\n    }\n\n    @Test\n    public void unreferencedAppenderShouldNotTriggerUnknownPropertyMessages() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.ISSUES_PREFIX + \"/logback1572.xml\";\n        configure(configFileAsStr);\n        checker.assertContainsMatch(Status.WARN,\n                \"Appender named \\\\[EMAIL\\\\] not referenced. Skipping further processing.\");\n        checker.assertNoMatch(IGNORING_UNKNOWN_PROP+\" \\\\[evaluator\\\\]\");\n    }\n\n    @Test\n    public void LOGBACK_111() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.ISSUES_PREFIX + \"lbcore193.xml\";\n        configure(configFileAsStr);\n        checker.assertContainsException(ScanException.class);\n        checker.assertContainsMatch(Status.ERROR, \"Expecting RIGHT_PARENTHESIS token but got null\");\n        checker.assertContainsMatch(Status.ERROR, \"See also \" + Parser.MISSING_RIGHT_PARENTHESIS);\n    }\n\n    @Test\n    public void properties() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"properties.xml\";\n        assertNull(System.getProperty(\"sys\"));\n\n        configure(configFileAsStr);\n        assertNotNull(loggerContext.getProperty(CoreConstants.HOSTNAME_KEY));\n        assertNull(loggerContext.getProperty(\"transientKey1\"));\n        assertNull(loggerContext.getProperty(\"transientKey2\"));\n        assertEquals(\"node0\", loggerContext.getProperty(\"nodeId\"));\n        assertEquals(\"tem\", System.getProperty(\"sys\"));\n        assertNotNull(loggerContext.getProperty(\"path\"));\n        checker.assertIsErrorFree();\n    }\n\n    @Test\n    public void hostnameProperty() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"hostnameProperty.xml\";\n        configure(configFileAsStr);\n        assertEquals(\"A\", loggerContext.getProperty(CoreConstants.HOSTNAME_KEY));\n    }\n\n    // see also http://jira.qos.ch/browse/LOGBACK-134\n    @Test\n    public void sysProps() throws JoranException {\n        System.setProperty(\"k.lbcore254\", ClassicTestConstants.ISSUES_PREFIX + \"lbcore254\");\n        JoranConfigurator configurator = new JoranConfigurator();\n        configurator.setContext(loggerContext);\n        configurator.doConfigure(ClassicTestConstants.ISSUES_PREFIX + \"lbcore254.xml\");\n\n        checker.assertIsErrorFree();\n    }\n\n    @Test\n    public void propsWithMissingRightCurlyBrace() throws JoranException {\n        System.setProperty(\"abc\", \"not important\");\n        JoranConfigurator configurator = new JoranConfigurator();\n        configurator.setContext(loggerContext);\n        configurator.doConfigure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"propsMissingRightCurlyBrace.xml\");\n        checker.assertContainsMatch(Status.ERROR, \"Problem while parsing\");\n    }\n\n    @Test\n    public void packageDataDisabledByConfigAttribute() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"packagingDataDisabled.xml\";\n        configure(configFileAsStr);\n        assertFalse(loggerContext.isPackagingDataEnabled());\n    }\n\n    @Test\n    public void packageDataEnabledByConfigAttribute() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"packagingDataEnabled.xml\";\n        try {\n            configure(configFileAsStr);\n        } finally {\n            // StatusPrinter.print(loggerContext);\n        }\n        assertTrue(loggerContext.isPackagingDataEnabled());\n    }\n\n    @Test\n    public void valueOfConvention() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"valueOfConvention.xml\";\n        configure(configFileAsStr);\n        checker.assertIsWarningOrErrorFree();\n    }\n\n    @Test\n    public void shutdownHookTest() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"issues/logback_1162.xml\";\n        loggerContext.putProperty(\"output_dir\", ClassicTestConstants.OUTPUT_DIR_PREFIX + \"logback_issue_1162/\");\n        configure(configFileAsStr);\n        Thread thread = (Thread) loggerContext.getObject(CoreConstants.SHUTDOWN_HOOK_THREAD);\n        assertNotNull(thread);\n    }\n\n\n    @Test\n    public void shutdownHookWithDelayParameter() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"issues/logback_1672.xml\";\n        configure(configFileAsStr);\n\n        Thread thread = (Thread) loggerContext.getObject(CoreConstants.SHUTDOWN_HOOK_THREAD);\n        assertNotNull(thread);\n        checker.assertNoMatch(IGNORING_UNKNOWN_PROP);\n    }\n\n    @Test\n    public void migrateShutdownHookClassName() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"issues/logback_1678.xml\";\n        configure(configFileAsStr);\n\n        Thread thread = (Thread) loggerContext.getObject(CoreConstants.SHUTDOWN_HOOK_THREAD);\n        assertNotNull(thread);\n        checker.assertContainsMatch(RENAME_WARNING);\n    }\n\n    @Test\n    public void appenderRefBeforeAppenderTest() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"appenderRefBeforeAppender.xml\";\n        configure(configFileAsStr);\n        Logger logger = loggerContext.getLogger(this.getClass().getName());\n        Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(listAppender);\n        assertEquals(0, listAppender.list.size());\n        String msg = \"hello world\";\n        logger.debug(msg);\n        assertEquals(1, listAppender.list.size());\n        ILoggingEvent le = (ILoggingEvent) listAppender.list.get(0);\n        assertEquals(msg, le.getMessage());\n        checker.assertIsErrorFree();\n    }\n\n    @Test\n    public void unreferencedAppendersShouldBeSkipped() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"unreferencedAppender1.xml\");\n\n        final ListAppender<ILoggingEvent> listAppenderA = (ListAppender<ILoggingEvent>) root.getAppender(\"A\");\n        assertNotNull(listAppenderA);\n        checker.assertContainsMatch(Status.WARN, \"Appender named \\\\[B\\\\] not referenced. Skipping further processing.\");\n    }\n\n    @Test\n    public void asynAppenderListFirst() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"asyncAppender_list_first.xml\");\n\n        final AsyncAppender asyncAppender = (AsyncAppender) root.getAppender(\"ASYNC\");\n        assertNotNull(asyncAppender);\n        assertTrue(asyncAppender.isStarted());\n    }\n\n    @Test\n    public void asynAppenderListAfter() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"asyncAppender_list_after.xml\");\n\n        final AsyncAppender asyncAppender = (AsyncAppender) root.getAppender(\"ASYNC\");\n        assertNotNull(asyncAppender);\n        assertTrue(asyncAppender.isStarted());\n    }\n\n    // https://jira.qos.ch/browse/LOGBACK-1570\n    @Test\n    public void missingPropertyErrorHandling() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"missingProperty.xml\");\n\n        final ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(listAppender);\n        assertTrue(listAppender.isStarted());\n        checker.assertContainsMatch(Status.WARN,\n                IGNORING_UNKNOWN_PROP+\" \\\\[inexistent\\\\] in \\\\[ch.qos.logback.core.read.ListAppender\\\\]\");\n    }\n\n    @Test\n    public void sequenceNumberGenerator() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"sequenceNumberGenerator.xml\");\n        final ListAppender<ILoggingEvent> listAppender= (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(listAppender);\n\n        logger.atDebug().setMessage(\"hello\").log();\n        logger.atDebug().setMessage(\"world\").log();\n\n        ILoggingEvent le0 = listAppender.list.get(0);\n        ILoggingEvent le1 = listAppender.list.get(1);\n\n        long se0 = le0.getSequenceNumber();\n        long se1 = le1.getSequenceNumber();\n        assertEquals(1, se1 - se0);\n        StatusPrinter.print(loggerContext);\n    }\n\n    @Test\n    public void sequenceNumberGenerator_missingClass() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"sequenceNumberGenerator-missingClass.xml\");\n        StatusPrinter.print(loggerContext);\n        final ListAppender<ILoggingEvent> listAppender= (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(listAppender);\n        checker.assertContainsMatch(Status.ERROR, \"Missing attribute \\\\[class\\\\] in element \\\\[sequenceNumberGenerator\\\\]\");\n    }\n\n        @Test\n    public void kvp() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"pattern/kvp.xml\");\n\n        String msg = \"hello kvp\";\n\n        KeyValuePair kvp1 = new KeyValuePair(\"k\" + diff, \"v\" + diff);\n        KeyValuePair kvp2 = new KeyValuePair(\"k\" + (diff + 1), \"v\" + (diff + 1));\n        KeyValuePair kvpNullKey = new KeyValuePair(null, \"v\" + (diff + 2));\n        KeyValuePair kvpNullValue = new KeyValuePair(\"k\" + (diff + 3), null);\n\n        logger.atDebug().addKeyValue(kvp1.key, kvp1.value).log(msg);\n        logger.atDebug().addKeyValue(kvp2.key, kvp2.value).log(msg);\n        logger.atDebug().addKeyValue(kvpNullKey.key, kvpNullKey.value).log(msg);\n        logger.atDebug().addKeyValue(kvpNullValue.key, kvpNullValue.value).log(msg);\n\n        StringListAppender<ILoggingEvent> slAppender = (StringListAppender<ILoggingEvent>) loggerContext\n                .getLogger(\"root\").getAppender(\"LIST\");\n        assertNotNull(slAppender);\n        assertEquals(4, slAppender.strList.size());\n        assertTrue(slAppender.strList.get(0).contains(kvp1.key + \"=\\\"\" + kvp1.value + \"\\\" \" + msg));\n        assertTrue(slAppender.strList.get(1).contains(kvp2.key + \"=\\\"\" + kvp2.value + \"\\\" \" + msg));\n        assertTrue(slAppender.strList.get(2).contains(\"null=\\\"\" + kvpNullKey.value + \"\\\" \" + msg));\n        assertTrue(slAppender.strList.get(3).contains(kvpNullValue.key + \"=\\\"null\\\" \" + msg));\n    }\n \n    \n    // https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=46697\n    @Test\n    public void ossFuzz_46697() throws JoranException  {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/fuzz-46697.xml\");\n         \n        checker.assertContainsMatch(Status.ERROR, ErrorCodes.EMPTY_MODEL_STACK);\n        StatusPrinter.print(loggerContext);\n    }\n\n    // https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47093\n    // In previous versions of the code, we honored String literal\n    // escape sequences for the 'value' attribute named 'value'. After\n    // analysis this was deemed superfluous.\n    @Test\n    public void ossFuzz_47093() throws JoranException  {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/fuzz-47093.xml\");\n        assertEquals(\"a\\\\t\", loggerContext.getProperty(\"fuzz-47093-a\"));\n        assertEquals(\"a\\\\\\\\\", loggerContext.getProperty(\"fuzz-47093-b\"));\n    }\n\n    @Test\n    public void ossFuzz_41117() throws JoranException  {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/fuzz-47117.xml\");\n        checker.assertContainsMatch(Status.ERROR, ErrorCodes.ROOT_LEVEL_CANNOT_BE_SET_TO_NULL);\n        checker.assertErrorCount(2);\n        //StatusPrinter.print(loggerContext);\n    }\n\n    @Test\n    public void ossFuzz_41117_bis() throws JoranException  {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/fuzz-47117-bis.xml\");\n        checker.assertContainsMatch(Status.ERROR, ErrorCodes.ROOT_LEVEL_CANNOT_BE_SET_TO_NULL);\n    }\n\n    @Test\n    public void ossFuzz_41117_bis2() throws JoranException  {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/fuzz-47117-bis2.xml\");\n        checker.assertContainsMatch(Status.ERROR, ErrorCodes.ROOT_LEVEL_CANNOT_BE_SET_TO_NULL);\n    }\n\n    @Test\n    public void ossFuzz_47293() throws JoranException  {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/fuzz-47293.xml\");\n        checker.assertContainsMatch(Status.ERROR, ErrorCodes.MISSING_IF_EMPTY_MODEL_STACK);\n    }\n\n    // reproduction requires placing a binary properties file. Probably not worth the effort.\n//    @Test\n//    public void ossFuzz_47249() throws JoranException  {\n//        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/fuzz-47249.xml\");\n//         StatusPrinter.print(loggerContext);\n//    }\n\n//\t@Test\n//\tpublic void doTest() throws JoranException {\n//\t\tint LIMIT = 0;\n//\t\tboolean oss = true;\n//\t\tfor (int i = 0; i < LIMIT; i++) {\n//\t\t\tinnerDoT(oss);\n//\t\t}\n//\t\tlong start = System.currentTimeMillis();\n//\t\tinnerDoT(oss);\n//\t\tlong diff = System.currentTimeMillis() - start;\n//\t\tdouble average = (1.0d * diff);\n//\t\tSystem.out.println(\"Average time \" + average + \" ms. By serialization \" + oss);\n//\n//\t}\n\n//\tprivate void innerDoT(boolean oss) throws JoranException {\n//\t\tJoranConfigurator jc = new JoranConfigurator();\n//\t\tjc.setContext(loggerContext);\n//\t\tif (oss) {\n//\t\t\tSystem.out.println(\"jc.doT\");\n//\t\t\tjc.doT();\n//\t\t} else {\n//\t\t\tSystem.out.println(\"jc.doConfigure\");\n//\t\t\tjc.doConfigure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"twoAppenders.xml\");\n//\t\t}\n//\t}\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.joran;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.slf4j.MDC;\nimport org.slf4j.event.KeyValuePair;\n\nimport ch.qos.logback.classic.AsyncAppender;\nimport ch.qos.logback.classic.ClassicTestConstants;\nimport ch.qos.logback.classic.Level;\nimport ch.qos.logback.classic.Logger;\nimport ch.qos.logback.classic.LoggerContext;\nimport ch.qos.logback.classic.jul.JULHelper;\nimport ch.qos.logback.classic.spi.ILoggingEvent;\nimport ch.qos.logback.classic.turbo.DebugUsersTurboFilter;\nimport ch.qos.logback.classic.turbo.NOPTurboFilter;\nimport ch.qos.logback.classic.turbo.TurboFilter;\nimport ch.qos.logback.core.ConsoleAppender;\nimport ch.qos.logback.core.CoreConstants;\nimport ch.qos.logback.core.encoder.LayoutWrappingEncoder;\nimport ch.qos.logback.core.joran.action.ParamAction;\nimport ch.qos.logback.core.joran.spi.ActionException;\nimport ch.qos.logback.core.joran.spi.JoranException;\nimport ch.qos.logback.core.pattern.parser.Parser;\nimport ch.qos.logback.core.read.ListAppender;\nimport ch.qos.logback.core.spi.ErrorCodes;\nimport ch.qos.logback.core.spi.ScanException;\nimport ch.qos.logback.core.status.Status;\nimport ch.qos.logback.core.testUtil.RandomUtil;\nimport ch.qos.logback.core.testUtil.StatusChecker;\nimport ch.qos.logback.core.testUtil.StringListAppender;\nimport ch.qos.logback.core.util.CachingDateFormatter;\nimport ch.qos.logback.core.util.StatusPrinter;\n\npublic class JoranConfiguratorTest {\n\n    LoggerContext loggerContext = new LoggerContext();\n    Logger logger = loggerContext.getLogger(this.getClass().getName());\n    Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n    StatusChecker checker = new StatusChecker(loggerContext);\n    int diff = RandomUtil.getPositiveInt();\n\n    void configure(String file) throws JoranException {\n        JoranConfigurator jc = new JoranConfigurator();\n        jc.setContext(loggerContext);\n        loggerContext.putProperty(\"diff\", \"\" + diff);\n        jc.doConfigure(file);\n\n    }\n\n    @Test\n    public void simpleList() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"simpleList.xml\");\n        Logger logger = loggerContext.getLogger(this.getClass().getName());\n        Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(listAppender);\n        assertEquals(0, listAppender.list.size());\n        String msg = \"hello world\";\n        logger.debug(msg);\n        assertEquals(1, listAppender.list.size());\n        ILoggingEvent le = (ILoggingEvent) listAppender.list.get(0);\n        assertEquals(msg, le.getMessage());\n    }\n\n\n    @Test\n    public void asyncWithMultipleAppendersInRoot() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"async/logback_1614.xml\");\n        Logger logger = loggerContext.getLogger(this.getClass().getName());\n        Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n        AsyncAppender asyncAppender = (AsyncAppender) root.getAppender(\"ASYNC\");\n        assertNotNull(asyncAppender);\n        ConsoleAppender<ILoggingEvent> console = (ConsoleAppender<ILoggingEvent>) root.getAppender(\"CONSOLE\");\n        assertNotNull(console);\n        assertTrue(console.isStarted());\n        //assertEquals(0, listAppender.list.size());\n        String msg = \"hello world\";\n        logger.warn(msg);\n        StatusPrinter.print(loggerContext);\n    }\n    \n    @Test\n    public void simpleListWithImports() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"simpleListWithImports.xml\");\n        Logger logger = loggerContext.getLogger(this.getClass().getName());\n        Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(listAppender);\n        assertEquals(0, listAppender.list.size());\n        String msg = \"hello world\";\n        logger.debug(msg);\n        assertEquals(1, listAppender.list.size());\n        ILoggingEvent le = (ILoggingEvent) listAppender.list.get(0);\n        assertEquals(msg, le.getMessage());\n    }\n\n    @Test\n    public void level() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"simpleLevel.xml\");\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertEquals(0, listAppender.list.size());\n        String msg = \"hello world\";\n        logger.debug(msg);\n        assertEquals(0, listAppender.list.size());\n    }\n\n    @Test\n    public void additivity() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"additivity.xml\");\n        Logger logger = loggerContext.getLogger(\"additivityTest\");\n        assertFalse(logger.isAdditive());\n    }\n\n    @Test\n    public void rootLoggerLevelSettingBySystemProperty() throws JoranException {\n        String propertyName = \"logback.level\";\n\n        System.setProperty(propertyName, \"INFO\");\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"rootLevelByProperty.xml\");\n        // StatusPrinter.print(loggerContext);\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertEquals(0, listAppender.list.size());\n        String msg = \"hello world\";\n        logger.debug(msg);\n        assertEquals(0, listAppender.list.size());\n        System.clearProperty(propertyName);\n    }\n\n    @Test\n    public void loggerLevelSettingBySystemProperty() throws JoranException {\n        String propertyName = \"logback.level\";\n        System.setProperty(propertyName, \"DEBUG\");\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"loggerLevelByProperty.xml\");\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertEquals(0, listAppender.list.size());\n        String msg = \"hello world\";\n        logger.debug(msg);\n        assertEquals(1, listAppender.list.size());\n        System.clearProperty(propertyName);\n    }\n\n    @Test\n    public void appenderRefSettingBySystemProperty() throws JoranException {\n        final String propertyName = \"logback.appenderRef\";\n        System.setProperty(propertyName, \"A\");\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"appenderRefByProperty.xml\");\n        final Logger logger = loggerContext.getLogger(\"ch.qos.logback.classic.joran\");\n        final ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) logger.getAppender(\"A\");\n        assertEquals(0, listAppender.list.size());\n        final String msg = \"hello world\";\n        logger.info(msg);\n\n        assertEquals(1, listAppender.list.size());\n        System.clearProperty(propertyName);\n    }\n\n    @Test\n    public void statusListener() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"statusListener.xml\");\n        StatusPrinter.print(loggerContext);\n        checker.assertIsErrorFree();\n        checker.assertContainsMatch(Status.WARN,\n                \"Please use \\\"level\\\" attribute within <logger> or <root> elements instead.\");\n    }\n\n    @Test\n    public void statusListenerWithImports() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"statusListenerWithImports.xml\");\n        //StatusPrinter.print(loggerContext);\n        checker.assertIsErrorFree();\n        checker.assertContainsMatch(Status.WARN,\n                \"Please use \\\"level\\\" attribute within <logger> or <root> elements instead.\");\n    }\n\n    @Test\n    public void contextRename() throws JoranException {\n        loggerContext.setName(CoreConstants.DEFAULT_CONTEXT_NAME);\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"contextRename.xml\");\n        assertEquals(\"wombat\", loggerContext.getName());\n    }\n\n    @Test\n    public void eval() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"callerData.xml\");\n        String msg = \"hello world\";\n        logger.debug(\"toto\");\n        logger.debug(msg);\n\n        StringListAppender<ILoggingEvent> slAppender = (StringListAppender<ILoggingEvent>) loggerContext\n                .getLogger(\"root\").getAppender(\"STR_LIST\");\n        assertNotNull(slAppender);\n        assertEquals(2, slAppender.strList.size());\n        assertTrue(slAppender.strList.get(0).contains(\" DEBUG - toto\"));\n\n        String str1 = slAppender.strList.get(1);\n        assertTrue(str1.contains(\"Caller+0\"));\n        assertTrue(str1.contains(\" DEBUG - hello world\"));\n    }\n\n    \n    @Test\n    public void missingConfigurationElement() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/noConfig.xml\");\n        \n        String msg1 = \"Exception in body\\\\(\\\\) method for action \\\\[\"+ParamAction.class.getName()+\"\\\\]\";\n        checker.assertContainsMatch(Status.ERROR, msg1);\n        \n        String msg2 = \"current model is null. Is <configuration> element missing?\";\n        checker.assertContainsException(ActionException.class, msg2 );\n    }\n\n    @Test\n    public void ignoreUnknownProperty() throws JoranException {\n        \n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/unknownProperty.xml\");\n        String msg = \"Ignoring unkown property \\\\[a\\\\] in \\\\[ch.qos.logback.classic.LoggerContext\\\\]\";\n        checker.assertContainsMatch(Status.WARN, msg);\n    }\n    \n    // https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=46995\n    @Test\n    public void complexCollectionWihhNoKnownClass() throws JoranException {\n        \n       configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/nestedComplexWithNoKnownClass.xml\");\n       String msg = \"Could not find an appropriate class for property \\\\[listener\\\\]\";\n       checker.assertContainsMatch(Status.ERROR, msg);\n    }\n    \n    @Test\n    public void turboFilter() throws JoranException {\n        // Although this test uses turbo filters, it only checks\n        // that Joran can see the xml element and create\n        // and place the relevant object correctly.\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"turbo.xml\");\n\n        TurboFilter filter = loggerContext.getTurboFilterList().get(0);\n        assertTrue(filter instanceof NOPTurboFilter);\n    }\n\n    @Test\n    public void testTurboFilterWithStringList() throws JoranException {\n        // Although this test uses turbo filters, it only checks\n        // that Joran can see <user> elements, and behave correctly\n        // that is call the addUser method and pass the correct values\n        // to that method.\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"turbo2.xml\");\n\n        // StatusPrinter.print(loggerContext.getStatusManager());\n\n        TurboFilter filter = loggerContext.getTurboFilterList().get(0);\n        assertTrue(filter instanceof DebugUsersTurboFilter);\n        DebugUsersTurboFilter dutf = (DebugUsersTurboFilter) filter;\n        assertEquals(2, dutf.getUsers().size());\n    }\n\n    @Test\n    public void testLevelFilter() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"levelFilter.xml\");\n\n        // StatusPrinter.print(loggerContext);\n\n        logger.warn(\"hello\");\n        logger.error(\"to be ignored\");\n\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n\n        assertNotNull(listAppender);\n        assertEquals(1, listAppender.list.size());\n        ILoggingEvent back = listAppender.list.get(0);\n        assertEquals(Level.WARN, back.getLevel());\n        assertEquals(\"hello\", back.getMessage());\n    }\n\n    @Test\n    public void testEvaluatorFilter() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"evaluatorFilter.xml\");\n\n        // StatusPrinter.print(loggerContext);\n\n        logger.warn(\"hello\");\n        logger.error(\"to be ignored\");\n\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n\n        assertNotNull(listAppender);\n        assertEquals(1, listAppender.list.size());\n        ILoggingEvent back = listAppender.list.get(0);\n        assertEquals(Level.WARN, back.getLevel());\n        assertEquals(\"hello\", back.getMessage());\n    }\n\n    @Test\n    public void testEvaluatorFilterWithImports() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"evaluatorFilterWithImports.xml\");\n\n        // StatusPrinter.print(loggerContext);\n\n        logger.warn(\"hello\");\n        logger.error(\"to be ignored\");\n\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n\n        assertNotNull(listAppender);\n        assertEquals(1, listAppender.list.size());\n        ILoggingEvent back = listAppender.list.get(0);\n        assertEquals(Level.WARN, back.getLevel());\n        assertEquals(\"hello\", back.getMessage());\n    }\n\n    @Test\n    public void testTurboDynamicThreshold() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"turboDynamicThreshold.xml\");\n\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertEquals(0, listAppender.list.size());\n\n        // this one should be denied\n        MDC.put(\"userId\", \"user1\");\n        logger.debug(\"hello user1\");\n        // this one should log\n        MDC.put(\"userId\", \"user2\");\n        logger.debug(\"hello user2\");\n\n        assertEquals(1, listAppender.list.size());\n        ILoggingEvent le = (ILoggingEvent) listAppender.list.get(0);\n        assertEquals(\"hello user2\", le.getMessage());\n    }\n\n    @Test\n    public void testTurboDynamicThreshold2() throws JoranException {\n\n        try {\n            configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"turboDynamicThreshold2.xml\");\n        } finally {\n            // StatusPrinter.print(loggerContext);\n        }\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertEquals(0, listAppender.list.size());\n\n        // this one should log\n        MDC.put(\"userId\", \"user1\");\n        logger.debug(\"hello user1\");\n        // this one should log\n        MDC.put(\"userId\", \"user2\");\n        logger.debug(\"hello user2\");\n        // this one should fail\n        MDC.put(\"userId\", \"user3\");\n        logger.debug(\"hello user3\");\n\n        assertEquals(2, listAppender.list.size());\n        ILoggingEvent le = (ILoggingEvent) listAppender.list.get(0);\n        assertEquals(\"hello user1\", le.getMessage());\n        le = (ILoggingEvent) listAppender.list.get(1);\n        assertEquals(\"hello user2\", le.getMessage());\n    }\n\n    @Test\n    public void timestamp() throws JoranException, IOException, InterruptedException {\n\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"timestamp-context.xml\";\n        configure(configFileAsStr);\n\n        String r = loggerContext.getProperty(\"testTimestamp\");\n        assertNotNull(r);\n        CachingDateFormatter sdf = new CachingDateFormatter(\"yyyy-MM\");\n        String expected = sdf.format(System.currentTimeMillis());\n        assertEquals(\"expected \\\"\" + expected + \"\\\" but got \" + r, expected, r);\n    }\n\n    @Test\n    public void timestampLocal() throws JoranException, IOException, InterruptedException {\n\n        String sysProp = \"ch.qos.logback.classic.joran.JoranConfiguratorTest.timestampLocal\";\n        System.setProperty(sysProp, \"\");\n\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"timestamp-local.xml\";\n        configure(configFileAsStr);\n\n        // It's hard to test the local variable has been set, as it's not\n        // visible from here. But instead we test that it's not set in the\n        // context. And check that a system property has been replaced with the\n        // contents of the local variable\n\n        String r = loggerContext.getProperty(\"testTimestamp\");\n        assertNull(r);\n\n        String expected = \"today is \" + new SimpleDateFormat(\"yyyy-MM\").format(new Date());\n        String sysPropValue = System.getProperty(sysProp);\n        assertEquals(expected, sysPropValue);\n    }\n\n    @Test\n    public void encoderCharset() throws JoranException, IOException, InterruptedException {\n\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"encoderCharset.xml\";\n        configure(configFileAsStr);\n\n        ConsoleAppender<ILoggingEvent> consoleAppender = (ConsoleAppender<ILoggingEvent>) root.getAppender(\"CONSOLE\");\n        assertNotNull(consoleAppender);\n        LayoutWrappingEncoder<ILoggingEvent> encoder = (LayoutWrappingEncoder<ILoggingEvent>) consoleAppender\n                .getEncoder();\n\n        assertEquals(\"UTF-8\", encoder.getCharset().displayName());\n\n        checker.assertIsErrorFree();\n    }\n\n    void verifyJULLevel(String loggerName, Level expectedLevel) {\n        java.util.logging.Logger julLogger = JULHelper.asJULLogger(loggerName);\n        java.util.logging.Level julLevel = julLogger.getLevel();\n\n        if (expectedLevel == null) {\n            assertNull(julLevel);\n        } else {\n            assertEquals(JULHelper.asJULLevel(expectedLevel), julLevel);\n        }\n\n    }\n\n    @Test\n    public void levelChangePropagator0() throws JoranException, IOException, InterruptedException {\n        String loggerName = \"changePropagator0\" + diff;\n        java.util.logging.Logger.getLogger(loggerName).setLevel(java.util.logging.Level.INFO);\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"/jul/levelChangePropagator0.xml\";\n        configure(configFileAsStr);\n\n        checker.assertIsErrorFree();\n        verifyJULLevel(loggerName, null);\n        verifyJULLevel(\"a.b.c.\" + diff, Level.WARN);\n        verifyJULLevel(Logger.ROOT_LOGGER_NAME, Level.TRACE);\n    }\n\n    @Test\n    public void levelChangePropagator1() throws JoranException, IOException, InterruptedException {\n        String loggerName = \"changePropagator1\" + diff;\n        java.util.logging.Logger logger1 = java.util.logging.Logger.getLogger(loggerName);\n        logger1.setLevel(java.util.logging.Level.INFO);\n        verifyJULLevel(loggerName, Level.INFO);\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"/jul/levelChangePropagator1.xml\";\n        configure(configFileAsStr);\n\n        checker.assertIsErrorFree();\n        verifyJULLevel(loggerName, Level.INFO); //\n        verifyJULLevel(\"a.b.c.\" + diff, Level.WARN);\n        verifyJULLevel(Logger.ROOT_LOGGER_NAME, Level.TRACE);\n    }\n\n    @Test\n    @Ignore\n    public void onConsoleRetro() throws JoranException, IOException, InterruptedException {\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"/onConsoleRetro.xml\";\n        configure(configFileAsStr);\n        Thread.sleep(400);\n\n        loggerContext.reset();\n        configure(configFileAsStr);\n    }\n\n    @Test\n    public void unreferencedAppenderShouldNotTriggerUnknownPropertyMessages() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.ISSUES_PREFIX + \"/logback1572.xml\";\n        configure(configFileAsStr);\n        checker.assertContainsMatch(Status.WARN,\n                \"Appender named \\\\[EMAIL\\\\] not referenced. Skipping further processing.\");\n        checker.assertNoMatch(\"Ignoring unkown property \\\\[evaluator\\\\]\");\n    }\n\n    @Test\n    public void LOGBACK_111() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.ISSUES_PREFIX + \"lbcore193.xml\";\n        configure(configFileAsStr);\n        checker.assertContainsException(ScanException.class);\n        checker.assertContainsMatch(Status.ERROR, \"Expecting RIGHT_PARENTHESIS token but got null\");\n        checker.assertContainsMatch(Status.ERROR, \"See also \" + Parser.MISSING_RIGHT_PARENTHESIS);\n    }\n\n    @Test\n    public void properties() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"properties.xml\";\n        assertNull(System.getProperty(\"sys\"));\n\n        configure(configFileAsStr);\n        assertNotNull(loggerContext.getProperty(CoreConstants.HOSTNAME_KEY));\n        assertNull(loggerContext.getProperty(\"transientKey1\"));\n        assertNull(loggerContext.getProperty(\"transientKey2\"));\n        assertEquals(\"node0\", loggerContext.getProperty(\"nodeId\"));\n        assertEquals(\"tem\", System.getProperty(\"sys\"));\n        assertNotNull(loggerContext.getProperty(\"path\"));\n        checker.assertIsErrorFree();\n    }\n\n    @Test\n    public void hostnameProperty() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"hostnameProperty.xml\";\n        configure(configFileAsStr);\n        assertEquals(\"A\", loggerContext.getProperty(CoreConstants.HOSTNAME_KEY));\n    }\n\n    // see also http://jira.qos.ch/browse/LOGBACK-134\n    @Test\n    public void sysProps() throws JoranException {\n        System.setProperty(\"k.lbcore254\", ClassicTestConstants.ISSUES_PREFIX + \"lbcore254\");\n        JoranConfigurator configurator = new JoranConfigurator();\n        configurator.setContext(loggerContext);\n        configurator.doConfigure(ClassicTestConstants.ISSUES_PREFIX + \"lbcore254.xml\");\n\n        checker.assertIsErrorFree();\n    }\n\n    @Test\n    public void propsWithMissingRightCurlyBrace() throws JoranException {\n        System.setProperty(\"abc\", \"not important\");\n        JoranConfigurator configurator = new JoranConfigurator();\n        configurator.setContext(loggerContext);\n        configurator.doConfigure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"propsMissingRightCurlyBrace.xml\");\n        checker.assertContainsMatch(Status.ERROR, \"Problem while parsing\");\n    }\n\n    @Test\n    public void packageDataDisabledByConfigAttribute() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"packagingDataDisabled.xml\";\n        configure(configFileAsStr);\n        assertFalse(loggerContext.isPackagingDataEnabled());\n    }\n\n    @Test\n    public void packageDataEnabledByConfigAttribute() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"packagingDataEnabled.xml\";\n        try {\n            configure(configFileAsStr);\n        } finally {\n            // StatusPrinter.print(loggerContext);\n        }\n        assertTrue(loggerContext.isPackagingDataEnabled());\n    }\n\n    @Test\n    public void valueOfConvention() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"valueOfConvention.xml\";\n        configure(configFileAsStr);\n        checker.assertIsWarningOrErrorFree();\n    }\n\n    @Test\n    public void shutdownHookTest() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"issues/logback_1162.xml\";\n        loggerContext.putProperty(\"output_dir\", ClassicTestConstants.OUTPUT_DIR_PREFIX + \"logback_issue_1162/\");\n        configure(configFileAsStr);\n        assertNotNull(loggerContext.getObject(CoreConstants.SHUTDOWN_HOOK_THREAD));\n    }\n\n    @Test\n    public void appenderRefBeforeAppenderTest() throws JoranException {\n        String configFileAsStr = ClassicTestConstants.JORAN_INPUT_PREFIX + \"appenderRefBeforeAppender.xml\";\n        configure(configFileAsStr);\n        Logger logger = loggerContext.getLogger(this.getClass().getName());\n        Logger root = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n        ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(listAppender);\n        assertEquals(0, listAppender.list.size());\n        String msg = \"hello world\";\n        logger.debug(msg);\n        assertEquals(1, listAppender.list.size());\n        ILoggingEvent le = (ILoggingEvent) listAppender.list.get(0);\n        assertEquals(msg, le.getMessage());\n        checker.assertIsErrorFree();\n    }\n\n    @Test\n    public void unreferencedAppendersShouldBeSkipped() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"unreferencedAppender1.xml\");\n\n        final ListAppender<ILoggingEvent> listAppenderA = (ListAppender<ILoggingEvent>) root.getAppender(\"A\");\n        assertNotNull(listAppenderA);\n        checker.assertContainsMatch(Status.WARN, \"Appender named \\\\[B\\\\] not referenced. Skipping further processing.\");\n    }\n\n    @Test\n    public void asynAppenderListFirst() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"asyncAppender_list_first.xml\");\n\n        final AsyncAppender asyncAppender = (AsyncAppender) root.getAppender(\"ASYNC\");\n        assertNotNull(asyncAppender);\n        assertTrue(asyncAppender.isStarted());\n    }\n\n    @Test\n    public void asynAppenderListAfter() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"asyncAppender_list_after.xml\");\n\n        final AsyncAppender asyncAppender = (AsyncAppender) root.getAppender(\"ASYNC\");\n        assertNotNull(asyncAppender);\n        assertTrue(asyncAppender.isStarted());\n    }\n\n    // https://jira.qos.ch/browse/LOGBACK-1570\n    @Test\n    public void missingPropertyErrorHandling() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"missingProperty.xml\");\n\n        final ListAppender<ILoggingEvent> listAppender = (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(listAppender);\n        assertTrue(listAppender.isStarted());\n        checker.assertContainsMatch(Status.WARN,\n                \"Ignoring unkown property \\\\[inexistent\\\\] in \\\\[ch.qos.logback.core.read.ListAppender\\\\]\");\n    }\n\n    @Test\n    public void sequenceNumberGenerator() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"sequenceNumberGenerator.xml\");\n        final ListAppender<ILoggingEvent> listAppender= (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(listAppender);\n\n        logger.atDebug().setMessage(\"hello\").log();\n        logger.atDebug().setMessage(\"world\").log();\n\n        ILoggingEvent le0 = listAppender.list.get(0);\n        ILoggingEvent le1 = listAppender.list.get(1);\n\n        long se0 = le0.getSequenceNumber();\n        long se1 = le1.getSequenceNumber();\n        assertEquals(1, se1 - se0);\n        StatusPrinter.print(loggerContext);\n    }\n\n    @Test\n    public void sequenceNumberGenerator_missingClass() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"sequenceNumberGenerator-missingClass.xml\");\n        StatusPrinter.print(loggerContext);\n        final ListAppender<ILoggingEvent> listAppender= (ListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(listAppender);\n        checker.assertContainsMatch(Status.ERROR, \"Missing attribute \\\\[class\\\\] in element \\\\[sequenceNumberGenerator\\\\]\");\n    }\n\n        @Test\n    public void kvp() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"pattern/kvp.xml\");\n\n        String msg = \"hello kvp\";\n\n        KeyValuePair kvp1 = new KeyValuePair(\"k\" + diff, \"v\" + diff);\n        KeyValuePair kvp2 = new KeyValuePair(\"k\" + (diff + 1), \"v\" + (diff + 1));\n        KeyValuePair kvpNullKey = new KeyValuePair(null, \"v\" + (diff + 2));\n        KeyValuePair kvpNullValue = new KeyValuePair(\"k\" + (diff + 3), null);\n\n        logger.atDebug().addKeyValue(kvp1.key, kvp1.value).log(msg);\n        logger.atDebug().addKeyValue(kvp2.key, kvp2.value).log(msg);\n        logger.atDebug().addKeyValue(kvpNullKey.key, kvpNullKey.value).log(msg);\n        logger.atDebug().addKeyValue(kvpNullValue.key, kvpNullValue.value).log(msg);\n\n        StringListAppender<ILoggingEvent> slAppender = (StringListAppender<ILoggingEvent>) loggerContext\n                .getLogger(\"root\").getAppender(\"LIST\");\n        assertNotNull(slAppender);\n        assertEquals(4, slAppender.strList.size());\n        assertTrue(slAppender.strList.get(0).contains(kvp1.key + \"=\\\"\" + kvp1.value + \"\\\" \" + msg));\n        assertTrue(slAppender.strList.get(1).contains(kvp2.key + \"=\\\"\" + kvp2.value + \"\\\" \" + msg));\n        assertTrue(slAppender.strList.get(2).contains(\"null=\\\"\" + kvpNullKey.value + \"\\\" \" + msg));\n        assertTrue(slAppender.strList.get(3).contains(kvpNullValue.key + \"=\\\"null\\\" \" + msg));\n    }\n \n    \n    // https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=46697\n    @Test\n    public void ossFuzz_46697() throws JoranException  {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/fuzz-46697.xml\");\n         \n        checker.assertContainsMatch(Status.ERROR, ErrorCodes.EMPTY_MODEL_STACK);\n        StatusPrinter.print(loggerContext);\n    }\n\n    // https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47093\n    // In previous versions of the code, we honored String literal\n    // escape sequences for the 'value' attribute named 'value'. After\n    // analysis this was deemed superfluous.\n    @Test\n    public void ossFuzz_47093() throws JoranException  {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/fuzz-47093.xml\");\n        assertEquals(\"a\\\\t\", loggerContext.getProperty(\"fuzz-47093-a\"));\n        assertEquals(\"a\\\\\\\\\", loggerContext.getProperty(\"fuzz-47093-b\"));\n    }\n\n    @Test\n    public void ossFuzz_41117() throws JoranException  {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/fuzz-47117.xml\");\n        checker.assertContainsMatch(Status.ERROR, ErrorCodes.ROOT_LEVEL_CANNOT_BE_SET_TO_NULL);\n        checker.assertErrorCount(2);\n        //StatusPrinter.print(loggerContext);\n    }\n\n    @Test\n    public void ossFuzz_41117_bis() throws JoranException  {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/fuzz-47117-bis.xml\");\n        checker.assertContainsMatch(Status.ERROR, ErrorCodes.ROOT_LEVEL_CANNOT_BE_SET_TO_NULL);\n    }\n\n    @Test\n    public void ossFuzz_41117_bis2() throws JoranException  {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/fuzz-47117-bis2.xml\");\n        checker.assertContainsMatch(Status.ERROR, ErrorCodes.ROOT_LEVEL_CANNOT_BE_SET_TO_NULL);\n    }\n\n    @Test\n    public void ossFuzz_47293() throws JoranException  {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/fuzz-47293.xml\");\n        checker.assertContainsMatch(Status.ERROR, ErrorCodes.MISSING_IF_EMPTY_MODEL_STACK);\n    }\n\n    // reproduction requires placing a binary properties file. Probably not worth the effort.\n//    @Test\n//    public void ossFuzz_47249() throws JoranException  {\n//        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"ossfuzz/fuzz-47249.xml\");\n//         StatusPrinter.print(loggerContext);\n//    }\n\n//\t@Test\n//\tpublic void doTest() throws JoranException {\n//\t\tint LIMIT = 0;\n//\t\tboolean oss = true;\n//\t\tfor (int i = 0; i < LIMIT; i++) {\n//\t\t\tinnerDoT(oss);\n//\t\t}\n//\t\tlong start = System.currentTimeMillis();\n//\t\tinnerDoT(oss);\n//\t\tlong diff = System.currentTimeMillis() - start;\n//\t\tdouble average = (1.0d * diff);\n//\t\tSystem.out.println(\"Average time \" + average + \" ms. By serialization \" + oss);\n//\n//\t}\n\n//\tprivate void innerDoT(boolean oss) throws JoranException {\n//\t\tJoranConfigurator jc = new JoranConfigurator();\n//\t\tjc.setContext(loggerContext);\n//\t\tif (oss) {\n//\t\t\tSystem.out.println(\"jc.doT\");\n//\t\t\tjc.doT();\n//\t\t} else {\n//\t\t\tSystem.out.println(\"jc.doConfigure\");\n//\t\t\tjc.doConfigure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"twoAppenders.xml\");\n//\t\t}\n//\t}\n\n}\n","lineNo":578}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2022, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.model.processor;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.function.Supplier;\n\nimport ch.qos.logback.core.Context;\nimport ch.qos.logback.core.joran.util.beans.BeanDescriptionCache;\nimport ch.qos.logback.core.model.Model;\nimport ch.qos.logback.core.model.ModelHandlerFactoryMethod;\nimport ch.qos.logback.core.model.NamedComponentModel;\nimport ch.qos.logback.core.spi.ContextAwareBase;\nimport ch.qos.logback.core.spi.FilterReply;\n\n/**\n * DefaultProcessor traverses the Model produced at an earlier step and performs actual \n * configuration of logback according to the handlers it was given.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @since 1.3.0\n */\npublic class DefaultProcessor extends ContextAwareBase {\n\n    interface TraverseMethod {\n        int traverse(Model model, ModelFilter modelFiler);\n    }\n \n    final ModelInterpretationContext mic;\n    final HashMap<Class<? extends Model>, ModelHandlerFactoryMethod> modelClassToHandlerMap = new HashMap<>();\n    final HashMap<Class<? extends Model>, Supplier<ModelHandlerBase>> modelClassToDependencyAnalyserMap = new HashMap<>();\n\n    ChainedModelFilter phaseOneFilter = new ChainedModelFilter();\n    ChainedModelFilter phaseTwoFilter = new ChainedModelFilter();\n\n    public DefaultProcessor(Context context, ModelInterpretationContext mic) {\n        this.setContext(context);\n        this.mic = mic;\n    }\n\n    public void addHandler(Class<? extends Model> modelClass, ModelHandlerFactoryMethod modelFactoryMethod) {\n        \n        modelClassToHandlerMap.put(modelClass, modelFactoryMethod);\n        \n        ProcessingPhase phase = determineProcessingPhase(modelClass);\n        switch(phase) {\n        case FIRST:\n            getPhaseOneFilter().allow(modelClass);\n            break;\n        case SECOND:\n            getPhaseTwoFilter().allow(modelClass);\n            break;\n        default:\n            throw new IllegalArgumentException(\"unexpected value \" + phase + \" for model class \"+ modelClass.getName());        \n        }\n    }\n\n    private ProcessingPhase determineProcessingPhase(Class<? extends Model> modelClass) {\n        \n        PhaseIndicator phaseIndicator =  modelClass.getAnnotation(PhaseIndicator.class);\n        if(phaseIndicator == null) {\n            return ProcessingPhase.FIRST;\n        }\n        \n        ProcessingPhase phase = phaseIndicator.phase();\n        return phase;\n    }\n\n    public void addAnalyser(Class<? extends Model> modelClass, Supplier<ModelHandlerBase> analyserSupplier) {\n        modelClassToDependencyAnalyserMap.put(modelClass, analyserSupplier);\n    }\n\n    private void traversalLoop(TraverseMethod traverseMethod, Model model, ModelFilter modelfFilter, String phaseName) {\n        int LIMIT = 3;\n        for (int i = 0; i < LIMIT; i++) {\n            int handledModelCount = traverseMethod.traverse(model, modelfFilter);\n            if (handledModelCount == 0)\n                break;\n        }\n    }\n\n    public void process(Model model) {\n\n        if (model == null) {\n            addError(\"Expecting non null model to process\");\n            return;\n        }\n        initialObjectPush();\n\n        mainTraverse(model, getPhaseOneFilter());\n        analyseDependencies(model);\n        traversalLoop(this::secondPhaseTraverse, model, getPhaseTwoFilter(), \"phase 2\");\n\n        addInfo(\"End of configuration.\");\n        finalObjectPop();\n    }\n\n    private void finalObjectPop() {\n        mic.popObject();\n    }\n\n    private void initialObjectPush() {\n        mic.pushObject(context);\n    }\n\n    public ChainedModelFilter getPhaseOneFilter() {\n        return phaseOneFilter;\n    }\n\n    public ChainedModelFilter getPhaseTwoFilter() {\n        return phaseTwoFilter;\n    }\n\n\n    protected void analyseDependencies(Model model) {\n        Supplier<ModelHandlerBase> analyserSupplier = modelClassToDependencyAnalyserMap.get(model.getClass());\n        \n        ModelHandlerBase analyser = null;\n        \n        if(analyserSupplier != null) {\n            analyser = analyserSupplier.get();\n        }\n        \n        if (analyser != null) {\n            try {\n                analyser.handle(mic, model);\n            } catch (ModelHandlerException e) {\n                addError(\"Failed to traverse model \" + model.getTag(), e);\n            }\n        }\n\n        for (Model m : model.getSubModels()) {\n            analyseDependencies(m);\n        }\n        if (analyser != null) {\n            try {\n                analyser.postHandle(mic, model);\n            } catch (ModelHandlerException e) {\n                addError(\"Failed to invoke postHandle on model \" + model.getTag(), e);\n            }\n        }\n    }\n\n    static final int DENIED = -1;\n\n    private ModelHandlerBase createHandler(Model model) {\n        ModelHandlerFactoryMethod modelFactoryMethod = modelClassToHandlerMap.get(model.getClass());\n\n        if (modelFactoryMethod == null) {\n            addError(\"Can't handle model of type \" + model.getClass() + \"  with tag: \" + model.getTag() + \" at line \"\n                    + model.getLineNumber());\n            return null;\n        }\n\n        ModelHandlerBase handler = modelFactoryMethod.make(context, mic);\n        if (handler == null)\n            return null;\n        if (!handler.isSupportedModelType(model)) {\n            addWarn(\"Handler [\" + handler.getClass() + \"] does not support \" + model.idString());\n            return null;\n        }\n        return handler;\n    }\n\n    protected int mainTraverse(Model model, ModelFilter modelFiler) {\n\n        FilterReply filterReply = modelFiler.decide(model);\n        if (filterReply == FilterReply.DENY)\n            return DENIED;\n\n        int count = 0;\n\n        try {\n            ModelHandlerBase handler = null;\n            boolean unhandled = model.isUnhandled();\n\n            if (unhandled) {\n                handler = createHandler(model);\n                if (handler != null) {\n                    handler.handle(mic, model);\n                    model.markAsHandled();\n                    count++;\n                }\n            }\n            // recurse into submodels handled or not\n            if (!model.isSkipped()) {\n                for (Model m : model.getSubModels()) {\n                    count += mainTraverse(m, modelFiler);\n                }\n            }\n\n            if (unhandled && handler != null) {\n                handler.postHandle(mic, model);\n            }\n        } catch (ModelHandlerException e) {\n            addError(\"Failed to traverse model \" + model.getTag(), e);\n        }\n        return count;\n    }\n\n    protected int secondPhaseTraverse(Model model, ModelFilter modelFilter) {\n\n        FilterReply filterReply = modelFilter.decide(model);\n        if (filterReply == FilterReply.DENY) {\n            return 0;\n        }\n\n        int count = 0;\n\n        try {\n\n            boolean allDependenciesStarted = allDependenciesStarted(model);\n\n            ModelHandlerBase handler = null;\n            if (model.isUnhandled() && allDependenciesStarted) {\n                handler = createHandler(model);\n                if (handler != null) {\n                    handler.handle(mic, model);\n                    model.markAsHandled();\n                    count++;\n                }\n            }\n\n            if (!allDependenciesStarted && !dependencyIsADirectSubmodel(model)) {\n                return count;\n            }\n\n            if (!model.isSkipped()) {\n                for (Model m : model.getSubModels()) {\n                    count += secondPhaseTraverse(m, modelFilter);\n                }\n            }\n            if (handler != null) {\n                handler.postHandle(mic, model);\n            }\n        } catch (ModelHandlerException e) {\n            addError(\"Failed to traverse model \" + model.getTag(), e);\n        }\n        return count;\n    }\n\n    private boolean dependencyIsADirectSubmodel(Model model) {\n        List<String> dependecyNames = this.mic.getDependeeNamesForModel(model);\n        if (dependecyNames == null || dependecyNames.isEmpty()) {\n            return false;\n        }\n        for (Model submodel : model.getSubModels()) {\n            if (submodel instanceof NamedComponentModel) {\n                NamedComponentModel namedComponentModel = (NamedComponentModel) submodel;\n                String subModelName = namedComponentModel.getName();\n                if (dependecyNames.contains(subModelName)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private boolean allDependenciesStarted(Model model) {\n        List<String> dependencyNames = mic.getDependeeNamesForModel(model);\n       \n        if (dependencyNames == null || dependencyNames.isEmpty()) {\n            return true;\n        }\n        for (String name : dependencyNames) {\n            boolean isStarted = mic.isNamedDependeeStarted(name);\n            if (isStarted == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    ModelHandlerBase instantiateHandler(Class<? extends ModelHandlerBase> handlerClass) {\n        try {\n            Constructor<? extends ModelHandlerBase> commonConstructor = getWithContextConstructor(handlerClass);\n            if (commonConstructor != null) {\n                return commonConstructor.newInstance(context);\n            }\n            Constructor<? extends ModelHandlerBase> constructorWithBDC = getWithContextAndBDCConstructor(handlerClass);\n            if (constructorWithBDC != null) {\n                return constructorWithBDC.newInstance(context, mic.getBeanDescriptionCache());\n            }\n            addError(\"Failed to find suitable constructor for class [\" + handlerClass + \"]\");\n            return null;\n        } catch (InstantiationException | IllegalAccessException | SecurityException | IllegalArgumentException\n                | InvocationTargetException e1) {\n            addError(\"Failed to instantiate \" + handlerClass);\n            return null;\n        }\n    }\n\n    private Constructor<? extends ModelHandlerBase> getWithContextConstructor(\n            Class<? extends ModelHandlerBase> handlerClass) {\n        try {\n            Constructor<? extends ModelHandlerBase> constructor = handlerClass.getConstructor(Context.class);\n            return constructor;\n        } catch (NoSuchMethodException e) {\n            return null;\n        }\n    }\n\n    private Constructor<? extends ModelHandlerBase> getWithContextAndBDCConstructor(\n            Class<? extends ModelHandlerBase> handlerClass) {\n        try {\n            Constructor<? extends ModelHandlerBase> constructor = handlerClass.getConstructor(Context.class,\n                    BeanDescriptionCache.class);\n            return constructor;\n        } catch (NoSuchMethodException e) {\n            return null;\n        }\n    }\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2022, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.model.processor;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.function.Supplier;\n\nimport ch.qos.logback.core.Context;\nimport ch.qos.logback.core.joran.util.beans.BeanDescriptionCache;\nimport ch.qos.logback.core.model.Model;\nimport ch.qos.logback.core.model.ModelHandlerFactoryMethod;\nimport ch.qos.logback.core.model.NamedComponentModel;\nimport ch.qos.logback.core.spi.ContextAwareBase;\nimport ch.qos.logback.core.spi.FilterReply;\n\n/**\n * DefaultProcessor traverses the Model produced at an earlier step and performs actual \n * configuration of logback according to the handlers it was given.\n * \n * @author Ceki G&uuml;lc&uuml;\n * @since 1.3.0\n */\npublic class DefaultProcessor extends ContextAwareBase {\n\n    interface TraverseMethod {\n        int traverse(Model model, ModelFilter modelFiler);\n    }\n \n    final ModelInterpretationContext mic;\n    final HashMap<Class<? extends Model>, ModelHandlerFactoryMethod> modelClassToHandlerMap = new HashMap<>();\n    final HashMap<Class<? extends Model>, Supplier<ModelHandlerBase>> modelClassToDependencyAnalyserMap = new HashMap<>();\n\n    ChainedModelFilter phaseOneFilter = new ChainedModelFilter();\n    ChainedModelFilter phaseTwoFilter = new ChainedModelFilter();\n\n    public DefaultProcessor(Context context, ModelInterpretationContext mic) {\n        this.setContext(context);\n        this.mic = mic;\n    }\n\n    public void addHandler(Class<? extends Model> modelClass, ModelHandlerFactoryMethod modelFactoryMethod) {\n        \n        modelClassToHandlerMap.put(modelClass, modelFactoryMethod);\n        \n        ProcessingPhase phase = determineProcessingPhase(modelClass);\n        switch(phase) {\n        case FIRST:\n            getPhaseOneFilter().allow(modelClass);\n            break;\n        case SECOND:\n            getPhaseTwoFilter().allow(modelClass);\n            break;\n        default:\n            throw new IllegalArgumentException(\"unexpected value \" + phase + \" for model class \"+ modelClass.getName());        \n        }\n    }\n\n    private ProcessingPhase determineProcessingPhase(Class<? extends Model> modelClass) {\n        \n        PhaseIndicator phaseIndicator =  modelClass.getAnnotation(PhaseIndicator.class);\n        if(phaseIndicator == null) {\n            return ProcessingPhase.FIRST;\n        }\n        \n        ProcessingPhase phase = phaseIndicator.phase();\n        return phase;\n    }\n\n    public void addAnalyser(Class<? extends Model> modelClass, Supplier<ModelHandlerBase> analyserSupplier) {\n        modelClassToDependencyAnalyserMap.put(modelClass, analyserSupplier);\n    }\n\n    private void traversalLoop(TraverseMethod traverseMethod, Model model, ModelFilter modelfFilter, String phaseName) {\n        int LIMIT = 3;\n        for (int i = 0; i < LIMIT; i++) {\n            int handledModelCount = traverseMethod.traverse(model, modelfFilter);\n            if (handledModelCount == 0)\n                break;\n        }\n    }\n\n    public void process(Model model) {\n\n        if (model == null) {\n            addError(\"Expecting non null model to process\");\n            return;\n        }\n        initialObjectPush();\n\n        mainTraverse(model, getPhaseOneFilter());\n        analyseDependencies(model);\n        traversalLoop(this::secondPhaseTraverse, model, getPhaseTwoFilter(), \"phase 2\");\n\n        addInfo(\"End of configuration.\");\n        finalObjectPop();\n    }\n\n    private void finalObjectPop() {\n        mic.popObject();\n    }\n\n    private void initialObjectPush() {\n        mic.pushObject(context);\n    }\n\n    public ChainedModelFilter getPhaseOneFilter() {\n        return phaseOneFilter;\n    }\n\n    public ChainedModelFilter getPhaseTwoFilter() {\n        return phaseTwoFilter;\n    }\n\n\n    protected void analyseDependencies(Model model) {\n        Supplier<ModelHandlerBase> analyserSupplier = modelClassToDependencyAnalyserMap.get(model.getClass());\n        \n        ModelHandlerBase analyser = null;\n        \n        if(analyserSupplier != null) {\n            analyser = analyserSupplier.get();\n        }\n        \n        if (analyser != null) {\n            try {\n                analyser.handle(mic, model);\n            } catch (ModelHandlerException e) {\n                addError(\"Failed to traverse model \" + model.getTag(), e);\n            }\n        }\n\n        for (Model m : model.getSubModels()) {\n            analyseDependencies(m);\n        }\n        if (analyser != null) {\n            try {\n                analyser.postHandle(mic, model);\n            } catch (ModelHandlerException e) {\n                addError(\"Failed to invoke postHandle on model \" + model.getTag(), e);\n            }\n        }\n    }\n\n    static final int DENIED = -1;\n\n    private ModelHandlerBase createHandler(Model model) {\n        ModelHandlerFactoryMethod modelFactoryMethod = modelClassToHandlerMap.get(model.getClass());\n\n        if (modelFactoryMethod == null) {\n            addError(\"Can't handle model of type \" + model.getClass() + \"  with tag: \" + model.getTag() + \" at line \"\n                    + model.getLineNumber());\n            return null;\n        }\n\n        ModelHandlerBase handler = modelFactoryMethod.make(context, mic);\n        if (handler == null)\n            return null;\n        if (!handler.isSupportedModelType(model)) {\n            addWarn(\"Handler [\" + handler.getClass() + \"] does not support \" + model.idString());\n            return null;\n        }\n        return handler;\n    }\n\n    protected int mainTraverse(Model model, ModelFilter modelFiler) {\n\n        FilterReply filterReply = modelFiler.decide(model);\n        if (filterReply == FilterReply.DENY)\n            return DENIED;\n\n        int count = 0;\n\n        try {\n            ModelHandlerBase handler = null;\n            if (model.isUnhandled()) {\n                handler = createHandler(model);\n                if (handler != null) {\n                    handler.handle(mic, model);\n                    model.markAsHandled();\n                    count++;\n                }\n            }\n            // recurse into submodels handled or not\n            if (!model.isSkipped()) {\n                for (Model m : model.getSubModels()) {\n                    count += mainTraverse(m, modelFiler);\n                }\n            }\n\n            if (model.isUnhandled() && handler != null) {\n                handler.postHandle(mic, model);\n            }\n        } catch (ModelHandlerException e) {\n            addError(\"Failed to traverse model \" + model.getTag(), e);\n        }\n        return count;\n    }\n\n    protected int secondPhaseTraverse(Model model, ModelFilter modelFilter) {\n\n        FilterReply filterReply = modelFilter.decide(model);\n        if (filterReply == FilterReply.DENY) {\n            return 0;\n        }\n\n        int count = 0;\n\n        try {\n\n            boolean allDependenciesStarted = allDependenciesStarted(model);\n\n            ModelHandlerBase handler = null;\n            if (model.isUnhandled() && allDependenciesStarted) {\n                handler = createHandler(model);\n                if (handler != null) {\n                    handler.handle(mic, model);\n                    model.markAsHandled();\n                    count++;\n                }\n            }\n\n            if (!allDependenciesStarted && !dependencyIsADirectSubmodel(model)) {\n                return count;\n            }\n\n            if (!model.isSkipped()) {\n                for (Model m : model.getSubModels()) {\n                    count += secondPhaseTraverse(m, modelFilter);\n                }\n            }\n            if (handler != null) {\n                handler.postHandle(mic, model);\n            }\n        } catch (ModelHandlerException e) {\n            addError(\"Failed to traverse model \" + model.getTag(), e);\n        }\n        return count;\n    }\n\n    private boolean dependencyIsADirectSubmodel(Model model) {\n        List<String> dependecyNames = this.mic.getDependeeNamesForModel(model);\n        if (dependecyNames == null || dependecyNames.isEmpty()) {\n            return false;\n        }\n        for (Model submodel : model.getSubModels()) {\n            if (submodel instanceof NamedComponentModel) {\n                NamedComponentModel namedComponentModel = (NamedComponentModel) submodel;\n                String subModelName = namedComponentModel.getName();\n                if (dependecyNames.contains(subModelName)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private boolean allDependenciesStarted(Model model) {\n        List<String> dependencyNames = mic.getDependeeNamesForModel(model);\n       \n        if (dependencyNames == null || dependencyNames.isEmpty()) {\n            return true;\n        }\n        for (String name : dependencyNames) {\n            boolean isStarted = mic.isNamedDependeeStarted(name);\n            if (isStarted == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    ModelHandlerBase instantiateHandler(Class<? extends ModelHandlerBase> handlerClass) {\n        try {\n            Constructor<? extends ModelHandlerBase> commonConstructor = getWithContextConstructor(handlerClass);\n            if (commonConstructor != null) {\n                return commonConstructor.newInstance(context);\n            }\n            Constructor<? extends ModelHandlerBase> constructorWithBDC = getWithContextAndBDCConstructor(handlerClass);\n            if (constructorWithBDC != null) {\n                return constructorWithBDC.newInstance(context, mic.getBeanDescriptionCache());\n            }\n            addError(\"Failed to find suitable constructor for class [\" + handlerClass + \"]\");\n            return null;\n        } catch (InstantiationException | IllegalAccessException | SecurityException | IllegalArgumentException\n                | InvocationTargetException e1) {\n            addError(\"Failed to instantiate \" + handlerClass);\n            return null;\n        }\n    }\n\n    private Constructor<? extends ModelHandlerBase> getWithContextConstructor(\n            Class<? extends ModelHandlerBase> handlerClass) {\n        try {\n            Constructor<? extends ModelHandlerBase> constructor = handlerClass.getConstructor(Context.class);\n            return constructor;\n        } catch (NoSuchMethodException e) {\n            return null;\n        }\n    }\n\n    private Constructor<? extends ModelHandlerBase> getWithContextAndBDCConstructor(\n            Class<? extends ModelHandlerBase> handlerClass) {\n        try {\n            Constructor<? extends ModelHandlerBase> constructor = handlerClass.getConstructor(Context.class,\n                    BeanDescriptionCache.class);\n            return constructor;\n        } catch (NoSuchMethodException e) {\n            return null;\n        }\n    }\n\n}\n","lineNo":189}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2022, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.model.processor;\n\nimport ch.qos.logback.core.Context;\nimport ch.qos.logback.core.model.AppenderRefModel;\nimport ch.qos.logback.core.model.Model;\n\npublic class AppenderRefDependencyAnalyser extends ModelHandlerBase {\n\n    public AppenderRefDependencyAnalyser(Context context) {\n        super(context);\n    }\n\n    @Override\n    protected Class<AppenderRefModel> getSupportedModelClass() {\n        return AppenderRefModel.class;\n    }\n\n    @Override\n    public void handle(ModelInterpretationContext mic, Model model) throws ModelHandlerException {\n\n        AppenderRefModel appenderRefModel = (AppenderRefModel) model;\n\n        String ref = mic.subst(appenderRefModel.getRef());\n\n        Model depender;\n        if (mic.isModelStackEmpty()) {\n            // appenderRefModel maybe the dependent model. This is the case in logback-access\n            depender = appenderRefModel;\n        } else {\n            Model parentModel = mic.peekModel();\n            depender = parentModel;\n        }\n\n        DependencyDefinition dd = new DependencyDefinition(depender, ref);\n        mic.addDependencyDefinition(dd);\n        \n    }\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2022, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.model.processor;\n\nimport ch.qos.logback.core.Context;\nimport ch.qos.logback.core.model.AppenderRefModel;\nimport ch.qos.logback.core.model.Model;\n\npublic class AppenderRefDependencyAnalyser extends ModelHandlerBase {\n\n    public AppenderRefDependencyAnalyser(Context context) {\n        super(context);\n    }\n\n    @Override\n    protected Class<AppenderRefModel> getSupportedModelClass() {\n        return AppenderRefModel.class;\n    }\n\n    @Override\n    public void handle(ModelInterpretationContext mic, Model model) throws ModelHandlerException {\n\n        AppenderRefModel appenderRefModel = (AppenderRefModel) model;\n\n        String ref = mic.subst(appenderRefModel.getRef());\n\n        \n        if (mic.isModelStackEmpty()) {\n            // appenderRefModel maybe the dependent model. This is the case in logback-access\n            DependencyDefinition dd = new DependencyDefinition(appenderRefModel, ref);\n            mic.addDependencyDefinition(dd);\n        } else {\n            Model parentModel = mic.peekModel();\n            DependencyDefinition dd = new DependencyDefinition(parentModel, ref);\n            mic.addDependencyDefinition(dd);\n        }\n    }\n\n}\n","lineNo":38}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.joran.spi;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertThrows;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.util.function.Supplier;\n\nimport org.junit.Test;\nimport org.xml.sax.Attributes;\n\nimport ch.qos.logback.core.ContextBase;\nimport ch.qos.logback.core.joran.action.Action;\n\n/**\n * Test SimpleRuleStore for various explicit rule combinations.\n * \n * We also test that explicit patterns are case sensitive.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic class SimpleRuleStoreTest {\n\n    SimpleRuleStore srs = new SimpleRuleStore(new ContextBase());\n    CaseCombinator cc = new CaseCombinator();\n\n    @Test\n    public void smoke() throws Exception {\n        srs.addRule(new ElementSelector(\"a/b\"), () -> new XAction());\n\n        // test for all possible case combinations of \"a/b\"\n        for (String s : cc.combinations(\"a/b\")) {\n            System.out.println(\"s=\" + s);\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n            if (!(r.get() instanceof XAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void smokeII() throws Exception {\n        srs.addRule(new ElementSelector(\"a/b\"), () -> new XAction());\n\n        Exception e = assertThrows(IllegalStateException.class, () -> {\n            srs.addRule(new ElementSelector(\"a/b\"), () -> new YAction());\n        });\n        assertEquals(\"[a][b] already has an associated action supplier\", e.getMessage());\n    }\n\n    @Test\n    public void testSlashSuffix() throws Exception {\n        ElementSelector pa = new ElementSelector(\"a/\");\n        srs.addRule(pa, () -> new XAction());\n\n        for (String s : cc.combinations(\"a\")) {\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n            if (!(r.get() instanceof XAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n\n    }\n\n    @Test\n    public void testTail1() throws Exception {\n        srs.addRule(new ElementSelector(\"*/b\"), () -> new XAction());\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n            if (!(r.get() instanceof XAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void testTail2() throws Exception {\n        SimpleRuleStore srs = new SimpleRuleStore(new ContextBase());\n        srs.addRule(new ElementSelector(\"*/c\"), () -> new XAction());\n\n        for (String s : cc.combinations(\"a/b/c\")) {\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n            if (!(r.get() instanceof XAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void testTail3() throws Exception {\n        srs.addRule(new ElementSelector(\"*/b\"), () -> new XAction());\n        srs.addRule(new ElementSelector(\"*/a/b\"), () -> new YAction());\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n            Action ya = r.get();\n            if (!(ya instanceof YAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void testTail4() throws Exception {\n        srs.addRule(new ElementSelector(\"*/b\"), () -> new XAction());\n        srs.addRule(new ElementSelector(\"*/a/b\"), () -> new YAction());\n        srs.addRule(new ElementSelector(\"a/b\"), () -> new ZAction());\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n            if (!(r.get() instanceof ZAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void testSuffix() throws Exception {\n        srs.addRule(new ElementSelector(\"a\"), () -> new XAction());\n        srs.addRule(new ElementSelector(\"a/*\"), () -> new YAction());\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n            assertTrue(r.get() instanceof YAction);\n        }\n    }\n\n    @Test\n    public void testDeepSuffix() throws Exception {\n        srs.addRule(new ElementSelector(\"a\"), () -> new XAction(1));\n        srs.addRule(new ElementSelector(\"a/b/*\"), () -> new XAction(2));\n\n        for (String s : cc.combinations(\"a/other\")) {\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNull(r);\n        }\n    }\n\n    @Test\n    public void testPrefixSuffixInteraction1() throws Exception {\n        srs.addRule(new ElementSelector(\"a\"), () -> new ZAction());\n        srs.addRule(new ElementSelector(\"a/*\"), () -> new YAction());\n        srs.addRule(new ElementSelector(\"*/a/b\"), () -> new XAction(3));\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n            Action ra = r.get();\n            \n            assertTrue(ra instanceof XAction);\n            XAction xaction = (XAction) ra;\n            assertEquals(3, xaction.id);\n        }\n    }\n\n    @Test\n    public void testPrefixSuffixInteraction2() throws Exception {\n        srs.addRule(new ElementSelector(\"tG\"), () -> new XAction());\n        srs.addRule(new ElementSelector(\"tG/tS\"), () -> new YAction());\n        srs.addRule(new ElementSelector(\"tG/tS/test\"), () -> new ZAction());\n        srs.addRule(new ElementSelector(\"tG/tS/test/*\"), () -> new XAction(9));\n\n        for (String s : cc.combinations(\"tG/tS/toto\")) {\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNull(r);\n        }\n    }\n\n    @Test\n    public void withTransparentParts() throws Exception {\n//        srs.addRule(new ElementSelector(\"x\"), new TopElementAction());\n//        srs.addRule(new ElementSelector(\"x/stack\"), new StackAction());\n//        srs.addRule(new ElementSelector(\"x/property\"), new PropertyAction());\n//        srs.addRule(new ElementSelector(\"*/if\"), new IfAction());\n//        srs.addRule(new ElementSelector(\"*/if/then\"), new ThenAction());\n//        srs.addRule(new ElementSelector(\"*/if/else\"), new ElseAction());\n\n        srs.addTransparentPathPart(\"if\");\n        srs.addTransparentPathPart(\"then\");\n        srs.addTransparentPathPart(\"else\");\n\n        {\n            ElementPath ep = new ElementPath(\"x/if/then/if\");\n            ElementPath witness = new ElementPath(\"x/\");\n            \n            ElementPath cleanedEP = srs.removeTransparentPathParts(ep);\n            assertEquals(witness, cleanedEP);\n        }\n        \n        {\n            ElementPath ep = new ElementPath(\"x/if/then/stack\");\n            ElementPath witness = new ElementPath(\"x/stack\");\n            \n            ElementPath cleanedEP = srs.removeTransparentPathParts(ep);\n            assertEquals(witness, cleanedEP);\n        }\n        \n        {\n            ElementPath ep = new ElementPath(\"x/if/then/if/else/stack\");\n            ElementPath witness = new ElementPath(\"x/stack\");\n            \n            ElementPath cleanedEP = srs.removeTransparentPathParts(ep);\n            assertEquals(witness, cleanedEP);\n        }\n        \n\n    }\n\n    class XAction extends Action {\n        int id = 0;\n\n        XAction() {\n        }\n\n        XAction(int id) {\n            this.id = id;\n        }\n\n        public void begin(SaxEventInterpretationContext ec, String name, Attributes attributes) {\n        }\n\n        public void end(SaxEventInterpretationContext ec, String name) {\n        }\n\n        public void finish(SaxEventInterpretationContext ec) {\n        }\n\n        public String toString() {\n            return \"XAction(\" + id + \")\";\n        }\n    }\n\n    class YAction extends Action {\n        public void begin(SaxEventInterpretationContext ec, String name, Attributes attributes) {\n        }\n\n        public void end(SaxEventInterpretationContext ec, String name) {\n        }\n\n        public void finish(SaxEventInterpretationContext ec) {\n        }\n    }\n\n    class ZAction extends Action {\n        public void begin(SaxEventInterpretationContext ec, String name, Attributes attributes) {\n        }\n\n        public void end(SaxEventInterpretationContext ec, String name) {\n        }\n\n        public void finish(SaxEventInterpretationContext ec) {\n        }\n    }\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.joran.spi;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertThrows;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport org.junit.Test;\nimport org.xml.sax.Attributes;\n\nimport ch.qos.logback.core.ContextBase;\nimport ch.qos.logback.core.joran.action.Action;\n\n/**\n * Test SimpleRuleStore for various explicit rule combinations.\n * \n * We also test that explicit patterns are case sensitive.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic class SimpleRuleStoreTest {\n\n    SimpleRuleStore srs = new SimpleRuleStore(new ContextBase());\n    CaseCombinator cc = new CaseCombinator();\n\n    @Test\n    public void smoke() throws Exception {\n        srs.addRule(new ElementSelector(\"a/b\"), new XAction());\n\n        // test for all possible case combinations of \"a/b\"\n        for (String s : cc.combinations(\"a/b\")) {\n            System.out.println(\"s=\" + s);\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n            if (!(r instanceof XAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void smokeII() throws Exception {\n        srs.addRule(new ElementSelector(\"a/b\"), new XAction());\n        \n        Exception e = assertThrows(IllegalStateException.class, () -> {\n           srs.addRule(new ElementSelector(\"a/b\"), new YAction());\n        });\n        assertEquals(\"[a][b] already has an associated action\", e.getMessage());\n    }\n    @Test\n    public void testSlashSuffix() throws Exception {\n        ElementSelector pa = new ElementSelector(\"a/\");\n        srs.addRule(pa, new XAction());\n\n        for (String s : cc.combinations(\"a\")) {\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n            \n            if (!(r instanceof XAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n\n    }\n\n    @Test\n    public void testTail1() throws Exception {\n        srs.addRule(new ElementSelector(\"*/b\"), new XAction());\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n            if (!(r instanceof XAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void testTail2() throws Exception {\n        SimpleRuleStore srs = new SimpleRuleStore(new ContextBase());\n        srs.addRule(new ElementSelector(\"*/c\"), new XAction());\n\n        for (String s : cc.combinations(\"a/b/c\")) {\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n            if (!(r instanceof XAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void testTail3() throws Exception {\n        srs.addRule(new ElementSelector(\"*/b\"), new XAction());\n        srs.addRule(new ElementSelector(\"*/a/b\"), new YAction());\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n            if (!(r instanceof YAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void testTail4() throws Exception {\n        srs.addRule(new ElementSelector(\"*/b\"), new XAction());\n        srs.addRule(new ElementSelector(\"*/a/b\"), new YAction());\n        srs.addRule(new ElementSelector(\"a/b\"), new ZAction());\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n            if (!(r instanceof ZAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void testSuffix() throws Exception {\n        srs.addRule(new ElementSelector(\"a\"), new XAction());\n        srs.addRule(new ElementSelector(\"a/*\"), new YAction());\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n            assertTrue(r instanceof YAction);\n        }\n    }\n\n    @Test\n    public void testDeepSuffix() throws Exception {\n        srs.addRule(new ElementSelector(\"a\"), new XAction(1));\n        srs.addRule(new ElementSelector(\"a/b/*\"), new XAction(2));\n\n        for (String s : cc.combinations(\"a/other\")) {\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNull(r);\n        }\n    }\n\n    @Test\n    public void testPrefixSuffixInteraction1() throws Exception {\n        srs.addRule(new ElementSelector(\"a\"), new ZAction());\n        srs.addRule(new ElementSelector(\"a/*\"), new YAction());\n        srs.addRule(new ElementSelector(\"*/a/b\"), new XAction(3));\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n\n            assertTrue(r instanceof XAction);\n            XAction xaction = (XAction) r;\n            assertEquals(3, xaction.id);\n        }\n    }\n\n    @Test\n    public void testPrefixSuffixInteraction2() throws Exception {\n        srs.addRule(new ElementSelector(\"tG\"), new XAction());\n        srs.addRule(new ElementSelector(\"tG/tS\"), new YAction());\n        srs.addRule(new ElementSelector(\"tG/tS/test\"), new ZAction());\n        srs.addRule(new ElementSelector(\"tG/tS/test/*\"), new XAction(9));\n\n        for (String s : cc.combinations(\"tG/tS/toto\")) {\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNull(r);\n        }\n    }\n\n    class XAction extends Action {\n        int id = 0;\n\n        XAction() {\n        }\n\n        XAction(int id) {\n            this.id = id;\n        }\n\n        public void begin(SaxEventInterpretationContext ec, String name, Attributes attributes) {\n        }\n\n        public void end(SaxEventInterpretationContext ec, String name) {\n        }\n\n        public void finish(SaxEventInterpretationContext ec) {\n        }\n\n        public String toString() {\n            return \"XAction(\" + id + \")\";\n        }\n    }\n\n    class YAction extends Action {\n        public void begin(SaxEventInterpretationContext ec, String name, Attributes attributes) {\n        }\n\n        public void end(SaxEventInterpretationContext ec, String name) {\n        }\n\n        public void finish(SaxEventInterpretationContext ec) {\n        }\n    }\n\n    class ZAction extends Action {\n        public void begin(SaxEventInterpretationContext ec, String name, Attributes attributes) {\n        }\n\n        public void end(SaxEventInterpretationContext ec, String name) {\n        }\n\n        public void finish(SaxEventInterpretationContext ec) {\n        }\n    }\n\n}\n","lineNo":121}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.joran.spi;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertThrows;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.util.function.Supplier;\n\nimport org.junit.Test;\nimport org.xml.sax.Attributes;\n\nimport ch.qos.logback.core.ContextBase;\nimport ch.qos.logback.core.joran.action.Action;\n\n/**\n * Test SimpleRuleStore for various explicit rule combinations.\n * \n * We also test that explicit patterns are case sensitive.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic class SimpleRuleStoreTest {\n\n    SimpleRuleStore srs = new SimpleRuleStore(new ContextBase());\n    CaseCombinator cc = new CaseCombinator();\n\n    @Test\n    public void smoke() throws Exception {\n        srs.addRule(new ElementSelector(\"a/b\"), () -> new XAction());\n\n        // test for all possible case combinations of \"a/b\"\n        for (String s : cc.combinations(\"a/b\")) {\n            System.out.println(\"s=\" + s);\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n            if (!(r.get() instanceof XAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void smokeII() throws Exception {\n        srs.addRule(new ElementSelector(\"a/b\"), () -> new XAction());\n\n        Exception e = assertThrows(IllegalStateException.class, () -> {\n            srs.addRule(new ElementSelector(\"a/b\"), () -> new YAction());\n        });\n        assertEquals(\"[a][b] already has an associated action supplier\", e.getMessage());\n    }\n\n    @Test\n    public void testSlashSuffix() throws Exception {\n        ElementSelector pa = new ElementSelector(\"a/\");\n        srs.addRule(pa, () -> new XAction());\n\n        for (String s : cc.combinations(\"a\")) {\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n            if (!(r.get() instanceof XAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n\n    }\n\n    @Test\n    public void testTail1() throws Exception {\n        srs.addRule(new ElementSelector(\"*/b\"), () -> new XAction());\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n            if (!(r.get() instanceof XAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void testTail2() throws Exception {\n        SimpleRuleStore srs = new SimpleRuleStore(new ContextBase());\n        srs.addRule(new ElementSelector(\"*/c\"), () -> new XAction());\n\n        for (String s : cc.combinations(\"a/b/c\")) {\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n            if (!(r.get() instanceof XAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void testTail3() throws Exception {\n        srs.addRule(new ElementSelector(\"*/b\"), () -> new XAction());\n        srs.addRule(new ElementSelector(\"*/a/b\"), () -> new YAction());\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n            Action ya = r.get();\n            if (!(ya instanceof YAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void testTail4() throws Exception {\n        srs.addRule(new ElementSelector(\"*/b\"), () -> new XAction());\n        srs.addRule(new ElementSelector(\"*/a/b\"), () -> new YAction());\n        srs.addRule(new ElementSelector(\"a/b\"), () -> new ZAction());\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n            if (!(r.get() instanceof ZAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void testSuffix() throws Exception {\n        srs.addRule(new ElementSelector(\"a\"), () -> new XAction());\n        srs.addRule(new ElementSelector(\"a/*\"), () -> new YAction());\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n            assertTrue(r.get() instanceof YAction);\n        }\n    }\n\n    @Test\n    public void testDeepSuffix() throws Exception {\n        srs.addRule(new ElementSelector(\"a\"), () -> new XAction(1));\n        srs.addRule(new ElementSelector(\"a/b/*\"), () -> new XAction(2));\n\n        for (String s : cc.combinations(\"a/other\")) {\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNull(r);\n        }\n    }\n\n    @Test\n    public void testPrefixSuffixInteraction1() throws Exception {\n        srs.addRule(new ElementSelector(\"a\"), () -> new ZAction());\n        srs.addRule(new ElementSelector(\"a/*\"), () -> new YAction());\n        srs.addRule(new ElementSelector(\"*/a/b\"), () -> new XAction(3));\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n            Action ra = r.get();\n            \n            assertTrue(ra instanceof XAction);\n            XAction xaction = (XAction) ra;\n            assertEquals(3, xaction.id);\n        }\n    }\n\n    @Test\n    public void testPrefixSuffixInteraction2() throws Exception {\n        srs.addRule(new ElementSelector(\"tG\"), () -> new XAction());\n        srs.addRule(new ElementSelector(\"tG/tS\"), () -> new YAction());\n        srs.addRule(new ElementSelector(\"tG/tS/test\"), () -> new ZAction());\n        srs.addRule(new ElementSelector(\"tG/tS/test/*\"), () -> new XAction(9));\n\n        for (String s : cc.combinations(\"tG/tS/toto\")) {\n            Supplier<Action> r = srs.matchActions(new ElementPath(s));\n            assertNull(r);\n        }\n    }\n\n    @Test\n    public void withTransparentParts() throws Exception {\n//        srs.addRule(new ElementSelector(\"x\"), new TopElementAction());\n//        srs.addRule(new ElementSelector(\"x/stack\"), new StackAction());\n//        srs.addRule(new ElementSelector(\"x/property\"), new PropertyAction());\n//        srs.addRule(new ElementSelector(\"*/if\"), new IfAction());\n//        srs.addRule(new ElementSelector(\"*/if/then\"), new ThenAction());\n//        srs.addRule(new ElementSelector(\"*/if/else\"), new ElseAction());\n\n        srs.addTransparentPathPart(\"if\");\n        srs.addTransparentPathPart(\"then\");\n        srs.addTransparentPathPart(\"else\");\n\n        {\n            ElementPath ep = new ElementPath(\"x/if/then/if\");\n            ElementPath witness = new ElementPath(\"x/\");\n            \n            ElementPath cleanedEP = srs.removeTransparentPathParts(ep);\n            assertEquals(witness, cleanedEP);\n        }\n        \n        {\n            ElementPath ep = new ElementPath(\"x/if/then/stack\");\n            ElementPath witness = new ElementPath(\"x/stack\");\n            \n            ElementPath cleanedEP = srs.removeTransparentPathParts(ep);\n            assertEquals(witness, cleanedEP);\n        }\n        \n        {\n            ElementPath ep = new ElementPath(\"x/if/then/if/else/stack\");\n            ElementPath witness = new ElementPath(\"x/stack\");\n            \n            ElementPath cleanedEP = srs.removeTransparentPathParts(ep);\n            assertEquals(witness, cleanedEP);\n        }\n        \n\n    }\n\n    class XAction extends Action {\n        int id = 0;\n\n        XAction() {\n        }\n\n        XAction(int id) {\n            this.id = id;\n        }\n\n        public void begin(SaxEventInterpretationContext ec, String name, Attributes attributes) {\n        }\n\n        public void end(SaxEventInterpretationContext ec, String name) {\n        }\n\n        public void finish(SaxEventInterpretationContext ec) {\n        }\n\n        public String toString() {\n            return \"XAction(\" + id + \")\";\n        }\n    }\n\n    class YAction extends Action {\n        public void begin(SaxEventInterpretationContext ec, String name, Attributes attributes) {\n        }\n\n        public void end(SaxEventInterpretationContext ec, String name) {\n        }\n\n        public void finish(SaxEventInterpretationContext ec) {\n        }\n    }\n\n    class ZAction extends Action {\n        public void begin(SaxEventInterpretationContext ec, String name, Attributes attributes) {\n        }\n\n        public void end(SaxEventInterpretationContext ec, String name) {\n        }\n\n        public void finish(SaxEventInterpretationContext ec) {\n        }\n    }\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.joran.spi;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertThrows;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport org.junit.Test;\nimport org.xml.sax.Attributes;\n\nimport ch.qos.logback.core.ContextBase;\nimport ch.qos.logback.core.joran.action.Action;\n\n/**\n * Test SimpleRuleStore for various explicit rule combinations.\n * \n * We also test that explicit patterns are case sensitive.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic class SimpleRuleStoreTest {\n\n    SimpleRuleStore srs = new SimpleRuleStore(new ContextBase());\n    CaseCombinator cc = new CaseCombinator();\n\n    @Test\n    public void smoke() throws Exception {\n        srs.addRule(new ElementSelector(\"a/b\"), new XAction());\n\n        // test for all possible case combinations of \"a/b\"\n        for (String s : cc.combinations(\"a/b\")) {\n            System.out.println(\"s=\" + s);\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n            if (!(r instanceof XAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void smokeII() throws Exception {\n        srs.addRule(new ElementSelector(\"a/b\"), new XAction());\n        \n        Exception e = assertThrows(IllegalStateException.class, () -> {\n           srs.addRule(new ElementSelector(\"a/b\"), new YAction());\n        });\n        assertEquals(\"[a][b] already has an associated action\", e.getMessage());\n    }\n    @Test\n    public void testSlashSuffix() throws Exception {\n        ElementSelector pa = new ElementSelector(\"a/\");\n        srs.addRule(pa, new XAction());\n\n        for (String s : cc.combinations(\"a\")) {\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n            \n            if (!(r instanceof XAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n\n    }\n\n    @Test\n    public void testTail1() throws Exception {\n        srs.addRule(new ElementSelector(\"*/b\"), new XAction());\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n            if (!(r instanceof XAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void testTail2() throws Exception {\n        SimpleRuleStore srs = new SimpleRuleStore(new ContextBase());\n        srs.addRule(new ElementSelector(\"*/c\"), new XAction());\n\n        for (String s : cc.combinations(\"a/b/c\")) {\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n            if (!(r instanceof XAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void testTail3() throws Exception {\n        srs.addRule(new ElementSelector(\"*/b\"), new XAction());\n        srs.addRule(new ElementSelector(\"*/a/b\"), new YAction());\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n            if (!(r instanceof YAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void testTail4() throws Exception {\n        srs.addRule(new ElementSelector(\"*/b\"), new XAction());\n        srs.addRule(new ElementSelector(\"*/a/b\"), new YAction());\n        srs.addRule(new ElementSelector(\"a/b\"), new ZAction());\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n            if (!(r instanceof ZAction)) {\n                fail(\"Wrong type\");\n            }\n        }\n    }\n\n    @Test\n    public void testSuffix() throws Exception {\n        srs.addRule(new ElementSelector(\"a\"), new XAction());\n        srs.addRule(new ElementSelector(\"a/*\"), new YAction());\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n            assertTrue(r instanceof YAction);\n        }\n    }\n\n    @Test\n    public void testDeepSuffix() throws Exception {\n        srs.addRule(new ElementSelector(\"a\"), new XAction(1));\n        srs.addRule(new ElementSelector(\"a/b/*\"), new XAction(2));\n\n        for (String s : cc.combinations(\"a/other\")) {\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNull(r);\n        }\n    }\n\n    @Test\n    public void testPrefixSuffixInteraction1() throws Exception {\n        srs.addRule(new ElementSelector(\"a\"), new ZAction());\n        srs.addRule(new ElementSelector(\"a/*\"), new YAction());\n        srs.addRule(new ElementSelector(\"*/a/b\"), new XAction(3));\n\n        for (String s : cc.combinations(\"a/b\")) {\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNotNull(r);\n\n\n            assertTrue(r instanceof XAction);\n            XAction xaction = (XAction) r;\n            assertEquals(3, xaction.id);\n        }\n    }\n\n    @Test\n    public void testPrefixSuffixInteraction2() throws Exception {\n        srs.addRule(new ElementSelector(\"tG\"), new XAction());\n        srs.addRule(new ElementSelector(\"tG/tS\"), new YAction());\n        srs.addRule(new ElementSelector(\"tG/tS/test\"), new ZAction());\n        srs.addRule(new ElementSelector(\"tG/tS/test/*\"), new XAction(9));\n\n        for (String s : cc.combinations(\"tG/tS/toto\")) {\n            Action r = srs.matchActions(new ElementPath(s));\n            assertNull(r);\n        }\n    }\n\n    class XAction extends Action {\n        int id = 0;\n\n        XAction() {\n        }\n\n        XAction(int id) {\n            this.id = id;\n        }\n\n        public void begin(SaxEventInterpretationContext ec, String name, Attributes attributes) {\n        }\n\n        public void end(SaxEventInterpretationContext ec, String name) {\n        }\n\n        public void finish(SaxEventInterpretationContext ec) {\n        }\n\n        public String toString() {\n            return \"XAction(\" + id + \")\";\n        }\n    }\n\n    class YAction extends Action {\n        public void begin(SaxEventInterpretationContext ec, String name, Attributes attributes) {\n        }\n\n        public void end(SaxEventInterpretationContext ec, String name) {\n        }\n\n        public void finish(SaxEventInterpretationContext ec) {\n        }\n    }\n\n    class ZAction extends Action {\n        public void begin(SaxEventInterpretationContext ec, String name, Attributes attributes) {\n        }\n\n        public void end(SaxEventInterpretationContext ec, String name) {\n        }\n\n        public void finish(SaxEventInterpretationContext ec) {\n        }\n    }\n\n}\n","lineNo":177}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.joran.spi;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport ch.qos.logback.core.Context;\nimport ch.qos.logback.core.joran.action.Action;\nimport ch.qos.logback.core.spi.ContextAwareBase;\nimport ch.qos.logback.core.util.OptionHelper;\n\n/**\n * This class implements the {@link RuleStore} interface. It is the rule store\n * implementation used by default in Joran.\n * \n * @author Ceki G&uuml;lc&uuml;\n * \n */\npublic class SimpleRuleStore extends ContextAwareBase implements RuleStore {\n\n    static String KLEENE_STAR = \"*\";\n\n    // key: Pattern instance, value: ArrayList containing actions\n    HashMap<ElementSelector, Action> rules = new HashMap<>();\n\n    // public SimpleRuleStore() {\n    // }\n\n    public SimpleRuleStore(Context context) {\n        setContext(context);\n    }\n\n    /**\n     * Add a new rule, i.e. a pattern, action pair to the rule store.\n     * <p>\n     * Note that the added action's LoggerRepository will be set in the process.\n     */\n    public void addRule(ElementSelector elementSelector, Action action) {\n        action.setContext(context);\n\n        Action existing = rules.get(elementSelector);\n        \n        if (existing == null) {\n            rules.put(elementSelector, action);\n        } else {\n            throw new IllegalStateException(elementSelector.toString() + \" already has an associated action\");\n        }\n    }\n\n    public void addRule(ElementSelector elementSelector, String actionClassName) {\n        Action action = null;\n\n        try {\n            action = (Action) OptionHelper.instantiateByClassName(actionClassName, Action.class, context);\n        } catch (Exception e) {\n            addError(\"Could not instantiate class [\" + actionClassName + \"]\", e);\n        }\n        if (action != null) {\n            addRule(elementSelector, action);\n        }\n    }\n\n    // exact match has highest priority\n    // if no exact match, check for suffix (tail) match, i.e matches\n    // of type */x/y. Suffix match for */x/y has higher priority than match for\n    // */x\n    // if no suffix match, check for prefix match, i.e. matches for x/*\n    // match for x/y/* has higher priority than matches for x/*\n\n    public Action matchActions(ElementPath elementPath) {\n        Action action;\n        \n        ElementPath cleanedElementPath = elementPath;\n\n        //ElementPath cleanedElementPath = cleanElementPath(elementPath);\n        \n        if ((action = fullPathMatch(cleanedElementPath)) != null) {\n            return action;\n        } else if ((action = suffixMatch(cleanedElementPath)) != null) {\n            return action;\n        } else if ((action = prefixMatch(cleanedElementPath)) != null) {\n            return action;\n        } else if ((action = middleMatch(cleanedElementPath)) != null) {\n            return action;\n        } else {\n            return null;\n        }\n    }\n\n    private ElementPath cleanElementPath(ElementPath uncleanElementPath) {\n        Stream<String> stream = uncleanElementPath.partList.stream();\n        \n        List<String> cleanedList = stream.filter(e -> e.equalsIgnoreCase(\"if\")).collect(Collectors.toList());\n        \n        return new ElementPath(cleanedList);\n        \n        \n    }\n\n    Action fullPathMatch(ElementPath elementPath) {\n        for (ElementSelector selector : rules.keySet()) {\n            if (selector.fullPathMatch(elementPath))\n                return rules.get(selector);\n        }\n        return null;\n    }\n\n    // Suffix matches are matches of type */x/y\n    Action suffixMatch(ElementPath elementPath) {\n        int max = 0;\n        ElementSelector longestMatchingElementSelector = null;\n\n        for (ElementSelector selector : rules.keySet()) {\n            if (isSuffixPattern(selector)) {\n                int r = selector.getTailMatchLength(elementPath);\n                if (r > max) {\n                    max = r;\n                    longestMatchingElementSelector = selector;\n                }\n            }\n        }\n\n        if (longestMatchingElementSelector != null) {\n            return rules.get(longestMatchingElementSelector);\n        } else {\n            return null;\n        }\n    }\n\n    private boolean isSuffixPattern(ElementSelector p) {\n        return (p.size() > 1) && p.get(0).equals(KLEENE_STAR);\n    }\n\n    Action prefixMatch(ElementPath elementPath) {\n        int max = 0;\n        ElementSelector longestMatchingElementSelector = null;\n\n        for (ElementSelector selector : rules.keySet()) {\n            String last = selector.peekLast();\n            if (isKleeneStar(last)) {\n                int r = selector.getPrefixMatchLength(elementPath);\n                // to qualify the match length must equal p's size omitting the '*'\n                if ((r == selector.size() - 1) && (r > max)) {\n                    max = r;\n                    longestMatchingElementSelector = selector;\n                }\n            }\n        }\n\n        if (longestMatchingElementSelector != null) {\n            return rules.get(longestMatchingElementSelector);\n        } else {\n            return null;\n        }\n    }\n\n    private boolean isKleeneStar(String last) {\n        return KLEENE_STAR.equals(last);\n    }\n\n    Action middleMatch(ElementPath path) {\n\n        int max = 0;\n        ElementSelector longestMatchingElementSelector = null;\n\n        for (ElementSelector selector : rules.keySet()) {\n            String last = selector.peekLast();\n            String first = null;\n            if (selector.size() > 1) {\n                first = selector.get(0);\n            }\n            if (isKleeneStar(last) && isKleeneStar(first)) {\n                List<String> copyOfPartList = selector.getCopyOfPartList();\n                if (copyOfPartList.size() > 2) {\n                    copyOfPartList.remove(0);\n                    copyOfPartList.remove(copyOfPartList.size() - 1);\n                }\n\n                int r = 0;\n                ElementSelector clone = new ElementSelector(copyOfPartList);\n                if (clone.isContainedIn(path)) {\n                    r = clone.size();\n                }\n                if (r > max) {\n                    max = r;\n                    longestMatchingElementSelector = selector;\n                }\n            }\n        }\n\n        if (longestMatchingElementSelector != null) {\n            return rules.get(longestMatchingElementSelector);\n        } else {\n            return null;\n        }\n    }\n\n    public String toString() {\n        final String TAB = \"  \";\n\n        StringBuilder retValue = new StringBuilder();\n\n        retValue.append(\"SimpleRuleStore ( \").append(\"rules = \").append(this.rules).append(TAB).append(\" )\");\n\n        return retValue.toString();\n    }\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.joran.spi;\n\nimport java.util.HashMap;\nimport java.util.List;\n\nimport ch.qos.logback.core.Context;\nimport ch.qos.logback.core.joran.action.Action;\nimport ch.qos.logback.core.spi.ContextAwareBase;\nimport ch.qos.logback.core.util.OptionHelper;\n\n/**\n * This class implements the {@link RuleStore} interface. It is the rule store\n * implementation used by default in Joran.\n * \n * @author Ceki G&uuml;lc&uuml;\n * \n */\npublic class SimpleRuleStore extends ContextAwareBase implements RuleStore {\n\n    static String KLEENE_STAR = \"*\";\n\n    // key: Pattern instance, value: ArrayList containing actions\n    HashMap<ElementSelector, Action> rules = new HashMap<>();\n\n    // public SimpleRuleStore() {\n    // }\n\n    public SimpleRuleStore(Context context) {\n        setContext(context);\n    }\n\n    /**\n     * Add a new rule, i.e. a pattern, action pair to the rule store.\n     * <p>\n     * Note that the added action's LoggerRepository will be set in the process.\n     */\n    public void addRule(ElementSelector elementSelector, Action action) {\n        action.setContext(context);\n\n        Action existing = rules.get(elementSelector);\n        \n        if (existing == null) {\n            rules.put(elementSelector, action);\n        } else {\n            throw new IllegalStateException(elementSelector.toString() + \" already has an associated action\");\n        }\n    }\n\n    public void addRule(ElementSelector elementSelector, String actionClassName) {\n        Action action = null;\n\n        try {\n            action = (Action) OptionHelper.instantiateByClassName(actionClassName, Action.class, context);\n        } catch (Exception e) {\n            addError(\"Could not instantiate class [\" + actionClassName + \"]\", e);\n        }\n        if (action != null) {\n            addRule(elementSelector, action);\n        }\n    }\n\n    // exact match has highest priority\n    // if no exact match, check for suffix (tail) match, i.e matches\n    // of type */x/y. Suffix match for */x/y has higher priority than match for\n    // */x\n    // if no suffix match, check for prefix match, i.e. matches for x/*\n    // match for x/y/* has higher priority than matches for x/*\n\n    public Action matchActions(ElementPath elementPath) {\n        Action action;\n\n        if ((action = fullPathMatch(elementPath)) != null) {\n            return action;\n        } else if ((action = suffixMatch(elementPath)) != null) {\n            return action;\n        } else if ((action = prefixMatch(elementPath)) != null) {\n            return action;\n        } else if ((action = middleMatch(elementPath)) != null) {\n            return action;\n        } else {\n            return null;\n        }\n    }\n\n    Action fullPathMatch(ElementPath elementPath) {\n        for (ElementSelector selector : rules.keySet()) {\n            if (selector.fullPathMatch(elementPath))\n                return rules.get(selector);\n        }\n        return null;\n    }\n\n    // Suffix matches are matches of type */x/y\n    Action suffixMatch(ElementPath elementPath) {\n        int max = 0;\n        ElementSelector longestMatchingElementSelector = null;\n\n        for (ElementSelector selector : rules.keySet()) {\n            if (isSuffixPattern(selector)) {\n                int r = selector.getTailMatchLength(elementPath);\n                if (r > max) {\n                    max = r;\n                    longestMatchingElementSelector = selector;\n                }\n            }\n        }\n\n        if (longestMatchingElementSelector != null) {\n            return rules.get(longestMatchingElementSelector);\n        } else {\n            return null;\n        }\n    }\n\n    private boolean isSuffixPattern(ElementSelector p) {\n        return (p.size() > 1) && p.get(0).equals(KLEENE_STAR);\n    }\n\n    Action prefixMatch(ElementPath elementPath) {\n        int max = 0;\n        ElementSelector longestMatchingElementSelector = null;\n\n        for (ElementSelector selector : rules.keySet()) {\n            String last = selector.peekLast();\n            if (isKleeneStar(last)) {\n                int r = selector.getPrefixMatchLength(elementPath);\n                // to qualify the match length must equal p's size omitting the '*'\n                if ((r == selector.size() - 1) && (r > max)) {\n                    max = r;\n                    longestMatchingElementSelector = selector;\n                }\n            }\n        }\n\n        if (longestMatchingElementSelector != null) {\n            return rules.get(longestMatchingElementSelector);\n        } else {\n            return null;\n        }\n    }\n\n    private boolean isKleeneStar(String last) {\n        return KLEENE_STAR.equals(last);\n    }\n\n    Action middleMatch(ElementPath path) {\n\n        int max = 0;\n        ElementSelector longestMatchingElementSelector = null;\n\n        for (ElementSelector selector : rules.keySet()) {\n            String last = selector.peekLast();\n            String first = null;\n            if (selector.size() > 1) {\n                first = selector.get(0);\n            }\n            if (isKleeneStar(last) && isKleeneStar(first)) {\n                List<String> copyOfPartList = selector.getCopyOfPartList();\n                if (copyOfPartList.size() > 2) {\n                    copyOfPartList.remove(0);\n                    copyOfPartList.remove(copyOfPartList.size() - 1);\n                }\n\n                int r = 0;\n                ElementSelector clone = new ElementSelector(copyOfPartList);\n                if (clone.isContainedIn(path)) {\n                    r = clone.size();\n                }\n                if (r > max) {\n                    max = r;\n                    longestMatchingElementSelector = selector;\n                }\n            }\n        }\n\n        if (longestMatchingElementSelector != null) {\n            return rules.get(longestMatchingElementSelector);\n        } else {\n            return null;\n        }\n    }\n\n    public String toString() {\n        final String TAB = \"  \";\n\n        StringBuilder retValue = new StringBuilder();\n\n        retValue.append(\"SimpleRuleStore ( \").append(\"rules = \").append(this.rules).append(TAB).append(\" )\");\n\n        return retValue.toString();\n    }\n\n}\n","lineNo":87}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.joran.action;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.List;\n\nimport org.xml.sax.Attributes;\n\nimport ch.qos.logback.core.joran.event.SaxEvent;\nimport ch.qos.logback.core.joran.event.SaxEventRecorder;\nimport ch.qos.logback.core.joran.spi.ActionException;\nimport ch.qos.logback.core.joran.spi.JoranException;\nimport ch.qos.logback.core.joran.spi.SaxEventInterpretationContext;\nimport ch.qos.logback.core.joran.util.ConfigurationWatchListUtil;\nimport ch.qos.logback.core.model.IncludeModel;\nimport ch.qos.logback.core.model.Model;\nimport ch.qos.logback.core.util.Loader;\nimport ch.qos.logback.core.util.OptionHelper;\n\nimport static ch.qos.logback.core.joran.JoranConstants.INCLUDED_TAG;\n\n/**\n * \n * @author ceki\n *\n */\npublic class IncludeAction extends Action {\n\n    private static final String FILE_ATTR = \"file\";\n    private static final String URL_ATTR = \"url\";\n    private static final String RESOURCE_ATTR = \"resource\";\n    private static final String OPTIONAL_ATTR = \"optional\";\n\n    private String attributeInUse;\n    private boolean optional;\n\n    Model parentModel;\n    IncludeModel includeModel;\n    boolean inError = false;\n    \n    @Override\n    public void begin(SaxEventInterpretationContext ec, String name, Attributes attributes) throws ActionException {\n\n        parentModel = null;\n        includeModel = null;\n        \n        SaxEventRecorder recorder = new SaxEventRecorder(context);\n        \n        String optionalStr = attributes.getValue(OPTIONAL_ATTR);\n        \n        createModelForNonXMLUse(ec, name, attributes, optionalStr);\n        \n        \n        this.attributeInUse = null;\n        this.optional = OptionHelper.toBoolean(optionalStr, false);\n        \n        if (!checkAttributes(attributes)) {\n            inError = true;\n            return;\n        }\n\n        \n        InputStream in = getInputStream(ec, attributes);\n\n        try {\n            if (in != null) {\n                parseAndRecord(in, recorder);\n                // remove the <included> tag from the beginning and <\/included> from the end\n                trimHeadAndTail(recorder);\n\n                // offset = 2, because we need to get past this element as well as the end\n                // element\n                ec.getSaxEventInterpreter().getEventPlayer().addEventsDynamically(recorder.saxEventList, 2);\n            }\n        } catch (JoranException e) {\n            addError(\"Error while parsing  \" + attributeInUse, e);\n        } finally {\n            close(in);\n        }\n\n    }\n\n    private void createModelForNonXMLUse(SaxEventInterpretationContext seic, String name, Attributes attributes,\n            String optionalStr) {\n        this.includeModel = new IncludeModel();\n        this.includeModel.setOptional(optionalStr);\n        fillInIncludeModelAttributes(includeModel, name, attributes);\n        if (!seic.isModelStackEmpty()) {\n            parentModel = seic.peekModel();\n        }\n        final int lineNumber = getLineNumber(seic);\n        this.includeModel.setLineNumber(lineNumber);\n        seic.pushModel(includeModel);\n    }\n\n    private void fillInIncludeModelAttributes(IncludeModel includeModel, String name, Attributes attributes) {\n        this.includeModel.setTag(name);\n        String fileAttribute = attributes.getValue(FILE_ATTR);\n        String urlAttribute = attributes.getValue(URL_ATTR);\n        String resourceAttribute = attributes.getValue(RESOURCE_ATTR);\n        \n        this.includeModel.setFile(fileAttribute);\n        this.includeModel.setUrl(urlAttribute);\n        this.includeModel.setResource(resourceAttribute);\n        \n    }\n\n    void close(InputStream in) {\n        if (in != null) {\n            try {\n                in.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n\n    private boolean checkAttributes(Attributes attributes) {\n        String fileAttribute = attributes.getValue(FILE_ATTR);\n        String urlAttribute = attributes.getValue(URL_ATTR);\n        String resourceAttribute = attributes.getValue(RESOURCE_ATTR);\n\n        int count = 0;\n\n        if (!OptionHelper.isNullOrEmpty(fileAttribute)) {\n            count++;\n        }\n        if (!OptionHelper.isNullOrEmpty(urlAttribute)) {\n            count++;\n        }\n        if (!OptionHelper.isNullOrEmpty(resourceAttribute)) {\n            count++;\n        }\n\n        if (count == 0) {\n            addError(\"One of \\\"path\\\", \\\"resource\\\" or \\\"url\\\" attributes must be set.\");\n            return false;\n        } else if (count > 1) {\n            addError(\"Only one of \\\"file\\\", \\\"url\\\" or \\\"resource\\\" attributes should be set.\");\n            return false;\n        } else if (count == 1) {\n            return true;\n        }\n        throw new IllegalStateException(\"Count value [\" + count + \"] is not expected\");\n    }\n\n    URL attributeToURL(String urlAttribute) {\n        try {\n            return new URL(urlAttribute);\n        } catch (MalformedURLException mue) {\n            String errMsg = \"URL [\" + urlAttribute + \"] is not well formed.\";\n            addError(errMsg, mue);\n            return null;\n        }\n    }\n\n    InputStream openURL(URL url) {\n        try {\n            return url.openStream();\n        } catch (IOException e) {\n            optionalWarning(\"Failed to open [\" + url.toString() + \"]\");\n            return null;\n        }\n    }\n\n    URL resourceAsURL(String resourceAttribute) {\n        URL url = Loader.getResourceBySelfClassLoader(resourceAttribute);\n        if (url == null) {\n            optionalWarning(\"Could not find resource corresponding to [\" + resourceAttribute + \"]\");\n            return null;\n        } else\n            return url;\n    }\n\n    private void optionalWarning(String msg) {\n        if (!optional) {\n            addWarn(msg);\n        }\n    }\n\n    URL filePathAsURL(String path) {\n        URI uri = new File(path).toURI();\n        try {\n            return uri.toURL();\n        } catch (MalformedURLException e) {\n            // impossible to get here\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    URL getInputURL(SaxEventInterpretationContext ec, Attributes attributes) {\n        String fileAttribute = attributes.getValue(FILE_ATTR);\n        String urlAttribute = attributes.getValue(URL_ATTR);\n        String resourceAttribute = attributes.getValue(RESOURCE_ATTR);\n\n        if (!OptionHelper.isNullOrEmpty(fileAttribute)) {\n            this.attributeInUse = ec.subst(fileAttribute);\n            return filePathAsURL(attributeInUse);\n        }\n\n        if (!OptionHelper.isNullOrEmpty(urlAttribute)) {\n            this.attributeInUse = ec.subst(urlAttribute);\n            return attributeToURL(attributeInUse);\n        }\n\n        if (!OptionHelper.isNullOrEmpty(resourceAttribute)) {\n            this.attributeInUse = ec.subst(resourceAttribute);\n            return resourceAsURL(attributeInUse);\n        }\n        // given previous checkAttributes() check we cannot reach this line\n        throw new IllegalStateException(\"A URL stream should have been returned\");\n\n    }\n\n    InputStream getInputStream(SaxEventInterpretationContext ec, Attributes attributes) {\n        URL inputURL = getInputURL(ec, attributes);\n        if (inputURL == null)\n            return null;\n\n        ConfigurationWatchListUtil.addToWatchList(context, inputURL);\n        return openURL(inputURL);\n    }\n\n    private void trimHeadAndTail(SaxEventRecorder recorder) {\n        // Let's remove the two <included> events before\n        // adding the events to the player.\n\n        List<SaxEvent> saxEventList = recorder.saxEventList;\n\n        if (saxEventList.size() == 0) {\n            return;\n        }\n\n        SaxEvent first = saxEventList.get(0);\n        if (first != null && first.qName.equalsIgnoreCase(INCLUDED_TAG)) {\n            saxEventList.remove(0);\n        }\n\n        SaxEvent last = saxEventList.get(recorder.saxEventList.size() - 1);\n        if (last != null && last.qName.equalsIgnoreCase(INCLUDED_TAG)) {\n            saxEventList.remove(recorder.saxEventList.size() - 1);\n        }\n    }\n\n    private void parseAndRecord(InputStream inputSource, SaxEventRecorder recorder) throws JoranException {\n        recorder.setContext(context);\n        recorder.recordEvents(inputSource);\n    }\n\n    @Override\n    public void end(SaxEventInterpretationContext seic, String name) throws ActionException {\n        \n        if(inError)\n            return;\n        \n        Model m = seic.peekModel();\n\n        if (m != includeModel) {\n            addWarn(\"The object at the of the stack is not the model [\" + includeModel.idString()\n                    + \"] pushed earlier.\");\n            addWarn(\"This is wholly unexpected.\");\n        }\n\n        // do not pop nor add to parent if there is no parent\n        if (parentModel != null) {\n            parentModel.addSubModel(includeModel);\n            seic.popModel();\n        }\n    }\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.joran.action;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.List;\n\nimport org.xml.sax.Attributes;\n\nimport ch.qos.logback.core.joran.event.SaxEvent;\nimport ch.qos.logback.core.joran.event.SaxEventRecorder;\nimport ch.qos.logback.core.joran.spi.ActionException;\nimport ch.qos.logback.core.joran.spi.JoranException;\nimport ch.qos.logback.core.joran.spi.SaxEventInterpretationContext;\nimport ch.qos.logback.core.joran.util.ConfigurationWatchListUtil;\nimport ch.qos.logback.core.util.Loader;\nimport ch.qos.logback.core.util.OptionHelper;\n\nimport static ch.qos.logback.core.joran.JoranConstants.INCLUDED_TAG;\n\n/**\n * \n * @author ceki\n *\n */\npublic class IncludeAction extends Action {\n\n    private static final String FILE_ATTR = \"file\";\n    private static final String URL_ATTR = \"url\";\n    private static final String RESOURCE_ATTR = \"resource\";\n    private static final String OPTIONAL_ATTR = \"optional\";\n\n    private String attributeInUse;\n    private boolean optional;\n\n    @Override\n    public void begin(SaxEventInterpretationContext ec, String name, Attributes attributes) throws ActionException {\n\n        SaxEventRecorder recorder = new SaxEventRecorder(context);\n\n        this.attributeInUse = null;\n        this.optional = OptionHelper.toBoolean(attributes.getValue(OPTIONAL_ATTR), false);\n\n        if (!checkAttributes(attributes)) {\n            return;\n        }\n\n        InputStream in = getInputStream(ec, attributes);\n\n        try {\n            if (in != null) {\n                parseAndRecord(in, recorder);\n                // remove the <included> tag from the beginning and <\/included> from the end\n                trimHeadAndTail(recorder);\n\n                // offset = 2, because we need to get past this element as well as the end\n                // element\n                ec.getSaxEventInterpreter().getEventPlayer().addEventsDynamically(recorder.saxEventList, 2);\n            }\n        } catch (JoranException e) {\n            addError(\"Error while parsing  \" + attributeInUse, e);\n        } finally {\n            close(in);\n        }\n\n    }\n\n    void close(InputStream in) {\n        if (in != null) {\n            try {\n                in.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n\n    private boolean checkAttributes(Attributes attributes) {\n        String fileAttribute = attributes.getValue(FILE_ATTR);\n        String urlAttribute = attributes.getValue(URL_ATTR);\n        String resourceAttribute = attributes.getValue(RESOURCE_ATTR);\n\n        int count = 0;\n\n        if (!OptionHelper.isNullOrEmpty(fileAttribute)) {\n            count++;\n        }\n        if (!OptionHelper.isNullOrEmpty(urlAttribute)) {\n            count++;\n        }\n        if (!OptionHelper.isNullOrEmpty(resourceAttribute)) {\n            count++;\n        }\n\n        if (count == 0) {\n            addError(\"One of \\\"path\\\", \\\"resource\\\" or \\\"url\\\" attributes must be set.\");\n            return false;\n        } else if (count > 1) {\n            addError(\"Only one of \\\"file\\\", \\\"url\\\" or \\\"resource\\\" attributes should be set.\");\n            return false;\n        } else if (count == 1) {\n            return true;\n        }\n        throw new IllegalStateException(\"Count value [\" + count + \"] is not expected\");\n    }\n\n    URL attributeToURL(String urlAttribute) {\n        try {\n            return new URL(urlAttribute);\n        } catch (MalformedURLException mue) {\n            String errMsg = \"URL [\" + urlAttribute + \"] is not well formed.\";\n            addError(errMsg, mue);\n            return null;\n        }\n    }\n\n    InputStream openURL(URL url) {\n        try {\n            return url.openStream();\n        } catch (IOException e) {\n            optionalWarning(\"Failed to open [\" + url.toString() + \"]\");\n            return null;\n        }\n    }\n\n    URL resourceAsURL(String resourceAttribute) {\n        URL url = Loader.getResourceBySelfClassLoader(resourceAttribute);\n        if (url == null) {\n            optionalWarning(\"Could not find resource corresponding to [\" + resourceAttribute + \"]\");\n            return null;\n        } else\n            return url;\n    }\n\n    private void optionalWarning(String msg) {\n        if (!optional) {\n            addWarn(msg);\n        }\n    }\n\n    URL filePathAsURL(String path) {\n        URI uri = new File(path).toURI();\n        try {\n            return uri.toURL();\n        } catch (MalformedURLException e) {\n            // impossible to get here\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    URL getInputURL(SaxEventInterpretationContext ec, Attributes attributes) {\n        String fileAttribute = attributes.getValue(FILE_ATTR);\n        String urlAttribute = attributes.getValue(URL_ATTR);\n        String resourceAttribute = attributes.getValue(RESOURCE_ATTR);\n\n        if (!OptionHelper.isNullOrEmpty(fileAttribute)) {\n            this.attributeInUse = ec.subst(fileAttribute);\n            return filePathAsURL(attributeInUse);\n        }\n\n        if (!OptionHelper.isNullOrEmpty(urlAttribute)) {\n            this.attributeInUse = ec.subst(urlAttribute);\n            return attributeToURL(attributeInUse);\n        }\n\n        if (!OptionHelper.isNullOrEmpty(resourceAttribute)) {\n            this.attributeInUse = ec.subst(resourceAttribute);\n            return resourceAsURL(attributeInUse);\n        }\n        // given previous checkAttributes() check we cannot reach this line\n        throw new IllegalStateException(\"A URL stream should have been returned\");\n\n    }\n\n    InputStream getInputStream(SaxEventInterpretationContext ec, Attributes attributes) {\n        URL inputURL = getInputURL(ec, attributes);\n        if (inputURL == null)\n            return null;\n\n        ConfigurationWatchListUtil.addToWatchList(context, inputURL);\n        return openURL(inputURL);\n    }\n\n    private void trimHeadAndTail(SaxEventRecorder recorder) {\n        // Let's remove the two <included> events before\n        // adding the events to the player.\n\n        List<SaxEvent> saxEventList = recorder.saxEventList;\n\n        if (saxEventList.size() == 0) {\n            return;\n        }\n\n        SaxEvent first = saxEventList.get(0);\n        if (first != null && first.qName.equalsIgnoreCase(INCLUDED_TAG)) {\n            saxEventList.remove(0);\n        }\n\n        SaxEvent last = saxEventList.get(recorder.saxEventList.size() - 1);\n        if (last != null && last.qName.equalsIgnoreCase(INCLUDED_TAG)) {\n            saxEventList.remove(recorder.saxEventList.size() - 1);\n        }\n    }\n\n    private void parseAndRecord(InputStream inputSource, SaxEventRecorder recorder) throws JoranException {\n        recorder.setContext(context);\n        recorder.recordEvents(inputSource);\n    }\n\n    @Override\n    public void end(SaxEventInterpretationContext ec, String name) throws ActionException {\n        // do nothing\n    }\n}\n","lineNo":66}
{"Refactored Sample":"package ch.qos.logback.core.model.processor;\n\nimport java.util.Stack;\n\nimport ch.qos.logback.core.Context;\nimport ch.qos.logback.core.joran.action.ImcplicitActionDataForBasicProperty;\nimport ch.qos.logback.core.joran.action.ImplicitActionDataBase;\nimport ch.qos.logback.core.joran.action.ImplicitActionDataForComplexProperty;\nimport ch.qos.logback.core.joran.spi.NoAutoStartUtil;\nimport ch.qos.logback.core.joran.util.PropertySetter;\nimport ch.qos.logback.core.joran.util.beans.BeanDescriptionCache;\nimport ch.qos.logback.core.model.ComponentModel;\nimport ch.qos.logback.core.model.ImplicitModel;\nimport ch.qos.logback.core.model.Model;\nimport ch.qos.logback.core.spi.ContextAware;\nimport ch.qos.logback.core.spi.LifeCycle;\nimport ch.qos.logback.core.util.AggregationType;\nimport ch.qos.logback.core.util.Loader;\nimport ch.qos.logback.core.util.OptionHelper;\n\npublic class ImplicitModelHandler extends ModelHandlerBase {\n\n\tprivate final BeanDescriptionCache beanDescriptionCache;\n\n\tstatic final String  PARENT_PROPPERTY_KEY = \"parent\";\n\t\n\t\n\tboolean inError = false;\n\n\tpublic ImplicitModelHandler(Context context, BeanDescriptionCache beanDescriptionCache) {\n\t\tsuper(context);\n\t\tthis.beanDescriptionCache = beanDescriptionCache;\n\t}\n\n\tprotected Class<? extends ImplicitModel> getSupportedModelClass() {\n\t\treturn ImplicitModel.class;\n\t}\n\n\tstatic public ImplicitModelHandler makeInstance(Context context, ModelInterpretationContext ic) {\n\t\tBeanDescriptionCache beanDescriptionCache  = ic.getBeanDescriptionCache();\n\t\treturn new ImplicitModelHandler(context, beanDescriptionCache);\n\t}\n\t\n\t@Override\n\tpublic void handle(ModelInterpretationContext intercon, Model model) {\n\n\t\tImplicitModel implicitModel = (ImplicitModel) model;\n\n\t\t// calling intercon.peekObject with an empty stack will throw an exception\n\t\tif (intercon.isObjectStackEmpty()) {\n\t\t\tinError = true;\n\t\t\treturn;\n\t\t}\n\t\tString nestedElementTagName = implicitModel.getTag();\n\n\t\tObject o = intercon.peekObject();\n\t\tPropertySetter parentBean = new PropertySetter(beanDescriptionCache, o);\n\t\tparentBean.setContext(context);\n\n\t\tAggregationType aggregationType = parentBean.computeAggregationType(nestedElementTagName);\n\n\t\tStack<ImplicitActionDataBase> actionDataStack = intercon.getImplcitActionDataStack();\n\n\t\tswitch (aggregationType) {\n\t\tcase NOT_FOUND:\n\t\t\taddWarn(\"Ignoring unkown property [\"+nestedElementTagName+\"] in [\"+o.getClass().getName()+\"]\");\n\t\t\tinError = true;\n\t\t\treturn;\n\t\tcase AS_BASIC_PROPERTY:\n\t\tcase AS_BASIC_PROPERTY_COLLECTION:\n\t\t\tImcplicitActionDataForBasicProperty adBasicProperty = new ImcplicitActionDataForBasicProperty(parentBean,\n\t\t\t\t\taggregationType, nestedElementTagName);\n\t\t\tactionDataStack.push(adBasicProperty);\n\t\t\tdoBasicProperty(intercon, model, adBasicProperty);\n\t\t\treturn;\n\t\t// we only push action data if NestComponentIA is applicable\n\t\tcase AS_COMPLEX_PROPERTY_COLLECTION:\n\t\tcase AS_COMPLEX_PROPERTY:\n\t\t\tImplicitActionDataForComplexProperty adComplex = new ImplicitActionDataForComplexProperty(parentBean,\n\t\t\t\t\taggregationType, nestedElementTagName);\n\t\t\tactionDataStack.push(adComplex);\n\t\t\tdoComplex(intercon, implicitModel, adComplex);\n\t\t\treturn;\n\t\tdefault:\n\t\t\taddError(\"PropertySetter.computeAggregationType returned \" + aggregationType);\n\t\t\treturn;\n\t\t}\n\n\t}\n\n\tvoid doBasicProperty(ModelInterpretationContext interpretationContext, Model model,\n\t\t\tImcplicitActionDataForBasicProperty actionData) {\n\t\tString finalBody = interpretationContext.subst(model.getBodyText());\n\t\t// get the action data object pushed in isApplicable() method call\n\t\t// IADataForBasicProperty actionData = (IADataForBasicProperty)\n\t\t// actionDataStack.peek();\n\t\tswitch (actionData.aggregationType) {\n\t\tcase AS_BASIC_PROPERTY:\n\t\t\tactionData.parentBean.setProperty(actionData.propertyName, finalBody);\n\t\t\tbreak;\n\t\tcase AS_BASIC_PROPERTY_COLLECTION:\n\t\t\tactionData.parentBean.addBasicProperty(actionData.propertyName, finalBody);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\taddError(\"Unexpected aggregationType \" + actionData.aggregationType);\n\t\t}\n\t}\n\n\tpublic void doComplex(ModelInterpretationContext interpretationContext, ComponentModel componentModel,\n\t\t\tImplicitActionDataForComplexProperty actionData) {\n\n\t\tString className = componentModel.getClassName();\n\t\t// perform variable name substitution\n\t\tString substClassName = interpretationContext.subst(className);\n\t\t\n\t\tString fqcn = interpretationContext.getImport(substClassName);\n\t\t\n\t\t\n\t\tClass<?> componentClass = null;\n\t\ttry {\n\n\t\t\tif (!OptionHelper.isNullOrEmpty(fqcn)) {\n\t\t\t\tcomponentClass = Loader.loadClass(fqcn, context);\n\t\t\t} else {\n\t\t\t\t// guess class name via implicit rules\n\t\t\t\tPropertySetter parentBean = actionData.parentBean;\n\t\t\t\tcomponentClass = parentBean.getClassNameViaImplicitRules(actionData.propertyName,\n\t\t\t\t\t\tactionData.getAggregationType(), interpretationContext.getDefaultNestedComponentRegistry());\n\t\t\t}\n\n\t\t\tif (componentClass == null) {\n\t\t\t\tactionData.inError = true;\n\t\t\t\tString errMsg = \"Could not find an appropriate class for property [\" + componentModel.getTag() + \"]\";\n\t\t\t\taddError(errMsg);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (OptionHelper.isNullOrEmpty(fqcn)) {\n\t\t\t\taddInfo(\"Assuming default type [\" + componentClass.getName() + \"] for [\" + componentModel.getTag()\n\t\t\t\t\t\t+ \"] property\");\n\t\t\t}\n\n\t\t\tactionData.setNestedComplexProperty(componentClass.getConstructor().newInstance());\n\n\t\t\t// pass along the repository\n\t\t\tif (actionData.getNestedComplexProperty() instanceof ContextAware) {\n\t\t\t\t((ContextAware) actionData.getNestedComplexProperty()).setContext(this.context);\n\t\t\t}\n\t\t\t// addInfo(\"Pushing component [\" + localName\n\t\t\t// + \"] on top of the object stack.\");\n\t\t\tinterpretationContext.pushObject(actionData.getNestedComplexProperty());\n\n\t\t} catch (Exception oops) {\n\t\t\tactionData.inError = true;\n\t\t\tString msg = \"Could not create component [\" + componentModel.getTag() + \"] of type [\" + fqcn + \"]\";\n\t\t\taddError(msg, oops);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void postHandle(ModelInterpretationContext intercon, Model model) {\n\t\tif (inError) {\n\t\t\treturn;\n\t\t}\n\n\t\tStack<ImplicitActionDataBase> actionDataStack = intercon.getImplcitActionDataStack();\n\t\tImplicitActionDataBase actionData = actionDataStack.pop();\n\n\t\tif (actionData instanceof ImplicitActionDataForComplexProperty) {\n\t\t\tpostHandleComplex(intercon, model, actionData);\n\t\t}\n\n\t}\n\n\tprivate void postHandleComplex(ModelInterpretationContext intercon, Model model, ImplicitActionDataBase actionData) {\n\t\tImplicitActionDataForComplexProperty complexActionData = (ImplicitActionDataForComplexProperty) actionData;\n\n\t\tPropertySetter nestedBean = new PropertySetter(beanDescriptionCache,\n\t\t\t\tcomplexActionData.getNestedComplexProperty());\n\t\tnestedBean.setContext(context);\n\n\t\t// have the nested element point to its parent if possible\n\t\tif (nestedBean.computeAggregationType(PARENT_PROPPERTY_KEY) == AggregationType.AS_COMPLEX_PROPERTY) {\n\t\t\tnestedBean.setComplexProperty(PARENT_PROPPERTY_KEY, actionData.parentBean.getObj());\n\t\t}\n\n\t\t// start the nested complex property if it implements LifeCycle and is not\n\t\t// marked with a @NoAutoStart annotation\n\t\tObject nestedComplexProperty = complexActionData.getNestedComplexProperty();\n\t\tif (nestedComplexProperty instanceof LifeCycle\n\t\t\t\t&& NoAutoStartUtil.notMarkedWithNoAutoStart(nestedComplexProperty)) {\n\t\t\t((LifeCycle) nestedComplexProperty).start();\n\t\t}\n\n\t\tObject o = intercon.peekObject();\n\n\t\tif (o != complexActionData.getNestedComplexProperty()) {\n\t\t\taddError(\"The object on the top the of the stack is not the component pushed earlier.\");\n\t\t} else {\n\t\t\tintercon.popObject();\n\t\t\t// Now let us attach the component\n\t\t\tswitch (actionData.aggregationType) {\n\t\t\tcase AS_COMPLEX_PROPERTY:\n\t\t\t\tactionData.parentBean.setComplexProperty(model.getTag(), complexActionData.getNestedComplexProperty());\n\n\t\t\t\tbreak;\n\t\t\tcase AS_COMPLEX_PROPERTY_COLLECTION:\n\t\t\t\tactionData.parentBean.addComplexProperty(model.getTag(), complexActionData.getNestedComplexProperty());\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\taddError(\"Unexpected aggregationType \" + actionData.aggregationType);\n\t\t\t}\n\t\t}\n\t}\n\n}\n","Smelly Sample":"package ch.qos.logback.core.model.processor;\n\nimport java.util.Stack;\n\nimport ch.qos.logback.core.Context;\nimport ch.qos.logback.core.joran.action.ImcplicitActionDataForBasicProperty;\nimport ch.qos.logback.core.joran.action.ImplicitActionDataBase;\nimport ch.qos.logback.core.joran.action.ImplicitActionDataForComplexProperty;\nimport ch.qos.logback.core.joran.spi.InterpretationContext;\nimport ch.qos.logback.core.joran.spi.NoAutoStartUtil;\nimport ch.qos.logback.core.joran.util.PropertySetter;\nimport ch.qos.logback.core.joran.util.beans.BeanDescriptionCache;\nimport ch.qos.logback.core.model.ComponentModel;\nimport ch.qos.logback.core.model.ImplicitModel;\nimport ch.qos.logback.core.model.Model;\nimport ch.qos.logback.core.spi.ContextAware;\nimport ch.qos.logback.core.spi.LifeCycle;\nimport ch.qos.logback.core.util.AggregationType;\nimport ch.qos.logback.core.util.Loader;\nimport ch.qos.logback.core.util.OptionHelper;\n\npublic class ImplicitModelHandler extends ModelHandlerBase {\n\n\tprivate final BeanDescriptionCache beanDescriptionCache;\n\n\tstatic final String  PARENT_PROPPERTY_KEY = \"parent\";\n\t\n\t\n\tboolean inError = false;\n\n\tpublic ImplicitModelHandler(Context context, BeanDescriptionCache beanDescriptionCache) {\n\t\tsuper(context);\n\t\tthis.beanDescriptionCache = beanDescriptionCache;\n\t}\n\n\tprotected Class<? extends ImplicitModel> getSupportedModelClass() {\n\t\treturn ImplicitModel.class;\n\t}\n\n\tstatic public ImplicitModelHandler makeInstance(Context context, InterpretationContext ic) {\n\t\treturn new ImplicitModelHandler(context, ic.getBeanDescriptionCache());\n\t}\n\t\n\t@Override\n\tpublic void handle(InterpretationContext intercon, Model model) {\n\n\t\tImplicitModel implicitModel = (ImplicitModel) model;\n\n\t\t// calling intercon.peekObject with an empty stack will throw an exception\n\t\tif (intercon.isObjectStackEmpty()) {\n\t\t\tinError = true;\n\t\t\treturn;\n\t\t}\n\t\tString nestedElementTagName = implicitModel.getTag();\n\n\t\tObject o = intercon.peekObject();\n\t\tPropertySetter parentBean = new PropertySetter(beanDescriptionCache, o);\n\t\tparentBean.setContext(context);\n\n\t\tAggregationType aggregationType = parentBean.computeAggregationType(nestedElementTagName);\n\n\t\tStack<ImplicitActionDataBase> actionDataStack = intercon.getImplcitActionDataStack();\n\n\t\tswitch (aggregationType) {\n\t\tcase NOT_FOUND:\n\t\t\taddWarn(\"Ignoring unkown property [\"+nestedElementTagName+\"] in [\"+o.getClass().getName()+\"]\");\n\t\t\tinError = true;\n\t\t\treturn;\n\t\tcase AS_BASIC_PROPERTY:\n\t\tcase AS_BASIC_PROPERTY_COLLECTION:\n\t\t\tImcplicitActionDataForBasicProperty adBasicProperty = new ImcplicitActionDataForBasicProperty(parentBean,\n\t\t\t\t\taggregationType, nestedElementTagName);\n\t\t\tactionDataStack.push(adBasicProperty);\n\t\t\tdoBasicProperty(intercon, model, adBasicProperty);\n\t\t\treturn;\n\t\t// we only push action data if NestComponentIA is applicable\n\t\tcase AS_COMPLEX_PROPERTY_COLLECTION:\n\t\tcase AS_COMPLEX_PROPERTY:\n\t\t\tImplicitActionDataForComplexProperty adComplex = new ImplicitActionDataForComplexProperty(parentBean,\n\t\t\t\t\taggregationType, nestedElementTagName);\n\t\t\tactionDataStack.push(adComplex);\n\t\t\tdoComplex(intercon, implicitModel, adComplex);\n\t\t\treturn;\n\t\tdefault:\n\t\t\taddError(\"PropertySetter.computeAggregationType returned \" + aggregationType);\n\t\t\treturn;\n\t\t}\n\n\t}\n\n\tvoid doBasicProperty(InterpretationContext interpretationContext, Model model,\n\t\t\tImcplicitActionDataForBasicProperty actionData) {\n\t\tString finalBody = interpretationContext.subst(model.getBodyText());\n\t\t// get the action data object pushed in isApplicable() method call\n\t\t// IADataForBasicProperty actionData = (IADataForBasicProperty)\n\t\t// actionDataStack.peek();\n\t\tswitch (actionData.aggregationType) {\n\t\tcase AS_BASIC_PROPERTY:\n\t\t\tactionData.parentBean.setProperty(actionData.propertyName, finalBody);\n\t\t\tbreak;\n\t\tcase AS_BASIC_PROPERTY_COLLECTION:\n\t\t\tactionData.parentBean.addBasicProperty(actionData.propertyName, finalBody);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\taddError(\"Unexpected aggregationType \" + actionData.aggregationType);\n\t\t}\n\t}\n\n\tpublic void doComplex(InterpretationContext interpretationContext, ComponentModel componentModel,\n\t\t\tImplicitActionDataForComplexProperty actionData) {\n\n\t\tString className = componentModel.getClassName();\n\t\t// perform variable name substitution\n\t\tString substClassName = interpretationContext.subst(className);\n\t\t\n\t\tString fqcn = interpretationContext.getImport(substClassName);\n\t\t\n\t\t\n\t\tClass<?> componentClass = null;\n\t\ttry {\n\n\t\t\tif (!OptionHelper.isNullOrEmpty(fqcn)) {\n\t\t\t\tcomponentClass = Loader.loadClass(fqcn, context);\n\t\t\t} else {\n\t\t\t\t// guess class name via implicit rules\n\t\t\t\tPropertySetter parentBean = actionData.parentBean;\n\t\t\t\tcomponentClass = parentBean.getClassNameViaImplicitRules(actionData.propertyName,\n\t\t\t\t\t\tactionData.getAggregationType(), interpretationContext.getDefaultNestedComponentRegistry());\n\t\t\t}\n\n\t\t\tif (componentClass == null) {\n\t\t\t\tactionData.inError = true;\n\t\t\t\tString errMsg = \"Could not find an appropriate class for property [\" + componentModel.getTag() + \"]\";\n\t\t\t\taddError(errMsg);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (OptionHelper.isNullOrEmpty(fqcn)) {\n\t\t\t\taddInfo(\"Assuming default type [\" + componentClass.getName() + \"] for [\" + componentModel.getTag()\n\t\t\t\t\t\t+ \"] property\");\n\t\t\t}\n\n\t\t\tactionData.setNestedComplexProperty(componentClass.getConstructor().newInstance());\n\n\t\t\t// pass along the repository\n\t\t\tif (actionData.getNestedComplexProperty() instanceof ContextAware) {\n\t\t\t\t((ContextAware) actionData.getNestedComplexProperty()).setContext(this.context);\n\t\t\t}\n\t\t\t// addInfo(\"Pushing component [\" + localName\n\t\t\t// + \"] on top of the object stack.\");\n\t\t\tinterpretationContext.pushObject(actionData.getNestedComplexProperty());\n\n\t\t} catch (Exception oops) {\n\t\t\tactionData.inError = true;\n\t\t\tString msg = \"Could not create component [\" + componentModel.getTag() + \"] of type [\" + fqcn + \"]\";\n\t\t\taddError(msg, oops);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void postHandle(InterpretationContext intercon, Model model) {\n\t\tif (inError) {\n\t\t\treturn;\n\t\t}\n\n\t\tStack<ImplicitActionDataBase> actionDataStack = intercon.getImplcitActionDataStack();\n\t\tImplicitActionDataBase actionData = actionDataStack.pop();\n\n\t\tif (actionData instanceof ImplicitActionDataForComplexProperty) {\n\t\t\tpostHandleComplex(intercon, model, actionData);\n\t\t}\n\n\t}\n\n\tprivate void postHandleComplex(InterpretationContext intercon, Model model, ImplicitActionDataBase actionData) {\n\t\tImplicitActionDataForComplexProperty complexActionData = (ImplicitActionDataForComplexProperty) actionData;\n\n\t\tPropertySetter nestedBean = new PropertySetter(beanDescriptionCache,\n\t\t\t\tcomplexActionData.getNestedComplexProperty());\n\t\tnestedBean.setContext(context);\n\n\t\t// have the nested element point to its parent if possible\n\t\tif (nestedBean.computeAggregationType(PARENT_PROPPERTY_KEY) == AggregationType.AS_COMPLEX_PROPERTY) {\n\t\t\tnestedBean.setComplexProperty(PARENT_PROPPERTY_KEY, actionData.parentBean.getObj());\n\t\t}\n\n\t\t// start the nested complex property if it implements LifeCycle and is not\n\t\t// marked with a @NoAutoStart annotation\n\t\tObject nestedComplexProperty = complexActionData.getNestedComplexProperty();\n\t\tif (nestedComplexProperty instanceof LifeCycle\n\t\t\t\t&& NoAutoStartUtil.notMarkedWithNoAutoStart(nestedComplexProperty)) {\n\t\t\t((LifeCycle) nestedComplexProperty).start();\n\t\t}\n\n\t\tObject o = intercon.peekObject();\n\n\t\tif (o != complexActionData.getNestedComplexProperty()) {\n\t\t\taddError(\"The object on the top the of the stack is not the component pushed earlier.\");\n\t\t} else {\n\t\t\tintercon.popObject();\n\t\t\t// Now let us attach the component\n\t\t\tswitch (actionData.aggregationType) {\n\t\t\tcase AS_COMPLEX_PROPERTY:\n\t\t\t\tactionData.parentBean.setComplexProperty(model.getTag(), complexActionData.getNestedComplexProperty());\n\n\t\t\t\tbreak;\n\t\t\tcase AS_COMPLEX_PROPERTY_COLLECTION:\n\t\t\t\tactionData.parentBean.addComplexProperty(model.getTag(), complexActionData.getNestedComplexProperty());\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\taddError(\"Unexpected aggregationType \" + actionData.aggregationType);\n\t\t\t}\n\t\t}\n\t}\n\n}\n","lineNo":40}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.pattern;\n\nimport static ch.qos.logback.core.CoreConstants.DOT;\n\npublic class TargetLengthBasedClassNameAbbreviator implements Abbreviator {\n\n\tfinal int targetLength;\n\n\tpublic TargetLengthBasedClassNameAbbreviator(int targetLength) {\n\t\tthis.targetLength = targetLength;\n\t}\n\n\tenum ScanState {\n\t\tINITIAL, A_DOT, A_CHAR\n\t};\n\n\tpublic String abbreviate(String fqClassName) {\n\t\tif (fqClassName == null) {\n\t\t\tthrow new IllegalArgumentException(\"Class name may not be null\");\n\t\t}\n\n\t\tint inLen = fqClassName.length();\n\t\tif (inLen < targetLength) {\n\t\t\treturn fqClassName;\n\t\t}\n\n\t\tStringBuilder buf = new StringBuilder(inLen);\n\n\t\tint rightMostDotIndex = fqClassName.lastIndexOf(DOT);\n\n\t\tif (rightMostDotIndex == -1)\n\t\t\treturn fqClassName;\n\n\t\t// length of last segment including the dot\n\t\tint lastSegmentLength = inLen - rightMostDotIndex;\n\n\t\tint leftSegments_TargetLen = targetLength - lastSegmentLength;\n\t\tif (leftSegments_TargetLen < 0)\n\t\t\tleftSegments_TargetLen = 0;\n\t\t\n\t\tint leftSegmentsLen = inLen - lastSegmentLength;\n\n\t\tint maxPossibleTrim = leftSegmentsLen - leftSegments_TargetLen;\n\n\t\tint trimmed = 0;\n\t\tScanState scanState = ScanState.INITIAL;\n\n\t\tint i = 0;\n\t\tfor (; i < rightMostDotIndex; i++) {\n\t\t\tchar c = fqClassName.charAt(i);\n\t\t\tif (c == DOT) {\n\t\t\t\tif (trimmed >= maxPossibleTrim)\n\t\t\t\t\tbreak;\n\t\t\t\tbuf.append(c);\n\t\t\t\tscanState = ScanState.A_DOT;\n\t\t\t\t\n\n\t\t\t} else {\n\t\t\t\tswitch (scanState) {\n\t\t\t\tcase INITIAL:\n\t\t\t\tcase A_DOT:\n\t\t\t\t\tbuf.append(c);\n\t\t\t\t\tscanState = ScanState.A_CHAR;\n\t\t\t\t\tbreak;\n\t\t\t\tcase A_CHAR:\n\t\t\t\t\ttrimmed++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbuf.append(fqClassName.substring(i));\n\t\treturn buf.toString();\n\t}\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.pattern;\n\nimport ch.qos.logback.classic.ClassicConstants;\nimport ch.qos.logback.core.CoreConstants;\n\npublic class TargetLengthBasedClassNameAbbreviator implements Abbreviator {\n\n    final int targetLength;\n\n    public TargetLengthBasedClassNameAbbreviator(int targetLength) {\n        this.targetLength = targetLength;\n    }\n\n    public String abbreviate(String fqClassName) {\n        StringBuilder buf = new StringBuilder(targetLength);\n        if (fqClassName == null) {\n            throw new IllegalArgumentException(\"Class name may not be null\");\n        }\n\n        int inLen = fqClassName.length();\n        if (inLen < targetLength) {\n            return fqClassName;\n        }\n\n        int[] dotIndexesArray = new int[ClassicConstants.MAX_DOTS];\n        // a.b.c contains 2 dots but 2+1 parts.\n        // see also http://jira.qos.ch/browse/LOGBACK-437\n        int[] lengthArray = new int[ClassicConstants.MAX_DOTS + 1];\n\n        int dotCount = computeDotIndexes(fqClassName, dotIndexesArray);\n\n        // System.out.println();\n        // System.out.println(\"Dot count for [\" + className + \"] is \" + dotCount);\n        // if there are no dots than abbreviation is not possible\n        if (dotCount == 0) {\n            return fqClassName;\n        }\n        // printArray(\"dotArray: \", dotArray);\n        computeLengthArray(fqClassName, dotIndexesArray, lengthArray, dotCount);\n        //printArray(\"lengthArray: \", lengthArray);\n        for (int i = 0; i <= dotCount; i++) {\n            if (i == 0) {\n                buf.append(fqClassName.substring(0, lengthArray[i] - 1));\n            } else {\n                buf.append(fqClassName.substring(dotIndexesArray[i - 1], dotIndexesArray[i - 1] + lengthArray[i]));\n            }\n            // System.out.println(\"i=\" + i + \", buf=\" + buf);\n        }\n\n        return buf.toString();\n    }\n\n    /**\n     * Populate dotArray with the positions of the DOT character in className.\n     * Leftmost dot is placed at index 0 of dotArray.\n     * \n     * @param className\n     * @param dotArray\n     * @return the number of dots found\n     */\n    static int computeDotIndexes(final String className, int[] dotArray) {\n        int dotCount = 0;\n        int k = 0;\n        while (true) {\n            // ignore the $ separator in our computations. This is both convenient\n            // and sensible.\n            k = className.indexOf(CoreConstants.DOT, k);\n            if (k != -1 && dotCount < ClassicConstants.MAX_DOTS) {\n                dotArray[dotCount] = k;\n                dotCount++;\n                k++; // move past the last found DOT\n            } else {\n                break;\n            }\n        }\n        return dotCount;\n    }\n\n    void computeLengthArray(final String className, int[] dotArray, int[] lengthArray, int dotCount) {\n        int toTrim = className.length() - targetLength;\n        // System.out.println(\"toTrim=\" + toTrim);\n\n        int len;\n        for (int i = 0; i < dotCount; i++) {\n            int previousDotPosition = -1;\n            if (i > 0) {\n                previousDotPosition = dotArray[i - 1];\n            }\n            int available = dotArray[i] - previousDotPosition - 1;\n            // System.out.println(\"i=\" + i + \", available = \" + available);\n\n            len = (available < 1) ? available : 1;\n            // System.out.println(\"i=\" + i + \", toTrim = \" + toTrim);\n\n            if (toTrim > 0) {\n                len = (available < 1) ? available : 1;\n            } else {\n                len = available;\n            }\n            toTrim -= (available - len);\n            lengthArray[i] = len + 1;\n        }\n\n        int lastDotIndex = dotCount - 1;\n        lengthArray[dotCount] = className.length() - dotArray[lastDotIndex];\n    }\n\n    static void printArray(String msg, int[] ia) {\n        System.out.print(msg);\n        for (int i = 0; i < ia.length; i++) {\n            if (i == 0) {\n                System.out.print(ia[i]);\n            } else {\n                System.out.print(\", \" + ia[i]);\n            }\n        }\n        System.out.println();\n    }\n}\n","lineNo":63}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.pattern;\n\nimport static ch.qos.logback.core.CoreConstants.DOT;\n\npublic class TargetLengthBasedClassNameAbbreviator implements Abbreviator {\n\n\tfinal int targetLength;\n\n\tpublic TargetLengthBasedClassNameAbbreviator(int targetLength) {\n\t\tthis.targetLength = targetLength;\n\t}\n\n\tenum ScanState {\n\t\tINITIAL, A_DOT, A_CHAR\n\t};\n\n\tpublic String abbreviate(String fqClassName) {\n\t\tif (fqClassName == null) {\n\t\t\tthrow new IllegalArgumentException(\"Class name may not be null\");\n\t\t}\n\n\t\tint inLen = fqClassName.length();\n\t\tif (inLen < targetLength) {\n\t\t\treturn fqClassName;\n\t\t}\n\n\t\tStringBuilder buf = new StringBuilder(inLen);\n\n\t\tint rightMostDotIndex = fqClassName.lastIndexOf(DOT);\n\n\t\tif (rightMostDotIndex == -1)\n\t\t\treturn fqClassName;\n\n\t\t// length of last segment including the dot\n\t\tint lastSegmentLength = inLen - rightMostDotIndex;\n\n\t\tint leftSegments_TargetLen = targetLength - lastSegmentLength;\n\t\tif (leftSegments_TargetLen < 0)\n\t\t\tleftSegments_TargetLen = 0;\n\t\t\n\t\tint leftSegmentsLen = inLen - lastSegmentLength;\n\n\t\tint maxPossibleTrim = leftSegmentsLen - leftSegments_TargetLen;\n\n\t\tint trimmed = 0;\n\t\tScanState scanState = ScanState.INITIAL;\n\n\t\tint i = 0;\n\t\tfor (; i < rightMostDotIndex; i++) {\n\t\t\tchar c = fqClassName.charAt(i);\n\t\t\tif (c == DOT) {\n\t\t\t\tif (trimmed >= maxPossibleTrim)\n\t\t\t\t\tbreak;\n\t\t\t\tbuf.append(c);\n\t\t\t\tscanState = ScanState.A_DOT;\n\t\t\t\t\n\n\t\t\t} else {\n\t\t\t\tswitch (scanState) {\n\t\t\t\tcase INITIAL:\n\t\t\t\tcase A_DOT:\n\t\t\t\t\tbuf.append(c);\n\t\t\t\t\tscanState = ScanState.A_CHAR;\n\t\t\t\t\tbreak;\n\t\t\t\tcase A_CHAR:\n\t\t\t\t\ttrimmed++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbuf.append(fqClassName.substring(i));\n\t\treturn buf.toString();\n\t}\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.pattern;\n\nimport ch.qos.logback.classic.ClassicConstants;\nimport ch.qos.logback.core.CoreConstants;\n\npublic class TargetLengthBasedClassNameAbbreviator implements Abbreviator {\n\n    final int targetLength;\n\n    public TargetLengthBasedClassNameAbbreviator(int targetLength) {\n        this.targetLength = targetLength;\n    }\n\n    public String abbreviate(String fqClassName) {\n        StringBuilder buf = new StringBuilder(targetLength);\n        if (fqClassName == null) {\n            throw new IllegalArgumentException(\"Class name may not be null\");\n        }\n\n        int inLen = fqClassName.length();\n        if (inLen < targetLength) {\n            return fqClassName;\n        }\n\n        int[] dotIndexesArray = new int[ClassicConstants.MAX_DOTS];\n        // a.b.c contains 2 dots but 2+1 parts.\n        // see also http://jira.qos.ch/browse/LOGBACK-437\n        int[] lengthArray = new int[ClassicConstants.MAX_DOTS + 1];\n\n        int dotCount = computeDotIndexes(fqClassName, dotIndexesArray);\n\n        // System.out.println();\n        // System.out.println(\"Dot count for [\" + className + \"] is \" + dotCount);\n        // if there are no dots than abbreviation is not possible\n        if (dotCount == 0) {\n            return fqClassName;\n        }\n        // printArray(\"dotArray: \", dotArray);\n        computeLengthArray(fqClassName, dotIndexesArray, lengthArray, dotCount);\n        //printArray(\"lengthArray: \", lengthArray);\n        for (int i = 0; i <= dotCount; i++) {\n            if (i == 0) {\n                buf.append(fqClassName.substring(0, lengthArray[i] - 1));\n            } else {\n                buf.append(fqClassName.substring(dotIndexesArray[i - 1], dotIndexesArray[i - 1] + lengthArray[i]));\n            }\n            // System.out.println(\"i=\" + i + \", buf=\" + buf);\n        }\n\n        return buf.toString();\n    }\n\n    /**\n     * Populate dotArray with the positions of the DOT character in className.\n     * Leftmost dot is placed at index 0 of dotArray.\n     * \n     * @param className\n     * @param dotArray\n     * @return the number of dots found\n     */\n    static int computeDotIndexes(final String className, int[] dotArray) {\n        int dotCount = 0;\n        int k = 0;\n        while (true) {\n            // ignore the $ separator in our computations. This is both convenient\n            // and sensible.\n            k = className.indexOf(CoreConstants.DOT, k);\n            if (k != -1 && dotCount < ClassicConstants.MAX_DOTS) {\n                dotArray[dotCount] = k;\n                dotCount++;\n                k++; // move past the last found DOT\n            } else {\n                break;\n            }\n        }\n        return dotCount;\n    }\n\n    void computeLengthArray(final String className, int[] dotArray, int[] lengthArray, int dotCount) {\n        int toTrim = className.length() - targetLength;\n        // System.out.println(\"toTrim=\" + toTrim);\n\n        int len;\n        for (int i = 0; i < dotCount; i++) {\n            int previousDotPosition = -1;\n            if (i > 0) {\n                previousDotPosition = dotArray[i - 1];\n            }\n            int available = dotArray[i] - previousDotPosition - 1;\n            // System.out.println(\"i=\" + i + \", available = \" + available);\n\n            len = (available < 1) ? available : 1;\n            // System.out.println(\"i=\" + i + \", toTrim = \" + toTrim);\n\n            if (toTrim > 0) {\n                len = (available < 1) ? available : 1;\n            } else {\n                len = available;\n            }\n            toTrim -= (available - len);\n            lengthArray[i] = len + 1;\n        }\n\n        int lastDotIndex = dotCount - 1;\n        lengthArray[dotCount] = className.length() - dotArray[lastDotIndex];\n    }\n\n    static void printArray(String msg, int[] ia) {\n        System.out.print(msg);\n        for (int i = 0; i < ia.length; i++) {\n            if (i == 0) {\n                System.out.print(ia[i]);\n            } else {\n                System.out.print(\", \" + ia[i]);\n            }\n        }\n        System.out.println();\n    }\n}\n","lineNo":61}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core;\n\nimport static ch.qos.logback.core.CoreConstants.CONTEXT_NAME_KEY;\nimport static ch.qos.logback.core.CoreConstants.FA_FILENAME_COLLISION_MAP;\nimport static ch.qos.logback.core.CoreConstants.HOSTNAME_KEY;\nimport static ch.qos.logback.core.CoreConstants.RFA_FILENAME_PATTERN_COLLISION_MAP;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\n\nimport ch.qos.logback.core.rolling.helper.FileNamePattern;\nimport ch.qos.logback.core.spi.LifeCycle;\nimport ch.qos.logback.core.spi.LogbackLock;\nimport ch.qos.logback.core.spi.SequenceNumberGenerator;\nimport ch.qos.logback.core.status.InfoStatus;\nimport ch.qos.logback.core.status.Status;\nimport ch.qos.logback.core.status.StatusManager;\nimport ch.qos.logback.core.util.ExecutorServiceUtil;\nimport ch.qos.logback.core.util.NetworkAddressUtil;\n\npublic class ContextBase implements Context, LifeCycle {\n\n    private long birthTime = System.currentTimeMillis();\n\n    private String name;\n    private StatusManager sm = new BasicStatusManager();\n    // TODO propertyMap should be observable so that we can be notified\n    // when it changes so that a new instance of propertyMap can be\n    // serialized. For the time being, we ignore this shortcoming.\n    Map<String, String> propertyMap = new HashMap<String, String>();\n    Map<String, Object> objectMap = new HashMap<String, Object>();\n\n    LogbackLock configurationLock = new LogbackLock();\n\n    private ScheduledExecutorService scheduledExecutorService;\n    protected List<ScheduledFuture<?>> scheduledFutures = new ArrayList<ScheduledFuture<?>>(1);\n    private LifeCycleManager lifeCycleManager;\n    private SequenceNumberGenerator sequenceNumberGenerator;\n  \n\n    private boolean started;\n\n    public ContextBase() {\n        initCollisionMaps();\n    }\n\n    public StatusManager getStatusManager() {\n        return sm;\n    }\n\n    /**\n     * Set the {@link StatusManager} for this context. Note that by default this\n     * context is initialized with a {@link BasicStatusManager}. A null value for\n     * the 'statusManager' argument is not allowed.\n     * \n     * <p> A malicious attacker can set the status manager to a dummy instance,\n     * disabling internal error reporting.\n     *\n     * @param statusManager the new status manager\n     */\n    public void setStatusManager(StatusManager statusManager) {\n        // this method was added in response to http://jira.qos.ch/browse/LBCORE-35\n        if (statusManager == null) {\n            throw new IllegalArgumentException(\"null StatusManager not allowed\");\n        }\n        this.sm = statusManager;\n    }\n\n    public Map<String, String> getCopyOfPropertyMap() {\n        return new HashMap<String, String>(propertyMap);\n    }\n\n    public void putProperty(String key, String val) {\n        if (HOSTNAME_KEY.equalsIgnoreCase(key)) {\n            putHostnameProperty(val);\n        } else {\n            this.propertyMap.put(key, val);\n        }\n    }\n\n    protected void initCollisionMaps() {\n        putObject(FA_FILENAME_COLLISION_MAP, new HashMap<String, String>());\n        putObject(RFA_FILENAME_PATTERN_COLLISION_MAP, new HashMap<String, FileNamePattern>());\n    }\n\n    /**\n     * Given a key, return the corresponding property value. If invoked with\n     * the special key \"CONTEXT_NAME\", the name of the context is returned.\n     *\n     * @param key\n     * @return\n     */\n    public String getProperty(String key) {\n        if (CONTEXT_NAME_KEY.equals(key))\n            return getName();\n        if (HOSTNAME_KEY.equalsIgnoreCase(key)) {\n            return lazyGetHostname();\n        }\n\n        return (String) this.propertyMap.get(key);\n    }\n\n    private String lazyGetHostname() {\n        String hostname = (String) this.propertyMap.get(HOSTNAME_KEY);\n        if (hostname == null) {\n            hostname = new NetworkAddressUtil(this).safelyGetLocalHostName();\n            putHostnameProperty(hostname);\n        }\n        return hostname;\n    }\n\n    private void putHostnameProperty(String hostname) {\n        String existingHostname = (String) this.propertyMap.get(HOSTNAME_KEY);\n        if (existingHostname == null) {\n            this.propertyMap.put(CoreConstants.HOSTNAME_KEY, hostname);\n        } else {\n\n        }\n    }\n\n    public Object getObject(String key) {\n        return objectMap.get(key);\n    }\n\n    public void putObject(String key, Object value) {\n        objectMap.put(key, value);\n    }\n\n    public void removeObject(String key) {\n        objectMap.remove(key);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void start() {\n        // We'd like to create the executor service here, but we can't;\n        // ContextBase has not always implemented LifeCycle and there are *many*\n        // uses (mostly in tests) that would need to be modified.\n        started = true;\n    }\n\n    public void stop() {\n        // We don't check \"started\" here, because the executor service uses\n        // lazy initialization, rather than being created in the start method\n        stopExecutorService();\n\n        started = false;\n    }\n\n    public boolean isStarted() {\n        return started;\n    }\n\n    /**\n     * Clear the internal objectMap and all properties. Removes any registered\n     * shutdown hook.\n     */\n    public void reset() {\n\n        removeShutdownHook();\n        getLifeCycleManager().reset();\n        propertyMap.clear();\n        objectMap.clear();\n    }\n\n    /**\n     * The context name can be set only if it is not already set, or if the\n     * current name is the default context name, namely \"default\", or if the\n     * current name and the old name are the same.\n     *\n     * @throws IllegalStateException if the context already has a name, other than \"default\".\n     */\n    public void setName(String name) throws IllegalStateException {\n        if (name != null && name.equals(this.name)) {\n            return; // idempotent naming\n        }\n        if (this.name == null || CoreConstants.DEFAULT_CONTEXT_NAME.equals(this.name)) {\n            this.name = name;\n        } else {\n            throw new IllegalStateException(\"Context has been already given a name\");\n        }\n    }\n\n    public long getBirthTime() {\n        return birthTime;\n    }\n\n    public Object getConfigurationLock() {\n        return configurationLock;\n    }\n\n    @Override\n    /**\n     * @deprecated\n     */\n    public synchronized ExecutorService getExecutorService() {\n        return getScheduledExecutorService();\n    }\n\n    @Override\n    public synchronized ScheduledExecutorService getScheduledExecutorService() {\n        if (scheduledExecutorService == null) {\n            scheduledExecutorService = ExecutorServiceUtil.newScheduledExecutorService();\n        }\n        return scheduledExecutorService;\n    }\n\n    private synchronized void stopExecutorService() {\n        if (scheduledExecutorService != null) {\n            ExecutorServiceUtil.shutdown(scheduledExecutorService);\n            scheduledExecutorService = null;\n        }\n    }\n\n    private void removeShutdownHook() {\n        Thread hook = (Thread) getObject(CoreConstants.SHUTDOWN_HOOK_THREAD);\n        if (hook != null) {\n            removeObject(CoreConstants.SHUTDOWN_HOOK_THREAD);\n            \n            try {\n            \tsm.add(new InfoStatus(\"Removing shutdownHook \"+hook, this));\n            \tRuntime runtime = Runtime.getRuntime();\n            \tboolean result = runtime.removeShutdownHook(hook);\n            \tsm.add(new InfoStatus(\"ShutdownHook removal result: \"+ result, this));\n            } catch (IllegalStateException e) {\n                // if JVM is already shutting down, ISE is thrown\n                // no need to do anything else\n            }\n        }\n    }\n\n    public void register(LifeCycle component) {\n        getLifeCycleManager().register(component);\n    }\n\n    /**\n     * Gets the life cycle manager for this context.\n     * <p>\n     * The default implementation lazily initializes an instance of\n     * {@link LifeCycleManager}.  Subclasses may override to provide a custom \n     * manager implementation, but must take care to return the same manager\n     * object for each call to this method.\n     * <p>\n     * This is exposed primarily to support instrumentation for unit testing.\n     * \n     * @return manager object \n     */\n    synchronized LifeCycleManager getLifeCycleManager() {\n        if (lifeCycleManager == null) {\n            lifeCycleManager = new LifeCycleManager();\n        }\n        return lifeCycleManager;\n    }\n\n    @Override\n    public String toString() {\n        return name;\n    }\n\n    @Override\n    public void addScheduledFuture(ScheduledFuture<?> scheduledFuture) {\n        scheduledFutures.add(scheduledFuture);\n    }\n\n    /**\n     * @deprecated replaced by getCopyOfScheduledFutures\n     */\n    @Deprecated \n    public List<ScheduledFuture<?>> getScheduledFutures() {\n        return getCopyOfScheduledFutures();\n    }\n    \n    public List<ScheduledFuture<?>> getCopyOfScheduledFutures() {\n        return new ArrayList<ScheduledFuture<?>>(scheduledFutures);\n    }\n    \n    public SequenceNumberGenerator getSequenceNumberGenerator() {\n        return sequenceNumberGenerator;\n    }\n\n    public void setSequenceNumberGenerator(SequenceNumberGenerator sequenceNumberGenerator) {\n        this.sequenceNumberGenerator = sequenceNumberGenerator;\n    }\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core;\n\nimport static ch.qos.logback.core.CoreConstants.CONTEXT_NAME_KEY;\nimport static ch.qos.logback.core.CoreConstants.FA_FILENAME_COLLISION_MAP;\nimport static ch.qos.logback.core.CoreConstants.HOSTNAME_KEY;\nimport static ch.qos.logback.core.CoreConstants.RFA_FILENAME_PATTERN_COLLISION_MAP;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\n\nimport ch.qos.logback.core.rolling.helper.FileNamePattern;\nimport ch.qos.logback.core.spi.LifeCycle;\nimport ch.qos.logback.core.spi.LogbackLock;\nimport ch.qos.logback.core.spi.SequenceNumberGenerator;\nimport ch.qos.logback.core.status.StatusManager;\nimport ch.qos.logback.core.util.ExecutorServiceUtil;\nimport ch.qos.logback.core.util.NetworkAddressUtil;\n\npublic class ContextBase implements Context, LifeCycle {\n\n    private long birthTime = System.currentTimeMillis();\n\n    private String name;\n    private StatusManager sm = new BasicStatusManager();\n    // TODO propertyMap should be observable so that we can be notified\n    // when it changes so that a new instance of propertyMap can be\n    // serialized. For the time being, we ignore this shortcoming.\n    Map<String, String> propertyMap = new HashMap<String, String>();\n    Map<String, Object> objectMap = new HashMap<String, Object>();\n\n    LogbackLock configurationLock = new LogbackLock();\n\n    private ScheduledExecutorService scheduledExecutorService;\n    protected List<ScheduledFuture<?>> scheduledFutures = new ArrayList<ScheduledFuture<?>>(1);\n    private LifeCycleManager lifeCycleManager;\n    private SequenceNumberGenerator sequenceNumberGenerator;\n  \n\n    private boolean started;\n\n    public ContextBase() {\n        initCollisionMaps();\n    }\n\n    public StatusManager getStatusManager() {\n        return sm;\n    }\n\n    /**\n     * Set the {@link StatusManager} for this context. Note that by default this\n     * context is initialized with a {@link BasicStatusManager}. A null value for\n     * the 'statusManager' argument is not allowed.\n     * \n     * <p> A malicious attacker can set the status manager to a dummy instance,\n     * disabling internal error reporting.\n     *\n     * @param statusManager the new status manager\n     */\n    public void setStatusManager(StatusManager statusManager) {\n        // this method was added in response to http://jira.qos.ch/browse/LBCORE-35\n        if (statusManager == null) {\n            throw new IllegalArgumentException(\"null StatusManager not allowed\");\n        }\n        this.sm = statusManager;\n    }\n\n    public Map<String, String> getCopyOfPropertyMap() {\n        return new HashMap<String, String>(propertyMap);\n    }\n\n    public void putProperty(String key, String val) {\n        if (HOSTNAME_KEY.equalsIgnoreCase(key)) {\n            putHostnameProperty(val);\n        } else {\n            this.propertyMap.put(key, val);\n        }\n    }\n\n    protected void initCollisionMaps() {\n        putObject(FA_FILENAME_COLLISION_MAP, new HashMap<String, String>());\n        putObject(RFA_FILENAME_PATTERN_COLLISION_MAP, new HashMap<String, FileNamePattern>());\n    }\n\n    /**\n     * Given a key, return the corresponding property value. If invoked with\n     * the special key \"CONTEXT_NAME\", the name of the context is returned.\n     *\n     * @param key\n     * @return\n     */\n    public String getProperty(String key) {\n        if (CONTEXT_NAME_KEY.equals(key))\n            return getName();\n        if (HOSTNAME_KEY.equalsIgnoreCase(key)) {\n            return lazyGetHostname();\n        }\n\n        return (String) this.propertyMap.get(key);\n    }\n\n    private String lazyGetHostname() {\n        String hostname = (String) this.propertyMap.get(HOSTNAME_KEY);\n        if (hostname == null) {\n            hostname = new NetworkAddressUtil(this).safelyGetLocalHostName();\n            putHostnameProperty(hostname);\n        }\n        return hostname;\n    }\n\n    private void putHostnameProperty(String hostname) {\n        String existingHostname = (String) this.propertyMap.get(HOSTNAME_KEY);\n        if (existingHostname == null) {\n            this.propertyMap.put(CoreConstants.HOSTNAME_KEY, hostname);\n        } else {\n\n        }\n    }\n\n    public Object getObject(String key) {\n        return objectMap.get(key);\n    }\n\n    public void putObject(String key, Object value) {\n        objectMap.put(key, value);\n    }\n\n    public void removeObject(String key) {\n        objectMap.remove(key);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void start() {\n        // We'd like to create the executor service here, but we can't;\n        // ContextBase has not always implemented LifeCycle and there are *many*\n        // uses (mostly in tests) that would need to be modified.\n        started = true;\n    }\n\n    public void stop() {\n        // We don't check \"started\" here, because the executor service uses\n        // lazy initialization, rather than being created in the start method\n        stopExecutorService();\n\n        started = false;\n    }\n\n    public boolean isStarted() {\n        return started;\n    }\n\n    /**\n     * Clear the internal objectMap and all properties. Removes any registered\n     * shutdown hook.\n     */\n    public void reset() {\n\n        removeShutdownHook();\n        getLifeCycleManager().reset();\n        propertyMap.clear();\n        objectMap.clear();\n    }\n\n    /**\n     * The context name can be set only if it is not already set, or if the\n     * current name is the default context name, namely \"default\", or if the\n     * current name and the old name are the same.\n     *\n     * @throws IllegalStateException if the context already has a name, other than \"default\".\n     */\n    public void setName(String name) throws IllegalStateException {\n        if (name != null && name.equals(this.name)) {\n            return; // idempotent naming\n        }\n        if (this.name == null || CoreConstants.DEFAULT_CONTEXT_NAME.equals(this.name)) {\n            this.name = name;\n        } else {\n            throw new IllegalStateException(\"Context has been already given a name\");\n        }\n    }\n\n    public long getBirthTime() {\n        return birthTime;\n    }\n\n    public Object getConfigurationLock() {\n        return configurationLock;\n    }\n\n    @Override\n    /**\n     * @deprecated\n     */\n    public synchronized ExecutorService getExecutorService() {\n        return getScheduledExecutorService();\n    }\n\n    @Override\n    public synchronized ScheduledExecutorService getScheduledExecutorService() {\n        if (scheduledExecutorService == null) {\n            scheduledExecutorService = ExecutorServiceUtil.newScheduledExecutorService();\n        }\n        return scheduledExecutorService;\n    }\n\n    private synchronized void stopExecutorService() {\n        if (scheduledExecutorService != null) {\n            ExecutorServiceUtil.shutdown(scheduledExecutorService);\n            scheduledExecutorService = null;\n        }\n    }\n\n    private void removeShutdownHook() {\n        Thread hook = (Thread) getObject(CoreConstants.SHUTDOWN_HOOK_THREAD);\n        if (hook != null) {\n            removeObject(CoreConstants.SHUTDOWN_HOOK_THREAD);\n            try {\n                Runtime.getRuntime().removeShutdownHook(hook);\n            } catch (IllegalStateException e) {\n                // if JVM is already shutting down, ISE is thrown\n                // no need to do anything else\n            }\n        }\n    }\n\n    public void register(LifeCycle component) {\n        getLifeCycleManager().register(component);\n    }\n\n    /**\n     * Gets the life cycle manager for this context.\n     * <p>\n     * The default implementation lazily initializes an instance of\n     * {@link LifeCycleManager}.  Subclasses may override to provide a custom \n     * manager implementation, but must take care to return the same manager\n     * object for each call to this method.\n     * <p>\n     * This is exposed primarily to support instrumentation for unit testing.\n     * \n     * @return manager object \n     */\n    synchronized LifeCycleManager getLifeCycleManager() {\n        if (lifeCycleManager == null) {\n            lifeCycleManager = new LifeCycleManager();\n        }\n        return lifeCycleManager;\n    }\n\n    @Override\n    public String toString() {\n        return name;\n    }\n\n    @Override\n    public void addScheduledFuture(ScheduledFuture<?> scheduledFuture) {\n        scheduledFutures.add(scheduledFuture);\n    }\n\n    public List<ScheduledFuture<?>> getScheduledFutures() {\n        return new ArrayList<ScheduledFuture<?>>(scheduledFutures);\n    }\n    \n    public SequenceNumberGenerator getSequenceNumberGenerator() {\n        return sequenceNumberGenerator;\n    }\n\n    public void setSequenceNumberGenerator(SequenceNumberGenerator sequenceNumberGenerator) {\n        this.sequenceNumberGenerator = sequenceNumberGenerator;\n    }\n\n}\n","lineNo":242}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.joran.action;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Stack;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.xml.sax.SAXParseException;\n\nimport ch.qos.logback.core.Context;\nimport ch.qos.logback.core.ContextBase;\nimport ch.qos.logback.core.joran.TrivialConfigurator;\nimport ch.qos.logback.core.joran.action.ext.StackAction;\nimport ch.qos.logback.core.joran.spi.ElementSelector;\nimport ch.qos.logback.core.joran.spi.InterpretationContext;\nimport ch.qos.logback.core.joran.spi.JoranException;\nimport ch.qos.logback.core.model.IncludeModel;\nimport ch.qos.logback.core.model.TopModel;\nimport ch.qos.logback.core.model.processor.ChainedModelFilter;\nimport ch.qos.logback.core.model.processor.DefaultProcessor;\nimport ch.qos.logback.core.model.processor.IncludeModelHandler;\nimport ch.qos.logback.core.model.processor.ModelFiler;\nimport ch.qos.logback.core.model.processor.NOPModelHandler;\nimport ch.qos.logback.core.status.Status;\nimport ch.qos.logback.core.testUtil.CoreTestConstants;\nimport ch.qos.logback.core.testUtil.FileTestUtil;\nimport ch.qos.logback.core.testUtil.RandomUtil;\nimport ch.qos.logback.core.testUtil.StatusChecker;\nimport ch.qos.logback.core.util.StatusPrinter;\n\npublic class IncludeActionTest {\n\n    final static String INCLUDE_KEY = \"includeKey\";\n    final static String SUB_FILE_KEY = \"subFileKey\";\n    final static String SECOND_FILE_KEY = \"secondFileKey\";\n\n    Context context = new ContextBase();\n    StatusChecker statusChecker = new StatusChecker(context);\n    TrivialConfigurator tc;\n\n    static final String INCLUSION_DIR_PREFIX = CoreTestConstants.JORAN_INPUT_PREFIX + \"inclusion/\";\n\n    static final String TOP_BY_FILE = INCLUSION_DIR_PREFIX + \"topByFile.xml\";\n\n    static final String TOP_OPTIONAL = INCLUSION_DIR_PREFIX + \"topOptional.xml\";\n\n    static final String TOP_OPTIONAL_RESOURCE = INCLUSION_DIR_PREFIX + \"topOptionalResource.xml\";\n\n    static final String INTERMEDIARY_FILE = INCLUSION_DIR_PREFIX + \"intermediaryByFile.xml\";\n\n    static final String SUB_FILE = INCLUSION_DIR_PREFIX + \"subByFile.xml\";\n\n    static final String MULTI_INCLUDE_BY_FILE = INCLUSION_DIR_PREFIX + \"multiIncludeByFile.xml\";\n\n    static final String SECOND_FILE = INCLUSION_DIR_PREFIX + \"second.xml\";\n\n    static final String TOP_BY_URL = INCLUSION_DIR_PREFIX + \"topByUrl.xml\";\n\n    static final String TOP_BY_ENTITY = INCLUSION_DIR_PREFIX + \"topByEntity.xml\";\n\n    static final String INCLUDE_BY_RESOURCE = INCLUSION_DIR_PREFIX + \"topByResource.xml\";\n\n    static final String INCLUDED_FILE = INCLUSION_DIR_PREFIX + \"included.xml\";\n    static final String URL_TO_INCLUDE = \"file:./\" + INCLUDED_FILE;\n\n    static final String INVALID = INCLUSION_DIR_PREFIX + \"invalid.xml\";\n\n    static final String INCLUDED_AS_RESOURCE = \"asResource/joran/inclusion/includedAsResource.xml\";\n\n    int diff = RandomUtil.getPositiveInt();\n\n    StackAction stackAction = new StackAction();\n\n    @Before\n    public void setUp() throws Exception {\n        FileTestUtil.makeTestOutputDir();\n        HashMap<ElementSelector, Action> rulesMap = new HashMap<ElementSelector, Action>();\n        rulesMap.put(new ElementSelector(\"x\"), new TopElementAction());\n        rulesMap.put(new ElementSelector(\"x/include\"), new IncludeModelAction());\n        rulesMap.put(new ElementSelector(\"x/stack\"), stackAction);\n\n        tc = new TrivialConfigurator(rulesMap) {\n            @Override\n            protected DefaultProcessor buildDefaultProcessor(Context context, InterpretationContext interpretationContext) {\n                DefaultProcessor defaultProcessor = super.buildDefaultProcessor(context, interpretationContext);\n                defaultProcessor.addHandler(TopModel.class, NOPModelHandler::makeInstance);\n                defaultProcessor.addHandler(IncludeModel.class, IncludeModelHandler::makeInstance);\n                ModelFiler p1Filter = ChainedModelFilter.newInstance().allow(TopModel.class).denyAll();\n                defaultProcessor.setPhaseOneFilter(p1Filter);\n                ModelFiler p2Filter = ChainedModelFilter.newInstance().allow(TopModel.class).allow(IncludeModel.class).denyAll();\n                defaultProcessor.setPhaseTwoFilter(p2Filter);\n                return defaultProcessor;\n            }\n        };\n        \n        tc.setContext(context);\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        StatusPrinter.printInCaseOfErrorsOrWarnings(context);\n        context = null;\n        System.clearProperty(INCLUDE_KEY);\n        System.clearProperty(SECOND_FILE_KEY);\n        System.clearProperty(SUB_FILE_KEY);\n        // StackAction.reset();\n    }\n\n    @Test\n    public void basicFile() throws JoranException {\n        System.setProperty(INCLUDE_KEY, INCLUDED_FILE);\n        tc.doConfigure(TOP_BY_FILE);\n        StatusPrinter.print(context);\n        verifyConfig(new String[] { \"IA\", \"IB\" });\n    }\n\n    @Test\n    public void optionalFile() throws JoranException {\n        tc.doConfigure(TOP_OPTIONAL);\n        verifyConfig(new String[] { \"IA\", \"IB\" });\n        StatusPrinter.print(context);\n    }\n\n    @Test\n    public void optionalResource() throws JoranException {\n        tc.doConfigure(TOP_OPTIONAL_RESOURCE);\n        verifyConfig(new String[] { \"IA\", \"IB\" });\n        StatusPrinter.print(context);\n        assertEquals(Status.INFO, statusChecker.getHighestLevel(0));\n    }\n\n    @Test\n    public void basicResource() throws JoranException {\n        System.setProperty(INCLUDE_KEY, INCLUDED_AS_RESOURCE);\n        tc.doConfigure(INCLUDE_BY_RESOURCE);\n        verifyConfig(new String[] { \"AR_A\", \"AR_B\" });\n    }\n\n    @Test\n    public void basicURL() throws JoranException {\n        System.setProperty(INCLUDE_KEY, URL_TO_INCLUDE);\n        tc.doConfigure(TOP_BY_URL);\n        StatusPrinter.print(context);\n        verifyConfig(new String[] { \"IA\", \"IB\" });\n    }\n\n    @Test\n    public void noFileFound() throws JoranException {\n        System.setProperty(INCLUDE_KEY, \"toto\");\n        tc.doConfigure(TOP_BY_FILE);\n        assertEquals(Status.WARN, statusChecker.getHighestLevel(0));\n    }\n\n    @Test\n    public void withCorruptFile() throws JoranException, IOException {\n        String tmpOut = copyToTemp(INVALID);\n        System.setProperty(INCLUDE_KEY, tmpOut);\n        tc.doConfigure(TOP_BY_FILE);\n        assertEquals(Status.ERROR, statusChecker.getHighestLevel(0));\n        StatusPrinter.print(context);\n        assertTrue(statusChecker.containsException(SAXParseException.class));\n\n        // we like to erase the temp file in order to see\n        // if http://jira.qos.ch/browse/LBCORE-122 was fixed\n        File f = new File(tmpOut);\n        assertTrue(f.exists());\n        assertTrue(f.delete());\n\n    }\n\n    String copyToTemp(String in) throws IOException {\n        FileInputStream fis = new FileInputStream(in);\n        String out = CoreTestConstants.OUTPUT_DIR_PREFIX + \"out\" + diff;\n        FileOutputStream fos = new FileOutputStream(out);\n        int b;\n        while ((b = fis.read()) != -1) {\n            fos.write(b);\n        }\n        fis.close();\n        fos.close();\n        return out;\n    }\n\n    @Test\n    public void malformedURL() throws JoranException {\n    \tString MALFORMED = \"htp://logback.qos.ch\";\n    \t\t\n        System.setProperty(INCLUDE_KEY, MALFORMED);\n        tc.doConfigure(TOP_BY_URL);\n        assertEquals(Status.ERROR, statusChecker.getHighestLevel(0));\n        assertTrue(statusChecker.containsException(MalformedURLException.class));\n    }\n\n    @Test\n    public void unknownURL() throws JoranException {\n        System.setProperty(INCLUDE_KEY, \"http://logback2345.qos.ch\");\n        tc.doConfigure(TOP_BY_URL);\n        assertEquals(Status.WARN, statusChecker.getHighestLevel(0));\n    }\n\n    @Test\n    public void nestedInclude() throws JoranException {\n        System.setProperty(SUB_FILE_KEY, SUB_FILE);\n        System.setProperty(INCLUDE_KEY, INTERMEDIARY_FILE);\n        tc.doConfigure(TOP_BY_FILE);\n        Stack<String> expected = new Stack<String>();\n        expected.push(\"a\");\n        expected.push(\"c\");\n        expected.push(\"b\");\n        assertEquals(expected, stackAction.getStack());\n    }\n\n    @Test\n    public void multiInclude() throws JoranException {\n        System.setProperty(INCLUDE_KEY, INCLUDED_FILE);\n        System.setProperty(SECOND_FILE_KEY, SECOND_FILE);\n        tc.doConfigure(MULTI_INCLUDE_BY_FILE);\n        verifyConfig(new String[] { \"IA\", \"IB\", \"SECOND\" });\n    }\n    \n    \n    // See LOGBACK-1465 - xxe vulnerability\n    @Test\n    public void includeAsEntity() throws JoranException {\n        tc.doConfigure(TOP_BY_ENTITY);\n        StatusPrinter.print(context);\n        //verifyConfig(new String[] { \"EA\", \"EB\" });\n        // entity inclusion disabled\n        verifyConfig(new String[] { });\n    }\n    \n    void verifyConfig(String[] expected) {\n        Stack<String> witness = new Stack<String>();\n        witness.addAll(Arrays.asList(expected));\n        assertEquals(witness, stackAction.getStack());\n    }\n\n\n    \n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.joran.action;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Stack;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.xml.sax.SAXParseException;\n\nimport ch.qos.logback.core.Context;\nimport ch.qos.logback.core.ContextBase;\nimport ch.qos.logback.core.joran.TrivialConfigurator;\nimport ch.qos.logback.core.joran.action.ext.StackAction;\nimport ch.qos.logback.core.joran.spi.ElementSelector;\nimport ch.qos.logback.core.joran.spi.InterpretationContext;\nimport ch.qos.logback.core.joran.spi.JoranException;\nimport ch.qos.logback.core.model.IncludeModel;\nimport ch.qos.logback.core.model.TopModel;\nimport ch.qos.logback.core.model.processor.ChainedModelFilter;\nimport ch.qos.logback.core.model.processor.DefaultProcessor;\nimport ch.qos.logback.core.model.processor.IncludeModelHandler;\nimport ch.qos.logback.core.model.processor.ModelFiler;\nimport ch.qos.logback.core.model.processor.NOPModelHandler;\nimport ch.qos.logback.core.status.Status;\nimport ch.qos.logback.core.testUtil.CoreTestConstants;\nimport ch.qos.logback.core.testUtil.FileTestUtil;\nimport ch.qos.logback.core.testUtil.RandomUtil;\nimport ch.qos.logback.core.testUtil.StatusChecker;\nimport ch.qos.logback.core.util.StatusPrinter;\n\npublic class IncludeActionTest {\n\n    final static String INCLUDE_KEY = \"includeKey\";\n    final static String SUB_FILE_KEY = \"subFileKey\";\n    final static String SECOND_FILE_KEY = \"secondFileKey\";\n\n    Context context = new ContextBase();\n    StatusChecker statusChecker = new StatusChecker(context);\n    TrivialConfigurator tc;\n\n    static final String INCLUSION_DIR_PREFIX = CoreTestConstants.JORAN_INPUT_PREFIX + \"inclusion/\";\n\n    static final String TOP_BY_FILE = INCLUSION_DIR_PREFIX + \"topByFile.xml\";\n\n    static final String TOP_OPTIONAL = INCLUSION_DIR_PREFIX + \"topOptional.xml\";\n\n    static final String TOP_OPTIONAL_RESOURCE = INCLUSION_DIR_PREFIX + \"topOptionalResource.xml\";\n\n    static final String INTERMEDIARY_FILE = INCLUSION_DIR_PREFIX + \"intermediaryByFile.xml\";\n\n    static final String SUB_FILE = INCLUSION_DIR_PREFIX + \"subByFile.xml\";\n\n    static final String MULTI_INCLUDE_BY_FILE = INCLUSION_DIR_PREFIX + \"multiIncludeByFile.xml\";\n\n    static final String SECOND_FILE = INCLUSION_DIR_PREFIX + \"second.xml\";\n\n    static final String TOP_BY_URL = INCLUSION_DIR_PREFIX + \"topByUrl.xml\";\n\n    static final String TOP_BY_ENTITY = INCLUSION_DIR_PREFIX + \"topByEntity.xml\";\n\n    static final String INCLUDE_BY_RESOURCE = INCLUSION_DIR_PREFIX + \"topByResource.xml\";\n\n    static final String INCLUDED_FILE = INCLUSION_DIR_PREFIX + \"included.xml\";\n    static final String URL_TO_INCLUDE = \"file:./\" + INCLUDED_FILE;\n\n    static final String INVALID = INCLUSION_DIR_PREFIX + \"invalid.xml\";\n\n    static final String INCLUDED_AS_RESOURCE = \"asResource/joran/inclusion/includedAsResource.xml\";\n\n    int diff = RandomUtil.getPositiveInt();\n\n    StackAction stackAction = new StackAction();\n\n    @Before\n    public void setUp() throws Exception {\n        FileTestUtil.makeTestOutputDir();\n        HashMap<ElementSelector, Action> rulesMap = new HashMap<ElementSelector, Action>();\n        rulesMap.put(new ElementSelector(\"x\"), new TopElementAction());\n        rulesMap.put(new ElementSelector(\"x/include\"), new IncludeModelAction());\n        rulesMap.put(new ElementSelector(\"x/stack\"), stackAction);\n\n        tc = new TrivialConfigurator(rulesMap) {\n            @Override\n            protected DefaultProcessor buildDefaultProcessor(Context context, InterpretationContext interpretationContext) {\n                DefaultProcessor defaultProcessor = super.buildDefaultProcessor(context, interpretationContext);\n                defaultProcessor.addHandler(TopModel.class, NOPModelHandler::makeInstance);\n                defaultProcessor.addHandler(IncludeModel.class, IncludeModelHandler::makeInstance);\n                ModelFiler p1Filter = ChainedModelFilter.newInstance().allow(TopModel.class).denyAll();\n                defaultProcessor.setPhaseOneFilter(p1Filter);\n                ModelFiler p2Filter = ChainedModelFilter.newInstance().allow(TopModel.class).allow(IncludeModel.class).denyAll();\n                defaultProcessor.setPhaseTwoFilter(p2Filter);\n                return defaultProcessor;\n            }\n        };\n        \n        tc.setContext(context);\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        StatusPrinter.printInCaseOfErrorsOrWarnings(context);\n        context = null;\n        System.clearProperty(INCLUDE_KEY);\n        System.clearProperty(SECOND_FILE_KEY);\n        System.clearProperty(SUB_FILE_KEY);\n        // StackAction.reset();\n    }\n\n    @Test\n    public void basicFile() throws JoranException {\n        System.setProperty(INCLUDE_KEY, INCLUDED_FILE);\n        tc.doConfigure(TOP_BY_FILE);\n        StatusPrinter.print(context);\n        verifyConfig(new String[] { \"IA\", \"IB\" });\n    }\n\n    @Test\n    public void optionalFile() throws JoranException {\n        tc.doConfigure(TOP_OPTIONAL);\n        verifyConfig(new String[] { \"IA\", \"IB\" });\n        StatusPrinter.print(context);\n    }\n\n    @Test\n    public void optionalResource() throws JoranException {\n        tc.doConfigure(TOP_OPTIONAL_RESOURCE);\n        verifyConfig(new String[] { \"IA\", \"IB\" });\n        StatusPrinter.print(context);\n        assertEquals(Status.INFO, statusChecker.getHighestLevel(0));\n    }\n\n    @Test\n    public void basicResource() throws JoranException {\n        System.setProperty(INCLUDE_KEY, INCLUDED_AS_RESOURCE);\n        tc.doConfigure(INCLUDE_BY_RESOURCE);\n        verifyConfig(new String[] { \"AR_A\", \"AR_B\" });\n    }\n\n    @Test\n    public void basicURL() throws JoranException {\n        System.setProperty(INCLUDE_KEY, URL_TO_INCLUDE);\n        tc.doConfigure(TOP_BY_URL);\n        StatusPrinter.print(context);\n        verifyConfig(new String[] { \"IA\", \"IB\" });\n    }\n\n    @Test\n    public void noFileFound() throws JoranException {\n        System.setProperty(INCLUDE_KEY, \"toto\");\n        tc.doConfigure(TOP_BY_FILE);\n        assertEquals(Status.WARN, statusChecker.getHighestLevel(0));\n    }\n\n    @Test\n    public void withCorruptFile() throws JoranException, IOException {\n        String tmpOut = copyToTemp(INVALID);\n        System.setProperty(INCLUDE_KEY, tmpOut);\n        tc.doConfigure(TOP_BY_FILE);\n        assertEquals(Status.ERROR, statusChecker.getHighestLevel(0));\n        StatusPrinter.print(context);\n        assertTrue(statusChecker.containsException(SAXParseException.class));\n\n        // we like to erase the temp file in order to see\n        // if http://jira.qos.ch/browse/LBCORE-122 was fixed\n        File f = new File(tmpOut);\n        assertTrue(f.exists());\n        assertTrue(f.delete());\n\n    }\n\n    String copyToTemp(String in) throws IOException {\n        FileInputStream fis = new FileInputStream(in);\n        String out = CoreTestConstants.OUTPUT_DIR_PREFIX + \"out\" + diff;\n        FileOutputStream fos = new FileOutputStream(out);\n        int b;\n        while ((b = fis.read()) != -1) {\n            fos.write(b);\n        }\n        fis.close();\n        fos.close();\n        return out;\n    }\n\n    @Test\n    public void malformedURL() throws JoranException {\n        System.setProperty(INCLUDE_KEY, \"htp://logback.qos.ch\");\n        tc.doConfigure(TOP_BY_URL);\n        assertEquals(Status.ERROR, statusChecker.getHighestLevel(0));\n        assertTrue(statusChecker.containsException(MalformedURLException.class));\n    }\n\n    @Test\n    public void unknownURL() throws JoranException {\n        System.setProperty(INCLUDE_KEY, \"http://logback2345.qos.ch\");\n        tc.doConfigure(TOP_BY_URL);\n        assertEquals(Status.WARN, statusChecker.getHighestLevel(0));\n    }\n\n    @Test\n    public void nestedInclude() throws JoranException {\n        System.setProperty(SUB_FILE_KEY, SUB_FILE);\n        System.setProperty(INCLUDE_KEY, INTERMEDIARY_FILE);\n        tc.doConfigure(TOP_BY_FILE);\n        Stack<String> expected = new Stack<String>();\n        expected.push(\"a\");\n        expected.push(\"c\");\n        expected.push(\"b\");\n        assertEquals(expected, stackAction.getStack());\n    }\n\n    @Test\n    public void multiInclude() throws JoranException {\n        System.setProperty(INCLUDE_KEY, INCLUDED_FILE);\n        System.setProperty(SECOND_FILE_KEY, SECOND_FILE);\n        tc.doConfigure(MULTI_INCLUDE_BY_FILE);\n        verifyConfig(new String[] { \"IA\", \"IB\", \"SECOND\" });\n    }\n    \n    @Test\n    public void includeAsEntity() throws JoranException {\n        tc.doConfigure(TOP_BY_ENTITY);\n        verifyConfig(new String[] { \"EA\", \"EB\" });  \n    }\n    \n    void verifyConfig(String[] expected) {\n        Stack<String> witness = new Stack<String>();\n        witness.addAll(Arrays.asList(expected));\n        assertEquals(witness, stackAction.getStack());\n    }\n\n\n    \n}\n","lineNo":209}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.joran;\n\nimport static ch.qos.logback.classic.ClassicTestConstants.JORAN_INPUT_PREFIX;\nimport static ch.qos.logback.classic.joran.ReconfigureOnChangeTask.DETECTED_CHANGE_IN_CONFIGURATION_FILES;\nimport static ch.qos.logback.classic.joran.ReconfigureOnChangeTask.FALLING_BACK_TO_SAFE_CONFIGURATION;\nimport static ch.qos.logback.classic.joran.ReconfigureOnChangeTask.RE_REGISTERING_PREVIOUS_SAFE_CONFIGURATION;\nimport static ch.qos.logback.core.CoreConstants.RECONFIGURE_ON_CHANGE_TASK;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ScheduledFuture;\n\nimport org.junit.BeforeClass;\nimport org.junit.Test;\n\nimport ch.qos.logback.classic.Logger;\nimport ch.qos.logback.classic.LoggerContext;\nimport ch.qos.logback.classic.issue.lbclassic135.LoggingRunnable;\nimport ch.qos.logback.core.CoreConstants;\nimport ch.qos.logback.core.contention.AbstractMultiThreadedHarness;\nimport ch.qos.logback.core.contention.RunnableWithCounterAndDone;\nimport ch.qos.logback.core.joran.spi.ConfigurationWatchList;\nimport ch.qos.logback.core.joran.spi.JoranException;\nimport ch.qos.logback.core.joran.util.ConfigurationWatchListUtil;\nimport ch.qos.logback.core.status.InfoStatus;\nimport ch.qos.logback.core.status.Status;\nimport ch.qos.logback.core.testUtil.CoreTestConstants;\nimport ch.qos.logback.core.testUtil.FileTestUtil;\nimport ch.qos.logback.core.testUtil.RandomUtil;\nimport ch.qos.logback.core.testUtil.StatusChecker;\nimport ch.qos.logback.core.util.StatusPrinter;\n\npublic class ReconfigureOnChangeTaskTest {\n    final static int THREAD_COUNT = 5;\n\n    int diff = RandomUtil.getPositiveInt();\n\n    // the space in the file name mandated by\n    // http://jira.qos.ch/browse/LBCORE-119\n    final static String SCAN1_FILE_AS_STR = JORAN_INPUT_PREFIX + \"roct/scan 1.xml\";\n\n    final static String G_SCAN1_FILE_AS_STR = JORAN_INPUT_PREFIX + \"roct/scan 1.groovy\";\n\n    final static String SCAN_LOGBACK_474_FILE_AS_STR = JORAN_INPUT_PREFIX + \"roct/scan_logback_474.xml\";\n\n    final static String INCLUSION_SCAN_TOPLEVEL0_AS_STR = JORAN_INPUT_PREFIX + \"roct/inclusion/topLevel0.xml\";\n\n    final static String INCLUSION_SCAN_TOP_BY_RESOURCE_AS_STR = JORAN_INPUT_PREFIX + \"roct/inclusion/topByResource.xml\";\n\n    final static String INCLUSION_SCAN_INNER0_AS_STR = JORAN_INPUT_PREFIX + \"roct/inclusion/inner0.xml\";\n\n    final static String INCLUSION_SCAN_INNER1_AS_STR = \"target/test-classes/asResource/inner1.xml\";\n\n    private static final String SCAN_PERIOD_DEFAULT_FILE_AS_STR =  JORAN_INPUT_PREFIX + \"roct/scan_period_default.xml\";\n    \n    LoggerContext loggerContext = new LoggerContext();\n    Logger logger = loggerContext.getLogger(this.getClass());\n    StatusChecker statusChecker = new StatusChecker(loggerContext);\n\n    @BeforeClass\n    static public void classSetup() {\n        FileTestUtil.makeTestOutputDir();\n    }\n\n    void configure(File file) throws JoranException {\n        JoranConfigurator jc = new JoranConfigurator();\n        jc.setContext(loggerContext);\n        jc.doConfigure(file);\n    }\n\n    void configure(InputStream is) throws JoranException {\n        JoranConfigurator jc = new JoranConfigurator();\n        jc.setContext(loggerContext);\n        jc.doConfigure(is);\n    }\n\n//    void gConfigure(File file) throws JoranException {\n//        GafferConfigurator gc = new GafferConfigurator(loggerContext);\n//        gc.run(file);\n//    }\n\n    @Test(timeout = 4000L)\n    public void checkBasicLifecyle() throws JoranException, IOException, InterruptedException {\n        File file = new File(SCAN1_FILE_AS_STR);\n        configure(file);\n        List<File> fileList = getConfigurationWatchList(loggerContext);\n        assertThatListContainsFile(fileList, file);\n        checkThatTaskHasRan();\n        checkThatTaskCanBeStopped();\n    }\n\n//    @Test(timeout = 4000L)\n//    public void checkBasicLifecyleWithGaffer() throws JoranException, IOException, InterruptedException {\n//        File file = new File(G_SCAN1_FILE_AS_STR);\n//        gConfigure(file);\n//        List<File> fileList = getConfigurationWatchList(loggerContext);\n//        assertThatListContainsFile(fileList, file);\n//        checkThatTaskHasRan();\n//        checkThatTaskCanBeStopped();\n//    }\n\n    private void checkThatTaskCanBeStopped() {\n        ScheduledFuture<?> future = loggerContext.getScheduledFutures().get(0);\n        loggerContext.stop();\n        assertTrue(future.isCancelled());\n    }\n\n    private void checkThatTaskHasRan() throws InterruptedException {\n        waitForReconfigureOnChangeTaskToRun();\n    }\n\n    List<File> getConfigurationWatchList(LoggerContext context) {\n        ConfigurationWatchList configurationWatchList = ConfigurationWatchListUtil.getConfigurationWatchList(loggerContext);\n        return configurationWatchList.getCopyOfFileWatchList();\n    }\n\n    @Test(timeout = 4000L)\n    public void scanWithFileInclusion() throws JoranException, IOException, InterruptedException {\n        File topLevelFile = new File(INCLUSION_SCAN_TOPLEVEL0_AS_STR);\n        File innerFile = new File(INCLUSION_SCAN_INNER0_AS_STR);\n        configure(topLevelFile);\n        List<File> fileList = getConfigurationWatchList(loggerContext);\n        assertThatListContainsFile(fileList, topLevelFile);\n        assertThatListContainsFile(fileList, innerFile);\n        checkThatTaskHasRan();\n        checkThatTaskCanBeStopped();\n    }\n\n    @Test(timeout = 4000L)\n    public void scanWithResourceInclusion() throws JoranException, IOException, InterruptedException {\n        File topLevelFile = new File(INCLUSION_SCAN_TOP_BY_RESOURCE_AS_STR);\n        File innerFile = new File(INCLUSION_SCAN_INNER1_AS_STR);\n        configure(topLevelFile);\n        List<File> fileList = getConfigurationWatchList(loggerContext);\n        assertThatListContainsFile(fileList, topLevelFile);\n        assertThatListContainsFile(fileList, innerFile);\n    }\n\n    // See also http://jira.qos.ch/browse/LOGBACK-338\n    @Test(timeout = 4000L)\n    public void reconfigurationIsNotPossibleInTheAbsenceOfATopFile() throws IOException, JoranException, InterruptedException {\n        String configurationStr = \"<configuration scan=\\\"true\\\" scanPeriod=\\\"50 millisecond\\\"><include resource=\\\"asResource/inner1.xml\\\"/><\/configuration>\";\n        configure(new ByteArrayInputStream(configurationStr.getBytes(\"UTF-8\")));\n\n        ConfigurationWatchList configurationWatchList = ConfigurationWatchListUtil.getConfigurationWatchList(loggerContext);\n        assertNull(configurationWatchList);\n        // assertNull(configurationWatchList.getMainURL());\n\n        statusChecker.containsMatch(Status.WARN, \"Due to missing top level\");\n        StatusPrinter.print(loggerContext);\n        ReconfigureOnChangeTask roct = getRegisteredReconfigureTask();\n        assertNull(roct);\n        assertEquals(0, loggerContext.getScheduledFutures().size());\n    }\n\n    @Test(timeout = 3000L)\n    public void fallbackToSafe_FollowedByRecovery() throws IOException, JoranException, InterruptedException {\n        String path = CoreTestConstants.OUTPUT_DIR_PREFIX + \"reconfigureOnChangeConfig_fallbackToSafe-\" + diff + \".xml\";\n        File topLevelFile = new File(path);\n        writeToFile(topLevelFile, \"<configuration scan=\\\"true\\\" scanPeriod=\\\"5 millisecond\\\"><root level=\\\"ERROR\\\"/><\/configuration> \");\n        configure(topLevelFile);\n        StatusPrinter.print(loggerContext);\n        CountDownLatch changeDetectedLatch = waitForReconfigurationToBeDone(null);\n        ReconfigureOnChangeTask oldRoct = getRegisteredReconfigureTask();\n        assertNotNull(oldRoct);\n        \n        String badXML = \"<configuration scan=\\\"true\\\" scanPeriod=\\\"5 millisecond\\\">\\n\" + \"  <root><\/configuration>\";\n        writeToFile(topLevelFile, badXML);\n        System.out.println(\"Waiting for changeDetectedLatch.await()\");\n        changeDetectedLatch.await();\n        System.out.println(\"Woke from changeDetectedLatch.await()\");\n        \n        StatusPrinter.print(loggerContext);\n        \n        statusChecker.assertContainsMatch(Status.WARN, FALLING_BACK_TO_SAFE_CONFIGURATION);\n        statusChecker.assertContainsMatch(Status.INFO, RE_REGISTERING_PREVIOUS_SAFE_CONFIGURATION);\n\n        loggerContext.getStatusManager().clear();\n\n        CountDownLatch secondDoneLatch = waitForReconfigurationToBeDone(oldRoct);\n        writeToFile(topLevelFile, \"<configuration scan=\\\"true\\\" scanPeriod=\\\"5 millisecond\\\"><root level=\\\"ERROR\\\"/><\/configuration> \");\n        secondDoneLatch.await();\n        StatusPrinter.print(loggerContext);\n        statusChecker.assertIsErrorFree();\n        statusChecker.containsMatch(DETECTED_CHANGE_IN_CONFIGURATION_FILES);\n    }\n\n    @Test(timeout = 4000L)\n    public void fallbackToSafeWithIncludedFile_FollowedByRecovery() throws IOException, JoranException, InterruptedException, ExecutionException {\n        String topLevelFileAsStr = CoreTestConstants.OUTPUT_DIR_PREFIX + \"reconfigureOnChangeConfig_top-\" + diff + \".xml\";\n        String innerFileAsStr = CoreTestConstants.OUTPUT_DIR_PREFIX + \"reconfigureOnChangeConfig_inner-\" + diff + \".xml\";\n        File topLevelFile = new File(topLevelFileAsStr);\n        writeToFile(topLevelFile, \"<configuration xdebug=\\\"true\\\" scan=\\\"true\\\" scanPeriod=\\\"5 millisecond\\\"><include file=\\\"\" + innerFileAsStr\n                        + \"\\\"/><\/configuration> \");\n\n        File innerFile = new File(innerFileAsStr);\n        writeToFile(innerFile, \"<included><root level=\\\"ERROR\\\"/><\/included> \");\n        configure(topLevelFile);\n\n        StatusPrinter.print(loggerContext);\n        \n        CountDownLatch doneLatch = waitForReconfigurationToBeDone(null);\n        ReconfigureOnChangeTask oldRoct = getRegisteredReconfigureTask();\n        assertNotNull(oldRoct);\n        \n        writeToFile(innerFile, \"<included>\\n<root>\\n<\/included>\");\n        doneLatch.await();\n\n        statusChecker.assertContainsMatch(Status.WARN, FALLING_BACK_TO_SAFE_CONFIGURATION);\n        statusChecker.assertContainsMatch(Status.INFO, RE_REGISTERING_PREVIOUS_SAFE_CONFIGURATION);\n\n        loggerContext.getStatusManager().clear();\n\n        CountDownLatch secondDoneLatch = waitForReconfigurationToBeDone(oldRoct);\n        writeToFile(innerFile, \"<included><root level=\\\"ERROR\\\"/><\/included> \");\n        secondDoneLatch.await();\n        \n        StatusPrinter.print(loggerContext);\n        statusChecker.assertIsErrorFree();\n        statusChecker.containsMatch(DETECTED_CHANGE_IN_CONFIGURATION_FILES);\n    }\n\n    private ReconfigureOnChangeTask getRegisteredReconfigureTask() {\n        return (ReconfigureOnChangeTask) loggerContext.getObject(RECONFIGURE_ON_CHANGE_TASK);\n    }\n\n    class RunMethodInvokedListener extends ReconfigureOnChangeTaskListener {\n        CountDownLatch countDownLatch;\n\n        RunMethodInvokedListener(CountDownLatch countDownLatch) {\n            this.countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void enteredRunMethod() {\n            countDownLatch.countDown();\n        }\n    };\n\n    class ChangeDetectedListener extends ReconfigureOnChangeTaskListener {\n        CountDownLatch countDownLatch;\n\n        ChangeDetectedListener(CountDownLatch countDownLatch) {\n            this.countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void changeDetected() {\n            countDownLatch.countDown();\n        }\n    };\n\n    class ReconfigurationDoneListener extends ReconfigureOnChangeTaskListener {\n        CountDownLatch countDownLatch;\n\n        ReconfigurationDoneListener(CountDownLatch countDownLatch) {\n            this.countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void doneReconfiguring() {\n        \tSystem.out.println(\"ReconfigurationDoneListener now invoking countDownLatch.countDown()\");\n            countDownLatch.countDown();\n        }\n    };\n\n    private ReconfigureOnChangeTask waitForReconfigureOnChangeTaskToRun() throws InterruptedException {\n        ReconfigureOnChangeTask roct = null;\n        while (roct == null) {\n            roct = getRegisteredReconfigureTask();\n            Thread.yield();\n        }\n\n        CountDownLatch countDownLatch = new CountDownLatch(1);\n        roct.addListener(new RunMethodInvokedListener(countDownLatch));\n        countDownLatch.await();\n        return roct;\n    }\n\n    private CountDownLatch waitForReconfigurationToBeDone(ReconfigureOnChangeTask oldTask) throws InterruptedException {\n        ReconfigureOnChangeTask roct = oldTask;\n        while (roct == oldTask) {\n            roct = getRegisteredReconfigureTask();\n            Thread.yield();\n        }\n\n        CountDownLatch countDownLatch = new CountDownLatch(1);\n        roct.addListener(new ReconfigurationDoneListener(countDownLatch));\n        return countDownLatch;\n    }\n\n    private RunnableWithCounterAndDone[] buildRunnableArray(File configFile, UpdateType updateType) {\n        RunnableWithCounterAndDone[] rArray = new RunnableWithCounterAndDone[THREAD_COUNT];\n        rArray[0] = new Updater(configFile, updateType);\n        for (int i = 1; i < THREAD_COUNT; i++) {\n            rArray[i] = new LoggingRunnable(logger);\n        }\n        return rArray;\n    }\n\n    @Test\n    public void checkReconfigureTaskScheduledWhenDefaultScanPeriodUsed() throws JoranException {\n        File file = new File(SCAN_PERIOD_DEFAULT_FILE_AS_STR);\n        configure(file);\n\n        final List<ScheduledFuture<?>> scheduledFutures = loggerContext.getScheduledFutures();\n        StatusPrinter.print(loggerContext);\n        assertFalse(scheduledFutures.isEmpty());\n        statusChecker.containsMatch(\"No 'scanPeriod' specified. Defaulting to\");\n   \n    }\n\n    // check for deadlocks\n    @Test(timeout = 4000L)\n    public void scan_LOGBACK_474() throws JoranException, IOException, InterruptedException {\n        loggerContext.setName(\"scan_LOGBACK_474\");\n        File file = new File(SCAN_LOGBACK_474_FILE_AS_STR);\n        // StatusListenerConfigHelper.addOnConsoleListenerInstance(loggerContext, new OnConsoleStatusListener());\n        configure(file);\n\n        // ReconfigureOnChangeTask roct = waitForReconfigureOnChangeTaskToRun();\n\n        int expectedResets = 2;\n        Harness harness = new Harness(expectedResets);\n\n        RunnableWithCounterAndDone[] runnableArray = buildRunnableArray(file, UpdateType.TOUCH);\n        harness.execute(runnableArray);\n\n        loggerContext.getStatusManager().add(new InfoStatus(\"end of execution \", this));\n        StatusPrinter.print(loggerContext);\n        checkResetCount(expectedResets);\n    }\n\n    private void assertThatListContainsFile(List<File> fileList, File file) {\n        // conversion to absolute file seems to work nicely\n        assertTrue(fileList.contains(file.getAbsoluteFile()));\n    }\n\n    private void checkResetCount(int expected) {\n        StatusChecker checker = new StatusChecker(loggerContext);\n        checker.assertIsErrorFree();\n\n        int effectiveResets = checker.matchCount(CoreConstants.RESET_MSG_PREFIX);\n        assertEquals(expected, effectiveResets);\n\n        // String failMsg = \"effective=\" + effectiveResets + \", expected=\" + expected;\n        //\n        // there might be more effective resets than the expected amount\n        // since the harness may be sleeping while a reset occurs\n        // assertTrue(failMsg, expected <= effectiveResets && (expected + 2) >= effectiveResets);\n\n    }\n\n    void addInfo(String msg, Object o) {\n        loggerContext.getStatusManager().add(new InfoStatus(msg, o));\n    }\n\n    enum UpdateType {\n        TOUCH, MALFORMED, MALFORMED_INNER\n    }\n\n    void writeToFile(File file, String contents) throws IOException {\n    \tFileWriter fw = new FileWriter(file);\n        fw.write(contents);\n        fw.close();\n        // on linux changes to last modified are not propagated if the\n        // time stamp is near the previous time stamp hence the random delta\n        file.setLastModified(System.currentTimeMillis()+RandomUtil.getPositiveInt());\n    }\n\n    class Harness extends AbstractMultiThreadedHarness {\n        int changeCountLimit;\n\n        Harness(int changeCount) {\n            this.changeCountLimit = changeCount;\n        }\n\n        public void waitUntilEndCondition() throws InterruptedException {\n            ReconfigureOnChangeTaskTest.this.addInfo(\"Entering \" + this.getClass() + \".waitUntilEndCondition()\", this);\n\n            int changeCount = 0;\n            ReconfigureOnChangeTask lastRoct = null;\n            CountDownLatch countDownLatch = null;\n\n            while (changeCount < changeCountLimit) {\n                ReconfigureOnChangeTask roct = (ReconfigureOnChangeTask) loggerContext.getObject(RECONFIGURE_ON_CHANGE_TASK);\n                if (lastRoct != roct && roct != null) {\n                    lastRoct = roct;\n                    countDownLatch = new CountDownLatch(1);\n                    roct.addListener(new ChangeDetectedListener(countDownLatch));\n                } else if (countDownLatch != null) {\n                    countDownLatch.await();\n                    countDownLatch = null;\n                    changeCount++;\n                }\n                Thread.yield();\n            }\n            ReconfigureOnChangeTaskTest.this.addInfo(\"*****Exiting \" + this.getClass() + \".waitUntilEndCondition()\", this);\n        }\n\n    }\n\n    class Updater extends RunnableWithCounterAndDone {\n        File configFile;\n        UpdateType updateType;\n\n        // it actually takes time for Windows to propagate file modification changes\n        // values below 100 milliseconds can be problematic the same propagation\n        // latency occurs in Linux but is even larger (>600 ms)\n        // final static int DEFAULT_SLEEP_BETWEEN_UPDATES = 60;\n\n        int sleepBetweenUpdates = 100;\n\n        Updater(File configFile, UpdateType updateType) {\n            this.configFile = configFile;\n            this.updateType = updateType;\n        }\n\n        Updater(File configFile) {\n            this(configFile, UpdateType.TOUCH);\n        }\n\n        public void run() {\n            while (!isDone()) {\n                try {\n                    Thread.sleep(sleepBetweenUpdates);\n                } catch (InterruptedException e) {\n                }\n                if (isDone()) {\n                    ReconfigureOnChangeTaskTest.this.addInfo(\"Exiting Updater.run()\", this);\n                    return;\n                }\n                counter++;\n                ReconfigureOnChangeTaskTest.this.addInfo(\"Touching [\" + configFile + \"]\", this);\n                switch (updateType) {\n                case TOUCH:\n                    touchFile();\n                    break;\n                case MALFORMED:\n                    try {\n                        malformedUpdate();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                        fail(\"malformedUpdate failed\");\n                    }\n                    break;\n                case MALFORMED_INNER:\n                    try {\n                        malformedInnerUpdate();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                        fail(\"malformedInnerUpdate failed\");\n                    }\n                }\n            }\n            ReconfigureOnChangeTaskTest.this.addInfo(\"Exiting Updater.run()\", this);\n        }\n\n        private void malformedUpdate() throws IOException {\n            writeToFile(configFile, \"<configuration scan=\\\"true\\\" scanPeriod=\\\"50 millisecond\\\">\\n\" + \"  <root level=\\\"ERROR\\\">\\n\" + \"<\/configuration>\");\n        }\n\n        private void malformedInnerUpdate() throws IOException {\n            writeToFile(configFile, \"<included>\\n\" + \"  <root>\\n\" + \"<\/included>\");\n        }\n\n        void touchFile() {\n            configFile.setLastModified(System.currentTimeMillis());\n        }\n    }\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.joran;\n\nimport static ch.qos.logback.classic.ClassicTestConstants.JORAN_INPUT_PREFIX;\nimport static ch.qos.logback.classic.joran.ReconfigureOnChangeTask.DETECTED_CHANGE_IN_CONFIGURATION_FILES;\nimport static ch.qos.logback.classic.joran.ReconfigureOnChangeTask.FALLING_BACK_TO_SAFE_CONFIGURATION;\nimport static ch.qos.logback.classic.joran.ReconfigureOnChangeTask.RE_REGISTERING_PREVIOUS_SAFE_CONFIGURATION;\nimport static ch.qos.logback.core.CoreConstants.RECONFIGURE_ON_CHANGE_TASK;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ScheduledFuture;\n\nimport org.junit.BeforeClass;\nimport org.junit.Test;\n\nimport ch.qos.logback.classic.Logger;\nimport ch.qos.logback.classic.LoggerContext;\nimport ch.qos.logback.classic.issue.lbclassic135.LoggingRunnable;\nimport ch.qos.logback.core.CoreConstants;\nimport ch.qos.logback.core.contention.AbstractMultiThreadedHarness;\nimport ch.qos.logback.core.contention.RunnableWithCounterAndDone;\nimport ch.qos.logback.core.joran.spi.ConfigurationWatchList;\nimport ch.qos.logback.core.joran.spi.JoranException;\nimport ch.qos.logback.core.joran.util.ConfigurationWatchListUtil;\nimport ch.qos.logback.core.status.InfoStatus;\nimport ch.qos.logback.core.status.Status;\nimport ch.qos.logback.core.testUtil.CoreTestConstants;\nimport ch.qos.logback.core.testUtil.FileTestUtil;\nimport ch.qos.logback.core.testUtil.RandomUtil;\nimport ch.qos.logback.core.testUtil.StatusChecker;\nimport ch.qos.logback.core.util.StatusPrinter;\n\npublic class ReconfigureOnChangeTaskTest {\n    final static int THREAD_COUNT = 5;\n\n    int diff = RandomUtil.getPositiveInt();\n\n    // the space in the file name mandated by\n    // http://jira.qos.ch/browse/LBCORE-119\n    final static String SCAN1_FILE_AS_STR = JORAN_INPUT_PREFIX + \"roct/scan 1.xml\";\n\n    final static String G_SCAN1_FILE_AS_STR = JORAN_INPUT_PREFIX + \"roct/scan 1.groovy\";\n\n    final static String SCAN_LOGBACK_474_FILE_AS_STR = JORAN_INPUT_PREFIX + \"roct/scan_logback_474.xml\";\n\n    final static String INCLUSION_SCAN_TOPLEVEL0_AS_STR = JORAN_INPUT_PREFIX + \"roct/inclusion/topLevel0.xml\";\n\n    final static String INCLUSION_SCAN_TOP_BY_RESOURCE_AS_STR = JORAN_INPUT_PREFIX + \"roct/inclusion/topByResource.xml\";\n\n    final static String INCLUSION_SCAN_INNER0_AS_STR = JORAN_INPUT_PREFIX + \"roct/inclusion/inner0.xml\";\n\n    final static String INCLUSION_SCAN_INNER1_AS_STR = \"target/test-classes/asResource/inner1.xml\";\n\n    private static final String SCAN_PERIOD_DEFAULT_FILE_AS_STR =  JORAN_INPUT_PREFIX + \"roct/scan_period_default.xml\";\n    \n    LoggerContext loggerContext = new LoggerContext();\n    Logger logger = loggerContext.getLogger(this.getClass());\n    StatusChecker statusChecker = new StatusChecker(loggerContext);\n\n    @BeforeClass\n    static public void classSetup() {\n        FileTestUtil.makeTestOutputDir();\n    }\n\n    void configure(File file) throws JoranException {\n        JoranConfigurator jc = new JoranConfigurator();\n        jc.setContext(loggerContext);\n        jc.doConfigure(file);\n    }\n\n    void configure(InputStream is) throws JoranException {\n        JoranConfigurator jc = new JoranConfigurator();\n        jc.setContext(loggerContext);\n        jc.doConfigure(is);\n    }\n\n//    void gConfigure(File file) throws JoranException {\n//        GafferConfigurator gc = new GafferConfigurator(loggerContext);\n//        gc.run(file);\n//    }\n\n    @Test(timeout = 4000L)\n    public void checkBasicLifecyle() throws JoranException, IOException, InterruptedException {\n        File file = new File(SCAN1_FILE_AS_STR);\n        configure(file);\n        List<File> fileList = getConfigurationWatchList(loggerContext);\n        assertThatListContainsFile(fileList, file);\n        checkThatTaskHasRan();\n        checkThatTaskCanBeStopped();\n    }\n\n//    @Test(timeout = 4000L)\n//    public void checkBasicLifecyleWithGaffer() throws JoranException, IOException, InterruptedException {\n//        File file = new File(G_SCAN1_FILE_AS_STR);\n//        gConfigure(file);\n//        List<File> fileList = getConfigurationWatchList(loggerContext);\n//        assertThatListContainsFile(fileList, file);\n//        checkThatTaskHasRan();\n//        checkThatTaskCanBeStopped();\n//    }\n\n    private void checkThatTaskCanBeStopped() {\n        ScheduledFuture<?> future = loggerContext.getScheduledFutures().get(0);\n        loggerContext.stop();\n        assertTrue(future.isCancelled());\n    }\n\n    private void checkThatTaskHasRan() throws InterruptedException {\n        waitForReconfigureOnChangeTaskToRun();\n    }\n\n    List<File> getConfigurationWatchList(LoggerContext context) {\n        ConfigurationWatchList configurationWatchList = ConfigurationWatchListUtil.getConfigurationWatchList(loggerContext);\n        return configurationWatchList.getCopyOfFileWatchList();\n    }\n\n    @Test(timeout = 4000L)\n    public void scanWithFileInclusion() throws JoranException, IOException, InterruptedException {\n        File topLevelFile = new File(INCLUSION_SCAN_TOPLEVEL0_AS_STR);\n        File innerFile = new File(INCLUSION_SCAN_INNER0_AS_STR);\n        configure(topLevelFile);\n        List<File> fileList = getConfigurationWatchList(loggerContext);\n        assertThatListContainsFile(fileList, topLevelFile);\n        assertThatListContainsFile(fileList, innerFile);\n        checkThatTaskHasRan();\n        checkThatTaskCanBeStopped();\n    }\n\n    @Test(timeout = 4000L)\n    public void scanWithResourceInclusion() throws JoranException, IOException, InterruptedException {\n        File topLevelFile = new File(INCLUSION_SCAN_TOP_BY_RESOURCE_AS_STR);\n        File innerFile = new File(INCLUSION_SCAN_INNER1_AS_STR);\n        configure(topLevelFile);\n        List<File> fileList = getConfigurationWatchList(loggerContext);\n        assertThatListContainsFile(fileList, topLevelFile);\n        assertThatListContainsFile(fileList, innerFile);\n    }\n\n    // See also http://jira.qos.ch/browse/LOGBACK-338\n    @Test(timeout = 4000L)\n    public void reconfigurationIsNotPossibleInTheAbsenceOfATopFile() throws IOException, JoranException, InterruptedException {\n        String configurationStr = \"<configuration scan=\\\"true\\\" scanPeriod=\\\"50 millisecond\\\"><include resource=\\\"asResource/inner1.xml\\\"/><\/configuration>\";\n        configure(new ByteArrayInputStream(configurationStr.getBytes(\"UTF-8\")));\n\n        ConfigurationWatchList configurationWatchList = ConfigurationWatchListUtil.getConfigurationWatchList(loggerContext);\n        assertNull(configurationWatchList);\n        // assertNull(configurationWatchList.getMainURL());\n\n        statusChecker.containsMatch(Status.WARN, \"Due to missing top level\");\n        StatusPrinter.print(loggerContext);\n        ReconfigureOnChangeTask roct = getRegisteredReconfigureTask();\n        assertNull(roct);\n        assertEquals(0, loggerContext.getScheduledFutures().size());\n    }\n\n    @Test(timeout = 3000L)\n    public void fallbackToSafe_FollowedByRecovery() throws IOException, JoranException, InterruptedException {\n        String path = CoreTestConstants.OUTPUT_DIR_PREFIX + \"reconfigureOnChangeConfig_fallbackToSafe-\" + diff + \".xml\";\n        File topLevelFile = new File(path);\n        writeToFile(topLevelFile, \"<configuration scan=\\\"true\\\" scanPeriod=\\\"5 millisecond\\\"><root level=\\\"ERROR\\\"/><\/configuration> \");\n        configure(topLevelFile);\n        CountDownLatch changeDetectedLatch = waitForReconfigurationToBeDone(null);\n        ReconfigureOnChangeTask oldRoct = getRegisteredReconfigureTask();\n        assertNotNull(oldRoct);\n        writeToFile(topLevelFile, \"<configuration scan=\\\"true\\\" scanPeriod=\\\"5 millisecond\\\">\\n\" + \"  <root><\/configuration>\");\n        changeDetectedLatch.await();\n        statusChecker.assertContainsMatch(Status.WARN, FALLING_BACK_TO_SAFE_CONFIGURATION);\n        statusChecker.assertContainsMatch(Status.INFO, RE_REGISTERING_PREVIOUS_SAFE_CONFIGURATION);\n\n        loggerContext.getStatusManager().clear();\n\n        CountDownLatch secondDoneLatch = waitForReconfigurationToBeDone(oldRoct);\n        writeToFile(topLevelFile, \"<configuration scan=\\\"true\\\" scanPeriod=\\\"5 millisecond\\\"><root level=\\\"ERROR\\\"/><\/configuration> \");\n        secondDoneLatch.await();\n        StatusPrinter.print(loggerContext);\n        statusChecker.assertIsErrorFree();\n        statusChecker.containsMatch(DETECTED_CHANGE_IN_CONFIGURATION_FILES);\n    }\n\n    @Test(timeout = 4000L)\n    public void fallbackToSafeWithIncludedFile_FollowedByRecovery() throws IOException, JoranException, InterruptedException, ExecutionException {\n        String topLevelFileAsStr = CoreTestConstants.OUTPUT_DIR_PREFIX + \"reconfigureOnChangeConfig_top-\" + diff + \".xml\";\n        String innerFileAsStr = CoreTestConstants.OUTPUT_DIR_PREFIX + \"reconfigureOnChangeConfig_inner-\" + diff + \".xml\";\n        File topLevelFile = new File(topLevelFileAsStr);\n        writeToFile(topLevelFile, \"<configuration xdebug=\\\"true\\\" scan=\\\"true\\\" scanPeriod=\\\"5 millisecond\\\"><include file=\\\"\" + innerFileAsStr\n                        + \"\\\"/><\/configuration> \");\n\n        File innerFile = new File(innerFileAsStr);\n        writeToFile(innerFile, \"<included><root level=\\\"ERROR\\\"/><\/included> \");\n        configure(topLevelFile);\n\n        CountDownLatch doneLatch = waitForReconfigurationToBeDone(null);\n        ReconfigureOnChangeTask oldRoct = getRegisteredReconfigureTask();\n        assertNotNull(oldRoct);\n        \n        writeToFile(innerFile, \"<included>\\n<root>\\n<\/included>\");\n        doneLatch.await();\n\n        statusChecker.assertContainsMatch(Status.WARN, FALLING_BACK_TO_SAFE_CONFIGURATION);\n        statusChecker.assertContainsMatch(Status.INFO, RE_REGISTERING_PREVIOUS_SAFE_CONFIGURATION);\n\n        loggerContext.getStatusManager().clear();\n\n        CountDownLatch secondDoneLatch = waitForReconfigurationToBeDone(oldRoct);\n        writeToFile(innerFile, \"<included><root level=\\\"ERROR\\\"/><\/included> \");\n        secondDoneLatch.await();\n        \n        StatusPrinter.print(loggerContext);\n        statusChecker.assertIsErrorFree();\n        statusChecker.containsMatch(DETECTED_CHANGE_IN_CONFIGURATION_FILES);\n    }\n\n    private ReconfigureOnChangeTask getRegisteredReconfigureTask() {\n        return (ReconfigureOnChangeTask) loggerContext.getObject(RECONFIGURE_ON_CHANGE_TASK);\n    }\n\n    class RunMethodInvokedListener extends ReconfigureOnChangeTaskListener {\n        CountDownLatch countDownLatch;\n\n        RunMethodInvokedListener(CountDownLatch countDownLatch) {\n            this.countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void enteredRunMethod() {\n            countDownLatch.countDown();\n        }\n    };\n\n    class ChangeDetectedListener extends ReconfigureOnChangeTaskListener {\n        CountDownLatch countDownLatch;\n\n        ChangeDetectedListener(CountDownLatch countDownLatch) {\n            this.countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void changeDetected() {\n            countDownLatch.countDown();\n        }\n    };\n\n    class ReconfigurationDoneListener extends ReconfigureOnChangeTaskListener {\n        CountDownLatch countDownLatch;\n\n        ReconfigurationDoneListener(CountDownLatch countDownLatch) {\n            this.countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void doneReconfiguring() {\n            countDownLatch.countDown();\n        }\n    };\n\n    private ReconfigureOnChangeTask waitForReconfigureOnChangeTaskToRun() throws InterruptedException {\n        ReconfigureOnChangeTask roct = null;\n        while (roct == null) {\n            roct = getRegisteredReconfigureTask();\n            Thread.yield();\n        }\n\n        CountDownLatch countDownLatch = new CountDownLatch(1);\n        roct.addListener(new RunMethodInvokedListener(countDownLatch));\n        countDownLatch.await();\n        return roct;\n    }\n\n    private CountDownLatch waitForReconfigurationToBeDone(ReconfigureOnChangeTask oldTask) throws InterruptedException {\n        ReconfigureOnChangeTask roct = oldTask;\n        while (roct == oldTask) {\n            roct = getRegisteredReconfigureTask();\n            Thread.yield();\n        }\n\n        CountDownLatch countDownLatch = new CountDownLatch(1);\n        roct.addListener(new ReconfigurationDoneListener(countDownLatch));\n        return countDownLatch;\n    }\n\n    private RunnableWithCounterAndDone[] buildRunnableArray(File configFile, UpdateType updateType) {\n        RunnableWithCounterAndDone[] rArray = new RunnableWithCounterAndDone[THREAD_COUNT];\n        rArray[0] = new Updater(configFile, updateType);\n        for (int i = 1; i < THREAD_COUNT; i++) {\n            rArray[i] = new LoggingRunnable(logger);\n        }\n        return rArray;\n    }\n\n    @Test\n    public void checkReconfigureTaskScheduledWhenDefaultScanPeriodUsed() throws JoranException {\n        File file = new File(SCAN_PERIOD_DEFAULT_FILE_AS_STR);\n        configure(file);\n\n        final List<ScheduledFuture<?>> scheduledFutures = loggerContext.getScheduledFutures();\n        StatusPrinter.print(loggerContext);\n        assertFalse(scheduledFutures.isEmpty());\n        statusChecker.containsMatch(\"No 'scanPeriod' specified. Defaulting to\");\n   \n    }\n\n    // check for deadlocks\n    @Test(timeout = 4000L)\n    public void scan_LOGBACK_474() throws JoranException, IOException, InterruptedException {\n        loggerContext.setName(\"scan_LOGBACK_474\");\n        File file = new File(SCAN_LOGBACK_474_FILE_AS_STR);\n        // StatusListenerConfigHelper.addOnConsoleListenerInstance(loggerContext, new OnConsoleStatusListener());\n        configure(file);\n\n        // ReconfigureOnChangeTask roct = waitForReconfigureOnChangeTaskToRun();\n\n        int expectedResets = 2;\n        Harness harness = new Harness(expectedResets);\n\n        RunnableWithCounterAndDone[] runnableArray = buildRunnableArray(file, UpdateType.TOUCH);\n        harness.execute(runnableArray);\n\n        loggerContext.getStatusManager().add(new InfoStatus(\"end of execution \", this));\n        StatusPrinter.print(loggerContext);\n        checkResetCount(expectedResets);\n    }\n\n    private void assertThatListContainsFile(List<File> fileList, File file) {\n        // conversion to absolute file seems to work nicely\n        assertTrue(fileList.contains(file.getAbsoluteFile()));\n    }\n\n    private void checkResetCount(int expected) {\n        StatusChecker checker = new StatusChecker(loggerContext);\n        checker.assertIsErrorFree();\n\n        int effectiveResets = checker.matchCount(CoreConstants.RESET_MSG_PREFIX);\n        assertEquals(expected, effectiveResets);\n\n        // String failMsg = \"effective=\" + effectiveResets + \", expected=\" + expected;\n        //\n        // there might be more effective resets than the expected amount\n        // since the harness may be sleeping while a reset occurs\n        // assertTrue(failMsg, expected <= effectiveResets && (expected + 2) >= effectiveResets);\n\n    }\n\n    void addInfo(String msg, Object o) {\n        loggerContext.getStatusManager().add(new InfoStatus(msg, o));\n    }\n\n    enum UpdateType {\n        TOUCH, MALFORMED, MALFORMED_INNER\n    }\n\n    void writeToFile(File file, String contents) throws IOException {\n    \tFileWriter fw = new FileWriter(file);\n        fw.write(contents);\n        fw.close();\n        // on linux changes to last modified are not propagated if the\n        // time stamp is near the previous time stamp hence the random delta\n        file.setLastModified(System.currentTimeMillis()+RandomUtil.getPositiveInt());\n    }\n\n    class Harness extends AbstractMultiThreadedHarness {\n        int changeCountLimit;\n\n        Harness(int changeCount) {\n            this.changeCountLimit = changeCount;\n        }\n\n        public void waitUntilEndCondition() throws InterruptedException {\n            ReconfigureOnChangeTaskTest.this.addInfo(\"Entering \" + this.getClass() + \".waitUntilEndCondition()\", this);\n\n            int changeCount = 0;\n            ReconfigureOnChangeTask lastRoct = null;\n            CountDownLatch countDownLatch = null;\n\n            while (changeCount < changeCountLimit) {\n                ReconfigureOnChangeTask roct = (ReconfigureOnChangeTask) loggerContext.getObject(RECONFIGURE_ON_CHANGE_TASK);\n                if (lastRoct != roct && roct != null) {\n                    lastRoct = roct;\n                    countDownLatch = new CountDownLatch(1);\n                    roct.addListener(new ChangeDetectedListener(countDownLatch));\n                } else if (countDownLatch != null) {\n                    countDownLatch.await();\n                    countDownLatch = null;\n                    changeCount++;\n                }\n                Thread.yield();\n            }\n            ReconfigureOnChangeTaskTest.this.addInfo(\"*****Exiting \" + this.getClass() + \".waitUntilEndCondition()\", this);\n        }\n\n    }\n\n    class Updater extends RunnableWithCounterAndDone {\n        File configFile;\n        UpdateType updateType;\n\n        // it actually takes time for Windows to propagate file modification changes\n        // values below 100 milliseconds can be problematic the same propagation\n        // latency occurs in Linux but is even larger (>600 ms)\n        // final static int DEFAULT_SLEEP_BETWEEN_UPDATES = 60;\n\n        int sleepBetweenUpdates = 100;\n\n        Updater(File configFile, UpdateType updateType) {\n            this.configFile = configFile;\n            this.updateType = updateType;\n        }\n\n        Updater(File configFile) {\n            this(configFile, UpdateType.TOUCH);\n        }\n\n        public void run() {\n            while (!isDone()) {\n                try {\n                    Thread.sleep(sleepBetweenUpdates);\n                } catch (InterruptedException e) {\n                }\n                if (isDone()) {\n                    ReconfigureOnChangeTaskTest.this.addInfo(\"Exiting Updater.run()\", this);\n                    return;\n                }\n                counter++;\n                ReconfigureOnChangeTaskTest.this.addInfo(\"Touching [\" + configFile + \"]\", this);\n                switch (updateType) {\n                case TOUCH:\n                    touchFile();\n                    break;\n                case MALFORMED:\n                    try {\n                        malformedUpdate();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                        fail(\"malformedUpdate failed\");\n                    }\n                    break;\n                case MALFORMED_INNER:\n                    try {\n                        malformedInnerUpdate();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                        fail(\"malformedInnerUpdate failed\");\n                    }\n                }\n            }\n            ReconfigureOnChangeTaskTest.this.addInfo(\"Exiting Updater.run()\", this);\n        }\n\n        private void malformedUpdate() throws IOException {\n            writeToFile(configFile, \"<configuration scan=\\\"true\\\" scanPeriod=\\\"50 millisecond\\\">\\n\" + \"  <root level=\\\"ERROR\\\">\\n\" + \"<\/configuration>\");\n        }\n\n        private void malformedInnerUpdate() throws IOException {\n            writeToFile(configFile, \"<included>\\n\" + \"  <root>\\n\" + \"<\/included>\");\n        }\n\n        void touchFile() {\n            configFile.setLastModified(System.currentTimeMillis());\n        }\n    }\n\n}\n","lineNo":192}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic;\n\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * Defines the set of levels recognized by logback-classic, that is {@link #OFF},\n * {@link #ERROR}, {@link #WARN}, {@link #INFO}, {@link #DEBUG},\n * {@link #TRACE} and {@link #ALL}. <p/> The <code>Level<\/code> class is\n * final and cannot be sub-classed.\n * <\/p>\n */\npublic final class Level implements java.io.Serializable {\n\n    private static final long serialVersionUID = -814092767334282137L;\n\n    public static final int OFF_INT = Integer.MAX_VALUE;\n    public static final int ERROR_INT = 40000;\n    public static final int WARN_INT = 30000;\n    public static final int INFO_INT = 20000;\n    public static final int DEBUG_INT = 10000;\n    public static final int TRACE_INT = 5000;\n    public static final int ALL_INT = Integer.MIN_VALUE;\n\n    public static final Integer OFF_INTEGER = OFF_INT;\n    public static final Integer ERROR_INTEGER = ERROR_INT;\n    public static final Integer WARN_INTEGER = WARN_INT;\n    public static final Integer INFO_INTEGER = INFO_INT;\n    public static final Integer DEBUG_INTEGER = DEBUG_INT;\n    public static final Integer TRACE_INTEGER = TRACE_INT;\n    public static final Integer ALL_INTEGER = ALL_INT;\n\n    /**\n     * The <code>OFF<\/code> is used to turn off logging.\n     */\n    public static final Level OFF = new Level(OFF_INT, \"OFF\");\n\n    /**\n     * The <code>ERROR<\/code> level designates error events which may or not\n     * be fatal to the application.\n     */\n    public static final Level ERROR = new Level(ERROR_INT, \"ERROR\");\n\n    /**\n     * The <code>WARN<\/code> level designates potentially harmful situations.\n     */\n    public static final Level WARN = new Level(WARN_INT, \"WARN\");\n\n    /**\n     * The <code>INFO<\/code> level designates informational messages\n     * highlighting overall progress of the application.\n     */\n    public static final Level INFO = new Level(INFO_INT, \"INFO\");\n\n    /**\n     * The <code>DEBUG<\/code> level designates informational events of lower\n     * importance.\n     */\n    public static final Level DEBUG = new Level(DEBUG_INT, \"DEBUG\");\n\n    /**\n     * The <code>TRACE<\/code> level designates informational events of very low\n     * importance.\n     */\n    public static final Level TRACE = new Level(TRACE_INT, \"TRACE\");\n\n    /**\n     * The <code>ALL<\/code> is used to turn on all logging.\n     */\n    public static final Level ALL = new Level(ALL_INT, \"ALL\");\n\n    public final int levelInt;\n    public final String levelStr;\n\n    /**\n     * Instantiate a Level object.\n     */\n    private Level(int levelInt, String levelStr) {\n        this.levelInt = levelInt;\n        this.levelStr = levelStr;\n    }\n\n    /**\n     * Returns the string representation of this Level.\n     */\n    public String toString() {\n        return levelStr;\n    }\n\n    /**\n     * Returns the integer representation of this Level.\n     */\n    public int toInt() {\n        return levelInt;\n    }\n\n    /**\n     * Convert a Level to an Integer object.\n     *\n     * @return This level's Integer mapping.\n     */\n    public Integer toInteger() {\n        switch (levelInt) {\n        case ALL_INT:\n            return ALL_INTEGER;\n        case TRACE_INT:\n            return TRACE_INTEGER;\n        case DEBUG_INT:\n            return DEBUG_INTEGER;\n        case INFO_INT:\n            return INFO_INTEGER;\n        case WARN_INT:\n            return WARN_INTEGER;\n        case ERROR_INT:\n            return ERROR_INTEGER;\n        case OFF_INT:\n            return OFF_INTEGER;\n        default:\n            throw new IllegalStateException(\"Level \" + levelStr + \", \" + levelInt + \" is unknown.\");\n        }\n    }\n\n    /**\n     * Returns <code>true<\/code> if this Level has a higher or equal Level than\n     * the Level passed as argument, <code>false<\/code> otherwise.\n     */\n    public boolean isGreaterOrEqual(Level r) {\n        return levelInt >= r.levelInt;\n    }\n\n    /**\n     * Convert the string passed as argument to a Level. If the conversion fails,\n     * then this method returns {@link #DEBUG}.\n     */\n    public static Level toLevel(String sArg) {\n        return toLevel(sArg, Level.DEBUG);\n    }\n\n    /**\n     * This method exists in order to comply with Joran's valueOf convention.\n     *\n     * @param sArg\n     * @return\n     */\n    public static Level valueOf(String sArg) {\n        return toLevel(sArg, Level.DEBUG);\n    }\n\n    /**\n     * Convert an integer passed as argument to a Level. If the conversion fails,\n     * then this method returns {@link #DEBUG}.\n     */\n    public static Level toLevel(int val) {\n        return toLevel(val, Level.DEBUG);\n    }\n\n    /**\n     * Convert an integer passed as argument to a Level. If the conversion fails,\n     * then this method returns the specified default.\n     */\n    public static Level toLevel(int val, Level defaultLevel) {\n        switch (val) {\n        case ALL_INT:\n            return ALL;\n        case TRACE_INT:\n            return TRACE;\n        case DEBUG_INT:\n            return DEBUG;\n        case INFO_INT:\n            return INFO;\n        case WARN_INT:\n            return WARN;\n        case ERROR_INT:\n            return ERROR;\n        case OFF_INT:\n            return OFF;\n        default:\n            return defaultLevel;\n        }\n    }\n\n    /**\n     * Convert the string passed as argument to a Level. If the conversion fails,\n     * then this method returns the value of <code>defaultLevel<\/code>.\n     */\n    public static Level toLevel(final String sArg, Level defaultLevel) {\n        if (sArg == null) {\n            return defaultLevel;\n        }\n\n        // see LOGBACK-1288\n        final String in = sArg.trim();\n        \n        if (in.equalsIgnoreCase(\"ALL\")) {\n            return Level.ALL;\n        }\n        if (in.equalsIgnoreCase(\"TRACE\")) {\n            return Level.TRACE;\n        }\n        if (in.equalsIgnoreCase(\"DEBUG\")) {\n            return Level.DEBUG;\n        }\n        if (in.equalsIgnoreCase(\"INFO\")) {\n            return Level.INFO;\n        }\n        if (in.equalsIgnoreCase(\"WARN\")) {\n            return Level.WARN;\n        }\n        if (in.equalsIgnoreCase(\"ERROR\")) {\n            return Level.ERROR;\n        }\n        if (in.equalsIgnoreCase(\"OFF\")) {\n            return Level.OFF;\n        }\n        return defaultLevel;\n    }\n\n    /**\n     * Return the flyweight instance of the level received through serizalization,\n     * i.e. 'this'.\n     *\n     * @return The appropriate flyweight instance\n     */\n    private Object readResolve() {\n        return toLevel(this.levelInt);\n    }\n\n    /**\n     * Convert one of the integer values defined in {@link LocationAwareLogger}\n     * interface to an instance of this class, i.e. a Level.\n     *\n     * @param levelInt An integer value representing a level as defined in LocationAwareLogger\n     * @return an instance of this class, i.e. a Level.\n     * @since 1.0.1\n     */\n    public static Level fromLocationAwareLoggerInteger(int levelInt) {\n        Level level;\n        switch (levelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            level = TRACE;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            level = DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            level = INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            level = WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            level = ERROR;\n            break;\n        default:\n            throw new IllegalArgumentException(levelInt + \" not a valid level value\");\n        }\n        return level;\n    }\n\n    /**\n     * Convert this level instance to an integer  value defined in the\n     * {@link LocationAwareLogger} interface.\n     *\n     * @param level The level to convert to LocationAwareLogger integer\n     * @return int An integer corresponding to this level as defined in LocationAwareLogger\n     * @since 1.0.1\n     */\n    public static int toLocationAwareLoggerInteger(Level level) {\n        if (level == null)\n            throw new IllegalArgumentException(\"null level parameter is not admitted\");\n        switch (level.toInt()) {\n        case Level.TRACE_INT:\n            return LocationAwareLogger.TRACE_INT;\n        case Level.DEBUG_INT:\n            return LocationAwareLogger.DEBUG_INT;\n        case Level.INFO_INT:\n            return LocationAwareLogger.INFO_INT;\n        case Level.WARN_INT:\n            return LocationAwareLogger.WARN_INT;\n        case Level.ERROR_INT:\n            return LocationAwareLogger.ERROR_INT;\n        default:\n            throw new IllegalArgumentException(level + \" not a valid level value\");\n        }\n    }\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic;\n\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * Defines the set of levels recognized by logback-classic, that is {@link #OFF},\n * {@link #ERROR}, {@link #WARN}, {@link #INFO}, {@link #DEBUG},\n * {@link #TRACE} and {@link #ALL}. <p/> The <code>Level<\/code> class is\n * final and cannot be sub-classed.\n * <\/p>\n */\npublic final class Level implements java.io.Serializable {\n\n    private static final long serialVersionUID = -814092767334282137L;\n\n    public static final int OFF_INT = Integer.MAX_VALUE;\n    public static final int ERROR_INT = 40000;\n    public static final int WARN_INT = 30000;\n    public static final int INFO_INT = 20000;\n    public static final int DEBUG_INT = 10000;\n    public static final int TRACE_INT = 5000;\n    public static final int ALL_INT = Integer.MIN_VALUE;\n\n    public static final Integer OFF_INTEGER = OFF_INT;\n    public static final Integer ERROR_INTEGER = ERROR_INT;\n    public static final Integer WARN_INTEGER = WARN_INT;\n    public static final Integer INFO_INTEGER = INFO_INT;\n    public static final Integer DEBUG_INTEGER = DEBUG_INT;\n    public static final Integer TRACE_INTEGER = TRACE_INT;\n    public static final Integer ALL_INTEGER = ALL_INT;\n\n    /**\n     * The <code>OFF<\/code> is used to turn off logging.\n     */\n    public static final Level OFF = new Level(OFF_INT, \"OFF\");\n\n    /**\n     * The <code>ERROR<\/code> level designates error events which may or not\n     * be fatal to the application.\n     */\n    public static final Level ERROR = new Level(ERROR_INT, \"ERROR\");\n\n    /**\n     * The <code>WARN<\/code> level designates potentially harmful situations.\n     */\n    public static final Level WARN = new Level(WARN_INT, \"WARN\");\n\n    /**\n     * The <code>INFO<\/code> level designates informational messages\n     * highlighting overall progress of the application.\n     */\n    public static final Level INFO = new Level(INFO_INT, \"INFO\");\n\n    /**\n     * The <code>DEBUG<\/code> level designates informational events of lower\n     * importance.\n     */\n    public static final Level DEBUG = new Level(DEBUG_INT, \"DEBUG\");\n\n    /**\n     * The <code>TRACE<\/code> level designates informational events of very low\n     * importance.\n     */\n    public static final Level TRACE = new Level(TRACE_INT, \"TRACE\");\n\n    /**\n     * The <code>ALL<\/code> is used to turn on all logging.\n     */\n    public static final Level ALL = new Level(ALL_INT, \"ALL\");\n\n    public final int levelInt;\n    public final String levelStr;\n\n    /**\n     * Instantiate a Level object.\n     */\n    private Level(int levelInt, String levelStr) {\n        this.levelInt = levelInt;\n        this.levelStr = levelStr;\n    }\n\n    /**\n     * Returns the string representation of this Level.\n     */\n    public String toString() {\n        return levelStr;\n    }\n\n    /**\n     * Returns the integer representation of this Level.\n     */\n    public int toInt() {\n        return levelInt;\n    }\n\n    /**\n     * Convert a Level to an Integer object.\n     *\n     * @return This level's Integer mapping.\n     */\n    public Integer toInteger() {\n        switch (levelInt) {\n        case ALL_INT:\n            return ALL_INTEGER;\n        case TRACE_INT:\n            return TRACE_INTEGER;\n        case DEBUG_INT:\n            return DEBUG_INTEGER;\n        case INFO_INT:\n            return INFO_INTEGER;\n        case WARN_INT:\n            return WARN_INTEGER;\n        case ERROR_INT:\n            return ERROR_INTEGER;\n        case OFF_INT:\n            return OFF_INTEGER;\n        default:\n            throw new IllegalStateException(\"Level \" + levelStr + \", \" + levelInt + \" is unknown.\");\n        }\n    }\n\n    /**\n     * Returns <code>true<\/code> if this Level has a higher or equal Level than\n     * the Level passed as argument, <code>false<\/code> otherwise.\n     */\n    public boolean isGreaterOrEqual(Level r) {\n        return levelInt >= r.levelInt;\n    }\n\n    /**\n     * Convert the string passed as argument to a Level. If the conversion fails,\n     * then this method returns {@link #DEBUG}.\n     */\n    public static Level toLevel(String sArg) {\n        return toLevel(sArg, Level.DEBUG);\n    }\n\n    /**\n     * This method exists in order to comply with Joran's valueOf convention.\n     *\n     * @param sArg\n     * @return\n     */\n    public static Level valueOf(String sArg) {\n        return toLevel(sArg, Level.DEBUG);\n    }\n\n    /**\n     * Convert an integer passed as argument to a Level. If the conversion fails,\n     * then this method returns {@link #DEBUG}.\n     */\n    public static Level toLevel(int val) {\n        return toLevel(val, Level.DEBUG);\n    }\n\n    /**\n     * Convert an integer passed as argument to a Level. If the conversion fails,\n     * then this method returns the specified default.\n     */\n    public static Level toLevel(int val, Level defaultLevel) {\n        switch (val) {\n        case ALL_INT:\n            return ALL;\n        case TRACE_INT:\n            return TRACE;\n        case DEBUG_INT:\n            return DEBUG;\n        case INFO_INT:\n            return INFO;\n        case WARN_INT:\n            return WARN;\n        case ERROR_INT:\n            return ERROR;\n        case OFF_INT:\n            return OFF;\n        default:\n            return defaultLevel;\n        }\n    }\n\n    /**\n     * Convert the string passed as argument to a Level. If the conversion fails,\n     * then this method returns the value of <code>defaultLevel<\/code>.\n     */\n    public static Level toLevel(String sArg, Level defaultLevel) {\n        if (sArg == null) {\n            return defaultLevel;\n        }\n\n        if (sArg.equalsIgnoreCase(\"ALL\")) {\n            return Level.ALL;\n        }\n        if (sArg.equalsIgnoreCase(\"TRACE\")) {\n            return Level.TRACE;\n        }\n        if (sArg.equalsIgnoreCase(\"DEBUG\")) {\n            return Level.DEBUG;\n        }\n        if (sArg.equalsIgnoreCase(\"INFO\")) {\n            return Level.INFO;\n        }\n        if (sArg.equalsIgnoreCase(\"WARN\")) {\n            return Level.WARN;\n        }\n        if (sArg.equalsIgnoreCase(\"ERROR\")) {\n            return Level.ERROR;\n        }\n        if (sArg.equalsIgnoreCase(\"OFF\")) {\n            return Level.OFF;\n        }\n        return defaultLevel;\n    }\n\n    /**\n     * Return the flyweight instance of the level received through serizalization,\n     * i.e. 'this'.\n     *\n     * @return The appropriate flyweight instance\n     */\n    private Object readResolve() {\n        return toLevel(this.levelInt);\n    }\n\n    /**\n     * Convert one of the integer values defined in {@link LocationAwareLogger}\n     * interface to an instance of this class, i.e. a Level.\n     *\n     * @param levelInt An integer value representing a level as defined in LocationAwareLogger\n     * @return an instance of this class, i.e. a Level.\n     * @since 1.0.1\n     */\n    public static Level fromLocationAwareLoggerInteger(int levelInt) {\n        Level level;\n        switch (levelInt) {\n        case LocationAwareLogger.TRACE_INT:\n            level = TRACE;\n            break;\n        case LocationAwareLogger.DEBUG_INT:\n            level = DEBUG;\n            break;\n        case LocationAwareLogger.INFO_INT:\n            level = INFO;\n            break;\n        case LocationAwareLogger.WARN_INT:\n            level = WARN;\n            break;\n        case LocationAwareLogger.ERROR_INT:\n            level = ERROR;\n            break;\n        default:\n            throw new IllegalArgumentException(levelInt + \" not a valid level value\");\n        }\n        return level;\n    }\n\n    /**\n     * Convert this level instance to an integer  value defined in the\n     * {@link LocationAwareLogger} interface.\n     *\n     * @param level The level to convert to LocationAwareLogger integer\n     * @return int An integer corresponding to this level as defined in LocationAwareLogger\n     * @since 1.0.1\n     */\n    public static int toLocationAwareLoggerInteger(Level level) {\n        if (level == null)\n            throw new IllegalArgumentException(\"null level parameter is not admitted\");\n        switch (level.toInt()) {\n        case Level.TRACE_INT:\n            return LocationAwareLogger.TRACE_INT;\n        case Level.DEBUG_INT:\n            return LocationAwareLogger.DEBUG_INT;\n        case Level.INFO_INT:\n            return LocationAwareLogger.INFO_INT;\n        case Level.WARN_INT:\n            return LocationAwareLogger.WARN_INT;\n        case Level.ERROR_INT:\n            return LocationAwareLogger.ERROR_INT;\n        default:\n            throw new IllegalArgumentException(level + \" not a valid level value\");\n        }\n    }\n}\n","lineNo":204}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.util;\n\n/**\n * @author Ceki G&uuml;lc&uuml;\n */\npublic class EnvUtil {\n\n\tprivate EnvUtil() {\n\t}\n\n\tstatic public int getJDKVersion(String javaVersionStr) {\n\t\tint version = 0;\n\t\t\n\t\tfor (char ch : javaVersionStr.toCharArray()) {\n\t\t\tif (Character.isDigit(ch)) {\n\t\t\t\tversion = (version * 10) + (ch - 48);\n\t\t\t} else if (version == 1) {\n\t\t\t\tversion = 0;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn version;\n\t}\n\n\tstatic private boolean isJDK_N_OrHigher(int n) {\n\t\tString javaVersionStr = System.getProperty(\"java.version\", \"\");\n\t\tif (javaVersionStr.isEmpty())\n\t\t\treturn false;\n\n\t\tint version = getJDKVersion(javaVersionStr);\n\t\treturn version > 0 && n <= version;\n\t}\n\n\tstatic public boolean isJDK5() {\n\t\treturn isJDK_N_OrHigher(5);\n\t}\n\n\tstatic public boolean isJDK6OrHigher() {\n\t\treturn isJDK_N_OrHigher(6);\n\t}\n\n\tstatic public boolean isJDK7OrHigher() {\n\t\treturn isJDK_N_OrHigher(7);\n\t}\n\n\tstatic public boolean isJaninoAvailable() {\n\t\tClassLoader classLoader = EnvUtil.class.getClassLoader();\n\t\ttry {\n\t\t\tClass<?> bindingClass = classLoader.loadClass(\"org.codehaus.janino.ScriptEvaluator\");\n\t\t\treturn (bindingClass != null);\n\t\t} catch (ClassNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic static boolean isWindows() {\n\t\tString os = System.getProperty(\"os.name\");\n\t\treturn os.startsWith(\"Windows\");\n\t}\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.util;\n\n/**\n * @author Ceki G&uuml;lc&uuml;\n */\npublic class EnvUtil {\n\n    private EnvUtil() {}\n\n    static private boolean isJDK_N_OrHigher(int n) {\n        int version = 0;\n        for (byte ch : System.getProperty(\"java.version\", \"\").getBytes()) {\n            if (Character.isDigit(ch)) {\n                version = (version * 10) + (ch - 48);\n            } else if (version == 1) {\n                version = 0;\n            } else {\n                break;\n            }\n        }\n        return version > 0 && n <= version;\n    }\n\n    static public boolean isJDK5() {\n        return isJDK_N_OrHigher(5);\n    }\n\n    static public boolean isJDK6OrHigher() {\n        return isJDK_N_OrHigher(6);\n    }\n\n    static public boolean isJDK7OrHigher() {\n        return isJDK_N_OrHigher(7);\n    }\n\n    static public boolean isJaninoAvailable() {\n        ClassLoader classLoader = EnvUtil.class.getClassLoader();\n        try {\n            Class<?> bindingClass = classLoader.loadClass(\"org.codehaus.janino.ScriptEvaluator\");\n            return (bindingClass != null);\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n\n    public static boolean isWindows() {\n        String os = System.getProperty(\"os.name\");\n        return os.startsWith(\"Windows\");\n    }\n\n}\n","lineNo":40}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic;\n\nimport ch.qos.logback.classic.joran.JoranConfigurator;\nimport ch.qos.logback.classic.pattern.ConverterTest;\nimport ch.qos.logback.classic.spi.ILoggingEvent;\nimport ch.qos.logback.classic.spi.LoggingEvent;\nimport ch.qos.logback.classic.testUtil.SampleConverter;\nimport ch.qos.logback.core.Context;\nimport ch.qos.logback.core.joran.spi.JoranException;\nimport ch.qos.logback.core.pattern.PatternLayoutBase;\nimport ch.qos.logback.core.pattern.parser.AbstractPatternLayoutBaseTest;\nimport ch.qos.logback.core.testUtil.StringListAppender;\nimport ch.qos.logback.core.util.OptionHelper;\nimport ch.qos.logback.core.util.StatusPrinter;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.MDC;\n\nimport static ch.qos.logback.classic.ClassicTestConstants.ISO_REGEX;\nimport static ch.qos.logback.classic.ClassicTestConstants.MAIN_REGEX;\nimport static org.junit.Assert.*;\n\npublic class PatternLayoutTest extends AbstractPatternLayoutBaseTest<ILoggingEvent> {\n\n    private PatternLayout pl = new PatternLayout();\n    private LoggerContext lc = new LoggerContext();\n    Logger logger = lc.getLogger(ConverterTest.class);\n    Logger root = lc.getLogger(Logger.ROOT_LOGGER_NAME);\n\n    String aMessage = \"Some message\";\n    \n    ILoggingEvent le;\n\n    public PatternLayoutTest() {\n        super();\n        Exception ex = new Exception(\"Bogus exception\");\n        le = makeLoggingEvent(aMessage, ex);\n    }\n\n    @Before\n    public void setUp() {\n        pl.setContext(lc);\n    }\n\n    ILoggingEvent makeLoggingEvent(String msg, Exception ex) {\n        return new LoggingEvent(ch.qos.logback.core.pattern.FormattingConverter.class.getName(), logger, Level.INFO, msg, ex, null);\n    }\n\n\n    public ILoggingEvent getEventObject() {\n        return makeLoggingEvent(\"Some message\", null);\n    }\n\n      public PatternLayoutBase<ILoggingEvent> getPatternLayoutBase() {\n        return new PatternLayout();\n    }\n\n    @Test\n    public void testOK() {\n        pl.setPattern(\"%d %le [%t] %lo{30} - %m%n\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        // 2006-02-01 22:38:06,212 INFO [main] c.q.l.pattern.ConverterTest - Some\n        // message\n        // 2010-12-29 19:04:26,137 INFO [pool-1-thread-47] c.q.l.c.pattern.ConverterTest - Some message\n        String regex = ISO_REGEX + \" INFO \" + MAIN_REGEX + \" c.q.l.c.pattern.ConverterTest - Some message\\\\s*\";\n\n        assertTrue(\"val=\" + val, val.matches(regex));\n    }\n\n    @Test\n    public void testNoExeptionHandler() {\n        pl.setPattern(\"%m%n\");\n        pl.start();\n        String val = pl.doLayout(le);\n        assertTrue(val.contains(\"java.lang.Exception: Bogus exception\"));\n    }\n\n    @Test\n    public void testCompositePattern() {\n        pl.setPattern(\"%-56(%d %lo{20}) - %m%n\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        // 2008-03-18 21:55:54,250 c.q.l.c.pattern.ConverterTest - Some message\n        String regex = ISO_REGEX + \" c.q.l.c.p.ConverterTest          - Some message\\\\s*\";\n        assertTrue(val.matches(regex));\n    }\n\n    @Test\n    public void contextProperty() {\n        pl.setPattern(\"%property{a}\");\n        pl.start();\n        lc.putProperty(\"a\", \"b\");\n\n        String val = pl.doLayout(getEventObject());\n        assertEquals(\"b\", val);\n    }\n\n    @Test\n    public void testNopExeptionHandler() {\n        pl.setPattern(\"%nopex %m%n\");\n        pl.start();\n        String val = pl.doLayout(le);\n        assertTrue(!val.contains(\"java.lang.Exception: Bogus exception\"));\n    }\n\n    @Test\n    public void testWithParenthesis() {\n        pl.setPattern(\"\\\\(%msg:%msg\\\\) %msg\");\n        pl.start();\n        le = makeLoggingEvent(aMessage, null);\n        String val = pl.doLayout(le);\n        assertEquals(\"(Some message:Some message) Some message\", val);\n    }\n\n    @Test\n    public void testWithLettersComingFromLog4j() {\n        // Letters: p = level and c = logger\n        pl.setPattern(\"%d %p [%t] %c{30} - %m%n\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        // 2006-02-01 22:38:06,212 INFO [main] c.q.l.pattern.ConverterTest - Some\n        // message\n        String regex = ClassicTestConstants.ISO_REGEX + \" INFO \" + MAIN_REGEX + \" c.q.l.c.pattern.ConverterTest - Some message\\\\s*\";\n        assertTrue(val.matches(regex));\n    }\n\n    @Test\n    public void mdcWithDefaultValue() {\n        String pattern = \"%msg %mdc{foo} %mdc{bar:-[null]}\";\n        pl.setPattern(OptionHelper.substVars(pattern, lc));\n        pl.start();\n        MDC.put(\"foo\", \"foo\");\n        try {\n            String val = pl.doLayout(getEventObject());\n            assertEquals(\"Some message foo [null]\", val);\n        } finally {\n            MDC.remove(\"foo\");\n        }\n    }\n\n    @Test\n    public void contextNameTest() {\n        pl.setPattern(\"%contextName\");\n        lc.setName(\"aValue\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        assertEquals(\"aValue\", val);\n    }\n\n    @Test\n    public void cnTest() {\n        pl.setPattern(\"%cn\");\n        lc.setName(\"aValue\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        assertEquals(\"aValue\", val);\n    }\n\n    @Override\n    public Context getContext() {\n        return lc;\n    }\n\n    void configure(String file) throws JoranException {\n        JoranConfigurator jc = new JoranConfigurator();\n        jc.setContext(lc);\n        jc.doConfigure(file);\n    }\n\n    @Test\n    public void testConversionRuleSupportInPatternLayout() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"conversionRule/patternLayout0.xml\");\n        root.getAppender(\"LIST\");\n        String msg = \"Simon says\";\n        logger.debug(msg);\n        StringListAppender<ILoggingEvent> sla = (StringListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(sla);\n        assertEquals(1, sla.strList.size());\n        assertEquals(SampleConverter.SAMPLE_STR + \" - \" + msg, sla.strList.get(0));\n    }\n\n    @Test\n    public void smokeReplace() {\n        pl.setPattern(\"%replace(a1234b){'\\\\d{4}', 'XXXX'}\");\n        pl.start();\n        StatusPrinter.print(lc);\n        String val = pl.doLayout(getEventObject());\n        assertEquals(\"aXXXXb\", val);\n    }\n\n    @Test\n    public void replaceNewline() {\n        String pattern = \"%replace(A\\nB){'\\n', '\\n\\t'}\";\n        String substPattern = OptionHelper.substVars(pattern, null, lc);\n        assertEquals(pattern, substPattern);\n        pl.setPattern(substPattern);\n        pl.start();\n        StatusPrinter.print(lc);\n        String val = pl.doLayout(makeLoggingEvent(\"\", null));\n        assertEquals(\"A\\n\\tB\", val);\n    }\n    \n    @Test\n    public void replaceWithJoran() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"pattern/replace0.xml\");\n        StatusPrinter.print(lc);\n        root.getAppender(\"LIST\");\n        String msg = \"And the number is 4111111111110000, expiring on 12/2010\";\n        logger.debug(msg);\n        StringListAppender<ILoggingEvent> sla = (StringListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(sla);\n        assertEquals(1, sla.strList.size());\n        assertEquals(\"And the number is XXXX, expiring on 12/2010\", sla.strList.get(0));\n    }\n\n    @Test\n    public void replaceWithJoran_NEWLINE() throws JoranException {\n        lc.putProperty(\"TAB\", \"\\t\");\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"pattern/replaceNewline.xml\");\n        StatusPrinter.print(lc);\n        root.getAppender(\"LIST\");\n        String msg = \"A\\nC\";\n        logger.debug(msg);\n        StringListAppender<ILoggingEvent> sla = (StringListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(sla);\n        assertEquals(1, sla.strList.size());\n        assertEquals(\"A\\n\\tC\", sla.strList.get(0));\n    }\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic;\n\nimport ch.qos.logback.classic.joran.JoranConfigurator;\nimport ch.qos.logback.classic.pattern.ConverterTest;\nimport ch.qos.logback.classic.spi.ILoggingEvent;\nimport ch.qos.logback.classic.spi.LoggingEvent;\nimport ch.qos.logback.classic.testUtil.SampleConverter;\nimport ch.qos.logback.core.Context;\nimport ch.qos.logback.core.joran.spi.JoranException;\nimport ch.qos.logback.core.pattern.PatternLayoutBase;\nimport ch.qos.logback.core.pattern.parser.AbstractPatternLayoutBaseTest;\nimport ch.qos.logback.core.testUtil.StringListAppender;\nimport ch.qos.logback.core.util.OptionHelper;\nimport ch.qos.logback.core.util.StatusPrinter;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.MDC;\n\nimport static ch.qos.logback.classic.ClassicTestConstants.ISO_REGEX;\nimport static ch.qos.logback.classic.ClassicTestConstants.MAIN_REGEX;\nimport static org.junit.Assert.*;\n\npublic class PatternLayoutTest extends AbstractPatternLayoutBaseTest<ILoggingEvent> {\n\n    private PatternLayout pl = new PatternLayout();\n    private LoggerContext lc = new LoggerContext();\n    Logger logger = lc.getLogger(ConverterTest.class);\n    Logger root = lc.getLogger(Logger.ROOT_LOGGER_NAME);\n\n    String aMessage = \"Some message\";\n    \n    ILoggingEvent le;\n\n    public PatternLayoutTest() {\n        super();\n        Exception ex = new Exception(\"Bogus exception\");\n        le = makeLoggingEvent(aMessage, ex);\n    }\n\n    @Before\n    public void setUp() {\n        pl.setContext(lc);\n    }\n\n    ILoggingEvent makeLoggingEvent(String msg, Exception ex) {\n        return new LoggingEvent(ch.qos.logback.core.pattern.FormattingConverter.class.getName(), logger, Level.INFO, msg, ex, null);\n    }\n\n\n    public ILoggingEvent getEventObject() {\n        return makeLoggingEvent(\"Some message\", null);\n    }\n\n      public PatternLayoutBase<ILoggingEvent> getPatternLayoutBase() {\n        return new PatternLayout();\n    }\n\n    @Test\n    public void testOK() {\n        pl.setPattern(\"%d %le [%t] %lo{30} - %m%n\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        // 2006-02-01 22:38:06,212 INFO [main] c.q.l.pattern.ConverterTest - Some\n        // message\n        // 2010-12-29 19:04:26,137 INFO [pool-1-thread-47] c.q.l.c.pattern.ConverterTest - Some message\n        String regex = ISO_REGEX + \" INFO \" + MAIN_REGEX + \" c.q.l.c.pattern.ConverterTest - Some message\\\\s*\";\n\n        assertTrue(\"val=\" + val, val.matches(regex));\n    }\n\n    @Test\n    public void testNoExeptionHandler() {\n        pl.setPattern(\"%m%n\");\n        pl.start();\n        String val = pl.doLayout(le);\n        assertTrue(val.contains(\"java.lang.Exception: Bogus exception\"));\n    }\n\n    @Test\n    public void testCompositePattern() {\n        pl.setPattern(\"%-56(%d %lo{20}) - %m%n\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        // 2008-03-18 21:55:54,250 c.q.l.c.pattern.ConverterTest - Some message\n        String regex = ISO_REGEX + \" c.q.l.c.p.ConverterTest          - Some message\\\\s*\";\n        assertTrue(val.matches(regex));\n    }\n\n    @Test\n    public void contextProperty() {\n        pl.setPattern(\"%property{a}\");\n        pl.start();\n        lc.putProperty(\"a\", \"b\");\n\n        String val = pl.doLayout(getEventObject());\n        assertEquals(\"b\", val);\n    }\n\n    @Test\n    public void testNopExeptionHandler() {\n        pl.setPattern(\"%nopex %m%n\");\n        pl.start();\n        String val = pl.doLayout(le);\n        assertTrue(!val.contains(\"java.lang.Exception: Bogus exception\"));\n    }\n\n    @Test\n    public void testWithParenthesis() {\n        pl.setPattern(\"\\\\(%msg:%msg\\\\) %msg\");\n        pl.start();\n        le = makeLoggingEvent(aMessage, null);\n        String val = pl.doLayout(le);\n        assertEquals(\"(Some message:Some message) Some message\", val);\n    }\n\n    @Test\n    public void testWithLettersComingFromLog4j() {\n        // Letters: p = level and c = logger\n        pl.setPattern(\"%d %p [%t] %c{30} - %m%n\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        // 2006-02-01 22:38:06,212 INFO [main] c.q.l.pattern.ConverterTest - Some\n        // message\n        String regex = ClassicTestConstants.ISO_REGEX + \" INFO \" + MAIN_REGEX + \" c.q.l.c.pattern.ConverterTest - Some message\\\\s*\";\n        assertTrue(val.matches(regex));\n    }\n\n    @Test\n    public void mdcWithDefaultValue() {\n        String pattern = \"%msg %mdc{foo} %mdc{bar:-[null]}\";\n        pl.setPattern(OptionHelper.substVars(pattern, lc));\n        pl.start();\n        MDC.put(\"foo\", \"foo\");\n        try {\n            String val = pl.doLayout(getEventObject());\n            assertEquals(\"Some message foo [null]\", val);\n        } finally {\n            MDC.remove(\"foo\");\n        }\n    }\n\n    @Test\n    public void contextNameTest() {\n        pl.setPattern(\"%contextName\");\n        lc.setName(\"aValue\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        assertEquals(\"aValue\", val);\n    }\n\n    @Test\n    public void cnTest() {\n        pl.setPattern(\"%cn\");\n        lc.setName(\"aValue\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        assertEquals(\"aValue\", val);\n    }\n\n    @Override\n    public Context getContext() {\n        return lc;\n    }\n\n    void configure(String file) throws JoranException {\n        JoranConfigurator jc = new JoranConfigurator();\n        jc.setContext(lc);\n        jc.doConfigure(file);\n    }\n\n    @Test\n    public void testConversionRuleSupportInPatternLayout() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"conversionRule/patternLayout0.xml\");\n        root.getAppender(\"LIST\");\n        String msg = \"Simon says\";\n        logger.debug(msg);\n        StringListAppender<ILoggingEvent> sla = (StringListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(sla);\n        assertEquals(1, sla.strList.size());\n        assertEquals(SampleConverter.SAMPLE_STR + \" - \" + msg, sla.strList.get(0));\n    }\n\n    @Test\n    public void smokeReplace() {\n        pl.setPattern(\"%replace(a1234b){'\\\\d{4}', 'XXXX'}\");\n        pl.start();\n        StatusPrinter.print(lc);\n        String val = pl.doLayout(getEventObject());\n        assertEquals(\"aXXXXb\", val);\n    }\n\n    @Test\n    public void replaceNewline() {\n        pl.setPattern(\"%replace(A\\nB){'\\n', '\\n\\t'}\");\n        pl.start();\n        StatusPrinter.print(lc);\n        String val = pl.doLayout(makeLoggingEvent(\"\", null));\n        assertEquals(\"A\\n\\tB\", val);\n    }\n    \n    @Test\n    public void replaceWithJoran() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"pattern/replace0.xml\");\n        StatusPrinter.print(lc);\n        root.getAppender(\"LIST\");\n        String msg = \"And the number is 4111111111110000, expiring on 12/2010\";\n        logger.debug(msg);\n        StringListAppender<ILoggingEvent> sla = (StringListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(sla);\n        assertEquals(1, sla.strList.size());\n        assertEquals(\"And the number is XXXX, expiring on 12/2010\", sla.strList.get(0));\n    }\n\n}\n","lineNo":207}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic;\n\nimport ch.qos.logback.classic.joran.JoranConfigurator;\nimport ch.qos.logback.classic.pattern.ConverterTest;\nimport ch.qos.logback.classic.spi.ILoggingEvent;\nimport ch.qos.logback.classic.spi.LoggingEvent;\nimport ch.qos.logback.classic.testUtil.SampleConverter;\nimport ch.qos.logback.core.Context;\nimport ch.qos.logback.core.joran.spi.JoranException;\nimport ch.qos.logback.core.pattern.PatternLayoutBase;\nimport ch.qos.logback.core.pattern.parser.AbstractPatternLayoutBaseTest;\nimport ch.qos.logback.core.testUtil.StringListAppender;\nimport ch.qos.logback.core.util.OptionHelper;\nimport ch.qos.logback.core.util.StatusPrinter;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.MDC;\n\nimport static ch.qos.logback.classic.ClassicTestConstants.ISO_REGEX;\nimport static ch.qos.logback.classic.ClassicTestConstants.MAIN_REGEX;\nimport static org.junit.Assert.*;\n\npublic class PatternLayoutTest extends AbstractPatternLayoutBaseTest<ILoggingEvent> {\n\n    private PatternLayout pl = new PatternLayout();\n    private LoggerContext lc = new LoggerContext();\n    Logger logger = lc.getLogger(ConverterTest.class);\n    Logger root = lc.getLogger(Logger.ROOT_LOGGER_NAME);\n\n    String aMessage = \"Some message\";\n    \n    ILoggingEvent le;\n\n    public PatternLayoutTest() {\n        super();\n        Exception ex = new Exception(\"Bogus exception\");\n        le = makeLoggingEvent(aMessage, ex);\n    }\n\n    @Before\n    public void setUp() {\n        pl.setContext(lc);\n    }\n\n    ILoggingEvent makeLoggingEvent(String msg, Exception ex) {\n        return new LoggingEvent(ch.qos.logback.core.pattern.FormattingConverter.class.getName(), logger, Level.INFO, msg, ex, null);\n    }\n\n\n    public ILoggingEvent getEventObject() {\n        return makeLoggingEvent(\"Some message\", null);\n    }\n\n      public PatternLayoutBase<ILoggingEvent> getPatternLayoutBase() {\n        return new PatternLayout();\n    }\n\n    @Test\n    public void testOK() {\n        pl.setPattern(\"%d %le [%t] %lo{30} - %m%n\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        // 2006-02-01 22:38:06,212 INFO [main] c.q.l.pattern.ConverterTest - Some\n        // message\n        // 2010-12-29 19:04:26,137 INFO [pool-1-thread-47] c.q.l.c.pattern.ConverterTest - Some message\n        String regex = ISO_REGEX + \" INFO \" + MAIN_REGEX + \" c.q.l.c.pattern.ConverterTest - Some message\\\\s*\";\n\n        assertTrue(\"val=\" + val, val.matches(regex));\n    }\n\n    @Test\n    public void testNoExeptionHandler() {\n        pl.setPattern(\"%m%n\");\n        pl.start();\n        String val = pl.doLayout(le);\n        assertTrue(val.contains(\"java.lang.Exception: Bogus exception\"));\n    }\n\n    @Test\n    public void testCompositePattern() {\n        pl.setPattern(\"%-56(%d %lo{20}) - %m%n\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        // 2008-03-18 21:55:54,250 c.q.l.c.pattern.ConverterTest - Some message\n        String regex = ISO_REGEX + \" c.q.l.c.p.ConverterTest          - Some message\\\\s*\";\n        assertTrue(val.matches(regex));\n    }\n\n    @Test\n    public void contextProperty() {\n        pl.setPattern(\"%property{a}\");\n        pl.start();\n        lc.putProperty(\"a\", \"b\");\n\n        String val = pl.doLayout(getEventObject());\n        assertEquals(\"b\", val);\n    }\n\n    @Test\n    public void testNopExeptionHandler() {\n        pl.setPattern(\"%nopex %m%n\");\n        pl.start();\n        String val = pl.doLayout(le);\n        assertTrue(!val.contains(\"java.lang.Exception: Bogus exception\"));\n    }\n\n    @Test\n    public void testWithParenthesis() {\n        pl.setPattern(\"\\\\(%msg:%msg\\\\) %msg\");\n        pl.start();\n        le = makeLoggingEvent(aMessage, null);\n        String val = pl.doLayout(le);\n        assertEquals(\"(Some message:Some message) Some message\", val);\n    }\n\n    @Test\n    public void testWithLettersComingFromLog4j() {\n        // Letters: p = level and c = logger\n        pl.setPattern(\"%d %p [%t] %c{30} - %m%n\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        // 2006-02-01 22:38:06,212 INFO [main] c.q.l.pattern.ConverterTest - Some\n        // message\n        String regex = ClassicTestConstants.ISO_REGEX + \" INFO \" + MAIN_REGEX + \" c.q.l.c.pattern.ConverterTest - Some message\\\\s*\";\n        assertTrue(val.matches(regex));\n    }\n\n    @Test\n    public void mdcWithDefaultValue() {\n        String pattern = \"%msg %mdc{foo} %mdc{bar:-[null]}\";\n        pl.setPattern(OptionHelper.substVars(pattern, lc));\n        pl.start();\n        MDC.put(\"foo\", \"foo\");\n        try {\n            String val = pl.doLayout(getEventObject());\n            assertEquals(\"Some message foo [null]\", val);\n        } finally {\n            MDC.remove(\"foo\");\n        }\n    }\n\n    @Test\n    public void contextNameTest() {\n        pl.setPattern(\"%contextName\");\n        lc.setName(\"aValue\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        assertEquals(\"aValue\", val);\n    }\n\n    @Test\n    public void cnTest() {\n        pl.setPattern(\"%cn\");\n        lc.setName(\"aValue\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        assertEquals(\"aValue\", val);\n    }\n\n    @Override\n    public Context getContext() {\n        return lc;\n    }\n\n    void configure(String file) throws JoranException {\n        JoranConfigurator jc = new JoranConfigurator();\n        jc.setContext(lc);\n        jc.doConfigure(file);\n    }\n\n    @Test\n    public void testConversionRuleSupportInPatternLayout() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"conversionRule/patternLayout0.xml\");\n        root.getAppender(\"LIST\");\n        String msg = \"Simon says\";\n        logger.debug(msg);\n        StringListAppender<ILoggingEvent> sla = (StringListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(sla);\n        assertEquals(1, sla.strList.size());\n        assertEquals(SampleConverter.SAMPLE_STR + \" - \" + msg, sla.strList.get(0));\n    }\n\n    @Test\n    public void smokeReplace() {\n        pl.setPattern(\"%replace(a1234b){'\\\\d{4}', 'XXXX'}\");\n        pl.start();\n        StatusPrinter.print(lc);\n        String val = pl.doLayout(getEventObject());\n        assertEquals(\"aXXXXb\", val);\n    }\n\n    @Test\n    public void replaceNewline() {\n        String pattern = \"%replace(A\\nB){'\\n', '\\n\\t'}\";\n        String substPattern = OptionHelper.substVars(pattern, null, lc);\n        assertEquals(pattern, substPattern);\n        pl.setPattern(substPattern);\n        pl.start();\n        StatusPrinter.print(lc);\n        String val = pl.doLayout(makeLoggingEvent(\"\", null));\n        assertEquals(\"A\\n\\tB\", val);\n    }\n    \n    @Test\n    public void replaceWithJoran() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"pattern/replace0.xml\");\n        StatusPrinter.print(lc);\n        root.getAppender(\"LIST\");\n        String msg = \"And the number is 4111111111110000, expiring on 12/2010\";\n        logger.debug(msg);\n        StringListAppender<ILoggingEvent> sla = (StringListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(sla);\n        assertEquals(1, sla.strList.size());\n        assertEquals(\"And the number is XXXX, expiring on 12/2010\", sla.strList.get(0));\n    }\n\n    @Test\n    public void replaceWithJoran_NEWLINE() throws JoranException {\n        lc.putProperty(\"TAB\", \"\\t\");\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"pattern/replaceNewline.xml\");\n        StatusPrinter.print(lc);\n        root.getAppender(\"LIST\");\n        String msg = \"A\\nC\";\n        logger.debug(msg);\n        StringListAppender<ILoggingEvent> sla = (StringListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(sla);\n        assertEquals(1, sla.strList.size());\n        assertEquals(\"A\\n\\tC\", sla.strList.get(0));\n    }\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic;\n\nimport ch.qos.logback.classic.joran.JoranConfigurator;\nimport ch.qos.logback.classic.pattern.ConverterTest;\nimport ch.qos.logback.classic.spi.ILoggingEvent;\nimport ch.qos.logback.classic.spi.LoggingEvent;\nimport ch.qos.logback.classic.testUtil.SampleConverter;\nimport ch.qos.logback.core.Context;\nimport ch.qos.logback.core.joran.spi.JoranException;\nimport ch.qos.logback.core.pattern.PatternLayoutBase;\nimport ch.qos.logback.core.pattern.parser.AbstractPatternLayoutBaseTest;\nimport ch.qos.logback.core.testUtil.StringListAppender;\nimport ch.qos.logback.core.util.OptionHelper;\nimport ch.qos.logback.core.util.StatusPrinter;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.MDC;\n\nimport static ch.qos.logback.classic.ClassicTestConstants.ISO_REGEX;\nimport static ch.qos.logback.classic.ClassicTestConstants.MAIN_REGEX;\nimport static org.junit.Assert.*;\n\npublic class PatternLayoutTest extends AbstractPatternLayoutBaseTest<ILoggingEvent> {\n\n    private PatternLayout pl = new PatternLayout();\n    private LoggerContext lc = new LoggerContext();\n    Logger logger = lc.getLogger(ConverterTest.class);\n    Logger root = lc.getLogger(Logger.ROOT_LOGGER_NAME);\n\n    String aMessage = \"Some message\";\n    \n    ILoggingEvent le;\n\n    public PatternLayoutTest() {\n        super();\n        Exception ex = new Exception(\"Bogus exception\");\n        le = makeLoggingEvent(aMessage, ex);\n    }\n\n    @Before\n    public void setUp() {\n        pl.setContext(lc);\n    }\n\n    ILoggingEvent makeLoggingEvent(String msg, Exception ex) {\n        return new LoggingEvent(ch.qos.logback.core.pattern.FormattingConverter.class.getName(), logger, Level.INFO, msg, ex, null);\n    }\n\n\n    public ILoggingEvent getEventObject() {\n        return makeLoggingEvent(\"Some message\", null);\n    }\n\n      public PatternLayoutBase<ILoggingEvent> getPatternLayoutBase() {\n        return new PatternLayout();\n    }\n\n    @Test\n    public void testOK() {\n        pl.setPattern(\"%d %le [%t] %lo{30} - %m%n\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        // 2006-02-01 22:38:06,212 INFO [main] c.q.l.pattern.ConverterTest - Some\n        // message\n        // 2010-12-29 19:04:26,137 INFO [pool-1-thread-47] c.q.l.c.pattern.ConverterTest - Some message\n        String regex = ISO_REGEX + \" INFO \" + MAIN_REGEX + \" c.q.l.c.pattern.ConverterTest - Some message\\\\s*\";\n\n        assertTrue(\"val=\" + val, val.matches(regex));\n    }\n\n    @Test\n    public void testNoExeptionHandler() {\n        pl.setPattern(\"%m%n\");\n        pl.start();\n        String val = pl.doLayout(le);\n        assertTrue(val.contains(\"java.lang.Exception: Bogus exception\"));\n    }\n\n    @Test\n    public void testCompositePattern() {\n        pl.setPattern(\"%-56(%d %lo{20}) - %m%n\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        // 2008-03-18 21:55:54,250 c.q.l.c.pattern.ConverterTest - Some message\n        String regex = ISO_REGEX + \" c.q.l.c.p.ConverterTest          - Some message\\\\s*\";\n        assertTrue(val.matches(regex));\n    }\n\n    @Test\n    public void contextProperty() {\n        pl.setPattern(\"%property{a}\");\n        pl.start();\n        lc.putProperty(\"a\", \"b\");\n\n        String val = pl.doLayout(getEventObject());\n        assertEquals(\"b\", val);\n    }\n\n    @Test\n    public void testNopExeptionHandler() {\n        pl.setPattern(\"%nopex %m%n\");\n        pl.start();\n        String val = pl.doLayout(le);\n        assertTrue(!val.contains(\"java.lang.Exception: Bogus exception\"));\n    }\n\n    @Test\n    public void testWithParenthesis() {\n        pl.setPattern(\"\\\\(%msg:%msg\\\\) %msg\");\n        pl.start();\n        le = makeLoggingEvent(aMessage, null);\n        String val = pl.doLayout(le);\n        assertEquals(\"(Some message:Some message) Some message\", val);\n    }\n\n    @Test\n    public void testWithLettersComingFromLog4j() {\n        // Letters: p = level and c = logger\n        pl.setPattern(\"%d %p [%t] %c{30} - %m%n\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        // 2006-02-01 22:38:06,212 INFO [main] c.q.l.pattern.ConverterTest - Some\n        // message\n        String regex = ClassicTestConstants.ISO_REGEX + \" INFO \" + MAIN_REGEX + \" c.q.l.c.pattern.ConverterTest - Some message\\\\s*\";\n        assertTrue(val.matches(regex));\n    }\n\n    @Test\n    public void mdcWithDefaultValue() {\n        String pattern = \"%msg %mdc{foo} %mdc{bar:-[null]}\";\n        pl.setPattern(OptionHelper.substVars(pattern, lc));\n        pl.start();\n        MDC.put(\"foo\", \"foo\");\n        try {\n            String val = pl.doLayout(getEventObject());\n            assertEquals(\"Some message foo [null]\", val);\n        } finally {\n            MDC.remove(\"foo\");\n        }\n    }\n\n    @Test\n    public void contextNameTest() {\n        pl.setPattern(\"%contextName\");\n        lc.setName(\"aValue\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        assertEquals(\"aValue\", val);\n    }\n\n    @Test\n    public void cnTest() {\n        pl.setPattern(\"%cn\");\n        lc.setName(\"aValue\");\n        pl.start();\n        String val = pl.doLayout(getEventObject());\n        assertEquals(\"aValue\", val);\n    }\n\n    @Override\n    public Context getContext() {\n        return lc;\n    }\n\n    void configure(String file) throws JoranException {\n        JoranConfigurator jc = new JoranConfigurator();\n        jc.setContext(lc);\n        jc.doConfigure(file);\n    }\n\n    @Test\n    public void testConversionRuleSupportInPatternLayout() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"conversionRule/patternLayout0.xml\");\n        root.getAppender(\"LIST\");\n        String msg = \"Simon says\";\n        logger.debug(msg);\n        StringListAppender<ILoggingEvent> sla = (StringListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(sla);\n        assertEquals(1, sla.strList.size());\n        assertEquals(SampleConverter.SAMPLE_STR + \" - \" + msg, sla.strList.get(0));\n    }\n\n    @Test\n    public void smokeReplace() {\n        pl.setPattern(\"%replace(a1234b){'\\\\d{4}', 'XXXX'}\");\n        pl.start();\n        StatusPrinter.print(lc);\n        String val = pl.doLayout(getEventObject());\n        assertEquals(\"aXXXXb\", val);\n    }\n\n    @Test\n    public void replaceNewline() {\n        pl.setPattern(\"%replace(A\\nB){'\\n', '\\n\\t'}\");\n        pl.start();\n        StatusPrinter.print(lc);\n        String val = pl.doLayout(makeLoggingEvent(\"\", null));\n        assertEquals(\"A\\n\\tB\", val);\n    }\n    \n    @Test\n    public void replaceWithJoran() throws JoranException {\n        configure(ClassicTestConstants.JORAN_INPUT_PREFIX + \"pattern/replace0.xml\");\n        StatusPrinter.print(lc);\n        root.getAppender(\"LIST\");\n        String msg = \"And the number is 4111111111110000, expiring on 12/2010\";\n        logger.debug(msg);\n        StringListAppender<ILoggingEvent> sla = (StringListAppender<ILoggingEvent>) root.getAppender(\"LIST\");\n        assertNotNull(sla);\n        assertEquals(1, sla.strList.size());\n        assertEquals(\"And the number is XXXX, expiring on 12/2010\", sla.strList.get(0));\n    }\n\n}\n","lineNo":208}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core;\n\nimport ch.qos.logback.core.spi.AppenderAttachable;\nimport ch.qos.logback.core.spi.AppenderAttachableImpl;\nimport ch.qos.logback.core.util.InterruptUtil;\n\nimport java.util.Iterator;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\n\n/**\n * This appender and derived classes, log events asynchronously.  In order to avoid loss of logging events, this\n * appender should be closed. It is the user's  responsibility to close appenders, typically at the end of the\n * application lifecycle.\n * <p/>\n * This appender buffers events in a {@link BlockingQueue}. {@link Worker} thread created by this appender takes\n * events from the head of the queue, and dispatches them to the single appender attached to this appender.\n * <p/>\n * <p>Please refer to the <a href=\"http://logback.qos.ch/manual/appenders.html#AsyncAppender\">logback manual<\/a> for\n * further information about this appender.<\/p>\n *\n * @param <E>\n * @author Ceki G&uuml;lc&uuml;\n * @author Torsten Juergeleit\n * @since 1.0.4\n */\npublic class AsyncAppenderBase<E> extends UnsynchronizedAppenderBase<E> implements AppenderAttachable<E> {\n\n    AppenderAttachableImpl<E> aai = new AppenderAttachableImpl<E>();\n    BlockingQueue<E> blockingQueue;\n\n    /**\n     * The default buffer size.\n     */\n    public static final int DEFAULT_QUEUE_SIZE = 256;\n    int queueSize = DEFAULT_QUEUE_SIZE;\n\n    int appenderCount = 0;\n\n    static final int UNDEFINED = -1;\n    int discardingThreshold = UNDEFINED;\n    boolean neverBlock = false;\n\n    Worker worker = new Worker();\n\n    /**\n     * The default maximum queue flush time allowed during appender stop. If the \n     * worker takes longer than this time it will exit, discarding any remaining \n     * items in the queue\n     */\n    public static final int DEFAULT_MAX_FLUSH_TIME = 1000;\n    int maxFlushTime = DEFAULT_MAX_FLUSH_TIME;\n\n    /**\n     * Is the eventObject passed as parameter discardable? The base class's implementation of this method always returns\n     * 'false' but sub-classes may (and do) override this method.\n     * <p/>\n     * <p>Note that only if the buffer is nearly full are events discarded. Otherwise, when the buffer is \"not full\"\n     * all events are logged.\n     *\n     * @param eventObject\n     * @return - true if the event can be discarded, false otherwise\n     */\n    protected boolean isDiscardable(E eventObject) {\n        return false;\n    }\n\n    /**\n     * Pre-process the event prior to queueing. The base class does no pre-processing but sub-classes can\n     * override this behavior.\n     *\n     * @param eventObject\n     */\n    protected void preprocess(E eventObject) {\n    }\n\n    @Override\n    public void start() {\n        if (isStarted())\n            return;\n        if (appenderCount == 0) {\n            addError(\"No attached appenders found.\");\n            return;\n        }\n        if (queueSize < 1) {\n            addError(\"Invalid queue size [\" + queueSize + \"]\");\n            return;\n        }\n        blockingQueue = new ArrayBlockingQueue<E>(queueSize);\n\n        if (discardingThreshold == UNDEFINED)\n            discardingThreshold = queueSize / 5;\n        addInfo(\"Setting discardingThreshold to \" + discardingThreshold);\n        worker.setDaemon(true);\n        worker.setName(\"AsyncAppender-Worker-\" + getName());\n        // make sure this instance is marked as \"started\" before staring the worker Thread\n        super.start();\n        worker.start();\n    }\n\n    @Override\n    public void stop() {\n        if (!isStarted())\n            return;\n\n        // mark this appender as stopped so that Worker can also processPriorToRemoval if it is invoking\n        // aii.appendLoopOnAppenders\n        // and sub-appenders consume the interruption\n        super.stop();\n\n        // interrupt the worker thread so that it can terminate. Note that the interruption can be consumed\n        // by sub-appenders\n        worker.interrupt();\n\n        InterruptUtil interruptUtil = new InterruptUtil(context);\n\n        try {\n            interruptUtil.maskInterruptFlag();\n\n            worker.join(maxFlushTime);\n\n            // check to see if the thread ended and if not add a warning message\n            if (worker.isAlive()) {\n                addWarn(\"Max queue flush timeout (\" + maxFlushTime + \" ms) exceeded. Approximately \" + blockingQueue.size()\n                                + \" queued events were possibly discarded.\");\n            } else {\n                addInfo(\"Queue flush finished successfully within timeout.\");\n            }\n\n        } catch (InterruptedException e) {\n            int remaining = blockingQueue.size();\n            addError(\"Failed to join worker thread. \" + remaining + \" queued events may be discarded.\", e);\n        } finally {\n            interruptUtil.unmaskInterruptFlag();\n        }\n    }\n\n\n\n\n\n    @Override\n    protected void append(E eventObject) {\n        if (isQueueBelowDiscardingThreshold() && isDiscardable(eventObject)) {\n            return;\n        }\n        preprocess(eventObject);\n        put(eventObject);\n    }\n\n    private boolean isQueueBelowDiscardingThreshold() {\n        return (blockingQueue.remainingCapacity() < discardingThreshold);\n    }\n\n    private void put(E eventObject) {\n        if (neverBlock) {\n            blockingQueue.offer(eventObject);\n        } else {\n            putUninterruptibly(eventObject);\n        }\n    }\n\n    private void putUninterruptibly(E eventObject) {\n        boolean interrupted = false;\n        try {\n            while (true) {\n                try {\n                    blockingQueue.put(eventObject);\n                    break;\n                } catch (InterruptedException e) {\n                    interrupted = true;\n                }\n            }\n        } finally {\n            if (interrupted) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    public int getQueueSize() {\n        return queueSize;\n    }\n\n    public void setQueueSize(int queueSize) {\n        this.queueSize = queueSize;\n    }\n\n    public int getDiscardingThreshold() {\n        return discardingThreshold;\n    }\n\n    public void setDiscardingThreshold(int discardingThreshold) {\n        this.discardingThreshold = discardingThreshold;\n    }\n\n    public int getMaxFlushTime() {\n        return maxFlushTime;\n    }\n\n    public void setMaxFlushTime(int maxFlushTime) {\n        this.maxFlushTime = maxFlushTime;\n    }\n\n    /**\n     * Returns the number of elements currently in the blocking queue.\n     *\n     * @return number of elements currently in the queue.\n     */\n    public int getNumberOfElementsInQueue() {\n        return blockingQueue.size();\n    }\n\n    public void setNeverBlock(boolean neverBlock) {\n        this.neverBlock = neverBlock;\n    }\n\n    public boolean isNeverBlock() {\n        return neverBlock;\n    }\n\n    /**\n     * The remaining capacity available in the blocking queue.\n     *\n     * @return the remaining capacity\n     * @see {@link java.util.concurrent.BlockingQueue#remainingCapacity()}\n     */\n    public int getRemainingCapacity() {\n        return blockingQueue.remainingCapacity();\n    }\n\n    public void addAppender(Appender<E> newAppender) {\n        if (appenderCount == 0) {\n            appenderCount++;\n            addInfo(\"Attaching appender named [\" + newAppender.getName() + \"] to AsyncAppender.\");\n            aai.addAppender(newAppender);\n        } else {\n            addWarn(\"One and only one appender may be attached to AsyncAppender.\");\n            addWarn(\"Ignoring additional appender named [\" + newAppender.getName() + \"]\");\n        }\n    }\n\n    public Iterator<Appender<E>> iteratorForAppenders() {\n        return aai.iteratorForAppenders();\n    }\n\n    public Appender<E> getAppender(String name) {\n        return aai.getAppender(name);\n    }\n\n    public boolean isAttached(Appender<E> eAppender) {\n        return aai.isAttached(eAppender);\n    }\n\n    public void detachAndStopAllAppenders() {\n        aai.detachAndStopAllAppenders();\n    }\n\n    public boolean detachAppender(Appender<E> eAppender) {\n        return aai.detachAppender(eAppender);\n    }\n\n    public boolean detachAppender(String name) {\n        return aai.detachAppender(name);\n    }\n\n    class Worker extends Thread {\n\n        public void run() {\n            System.out.println(\"Worker started\");\n            AsyncAppenderBase<E> parent = AsyncAppenderBase.this;\n            AppenderAttachableImpl<E> aai = parent.aai;\n\n            // loop while the parent is started\n            while (parent.isStarted()) {\n                try {\n                    E e = parent.blockingQueue.take();\n                    aai.appendLoopOnAppenders(e);\n                } catch (InterruptedException ie) {\n                    break;\n                }\n            }\n\n            addInfo(\"Worker thread will flush remaining events before exiting. \");\n\n            for (E e : parent.blockingQueue) {\n                aai.appendLoopOnAppenders(e);\n                parent.blockingQueue.remove(e);\n            }\n\n            aai.detachAndStopAllAppenders();\n        }\n    }\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core;\n\nimport ch.qos.logback.core.spi.AppenderAttachable;\nimport ch.qos.logback.core.spi.AppenderAttachableImpl;\n\nimport java.util.Iterator;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\n\n/**\n * This appender and derived classes, log events asynchronously.  In order to avoid loss of logging events, this\n * appender should be closed. It is the user's  responsibility to close appenders, typically at the end of the\n * application lifecycle.\n * <p/>\n * This appender buffers events in a {@link BlockingQueue}. {@link Worker} thread created by this appender takes\n * events from the head of the queue, and dispatches them to the single appender attached to this appender.\n * <p/>\n * <p>Please refer to the <a href=\"http://logback.qos.ch/manual/appenders.html#AsyncAppender\">logback manual<\/a> for\n * further information about this appender.<\/p>\n *\n * @param <E>\n * @author Ceki G&uuml;lc&uuml;\n * @author Torsten Juergeleit\n * @since 1.0.4\n */\npublic class AsyncAppenderBase<E> extends UnsynchronizedAppenderBase<E> implements AppenderAttachable<E> {\n\n    AppenderAttachableImpl<E> aai = new AppenderAttachableImpl<E>();\n    BlockingQueue<E> blockingQueue;\n\n    /**\n     * The default buffer size.\n     */\n    public static final int DEFAULT_QUEUE_SIZE = 256;\n    int queueSize = DEFAULT_QUEUE_SIZE;\n\n    int appenderCount = 0;\n\n    static final int UNDEFINED = -1;\n    int discardingThreshold = UNDEFINED;\n    boolean neverBlock = false;\n\n    Worker worker = new Worker();\n\n    /**\n     * The default maximum queue flush time allowed during appender stop. If the \n     * worker takes longer than this time it will exit, discarding any remaining \n     * items in the queue\n     */\n    public static final int DEFAULT_MAX_FLUSH_TIME = 1000;\n    int maxFlushTime = DEFAULT_MAX_FLUSH_TIME;\n\n    /**\n     * Is the eventObject passed as parameter discardable? The base class's implementation of this method always returns\n     * 'false' but sub-classes may (and do) override this method.\n     * <p/>\n     * <p>Note that only if the buffer is nearly full are events discarded. Otherwise, when the buffer is \"not full\"\n     * all events are logged.\n     *\n     * @param eventObject\n     * @return - true if the event can be discarded, false otherwise\n     */\n    protected boolean isDiscardable(E eventObject) {\n        return false;\n    }\n\n    /**\n     * Pre-process the event prior to queueing. The base class does no pre-processing but sub-classes can\n     * override this behavior.\n     *\n     * @param eventObject\n     */\n    protected void preprocess(E eventObject) {\n    }\n\n    @Override\n    public void start() {\n        if (isStarted())\n            return;\n        if (appenderCount == 0) {\n            addError(\"No attached appenders found.\");\n            return;\n        }\n        if (queueSize < 1) {\n            addError(\"Invalid queue size [\" + queueSize + \"]\");\n            return;\n        }\n        blockingQueue = new ArrayBlockingQueue<E>(queueSize);\n\n        if (discardingThreshold == UNDEFINED)\n            discardingThreshold = queueSize / 5;\n        addInfo(\"Setting discardingThreshold to \" + discardingThreshold);\n        worker.setDaemon(true);\n        worker.setName(\"AsyncAppender-Worker-\" + getName());\n        // make sure this instance is marked as \"started\" before staring the worker Thread\n        super.start();\n        worker.start();\n    }\n\n    @Override\n    public void stop() {\n        if (!isStarted())\n            return;\n\n        // mark this appender as stopped so that Worker can also processPriorToRemoval if it is invoking\n        // aii.appendLoopOnAppenders\n        // and sub-appenders consume the interruption\n        super.stop();\n\n        // interrupt the worker thread so that it can terminate. Note that the interruption can be consumed\n        // by the sub-appender\n        worker.interrupt();\n        try {\n            worker.join(maxFlushTime);\n\n            // check to see if the thread ended and if not add a warning message\n            if (worker.isAlive()) {\n                addWarn(\"Max queue flush timeout (\" + maxFlushTime + \" ms) exceeded. Approximately \" + blockingQueue.size()\n                                + \" queued events were possibly discarded.\");\n            } else {\n                addInfo(\"Queue flush finished successfully within timeout.\");\n            }\n\n        } catch (InterruptedException e) {\n            addError(\"Failed to join worker thread. \" + blockingQueue.size() + \" queued events may be discarded.\", e);\n        }\n    }\n\n    @Override\n    protected void append(E eventObject) {\n        if (isQueueBelowDiscardingThreshold() && isDiscardable(eventObject)) {\n            return;\n        }\n        preprocess(eventObject);\n        put(eventObject);\n    }\n\n    private boolean isQueueBelowDiscardingThreshold() {\n        return (blockingQueue.remainingCapacity() < discardingThreshold);\n    }\n\n    private void put(E eventObject) {\n        if (neverBlock) {\n            blockingQueue.offer(eventObject);\n        } else {\n            try {\n                blockingQueue.put(eventObject);\n            } catch (InterruptedException e) {\n                // Interruption of current thread when in doAppend method should not be consumed\n                // by AsyncAppender\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    public int getQueueSize() {\n        return queueSize;\n    }\n\n    public void setQueueSize(int queueSize) {\n        this.queueSize = queueSize;\n    }\n\n    public int getDiscardingThreshold() {\n        return discardingThreshold;\n    }\n\n    public void setDiscardingThreshold(int discardingThreshold) {\n        this.discardingThreshold = discardingThreshold;\n    }\n\n    public int getMaxFlushTime() {\n        return maxFlushTime;\n    }\n\n    public void setMaxFlushTime(int maxFlushTime) {\n        this.maxFlushTime = maxFlushTime;\n    }\n\n    /**\n     * Returns the number of elements currently in the blocking queue.\n     *\n     * @return number of elements currently in the queue.\n     */\n    public int getNumberOfElementsInQueue() {\n        return blockingQueue.size();\n    }\n\n    public void setNeverBlock(boolean neverBlock) {\n        this.neverBlock = neverBlock;\n    }\n\n    public boolean isNeverBlock() {\n        return neverBlock;\n    }\n\n    /**\n     * The remaining capacity available in the blocking queue.\n     *\n     * @return the remaining capacity\n     * @see {@link java.util.concurrent.BlockingQueue#remainingCapacity()}\n     */\n    public int getRemainingCapacity() {\n        return blockingQueue.remainingCapacity();\n    }\n\n    public void addAppender(Appender<E> newAppender) {\n        if (appenderCount == 0) {\n            appenderCount++;\n            addInfo(\"Attaching appender named [\" + newAppender.getName() + \"] to AsyncAppender.\");\n            aai.addAppender(newAppender);\n        } else {\n            addWarn(\"One and only one appender may be attached to AsyncAppender.\");\n            addWarn(\"Ignoring additional appender named [\" + newAppender.getName() + \"]\");\n        }\n    }\n\n    public Iterator<Appender<E>> iteratorForAppenders() {\n        return aai.iteratorForAppenders();\n    }\n\n    public Appender<E> getAppender(String name) {\n        return aai.getAppender(name);\n    }\n\n    public boolean isAttached(Appender<E> eAppender) {\n        return aai.isAttached(eAppender);\n    }\n\n    public void detachAndStopAllAppenders() {\n        aai.detachAndStopAllAppenders();\n    }\n\n    public boolean detachAppender(Appender<E> eAppender) {\n        return aai.detachAppender(eAppender);\n    }\n\n    public boolean detachAppender(String name) {\n        return aai.detachAppender(name);\n    }\n\n    class Worker extends Thread {\n\n        public void run() {\n            AsyncAppenderBase<E> parent = AsyncAppenderBase.this;\n            AppenderAttachableImpl<E> aai = parent.aai;\n\n            // loop while the parent is started\n            while (parent.isStarted()) {\n                try {\n                    E e = parent.blockingQueue.take();\n                    aai.appendLoopOnAppenders(e);\n                } catch (InterruptedException ie) {\n                    break;\n                }\n            }\n\n            addInfo(\"Worker thread will flush remaining events before exiting. \");\n\n            for (E e : parent.blockingQueue) {\n                aai.appendLoopOnAppenders(e);\n                parent.blockingQueue.remove(e);\n            }\n\n            aai.detachAndStopAllAppenders();\n        }\n    }\n}\n","lineNo":144}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.encoder;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;\n\nimport ch.qos.logback.core.CoreConstants;\nimport ch.qos.logback.core.Layout;\n\npublic class LayoutWrappingEncoder<E> extends EncoderBase<E> {\n\n    protected Layout<E> layout;\n\n    /**\n     * The charset to use when converting a String into bytes.\n     * <p/>\n     * By default this property has the value\n     * <code>null<\/null> which corresponds to\n     * the system's default charset.\n     */\n    private Charset charset;\n\n    private boolean immediateFlush = true;\n\n    /**\n     * Sets the immediateFlush option. The default value for immediateFlush is 'true'. If set to true,\n     * the doEncode() method will immediately flush the underlying OutputStream. Although immediate flushing\n     * is safer, it also significantly degrades logging throughput.\n     *\n     * @since 1.0.3\n     */\n    public void setImmediateFlush(boolean immediateFlush) {\n        this.immediateFlush = immediateFlush;\n    }\n\n    public boolean isImmediateFlush() {\n        return immediateFlush;\n    }\n\n    public Layout<E> getLayout() {\n        return layout;\n    }\n\n    public void setLayout(Layout<E> layout) {\n        this.layout = layout;\n    }\n\n    public Charset getCharset() {\n        return charset;\n    }\n\n    /**\n     * Set the charset to use when converting the string returned by the layout\n     * into bytes.\n     * <p/>\n     * By default this property has the value\n     * <code>null<\/null> which corresponds to\n     * the system's default charset.\n     *\n     * @param charset\n     */\n    public void setCharset(Charset charset) {\n        this.charset = charset;\n    }\n\n    public void init(OutputStream os) throws IOException {\n        super.init(os);\n        writeHeader();\n    }\n\n    void writeHeader() throws IOException {\n        if (layout != null && (outputStream != null)) {\n            StringBuilder sb = new StringBuilder();\n            appendIfNotNull(sb, layout.getFileHeader());\n            appendIfNotNull(sb, layout.getPresentationHeader());\n            if (sb.length() > 0) {\n                sb.append(CoreConstants.LINE_SEPARATOR);\n                // If at least one of file header or presentation header were not\n                // null, then append a line separator.\n                // This should be useful in most cases and should not hurt.\n                outputStream.write(convertToBytes(sb.toString()));\n                outputStream.flush();\n            }\n        }\n    }\n\n    public void close() throws IOException {\n        writeFooter();\n    }\n\n    void writeFooter() throws IOException {\n        if (layout != null && outputStream != null) {\n            StringBuilder sb = new StringBuilder();\n            appendIfNotNull(sb, layout.getPresentationFooter());\n            appendIfNotNull(sb, layout.getFileFooter());\n            if (sb.length() > 0) {\n                outputStream.write(convertToBytes(sb.toString()));\n                outputStream.flush();\n            }\n        }\n    }\n\n    private byte[] convertToBytes(String s) {\n        if (charset == null) {\n            return s.getBytes();\n        } else {\n            try {\n                return s.getBytes(charset.name());\n            } catch (UnsupportedEncodingException e) {\n                throw new IllegalStateException(\"An existing charset cannot possibly be unsupported.\");\n            }\n        }\n    }\n    \n    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n    \n    ReadLock lock1 = rwLock.readLock();\n    WriteLock lock2 = rwLock.writeLock();\n\n    public void doEncode(E event) throws IOException {\n        //lock1.lock();\n        byte[] bytes = null;\n        //try {\n            String txt = layout.doLayout(event);\n            bytes = convertToBytes(txt);\n        //} finally {\n          //  lock1.unlock();\n        //}\n\n        lock2.lock();\n        try {\n            outputStream.write(bytes);\n            if (immediateFlush)\n                outputStream.flush();\n        } finally {\n            lock2.unlock();\n        }\n    }\n\n    public boolean isStarted() {\n        return false;\n    }\n\n    public void start() {\n        started = true;\n    }\n\n    public void stop() {\n        started = false;\n        if (outputStream != null) {\n            try {\n                outputStream.flush();\n            } catch (IOException e) {\n            }\n        }\n    }\n\n    private void appendIfNotNull(StringBuilder sb, String s) {\n        if (s != null) {\n            sb.append(s);\n        }\n    }\n\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.encoder;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\n\nimport ch.qos.logback.core.CoreConstants;\nimport ch.qos.logback.core.Layout;\n\npublic class LayoutWrappingEncoder<E> extends EncoderBase<E> {\n\n    protected Layout<E> layout;\n\n    /**\n     * The charset to use when converting a String into bytes.\n     * <p/>\n     * By default this property has the value\n     * <code>null<\/null> which corresponds to\n     * the system's default charset.\n     */\n    private Charset charset;\n\n    private boolean immediateFlush = true;\n\n    /**\n     * Sets the immediateFlush option. The default value for immediateFlush is 'true'. If set to true,\n     * the doEncode() method will immediately flush the underlying OutputStream. Although immediate flushing\n     * is safer, it also significantly degrades logging throughput.\n     *\n     * @since 1.0.3\n     */\n    public void setImmediateFlush(boolean immediateFlush) {\n        this.immediateFlush = immediateFlush;\n    }\n\n    public boolean isImmediateFlush() {\n        return immediateFlush;\n    }\n\n    public Layout<E> getLayout() {\n        return layout;\n    }\n\n    public void setLayout(Layout<E> layout) {\n        this.layout = layout;\n    }\n\n    public Charset getCharset() {\n        return charset;\n    }\n\n    /**\n     * Set the charset to use when converting the string returned by the layout\n     * into bytes.\n     * <p/>\n     * By default this property has the value\n     * <code>null<\/null> which corresponds to\n     * the system's default charset.\n     *\n     * @param charset\n     */\n    public void setCharset(Charset charset) {\n        this.charset = charset;\n    }\n\n    public void init(OutputStream os) throws IOException {\n        super.init(os);\n        writeHeader();\n    }\n\n    void writeHeader() throws IOException {\n        if (layout != null && (outputStream != null)) {\n            StringBuilder sb = new StringBuilder();\n            appendIfNotNull(sb, layout.getFileHeader());\n            appendIfNotNull(sb, layout.getPresentationHeader());\n            if (sb.length() > 0) {\n                sb.append(CoreConstants.LINE_SEPARATOR);\n                // If at least one of file header or presentation header were not\n                // null, then append a line separator.\n                // This should be useful in most cases and should not hurt.\n                outputStream.write(convertToBytes(sb.toString()));\n                outputStream.flush();\n            }\n        }\n    }\n\n    public void close() throws IOException {\n        writeFooter();\n    }\n\n    void writeFooter() throws IOException {\n        if (layout != null && outputStream != null) {\n            StringBuilder sb = new StringBuilder();\n            appendIfNotNull(sb, layout.getPresentationFooter());\n            appendIfNotNull(sb, layout.getFileFooter());\n            if (sb.length() > 0) {\n                outputStream.write(convertToBytes(sb.toString()));\n                outputStream.flush();\n            }\n        }\n    }\n\n    private byte[] convertToBytes(String s) {\n        if (charset == null) {\n            return s.getBytes();\n        } else {\n            try {\n                return s.getBytes(charset.name());\n            } catch (UnsupportedEncodingException e) {\n                throw new IllegalStateException(\"An existing charset cannot possibly be unsupported.\");\n            }\n        }\n    }\n\n    public void doEncode(E event) throws IOException {\n        String txt = layout.doLayout(event);\n        outputStream.write(convertToBytes(txt));\n        if (immediateFlush)\n            outputStream.flush();\n    }\n\n    public boolean isStarted() {\n        return false;\n    }\n\n    public void start() {\n        started = true;\n    }\n\n    public void stop() {\n        started = false;\n        if (outputStream != null) {\n            try {\n                outputStream.flush();\n            } catch (IOException e) {\n            }\n        }\n    }\n\n    private void appendIfNotNull(StringBuilder sb, String s) {\n        if (s != null) {\n            sb.append(s);\n        }\n    }\n\n}\n","lineNo":141}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.joran;\n\nimport ch.qos.logback.core.Context;\nimport ch.qos.logback.core.joran.event.SaxEvent;\nimport ch.qos.logback.core.joran.event.SaxEventRecorder;\nimport ch.qos.logback.core.joran.spi.*;\nimport ch.qos.logback.core.joran.util.ConfigurationWatchListUtil;\nimport ch.qos.logback.core.joran.util.beans.BeanDescriptionCache;\nimport ch.qos.logback.core.spi.ContextAwareBase;\nimport ch.qos.logback.core.status.StatusUtil;\n\nimport org.xml.sax.InputSource;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.List;\n\nimport static ch.qos.logback.core.CoreConstants.SAFE_JORAN_CONFIGURATION;\n\npublic abstract class GenericConfigurator extends ContextAwareBase {\n\n    private BeanDescriptionCache beanDescriptionCache;\n\n    protected Interpreter interpreter;\n\n    public final void doConfigure(URL url) throws JoranException {\n        InputStream in = null;\n        try {\n            informContextOfURLUsedForConfiguration(getContext(), url);\n            URLConnection urlConnection = url.openConnection();\n            // per http://jira.qos.ch/browse/LBCORE-105\n            // per http://jira.qos.ch/browse/LBCORE-127\n            urlConnection.setUseCaches(false);\n\n            in = urlConnection.getInputStream();\n            doConfigure(in, url.toExternalForm());\n        } catch (IOException ioe) {\n            String errMsg = \"Could not open URL [\" + url + \"].\";\n            addError(errMsg, ioe);\n            throw new JoranException(errMsg, ioe);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ioe) {\n                    String errMsg = \"Could not close input stream\";\n                    addError(errMsg, ioe);\n                    throw new JoranException(errMsg, ioe);\n                }\n            }\n        }\n    }\n\n    public final void doConfigure(String filename) throws JoranException {\n        doConfigure(new File(filename));\n    }\n\n    public final void doConfigure(File file) throws JoranException {\n        FileInputStream fis = null;\n        try {\n            URL url = file.toURI().toURL();\n            informContextOfURLUsedForConfiguration(getContext(), url);\n            fis = new FileInputStream(file);\n            doConfigure(fis, url.toExternalForm());\n        } catch (IOException ioe) {\n            String errMsg = \"Could not open [\" + file.getPath() + \"].\";\n            addError(errMsg, ioe);\n            throw new JoranException(errMsg, ioe);\n        } finally {\n            if (fis != null) {\n                try {\n                    fis.close();\n                } catch (java.io.IOException ioe) {\n                    String errMsg = \"Could not close [\" + file.getName() + \"].\";\n                    addError(errMsg, ioe);\n                    throw new JoranException(errMsg, ioe);\n                }\n            }\n        }\n    }\n\n    public static void informContextOfURLUsedForConfiguration(Context context, URL url) {\n        ConfigurationWatchListUtil.setMainWatchURL(context, url);\n    }\n\n    public final void doConfigure(InputStream inputStream) throws JoranException {\n        doConfigure(new InputSource(inputStream));\n    }\n\n    public final void doConfigure(InputStream inputStream, String systemId) throws JoranException {\n        InputSource inputSource = new InputSource(inputStream);\n        inputSource.setSystemId(systemId);\n        doConfigure(inputSource);\n    }\n\n    protected BeanDescriptionCache getBeanDescriptionCache() {\n        if (beanDescriptionCache == null) {\n            beanDescriptionCache = new BeanDescriptionCache(getContext());\n        }\n        return beanDescriptionCache;\n    }\n\n    protected abstract void addInstanceRules(RuleStore rs);\n\n    protected abstract void addImplicitRules(Interpreter interpreter);\n\n    protected void addDefaultNestedComponentRegistryRules(DefaultNestedComponentRegistry registry) {\n\n    }\n\n    protected ElementPath initialElementPath() {\n        return new ElementPath();\n    }\n\n    protected void buildInterpreter() {\n        RuleStore rs = new SimpleRuleStore(context);\n        addInstanceRules(rs);\n        this.interpreter = new Interpreter(context, rs, initialElementPath());\n        InterpretationContext interpretationContext = interpreter.getInterpretationContext();\n        interpretationContext.setContext(context);\n        addImplicitRules(interpreter);\n        addDefaultNestedComponentRegistryRules(interpretationContext.getDefaultNestedComponentRegistry());\n    }\n\n    // this is the most inner form of doConfigure whereto other doConfigure\n    // methods ultimately delegate\n    public final void doConfigure(final InputSource inputSource) throws JoranException {\n\n        long threshold = System.currentTimeMillis();\n        // if (!ConfigurationWatchListUtil.wasConfigurationWatchListReset(context)) {\n        // informContextOfURLUsedForConfiguration(getContext(), null);\n        // }\n        SaxEventRecorder recorder = new SaxEventRecorder(context);\n        recorder.recordEvents(inputSource);\n        doConfigure(recorder.saxEventList);\n        // no exceptions a this level\n        StatusUtil statusUtil = new StatusUtil(context);\n        if (statusUtil.noXMLParsingErrorsOccurred(threshold)) {\n            addInfo(\"Registering current configuration as safe fallback point\");\n            registerSafeConfiguration(recorder.saxEventList);\n        }\n    }\n\n    public void doConfigure(final List<SaxEvent> eventList) throws JoranException {\n        buildInterpreter();\n        // disallow simultaneous configurations of the same context\n        synchronized (context.getConfigurationLock()) {\n            interpreter.getEventPlayer().play(eventList);\n        }\n    }\n\n    /**\n     * Register the current event list in currently in the interpreter as a safe\n     * configuration point.\n     *\n     * @since 0.9.30\n     */\n    public void registerSafeConfiguration(List<SaxEvent> eventList) {\n        context.putObject(SAFE_JORAN_CONFIGURATION, eventList);\n    }\n\n    /**\n     * Recall the event list previously registered as a safe point.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public List<SaxEvent> recallSafeConfiguration() {\n        return (List<SaxEvent>) context.getObject(SAFE_JORAN_CONFIGURATION);\n    }\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.joran;\n\nimport ch.qos.logback.core.Context;\nimport ch.qos.logback.core.joran.event.SaxEvent;\nimport ch.qos.logback.core.joran.event.SaxEventRecorder;\nimport ch.qos.logback.core.joran.spi.*;\nimport ch.qos.logback.core.joran.util.ConfigurationWatchListUtil;\nimport ch.qos.logback.core.joran.util.beans.BeanDescriptionCache;\nimport ch.qos.logback.core.spi.ContextAwareBase;\nimport ch.qos.logback.core.status.StatusUtil;\n\nimport org.xml.sax.InputSource;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.List;\n\nimport static ch.qos.logback.core.CoreConstants.SAFE_JORAN_CONFIGURATION;\n\npublic abstract class GenericConfigurator extends ContextAwareBase {\n\n    private BeanDescriptionCache beanDescriptionCache;\n\n    protected Interpreter interpreter;\n\n    public final void doConfigure(URL url) throws JoranException {\n        InputStream in = null;\n        try {\n            informContextOfURLUsedForConfiguration(getContext(), url);\n            URLConnection urlConnection = url.openConnection();\n            // per http://jira.qos.ch/browse/LBCORE-105\n            // per http://jira.qos.ch/browse/LBCORE-127\n            urlConnection.setUseCaches(false);\n\n            in = urlConnection.getInputStream();\n            doConfigure(in);\n        } catch (IOException ioe) {\n            String errMsg = \"Could not open URL [\" + url + \"].\";\n            addError(errMsg, ioe);\n            throw new JoranException(errMsg, ioe);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ioe) {\n                    String errMsg = \"Could not close input stream\";\n                    addError(errMsg, ioe);\n                    throw new JoranException(errMsg, ioe);\n                }\n            }\n        }\n    }\n\n    public final void doConfigure(String filename) throws JoranException {\n        doConfigure(new File(filename));\n    }\n\n    public final void doConfigure(File file) throws JoranException {\n        FileInputStream fis = null;\n        try {\n            informContextOfURLUsedForConfiguration(getContext(), file.toURI().toURL());\n            fis = new FileInputStream(file);\n            doConfigure(fis);\n        } catch (IOException ioe) {\n            String errMsg = \"Could not open [\" + file.getPath() + \"].\";\n            addError(errMsg, ioe);\n            throw new JoranException(errMsg, ioe);\n        } finally {\n            if (fis != null) {\n                try {\n                    fis.close();\n                } catch (java.io.IOException ioe) {\n                    String errMsg = \"Could not close [\" + file.getName() + \"].\";\n                    addError(errMsg, ioe);\n                    throw new JoranException(errMsg, ioe);\n                }\n            }\n        }\n    }\n\n    public static void informContextOfURLUsedForConfiguration(Context context, URL url) {\n        ConfigurationWatchListUtil.setMainWatchURL(context, url);\n    }\n\n    public final void doConfigure(InputStream inputStream) throws JoranException {\n        doConfigure(new InputSource(inputStream));\n    }\n\n    protected BeanDescriptionCache getBeanDescriptionCache() {\n        if (beanDescriptionCache == null) {\n            beanDescriptionCache = new BeanDescriptionCache(getContext());\n        }\n        return beanDescriptionCache;\n    }\n\n    protected abstract void addInstanceRules(RuleStore rs);\n\n    protected abstract void addImplicitRules(Interpreter interpreter);\n\n    protected void addDefaultNestedComponentRegistryRules(DefaultNestedComponentRegistry registry) {\n\n    }\n\n    protected ElementPath initialElementPath() {\n        return new ElementPath();\n    }\n\n    protected void buildInterpreter() {\n        RuleStore rs = new SimpleRuleStore(context);\n        addInstanceRules(rs);\n        this.interpreter = new Interpreter(context, rs, initialElementPath());\n        InterpretationContext interpretationContext = interpreter.getInterpretationContext();\n        interpretationContext.setContext(context);\n        addImplicitRules(interpreter);\n        addDefaultNestedComponentRegistryRules(interpretationContext.getDefaultNestedComponentRegistry());\n    }\n\n    // this is the most inner form of doConfigure whereto other doConfigure\n    // methods ultimately delegate\n    public final void doConfigure(final InputSource inputSource) throws JoranException {\n\n        long threshold = System.currentTimeMillis();\n        // if (!ConfigurationWatchListUtil.wasConfigurationWatchListReset(context)) {\n        // informContextOfURLUsedForConfiguration(getContext(), null);\n        // }\n        SaxEventRecorder recorder = new SaxEventRecorder(context);\n        recorder.recordEvents(inputSource);\n        doConfigure(recorder.saxEventList);\n        // no exceptions a this level\n        StatusUtil statusUtil = new StatusUtil(context);\n        if (statusUtil.noXMLParsingErrorsOccurred(threshold)) {\n            addInfo(\"Registering current configuration as safe fallback point\");\n            registerSafeConfiguration(recorder.saxEventList);\n        }\n    }\n\n    public void doConfigure(final List<SaxEvent> eventList) throws JoranException {\n        buildInterpreter();\n        // disallow simultaneous configurations of the same context\n        synchronized (context.getConfigurationLock()) {\n            interpreter.getEventPlayer().play(eventList);\n        }\n    }\n\n    /**\n     * Register the current event list in currently in the interpreter as a safe\n     * configuration point.\n     *\n     * @since 0.9.30\n     */\n    public void registerSafeConfiguration(List<SaxEvent> eventList) {\n        context.putObject(SAFE_JORAN_CONFIGURATION, eventList);\n    }\n\n    /**\n     * Recall the event list previously registered as a safe point.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public List<SaxEvent> recallSafeConfiguration() {\n        return (List<SaxEvent>) context.getObject(SAFE_JORAN_CONFIGURATION);\n    }\n}\n","lineNo":78}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.pattern;\n\nimport java.io.BufferedReader;\nimport java.io.PrintWriter;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport ch.qos.logback.core.CoreConstants;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport ch.qos.logback.classic.Level;\nimport ch.qos.logback.classic.Logger;\nimport ch.qos.logback.classic.LoggerContext;\nimport ch.qos.logback.classic.spi.ILoggingEvent;\nimport ch.qos.logback.classic.spi.LoggingEvent;\nimport ch.qos.logback.classic.util.TestHelper;\n\nimport static ch.qos.logback.classic.util.TestHelper.addSuppressed;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.Assert.*;\nimport static org.junit.Assume.assumeTrue;\n\npublic class ThrowableProxyConverterTest {\n\n    LoggerContext lc = new LoggerContext();\n    ThrowableProxyConverter tpc = new ThrowableProxyConverter();\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n\n    @Before\n    public void setUp() throws Exception {\n        tpc.setContext(lc);\n        tpc.start();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n    }\n\n    private ILoggingEvent createLoggingEvent(Throwable t) {\n        return new LoggingEvent(this.getClass().getName(), lc.getLogger(Logger.ROOT_LOGGER_NAME), Level.DEBUG, \"test message\", t, null);\n    }\n\n    @Test\n    public void suppressed() throws InvocationTargetException, IllegalAccessException {\n        assumeTrue(TestHelper.suppressedSupported()); // only execute on Java 7, would work anyway but doesn't make\n                                                      // sense.\n        Exception ex = null;\n        try {\n            someMethod();\n        } catch (Exception e) {\n            Exception fooException = new Exception(\"Foo\");\n            Exception barException = new Exception(\"Bar\");\n            addSuppressed(e, fooException);\n            addSuppressed(e, barException);\n            ex = e;\n        }\n        verify(ex);\n    }\n\n    @Test\n    public void suppressedWithCause() throws InvocationTargetException, IllegalAccessException {\n        assumeTrue(TestHelper.suppressedSupported()); // only execute on Java 7, would work anyway but doesn't make\n                                                      // sense.\n        Exception ex = null;\n        try {\n            someMethod();\n        } catch (Exception e) {\n            ex = new Exception(\"Wrapper\", e);\n            Exception fooException = new Exception(\"Foo\");\n            Exception barException = new Exception(\"Bar\");\n            addSuppressed(ex, fooException);\n            addSuppressed(e, barException);\n        }\n        verify(ex);\n    }\n\n    @Test\n    public void suppressedWithSuppressed() throws Exception {\n        assumeTrue(TestHelper.suppressedSupported()); // only execute on Java 7, would work anyway but doesn't make\n                                                      // sense.\n        Exception ex = null;\n        try {\n            someMethod();\n        } catch (Exception e) {\n            ex = new Exception(\"Wrapper\", e);\n            Exception fooException = new Exception(\"Foo\");\n            Exception barException = new Exception(\"Bar\");\n            addSuppressed(barException, fooException);\n            addSuppressed(e, barException);\n        }\n        verify(ex);\n    }\n\n    @Test\n    public void smoke() {\n        Exception t = new Exception(\"smoke\");\n        verify(t);\n    }\n\n    @Test\n    public void nested() {\n        Throwable t = TestHelper.makeNestedException(1);\n        verify(t);\n    }\n\n    @Test\n    public void withArgumentOfOne() throws Exception {\n        final Throwable t = TestHelper.makeNestedException(0);\n        t.printStackTrace(pw);\n        final ILoggingEvent le = createLoggingEvent(t);\n\n        final List<String> optionList = Arrays.asList(\"1\");\n        tpc.setOptionList(optionList);\n        tpc.start();\n\n        final String result = tpc.convert(le);\n\n        final BufferedReader reader = new BufferedReader(new StringReader(result));\n        assertTrue(reader.readLine().contains(t.getMessage()));\n        assertNotNull(reader.readLine());\n        assertNull(\"Unexpected line in stack trace\", reader.readLine());\n    }\n\n    @Test\n    public void withShortArgument() throws Exception {\n        final Throwable t = TestHelper.makeNestedException(0);\n        t.printStackTrace(pw);\n        final ILoggingEvent le = createLoggingEvent(t);\n\n        final List<String> options = Arrays.asList(\"short\");\n        tpc.setOptionList(options);\n        tpc.start();\n\n        final String result = tpc.convert(le);\n\n        final BufferedReader reader = new BufferedReader(new StringReader(result));\n        assertTrue(reader.readLine().contains(t.getMessage()));\n        assertNotNull(reader.readLine());\n        assertNull(\"Unexpected line in stack trace\", reader.readLine());\n    }\n\n    @Test\n    public void skipSelectedLine() throws Exception {\n        String nameOfContainingMethod = \"skipSelectedLine\";\n        // given\n        final Throwable t = TestHelper.makeNestedException(0);\n        t.printStackTrace(pw);\n        final ILoggingEvent le = createLoggingEvent(t);\n        tpc.setOptionList(Arrays.asList(\"full\", nameOfContainingMethod));\n        tpc.start();\n\n        // when\n        final String result = tpc.convert(le);\n\n        // then\n        assertThat(result).doesNotContain(nameOfContainingMethod);\n        \n    }\n\n    @Test\n    public void skipMultipleLines() throws Exception {\n        String nameOfContainingMethod = \"skipMultipleLines\";\n        // given\n        final Throwable t = TestHelper.makeNestedException(0);\n        t.printStackTrace(pw);\n        final ILoggingEvent le = createLoggingEvent(t);\n        tpc.setOptionList(Arrays.asList(\"full\", nameOfContainingMethod, \"junit\"));\n        tpc.start();\n\n        // when\n        final String result = tpc.convert(le);\n\n        // then\n        assertThat(result).doesNotContain(nameOfContainingMethod).doesNotContain(\"junit\");\n    }\n\n    @Test\n    public void shouldLimitTotalLinesExcludingSkipped() throws Exception {\n        // given\n        final Throwable t = TestHelper.makeNestedException(0);\n        t.printStackTrace(pw);\n        final ILoggingEvent le = createLoggingEvent(t);\n        tpc.setOptionList(Arrays.asList(\"3\", \"shouldLimitTotalLinesExcludingSkipped\"));\n        tpc.start();\n\n        // when\n        final String result = tpc.convert(le);\n\n        // then\n        String[] lines = result.split(CoreConstants.LINE_SEPARATOR);\n        assertThat(lines).hasSize(3 + 1);\n    }\n\n    void someMethod() throws Exception {\n        throw new Exception(\"someMethod\");\n    }\n\n    void verify(Throwable t) {\n        t.printStackTrace(pw);\n\n        ILoggingEvent le = createLoggingEvent(t);\n        String result = tpc.convert(le);\n        System.out.println(result);\n        result = result.replace(\"common frames omitted\", \"more\");\n        assertEquals(sw.toString(), result);\n    }\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.classic.pattern;\n\nimport java.io.BufferedReader;\nimport java.io.PrintWriter;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport ch.qos.logback.core.CoreConstants;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport ch.qos.logback.classic.Level;\nimport ch.qos.logback.classic.Logger;\nimport ch.qos.logback.classic.LoggerContext;\nimport ch.qos.logback.classic.spi.ILoggingEvent;\nimport ch.qos.logback.classic.spi.LoggingEvent;\nimport ch.qos.logback.classic.util.TestHelper;\n\nimport static ch.qos.logback.classic.util.TestHelper.addSuppressed;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.Assert.*;\nimport static org.junit.Assume.assumeTrue;\n\npublic class ThrowableProxyConverterTest {\n\n    LoggerContext lc = new LoggerContext();\n    ThrowableProxyConverter tpc = new ThrowableProxyConverter();\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n\n    @Before\n    public void setUp() throws Exception {\n        tpc.setContext(lc);\n        tpc.start();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n    }\n\n    private ILoggingEvent createLoggingEvent(Throwable t) {\n        return new LoggingEvent(this.getClass().getName(), lc.getLogger(Logger.ROOT_LOGGER_NAME), Level.DEBUG, \"test message\", t, null);\n    }\n\n    @Test\n    public void suppressed() throws InvocationTargetException, IllegalAccessException {\n        assumeTrue(TestHelper.suppressedSupported()); // only execute on Java 7, would work anyway but doesn't make\n                                                      // sense.\n        Exception ex = null;\n        try {\n            someMethod();\n        } catch (Exception e) {\n            Exception fooException = new Exception(\"Foo\");\n            Exception barException = new Exception(\"Bar\");\n            addSuppressed(e, fooException);\n            addSuppressed(e, barException);\n            ex = e;\n        }\n        verify(ex);\n    }\n\n    @Test\n    public void suppressedWithCause() throws InvocationTargetException, IllegalAccessException {\n        assumeTrue(TestHelper.suppressedSupported()); // only execute on Java 7, would work anyway but doesn't make\n                                                      // sense.\n        Exception ex = null;\n        try {\n            someMethod();\n        } catch (Exception e) {\n            ex = new Exception(\"Wrapper\", e);\n            Exception fooException = new Exception(\"Foo\");\n            Exception barException = new Exception(\"Bar\");\n            addSuppressed(ex, fooException);\n            addSuppressed(e, barException);\n        }\n        verify(ex);\n    }\n\n    @Test\n    public void suppressedWithSuppressed() throws Exception {\n        assumeTrue(TestHelper.suppressedSupported()); // only execute on Java 7, would work anyway but doesn't make\n                                                      // sense.\n        Exception ex = null;\n        try {\n            someMethod();\n        } catch (Exception e) {\n            ex = new Exception(\"Wrapper\", e);\n            Exception fooException = new Exception(\"Foo\");\n            Exception barException = new Exception(\"Bar\");\n            addSuppressed(barException, fooException);\n            addSuppressed(e, barException);\n        }\n        verify(ex);\n    }\n\n    @Test\n    public void smoke() {\n        Exception t = new Exception(\"smoke\");\n        verify(t);\n    }\n\n    @Test\n    public void nested() {\n        Throwable t = TestHelper.makeNestedException(1);\n        verify(t);\n    }\n\n    @Test\n    public void withArgumentOfOne() throws Exception {\n        final Throwable t = TestHelper.makeNestedException(0);\n        t.printStackTrace(pw);\n        final ILoggingEvent le = createLoggingEvent(t);\n\n        final List<String> optionList = Arrays.asList(\"1\");\n        tpc.setOptionList(optionList);\n        tpc.start();\n\n        final String result = tpc.convert(le);\n\n        final BufferedReader reader = new BufferedReader(new StringReader(result));\n        assertTrue(reader.readLine().contains(t.getMessage()));\n        assertNotNull(reader.readLine());\n        assertNull(\"Unexpected line in stack trace\", reader.readLine());\n    }\n\n    @Test\n    public void withShortArgument() throws Exception {\n        final Throwable t = TestHelper.makeNestedException(0);\n        t.printStackTrace(pw);\n        final ILoggingEvent le = createLoggingEvent(t);\n\n        final List<String> options = Arrays.asList(\"short\");\n        tpc.setOptionList(options);\n        tpc.start();\n\n        final String result = tpc.convert(le);\n\n        final BufferedReader reader = new BufferedReader(new StringReader(result));\n        assertTrue(reader.readLine().contains(t.getMessage()));\n        assertNotNull(reader.readLine());\n        assertNull(\"Unexpected line in stack trace\", reader.readLine());\n    }\n\n    @Test\n    public void skipSelectedLine() throws Exception {\n        // given\n        final Throwable t = TestHelper.makeNestedException(0);\n        t.printStackTrace(pw);\n        final ILoggingEvent le = createLoggingEvent(t);\n        tpc.setOptionList(Arrays.asList(\"full\", \"skipSelectedLines\"));\n        tpc.start();\n\n        // when\n        final String result = tpc.convert(le);\n\n        // then\n        assertThat(result).doesNotContain(\"skipSelectedLines\");\n    }\n\n    @Test\n    public void skipMultipleLines() throws Exception {\n        // given\n        final Throwable t = TestHelper.makeNestedException(0);\n        t.printStackTrace(pw);\n        final ILoggingEvent le = createLoggingEvent(t);\n        tpc.setOptionList(Arrays.asList(\"full\", \"skipMultipleLines\", \"junit\"));\n        tpc.start();\n\n        // when\n        final String result = tpc.convert(le);\n\n        // then\n        assertThat(result).doesNotContain(\"skipSelectedLines\").doesNotContain(\"junit\");\n    }\n\n    @Test\n    public void shouldLimitTotalLinesExcludingSkipped() throws Exception {\n        // given\n        final Throwable t = TestHelper.makeNestedException(0);\n        t.printStackTrace(pw);\n        final ILoggingEvent le = createLoggingEvent(t);\n        tpc.setOptionList(Arrays.asList(\"3\", \"shouldLimitTotalLinesExcludingSkipped\"));\n        tpc.start();\n\n        // when\n        final String result = tpc.convert(le);\n\n        // then\n        String[] lines = result.split(CoreConstants.LINE_SEPARATOR);\n        assertThat(lines).hasSize(3 + 1);\n    }\n\n    void someMethod() throws Exception {\n        throw new Exception(\"someMethod\");\n    }\n\n    void verify(Throwable t) {\n        t.printStackTrace(pw);\n\n        ILoggingEvent le = createLoggingEvent(t);\n        String result = tpc.convert(le);\n        System.out.println(result);\n        result = result.replace(\"common frames omitted\", \"more\");\n        assertEquals(sw.toString(), result);\n    }\n}\n","lineNo":181}
{"Refactored Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.rolling;\n\nimport static ch.qos.logback.core.CoreConstants.DAILY_DATE_PATTERN;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.Days;\nimport org.joda.time.LocalDate;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Test;\n\nimport ch.qos.logback.core.CoreConstants;\nimport ch.qos.logback.core.pattern.SpacePadder;\nimport ch.qos.logback.core.rolling.helper.RollingCalendar;\nimport ch.qos.logback.core.util.FixedRateInvocationGate;\nimport ch.qos.logback.core.util.StatusPrinter;\n\npublic class TimeBasedRollingWithArchiveRemoval_Test extends ScaffoldingForRollingTests {\n    String MONTHLY_DATE_PATTERN = \"yyyy-MM\";\n    String MONTHLY_CRONOLOG_DATE_PATTERN = \"yyyy/MM\";\n    final String DAILY_CRONOLOG_DATE_PATTERN = \"yyyy/MM/dd\";\n\n    RollingFileAppender<Object> rfa = new RollingFileAppender<Object>();\n    TimeBasedRollingPolicy<Object> tbrp = new TimeBasedRollingPolicy<Object>();\n\n    // by default tbfnatp is an instance of DefaultTimeBasedFileNamingAndTriggeringPolicy\n    TimeBasedFileNamingAndTriggeringPolicy<Object> tbfnatp = new DefaultTimeBasedFileNamingAndTriggeringPolicy<Object>();\n\n    static long MILLIS_IN_MINUTE = 60 * 1000;\n    static long MILLIS_IN_HOUR = 60 * MILLIS_IN_MINUTE;\n    static long MILLIS_IN_DAY = 24 * MILLIS_IN_HOUR;\n    static long MILLIS_IN_MONTH = (long) ((365.242199 / 12) * MILLIS_IN_DAY);\n    static int MONTHS_IN_YEAR = 12;\n\n    // Wed Mar 23 23:07:05 CET 2016\n    static final long WED_2016_03_23_T_230705_CET = 1458770825333L;\n    static final long THU_2016_03_17_T_230330_CET = 1458252210975L;\n\n    \n    int slashCount = 0;\n    int ticksPerPeriod = 216; \n    \n    ConfigParameters cp; // initialized in setup\n    FixedRateInvocationGate fixedRateInvocationGate = new FixedRateInvocationGate(ticksPerPeriod/2);\n    \n    @Before\n    public void setUp() {\n        super.setUp();\n        this.cp = new ConfigParameters(currentTime);\n    }\n\n    private int computeSlashCount(String datePattern) {\n        if (datePattern == null)\n            return 0;\n        else {\n            int count = 0;\n            for (int i = 0; i < datePattern.length(); i++) {\n                char c = datePattern.charAt(i);\n                if (c == '/')\n                    count++;\n            }\n            return count;\n        }\n    }\n\n    // test that the number of files at the end of the test is same as the expected number taking into account end dates\n    // near the beginning of a new year. This test has been run in a loop with start date varying over a two years\n    // with success.\n    @Test\n    public void monthlyRolloverOverManyPeriods() {\n        this.slashCount = computeSlashCount(MONTHLY_CRONOLOG_DATE_PATTERN);\n        int maxHistory = 2;\n        int simulatedNumberOfPeriods = 30;\n        String fileNamePattern = randomOutputDir + \"/%d{\" + MONTHLY_CRONOLOG_DATE_PATTERN + \"}/clean.txt.zip\";\n\n        cp.maxHistory(maxHistory).fileNamePattern(fileNamePattern).simulatedNumberOfPeriods(simulatedNumberOfPeriods).periodDurationInMillis(MILLIS_IN_MONTH);\n\n        long startTime = currentTime;\n        long endTime = logOverMultiplePeriods(cp);\n        System.out.println(\"randomOutputDir:\" + randomOutputDir);\n        System.out.println(\"start:\" + startTime + \", end=\" + endTime);\n        int differenceInMonths = RollingCalendar.diffInMonths(startTime, endTime);\n        System.out.println(\"differenceInMonths:\" + differenceInMonths);\n        Calendar startTimeAsCalendar = Calendar.getInstance();\n        startTimeAsCalendar.setTimeInMillis(startTime);\n        int indexOfStartPeriod = startTimeAsCalendar.get(Calendar.MONTH);\n        boolean withExtraFolder = extraFolder(differenceInMonths, MONTHS_IN_YEAR, indexOfStartPeriod, maxHistory);\n\n        checkFileCount(expectedCountWithFolders(maxHistory, withExtraFolder));\n    }\n\n    long generateDailyRollover(ConfigParameters cp) {\n        this.slashCount = computeSlashCount(DAILY_DATE_PATTERN);\n        cp.fileNamePattern(randomOutputDir + \"clean-%d{\" + DAILY_DATE_PATTERN + \"}.txt\");\n        return logOverMultiplePeriods(cp);\n    }\n\n    long generateDailyRolloverAndCheckFileCount(ConfigParameters cp) {\n        long millisAtEnd = generateDailyRollover(cp);\n        int periodBarriersCrossed= computeCrossedDayBarriers(currentTime, millisAtEnd); \n        System.out.println(\"**** \"+periodBarriersCrossed);\n        checkFileCount(expectedCountWithoutFoldersWithInactivity(cp.maxHistory, periodBarriersCrossed, cp.startInactivity + cp.numInactivityPeriods));\n        return millisAtEnd;\n    }\n\n    @Test\n    public void checkCrossedPeriodsWithDSTBarrier() {\n        long SAT_2016_03_26_T_230705_CET = WED_2016_03_23_T_230705_CET+3*CoreConstants.MILLIS_IN_ONE_DAY;\n        System.out.println(\"SAT_2016_03_26_T_230705_CET \"+new Date(SAT_2016_03_26_T_230705_CET));\n        long MON_2016_03_28_T_000705_CET = SAT_2016_03_26_T_230705_CET+CoreConstants.MILLIS_IN_ONE_DAY;\n        System.out.println(\"MON_2016_03_28_T_000705_CET \"+new Date(MON_2016_03_28_T_000705_CET));\n            \n        int result = computeCrossedDayBarriers(SAT_2016_03_26_T_230705_CET, MON_2016_03_28_T_000705_CET, \"CET\");\n        assertEquals(2, result);\n    }\n   \n    private int computeCrossedDayBarriers(long currentTime, long millisAtEnd) {\n        return computeCrossedDayBarriers(currentTime, millisAtEnd, null);\n    }\n\n\n    private int computeCrossedDayBarriers(long currentTime, long millisAtEnd, String timeZoneID) {\n        DateTimeZone dateTimeZone = DateTimeZone.getDefault();\n        if(timeZoneID != null) {\n            dateTimeZone = DateTimeZone.forID(timeZoneID);\n        }\n        LocalDate startInstant = new LocalDate(currentTime, dateTimeZone);\n        LocalDate endInstant = new LocalDate(millisAtEnd, dateTimeZone);\n        Days days = Days.daysBetween(startInstant, endInstant);\n        return days.getDays();\n    }\n    \n    @Test\n    public void checkCleanupForBasicDailyRollover() {\n        cp.maxHistory(20).simulatedNumberOfPeriods(20 * 3).startInactivity(0).numInactivityPeriods(0);\n        generateDailyRolloverAndCheckFileCount(cp);\n    }\n\n    @Test\n    public void checkCleanupForBasicDailyRolloverWithSizeCap() {\n        long bytesOutputPerPeriod = 15984;\n        int sizeInUnitsOfBytesPerPeriod = 2;\n\n        cp.maxHistory(5).simulatedNumberOfPeriods(10).sizeCap(sizeInUnitsOfBytesPerPeriod * bytesOutputPerPeriod+1000);\n        generateDailyRollover(cp);\n        StatusPrinter.print(context);\n        checkFileCount(sizeInUnitsOfBytesPerPeriod+1);\n    }\n\n    @Test\n    public void checkCleanupForBasicDailyRolloverWithMaxSize() {\n        cp.maxHistory(6).simulatedNumberOfPeriods(30).startInactivity(10).numInactivityPeriods(1);\n        generateDailyRolloverAndCheckFileCount(cp);\n    }\n\n    // Since the duration of a month (in seconds) varies from month to month, tests with inactivity period must\n    // be conducted with daily rollover not monthly\n    @Test\n    public void checkCleanupForDailyRollover_15Periods() {\n        cp.maxHistory(5).simulatedNumberOfPeriods(15).startInactivity(6).numInactivityPeriods(3);\n        generateDailyRolloverAndCheckFileCount(cp);\n    }\n\n    @Test\n    public void checkCleanupForDailyRolloverWithInactivity_30Periods() {\n        /// -------\n        cp.maxHistory(2).simulatedNumberOfPeriods(30).startInactivity(3).numInactivityPeriods(1);\n        generateDailyRolloverAndCheckFileCount(cp);\n    }\n\n    \n    \n    @Test\n    public void checkCleanupForDailyRolloverWithInactivity_10Periods() {\n        this.currentTime = THU_2016_03_17_T_230330_CET;\n        cp.maxHistory(6).simulatedNumberOfPeriods(10).startInactivity(2).numInactivityPeriods(2);\n        generateDailyRolloverAndCheckFileCount(cp);\n    }\n\n    @Test\n    public void checkCleanupForDailyRolloverWithSecondPhase() {\n        slashCount = computeSlashCount(DAILY_DATE_PATTERN);\n        int maxHistory = 5;\n        String fileNamePattern = randomOutputDir + \"clean-%d{\" + DAILY_DATE_PATTERN + \"}.txt\";\n\n        ConfigParameters cp0 = new ConfigParameters(currentTime).maxHistory(maxHistory).fileNamePattern(fileNamePattern)\n                        .simulatedNumberOfPeriods(maxHistory * 2);\n        long endTime = logOverMultiplePeriods(cp0);\n\n        ConfigParameters cp1 = new ConfigParameters(endTime + MILLIS_IN_DAY * 10).maxHistory(maxHistory).fileNamePattern(fileNamePattern)\n                        .simulatedNumberOfPeriods(maxHistory);\n        logOverMultiplePeriods(cp1);\n        checkFileCount(expectedCountWithoutFolders(maxHistory));\n    }\n\n    @Test\n    public void dailyRolloverWithCronologPattern() {\n        this.slashCount = computeSlashCount(DAILY_CRONOLOG_DATE_PATTERN);\n        String fileNamePattern = randomOutputDir + \"/%d{\" + DAILY_CRONOLOG_DATE_PATTERN + \"}/clean.txt.zip\";\n        cp.maxHistory(8).fileNamePattern(fileNamePattern).simulatedNumberOfPeriods(8 * 3);\n        logOverMultiplePeriods(cp);\n        int expectedDirMin = 9 + slashCount;\n        int expectDirMax = expectedDirMin + 1 + 1;\n        expectedFileAndDirCount(9, expectedDirMin, expectDirMax);\n    }\n\n    @Test\n    public void dailySizeBasedRolloverWithoutCap() {\n        SizeAndTimeBasedFNATP<Object> sizeAndTimeBasedFNATP = new SizeAndTimeBasedFNATP<Object>();\n        sizeAndTimeBasedFNATP.invocationGate = fixedRateInvocationGate;\n        \n        sizeAndTimeBasedFNATP.setMaxFileSize(\"10000\");\n        tbfnatp = sizeAndTimeBasedFNATP;\n        this.slashCount = computeSlashCount(DAILY_DATE_PATTERN);\n        String fileNamePattern = randomOutputDir + \"/%d{\" + DAILY_DATE_PATTERN + \"}-clean.%i.zip\";\n        cp.maxHistory(5).fileNamePattern(fileNamePattern).simulatedNumberOfPeriods(5 * 4);\n        logOverMultiplePeriods(cp);\n        checkPatternCompliance(5 + 1 + slashCount, \"\\\\d{4}-\\\\d{2}-\\\\d{2}-clean(\\\\.\\\\d)(.zip)?\");\n    }\n\n    @Test\n    public void dailySizeBasedRolloverWithSizeCap()  {\n        SizeAndTimeBasedFNATP<Object> sizeAndTimeBasedFNATP = new SizeAndTimeBasedFNATP<Object>();\n        sizeAndTimeBasedFNATP.invocationGate = new FixedRateInvocationGate(ticksPerPeriod/8);\n        long bytesPerPeriod = 17000;\n        long fileSize = (bytesPerPeriod)/5;\n        int expectedFileCount = 10;\n        long sizeCap = expectedFileCount * fileSize;\n        sizeAndTimeBasedFNATP.setMaxFileSize(Long.toString(fileSize));\n        tbfnatp = sizeAndTimeBasedFNATP;\n        this.slashCount = computeSlashCount(DAILY_DATE_PATTERN);\n\n        // 2016-03-05 00:14:39 CET \n        long simulatedTime = 1457133279186L; \n        ConfigParameters params = new ConfigParameters(simulatedTime);\n        String fileNamePattern = randomOutputDir + \"/%d{\" + DAILY_DATE_PATTERN + \"}-clean.%i\";\n        params.maxHistory(60).fileNamePattern(fileNamePattern).simulatedNumberOfPeriods(10).sizeCap(sizeCap);\n        logOverMultiplePeriods(params);\n\n        List<File> foundFiles = findFilesByPattern(\"\\\\d{4}-\\\\d{2}-\\\\d{2}-clean(\\\\.\\\\d)\");\n        Collections.sort(foundFiles, new Comparator<File>() {\n            public int compare(File f0, File f1) {\n                String s0 = f0.getName().toString();\n                String s1 = f1.getName().toString();\n                return s0.compareTo(s1);\n            }\n        });\n        System.out.print(foundFiles);\n        StatusPrinter.print(context);\n        checkFileCount(expectedFileCount - 1);\n    }\n\n    @Test\n    public void dailyChronologSizeBasedRollover() {\n        SizeAndTimeBasedFNATP<Object> sizeAndTimeBasedFNATP = new SizeAndTimeBasedFNATP<Object>();\n        sizeAndTimeBasedFNATP.setMaxFileSize(\"10000\");\n        sizeAndTimeBasedFNATP.invocationGate = fixedRateInvocationGate;\n        tbfnatp = sizeAndTimeBasedFNATP;\n        slashCount = 1;\n        String fileNamePattern = randomOutputDir + \"/%d{\" + DAILY_DATE_PATTERN + \"}/clean.%i.zip\";\n        cp.maxHistory(5).fileNamePattern(fileNamePattern).simulatedNumberOfPeriods(5 * 3);\n        logOverMultiplePeriods(cp);\n        checkDirPatternCompliance(6);\n    }\n\n    @Test\n    public void dailyChronologSizeBasedRolloverWithSecondPhase() {\n        SizeAndTimeBasedFNATP<Object> sizeAndTimeBasedFNATP = new SizeAndTimeBasedFNATP<Object>();\n        sizeAndTimeBasedFNATP.setMaxFileSize(\"10000\");\n        sizeAndTimeBasedFNATP.invocationGate = fixedRateInvocationGate;\n        tbfnatp = sizeAndTimeBasedFNATP;\n        this.slashCount = 1;\n        String fileNamePattern = randomOutputDir + \"/%d{\" + DAILY_DATE_PATTERN + \"}/clean.%i\";\n        int maxHistory = 5;\n        cp.maxHistory(maxHistory).fileNamePattern(fileNamePattern).simulatedNumberOfPeriods(3);\n        long endTime = logOverMultiplePeriods(cp);\n\n        int simulatedNumberOfPeriods = maxHistory * 4;\n        ConfigParameters cp1 = new ConfigParameters(endTime + MILLIS_IN_DAY * 7).maxHistory(maxHistory).fileNamePattern(fileNamePattern)\n                        .simulatedNumberOfPeriods(simulatedNumberOfPeriods);\n        logOverMultiplePeriods(cp1);\n        checkDirPatternCompliance(maxHistory + 1);\n    }\n\n    void logTwiceAndStop(long currentTime, String fileNamePattern, int maxHistory) {\n        ConfigParameters params = new ConfigParameters(currentTime).fileNamePattern(fileNamePattern).maxHistory(maxHistory);\n        buildRollingFileAppender(params, DO_CLEAN_HISTORY_ON_START);\n        rfa.doAppend(\"Hello ----------------------------------------------------------\" + new Date(currentTime));\n        currentTime += MILLIS_IN_DAY/2;\n        add(tbrp.compressionFuture);\n        add(tbrp.cleanUpFuture);\n        waitForJobsToComplete();\n        tbrp.timeBasedFileNamingAndTriggeringPolicy.setCurrentTime(currentTime);\n        rfa.doAppend(\"Hello ----------------------------------------------------------\" + new Date(currentTime));\n        rfa.stop();\n    }\n\n    @Test\n    public void cleanHistoryOnStart() {\n        long simulatedTime = WED_2016_03_23_T_230705_CET;\n        System.out.println(new Date(simulatedTime));\n        \n        String fileNamePattern = randomOutputDir + \"clean-%d{\" + DAILY_DATE_PATTERN + \"}.txt\";\n        int maxHistory = 3;\n        for (int i = 0; i <= 5; i++) {\n            logTwiceAndStop(simulatedTime, fileNamePattern, maxHistory);\n            simulatedTime += MILLIS_IN_DAY;\n        }\n        StatusPrinter.print(context);\n        checkFileCount(expectedCountWithoutFolders(maxHistory));\n    }\n\n    @Test\n    public void cleanHistoryOnStartWithDayPattern() {\n        long simulatedTime = WED_2016_03_23_T_230705_CET;\n        String fileNamePattern = randomOutputDir + \"clean-%d{yyyy-MM-dd}.txt\";\n        int maxHistory = 3;\n        for (int i = 0; i <= 5; i++) {\n            logTwiceAndStop(simulatedTime, fileNamePattern, maxHistory);\n            simulatedTime += MILLIS_IN_DAY;\n        }\n        StatusPrinter.print(context);\n        checkFileCount(expectedCountWithoutFolders(maxHistory));\n    }\n\n    @Ignore\n    @Test\n    // this test assumes a high degree of collisions in the archived files. Every 24 hours, the archive\n    // belonging to the previous day will be overwritten. Given that logback goes 14 days (336 hours) in history\n    // to clean files on start up, it is bound to delete more recent files. It is not logback's responsibility\n    // to cater for such degenerate cases.\n    public void cleanHistoryOnStartWithHourPattern() {\n        long now = this.currentTime;\n        String fileNamePattern = randomOutputDir + \"clean-%d{HH}.txt\";\n        int maxHistory = 3;\n        for (int i = 0; i <= 5; i++) {\n            logTwiceAndStop(now, fileNamePattern, maxHistory);\n            now = now + MILLIS_IN_HOUR;\n        }\n        StatusPrinter.print(context);\n        checkFileCount(expectedCountWithoutFolders(maxHistory));\n    }\n\n    int expectedCountWithoutFolders(int maxHistory) {\n        return maxHistory + 1;\n    }\n\n    int expectedCountWithFolders(int maxHistory, boolean withExtraFolder) {\n        int numLogFiles = (maxHistory + 1);\n        int numLogFilesAndFolders = numLogFiles * 2;\n        int result = numLogFilesAndFolders + slashCount;\n        if (withExtraFolder)\n            result += 1;\n        return result;\n    }\n\n    void buildRollingFileAppender(ConfigParameters cp, boolean cleanHistoryOnStart) {\n        rfa.setContext(context);\n        rfa.setEncoder(encoder);\n        tbrp.setContext(context);\n        tbrp.setFileNamePattern(cp.fileNamePattern);\n        tbrp.setMaxHistory(cp.maxHistory);\n        tbrp.setTotalSizeCap(cp.sizeCap);\n        tbrp.setParent(rfa);\n        tbrp.setCleanHistoryOnStart(cleanHistoryOnStart);\n        tbrp.timeBasedFileNamingAndTriggeringPolicy = tbfnatp;\n        tbrp.timeBasedFileNamingAndTriggeringPolicy.setCurrentTime(cp.simulatedTime);\n        tbrp.start();\n        rfa.setRollingPolicy(tbrp);\n        rfa.start();\n    }\n\n    boolean DO_CLEAN_HISTORY_ON_START = true;\n    boolean DO_NOT_CLEAN_HISTORY_ON_START = false;\n\n    long logOverMultiplePeriods(ConfigParameters cp) {\n\n        buildRollingFileAppender(cp, DO_NOT_CLEAN_HISTORY_ON_START);\n        \n        int runLength = cp.simulatedNumberOfPeriods * ticksPerPeriod;\n        int startInactivityIndex = 1 + cp.startInactivity * ticksPerPeriod;\n        int endInactivityIndex = startInactivityIndex + cp.numInactivityPeriods * ticksPerPeriod;\n        long tickDuration = cp.periodDurationInMillis / ticksPerPeriod;\n\n        System.out.println(\"cp.periodDurationInMillis=\"+cp.periodDurationInMillis+\", tickDuration=:\"+tickDuration+\", runLength=\"+runLength);\n        for (int i = 0; i <= runLength; i++) {\n            if (i < startInactivityIndex || i > endInactivityIndex) {\n                StringBuilder sb = new StringBuilder(\"Hello\");\n                String iAsString = Integer.toString(i);\n                SpacePadder.spacePad(sb, 66+(6-iAsString.length()));\n                rfa.doAppend(sb.toString());\n            } else {\n                @SuppressWarnings(\"unused\")\n                Date d = new Date(tbrp.timeBasedFileNamingAndTriggeringPolicy.getCurrentTime());\n                System.out.print(\"\");\n            }\n            \n            tbrp.timeBasedFileNamingAndTriggeringPolicy.setCurrentTime(addTime(tbrp.timeBasedFileNamingAndTriggeringPolicy.getCurrentTime(), tickDuration));\n            add(tbrp.compressionFuture);\n            add(tbrp.cleanUpFuture);\n            waitForJobsToComplete();\n        }\n        rfa.stop();\n        \n        System.out.println(new Date( tbrp.timeBasedFileNamingAndTriggeringPolicy.getCurrentTime()));\n        return tbrp.timeBasedFileNamingAndTriggeringPolicy.getCurrentTime();\n    }\n\n   void fillWithChar(StringBuffer sb, char c, int count) {\n        for(int i = 0; i<count; i++) {\n            sb.append(c);\n        }\n    }\n    \n    boolean extraFolder(int numPeriods, int periodsPerEra, int beginPeriod, int maxHistory) {\n        int valueOfLastMonth = ((beginPeriod) + numPeriods) % periodsPerEra;\n        return (valueOfLastMonth < maxHistory);\n    }\n\n    long addTime(long time, long timeToWait) {\n        return time + timeToWait;\n    }\n\n    void expectedFileAndDirCount(int expectedFileAndDirCount, int expectedDirCountMin, int expectedDirCountMax) {\n        File dir = new File(randomOutputDir);\n        List<File> fileList = new ArrayList<File>();\n        findFilesInFolderRecursivelyByPatterMatch(dir, fileList, \"clean\");\n        List<File> dirList = new ArrayList<File>();\n        findAllFoldersInFolderRecursively(dir, dirList);\n        String msg = \"expectedDirCountMin=\" + expectedDirCountMin + \", expectedDirCountMax=\" + expectedDirCountMax + \" actual value=\" + dirList.size();\n        assertTrue(msg, expectedDirCountMin <= dirList.size() && dirList.size() <= expectedDirCountMax);\n    }\n\n    void checkFileCount(int expectedCount) {\n        File dir = new File(randomOutputDir);\n        List<File> fileList = new ArrayList<File>();\n        findAllDirsOrStringContainsFilesRecursively(dir, fileList, \"clean\");\n        assertEquals(expectedCount, fileList.size());\n    }\n\n    int expectedCountWithoutFoldersWithInactivity(int maxHistory, int totalPeriods, int endOfInactivity) {\n        int availableHistory = (totalPeriods + 1) - endOfInactivity;\n        int actualHistory = Math.min(availableHistory, maxHistory + 1);\n        return actualHistory;\n    }\n\n    void genericFindMatching(final FileMatchFunction matchFunc, File dir, List<File> fileList, final String pattern, boolean includeDirs) {\n        if (dir.isDirectory()) {\n            File[] matchArray = dir.listFiles(new FileFilter() {\n                public boolean accept(File f) {\n                    return f.isDirectory() || matchFunc.match(f, pattern);\n                }\n            });\n            for (File f : matchArray) {\n                if (f.isDirectory()) {\n                    if (includeDirs)\n                        fileList.add(f);\n                    genericFindMatching(matchFunc, f, fileList, pattern, includeDirs);\n                } else\n                    fileList.add(f);\n            }\n        }\n    }\n\n    private void findAllFoldersInFolderRecursively(File dir, List<File> fileList) {\n        FileMatchFunction alwaysFalse = new FileMatchFunction() {\n            public boolean match(File f, String pattern) {\n                return false;\n            }\n        };\n        genericFindMatching(alwaysFalse, dir, fileList, null, true);\n    }\n\n    private void findAllDirsOrStringContainsFilesRecursively(File dir, List<File> fileList, String pattern) {\n        FileMatchFunction matchFunction = new FileMatchFunction() {\n            public boolean match(File f, String pattern) {\n                return f.getName().contains(pattern);\n            }\n        };\n        genericFindMatching(matchFunction, dir, fileList, pattern, true);\n    }\n\n    void findFilesInFolderRecursivelyByPatterMatch(File dir, List<File> fileList, String pattern) {\n        FileMatchFunction matchByPattern = new FileMatchFunction() {\n            public boolean match(File f, String pattern) {\n                return f.getName().matches(pattern);\n            }\n        };\n        genericFindMatching(matchByPattern, dir, fileList, pattern, false);\n    }\n\n    Set<String> groupByClass(List<File> fileList, String regex) {\n        Pattern p = Pattern.compile(regex);\n        Set<String> set = new HashSet<String>();\n        for (File f : fileList) {\n            String n = f.getName();\n            Matcher m = p.matcher(n);\n            m.matches();\n            int begin = m.start(1);\n            String reduced = n.substring(0, begin);\n            set.add(reduced);\n        }\n        return set;\n    }\n\n    void checkPatternCompliance(int expectedClassCount, String regex) {\n        Set<String> set = findFilesByPatternClass(regex);\n        assertEquals(expectedClassCount, set.size());\n    }\n\n    private List<File> findFilesByPattern(String regex) {\n        File dir = new File(randomOutputDir);\n        List<File> fileList = new ArrayList<File>();\n        findFilesInFolderRecursivelyByPatterMatch(dir, fileList, regex);\n        return fileList;\n    }\n\n    private Set<String> findFilesByPatternClass(String regex) {\n        List<File> fileList = findFilesByPattern(regex);\n        Set<String> set = groupByClass(fileList, regex);\n        return set;\n    }\n\n    void checkDirPatternCompliance(int expectedClassCount) {\n        File dir = new File(randomOutputDir);\n        List<File> fileList = new ArrayList<File>();\n        findAllFoldersInFolderRecursively(dir, fileList);\n        for (File f : fileList) {\n            assertTrue(f.list().length >= 1);\n        }\n        assertEquals(expectedClassCount, fileList.size());\n    }\n}\n","Smelly Sample":"/**\n * Logback: the reliable, generic, fast and flexible logging framework.\n * Copyright (C) 1999-2015, QOS.ch. All rights reserved.\n *\n * This program and the accompanying materials are dual-licensed under\n * either the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation\n *\n *   or (per the licensee's choosing)\n *\n * under the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation.\n */\npackage ch.qos.logback.core.rolling;\n\nimport static ch.qos.logback.core.CoreConstants.DAILY_DATE_PATTERN;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.Days;\nimport org.joda.time.Duration;\nimport org.joda.time.Instant;\nimport org.joda.time.Interval;\nimport org.joda.time.LocalDate;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Test;\n\nimport ch.qos.logback.core.CoreConstants;\nimport ch.qos.logback.core.pattern.SpacePadder;\nimport ch.qos.logback.core.rolling.helper.RollingCalendar;\nimport ch.qos.logback.core.util.FixedRateInvocationGate;\nimport ch.qos.logback.core.util.StatusPrinter;\n\npublic class TimeBasedRollingWithArchiveRemoval_Test extends ScaffoldingForRollingTests {\n    String MONTHLY_DATE_PATTERN = \"yyyy-MM\";\n    String MONTHLY_CRONOLOG_DATE_PATTERN = \"yyyy/MM\";\n    final String DAILY_CRONOLOG_DATE_PATTERN = \"yyyy/MM/dd\";\n\n    RollingFileAppender<Object> rfa = new RollingFileAppender<Object>();\n    TimeBasedRollingPolicy<Object> tbrp = new TimeBasedRollingPolicy<Object>();\n\n    // by default tbfnatp is an instance of DefaultTimeBasedFileNamingAndTriggeringPolicy\n    TimeBasedFileNamingAndTriggeringPolicy<Object> tbfnatp = new DefaultTimeBasedFileNamingAndTriggeringPolicy<Object>();\n\n    static long MILLIS_IN_MINUTE = 60 * 1000;\n    static long MILLIS_IN_HOUR = 60 * MILLIS_IN_MINUTE;\n    static long MILLIS_IN_DAY = 24 * MILLIS_IN_HOUR;\n    static long MILLIS_IN_MONTH = (long) ((365.242199 / 12) * MILLIS_IN_DAY);\n    static int MONTHS_IN_YEAR = 12;\n\n    // Wed Mar 23 23:07:05 CET 2016\n    static final long WED_2016_03_23_T_230705_CET = 1458770825333L;\n    static final long THU_2016_03_17_T_230330_CET = 1458252210975L;\n\n    \n    int slashCount = 0;\n    int ticksPerPeriod = 216; \n    \n    ConfigParameters cp; // initialized in setup\n    FixedRateInvocationGate fixedRateInvocationGate = new FixedRateInvocationGate(ticksPerPeriod/2);\n    \n    @Before\n    public void setUp() {\n        super.setUp();\n        this.cp = new ConfigParameters(currentTime);\n    }\n\n    private int computeSlashCount(String datePattern) {\n        if (datePattern == null)\n            return 0;\n        else {\n            int count = 0;\n            for (int i = 0; i < datePattern.length(); i++) {\n                char c = datePattern.charAt(i);\n                if (c == '/')\n                    count++;\n            }\n            return count;\n        }\n    }\n\n    // test that the number of files at the end of the test is same as the expected number taking into account end dates\n    // near the beginning of a new year. This test has been run in a loop with start date varying over a two years\n    // with success.\n    @Test\n    public void monthlyRolloverOverManyPeriods() {\n        this.slashCount = computeSlashCount(MONTHLY_CRONOLOG_DATE_PATTERN);\n        int maxHistory = 2;\n        int simulatedNumberOfPeriods = 30;\n        String fileNamePattern = randomOutputDir + \"/%d{\" + MONTHLY_CRONOLOG_DATE_PATTERN + \"}/clean.txt.zip\";\n\n        cp.maxHistory(maxHistory).fileNamePattern(fileNamePattern).simulatedNumberOfPeriods(simulatedNumberOfPeriods).periodDurationInMillis(MILLIS_IN_MONTH);\n\n        long startTime = currentTime;\n        long endTime = logOverMultiplePeriods(cp);\n        System.out.println(\"randomOutputDir:\" + randomOutputDir);\n        System.out.println(\"start:\" + startTime + \", end=\" + endTime);\n        int differenceInMonths = RollingCalendar.diffInMonths(startTime, endTime);\n        System.out.println(\"differenceInMonths:\" + differenceInMonths);\n        Calendar startTimeAsCalendar = Calendar.getInstance();\n        startTimeAsCalendar.setTimeInMillis(startTime);\n        int indexOfStartPeriod = startTimeAsCalendar.get(Calendar.MONTH);\n        boolean withExtraFolder = extraFolder(differenceInMonths, MONTHS_IN_YEAR, indexOfStartPeriod, maxHistory);\n\n        checkFileCount(expectedCountWithFolders(maxHistory, withExtraFolder));\n    }\n\n    long generateDailyRollover(ConfigParameters cp) {\n        this.slashCount = computeSlashCount(DAILY_DATE_PATTERN);\n        cp.fileNamePattern(randomOutputDir + \"clean-%d{\" + DAILY_DATE_PATTERN + \"}.txt\");\n        return logOverMultiplePeriods(cp);\n    }\n\n    long generateDailyRolloverAndCheckFileCount(ConfigParameters cp) {\n        long millisAtEnd = generateDailyRollover(cp);\n        int periodBarriersCrossed= computeCrossedDayBarriers(currentTime, millisAtEnd); \n        System.out.println(\"**** \"+periodBarriersCrossed);\n        checkFileCount(expectedCountWithoutFoldersWithInactivity(cp.maxHistory, periodBarriersCrossed, cp.startInactivity + cp.numInactivityPeriods));\n        return millisAtEnd;\n    }\n\n    @Test\n    public void checkCrossedPeriods() {\n        long SAT_2016_03_26_T_230705_CET = WED_2016_03_23_T_230705_CET+3*CoreConstants.MILLIS_IN_ONE_DAY;\n        System.out.println(\"SAT_2016_03_26_T_230705_CET \"+new Date(SAT_2016_03_26_T_230705_CET));\n        long MON_2016_03_28_T_000705_CET = SAT_2016_03_26_T_230705_CET+CoreConstants.MILLIS_IN_ONE_DAY;\n        System.out.println(\"MON_2016_03_28_T_000705_CET \"+new Date(MON_2016_03_28_T_000705_CET));\n            \n        int result = computeCrossedDayBarriers(SAT_2016_03_26_T_230705_CET, MON_2016_03_28_T_000705_CET);\n        assertEquals(2, result);\n    }\n   \n    private int computeCrossedDayBarriers(long currentTime, long millisAtEnd) {\n        LocalDate startInstant = new LocalDate(currentTime, DateTimeZone.getDefault());\n        LocalDate endInstant = new LocalDate(millisAtEnd, DateTimeZone.getDefault());\n        Days days = Days.daysBetween(startInstant, endInstant);\n        return days.getDays();\n    }\n\n    @Test\n    public void checkCleanupForBasicDailyRollover() {\n        cp.maxHistory(20).simulatedNumberOfPeriods(20 * 3).startInactivity(0).numInactivityPeriods(0);\n        generateDailyRolloverAndCheckFileCount(cp);\n    }\n\n    @Test\n    public void checkCleanupForBasicDailyRolloverWithSizeCap() {\n        long bytesOutputPerPeriod = 15984;\n        int sizeInUnitsOfBytesPerPeriod = 2;\n\n        cp.maxHistory(5).simulatedNumberOfPeriods(10).sizeCap(sizeInUnitsOfBytesPerPeriod * bytesOutputPerPeriod+1000);\n        generateDailyRollover(cp);\n        StatusPrinter.print(context);\n        checkFileCount(sizeInUnitsOfBytesPerPeriod+1);\n    }\n\n    @Test\n    public void checkCleanupForBasicDailyRolloverWithMaxSize() {\n        cp.maxHistory(6).simulatedNumberOfPeriods(30).startInactivity(10).numInactivityPeriods(1);\n        generateDailyRolloverAndCheckFileCount(cp);\n    }\n\n    // Since the duration of a month (in seconds) varies from month to month, tests with inactivity period must\n    // be conducted with daily rollover not monthly\n    @Test\n    public void checkCleanupForDailyRollover_15Periods() {\n        cp.maxHistory(5).simulatedNumberOfPeriods(15).startInactivity(6).numInactivityPeriods(3);\n        generateDailyRolloverAndCheckFileCount(cp);\n    }\n\n    @Test\n    public void checkCleanupForDailyRolloverWithInactivity_30Periods() {\n        /// -------\n        cp.maxHistory(2).simulatedNumberOfPeriods(30).startInactivity(3).numInactivityPeriods(1);\n        generateDailyRolloverAndCheckFileCount(cp);\n    }\n\n    \n    \n    @Test\n    public void checkCleanupForDailyRolloverWithInactivity_10Periods() {\n        this.currentTime = THU_2016_03_17_T_230330_CET;\n        cp.maxHistory(6).simulatedNumberOfPeriods(10).startInactivity(2).numInactivityPeriods(2);\n        generateDailyRolloverAndCheckFileCount(cp);\n    }\n\n    @Test\n    public void checkCleanupForDailyRolloverWithSecondPhase() {\n        slashCount = computeSlashCount(DAILY_DATE_PATTERN);\n        int maxHistory = 5;\n        String fileNamePattern = randomOutputDir + \"clean-%d{\" + DAILY_DATE_PATTERN + \"}.txt\";\n\n        ConfigParameters cp0 = new ConfigParameters(currentTime).maxHistory(maxHistory).fileNamePattern(fileNamePattern)\n                        .simulatedNumberOfPeriods(maxHistory * 2);\n        long endTime = logOverMultiplePeriods(cp0);\n\n        ConfigParameters cp1 = new ConfigParameters(endTime + MILLIS_IN_DAY * 10).maxHistory(maxHistory).fileNamePattern(fileNamePattern)\n                        .simulatedNumberOfPeriods(maxHistory);\n        logOverMultiplePeriods(cp1);\n        checkFileCount(expectedCountWithoutFolders(maxHistory));\n    }\n\n    @Test\n    public void dailyRolloverWithCronologPattern() {\n        this.slashCount = computeSlashCount(DAILY_CRONOLOG_DATE_PATTERN);\n        String fileNamePattern = randomOutputDir + \"/%d{\" + DAILY_CRONOLOG_DATE_PATTERN + \"}/clean.txt.zip\";\n        cp.maxHistory(8).fileNamePattern(fileNamePattern).simulatedNumberOfPeriods(8 * 3);\n        logOverMultiplePeriods(cp);\n        int expectedDirMin = 9 + slashCount;\n        int expectDirMax = expectedDirMin + 1 + 1;\n        expectedFileAndDirCount(9, expectedDirMin, expectDirMax);\n    }\n\n    @Test\n    public void dailySizeBasedRolloverWithoutCap() {\n        SizeAndTimeBasedFNATP<Object> sizeAndTimeBasedFNATP = new SizeAndTimeBasedFNATP<Object>();\n        sizeAndTimeBasedFNATP.invocationGate = fixedRateInvocationGate;\n        \n        sizeAndTimeBasedFNATP.setMaxFileSize(\"10000\");\n        tbfnatp = sizeAndTimeBasedFNATP;\n        this.slashCount = computeSlashCount(DAILY_DATE_PATTERN);\n        String fileNamePattern = randomOutputDir + \"/%d{\" + DAILY_DATE_PATTERN + \"}-clean.%i.zip\";\n        cp.maxHistory(5).fileNamePattern(fileNamePattern).simulatedNumberOfPeriods(5 * 4);\n        logOverMultiplePeriods(cp);\n        checkPatternCompliance(5 + 1 + slashCount, \"\\\\d{4}-\\\\d{2}-\\\\d{2}-clean(\\\\.\\\\d)(.zip)?\");\n    }\n\n    @Test\n    public void dailySizeBasedRolloverWithSizeCap()  {\n        SizeAndTimeBasedFNATP<Object> sizeAndTimeBasedFNATP = new SizeAndTimeBasedFNATP<Object>();\n        sizeAndTimeBasedFNATP.invocationGate = new FixedRateInvocationGate(ticksPerPeriod/8);\n        long bytesPerPeriod = 17000;\n        long fileSize = (bytesPerPeriod)/5;\n        int expectedFileCount = 10;\n        long sizeCap = expectedFileCount * fileSize;\n        sizeAndTimeBasedFNATP.setMaxFileSize(Long.toString(fileSize));\n        tbfnatp = sizeAndTimeBasedFNATP;\n        this.slashCount = computeSlashCount(DAILY_DATE_PATTERN);\n\n        // 2016-03-05 00:14:39 CET \n        long simulatedTime = 1457133279186L; \n        ConfigParameters params = new ConfigParameters(simulatedTime);\n        String fileNamePattern = randomOutputDir + \"/%d{\" + DAILY_DATE_PATTERN + \"}-clean.%i\";\n        params.maxHistory(60).fileNamePattern(fileNamePattern).simulatedNumberOfPeriods(10).sizeCap(sizeCap);\n        logOverMultiplePeriods(params);\n\n        List<File> foundFiles = findFilesByPattern(\"\\\\d{4}-\\\\d{2}-\\\\d{2}-clean(\\\\.\\\\d)\");\n        Collections.sort(foundFiles, new Comparator<File>() {\n            public int compare(File f0, File f1) {\n                String s0 = f0.getName().toString();\n                String s1 = f1.getName().toString();\n                return s0.compareTo(s1);\n            }\n        });\n        System.out.print(foundFiles);\n        StatusPrinter.print(context);\n        checkFileCount(expectedFileCount - 1);\n    }\n\n    @Test\n    public void dailyChronologSizeBasedRollover() {\n        SizeAndTimeBasedFNATP<Object> sizeAndTimeBasedFNATP = new SizeAndTimeBasedFNATP<Object>();\n        sizeAndTimeBasedFNATP.setMaxFileSize(\"10000\");\n        sizeAndTimeBasedFNATP.invocationGate = fixedRateInvocationGate;\n        tbfnatp = sizeAndTimeBasedFNATP;\n        slashCount = 1;\n        String fileNamePattern = randomOutputDir + \"/%d{\" + DAILY_DATE_PATTERN + \"}/clean.%i.zip\";\n        cp.maxHistory(5).fileNamePattern(fileNamePattern).simulatedNumberOfPeriods(5 * 3);\n        logOverMultiplePeriods(cp);\n        checkDirPatternCompliance(6);\n    }\n\n    @Test\n    public void dailyChronologSizeBasedRolloverWithSecondPhase() {\n        SizeAndTimeBasedFNATP<Object> sizeAndTimeBasedFNATP = new SizeAndTimeBasedFNATP<Object>();\n        sizeAndTimeBasedFNATP.setMaxFileSize(\"10000\");\n        sizeAndTimeBasedFNATP.invocationGate = fixedRateInvocationGate;\n        tbfnatp = sizeAndTimeBasedFNATP;\n        this.slashCount = 1;\n        String fileNamePattern = randomOutputDir + \"/%d{\" + DAILY_DATE_PATTERN + \"}/clean.%i\";\n        int maxHistory = 5;\n        cp.maxHistory(maxHistory).fileNamePattern(fileNamePattern).simulatedNumberOfPeriods(3);\n        long endTime = logOverMultiplePeriods(cp);\n\n        int simulatedNumberOfPeriods = maxHistory * 4;\n        ConfigParameters cp1 = new ConfigParameters(endTime + MILLIS_IN_DAY * 7).maxHistory(maxHistory).fileNamePattern(fileNamePattern)\n                        .simulatedNumberOfPeriods(simulatedNumberOfPeriods);\n        logOverMultiplePeriods(cp1);\n        checkDirPatternCompliance(maxHistory + 1);\n    }\n\n    void logTwiceAndStop(long currentTime, String fileNamePattern, int maxHistory) {\n        ConfigParameters params = new ConfigParameters(currentTime).fileNamePattern(fileNamePattern).maxHistory(maxHistory);\n        buildRollingFileAppender(params, DO_CLEAN_HISTORY_ON_START);\n        rfa.doAppend(\"Hello ----------------------------------------------------------\" + new Date(currentTime));\n        currentTime += MILLIS_IN_DAY/2;\n        add(tbrp.compressionFuture);\n        add(tbrp.cleanUpFuture);\n        waitForJobsToComplete();\n        tbrp.timeBasedFileNamingAndTriggeringPolicy.setCurrentTime(currentTime);\n        rfa.doAppend(\"Hello ----------------------------------------------------------\" + new Date(currentTime));\n        rfa.stop();\n    }\n\n    @Test\n    public void cleanHistoryOnStart() {\n        long simulatedTime = WED_2016_03_23_T_230705_CET;\n        System.out.println(new Date(simulatedTime));\n        \n        String fileNamePattern = randomOutputDir + \"clean-%d{\" + DAILY_DATE_PATTERN + \"}.txt\";\n        int maxHistory = 3;\n        for (int i = 0; i <= 5; i++) {\n            logTwiceAndStop(simulatedTime, fileNamePattern, maxHistory);\n            simulatedTime += MILLIS_IN_DAY;\n        }\n        StatusPrinter.print(context);\n        checkFileCount(expectedCountWithoutFolders(maxHistory));\n    }\n\n    @Test\n    public void cleanHistoryOnStartWithDayPattern() {\n        long simulatedTime = WED_2016_03_23_T_230705_CET;\n        String fileNamePattern = randomOutputDir + \"clean-%d{yyyy-MM-dd}.txt\";\n        int maxHistory = 3;\n        for (int i = 0; i <= 5; i++) {\n            logTwiceAndStop(simulatedTime, fileNamePattern, maxHistory);\n            simulatedTime += MILLIS_IN_DAY;\n        }\n        StatusPrinter.print(context);\n        checkFileCount(expectedCountWithoutFolders(maxHistory));\n    }\n\n    @Ignore\n    @Test\n    // this test assumes a high degree of collisions in the archived files. Every 24 hours, the archive\n    // belonging to the previous day will be overwritten. Given that logback goes 14 days (336 hours) in history\n    // to clean files on start up, it is bound to delete more recent files. It is not logback's responsibility\n    // to cater for such degenerate cases.\n    public void cleanHistoryOnStartWithHourPattern() {\n        long now = this.currentTime;\n        String fileNamePattern = randomOutputDir + \"clean-%d{HH}.txt\";\n        int maxHistory = 3;\n        for (int i = 0; i <= 5; i++) {\n            logTwiceAndStop(now, fileNamePattern, maxHistory);\n            now = now + MILLIS_IN_HOUR;\n        }\n        StatusPrinter.print(context);\n        checkFileCount(expectedCountWithoutFolders(maxHistory));\n    }\n\n    int expectedCountWithoutFolders(int maxHistory) {\n        return maxHistory + 1;\n    }\n\n    int expectedCountWithFolders(int maxHistory, boolean withExtraFolder) {\n        int numLogFiles = (maxHistory + 1);\n        int numLogFilesAndFolders = numLogFiles * 2;\n        int result = numLogFilesAndFolders + slashCount;\n        if (withExtraFolder)\n            result += 1;\n        return result;\n    }\n\n    void buildRollingFileAppender(ConfigParameters cp, boolean cleanHistoryOnStart) {\n        rfa.setContext(context);\n        rfa.setEncoder(encoder);\n        tbrp.setContext(context);\n        tbrp.setFileNamePattern(cp.fileNamePattern);\n        tbrp.setMaxHistory(cp.maxHistory);\n        tbrp.setTotalSizeCap(cp.sizeCap);\n        tbrp.setParent(rfa);\n        tbrp.setCleanHistoryOnStart(cleanHistoryOnStart);\n        tbrp.timeBasedFileNamingAndTriggeringPolicy = tbfnatp;\n        tbrp.timeBasedFileNamingAndTriggeringPolicy.setCurrentTime(cp.simulatedTime);\n        tbrp.start();\n        rfa.setRollingPolicy(tbrp);\n        rfa.start();\n    }\n\n    boolean DO_CLEAN_HISTORY_ON_START = true;\n    boolean DO_NOT_CLEAN_HISTORY_ON_START = false;\n\n    long logOverMultiplePeriods(ConfigParameters cp) {\n\n        buildRollingFileAppender(cp, DO_NOT_CLEAN_HISTORY_ON_START);\n        \n        int runLength = cp.simulatedNumberOfPeriods * ticksPerPeriod;\n        int startInactivityIndex = 1 + cp.startInactivity * ticksPerPeriod;\n        int endInactivityIndex = startInactivityIndex + cp.numInactivityPeriods * ticksPerPeriod;\n        long tickDuration = cp.periodDurationInMillis / ticksPerPeriod;\n\n        System.out.println(\"cp.periodDurationInMillis=\"+cp.periodDurationInMillis+\", tickDuration=:\"+tickDuration+\", runLength=\"+runLength);\n        for (int i = 0; i <= runLength; i++) {\n            if (i < startInactivityIndex || i > endInactivityIndex) {\n                StringBuilder sb = new StringBuilder(\"Hello\");\n                String iAsString = Integer.toString(i);\n                SpacePadder.spacePad(sb, 66+(6-iAsString.length()));\n                rfa.doAppend(sb.toString());\n            } else {\n                @SuppressWarnings(\"unused\")\n                Date d = new Date(tbrp.timeBasedFileNamingAndTriggeringPolicy.getCurrentTime());\n                System.out.print(\"\");\n            }\n            \n            tbrp.timeBasedFileNamingAndTriggeringPolicy.setCurrentTime(addTime(tbrp.timeBasedFileNamingAndTriggeringPolicy.getCurrentTime(), tickDuration));\n            add(tbrp.compressionFuture);\n            add(tbrp.cleanUpFuture);\n            waitForJobsToComplete();\n        }\n        rfa.stop();\n        \n        System.out.println(new Date( tbrp.timeBasedFileNamingAndTriggeringPolicy.getCurrentTime()));\n        return tbrp.timeBasedFileNamingAndTriggeringPolicy.getCurrentTime();\n    }\n\n   void fillWithChar(StringBuffer sb, char c, int count) {\n        for(int i = 0; i<count; i++) {\n            sb.append(c);\n        }\n    }\n    \n    boolean extraFolder(int numPeriods, int periodsPerEra, int beginPeriod, int maxHistory) {\n        int valueOfLastMonth = ((beginPeriod) + numPeriods) % periodsPerEra;\n        return (valueOfLastMonth < maxHistory);\n    }\n\n    long addTime(long time, long timeToWait) {\n        return time + timeToWait;\n    }\n\n    void expectedFileAndDirCount(int expectedFileAndDirCount, int expectedDirCountMin, int expectedDirCountMax) {\n        File dir = new File(randomOutputDir);\n        List<File> fileList = new ArrayList<File>();\n        findFilesInFolderRecursivelyByPatterMatch(dir, fileList, \"clean\");\n        List<File> dirList = new ArrayList<File>();\n        findAllFoldersInFolderRecursively(dir, dirList);\n        String msg = \"expectedDirCountMin=\" + expectedDirCountMin + \", expectedDirCountMax=\" + expectedDirCountMax + \" actual value=\" + dirList.size();\n        assertTrue(msg, expectedDirCountMin <= dirList.size() && dirList.size() <= expectedDirCountMax);\n    }\n\n    void checkFileCount(int expectedCount) {\n        File dir = new File(randomOutputDir);\n        List<File> fileList = new ArrayList<File>();\n        findAllDirsOrStringContainsFilesRecursively(dir, fileList, \"clean\");\n        assertEquals(expectedCount, fileList.size());\n    }\n\n    int expectedCountWithoutFoldersWithInactivity(int maxHistory, int totalPeriods, int endOfInactivity) {\n        int availableHistory = (totalPeriods + 1) - endOfInactivity;\n        int actualHistory = Math.min(availableHistory, maxHistory + 1);\n        return actualHistory;\n    }\n\n    void genericFindMatching(final FileMatchFunction matchFunc, File dir, List<File> fileList, final String pattern, boolean includeDirs) {\n        if (dir.isDirectory()) {\n            File[] matchArray = dir.listFiles(new FileFilter() {\n                public boolean accept(File f) {\n                    return f.isDirectory() || matchFunc.match(f, pattern);\n                }\n            });\n            for (File f : matchArray) {\n                if (f.isDirectory()) {\n                    if (includeDirs)\n                        fileList.add(f);\n                    genericFindMatching(matchFunc, f, fileList, pattern, includeDirs);\n                } else\n                    fileList.add(f);\n            }\n        }\n    }\n\n    private void findAllFoldersInFolderRecursively(File dir, List<File> fileList) {\n        FileMatchFunction alwaysFalse = new FileMatchFunction() {\n            public boolean match(File f, String pattern) {\n                return false;\n            }\n        };\n        genericFindMatching(alwaysFalse, dir, fileList, null, true);\n    }\n\n    private void findAllDirsOrStringContainsFilesRecursively(File dir, List<File> fileList, String pattern) {\n        FileMatchFunction matchFunction = new FileMatchFunction() {\n            public boolean match(File f, String pattern) {\n                return f.getName().contains(pattern);\n            }\n        };\n        genericFindMatching(matchFunction, dir, fileList, pattern, true);\n    }\n\n    void findFilesInFolderRecursivelyByPatterMatch(File dir, List<File> fileList, String pattern) {\n        FileMatchFunction matchByPattern = new FileMatchFunction() {\n            public boolean match(File f, String pattern) {\n                return f.getName().matches(pattern);\n            }\n        };\n        genericFindMatching(matchByPattern, dir, fileList, pattern, false);\n    }\n\n    Set<String> groupByClass(List<File> fileList, String regex) {\n        Pattern p = Pattern.compile(regex);\n        Set<String> set = new HashSet<String>();\n        for (File f : fileList) {\n            String n = f.getName();\n            Matcher m = p.matcher(n);\n            m.matches();\n            int begin = m.start(1);\n            String reduced = n.substring(0, begin);\n            set.add(reduced);\n        }\n        return set;\n    }\n\n    void checkPatternCompliance(int expectedClassCount, String regex) {\n        Set<String> set = findFilesByPatternClass(regex);\n        assertEquals(expectedClassCount, set.size());\n    }\n\n    private List<File> findFilesByPattern(String regex) {\n        File dir = new File(randomOutputDir);\n        List<File> fileList = new ArrayList<File>();\n        findFilesInFolderRecursivelyByPatterMatch(dir, fileList, regex);\n        return fileList;\n    }\n\n    private Set<String> findFilesByPatternClass(String regex) {\n        List<File> fileList = findFilesByPattern(regex);\n        Set<String> set = groupByClass(fileList, regex);\n        return set;\n    }\n\n    void checkDirPatternCompliance(int expectedClassCount) {\n        File dir = new File(randomOutputDir);\n        List<File> fileList = new ArrayList<File>();\n        findAllFoldersInFolderRecursively(dir, fileList);\n        for (File f : fileList) {\n            assertTrue(f.list().length >= 1);\n        }\n        assertEquals(expectedClassCount, fileList.size());\n    }\n}\n","lineNo":151}
{"Refactored Sample":"package ch.qos.logback.core.joran.util.beans;\n\nimport java.lang.reflect.Method;\n\n/**\n * Encapsulates utility methods associated with standard java beans.\n * @author urechm\n */\npublic class BeanUtil {\n\n\tpublic static final BeanUtil INSTANCE=new BeanUtil();\n\n\tpublic static final String PREFIX_GETTER_IS=\"is\";\n\tpublic static final String PREFIX_GETTER_GET=\"get\";\n\tpublic static final String PREFIX_SETTER=\"set\";\n\tpublic static final String PREFIX_ADDER=\"add\";\n\n\t/**\n\t *\n\t * @param method to check if it is an 'adder' method.\n\t * @return true if the given method is an 'adder' method.\n\t */\n\tpublic boolean isAdder(Method method) {\n\t\tint parameterCount = getParameterCount(method);\n\t\tif(parameterCount!=1){\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> returnType = method.getReturnType();\n\t\tif(returnType!=void.class){\n\t\t\treturn false;\n\t\t}\n\t\tString methodName = method.getName();\n\t\treturn methodName.startsWith(PREFIX_ADDER);\n\t}\n\n\t/**\n\t *\n\t * @param method to check if it is a standard java beans getter.\n\t * @return true if the given method is a standard java beans getter.\n\t */\n\tpublic boolean isGetter(Method method) {\n\t\tint parameterCount = getParameterCount(method);\n\t\tif(parameterCount>0){\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> returnType = method.getReturnType();\n\t\tif(returnType==void.class){\n\t\t\treturn false;\n\t\t}\n\t\tString methodName = method.getName();\n\t\tif(!methodName.startsWith(PREFIX_GETTER_GET)&&!methodName.startsWith(PREFIX_GETTER_IS)){\n\t\t\treturn false;\n\t\t}\n\t\tif(methodName.startsWith(PREFIX_GETTER_IS)){\n\t\t\tif(!returnType.equals(boolean.class)&&!returnType.equals(Boolean.class)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int getParameterCount(Method method) {\n\t\treturn method.getParameterTypes().length;\n\t}\n\n\t/**\n\t *\n\t * @param method to check if it is a standard java beans setter.\n\t * @return true if the given method is a standard java beans setter.\n\t */\n\tpublic boolean isSetter(Method method){\n\t\tint parameterCount = getParameterCount(method);\n\t\tif(parameterCount!=1){\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> returnType = method.getReturnType();\n\t\tif(returnType!=void.class){\n\t\t\treturn false;\n\t\t}\n\t\tString methodName = method.getName();\n\t\tif(!methodName.startsWith(PREFIX_SETTER)){\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param method to get the associated property name for.\n\t * @return The property name of the associated property if the given method matches a standard java beans getter or setter.\n\t */\n\tpublic String getPropertyName(Method method) {\n\t\tString methodName = method.getName();\n\t\tString rawPropertyName=getSubstringIfPrefixMatches(methodName,PREFIX_GETTER_GET);\n\t\tif(rawPropertyName==null){\n\t\t\trawPropertyName=getSubstringIfPrefixMatches(methodName, PREFIX_SETTER);\n\t\t}\n\t\tif(rawPropertyName==null){\n\t\t\trawPropertyName=getSubstringIfPrefixMatches(methodName,PREFIX_GETTER_IS);\n\t\t}\n\t\tif(rawPropertyName==null){\n\t\t\trawPropertyName=getSubstringIfPrefixMatches(methodName,PREFIX_ADDER);\n\t\t}\n\t\treturn toLowerCamelCase(rawPropertyName);\n\t}\n\n\t/**\n\t * Converts the given String into lower camel case form.\n\t * @param string to decapitalize.\n\t * @return null if the given String is null.\n\t * Emtpy string if the given string is empty.\n\t * The given string if the first two consecutive letters are in upper case.\n\t * The given string with the first letter in lower case otherwise, which might be the given string.\n\t */\n\tpublic String toLowerCamelCase(String string){\n\t\tif(string==null){\n\t\t\treturn null;\n\t\t}\n\t\tif(string.isEmpty()){\n\t\t\treturn string;\n\t\t}\n        if (string.length() > 1 && Character.isUpperCase(string.charAt(1)) &&\n                Character.isUpperCase(string.charAt(0))){\n        \treturn string;\n        }\n        char chars[] = string.toCharArray();\n        chars[0] = Character.toLowerCase(chars[0]);\n        return new String(chars);\n\t}\n\n\tprivate String getSubstringIfPrefixMatches(String wholeString,String prefix) {\n\t\tif(wholeString.startsWith(prefix)){\n\t\t\treturn wholeString.substring(prefix.length());\n\t\t}\n\t\treturn null;\n\t}\n\n}\n","Smelly Sample":"package ch.qos.logback.core.joran.util.beans;\n\nimport java.lang.reflect.Method;\n\n/**\n * Encapsulates utility methods associated with standard java beans.\n * @author urechm\n */\npublic class BeanUtil {\n\n\tpublic static final BeanUtil INSTANCE=new BeanUtil();\n\n\tpublic static final String PREFIX_GETTER_IS=\"is\";\n\tpublic static final String PREFIX_GETTER_GET=\"get\";\n\tpublic static final String PREFIX_SETTER=\"set\";\n\tpublic static final String PREFIX_ADDER=\"add\";\n\n\t/**\n\t *\n\t * @param method to check if it is an 'adder' method.\n\t * @return true if the given method is an 'adder' method.\n\t */\n\tpublic boolean isAdder(Method method) {\n\t\treturn method.getName().startsWith(PREFIX_ADDER);\n\t}\n\n\t/**\n\t *\n\t * @param method to check if it is a standard java beans getter.\n\t * @return true if the given method is a standard java beans getter.\n\t */\n\tpublic boolean isGetter(Method method) {\n\t\tint parameterCount = method.getParameterTypes().length;\n\t\tif(parameterCount>0){\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> returnType = method.getReturnType();\n\t\tif(returnType==void.class){\n\t\t\treturn false;\n\t\t}\n\t\tString methodName = method.getName();\n\t\tif(!methodName.startsWith(PREFIX_GETTER_GET)&&!methodName.startsWith(PREFIX_GETTER_IS)){\n\t\t\treturn false;\n\t\t}\n\t\tif(methodName.startsWith(PREFIX_GETTER_IS)){\n\t\t\tif(!returnType.equals(boolean.class)&&!returnType.equals(Boolean.class)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t *\n\t * @param method to check if it is a standard java beans setter.\n\t * @return true if the given method is a standard java beans setter.\n\t */\n\tpublic boolean isSetter(Method method){\n\t\tint parameterCount = method.getParameterTypes().length;\n\t\tif(parameterCount!=1){\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> returnType = method.getReturnType();\n\t\tif(returnType!=void.class){\n\t\t\treturn false;\n\t\t}\n\t\tString methodName = method.getName();\n\t\tif(!methodName.startsWith(PREFIX_SETTER)){\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param method to get the associated property name for.\n\t * @return The property name of the associated property if the given method matches a standard java beans getter or setter.\n\t */\n\tpublic String getPropertyName(Method method) {\n\t\tString methodName = method.getName();\n\t\tString rawPropertyName=getSubstringIfPrefixMatches(methodName,PREFIX_GETTER_GET);\n\t\tif(rawPropertyName==null){\n\t\t\trawPropertyName=getSubstringIfPrefixMatches(methodName, PREFIX_SETTER);\n\t\t}\n\t\tif(rawPropertyName==null){\n\t\t\trawPropertyName=getSubstringIfPrefixMatches(methodName,PREFIX_GETTER_IS);\n\t\t}\n\t\tif(rawPropertyName==null){\n\t\t\trawPropertyName=getSubstringIfPrefixMatches(methodName,PREFIX_ADDER);\n\t\t}\n\t\treturn toLowerCamelCase(rawPropertyName);\n\t}\n\n\t/**\n\t * Converts the given String into lower camel case form.\n\t * @param string to decapitalize.\n\t * @return null if the given String is null.\n\t * Emtpy string if the given string is empty.\n\t * The given string if the first two consecutive letters are in upper case.\n\t * The given string with the first letter in lower case otherwise, which might be the given string.\n\t */\n\tpublic String toLowerCamelCase(String string){\n\t\tif(string==null){\n\t\t\treturn null;\n\t\t}\n\t\tif(string.isEmpty()){\n\t\t\treturn string;\n\t\t}\n        if (string.length() > 1 && Character.isUpperCase(string.charAt(1)) &&\n                Character.isUpperCase(string.charAt(0))){\n        \treturn string;\n        }\n        char chars[] = string.toCharArray();\n        chars[0] = Character.toLowerCase(chars[0]);\n        return new String(chars);\n\t}\n\n\tprivate String getSubstringIfPrefixMatches(String wholeString,String prefix) {\n\t\tif(wholeString.startsWith(prefix)){\n\t\t\treturn wholeString.substring(prefix.length());\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Converts the given String into lower camel case form.\n\t * @param string to decapitalize.\n\t * @return null if the given String is null.\n\t * Emtpy string if the given string is empty.\n\t * The given string if the first two consecutive letters are in upper case.\n\t * The given string with the first letter in lower case otherwise, which might be the given string.\n\t */\n\tpublic static final String convertToLowerCamelCase(String string){\n\t\treturn BeanUtil.INSTANCE.toLowerCamelCase(string);\n\t}\n\n}\n","lineNo":32}
