{"Refactored Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.maven.plugin.plugin;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\n\n/**\n * Abstract class for this Plugin.\n *\n * @author <a href=\"mailto:jason@maven.org\">Jason van Zyl<\/a>\n *\n */\npublic abstract class AbstractGeneratorMojo extends AbstractMojo {\n    /**\n     * The project currently being built.\n     */\n    @Parameter(defaultValue = \"${project}\", readonly = true)\n    protected MavenProject project;\n\n    /**\n     * The goal prefix that will appear before the \":\".\n     */\n    @Parameter\n    protected String goalPrefix;\n\n    /**\n     * Set this to \"true\" to skip invoking any goals or reports of the plugin.\n     *\n     * @since 2.8\n     */\n    @Parameter(defaultValue = \"false\", property = \"maven.plugin.skip\")\n    private boolean skip;\n\n    /**\n     * Maven plugin packaging types. Default is single \"maven-plugin\".\n     *\n     * @since 3.3\n     */\n    @Parameter\n    private List<String> packagingTypes = Collections.singletonList(\"maven-plugin\");\n\n    /**\n     * System/OS line separator: used to format console messages.\n     */\n    protected static final String LS = System.lineSeparator();\n\n    protected abstract void generate() throws MojoExecutionException;\n\n    @Override\n    public void execute() throws MojoExecutionException {\n        if (!packagingTypes.contains(project.getPackaging())) {\n            getLog().info(\"Unsupported packaging type \" + project.getPackaging() + \", execution skipped\");\n            return;\n        }\n\n        if (skip) {\n            getLog().warn(\"Execution skipped\");\n            return;\n        }\n\n        if (goalPrefix == null || goalPrefix.isEmpty()) {\n            goalPrefix = getDefaultGoalPrefix(project);\n        }\n        if (goalPrefix == null || goalPrefix.isEmpty()) {\n            throw new MojoExecutionException(\"You need to specify a goalPrefix as it can not be correctly computed\");\n        }\n\n        generate();\n    }\n\n    static String getDefaultGoalPrefix(MavenProject project) {\n        String artifactId = project.getArtifactId();\n        if (artifactId.endsWith(\"-maven-plugin\")) {\n            return artifactId.substring(0, artifactId.length() - \"-maven-plugin\".length());\n        } else if (artifactId.startsWith(\"maven-\") && artifactId.endsWith(\"-plugin\")) {\n            return artifactId.substring(\"maven-\".length(), artifactId.length() - \"-plugin\".length());\n        } else {\n            return null;\n        }\n    }\n}\n","Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.maven.plugin.plugin;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\n\n/**\n * Abstract class for this Plugin.\n *\n * @author <a href=\"mailto:jason@maven.org\">Jason van Zyl<\/a>\n *\n */\npublic abstract class AbstractGeneratorMojo extends AbstractMojo {\n    /**\n     * The project currently being built.\n     */\n    @Parameter(defaultValue = \"${project}\", readonly = true)\n    protected MavenProject project;\n\n    /**\n     * The goal prefix that will appear before the \":\".\n     */\n    @Parameter\n    protected String goalPrefix;\n\n    /**\n     * Set this to \"true\" to skip invoking any goals or reports of the plugin.\n     *\n     * @since 2.8\n     */\n    @Parameter(defaultValue = \"false\", property = \"maven.plugin.skip\")\n    private boolean skip;\n\n    /**\n     * Maven plugin packaging types. Default is single \"maven-plugin\".\n     *\n     * @since 3.3\n     */\n    @Parameter\n    private List<String> packagingTypes = Collections.singletonList(\"maven-plugin\");\n\n    /**\n     * System/OS line separator: used to format console messages.\n     */\n    protected static final String LS = System.lineSeparator();\n\n    protected abstract void generate() throws MojoExecutionException;\n\n    @Override\n    public void execute() throws MojoExecutionException {\n        if (!packagingTypes.contains(project.getPackaging())) {\n            getLog().info(\"Unsupported packaging type \" + project.getPackaging() + \", execution skipped\");\n            return;\n        }\n\n        if (skip) {\n            getLog().warn(\"Execution skipped\");\n            return;\n        }\n\n        String defaultGoalPrefix = getDefaultGoalPrefix(project);\n\n        if (goalPrefix == null) {\n            goalPrefix = defaultGoalPrefix;\n        } else if (!goalPrefix.equals(defaultGoalPrefix)) {\n            getLog().warn(LS + LS + \"Goal prefix is specified as: '\" + goalPrefix + \"'. \"\n                    + \"Maven currently expects it to be '\" + defaultGoalPrefix + \"'.\" + LS);\n        }\n\n        generate();\n    }\n\n    static String getDefaultGoalPrefix(MavenProject project) {\n        String defaultGoalPrefix;\n        if (\"maven-plugin-report-plugin\".equalsIgnoreCase(project.getArtifactId())) {\n            defaultGoalPrefix = \"plugin-report\";\n        } else if (\"maven-plugin\".equalsIgnoreCase(project.getArtifactId())) {\n            defaultGoalPrefix =\n                    project.getGroupId().substring(project.getGroupId().lastIndexOf('.') + 1);\n        } else {\n            defaultGoalPrefix = PluginDescriptor.getGoalPrefixFromArtifactId(project.getArtifactId());\n        }\n        return defaultGoalPrefix;\n    }\n}\n","lineNo":94}
{"Refactored Sample":"package org.apache.maven.plugins.plugin.descriptor;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptorBuilder;\nimport org.apache.maven.rtinfo.RuntimeInformation;\nimport org.apache.maven.tools.plugin.EnhancedParameterWrapper;\nimport org.apache.maven.tools.plugin.ExtendedPluginDescriptor;\nimport org.codehaus.plexus.configuration.PlexusConfiguration;\nimport org.codehaus.plexus.configuration.PlexusConfigurationException;\nimport org.apache.maven.plugin.plugin.report.PluginReport;\n\nimport java.io.Reader;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Reads enhanced plugin.xml files as generated by\n * {@link org.apache.maven.tools.plugin.generator.PluginDescriptorFilesGenerator} and\n * used by {@link PluginReport}.\n * Populates the slightly extended {@link Parameter} object {@link EnhancedParameterWrapper}.\n * In addition populates all (optional) elements added after Maven Plugin API 3.2.5.\n */\npublic class EnhancedPluginDescriptorBuilder extends PluginDescriptorBuilder\n{\n    private final boolean requireAddingMissingParameterSinceField;\n    private PlexusConfiguration configuration;\n\n    public EnhancedPluginDescriptorBuilder( RuntimeInformation rtInfo )\n    {\n        this( rtInfo.isMavenVersion( \"[,3.3.9]\" ) );\n    }\n\n    EnhancedPluginDescriptorBuilder( boolean requireAddingMissingParameterSinceField )\n    {\n        this.requireAddingMissingParameterSinceField = requireAddingMissingParameterSinceField;\n    }\n\n    /**\n     * Cache the returned configuration for additional evaluation in {@link #build(Reader, String)}.\n     */\n    @Override\n    public PlexusConfiguration buildConfiguration( Reader reader )\n        throws PlexusConfigurationException\n    {\n        configuration = super.buildConfiguration( reader );\n        return configuration;\n    }\n\n    @Override\n    public PluginDescriptor build( Reader reader, String source )\n        throws PlexusConfigurationException\n    {\n        PluginDescriptor pluginDescriptor = super.build( reader, source );\n        // elements added in plugin descriptor 1.1\n        ExtendedPluginDescriptor extendedPluginDescriptor = new ExtendedPluginDescriptor( pluginDescriptor );\n        extendedPluginDescriptor.setRequiredJavaVersion( configuration.getChild( \"requiredJavaVersion\" ).getValue() );\n        extendedPluginDescriptor.setRequiredMavenVersion( configuration.getChild( \"requiredMavenVersion\" ).getValue() );\n        return extendedPluginDescriptor;\n    }\n\n    @Override\n    public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDescriptor pluginDescriptor )\n        throws PlexusConfigurationException\n    {\n        MojoDescriptor mojoDescriptor = super.buildComponentDescriptor( c, pluginDescriptor );\n        \n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] parameterConfigurations = c.getChild( \"parameters\" ).getChildren( \"parameter\" );\n\n        List<Parameter> parameters = new ArrayList<>( mojoDescriptor.getParameters() );\n        Map<String, Parameter> parameterMap = new LinkedHashMap<>( mojoDescriptor.getParameterMap() );\n\n        for ( PlexusConfiguration d : parameterConfigurations )\n        {\n            String parameterName = d.getChild( \"name\" ).getValue();\n            // don't call getParameterMap() to not populate \n            Parameter pd = parameterMap.get( parameterName );\n            if ( requireAddingMissingParameterSinceField )\n            {\n                addMissingParameterSinceField( pd, d );\n            }\n            PlexusConfiguration configTypeJavadocUrl = d.getChild( \"typeJavadocUrl\", false );\n            if ( configTypeJavadocUrl != null )\n            {\n                String parameterTypeJavadocUrl = configTypeJavadocUrl.getValue();\n                EnhancedParameterWrapper enhancedParameter = new EnhancedParameterWrapper( pd );\n                enhancedParameter.setTypeJavadocUrl( URI.create( parameterTypeJavadocUrl ) );\n                parameters.set( mojoDescriptor.getParameters().indexOf( pd ), enhancedParameter );\n                parameterMap.put( parameterName, enhancedParameter );\n            }\n        }\n\n        // clear() is required for maven < 3.6.2\n        mojoDescriptor.getParameters().clear();\n        // set parameters\n        mojoDescriptor.setParameters( parameters );\n        // on maven < 3.6.2, getParameterMap is kept internally in a field\n        // so update it in case we're on an old maven version\n        mojoDescriptor.getParameterMap().putAll( parameterMap );\n\n        return mojoDescriptor;\n    }\n\n    /**\n     * Reads the plugin descriptor and adds the fix for <a href=\"https://issues.apache.org/jira/browse/MNG-6109\">\n     * MNG-6109<\/a> when using Maven-3.3.9 and before.\n     * Method can be removed once Maven 3.5.0 is the prerequisite for this plugin.\n     * @throws PlexusConfigurationException \n     * \n     * @since 3.5.1\n     * @see <a href=\"https://issues.apache.org/jira/browse/MNG-6109\">MNG-6109<\/a>\n     * @see <a href=\"https://issues.apache.org/jira/browse/MPLUGIN-319\">MPLUGIN-319<\/a>\n     */\n     void addMissingParameterSinceField( Parameter pd, PlexusConfiguration d ) throws PlexusConfigurationException\n     {\n         String parameterSince = d.getChild( \"since\" ).getValue();\n         pd.setSince( parameterSince );\n     }\n}\n","Smelly Sample":"package org.apache.maven.plugins.plugin.descriptor;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptorBuilder;\nimport org.apache.maven.rtinfo.RuntimeInformation;\nimport org.apache.maven.tools.plugin.EnhancedParameterWrapper;\nimport org.apache.maven.tools.plugin.ExtendedPluginDescriptor;\nimport org.codehaus.plexus.configuration.PlexusConfiguration;\nimport org.codehaus.plexus.configuration.PlexusConfigurationException;\nimport org.apache.maven.plugin.plugin.report.PluginReport;\n\nimport java.io.Reader;\nimport java.net.URI;\n\n/**\n * Reads enhanced plugin.xml files as generated by\n * {@link org.apache.maven.tools.plugin.generator.PluginDescriptorFilesGenerator} and\n * used by {@link PluginReport}.\n * Populates the slightly extended {@link Parameter} object {@link EnhancedParameterWrapper}.\n * In addition populates all (optional) elements added after Maven Plugin API 3.2.5.\n */\npublic class EnhancedPluginDescriptorBuilder extends PluginDescriptorBuilder\n{\n    private final boolean requireAddingMissingParameterSinceField;\n    private PlexusConfiguration configuration;\n\n    public EnhancedPluginDescriptorBuilder( RuntimeInformation rtInfo )\n    {\n        this( rtInfo.isMavenVersion( \"[,3.3.9]\" ) );\n    }\n\n    EnhancedPluginDescriptorBuilder( boolean requireAddingMissingParameterSinceField )\n    {\n        this.requireAddingMissingParameterSinceField = requireAddingMissingParameterSinceField;\n    }\n\n    /**\n     * Cache the returned configuration for additional evaluation in {@link #build(Reader, String)}.\n     */\n    @Override\n    public PlexusConfiguration buildConfiguration( Reader reader )\n        throws PlexusConfigurationException\n    {\n        configuration = super.buildConfiguration( reader );\n        return configuration;\n    }\n\n    @Override\n    public PluginDescriptor build( Reader reader, String source )\n        throws PlexusConfigurationException\n    {\n        PluginDescriptor pluginDescriptor = super.build( reader, source );\n        // elements added in plugin descriptor 1.1\n        ExtendedPluginDescriptor extendedPluginDescriptor = new ExtendedPluginDescriptor( pluginDescriptor );\n        extendedPluginDescriptor.setRequiredJavaVersion( configuration.getChild( \"requiredJavaVersion\" ).getValue() );\n        extendedPluginDescriptor.setRequiredMavenVersion( configuration.getChild( \"requiredMavenVersion\" ).getValue() );\n        return extendedPluginDescriptor;\n    }\n\n    @Override\n    public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDescriptor pluginDescriptor )\n        throws PlexusConfigurationException\n    {\n        MojoDescriptor mojoDescriptor = super.buildComponentDescriptor( c, pluginDescriptor );\n        \n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] parameterConfigurations = c.getChild( \"parameters\" ).getChildren( \"parameter\" );\n\n        for ( PlexusConfiguration d : parameterConfigurations )\n        {\n            String parameterName = d.getChild( \"name\" ).getValue();\n            // don't call getParameterMap() to not populate \n            Parameter pd = mojoDescriptor.getParameterMap().get( parameterName );\n            if ( requireAddingMissingParameterSinceField )\n            {\n                addMissingParameterSinceField( pd, d );\n            }\n            PlexusConfiguration configTypeJavadocUrl = d.getChild( \"typeJavadocUrl\", false );\n            if ( configTypeJavadocUrl != null )\n            {\n                String parameterTypeJavadocUrl = configTypeJavadocUrl.getValue();\n                EnhancedParameterWrapper enhancedParameter = new EnhancedParameterWrapper( pd );\n                enhancedParameter.setTypeJavadocUrl( URI.create( parameterTypeJavadocUrl ) );\n                mojoDescriptor.getParameters().set( mojoDescriptor.getParameters().indexOf( pd ), enhancedParameter );\n                mojoDescriptor.getParameterMap().put( parameterName, enhancedParameter );\n            }\n        }\n        return mojoDescriptor;\n    }\n\n    /**\n     * Reads the plugin descriptor and adds the fix for <a href=\"https://issues.apache.org/jira/browse/MNG-6109\">\n     * MNG-6109<\/a> when using Maven-3.3.9 and before.\n     * Method can be removed once Maven 3.5.0 is the prerequisite for this plugin.\n     * @throws PlexusConfigurationException \n     * \n     * @since 3.5.1\n     * @see <a href=\"https://issues.apache.org/jira/browse/MNG-6109\">MNG-6109<\/a>\n     * @see <a href=\"https://issues.apache.org/jira/browse/MPLUGIN-319\">MPLUGIN-319<\/a>\n     */\n     void addMissingParameterSinceField( Parameter pd, PlexusConfiguration d ) throws PlexusConfigurationException\n     {\n         String parameterSince = d.getChild( \"since\" ).getValue();\n         pd.setSince( parameterSince );\n     }\n}\n","lineNo":98}
{"Refactored Sample":"package org.apache.maven.plugins.plugin.descriptor;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptorBuilder;\nimport org.apache.maven.rtinfo.RuntimeInformation;\nimport org.apache.maven.tools.plugin.EnhancedParameterWrapper;\nimport org.apache.maven.tools.plugin.ExtendedPluginDescriptor;\nimport org.codehaus.plexus.configuration.PlexusConfiguration;\nimport org.codehaus.plexus.configuration.PlexusConfigurationException;\nimport org.apache.maven.plugin.plugin.report.PluginReport;\n\nimport java.io.Reader;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Reads enhanced plugin.xml files as generated by\n * {@link org.apache.maven.tools.plugin.generator.PluginDescriptorFilesGenerator} and\n * used by {@link PluginReport}.\n * Populates the slightly extended {@link Parameter} object {@link EnhancedParameterWrapper}.\n * In addition populates all (optional) elements added after Maven Plugin API 3.2.5.\n */\npublic class EnhancedPluginDescriptorBuilder extends PluginDescriptorBuilder\n{\n    private final boolean requireAddingMissingParameterSinceField;\n    private PlexusConfiguration configuration;\n\n    public EnhancedPluginDescriptorBuilder( RuntimeInformation rtInfo )\n    {\n        this( rtInfo.isMavenVersion( \"[,3.3.9]\" ) );\n    }\n\n    EnhancedPluginDescriptorBuilder( boolean requireAddingMissingParameterSinceField )\n    {\n        this.requireAddingMissingParameterSinceField = requireAddingMissingParameterSinceField;\n    }\n\n    /**\n     * Cache the returned configuration for additional evaluation in {@link #build(Reader, String)}.\n     */\n    @Override\n    public PlexusConfiguration buildConfiguration( Reader reader )\n        throws PlexusConfigurationException\n    {\n        configuration = super.buildConfiguration( reader );\n        return configuration;\n    }\n\n    @Override\n    public PluginDescriptor build( Reader reader, String source )\n        throws PlexusConfigurationException\n    {\n        PluginDescriptor pluginDescriptor = super.build( reader, source );\n        // elements added in plugin descriptor 1.1\n        ExtendedPluginDescriptor extendedPluginDescriptor = new ExtendedPluginDescriptor( pluginDescriptor );\n        extendedPluginDescriptor.setRequiredJavaVersion( configuration.getChild( \"requiredJavaVersion\" ).getValue() );\n        extendedPluginDescriptor.setRequiredMavenVersion( configuration.getChild( \"requiredMavenVersion\" ).getValue() );\n        return extendedPluginDescriptor;\n    }\n\n    @Override\n    public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDescriptor pluginDescriptor )\n        throws PlexusConfigurationException\n    {\n        MojoDescriptor mojoDescriptor = super.buildComponentDescriptor( c, pluginDescriptor );\n        \n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] parameterConfigurations = c.getChild( \"parameters\" ).getChildren( \"parameter\" );\n\n        List<Parameter> parameters = new ArrayList<>( mojoDescriptor.getParameters() );\n        Map<String, Parameter> parameterMap = new LinkedHashMap<>( mojoDescriptor.getParameterMap() );\n\n        for ( PlexusConfiguration d : parameterConfigurations )\n        {\n            String parameterName = d.getChild( \"name\" ).getValue();\n            // don't call getParameterMap() to not populate \n            Parameter pd = parameterMap.get( parameterName );\n            if ( requireAddingMissingParameterSinceField )\n            {\n                addMissingParameterSinceField( pd, d );\n            }\n            PlexusConfiguration configTypeJavadocUrl = d.getChild( \"typeJavadocUrl\", false );\n            if ( configTypeJavadocUrl != null )\n            {\n                String parameterTypeJavadocUrl = configTypeJavadocUrl.getValue();\n                EnhancedParameterWrapper enhancedParameter = new EnhancedParameterWrapper( pd );\n                enhancedParameter.setTypeJavadocUrl( URI.create( parameterTypeJavadocUrl ) );\n                parameters.set( mojoDescriptor.getParameters().indexOf( pd ), enhancedParameter );\n                parameterMap.put( parameterName, enhancedParameter );\n            }\n        }\n\n        // clear() is required for maven < 3.6.2\n        mojoDescriptor.getParameters().clear();\n        // set parameters\n        mojoDescriptor.setParameters( parameters );\n        // on maven < 3.6.2, getParameterMap is kept internally in a field\n        // so update it in case we're on an old maven version\n        mojoDescriptor.getParameterMap().putAll( parameterMap );\n\n        return mojoDescriptor;\n    }\n\n    /**\n     * Reads the plugin descriptor and adds the fix for <a href=\"https://issues.apache.org/jira/browse/MNG-6109\">\n     * MNG-6109<\/a> when using Maven-3.3.9 and before.\n     * Method can be removed once Maven 3.5.0 is the prerequisite for this plugin.\n     * @throws PlexusConfigurationException \n     * \n     * @since 3.5.1\n     * @see <a href=\"https://issues.apache.org/jira/browse/MNG-6109\">MNG-6109<\/a>\n     * @see <a href=\"https://issues.apache.org/jira/browse/MPLUGIN-319\">MPLUGIN-319<\/a>\n     */\n     void addMissingParameterSinceField( Parameter pd, PlexusConfiguration d ) throws PlexusConfigurationException\n     {\n         String parameterSince = d.getChild( \"since\" ).getValue();\n         pd.setSince( parameterSince );\n     }\n}\n","Smelly Sample":"package org.apache.maven.plugins.plugin.descriptor;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptorBuilder;\nimport org.apache.maven.rtinfo.RuntimeInformation;\nimport org.apache.maven.tools.plugin.EnhancedParameterWrapper;\nimport org.apache.maven.tools.plugin.ExtendedPluginDescriptor;\nimport org.codehaus.plexus.configuration.PlexusConfiguration;\nimport org.codehaus.plexus.configuration.PlexusConfigurationException;\nimport org.apache.maven.plugin.plugin.report.PluginReport;\n\nimport java.io.Reader;\nimport java.net.URI;\n\n/**\n * Reads enhanced plugin.xml files as generated by\n * {@link org.apache.maven.tools.plugin.generator.PluginDescriptorFilesGenerator} and\n * used by {@link PluginReport}.\n * Populates the slightly extended {@link Parameter} object {@link EnhancedParameterWrapper}.\n * In addition populates all (optional) elements added after Maven Plugin API 3.2.5.\n */\npublic class EnhancedPluginDescriptorBuilder extends PluginDescriptorBuilder\n{\n    private final boolean requireAddingMissingParameterSinceField;\n    private PlexusConfiguration configuration;\n\n    public EnhancedPluginDescriptorBuilder( RuntimeInformation rtInfo )\n    {\n        this( rtInfo.isMavenVersion( \"[,3.3.9]\" ) );\n    }\n\n    EnhancedPluginDescriptorBuilder( boolean requireAddingMissingParameterSinceField )\n    {\n        this.requireAddingMissingParameterSinceField = requireAddingMissingParameterSinceField;\n    }\n\n    /**\n     * Cache the returned configuration for additional evaluation in {@link #build(Reader, String)}.\n     */\n    @Override\n    public PlexusConfiguration buildConfiguration( Reader reader )\n        throws PlexusConfigurationException\n    {\n        configuration = super.buildConfiguration( reader );\n        return configuration;\n    }\n\n    @Override\n    public PluginDescriptor build( Reader reader, String source )\n        throws PlexusConfigurationException\n    {\n        PluginDescriptor pluginDescriptor = super.build( reader, source );\n        // elements added in plugin descriptor 1.1\n        ExtendedPluginDescriptor extendedPluginDescriptor = new ExtendedPluginDescriptor( pluginDescriptor );\n        extendedPluginDescriptor.setRequiredJavaVersion( configuration.getChild( \"requiredJavaVersion\" ).getValue() );\n        extendedPluginDescriptor.setRequiredMavenVersion( configuration.getChild( \"requiredMavenVersion\" ).getValue() );\n        return extendedPluginDescriptor;\n    }\n\n    @Override\n    public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDescriptor pluginDescriptor )\n        throws PlexusConfigurationException\n    {\n        MojoDescriptor mojoDescriptor = super.buildComponentDescriptor( c, pluginDescriptor );\n        \n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] parameterConfigurations = c.getChild( \"parameters\" ).getChildren( \"parameter\" );\n\n        for ( PlexusConfiguration d : parameterConfigurations )\n        {\n            String parameterName = d.getChild( \"name\" ).getValue();\n            // don't call getParameterMap() to not populate \n            Parameter pd = mojoDescriptor.getParameterMap().get( parameterName );\n            if ( requireAddingMissingParameterSinceField )\n            {\n                addMissingParameterSinceField( pd, d );\n            }\n            PlexusConfiguration configTypeJavadocUrl = d.getChild( \"typeJavadocUrl\", false );\n            if ( configTypeJavadocUrl != null )\n            {\n                String parameterTypeJavadocUrl = configTypeJavadocUrl.getValue();\n                EnhancedParameterWrapper enhancedParameter = new EnhancedParameterWrapper( pd );\n                enhancedParameter.setTypeJavadocUrl( URI.create( parameterTypeJavadocUrl ) );\n                mojoDescriptor.getParameters().set( mojoDescriptor.getParameters().indexOf( pd ), enhancedParameter );\n                mojoDescriptor.getParameterMap().put( parameterName, enhancedParameter );\n            }\n        }\n        return mojoDescriptor;\n    }\n\n    /**\n     * Reads the plugin descriptor and adds the fix for <a href=\"https://issues.apache.org/jira/browse/MNG-6109\">\n     * MNG-6109<\/a> when using Maven-3.3.9 and before.\n     * Method can be removed once Maven 3.5.0 is the prerequisite for this plugin.\n     * @throws PlexusConfigurationException \n     * \n     * @since 3.5.1\n     * @see <a href=\"https://issues.apache.org/jira/browse/MNG-6109\">MNG-6109<\/a>\n     * @see <a href=\"https://issues.apache.org/jira/browse/MPLUGIN-319\">MPLUGIN-319<\/a>\n     */\n     void addMissingParameterSinceField( Parameter pd, PlexusConfiguration d ) throws PlexusConfigurationException\n     {\n         String parameterSince = d.getChild( \"since\" ).getValue();\n         pd.setSince( parameterSince );\n     }\n}\n","lineNo":97}
{"Refactored Sample":"package org.apache.maven.tools.plugin.javadoc;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.BufferedReader;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.settings.Settings;\nimport org.codehaus.plexus.languages.java.version.JavaVersion;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Generates links for elements (packages, classes, fields, constructors, methods) in external\n * and/or an internal (potentially not yet existing) javadoc site.\n * The external site must be accessible for it to be considered due to the different fragment formats.\n */\npublic class JavadocLinkGenerator\n{\n    /**\n     * Javadoc tool version ranges whose generated sites expose different link formats.\n     *\n     */\n    public enum JavadocToolVersionRange\n    {\n        JDK7_OR_LOWER( null, JavaVersion.parse( \"1.8\" ) ),\n        JDK8_OR_9( JavaVersion.parse( \"1.8\" ), JavaVersion.parse( \"10\" ) ),\n        JDK10_OR_HIGHER( JavaVersion.parse( \"10\" ), null );\n        \n        // upper bound is exclusive, lower bound inclusive (null means unlimited)\n        private final JavaVersion lowerBound;\n        private final JavaVersion upperBound;\n        JavadocToolVersionRange( JavaVersion lowerBound, JavaVersion upperBound )\n        {\n            this.lowerBound = lowerBound;\n            this.upperBound = upperBound;\n        }\n\n        static JavadocToolVersionRange findMatch( JavaVersion javadocVersion )\n        {\n            for ( JavadocToolVersionRange range : values() )\n            {\n                if ( ( range.lowerBound == null || javadocVersion.isAtLeast( range.lowerBound ) )\n                     && ( range.upperBound == null || javadocVersion.isBefore( range.upperBound ) ) )\n                {\n                    return range;\n                }\n            }\n            throw new IllegalArgumentException( \"Found no matching javadoc tool version range for \" + javadocVersion );\n        }\n    }\n\n    private static final Logger LOG = LoggerFactory.getLogger( JavadocLinkGenerator.class );\n    private final List<JavadocSite> externalJavadocSites;\n    private final JavadocSite internalJavadocSite; // may be null\n\n    /**\n     * Constructor for an offline internal site only.\n     * \n     * @param internalJavadocSiteUrl the url of the javadoc generated website\n     * @param internalJavadocVersion the version of javadoc with which the internal site from\n     *                               {@code internalJavadocSiteUrl} has been generated\n     */\n    public JavadocLinkGenerator( URI internalJavadocSiteUrl,\n                                 String internalJavadocVersion )\n    {\n        this( internalJavadocSiteUrl, internalJavadocVersion, Collections.emptyList(), null );\n    }\n\n    /**\n     * Constructor for online external sites only.\n     * \n     * @param externalJavadocSiteUrls\n     * @param settings\n     */\n    public JavadocLinkGenerator( List<URI> externalJavadocSiteUrls, Settings settings )\n    {\n        this( null, null, externalJavadocSiteUrls, settings );\n    }\n\n    /**\n     * Constructor for both an internal (offline) and external (online) sites.\n     * \n     * @param internalJavadocSiteUrl\n     * @param internalJavadocVersion\n     * @param externalJavadocSiteUrls\n     * @param settings\n     */\n    public JavadocLinkGenerator( URI internalJavadocSiteUrl,\n                                 String internalJavadocVersion,\n                                 List<URI> externalJavadocSiteUrls, Settings settings )\n    {\n        if ( internalJavadocSiteUrl != null )\n        {\n            // resolve version\n            JavaVersion javadocVersion = JavaVersion.parse( internalJavadocVersion );\n            internalJavadocSite = new JavadocSite( internalJavadocSiteUrl,\n                                                   JavadocToolVersionRange.findMatch( javadocVersion ),\n                                                   false );\n        }\n        else\n        {\n            internalJavadocSite = null;\n        }\n        if ( externalJavadocSiteUrls != null )\n        {\n            externalJavadocSites = new ArrayList<>( externalJavadocSiteUrls.size() );\n            for ( URI siteUrl : externalJavadocSiteUrls  )\n            {\n                try\n                {\n                    externalJavadocSites.add( new JavadocSite( siteUrl, settings ) );\n                }\n                catch ( IOException e )\n                {\n                    LOG.warn( \"Could not use {} as base URL: {}\", siteUrl, e.getMessage(), e );\n                }\n            }\n        }\n        else\n        {\n            externalJavadocSites = Collections.emptyList();\n        }\n        if ( internalJavadocSite == null && externalJavadocSites.isEmpty() )\n        {\n            throw new IllegalArgumentException( \"Either internal or at least one accessible external javadoc \"\n                                                + \"URLs must be given!\" );\n        }\n    }\n\n    /**\n     * Generates a (deep-)link to a HTML page in any of the sites given to the constructor.\n     * The link is not validated (i.e. might point to a non-existing page).\n     * Only uses the offline site for references returning {@code false} for\n     * {@link FullyQualifiedJavadocReference#isExternal()}.\n     * @param javadocReference\n     * @return the (deep-) link towards a javadoc page\n     * @throws IllegalArgumentException in case no javadoc link could be generated for the given reference\n     * @throws IllegalStateException in case no javadoc source sites have been configured\n     */\n    public URI createLink( FullyQualifiedJavadocReference javadocReference )\n    {\n        if ( !javadocReference.isExternal() && internalJavadocSite != null )\n        {\n            return internalJavadocSite.createLink( javadocReference );\n        }\n        else\n        {\n            JavadocSite javadocSite = externalJavadocSites.stream()\n                .filter( base -> base.hasEntryFor( javadocReference.getModuleName(),\n                                                   javadocReference.getPackageName() ) )\n                .findFirst().orElseThrow( () -> new IllegalArgumentException( \"Found no javadoc site for \"\n                + javadocReference ) );\n            return javadocSite.createLink( javadocReference );\n        }\n    }\n\n    /**\n     * Generates a (deep-)link to a HTML page in any of the sites given to the constructor.\n     * The link is not validated (i.e. might point to a non-existing page).\n     * Preferably resolves from the online sites if they provide the given package.\n     * @param binaryName a binary name according to \n     * <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1\">JLS 13.1<\/a>\n     * @return the (deep-) link towards a javadoc page\n     * @throws IllegalArgumentException in case no javadoc link could be generated for the given name\n     */\n    public URI createLink( String binaryName )\n    {\n        Map.Entry<String, String> packageAndClassName = JavadocSite.getPackageAndClassName( binaryName );\n        // first check external links, otherwise assume internal link\n        JavadocSite javadocSite = externalJavadocSites.stream()\n                        .filter( base -> base.hasEntryFor( Optional.empty(),\n                                                           Optional.of( packageAndClassName.getKey() ) ) )\n                        .findFirst().orElse( null );\n        if ( javadocSite == null )\n        {\n            if ( internalJavadocSite != null )\n            {\n                javadocSite = internalJavadocSite;\n            }\n            else\n            {\n                throw new IllegalArgumentException( \"Found no javadoc site for \" + binaryName );\n            }\n        }\n        return javadocSite.createLink( packageAndClassName.getKey(), packageAndClassName.getValue() );\n    }\n\n    public URI getInternalJavadocSiteBaseUrl()\n    {\n        if ( internalJavadocSite == null )\n        {\n            throw new IllegalStateException( \"Could not get docroot of internal javadoc as it hasn't been set\" );\n        }\n        return internalJavadocSite.getBaseUri();\n    }\n    \n    /**\n     * Checks if a given link is valid. For absolute links uses the underling {@link java.net.HttpURLConnection},\n     * otherwise checks for existence of the file on the filesystem.\n     * \n     * @param url the url to check\n     * @param baseDirectory the base directory to which relative file URLs refer\n     * @return {@code true} in case the given link is valid otherwise {@code false}\n     */\n    public static boolean isLinkValid( URI url, Path baseDirectory )\n    {\n        if ( url.isAbsolute() )\n        {\n            try ( BufferedReader reader = JavadocSite.getReader( url.toURL(), null ) )\n            {\n                if ( url.getFragment() != null )\n                {\n                    Pattern pattern = JavadocSite.getAnchorPattern( url.getFragment() );\n                    if ( reader.lines().noneMatch( pattern.asPredicate() ) )\n                    {\n                        return false;\n                    }\n                }\n            }\n            catch ( IOException e )\n            {\n                return false;\n            }\n            return true;\n        }\n        else\n        {\n            Path file = baseDirectory.resolve( url.getPath() );\n            boolean exists = Files.exists( file );\n            if ( !exists )\n            {\n                LOG.debug( \"Could not find file given through '{}' in resolved path '{}'\", url, file );\n            }\n            return exists;\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.javadoc;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.BufferedReader;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.settings.Settings;\nimport org.codehaus.plexus.languages.java.version.JavaVersion;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Generates links for elements (packages, classes, fields, constructors, methods) in external\n * and/or an internal (potentially not yet existing) javadoc site.\n * The external site must be accessible for it to be considered due to the different fragment formats.\n */\npublic class JavadocLinkGenerator\n{\n    /**\n     * Javadoc tool version ranges whose generated sites expose different link formats.\n     *\n     */\n    public enum JavadocToolVersionRange\n    {\n        JDK7_OR_LOWER( null, JavaVersion.parse( \"1.8\" ) ),\n        JDK8_OR_9( JavaVersion.parse( \"1.8\" ), JavaVersion.parse( \"10\" ) ),\n        JDK10_OR_HIGHER( JavaVersion.parse( \"10\" ), null );\n        \n        // upper bound is exclusive, lower bound inclusive (null means unlimited)\n        private final JavaVersion lowerBound;\n        private final JavaVersion upperBound;\n        JavadocToolVersionRange( JavaVersion lowerBound, JavaVersion upperBound )\n        {\n            this.lowerBound = lowerBound;\n            this.upperBound = upperBound;\n        }\n\n        static JavadocToolVersionRange findMatch( JavaVersion javadocVersion )\n        {\n            for ( JavadocToolVersionRange range : values() )\n            {\n                if ( ( range.lowerBound == null || javadocVersion.isAtLeast( range.lowerBound ) )\n                     && ( range.upperBound == null || javadocVersion.isBefore( range.upperBound ) ) )\n                {\n                    return range;\n                }\n            }\n            throw new IllegalArgumentException( \"Found no matching javadoc tool version range for \" + javadocVersion );\n        }\n    }\n\n    private static final Logger LOG = LoggerFactory.getLogger( JavadocLinkGenerator.class );\n    private final List<JavadocSite> externalJavadocSites;\n    private final JavadocSite internalJavadocSite; // may be null\n\n    /**\n     * Constructor for an offline internal site only.\n     * \n     * @param internalJavadocSiteUrl the url of the javadoc generated website\n     * @param internalJavadocVersion the version of javadoc with which the internal site from\n     *                               {@code internalJavadocSiteUrl} has been generated\n     */\n    public JavadocLinkGenerator( URI internalJavadocSiteUrl,\n                                 String internalJavadocVersion )\n    {\n        this( internalJavadocSiteUrl, internalJavadocVersion, Collections.emptyList(), null );\n    }\n\n    /**\n     * Constructor for online external sites only.\n     * \n     * @param externalJavadocSiteUrls\n     * @param settings\n     */\n    public JavadocLinkGenerator( List<URI> externalJavadocSiteUrls, Settings settings )\n    {\n        this( null, null, externalJavadocSiteUrls, settings );\n    }\n\n    /**\n     * Constructor for both an internal (offline) and external (online) sites.\n     * \n     * @param internalJavadocSiteUrl\n     * @param internalJavadocVersion\n     * @param externalJavadocSiteUrls\n     * @param settings\n     */\n    public JavadocLinkGenerator( URI internalJavadocSiteUrl,\n                                 String internalJavadocVersion,\n                                 List<URI> externalJavadocSiteUrls, Settings settings )\n    {\n        if ( internalJavadocSiteUrl != null )\n        {\n            // resolve version\n            JavaVersion javadocVersion = JavaVersion.parse( internalJavadocVersion );\n            internalJavadocSite = new JavadocSite( internalJavadocSiteUrl,\n                                                   JavadocToolVersionRange.findMatch( javadocVersion ),\n                                                   false );\n        }\n        else\n        {\n            internalJavadocSite = null;\n        }\n        if ( externalJavadocSiteUrls != null )\n        {\n            externalJavadocSites = new ArrayList<>( externalJavadocSiteUrls.size() );\n            for ( URI siteUrl : externalJavadocSiteUrls  )\n            {\n                try\n                {\n                    externalJavadocSites.add( new JavadocSite( siteUrl, settings ) );\n                }\n                catch ( IOException e )\n                {\n                    LOG.warn( \"Could not use {} as base URL: {}\", siteUrl, e.getMessage(), e );\n                }\n            }\n        }\n        else\n        {\n            externalJavadocSites = Collections.emptyList();\n        }\n        if ( internalJavadocSite == null && externalJavadocSites.isEmpty() )\n        {\n            throw new IllegalArgumentException( \"Either internal or at least one accessible external javadoc \"\n                                                + \"URLs must be given!\" );\n        }\n    }\n\n    /**\n     * Generates a (deep-)link to a HTML page in any of the sites given to the constructor.\n     * The link is not validated (i.e. might point to a non-existing page).\n     * Only uses the offline site for references returning {@code false} for\n     * {@link FullyQualifiedJavadocReference#isExternal()}.\n     * @param javadocReference\n     * @return the (deep-) link towards a javadoc page\n     * @throws IllegalArgumentException in case no javadoc link could be generated for the given reference\n     * @throws IllegalStateException in case no javadoc source sites have been configured\n     */\n    public URI createLink( FullyQualifiedJavadocReference javadocReference )\n    {\n        if ( !javadocReference.isExternal() && internalJavadocSite != null )\n        {\n            return internalJavadocSite.createLink( javadocReference );\n        }\n        else\n        {\n            JavadocSite javadocSite = externalJavadocSites.stream()\n                .filter( base -> base.hasEntryFor( javadocReference.getModuleName(),\n                                                   javadocReference.getPackageName() ) )\n                .findFirst().orElseThrow( () -> new IllegalArgumentException( \"Found no javadoc site for \"\n                + javadocReference ) );\n            return javadocSite.createLink( javadocReference );\n        }\n    }\n\n    /**\n     * Generates a (deep-)link to a HTML page in any of the sites given to the constructor.\n     * The link is not validated (i.e. might point to a non-existing page).\n     * Preferably resolves from the online sites if they provide the given package.\n     * @param binaryName a binary name according to \n     * <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1\">JLS 13.1<\/a>\n     * @return the (deep-) link towards a javadoc page\n     * @throws IllegalArgumentException in case no javadoc link could be generated for the given name\n     */\n    public URI createLink( String binaryName )\n    {\n        Map.Entry<String, String> packageAndClassName = JavadocSite.getPackageAndClassName( binaryName );\n        // first check external links, otherwise assume internal link\n        JavadocSite javadocSite = externalJavadocSites.stream()\n                        .filter( base -> base.hasEntryFor( Optional.empty(),\n                                                           Optional.of( packageAndClassName.getKey() ) ) )\n                        .findFirst().orElse( null );\n        if ( javadocSite == null )\n        {\n            if ( internalJavadocSite != null )\n            {\n                javadocSite = internalJavadocSite;\n            }\n            else\n            {\n                throw new IllegalArgumentException( \"Found no javadoc site for \" + binaryName );\n            }\n        }\n        return javadocSite.createLink( packageAndClassName.getKey(), packageAndClassName.getValue() );\n    }\n\n    public URI getInternalJavadocSiteBaseUrl()\n    {\n        if ( internalJavadocSite == null )\n        {\n            throw new IllegalStateException( \"Could not get docroot of internal javadoc as it hasn't been set\" );\n        }\n        return internalJavadocSite.getBaseUri();\n    }\n    \n    /**\n     * Checks if a given link is valid. For absolute links uses the underling {@link java.net.HttpURLConnection},\n     * otherwise checks for existence of the file on the filesystem.\n     * \n     * @param url the url to check\n     * @param baseDirectory the base directory to which relative file URLs refer\n     * @return {@code true} in case the given link is valid otherwise {@code false}\n     */\n    public static boolean isLinkValid( URI url, Path baseDirectory )\n    {\n        if ( url.isAbsolute() )\n        {\n            try ( BufferedReader reader = JavadocSite.getReader( url.toURL(), null ) )\n            {\n                if ( url.getFragment() != null )\n                {\n                    Pattern pattern = JavadocSite.getAnchorPattern( url.getFragment() );\n                    if ( reader.lines().noneMatch( pattern.asPredicate() ) )\n                    {\n                        return false;\n                    }\n                }\n            }\n            catch ( IOException e )\n            {\n                return false;\n            }\n            return true;\n        }\n        else\n        {\n            return Files.exists( baseDirectory.resolve( url.getPath() ) );\n        }\n    }\n}\n","lineNo":256}
{"Refactored Sample":"package org.apache.maven.tools.plugin.javadoc;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.BufferedReader;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.settings.Settings;\nimport org.codehaus.plexus.languages.java.version.JavaVersion;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Generates links for elements (packages, classes, fields, constructors, methods) in external\n * and/or an internal (potentially not yet existing) javadoc site.\n * The external site must be accessible for it to be considered due to the different fragment formats.\n */\npublic class JavadocLinkGenerator\n{\n    /**\n     * Javadoc tool version ranges whose generated sites expose different link formats.\n     *\n     */\n    public enum JavadocToolVersionRange\n    {\n        JDK7_OR_LOWER( null, JavaVersion.parse( \"1.8\" ) ),\n        JDK8_OR_9( JavaVersion.parse( \"1.8\" ), JavaVersion.parse( \"10\" ) ),\n        JDK10_OR_HIGHER( JavaVersion.parse( \"10\" ), null );\n        \n        // upper bound is exclusive, lower bound inclusive (null means unlimited)\n        private final JavaVersion lowerBound;\n        private final JavaVersion upperBound;\n        JavadocToolVersionRange( JavaVersion lowerBound, JavaVersion upperBound )\n        {\n            this.lowerBound = lowerBound;\n            this.upperBound = upperBound;\n        }\n\n        static JavadocToolVersionRange findMatch( JavaVersion javadocVersion )\n        {\n            for ( JavadocToolVersionRange range : values() )\n            {\n                if ( ( range.lowerBound == null || javadocVersion.isAtLeast( range.lowerBound ) )\n                     && ( range.upperBound == null || javadocVersion.isBefore( range.upperBound ) ) )\n                {\n                    return range;\n                }\n            }\n            throw new IllegalArgumentException( \"Found no matching javadoc tool version range for \" + javadocVersion );\n        }\n    }\n\n    private static final Logger LOG = LoggerFactory.getLogger( JavadocLinkGenerator.class );\n    private final List<JavadocSite> externalJavadocSites;\n    private final JavadocSite internalJavadocSite; // may be null\n\n    /**\n     * Constructor for an offline internal site only.\n     * \n     * @param internalJavadocSiteUrl the url of the javadoc generated website\n     * @param internalJavadocVersion the version of javadoc with which the internal site from\n     *                               {@code internalJavadocSiteUrl} has been generated\n     */\n    public JavadocLinkGenerator( URI internalJavadocSiteUrl,\n                                 String internalJavadocVersion )\n    {\n        this( internalJavadocSiteUrl, internalJavadocVersion, Collections.emptyList(), null );\n    }\n\n    /**\n     * Constructor for online external sites only.\n     * \n     * @param externalJavadocSiteUrls\n     * @param settings\n     */\n    public JavadocLinkGenerator( List<URI> externalJavadocSiteUrls, Settings settings )\n    {\n        this( null, null, externalJavadocSiteUrls, settings );\n    }\n\n    /**\n     * Constructor for both an internal (offline) and external (online) sites.\n     * \n     * @param internalJavadocSiteUrl\n     * @param internalJavadocVersion\n     * @param externalJavadocSiteUrls\n     * @param settings\n     */\n    public JavadocLinkGenerator( URI internalJavadocSiteUrl,\n                                 String internalJavadocVersion,\n                                 List<URI> externalJavadocSiteUrls, Settings settings )\n    {\n        if ( internalJavadocSiteUrl != null )\n        {\n            // resolve version\n            JavaVersion javadocVersion = JavaVersion.parse( internalJavadocVersion );\n            internalJavadocSite = new JavadocSite( internalJavadocSiteUrl,\n                                                   JavadocToolVersionRange.findMatch( javadocVersion ),\n                                                   false );\n        }\n        else\n        {\n            internalJavadocSite = null;\n        }\n        if ( externalJavadocSiteUrls != null )\n        {\n            externalJavadocSites = new ArrayList<>( externalJavadocSiteUrls.size() );\n            for ( URI siteUrl : externalJavadocSiteUrls  )\n            {\n                try\n                {\n                    externalJavadocSites.add( new JavadocSite( siteUrl, settings ) );\n                }\n                catch ( IOException e )\n                {\n                    LOG.warn( \"Could not use {} as base URL: {}\", siteUrl, e.getMessage(), e );\n                }\n            }\n        }\n        else\n        {\n            externalJavadocSites = Collections.emptyList();\n        }\n        if ( internalJavadocSite == null && externalJavadocSites.isEmpty() )\n        {\n            throw new IllegalArgumentException( \"Either internal or at least one accessible external javadoc \"\n                                                + \"URLs must be given!\" );\n        }\n    }\n\n    /**\n     * Generates a (deep-)link to a HTML page in any of the sites given to the constructor.\n     * The link is not validated (i.e. might point to a non-existing page).\n     * Only uses the offline site for references returning {@code false} for\n     * {@link FullyQualifiedJavadocReference#isExternal()}.\n     * @param javadocReference\n     * @return the (deep-) link towards a javadoc page\n     * @throws IllegalArgumentException in case no javadoc link could be generated for the given reference\n     * @throws IllegalStateException in case no javadoc source sites have been configured\n     */\n    public URI createLink( FullyQualifiedJavadocReference javadocReference )\n    {\n        if ( !javadocReference.isExternal() && internalJavadocSite != null )\n        {\n            return internalJavadocSite.createLink( javadocReference );\n        }\n        else\n        {\n            JavadocSite javadocSite = externalJavadocSites.stream()\n                .filter( base -> base.hasEntryFor( javadocReference.getModuleName(),\n                                                   javadocReference.getPackageName() ) )\n                .findFirst().orElseThrow( () -> new IllegalArgumentException( \"Found no javadoc site for \"\n                + javadocReference ) );\n            return javadocSite.createLink( javadocReference );\n        }\n    }\n\n    /**\n     * Generates a (deep-)link to a HTML page in any of the sites given to the constructor.\n     * The link is not validated (i.e. might point to a non-existing page).\n     * Preferably resolves from the online sites if they provide the given package.\n     * @param binaryName a binary name according to \n     * <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1\">JLS 13.1<\/a>\n     * @return the (deep-) link towards a javadoc page\n     * @throws IllegalArgumentException in case no javadoc link could be generated for the given name\n     */\n    public URI createLink( String binaryName )\n    {\n        Map.Entry<String, String> packageAndClassName = JavadocSite.getPackageAndClassName( binaryName );\n        // first check external links, otherwise assume internal link\n        JavadocSite javadocSite = externalJavadocSites.stream()\n                        .filter( base -> base.hasEntryFor( Optional.empty(),\n                                                           Optional.of( packageAndClassName.getKey() ) ) )\n                        .findFirst().orElse( null );\n        if ( javadocSite == null )\n        {\n            if ( internalJavadocSite != null )\n            {\n                javadocSite = internalJavadocSite;\n            }\n            else\n            {\n                throw new IllegalArgumentException( \"Found no javadoc site for \" + binaryName );\n            }\n        }\n        return javadocSite.createLink( packageAndClassName.getKey(), packageAndClassName.getValue() );\n    }\n\n    public URI getInternalJavadocSiteBaseUrl()\n    {\n        if ( internalJavadocSite == null )\n        {\n            throw new IllegalStateException( \"Could not get docroot of internal javadoc as it hasn't been set\" );\n        }\n        return internalJavadocSite.getBaseUri();\n    }\n    \n    /**\n     * Checks if a given link is valid. For absolute links uses the underling {@link java.net.HttpURLConnection},\n     * otherwise checks for existence of the file on the filesystem.\n     * \n     * @param url the url to check\n     * @param baseDirectory the base directory to which relative file URLs refer\n     * @return {@code true} in case the given link is valid otherwise {@code false}\n     */\n    public static boolean isLinkValid( URI url, Path baseDirectory )\n    {\n        if ( url.isAbsolute() )\n        {\n            try ( BufferedReader reader = JavadocSite.getReader( url.toURL(), null ) )\n            {\n                if ( url.getFragment() != null )\n                {\n                    Pattern pattern = JavadocSite.getAnchorPattern( url.getFragment() );\n                    if ( reader.lines().noneMatch( pattern.asPredicate() ) )\n                    {\n                        return false;\n                    }\n                }\n            }\n            catch ( IOException e )\n            {\n                return false;\n            }\n            return true;\n        }\n        else\n        {\n            Path file = baseDirectory.resolve( url.getPath() );\n            boolean exists = Files.exists( file );\n            if ( !exists )\n            {\n                LOG.debug( \"Could not find file given through '{}' in resolved path '{}'\", url, file );\n            }\n            return exists;\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.javadoc;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.BufferedReader;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.settings.Settings;\nimport org.codehaus.plexus.languages.java.version.JavaVersion;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Generates links for elements (packages, classes, fields, constructors, methods) in external\n * and/or an internal (potentially not yet existing) javadoc site.\n * The external site must be accessible for it to be considered due to the different fragment formats.\n */\npublic class JavadocLinkGenerator\n{\n    /**\n     * Javadoc tool version ranges whose generated sites expose different link formats.\n     *\n     */\n    public enum JavadocToolVersionRange\n    {\n        JDK7_OR_LOWER( null, JavaVersion.parse( \"1.8\" ) ),\n        JDK8_OR_9( JavaVersion.parse( \"1.8\" ), JavaVersion.parse( \"10\" ) ),\n        JDK10_OR_HIGHER( JavaVersion.parse( \"10\" ), null );\n        \n        // upper bound is exclusive, lower bound inclusive (null means unlimited)\n        private final JavaVersion lowerBound;\n        private final JavaVersion upperBound;\n        JavadocToolVersionRange( JavaVersion lowerBound, JavaVersion upperBound )\n        {\n            this.lowerBound = lowerBound;\n            this.upperBound = upperBound;\n        }\n\n        static JavadocToolVersionRange findMatch( JavaVersion javadocVersion )\n        {\n            for ( JavadocToolVersionRange range : values() )\n            {\n                if ( ( range.lowerBound == null || javadocVersion.isAtLeast( range.lowerBound ) )\n                     && ( range.upperBound == null || javadocVersion.isBefore( range.upperBound ) ) )\n                {\n                    return range;\n                }\n            }\n            throw new IllegalArgumentException( \"Found no matching javadoc tool version range for \" + javadocVersion );\n        }\n    }\n\n    private static final Logger LOG = LoggerFactory.getLogger( JavadocLinkGenerator.class );\n    private final List<JavadocSite> externalJavadocSites;\n    private final JavadocSite internalJavadocSite; // may be null\n\n    /**\n     * Constructor for an offline internal site only.\n     * \n     * @param internalJavadocSiteUrl the url of the javadoc generated website\n     * @param internalJavadocVersion the version of javadoc with which the internal site from\n     *                               {@code internalJavadocSiteUrl} has been generated\n     */\n    public JavadocLinkGenerator( URI internalJavadocSiteUrl,\n                                 String internalJavadocVersion )\n    {\n        this( internalJavadocSiteUrl, internalJavadocVersion, Collections.emptyList(), null );\n    }\n\n    /**\n     * Constructor for online external sites only.\n     * \n     * @param externalJavadocSiteUrls\n     * @param settings\n     */\n    public JavadocLinkGenerator( List<URI> externalJavadocSiteUrls, Settings settings )\n    {\n        this( null, null, externalJavadocSiteUrls, settings );\n    }\n\n    /**\n     * Constructor for both an internal (offline) and external (online) sites.\n     * \n     * @param internalJavadocSiteUrl\n     * @param internalJavadocVersion\n     * @param externalJavadocSiteUrls\n     * @param settings\n     */\n    public JavadocLinkGenerator( URI internalJavadocSiteUrl,\n                                 String internalJavadocVersion,\n                                 List<URI> externalJavadocSiteUrls, Settings settings )\n    {\n        if ( internalJavadocSiteUrl != null )\n        {\n            // resolve version\n            JavaVersion javadocVersion = JavaVersion.parse( internalJavadocVersion );\n            internalJavadocSite = new JavadocSite( internalJavadocSiteUrl,\n                                                   JavadocToolVersionRange.findMatch( javadocVersion ),\n                                                   false );\n        }\n        else\n        {\n            internalJavadocSite = null;\n        }\n        if ( externalJavadocSiteUrls != null )\n        {\n            externalJavadocSites = new ArrayList<>( externalJavadocSiteUrls.size() );\n            for ( URI siteUrl : externalJavadocSiteUrls  )\n            {\n                try\n                {\n                    externalJavadocSites.add( new JavadocSite( siteUrl, settings ) );\n                }\n                catch ( IOException e )\n                {\n                    LOG.warn( \"Could not use {} as base URL: {}\", siteUrl, e.getMessage(), e );\n                }\n            }\n        }\n        else\n        {\n            externalJavadocSites = Collections.emptyList();\n        }\n        if ( internalJavadocSite == null && externalJavadocSites.isEmpty() )\n        {\n            throw new IllegalArgumentException( \"Either internal or at least one accessible external javadoc \"\n                                                + \"URLs must be given!\" );\n        }\n    }\n\n    /**\n     * Generates a (deep-)link to a HTML page in any of the sites given to the constructor.\n     * The link is not validated (i.e. might point to a non-existing page).\n     * Only uses the offline site for references returning {@code false} for\n     * {@link FullyQualifiedJavadocReference#isExternal()}.\n     * @param javadocReference\n     * @return the (deep-) link towards a javadoc page\n     * @throws IllegalArgumentException in case no javadoc link could be generated for the given reference\n     * @throws IllegalStateException in case no javadoc source sites have been configured\n     */\n    public URI createLink( FullyQualifiedJavadocReference javadocReference )\n    {\n        if ( !javadocReference.isExternal() && internalJavadocSite != null )\n        {\n            return internalJavadocSite.createLink( javadocReference );\n        }\n        else\n        {\n            JavadocSite javadocSite = externalJavadocSites.stream()\n                .filter( base -> base.hasEntryFor( javadocReference.getModuleName(),\n                                                   javadocReference.getPackageName() ) )\n                .findFirst().orElseThrow( () -> new IllegalArgumentException( \"Found no javadoc site for \"\n                + javadocReference ) );\n            return javadocSite.createLink( javadocReference );\n        }\n    }\n\n    /**\n     * Generates a (deep-)link to a HTML page in any of the sites given to the constructor.\n     * The link is not validated (i.e. might point to a non-existing page).\n     * Preferably resolves from the online sites if they provide the given package.\n     * @param binaryName a binary name according to \n     * <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1\">JLS 13.1<\/a>\n     * @return the (deep-) link towards a javadoc page\n     * @throws IllegalArgumentException in case no javadoc link could be generated for the given name\n     */\n    public URI createLink( String binaryName )\n    {\n        Map.Entry<String, String> packageAndClassName = JavadocSite.getPackageAndClassName( binaryName );\n        // first check external links, otherwise assume internal link\n        JavadocSite javadocSite = externalJavadocSites.stream()\n                        .filter( base -> base.hasEntryFor( Optional.empty(),\n                                                           Optional.of( packageAndClassName.getKey() ) ) )\n                        .findFirst().orElse( null );\n        if ( javadocSite == null )\n        {\n            if ( internalJavadocSite != null )\n            {\n                javadocSite = internalJavadocSite;\n            }\n            else\n            {\n                throw new IllegalArgumentException( \"Found no javadoc site for \" + binaryName );\n            }\n        }\n        return javadocSite.createLink( packageAndClassName.getKey(), packageAndClassName.getValue() );\n    }\n\n    public URI getInternalJavadocSiteBaseUrl()\n    {\n        if ( internalJavadocSite == null )\n        {\n            throw new IllegalStateException( \"Could not get docroot of internal javadoc as it hasn't been set\" );\n        }\n        return internalJavadocSite.getBaseUri();\n    }\n    \n    /**\n     * Checks if a given link is valid. For absolute links uses the underling {@link java.net.HttpURLConnection},\n     * otherwise checks for existence of the file on the filesystem.\n     * \n     * @param url the url to check\n     * @param baseDirectory the base directory to which relative file URLs refer\n     * @return {@code true} in case the given link is valid otherwise {@code false}\n     */\n    public static boolean isLinkValid( URI url, Path baseDirectory )\n    {\n        if ( url.isAbsolute() )\n        {\n            try ( BufferedReader reader = JavadocSite.getReader( url.toURL(), null ) )\n            {\n                if ( url.getFragment() != null )\n                {\n                    Pattern pattern = JavadocSite.getAnchorPattern( url.getFragment() );\n                    if ( reader.lines().noneMatch( pattern.asPredicate() ) )\n                    {\n                        return false;\n                    }\n                }\n            }\n            catch ( IOException e )\n            {\n                return false;\n            }\n            return true;\n        }\n        else\n        {\n            return Files.exists( baseDirectory.resolve( url.getPath() ) );\n        }\n    }\n}\n","lineNo":257}
{"Refactored Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.EnhancedParameterWrapper;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.javadoc.JavadocLinkGenerator;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.io.CachingOutputStream;\nimport org.codehaus.plexus.util.xml.PrettyPrintXMLWriter;\nimport org.codehaus.plexus.util.xml.XMLWriter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * Generate <a href=\"https://maven.apache.org/doxia/references/xdoc-format.html\">xdoc documentation<\/a> for each mojo.\n */\npublic class PluginXdocGenerator\n    implements Generator\n{\n    /**\n     * Regular expression matching an XHTML link\n     * group 1 = link target, group 2 = link label\n     */\n    private static final Pattern HTML_LINK_PATTERN = Pattern.compile( \"<a href=\\\\\\\"([^\\\\\\\"]*)\\\\\\\">(.*?)<\/a>\" );\n\n    private static final Logger LOG = LoggerFactory.getLogger( PluginXdocGenerator.class );\n\n    /**\n     * locale\n     */\n    private final Locale locale;\n\n    /**\n     * project\n     */\n    private final MavenProject project;\n\n    /**\n     * The directory where the generated site is written.\n     * Used for resolving relative links to javadoc.\n     */\n    private final File reportOutputDirectory;\n\n    private final boolean disableInternalJavadocLinkValidation;\n\n    /**\n     * Default constructor using <code>Locale.ENGLISH<\/code> as locale.\n     * Used only in test cases.\n     */\n    public PluginXdocGenerator()\n    {\n        this( null );\n    }\n\n    /**\n     * Constructor using <code>Locale.ENGLISH<\/code> as locale.\n     *\n     * @param project not null Maven project.\n     */\n    public PluginXdocGenerator( MavenProject project )\n    {\n        this( project, Locale.ENGLISH, new File( \"\" ).getAbsoluteFile(), false );\n    }\n\n    /**\n     * @param project not null.\n     * @param locale  not null wanted locale.\n     */\n    public PluginXdocGenerator( MavenProject project, Locale locale, File reportOutputDirectory,\n                                boolean disableInternalJavadocLinkValidation )\n    {\n        this.project = project;\n        if ( locale == null )\n        {\n            this.locale = Locale.ENGLISH;\n        }\n        else\n        {\n            this.locale = locale;\n        }\n        this.reportOutputDirectory = reportOutputDirectory;\n        this.disableInternalJavadocLinkValidation = disableInternalJavadocLinkValidation;\n    }\n\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws GeneratorException\n    {\n        try\n        {\n            if ( request.getPluginDescriptor().getMojos() != null )\n            {\n                List<MojoDescriptor> mojos = request.getPluginDescriptor().getMojos();\n                for ( MojoDescriptor descriptor : mojos )\n                {\n                    processMojoDescriptor( descriptor, destinationDirectory );\n                }\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n\n    }\n\n    /**\n     * @param mojoDescriptor       not null\n     * @param destinationDirectory not null\n     * @throws IOException if any\n     */\n    protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, File destinationDirectory )\n        throws IOException\n    {\n        File outputFile = new File( destinationDirectory, getMojoFilename( mojoDescriptor, \"xml\" ) );\n        try ( Writer writer = new OutputStreamWriter( new CachingOutputStream( outputFile ), UTF_8 ) )\n        {\n            XMLWriter w = new PrettyPrintXMLWriter( new PrintWriter( writer ), UTF_8.name(), null );\n            writeBody( mojoDescriptor, w );\n\n            writer.flush();\n        }\n    }\n\n    /**\n     * @param mojo not null\n     * @param ext  not null\n     * @return the output file name\n     */\n    private String getMojoFilename( MojoDescriptor mojo, String ext )\n    {\n        return mojo.getGoal() + \"-mojo.\" + ext;\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @param w              not null\n     */\n    private void writeBody( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"document\" );\n        w.addAttribute( \"xmlns\", \"http://maven.apache.org/XDOC/2.0\" );\n        w.addAttribute( \"xmlns:xsi\", \"http://www.w3.org/2001/XMLSchema-instance\" );\n        w.addAttribute( \"xsi:schemaLocation\",\n                        \"http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"properties\" );\n\n        w.startElement( \"title\" );\n        w.writeText( mojoDescriptor.getFullGoalName() );\n        w.endElement(); // title\n\n        w.endElement(); // properties\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"body\" );\n\n        w.startElement( \"section\" );\n\n        w.addAttribute( \"name\", mojoDescriptor.getFullGoalName() );\n\n        writeReportNotice( mojoDescriptor, w );\n\n        w.startElement( \"p\" );\n        w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.fullname\" ) );\n        w.endElement(); //p\n        w.startElement( \"p\" );\n        w.writeMarkup( mojoDescriptor.getPluginDescriptor().getGroupId() + \":\"\n                           + mojoDescriptor.getPluginDescriptor().getArtifactId() + \":\"\n                           + mojoDescriptor.getPluginDescriptor().getVersion() + \":\" + mojoDescriptor.getGoal() );\n        w.endElement(); //p\n\n        String context = \"goal \" + mojoDescriptor.getGoal();\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getDeprecated() ) )\n        {\n            w.startElement( \"p\" );\n            w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.deprecated\" ) );\n            w.endElement(); // p\n            w.startElement( \"div\" );\n            w.writeMarkup( getXhtmlWithValidatedLinks( mojoDescriptor.getDeprecated(), context ) );\n            w.endElement(); // div\n        }\n\n        w.startElement( \"p\" );\n        w.writeMarkup( getString( \"pluginxdoc.description\" ) );\n        w.endElement(); //p\n        w.startElement( \"div\" );\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getDescription() ) )\n        {\n            w.writeMarkup( getXhtmlWithValidatedLinks( mojoDescriptor.getDescription(), context ) );\n        }\n        else\n        {\n            w.writeText( getString( \"pluginxdoc.nodescription\" ) );\n        }\n        w.endElement(); // div\n\n        writeGoalAttributes( mojoDescriptor, w );\n\n        writeGoalParameterTable( mojoDescriptor, w );\n\n        w.endElement(); // section\n\n        w.endElement(); // body\n\n        w.endElement(); // document\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @param w              not null\n     */\n    private void writeReportNotice( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        if ( GeneratorUtils.isMavenReport( mojoDescriptor.getImplementation(), project ) )\n        {\n            w.startElement( \"p\" );\n            w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.notice.note\" ) );\n            w.writeText( getString( \"pluginxdoc.mojodescriptor.notice.isMavenReport\" ) );\n            w.endElement(); //p\n        }\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @param w              not null\n     */\n    private void writeGoalAttributes( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"p\" );\n        w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.attributes\" ) );\n        w.endElement(); //p\n\n        boolean addedUl = false;\n        String value;\n        if ( mojoDescriptor.isProjectRequired() )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.projectRequired\" ) );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isRequiresReports() )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.reportingMojo\" ) );\n            w.endElement(); // li\n        }\n\n        if ( mojoDescriptor.isAggregator() )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.aggregator\" ) );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isDirectInvocationOnly() )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.directInvocationOnly\" ) );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.isDependencyResolutionRequired();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( format( \"pluginxdoc.mojodescriptor.dependencyResolutionRequired\", value ) );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor instanceof ExtendedMojoDescriptor )\n        {\n            ExtendedMojoDescriptor extendedMojoDescriptor = (ExtendedMojoDescriptor) mojoDescriptor;\n\n            value = extendedMojoDescriptor.getDependencyCollectionRequired();\n            if ( StringUtils.isNotEmpty( value ) )\n            {\n                addedUl = addUl( w, addedUl );\n                w.startElement( \"li\" );\n                w.writeMarkup( format( \"pluginxdoc.mojodescriptor.dependencyCollectionRequired\", value ) );\n                w.endElement(); //li\n            }\n        }\n\n        addedUl = addUl( w, addedUl );\n        w.startElement( \"li\" );\n        w.writeMarkup( getString( mojoDescriptor.isThreadSafe()\n                ? \"pluginxdoc.mojodescriptor.threadSafe\"\n                : \"pluginxdoc.mojodescriptor.notThreadSafe\" ) );\n        w.endElement(); //li\n\n        value = mojoDescriptor.getSince();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( format( \"pluginxdoc.mojodescriptor.since\", value ) );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getPhase();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( format( \"pluginxdoc.mojodescriptor.phase\", value ) );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getExecutePhase();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( format( \"pluginxdoc.mojodescriptor.executePhase\", value ) );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getExecuteGoal();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( format( \"pluginxdoc.mojodescriptor.executeGoal\", value ) );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getExecuteLifecycle();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( format( \"pluginxdoc.mojodescriptor.executeLifecycle\", value ) );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isOnlineRequired() )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.onlineRequired\" ) );\n            w.endElement(); //li\n        }\n\n        if ( !mojoDescriptor.isInheritedByDefault() )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.inheritedByDefault\" ) );\n            w.endElement(); //li\n        }\n\n        if ( addedUl )\n        {\n            w.endElement(); //ul\n        }\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @param w              not null\n     */\n    private void writeGoalParameterTable( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        List<Parameter> parameterList = mojoDescriptor.getParameters();\n\n        // remove components and read-only parameters\n        List<Parameter> list = filterParameters( parameterList );\n\n        if ( !list.isEmpty() )\n        {\n            writeParameterSummary( list, w, mojoDescriptor.getGoal() );\n            writeParameterDetails( list, w, mojoDescriptor.getGoal() );\n        }\n        else\n        {\n            w.startElement( \"subsection\" );\n            w.addAttribute( \"name\", getString( \"pluginxdoc.mojodescriptor.parameters\" ) );\n\n            w.startElement( \"p\" );\n            w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.noParameter\" ) );\n            w.endElement(); //p\n\n            w.endElement();\n        }\n    }\n\n    /**\n     * Filter parameters to only retain those which must be documented, i.e. neither components nor readonly.\n     *\n     * @param parameterList not null\n     * @return the parameters list without components.\n     */\n    private List<Parameter> filterParameters( List<Parameter> parameterList )\n    {\n        List<Parameter> filtered = new ArrayList<>();\n\n        if ( parameterList != null )\n        {\n            for ( Parameter parameter : parameterList )\n            {\n                if ( parameter.isEditable() )\n                {\n                    String expression = parameter.getExpression();\n\n                    if ( expression == null || !expression.startsWith( \"${component.\" ) )\n                    {\n                        filtered.add( parameter );\n                    }\n                }\n            }\n        }\n\n        return filtered;\n    }\n\n    /**\n     * @param parameterList  not null\n     * @param w              not null\n     */\n    private void writeParameterDetails( List<Parameter> parameterList, XMLWriter w, String goal )\n    {\n        w.startElement( \"subsection\" );\n        w.addAttribute( \"name\", getString( \"pluginxdoc.mojodescriptor.parameter.details\" ) );\n\n        for ( Iterator<Parameter> parameters = parameterList.iterator(); parameters.hasNext(); )\n        {\n            Parameter parameter = parameters.next();\n\n            w.startElement( \"h4\" );\n            w.writeMarkup( format( \"pluginxdoc.mojodescriptor.parameter.name_internal\", parameter.getName() ) );\n            w.endElement();\n\n            String context = \"Parameter \" + parameter.getName() + \" in goal \" + goal;\n            if ( StringUtils.isNotEmpty( parameter.getDeprecated() ) )\n            {\n                w.startElement( \"div\" );\n                String deprecated = getXhtmlWithValidatedLinks( parameter.getDeprecated(), context );\n                w.writeMarkup( format( \"pluginxdoc.mojodescriptor.parameter.deprecated\", deprecated ) );\n                w.endElement(); // div\n            }\n\n            w.startElement( \"div\" );\n            if ( StringUtils.isNotEmpty( parameter.getDescription() ) )\n            {\n                \n                w.writeMarkup( getXhtmlWithValidatedLinks( parameter.getDescription(), context ) );\n            }\n            else\n            {\n                w.writeMarkup( getString( \"pluginxdoc.nodescription\" ) );\n            }\n            w.endElement(); // div\n\n            boolean addedUl = false;\n            addedUl = addUl( w, addedUl, parameter.getType() );\n            String typeValue = getLinkedType( parameter, false );\n            writeDetail( getString( \"pluginxdoc.mojodescriptor.parameter.type\" ), typeValue, w );\n\n            if ( StringUtils.isNotEmpty( parameter.getSince() ) )\n            {\n                addedUl = addUl( w, addedUl );\n                writeDetail( getString( \"pluginxdoc.mojodescriptor.parameter.since\" ), parameter.getSince(), w );\n            }\n\n            if ( parameter.isRequired() )\n            {\n                addedUl = addUl( w, addedUl );\n                writeDetail( getString( \"pluginxdoc.mojodescriptor.parameter.required\" ), getString( \"pluginxdoc.yes\" ),\n                             w );\n            }\n            else\n            {\n                addedUl = addUl( w, addedUl );\n                writeDetail( getString( \"pluginxdoc.mojodescriptor.parameter.required\" ), getString( \"pluginxdoc.no\" ),\n                             w );\n            }\n\n            String expression = parameter.getExpression();\n            addedUl = addUl( w, addedUl, expression );\n            String property = getPropertyFromExpression( expression );\n            if ( property == null )\n            {\n                writeDetail( getString( \"pluginxdoc.mojodescriptor.parameter.expression\" ), expression, w );\n            }\n            else\n            {\n                writeDetail( getString( \"pluginxdoc.mojodescriptor.parameter.property\" ), property, w );\n            }\n\n            addedUl = addUl( w, addedUl, parameter.getDefaultValue() );\n            writeDetail( getString( \"pluginxdoc.mojodescriptor.parameter.default\" ),\n                         escapeXml( parameter.getDefaultValue() ), w );\n\n            addedUl = addUl( w, addedUl, parameter.getAlias() );\n            writeDetail( getString( \"pluginxdoc.mojodescriptor.parameter.alias\" ), escapeXml( parameter.getAlias() ),\n                         w );\n\n            if ( addedUl )\n            {\n                w.endElement(); //ul\n            }\n\n            if ( parameters.hasNext() )\n            {\n                w.writeMarkup( \"<hr/>\" );\n            }\n        }\n\n        w.endElement();\n    }\n\n    static String getShortType( String type )\n    {\n        // split into type arguments and main type\n        int startTypeArguments = type.indexOf( '<' );\n        if ( startTypeArguments == -1 )\n        {\n            return getShortTypeOfSimpleType( type );\n        }\n        else\n        {\n            StringBuilder shortType = new StringBuilder();\n            shortType.append( getShortTypeOfSimpleType( type.substring( 0, startTypeArguments ) ) );\n            shortType.append( \"<\" )\n                .append( getShortTypeOfTypeArgument( \n                        type.substring( startTypeArguments + 1, type.lastIndexOf( \">\" ) ) ) )\n                .append( \">\" );\n            return shortType.toString();\n        }\n        \n    }\n\n    private static String getShortTypeOfTypeArgument( String type )\n    {\n        String[] typeArguments = type.split( \",\\\\s*\" );\n        StringBuilder shortType = new StringBuilder();\n        for ( int i = 0; i < typeArguments.length; i++ )\n        {\n            String typeArgument = typeArguments[i];\n            if ( typeArgument.contains( \"<\" ) )\n            {\n                // nested type arguments lead to ellipsis\n                return \"...\";\n            }\n            else\n            {\n                shortType.append( getShortTypeOfSimpleType( typeArgument ) );\n                if ( i < typeArguments.length - 1 )\n                {\n                    shortType.append( \",\" );\n                }\n            }\n        }\n        return shortType.toString();\n    }\n\n    private static String getShortTypeOfSimpleType( String type )\n    {\n        int index = type.lastIndexOf( '.' );\n        return type.substring( index + 1 );\n    }\n\n    private String getLinkedType( Parameter parameter, boolean isShortType  )\n    {\n        final String typeValue;\n        if ( isShortType )\n        {\n            typeValue = getShortType( parameter.getType() );\n        }\n        else\n        {\n            typeValue = parameter.getType();\n        }\n        if ( parameter instanceof EnhancedParameterWrapper )\n        {\n            EnhancedParameterWrapper enhancedParameter = (EnhancedParameterWrapper) parameter;\n            if ( enhancedParameter.getTypeJavadocUrl() != null )\n            {\n                URI javadocUrl = enhancedParameter.getTypeJavadocUrl();\n                // optionally check if link is valid\n                if ( javadocUrl.isAbsolute() \n                     || disableInternalJavadocLinkValidation \n                     || JavadocLinkGenerator.isLinkValid( javadocUrl, reportOutputDirectory.toPath() ) )\n                {\n                    return format( \"pluginxdoc.mojodescriptor.parameter.type_link\",\n                                   new Object[] { escapeXml( typeValue ), enhancedParameter.getTypeJavadocUrl() } );\n                }\n            }\n        }\n        return escapeXml( typeValue );\n    }\n\n    private boolean addUl( XMLWriter w, boolean addedUl, String content )\n    {\n        if ( StringUtils.isNotEmpty( content ) )\n        {\n            return addUl( w, addedUl );\n        }\n        return addedUl;\n    }\n\n    private boolean addUl( XMLWriter w, boolean addedUl )\n    {\n        if ( !addedUl )\n        {\n            w.startElement( \"ul\" );\n            addedUl = true;\n        }\n        return addedUl;\n    }\n\n    private String getPropertyFromExpression( String expression )\n    {\n        if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${\" ) && expression.endsWith( \"}\" )\n            && !expression.substring( 2 ).contains( \"${\" ) )\n        {\n            // expression=\"${xxx}\" -> property=\"xxx\"\n            return expression.substring( 2, expression.length() - 1 );\n        }\n        // no property can be extracted\n        return null;\n    }\n\n    /**\n     * @param param not null\n     * @param value could be null\n     * @param w     not null\n     */\n    private void writeDetail( String param, String value, XMLWriter w )\n    {\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( format( \"pluginxdoc.detail\", new String[]{ param, value } ) );\n            w.endElement(); //li\n        }\n    }\n\n    /**\n     * @param parameterList  not null\n     * @param w              not null\n     */\n    private void writeParameterSummary( List<Parameter> parameterList, XMLWriter w, String goal )\n    {\n        List<Parameter> requiredParams = getParametersByRequired( true, parameterList );\n        if ( !requiredParams.isEmpty() )\n        {\n            writeParameterList( getString( \"pluginxdoc.mojodescriptor.requiredParameters\" ),\n                                requiredParams, w, goal );\n        }\n\n        List<Parameter> optionalParams = getParametersByRequired( false, parameterList );\n        if ( !optionalParams.isEmpty() )\n        {\n            writeParameterList( getString( \"pluginxdoc.mojodescriptor.optionalParameters\" ),\n                                optionalParams, w, goal );\n        }\n    }\n\n    /**\n     * @param title          not null\n     * @param parameterList  not null\n     * @param w              not null\n     */\n    private void writeParameterList( String title, List<Parameter> parameterList, XMLWriter w, String goal )\n    {\n        w.startElement( \"subsection\" );\n        w.addAttribute( \"name\", title );\n\n        w.startElement( \"table\" );\n        w.addAttribute( \"border\", \"0\" );\n\n        w.startElement( \"tr\" );\n        w.startElement( \"th\" );\n        w.writeText( getString( \"pluginxdoc.mojodescriptor.parameter.name\" ) );\n        w.endElement(); //th\n        w.startElement( \"th\" );\n        w.writeText( getString( \"pluginxdoc.mojodescriptor.parameter.type\" ) );\n        w.endElement(); //th\n        w.startElement( \"th\" );\n        w.writeText( getString( \"pluginxdoc.mojodescriptor.parameter.since\" ) );\n        w.endElement(); //th\n        w.startElement( \"th\" );\n        w.writeText( getString( \"pluginxdoc.mojodescriptor.parameter.description\" ) );\n        w.endElement(); //th\n        w.endElement(); //tr\n\n        for ( Parameter parameter : parameterList )\n        {\n            w.startElement( \"tr\" );\n\n            // name\n            w.startElement( \"td\" );\n            w.writeMarkup( format( \"pluginxdoc.mojodescriptor.parameter.name_link\", parameter.getName() ) );\n            w.endElement(); //td\n\n            //type\n            w.startElement( \"td\" );\n            w.writeMarkup( \"<code>\" + getLinkedType( parameter, true ) + \"<\/code>\" );\n            w.endElement(); //td\n\n            // since\n            w.startElement( \"td\" );\n            if ( StringUtils.isNotEmpty( parameter.getSince() ) )\n            {\n                w.writeMarkup( \"<code>\" + parameter.getSince() + \"<\/code>\" );\n            }\n            else\n            {\n                w.writeMarkup( \"<code>-<\/code>\" );\n            }\n            w.endElement(); //td\n\n            // description\n            w.startElement( \"td\" );\n            String description;\n            String context = \"Parameter \" + parameter.getName() + \" in goal \" + goal;\n            if ( StringUtils.isNotEmpty( parameter.getDeprecated() ) )\n            {\n                String deprecated = getXhtmlWithValidatedLinks( parameter.getDescription(), context );\n                description = format( \"pluginxdoc.mojodescriptor.parameter.deprecated\", deprecated );\n            }\n            else if ( StringUtils.isNotEmpty( parameter.getDescription() ) )\n            {\n                description = getXhtmlWithValidatedLinks( parameter.getDescription(), context );\n            }\n            else\n            {\n                description = getString( \"pluginxdoc.nodescription\" );\n            }\n            w.writeMarkup( description + \"<br/>\" );\n\n            if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) )\n            {\n                w.writeMarkup( format( \"pluginxdoc.mojodescriptor.parameter.defaultValue\",\n                                       escapeXml( parameter.getDefaultValue() ) ) );\n                w.writeMarkup( \"<br/>\" );\n            }\n\n            String property = getPropertyFromExpression( parameter.getExpression() );\n            if ( property != null )\n            {\n                w.writeMarkup( format( \"pluginxdoc.mojodescriptor.parameter.property.description\", property ) );\n                w.writeMarkup( \"<br/>\" );\n            }\n\n            if ( StringUtils.isNotEmpty( parameter.getAlias() ) )\n            {\n                w.writeMarkup( format( \"pluginxdoc.mojodescriptor.parameter.alias.description\",\n                                       escapeXml( parameter.getAlias() ) ) );\n            }\n\n            w.endElement(); //td\n            w.endElement(); //tr\n        }\n\n        w.endElement(); //table\n        w.endElement(); //section\n    }\n\n    /**\n     * @param required      <code>true<\/code> for required parameters, <code>false<\/code> otherwise.\n     * @param parameterList not null\n     * @return list of parameters depending the value of <code>required<\/code>\n     */\n    private List<Parameter> getParametersByRequired( boolean required, List<Parameter> parameterList )\n    {\n        List<Parameter> list = new ArrayList<>();\n\n        for ( Parameter parameter : parameterList )\n        {\n            if ( parameter.isRequired() == required )\n            {\n                list.add( parameter );\n            }\n        }\n\n        return list;\n    }\n\n    /**\n     * Gets the resource bundle for the <code>locale<\/code> instance variable.\n     *\n     * @return The resource bundle for the <code>locale<\/code> instance variable.\n     */\n    private ResourceBundle getBundle()\n    {\n        return ResourceBundle.getBundle( \"pluginxdoc\", locale, getClass().getClassLoader() );\n    }\n\n    /**\n     * @param key not null\n     * @return Localized, text identified by <code>key<\/code>.\n     * @see #getBundle()\n     */\n    private String getString( String key )\n    {\n        return getBundle().getString( key );\n    }\n\n    /**\n     * Convenience method.\n     *\n     * @param key  not null\n     * @param arg1 not null\n     * @return Localized, formatted text identified by <code>key<\/code>.\n     * @see #format(String, Object[])\n     */\n    private String format( String key, Object arg1 )\n    {\n        return format( key, new Object[]{ arg1 } );\n    }\n\n    /**\n     * Looks up the value for <code>key<\/code> in the <code>ResourceBundle<\/code>,\n     * then formats that value for the specified <code>Locale<\/code> using <code>args<\/code>.\n     *\n     * @param key  not null\n     * @param args not null\n     * @return Localized, formatted text identified by <code>key<\/code>.\n     */\n    private String format( String key, Object[] args )\n    {\n        String pattern = getString( key );\n        // we don't need quoting so spare us the confusion in the resource bundle to double them up in some keys\n        pattern = StringUtils.replace( pattern, \"'\", \"''\" );\n\n        MessageFormat messageFormat = new MessageFormat( \"\" );\n        messageFormat.setLocale( locale );\n        messageFormat.applyPattern( pattern );\n\n        return messageFormat.format( args );\n    }\n\n    /**\n     * @param text the string to escape\n     * @return A string escaped with XML entities\n     */\n    private String escapeXml( String text )\n    {\n        if ( text != null )\n        {\n            text = text.replace( \"&\", \"&amp;\" );\n            text = text.replace( \"<\", \"&lt;\" );\n            text = text.replace( \">\", \"&gt;\" );\n            text = text.replace( \"\\\"\", \"&quot;\" );\n            text = text.replace( \"\\'\", \"&apos;\" );\n        }\n        return text;\n    }\n\n    String getXhtmlWithValidatedLinks( String xhtmlText, String context )\n    {\n        if ( disableInternalJavadocLinkValidation )\n        {\n            return xhtmlText;\n        }\n        StringBuffer sanitizedXhtmlText = new StringBuffer();\n        // find all links which are not absolute\n        Matcher matcher = HTML_LINK_PATTERN.matcher( xhtmlText );\n        while ( matcher.find() )\n        {\n            URI link;\n            try\n            {\n                link = new URI( matcher.group( 1 ) );\n                if ( !link.isAbsolute() && !JavadocLinkGenerator.isLinkValid( link, reportOutputDirectory.toPath() ) )\n                {\n                    matcher.appendReplacement( sanitizedXhtmlText, matcher.group( 2 ) );\n                    LOG.debug( \"Removed invalid link {} in {}\", link, context );\n                }\n                else\n                {\n                    matcher.appendReplacement( sanitizedXhtmlText, matcher.group( 0 ) );\n                }\n            }\n            catch ( URISyntaxException e )\n            {\n                LOG.warn( \"Invalid URI {} found in {}. Cannot validate, leave untouched\", matcher.group( 1 ), context );\n                matcher.appendReplacement( sanitizedXhtmlText, matcher.group( 0 ) );\n            }\n        }\n        matcher.appendTail( sanitizedXhtmlText );\n        return sanitizedXhtmlText.toString();\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.net.URI;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.EnhancedParameterWrapper;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.javadoc.JavadocLinkGenerator;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.io.CachingOutputStream;\nimport org.codehaus.plexus.util.xml.PrettyPrintXMLWriter;\nimport org.codehaus.plexus.util.xml.XMLWriter;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * Generate <a href=\"https://maven.apache.org/doxia/references/xdoc-format.html\">xdoc documentation<\/a> for each mojo.\n */\npublic class PluginXdocGenerator\n    implements Generator\n{\n    /**\n     * locale\n     */\n    private final Locale locale;\n\n    /**\n     * project\n     */\n    private final MavenProject project;\n\n    /**\n     * The directory where the generated site is written.\n     * Used for resolving relative links to javadoc.\n     */\n    private final File reportOutputDirectory;\n\n    /**\n     * Default constructor using <code>Locale.ENGLISH<\/code> as locale.\n     * Used only in test cases.\n     */\n    public PluginXdocGenerator()\n    {\n        this( null );\n    }\n\n    /**\n     * Constructor using <code>Locale.ENGLISH<\/code> as locale.\n     *\n     * @param project not null Maven project.\n     */\n    public PluginXdocGenerator( MavenProject project )\n    {\n        this( project, Locale.ENGLISH, new File( \"\" ).getAbsoluteFile() );\n    }\n\n    /**\n     * @param project not null.\n     * @param locale  not null wanted locale.\n     */\n    public PluginXdocGenerator( MavenProject project, Locale locale, File reportOutputDirectory )\n    {\n        this.project = project;\n        if ( locale == null )\n        {\n            this.locale = Locale.ENGLISH;\n        }\n        else\n        {\n            this.locale = locale;\n        }\n        this.reportOutputDirectory = reportOutputDirectory;\n    }\n\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws GeneratorException\n    {\n        try\n        {\n            if ( request.getPluginDescriptor().getMojos() != null )\n            {\n                List<MojoDescriptor> mojos = request.getPluginDescriptor().getMojos();\n                for ( MojoDescriptor descriptor : mojos )\n                {\n                    processMojoDescriptor( descriptor, destinationDirectory );\n                }\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n\n    }\n\n    /**\n     * @param mojoDescriptor       not null\n     * @param destinationDirectory not null\n     * @throws IOException if any\n     */\n    protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, File destinationDirectory )\n        throws IOException\n    {\n        File outputFile = new File( destinationDirectory, getMojoFilename( mojoDescriptor, \"xml\" ) );\n        try ( Writer writer = new OutputStreamWriter( new CachingOutputStream( outputFile ), UTF_8 ) )\n        {\n            XMLWriter w = new PrettyPrintXMLWriter( new PrintWriter( writer ), UTF_8.name(), null );\n            writeBody( mojoDescriptor, w );\n\n            writer.flush();\n        }\n    }\n\n    /**\n     * @param mojo not null\n     * @param ext  not null\n     * @return the output file name\n     */\n    private String getMojoFilename( MojoDescriptor mojo, String ext )\n    {\n        return mojo.getGoal() + \"-mojo.\" + ext;\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @param w              not null\n     */\n    private void writeBody( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"document\" );\n        w.addAttribute( \"xmlns\", \"http://maven.apache.org/XDOC/2.0\" );\n        w.addAttribute( \"xmlns:xsi\", \"http://www.w3.org/2001/XMLSchema-instance\" );\n        w.addAttribute( \"xsi:schemaLocation\",\n                        \"http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"properties\" );\n\n        w.startElement( \"title\" );\n        w.writeText( mojoDescriptor.getFullGoalName() );\n        w.endElement(); // title\n\n        w.endElement(); // properties\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"body\" );\n\n        w.startElement( \"section\" );\n\n        w.addAttribute( \"name\", mojoDescriptor.getFullGoalName() );\n\n        writeReportNotice( mojoDescriptor, w );\n\n        w.startElement( \"p\" );\n        w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.fullname\" ) );\n        w.endElement(); //p\n        w.startElement( \"p\" );\n        w.writeMarkup( mojoDescriptor.getPluginDescriptor().getGroupId() + \":\"\n                           + mojoDescriptor.getPluginDescriptor().getArtifactId() + \":\"\n                           + mojoDescriptor.getPluginDescriptor().getVersion() + \":\" + mojoDescriptor.getGoal() );\n        w.endElement(); //p\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getDeprecated() ) )\n        {\n            w.startElement( \"p\" );\n            w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.deprecated\" ) );\n            w.endElement(); // p\n            w.startElement( \"div\" );\n            w.writeMarkup( mojoDescriptor.getDeprecated() );\n            w.endElement(); // div\n        }\n\n        w.startElement( \"p\" );\n        w.writeMarkup( getString( \"pluginxdoc.description\" ) );\n        w.endElement(); //p\n        w.startElement( \"div\" );\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getDescription() ) )\n        {\n            w.writeMarkup( mojoDescriptor.getDescription() );\n        }\n        else\n        {\n            w.writeText( getString( \"pluginxdoc.nodescription\" ) );\n        }\n        w.endElement(); // div\n\n        writeGoalAttributes( mojoDescriptor, w );\n\n        writeGoalParameterTable( mojoDescriptor, w );\n\n        w.endElement(); // section\n\n        w.endElement(); // body\n\n        w.endElement(); // document\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @param w              not null\n     */\n    private void writeReportNotice( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        if ( GeneratorUtils.isMavenReport( mojoDescriptor.getImplementation(), project ) )\n        {\n            w.startElement( \"p\" );\n            w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.notice.note\" ) );\n            w.writeText( getString( \"pluginxdoc.mojodescriptor.notice.isMavenReport\" ) );\n            w.endElement(); //p\n        }\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @param w              not null\n     */\n    private void writeGoalAttributes( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"p\" );\n        w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.attributes\" ) );\n        w.endElement(); //p\n\n        boolean addedUl = false;\n        String value;\n        if ( mojoDescriptor.isProjectRequired() )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.projectRequired\" ) );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isRequiresReports() )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.reportingMojo\" ) );\n            w.endElement(); // li\n        }\n\n        if ( mojoDescriptor.isAggregator() )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.aggregator\" ) );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isDirectInvocationOnly() )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.directInvocationOnly\" ) );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.isDependencyResolutionRequired();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( format( \"pluginxdoc.mojodescriptor.dependencyResolutionRequired\", value ) );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor instanceof ExtendedMojoDescriptor )\n        {\n            ExtendedMojoDescriptor extendedMojoDescriptor = (ExtendedMojoDescriptor) mojoDescriptor;\n\n            value = extendedMojoDescriptor.getDependencyCollectionRequired();\n            if ( StringUtils.isNotEmpty( value ) )\n            {\n                addedUl = addUl( w, addedUl );\n                w.startElement( \"li\" );\n                w.writeMarkup( format( \"pluginxdoc.mojodescriptor.dependencyCollectionRequired\", value ) );\n                w.endElement(); //li\n            }\n        }\n\n        addedUl = addUl( w, addedUl );\n        w.startElement( \"li\" );\n        w.writeMarkup( getString( mojoDescriptor.isThreadSafe()\n                ? \"pluginxdoc.mojodescriptor.threadSafe\"\n                : \"pluginxdoc.mojodescriptor.notThreadSafe\" ) );\n        w.endElement(); //li\n\n        value = mojoDescriptor.getSince();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( format( \"pluginxdoc.mojodescriptor.since\", value ) );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getPhase();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( format( \"pluginxdoc.mojodescriptor.phase\", value ) );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getExecutePhase();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( format( \"pluginxdoc.mojodescriptor.executePhase\", value ) );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getExecuteGoal();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( format( \"pluginxdoc.mojodescriptor.executeGoal\", value ) );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getExecuteLifecycle();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( format( \"pluginxdoc.mojodescriptor.executeLifecycle\", value ) );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isOnlineRequired() )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.onlineRequired\" ) );\n            w.endElement(); //li\n        }\n\n        if ( !mojoDescriptor.isInheritedByDefault() )\n        {\n            addedUl = addUl( w, addedUl );\n            w.startElement( \"li\" );\n            w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.inheritedByDefault\" ) );\n            w.endElement(); //li\n        }\n\n        if ( addedUl )\n        {\n            w.endElement(); //ul\n        }\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @param w              not null\n     */\n    private void writeGoalParameterTable( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        List<Parameter> parameterList = mojoDescriptor.getParameters();\n\n        // remove components and read-only parameters\n        List<Parameter> list = filterParameters( parameterList );\n\n        if ( !list.isEmpty() )\n        {\n            writeParameterSummary( list, w );\n            writeParameterDetails( list, w );\n        }\n        else\n        {\n            w.startElement( \"subsection\" );\n            w.addAttribute( \"name\", getString( \"pluginxdoc.mojodescriptor.parameters\" ) );\n\n            w.startElement( \"p\" );\n            w.writeMarkup( getString( \"pluginxdoc.mojodescriptor.noParameter\" ) );\n            w.endElement(); //p\n\n            w.endElement();\n        }\n    }\n\n    /**\n     * Filter parameters to only retain those which must be documented, i.e. neither components nor readonly.\n     *\n     * @param parameterList not null\n     * @return the parameters list without components.\n     */\n    private List<Parameter> filterParameters( List<Parameter> parameterList )\n    {\n        List<Parameter> filtered = new ArrayList<>();\n\n        if ( parameterList != null )\n        {\n            for ( Parameter parameter : parameterList )\n            {\n                if ( parameter.isEditable() )\n                {\n                    String expression = parameter.getExpression();\n\n                    if ( expression == null || !expression.startsWith( \"${component.\" ) )\n                    {\n                        filtered.add( parameter );\n                    }\n                }\n            }\n        }\n\n        return filtered;\n    }\n\n    /**\n     * @param parameterList  not null\n     * @param w              not null\n     */\n    private void writeParameterDetails( List<Parameter> parameterList, XMLWriter w )\n    {\n        w.startElement( \"subsection\" );\n        w.addAttribute( \"name\", getString( \"pluginxdoc.mojodescriptor.parameter.details\" ) );\n\n        for ( Iterator<Parameter> parameters = parameterList.iterator(); parameters.hasNext(); )\n        {\n            Parameter parameter = parameters.next();\n\n            w.startElement( \"h4\" );\n            w.writeMarkup( format( \"pluginxdoc.mojodescriptor.parameter.name_internal\", parameter.getName() ) );\n            w.endElement();\n\n            if ( StringUtils.isNotEmpty( parameter.getDeprecated() ) )\n            {\n                w.startElement( \"div\" );\n                w.writeMarkup( format( \"pluginxdoc.mojodescriptor.parameter.deprecated\", parameter.getDeprecated() ) );\n                w.endElement(); // div\n            }\n\n            w.startElement( \"div\" );\n            if ( StringUtils.isNotEmpty( parameter.getDescription() ) )\n            {\n                w.writeMarkup( parameter.getDescription() );\n            }\n            else\n            {\n                w.writeMarkup( getString( \"pluginxdoc.nodescription\" ) );\n            }\n            w.endElement(); // div\n\n            boolean addedUl = false;\n            addedUl = addUl( w, addedUl, parameter.getType() );\n            String typeValue = getLinkedType( parameter, false );\n            writeDetail( getString( \"pluginxdoc.mojodescriptor.parameter.type\" ), typeValue, w );\n\n            if ( StringUtils.isNotEmpty( parameter.getSince() ) )\n            {\n                addedUl = addUl( w, addedUl );\n                writeDetail( getString( \"pluginxdoc.mojodescriptor.parameter.since\" ), parameter.getSince(), w );\n            }\n\n            if ( parameter.isRequired() )\n            {\n                addedUl = addUl( w, addedUl );\n                writeDetail( getString( \"pluginxdoc.mojodescriptor.parameter.required\" ), getString( \"pluginxdoc.yes\" ),\n                             w );\n            }\n            else\n            {\n                addedUl = addUl( w, addedUl );\n                writeDetail( getString( \"pluginxdoc.mojodescriptor.parameter.required\" ), getString( \"pluginxdoc.no\" ),\n                             w );\n            }\n\n            String expression = parameter.getExpression();\n            addedUl = addUl( w, addedUl, expression );\n            String property = getPropertyFromExpression( expression );\n            if ( property == null )\n            {\n                writeDetail( getString( \"pluginxdoc.mojodescriptor.parameter.expression\" ), expression, w );\n            }\n            else\n            {\n                writeDetail( getString( \"pluginxdoc.mojodescriptor.parameter.property\" ), property, w );\n            }\n\n            addedUl = addUl( w, addedUl, parameter.getDefaultValue() );\n            writeDetail( getString( \"pluginxdoc.mojodescriptor.parameter.default\" ),\n                         escapeXml( parameter.getDefaultValue() ), w );\n\n            addedUl = addUl( w, addedUl, parameter.getAlias() );\n            writeDetail( getString( \"pluginxdoc.mojodescriptor.parameter.alias\" ), escapeXml( parameter.getAlias() ),\n                         w );\n\n            if ( addedUl )\n            {\n                w.endElement(); //ul\n            }\n\n            if ( parameters.hasNext() )\n            {\n                w.writeMarkup( \"<hr/>\" );\n            }\n        }\n\n        w.endElement();\n    }\n\n    static String getShortType( String type )\n    {\n        // split into type arguments and main type\n        int startTypeArguments = type.indexOf( '<' );\n        if ( startTypeArguments == -1 )\n        {\n            return getShortTypeOfSimpleType( type );\n        }\n        else\n        {\n            StringBuilder shortType = new StringBuilder();\n            shortType.append( getShortTypeOfSimpleType( type.substring( 0, startTypeArguments ) ) );\n            shortType.append( \"<\" )\n                .append( getShortTypeOfTypeArgument( \n                        type.substring( startTypeArguments + 1, type.lastIndexOf( \">\" ) ) ) )\n                .append( \">\" );\n            return shortType.toString();\n        }\n        \n    }\n\n    private static String getShortTypeOfTypeArgument( String type )\n    {\n        String[] typeArguments = type.split( \",\\\\s*\" );\n        StringBuilder shortType = new StringBuilder();\n        for ( int i = 0; i < typeArguments.length; i++ )\n        {\n            String typeArgument = typeArguments[i];\n            if ( typeArgument.contains( \"<\" ) )\n            {\n                // nested type arguments lead to ellipsis\n                return \"...\";\n            }\n            else\n            {\n                shortType.append( getShortTypeOfSimpleType( typeArgument ) );\n                if ( i < typeArguments.length - 1 )\n                {\n                    shortType.append( \",\" );\n                }\n            }\n        }\n        return shortType.toString();\n    }\n\n    private static String getShortTypeOfSimpleType( String type )\n    {\n        int index = type.lastIndexOf( '.' );\n        return type.substring( index + 1 );\n    }\n\n    private String getLinkedType( Parameter parameter, boolean isShortType  )\n    {\n        final String typeValue;\n        if ( isShortType )\n        {\n            typeValue = getShortType( parameter.getType() );\n        }\n        else\n        {\n            typeValue = parameter.getType();\n        }\n        if ( parameter instanceof EnhancedParameterWrapper )\n        {\n            EnhancedParameterWrapper enhancedParameter = (EnhancedParameterWrapper) parameter;\n            if ( enhancedParameter.getTypeJavadocUrl() != null )\n            {\n                // check if link is valid\n                URI javadocUrl = enhancedParameter.getTypeJavadocUrl();\n                if ( javadocUrl.isAbsolute() \n                     || JavadocLinkGenerator.isLinkValid( javadocUrl, reportOutputDirectory.toPath() ) )\n                {\n                    return format( \"pluginxdoc.mojodescriptor.parameter.type_link\",\n                                   new Object[] { escapeXml( typeValue ), enhancedParameter.getTypeJavadocUrl() } );\n                }\n            }\n        }\n        return escapeXml( typeValue );\n    }\n\n    private boolean addUl( XMLWriter w, boolean addedUl, String content )\n    {\n        if ( StringUtils.isNotEmpty( content ) )\n        {\n            return addUl( w, addedUl );\n        }\n        return addedUl;\n    }\n\n    private boolean addUl( XMLWriter w, boolean addedUl )\n    {\n        if ( !addedUl )\n        {\n            w.startElement( \"ul\" );\n            addedUl = true;\n        }\n        return addedUl;\n    }\n\n    private String getPropertyFromExpression( String expression )\n    {\n        if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${\" ) && expression.endsWith( \"}\" )\n            && !expression.substring( 2 ).contains( \"${\" ) )\n        {\n            // expression=\"${xxx}\" -> property=\"xxx\"\n            return expression.substring( 2, expression.length() - 1 );\n        }\n        // no property can be extracted\n        return null;\n    }\n\n    /**\n     * @param param not null\n     * @param value could be null\n     * @param w     not null\n     */\n    private void writeDetail( String param, String value, XMLWriter w )\n    {\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( format( \"pluginxdoc.detail\", new String[]{ param, value } ) );\n            w.endElement(); //li\n        }\n    }\n\n    /**\n     * @param parameterList  not null\n     * @param w              not null\n     */\n    private void writeParameterSummary( List<Parameter> parameterList, XMLWriter w )\n    {\n        List<Parameter> requiredParams = getParametersByRequired( true, parameterList );\n        if ( !requiredParams.isEmpty() )\n        {\n            writeParameterList( getString( \"pluginxdoc.mojodescriptor.requiredParameters\" ),\n                                requiredParams, w );\n        }\n\n        List<Parameter> optionalParams = getParametersByRequired( false, parameterList );\n        if ( !optionalParams.isEmpty() )\n        {\n            writeParameterList( getString( \"pluginxdoc.mojodescriptor.optionalParameters\" ),\n                                optionalParams, w );\n        }\n    }\n\n    /**\n     * @param title          not null\n     * @param parameterList  not null\n     * @param w              not null\n     */\n    private void writeParameterList( String title, List<Parameter> parameterList, XMLWriter w )\n    {\n        w.startElement( \"subsection\" );\n        w.addAttribute( \"name\", title );\n\n        w.startElement( \"table\" );\n        w.addAttribute( \"border\", \"0\" );\n\n        w.startElement( \"tr\" );\n        w.startElement( \"th\" );\n        w.writeText( getString( \"pluginxdoc.mojodescriptor.parameter.name\" ) );\n        w.endElement(); //th\n        w.startElement( \"th\" );\n        w.writeText( getString( \"pluginxdoc.mojodescriptor.parameter.type\" ) );\n        w.endElement(); //th\n        w.startElement( \"th\" );\n        w.writeText( getString( \"pluginxdoc.mojodescriptor.parameter.since\" ) );\n        w.endElement(); //th\n        w.startElement( \"th\" );\n        w.writeText( getString( \"pluginxdoc.mojodescriptor.parameter.description\" ) );\n        w.endElement(); //th\n        w.endElement(); //tr\n\n        for ( Parameter parameter : parameterList )\n        {\n            w.startElement( \"tr\" );\n\n            // name\n            w.startElement( \"td\" );\n            w.writeMarkup( format( \"pluginxdoc.mojodescriptor.parameter.name_link\", parameter.getName() ) );\n            w.endElement(); //td\n\n            //type\n            w.startElement( \"td\" );\n            w.writeMarkup( \"<code>\" + getLinkedType( parameter, true ) + \"<\/code>\" );\n            w.endElement(); //td\n\n            // since\n            w.startElement( \"td\" );\n            if ( StringUtils.isNotEmpty( parameter.getSince() ) )\n            {\n                w.writeMarkup( \"<code>\" + parameter.getSince() + \"<\/code>\" );\n            }\n            else\n            {\n                w.writeMarkup( \"<code>-<\/code>\" );\n            }\n            w.endElement(); //td\n\n            // description\n            w.startElement( \"td\" );\n            String description;\n            if ( StringUtils.isNotEmpty( parameter.getDeprecated() ) )\n            {\n                description = format( \"pluginxdoc.mojodescriptor.parameter.deprecated\", parameter.getDeprecated() );\n            }\n            else if ( StringUtils.isNotEmpty( parameter.getDescription() ) )\n            {\n                description = parameter.getDescription();\n            }\n            else\n            {\n                description = getString( \"pluginxdoc.nodescription\" );\n            }\n            w.writeMarkup( description + \"<br/>\" );\n\n            if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) )\n            {\n                w.writeMarkup( format( \"pluginxdoc.mojodescriptor.parameter.defaultValue\",\n                                       escapeXml( parameter.getDefaultValue() ) ) );\n                w.writeMarkup( \"<br/>\" );\n            }\n\n            String property = getPropertyFromExpression( parameter.getExpression() );\n            if ( property != null )\n            {\n                w.writeMarkup( format( \"pluginxdoc.mojodescriptor.parameter.property.description\", property ) );\n                w.writeMarkup( \"<br/>\" );\n            }\n\n            if ( StringUtils.isNotEmpty( parameter.getAlias() ) )\n            {\n                w.writeMarkup( format( \"pluginxdoc.mojodescriptor.parameter.alias.description\",\n                                       escapeXml( parameter.getAlias() ) ) );\n            }\n\n            w.endElement(); //td\n            w.endElement(); //tr\n        }\n\n        w.endElement(); //table\n        w.endElement(); //section\n    }\n\n    /**\n     * @param required      <code>true<\/code> for required parameters, <code>false<\/code> otherwise.\n     * @param parameterList not null\n     * @return list of parameters depending the value of <code>required<\/code>\n     */\n    private List<Parameter> getParametersByRequired( boolean required, List<Parameter> parameterList )\n    {\n        List<Parameter> list = new ArrayList<>();\n\n        for ( Parameter parameter : parameterList )\n        {\n            if ( parameter.isRequired() == required )\n            {\n                list.add( parameter );\n            }\n        }\n\n        return list;\n    }\n\n    /**\n     * Gets the resource bundle for the <code>locale<\/code> instance variable.\n     *\n     * @return The resource bundle for the <code>locale<\/code> instance variable.\n     */\n    private ResourceBundle getBundle()\n    {\n        return ResourceBundle.getBundle( \"pluginxdoc\", locale, getClass().getClassLoader() );\n    }\n\n    /**\n     * @param key not null\n     * @return Localized, text identified by <code>key<\/code>.\n     * @see #getBundle()\n     */\n    private String getString( String key )\n    {\n        return getBundle().getString( key );\n    }\n\n    /**\n     * Convenience method.\n     *\n     * @param key  not null\n     * @param arg1 not null\n     * @return Localized, formatted text identified by <code>key<\/code>.\n     * @see #format(String, Object[])\n     */\n    private String format( String key, Object arg1 )\n    {\n        return format( key, new Object[]{ arg1 } );\n    }\n\n    /**\n     * Looks up the value for <code>key<\/code> in the <code>ResourceBundle<\/code>,\n     * then formats that value for the specified <code>Locale<\/code> using <code>args<\/code>.\n     *\n     * @param key  not null\n     * @param args not null\n     * @return Localized, formatted text identified by <code>key<\/code>.\n     */\n    private String format( String key, Object[] args )\n    {\n        String pattern = getString( key );\n        // we don't need quoting so spare us the confusion in the resource bundle to double them up in some keys\n        pattern = StringUtils.replace( pattern, \"'\", \"''\" );\n\n        MessageFormat messageFormat = new MessageFormat( \"\" );\n        messageFormat.setLocale( locale );\n        messageFormat.applyPattern( pattern );\n\n        return messageFormat.format( args );\n    }\n\n    /**\n     * @param text the string to escape\n     * @return A string escaped with XML entities\n     */\n    private String escapeXml( String text )\n    {\n        if ( text != null )\n        {\n            text = text.replace( \"&\", \"&amp;\" );\n            text = text.replace( \"<\", \"&lt;\" );\n            text = text.replace( \">\", \"&gt;\" );\n            text = text.replace( \"\\\"\", \"&quot;\" );\n            text = text.replace( \"\\'\", \"&apos;\" );\n        }\n        return text;\n    }\n\n}\n","lineNo":495}
{"Refactored Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.net.URI;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.javadoc.JavadocLinkGenerator;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.io.CachingOutputStream;\nimport org.codehaus.plexus.util.xml.PrettyPrintXMLWriter;\nimport org.codehaus.plexus.util.xml.XMLWriter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * Serializes\n * <ol>\n * <li>a standard <a href=\"/ref/current/maven-plugin-api/plugin.html\">Maven Plugin Descriptor XML file<\/a><\/li>\n * <li>a descriptor containing a limited set of attributes for {@link PluginHelpGenerator}<\/li>\n * <li>an enhanced descriptor containing HTML values for some elements (instead of plain text as for the other two)\n * for {@link PluginXdocGenerator}<\/li>\n * <\/ol>\n * from a given in-memory descriptor. The in-memory descriptor acting as source is supposed to contain XHTML values\n * for description elements.\n *\n */\npublic class PluginDescriptorFilesGenerator\n    implements Generator\n{\n    private static final Logger LOG = LoggerFactory.getLogger( PluginDescriptorFilesGenerator.class );\n\n    /**\n     * The type of the plugin descriptor file\n     */\n    enum DescriptorType\n    {\n        STANDARD,\n        LIMITED_FOR_HELP_MOJO,\n        XHTML\n    }\n\n    @Override\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws GeneratorException\n    {\n        try\n        {\n            // write standard plugin.xml descriptor\n            File f = new File( destinationDirectory, \"plugin.xml\" );\n            writeDescriptor( f, request, DescriptorType.STANDARD );\n\n            // write plugin-help.xml help-descriptor (containing only a limited set of attributes)\n            MavenProject mavenProject = request.getProject();\n            f = new File( destinationDirectory,\n                          PluginHelpGenerator.getPluginHelpPath( mavenProject ) );\n            writeDescriptor( f, request, DescriptorType.LIMITED_FOR_HELP_MOJO );\n\n            // write enhanced plugin-enhanced.xml descriptor (containing some XHTML values)\n            f = getEnhancedDescriptorFilePath( mavenProject );\n            writeDescriptor( f, request, DescriptorType.XHTML );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n    }\n\n    public static File getEnhancedDescriptorFilePath( MavenProject project )\n    {\n        return new File( project.getBuild().getDirectory(), \"plugin-enhanced.xml\" );\n    }\n\n    private String getVersion()\n    {\n        Package p = this.getClass().getPackage();\n        String version = ( p == null ) ? null : p.getSpecificationVersion();\n        return ( version == null ) ? \"SNAPSHOT\" : version;\n    }\n\n    public void writeDescriptor( File destinationFile, PluginToolsRequest request, DescriptorType type )\n        throws IOException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n\n        if ( !destinationFile.getParentFile().exists() )\n        {\n            destinationFile.getParentFile().mkdirs();\n        }\n\n        try ( Writer writer = new OutputStreamWriter( new CachingOutputStream( destinationFile ), UTF_8 ) )\n        {\n            XMLWriter w = new PrettyPrintXMLWriter( writer, UTF_8.name(), null );\n            \n            final String additionalInfo;\n            switch ( type )\n            {\n                case LIMITED_FOR_HELP_MOJO:\n                    additionalInfo = \" (for help'mojo with additional elements)\";\n                    break;\n                case XHTML:\n                    additionalInfo = \" (enhanced XHTML version with additional elements (used for plugin:report))\";\n                    break;\n                default:\n                    additionalInfo = \"\";\n                    break;\n            }\n            w.writeMarkup( \"\\n<!-- Generated by maven-plugin-tools \" + getVersion() \n                           + additionalInfo + \"-->\\n\\n\" );\n\n            w.startElement( \"plugin\" );\n\n            GeneratorUtils.element( w, \"name\", pluginDescriptor.getName() );\n\n            GeneratorUtils.element( w, \"description\", pluginDescriptor.getDescription() );\n\n            GeneratorUtils.element( w, \"groupId\", pluginDescriptor.getGroupId() );\n\n            GeneratorUtils.element( w, \"artifactId\", pluginDescriptor.getArtifactId() );\n\n            GeneratorUtils.element( w, \"version\", pluginDescriptor.getVersion() );\n\n            GeneratorUtils.element( w, \"goalPrefix\", pluginDescriptor.getGoalPrefix() );\n\n            if ( type != DescriptorType.LIMITED_FOR_HELP_MOJO )\n            {\n                GeneratorUtils.element( w, \"isolatedRealm\", String.valueOf( pluginDescriptor.isIsolatedRealm() ) );\n\n                GeneratorUtils.element( w, \"inheritedByDefault\",\n                                        String.valueOf( pluginDescriptor.isInheritedByDefault() ) );\n            }\n\n            w.startElement( \"mojos\" );\n\n            final JavadocLinkGenerator javadocLinkGenerator;\n            if ( request.getInternalJavadocBaseUrl() != null \n                 || ( request.getExternalJavadocBaseUrls() != null \n                      && !request.getExternalJavadocBaseUrls().isEmpty() ) )\n            {\n                javadocLinkGenerator =  new JavadocLinkGenerator( request.getInternalJavadocBaseUrl(),\n                                                                  request.getInternalJavadocVersion(),\n                                                                  request.getExternalJavadocBaseUrls(),\n                                                                  request.getSettings() );\n            }\n            else\n            {\n                javadocLinkGenerator = null;\n            }\n            if ( pluginDescriptor.getMojos() != null )\n            {\n                List<MojoDescriptor> descriptors = pluginDescriptor.getMojos();\n\n                PluginUtils.sortMojos( descriptors );\n\n                for ( MojoDescriptor descriptor : descriptors )\n                {\n                    processMojoDescriptor( descriptor, w, type, javadocLinkGenerator );\n                }\n            }\n\n            w.endElement();\n\n            if ( type != DescriptorType.LIMITED_FOR_HELP_MOJO )\n            {\n                GeneratorUtils.writeDependencies( w, pluginDescriptor );\n            }\n\n            w.endElement();\n\n            writer.flush();\n\n        }\n    }\n\n    /**\n     * \n     * @param type\n     * @param containsXhtmlValue\n     * @param text\n     * @return the normalized text value (i.e. potentially converted to XHTML)\n     */\n    private static String getTextValue( DescriptorType type, boolean containsXhtmlValue, String text )\n    {\n        final String xhtmlText;\n        if ( !containsXhtmlValue ) // text comes from legacy extractor\n        {\n            xhtmlText = GeneratorUtils.makeHtmlValid( text );\n        }\n        else\n        {\n            xhtmlText = text;\n        }\n        if ( type != DescriptorType.XHTML )\n        {\n            return new HtmlToPlainTextConverter().convert( text );\n        }\n        else\n        {\n            return xhtmlText;\n        }\n    }\n\n    @SuppressWarnings( \"deprecation\" )\n    protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, XMLWriter w, DescriptorType type,\n                                          JavadocLinkGenerator javadocLinkGenerator )\n    {\n        boolean containsXhtmlTextValues = mojoDescriptor instanceof ExtendedMojoDescriptor\n                        && ( (ExtendedMojoDescriptor) mojoDescriptor ).containsXhtmlTextValues();\n        \n        w.startElement( \"mojo\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"goal\" );\n        w.writeText( mojoDescriptor.getGoal() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        String description = mojoDescriptor.getDescription();\n\n        if ( StringUtils.isNotEmpty( description ) )\n        {\n            w.startElement( \"description\" );\n            w.writeText( getTextValue( type, containsXhtmlTextValues, mojoDescriptor.getDescription() ) );\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.isDependencyResolutionRequired() ) )\n        {\n            GeneratorUtils.element( w, \"requiresDependencyResolution\",\n                                    mojoDescriptor.isDependencyResolutionRequired() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"requiresDirectInvocation\",\n                                String.valueOf( mojoDescriptor.isDirectInvocationOnly() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"requiresProject\", String.valueOf( mojoDescriptor.isProjectRequired() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"requiresReports\", String.valueOf( mojoDescriptor.isRequiresReports() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"aggregator\", String.valueOf( mojoDescriptor.isAggregator() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"requiresOnline\", String.valueOf( mojoDescriptor.isOnlineRequired() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"inheritedByDefault\", String.valueOf( mojoDescriptor.isInheritedByDefault() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getPhase() ) )\n        {\n            GeneratorUtils.element( w, \"phase\", mojoDescriptor.getPhase() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getExecutePhase() ) )\n        {\n            GeneratorUtils.element( w, \"executePhase\", mojoDescriptor.getExecutePhase() );\n        }\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getExecuteGoal() ) )\n        {\n            GeneratorUtils.element( w, \"executeGoal\", mojoDescriptor.getExecuteGoal() );\n        }\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getExecuteLifecycle() ) )\n        {\n            GeneratorUtils.element( w, \"executeLifecycle\", mojoDescriptor.getExecuteLifecycle() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"implementation\" );\n        w.writeText( mojoDescriptor.getImplementation() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"language\" );\n        w.writeText( mojoDescriptor.getLanguage() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getComponentConfigurator() ) )\n        {\n            w.startElement( \"configurator\" );\n            w.writeText( mojoDescriptor.getComponentConfigurator() );\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getComponentComposer() ) )\n        {\n            w.startElement( \"composer\" );\n            w.writeText( mojoDescriptor.getComponentComposer() );\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"instantiationStrategy\" );\n        w.writeText( mojoDescriptor.getInstantiationStrategy() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Strategy for handling repeated reference to mojo in\n        // the calculated (decorated, resolved) execution stack\n        // ----------------------------------------------------------------------\n        w.startElement( \"executionStrategy\" );\n        w.writeText( mojoDescriptor.getExecutionStrategy() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getSince() != null )\n        {\n            w.startElement( \"since\" );\n\n            if ( StringUtils.isEmpty( mojoDescriptor.getSince() ) )\n            {\n                w.writeText( \"No version given\" );\n            }\n            else\n            {\n                w.writeText( mojoDescriptor.getSince() );\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getDeprecated() != null )\n        {\n            w.startElement( \"deprecated\" );\n\n            if ( StringUtils.isEmpty( mojoDescriptor.getDeprecated() ) )\n            {\n                w.writeText( \"No reason given\" );\n            }\n            else\n            {\n                w.writeText( getTextValue( type, containsXhtmlTextValues, mojoDescriptor.getDeprecated() ) );\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Extended (3.0) descriptor\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor instanceof ExtendedMojoDescriptor )\n        {\n            ExtendedMojoDescriptor extendedMojoDescriptor = (ExtendedMojoDescriptor) mojoDescriptor;\n            if ( extendedMojoDescriptor.getDependencyCollectionRequired() != null )\n            {\n                GeneratorUtils.element( w, \"requiresDependencyCollection\",\n                                        extendedMojoDescriptor.getDependencyCollectionRequired() );\n            }\n\n            GeneratorUtils.element( w, \"threadSafe\", String.valueOf( extendedMojoDescriptor.isThreadSafe() ) );\n        }\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        List<Parameter> parameters = mojoDescriptor.getParameters();\n\n        w.startElement( \"parameters\" );\n\n        Map<String, Requirement> requirements = new LinkedHashMap<>();\n\n        Set<Parameter> configuration = new LinkedHashSet<>();\n\n        if ( parameters != null )\n        {\n            if ( type == DescriptorType.LIMITED_FOR_HELP_MOJO )\n            {\n                PluginUtils.sortMojoParameters( parameters );\n            }\n\n            for ( Parameter parameter : parameters )\n            {\n                String expression = getExpression( parameter );\n\n                if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${component.\" ) )\n                {\n                    // treat it as a component...a requirement, in other words.\n\n                    // remove \"component.\" plus expression delimiters\n                    String role = expression.substring( \"${component.\".length(), expression.length() - 1 );\n\n                    String roleHint = null;\n\n                    int posRoleHintSeparator = role.indexOf( '#' );\n                    if ( posRoleHintSeparator > 0 )\n                    {\n                        roleHint = role.substring( posRoleHintSeparator + 1 );\n\n                        role = role.substring( 0, posRoleHintSeparator );\n                    }\n\n                    // TODO: remove deprecated expression\n                    requirements.put( parameter.getName(), new Requirement( role, roleHint ) );\n                }\n                else if ( parameter.getRequirement() != null )\n                {\n                    requirements.put( parameter.getName(), parameter.getRequirement() );\n                }\n                // don't show readonly parameters in help\n                else if ( type != DescriptorType.LIMITED_FOR_HELP_MOJO || parameter.isEditable() )\n                {\n                    // treat it as a normal parameter.\n\n                    w.startElement( \"parameter\" );\n\n                    GeneratorUtils.element( w, \"name\", parameter.getName() );\n\n                    if ( parameter.getAlias() != null )\n                    {\n                        GeneratorUtils.element( w, \"alias\", parameter.getAlias() );\n                    }\n\n                    writeParameterType( w, type, javadocLinkGenerator, parameter, mojoDescriptor.getGoal() );\n\n                    if ( parameter.getSince() != null )\n                    {\n                        w.startElement( \"since\" );\n\n                        if ( StringUtils.isEmpty( parameter.getSince() ) )\n                        {\n                            w.writeText( \"No version given\" );\n                        }\n                        else\n                        {\n                            w.writeText( parameter.getSince() );\n                        }\n\n                        w.endElement();\n                    }\n\n                    if ( parameter.getDeprecated() != null )\n                    {\n                        if ( StringUtils.isEmpty( parameter.getDeprecated() ) )\n                        {\n                            GeneratorUtils.element( w, \"deprecated\", \"No reason given\" );\n                        }\n                        else\n                        {\n                            GeneratorUtils.element( w, \"deprecated\", \n                                                    getTextValue( type, containsXhtmlTextValues,\n                                                                  parameter.getDeprecated() ) );\n                        }\n                    }\n\n                    if ( parameter.getImplementation() != null )\n                    {\n                        GeneratorUtils.element( w, \"implementation\", parameter.getImplementation() );\n                    }\n\n                    GeneratorUtils.element( w, \"required\", Boolean.toString( parameter.isRequired() ) );\n\n                    GeneratorUtils.element( w, \"editable\", Boolean.toString( parameter.isEditable() ) );\n\n                    GeneratorUtils.element( w, \"description\", getTextValue( type, containsXhtmlTextValues,\n                                                                            parameter.getDescription() ) );\n\n                    if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) || StringUtils.isNotEmpty(\n                        parameter.getExpression() ) )\n                    {\n                        configuration.add( parameter );\n                    }\n\n                    w.endElement();\n                }\n\n            }\n        }\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Configuration\n        // ----------------------------------------------------------------------\n\n        if ( !configuration.isEmpty() )\n        {\n            w.startElement( \"configuration\" );\n\n            for ( Parameter parameter : configuration )\n            {\n                if ( type == DescriptorType.LIMITED_FOR_HELP_MOJO && !parameter.isEditable() )\n                {\n                    // don't show readonly parameters in help\n                    continue;\n                }\n\n                w.startElement( parameter.getName() );\n\n                String parameterType = parameter.getType();\n                if ( StringUtils.isNotEmpty( parameterType ) )\n                {\n                    w.addAttribute( \"implementation\", parameterType );\n                }\n\n                if ( parameter.getDefaultValue() != null )\n                {\n                    w.addAttribute( \"default-value\", parameter.getDefaultValue() );\n                }\n\n                if ( StringUtils.isNotEmpty( parameter.getExpression() ) )\n                {\n                    w.writeText( parameter.getExpression() );\n                }\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        if ( !requirements.isEmpty() && type != DescriptorType.LIMITED_FOR_HELP_MOJO )\n        {\n            w.startElement( \"requirements\" );\n\n            for ( Map.Entry<String, Requirement> entry : requirements.entrySet() )\n            {\n                String key = entry.getKey();\n                Requirement requirement = entry.getValue();\n\n                w.startElement( \"requirement\" );\n\n                GeneratorUtils.element( w, \"role\", requirement.getRole() );\n\n                if ( StringUtils.isNotEmpty( requirement.getRoleHint() ) )\n                {\n                    GeneratorUtils.element( w, \"role-hint\", requirement.getRoleHint() );\n                }\n\n                GeneratorUtils.element( w, \"field-name\", key );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        w.endElement();\n    }\n\n    /**\n     * Writes parameter type information and potentially also the related javadoc URL.\n     * @param w\n     * @param type\n     * @param javadocLinkGenerator\n     * @param parameter\n     * @param goal\n     */\n    protected void writeParameterType( XMLWriter w, DescriptorType type, JavadocLinkGenerator javadocLinkGenerator,\n                                       Parameter parameter, String goal )\n    {\n        String parameterType = parameter.getType();\n        \n        if ( type == DescriptorType.STANDARD )\n        {\n            // strip type by parameter type (generics) information for standard plugin descriptor\n            parameterType = StringUtils.chomp( parameterType, \"<\" );\n        }\n        GeneratorUtils.element( w, \"type\", parameterType );\n\n        if ( type == DescriptorType.XHTML && javadocLinkGenerator != null )\n        {\n            // skip primitives which never has javadoc\n            if ( parameter.getType().indexOf( '.' ) == -1 )\n            {\n                LOG.debug( \"Javadoc URLs are not available for primitive types like {}\",\n                           parameter.getType() );\n            }\n            else\n            {\n                try\n                {\n                    URI javadocUrl = getJavadocUrlForType( javadocLinkGenerator, parameterType );\n                    GeneratorUtils.element( w, \"typeJavadocUrl\", javadocUrl.toString() );\n                } \n                catch ( IllegalArgumentException e )\n                {\n                    LOG.warn( \"Could not get javadoc URL for type {} of parameter {} from goal {}: {}\",\n                              parameter.getType(), parameter.getName(), goal,\n                              e.getMessage() );\n                }\n            }\n        }\n    }\n\n    static URI getJavadocUrlForType( JavadocLinkGenerator javadocLinkGenerator, String type )\n    {\n        final String binaryName;\n        int startOfParameterType = type.indexOf( \"<\" );\n        if ( startOfParameterType != -1 )\n        {\n            // parse parameter type\n            String mainType = type.substring( 0, startOfParameterType );\n            \n            // some heuristics here\n            String[] parameterTypes = type.substring( startOfParameterType + 1, type.lastIndexOf( \">\" ) )\n                            .split( \",\\\\s*\" );\n            switch ( parameterTypes.length )\n            {\n                case 1: // if only one parameter type, assume collection, first parameter type is most interesting\n                    binaryName = parameterTypes[0];\n                    break;\n                case 2: // if two parameter types assume map, second parameter type is most interesting\n                    binaryName = parameterTypes[1];\n                    break;\n                default:\n                    // all other cases link to main type\n                    binaryName = mainType;\n            }\n        }\n        else\n        {\n            binaryName = type;\n        }\n        return javadocLinkGenerator.createLink( binaryName );\n    }\n\n    /**\n     * Get the expression value, eventually surrounding it with <code>${ }<\/code>.\n     *\n     * @param parameter the parameter\n     * @return the expression value\n     */\n    private String getExpression( Parameter parameter )\n    {\n        String expression = parameter.getExpression();\n        if ( StringUtils.isNotBlank( expression ) && !expression.contains( \"${\" ) )\n        {\n            expression = \"${\" + expression.trim() + \"}\";\n            parameter.setExpression( expression );\n        }\n        return expression;\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.net.URI;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.javadoc.JavadocLinkGenerator;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.io.CachingOutputStream;\nimport org.codehaus.plexus.util.xml.PrettyPrintXMLWriter;\nimport org.codehaus.plexus.util.xml.XMLWriter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * Serializes\n * <ol>\n * <li>a standard <a href=\"/ref/current/maven-plugin-api/plugin.html\">Maven Plugin Descriptor XML file<\/a><\/li>\n * <li>a descriptor containing a limited set of attributes for {@link PluginHelpGenerator}<\/li>\n * <li>an enhanced descriptor containing HTML values for some elements (instead of plain text as for the other two)\n * for {@link PluginXdocGenerator}<\/li>\n * <\/ol>\n * from a given in-memory descriptor. The in-memory descriptor acting as source is supposed to contain XHTML values\n * for description elements.\n *\n */\npublic class PluginDescriptorFilesGenerator\n    implements Generator\n{\n    private static final Logger LOG = LoggerFactory.getLogger( PluginDescriptorFilesGenerator.class );\n\n    /**\n     * The type of the plugin descriptor file\n     */\n    enum DescriptorType\n    {\n        STANDARD,\n        LIMITED_FOR_HELP_MOJO,\n        XHTML\n    }\n\n    @Override\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws GeneratorException\n    {\n        try\n        {\n            // write standard plugin.xml descriptor\n            File f = new File( destinationDirectory, \"plugin.xml\" );\n            writeDescriptor( f, request, DescriptorType.STANDARD );\n\n            // write plugin-help.xml help-descriptor (containing only a limited set of attributes)\n            MavenProject mavenProject = request.getProject();\n            f = new File( destinationDirectory,\n                          PluginHelpGenerator.getPluginHelpPath( mavenProject ) );\n            writeDescriptor( f, request, DescriptorType.LIMITED_FOR_HELP_MOJO );\n\n            // write enhanced plugin-enhanced.xml descriptor (containing some XHTML values)\n            f = getEnhancedDescriptorFilePath( mavenProject );\n            writeDescriptor( f, request, DescriptorType.XHTML );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n    }\n\n    public static File getEnhancedDescriptorFilePath( MavenProject project )\n    {\n        return new File( project.getBuild().getDirectory(), \"plugin-enhanced.xml\" );\n    }\n\n    private String getVersion()\n    {\n        Package p = this.getClass().getPackage();\n        String version = ( p == null ) ? null : p.getSpecificationVersion();\n        return ( version == null ) ? \"SNAPSHOT\" : version;\n    }\n\n    public void writeDescriptor( File destinationFile, PluginToolsRequest request, DescriptorType type )\n        throws IOException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n\n        if ( !destinationFile.getParentFile().exists() )\n        {\n            destinationFile.getParentFile().mkdirs();\n        }\n\n        try ( Writer writer = new OutputStreamWriter( new CachingOutputStream( destinationFile ), UTF_8 ) )\n        {\n            XMLWriter w = new PrettyPrintXMLWriter( writer, UTF_8.name(), null );\n            \n            final String additionalInfo;\n            switch ( type )\n            {\n                case LIMITED_FOR_HELP_MOJO:\n                    additionalInfo = \" (for help'mojo with additional elements)\";\n                    break;\n                case XHTML:\n                    additionalInfo = \" (enhanced XHTML version with additional elements (used for plugin:report))\";\n                    break;\n                default:\n                    additionalInfo = \"\";\n                    break;\n            }\n            w.writeMarkup( \"\\n<!-- Generated by maven-plugin-tools \" + getVersion() \n                           + additionalInfo + \"-->\\n\\n\" );\n\n            w.startElement( \"plugin\" );\n\n            GeneratorUtils.element( w, \"name\", pluginDescriptor.getName() );\n\n            GeneratorUtils.element( w, \"description\", pluginDescriptor.getDescription() );\n\n            GeneratorUtils.element( w, \"groupId\", pluginDescriptor.getGroupId() );\n\n            GeneratorUtils.element( w, \"artifactId\", pluginDescriptor.getArtifactId() );\n\n            GeneratorUtils.element( w, \"version\", pluginDescriptor.getVersion() );\n\n            GeneratorUtils.element( w, \"goalPrefix\", pluginDescriptor.getGoalPrefix() );\n\n            if ( type != DescriptorType.LIMITED_FOR_HELP_MOJO )\n            {\n                GeneratorUtils.element( w, \"isolatedRealm\", String.valueOf( pluginDescriptor.isIsolatedRealm() ) );\n\n                GeneratorUtils.element( w, \"inheritedByDefault\",\n                                        String.valueOf( pluginDescriptor.isInheritedByDefault() ) );\n            }\n\n            w.startElement( \"mojos\" );\n\n            final JavadocLinkGenerator javadocLinkGenerator;\n            if ( request.getInternalJavadocBaseUrl() != null \n                 || ( request.getExternalJavadocBaseUrls() != null \n                      && !request.getExternalJavadocBaseUrls().isEmpty() ) )\n            {\n                javadocLinkGenerator =  new JavadocLinkGenerator( request.getInternalJavadocBaseUrl(),\n                                                                  request.getInternalJavadocVersion(),\n                                                                  request.getExternalJavadocBaseUrls(),\n                                                                  request.getSettings() );\n            }\n            else\n            {\n                javadocLinkGenerator = null;\n            }\n            if ( pluginDescriptor.getMojos() != null )\n            {\n                List<MojoDescriptor> descriptors = pluginDescriptor.getMojos();\n\n                PluginUtils.sortMojos( descriptors );\n\n                for ( MojoDescriptor descriptor : descriptors )\n                {\n                    processMojoDescriptor( descriptor, w, type, javadocLinkGenerator );\n                }\n            }\n\n            w.endElement();\n\n            if ( type != DescriptorType.LIMITED_FOR_HELP_MOJO )\n            {\n                GeneratorUtils.writeDependencies( w, pluginDescriptor );\n            }\n\n            w.endElement();\n\n            writer.flush();\n\n        }\n    }\n\n    /**\n     * \n     * @param type\n     * @param containsXhtmlValue\n     * @param text\n     * @return the normalized text value (i.e. potentially converted to XHTML)\n     */\n    private static String getTextValue( DescriptorType type, boolean containsXhtmlValue, String text )\n    {\n        final String xhtmlText;\n        if ( !containsXhtmlValue ) // text comes from legacy extractor\n        {\n            xhtmlText = GeneratorUtils.makeHtmlValid( text );\n        }\n        else\n        {\n            xhtmlText = text;\n        }\n        if ( type != DescriptorType.XHTML )\n        {\n            return new HtmlToPlainTextConverter().convert( text );\n        }\n        else\n        {\n            return xhtmlText;\n        }\n    }\n\n    @SuppressWarnings( \"deprecation\" )\n    protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, XMLWriter w, DescriptorType type,\n                                          JavadocLinkGenerator javadocLinkGenerator )\n    {\n        boolean containsXhtmlTextValues = mojoDescriptor instanceof ExtendedMojoDescriptor\n                        && ( (ExtendedMojoDescriptor) mojoDescriptor ).containsXhtmlTextValues();\n        \n        w.startElement( \"mojo\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"goal\" );\n        w.writeText( mojoDescriptor.getGoal() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        String description = mojoDescriptor.getDescription();\n\n        if ( StringUtils.isNotEmpty( description ) )\n        {\n            w.startElement( \"description\" );\n            w.writeText( getTextValue( type, containsXhtmlTextValues, mojoDescriptor.getDescription() ) );\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.isDependencyResolutionRequired() ) )\n        {\n            GeneratorUtils.element( w, \"requiresDependencyResolution\",\n                                    mojoDescriptor.isDependencyResolutionRequired() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"requiresDirectInvocation\",\n                                String.valueOf( mojoDescriptor.isDirectInvocationOnly() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"requiresProject\", String.valueOf( mojoDescriptor.isProjectRequired() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"requiresReports\", String.valueOf( mojoDescriptor.isRequiresReports() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"aggregator\", String.valueOf( mojoDescriptor.isAggregator() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"requiresOnline\", String.valueOf( mojoDescriptor.isOnlineRequired() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"inheritedByDefault\", String.valueOf( mojoDescriptor.isInheritedByDefault() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getPhase() ) )\n        {\n            GeneratorUtils.element( w, \"phase\", mojoDescriptor.getPhase() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getExecutePhase() ) )\n        {\n            GeneratorUtils.element( w, \"executePhase\", mojoDescriptor.getExecutePhase() );\n        }\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getExecuteGoal() ) )\n        {\n            GeneratorUtils.element( w, \"executeGoal\", mojoDescriptor.getExecuteGoal() );\n        }\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getExecuteLifecycle() ) )\n        {\n            GeneratorUtils.element( w, \"executeLifecycle\", mojoDescriptor.getExecuteLifecycle() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"implementation\" );\n        w.writeText( mojoDescriptor.getImplementation() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"language\" );\n        w.writeText( mojoDescriptor.getLanguage() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getComponentConfigurator() ) )\n        {\n            w.startElement( \"configurator\" );\n            w.writeText( mojoDescriptor.getComponentConfigurator() );\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getComponentComposer() ) )\n        {\n            w.startElement( \"composer\" );\n            w.writeText( mojoDescriptor.getComponentComposer() );\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"instantiationStrategy\" );\n        w.writeText( mojoDescriptor.getInstantiationStrategy() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Strategy for handling repeated reference to mojo in\n        // the calculated (decorated, resolved) execution stack\n        // ----------------------------------------------------------------------\n        w.startElement( \"executionStrategy\" );\n        w.writeText( mojoDescriptor.getExecutionStrategy() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getSince() != null )\n        {\n            w.startElement( \"since\" );\n\n            if ( StringUtils.isEmpty( mojoDescriptor.getSince() ) )\n            {\n                w.writeText( \"No version given\" );\n            }\n            else\n            {\n                w.writeText( mojoDescriptor.getSince() );\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getDeprecated() != null )\n        {\n            w.startElement( \"deprecated\" );\n\n            if ( StringUtils.isEmpty( mojoDescriptor.getDeprecated() ) )\n            {\n                w.writeText( \"No reason given\" );\n            }\n            else\n            {\n                w.writeText( getTextValue( type, containsXhtmlTextValues, mojoDescriptor.getDeprecated() ) );\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Extended (3.0) descriptor\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor instanceof ExtendedMojoDescriptor )\n        {\n            ExtendedMojoDescriptor extendedMojoDescriptor = (ExtendedMojoDescriptor) mojoDescriptor;\n            if ( extendedMojoDescriptor.getDependencyCollectionRequired() != null )\n            {\n                GeneratorUtils.element( w, \"requiresDependencyCollection\",\n                                        extendedMojoDescriptor.getDependencyCollectionRequired() );\n            }\n\n            GeneratorUtils.element( w, \"threadSafe\", String.valueOf( extendedMojoDescriptor.isThreadSafe() ) );\n        }\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        List<Parameter> parameters = mojoDescriptor.getParameters();\n\n        w.startElement( \"parameters\" );\n\n        Map<String, Requirement> requirements = new LinkedHashMap<>();\n\n        Set<Parameter> configuration = new LinkedHashSet<>();\n\n        if ( parameters != null )\n        {\n            if ( type == DescriptorType.LIMITED_FOR_HELP_MOJO )\n            {\n                PluginUtils.sortMojoParameters( parameters );\n            }\n\n            for ( Parameter parameter : parameters )\n            {\n                String expression = getExpression( parameter );\n\n                if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${component.\" ) )\n                {\n                    // treat it as a component...a requirement, in other words.\n\n                    // remove \"component.\" plus expression delimiters\n                    String role = expression.substring( \"${component.\".length(), expression.length() - 1 );\n\n                    String roleHint = null;\n\n                    int posRoleHintSeparator = role.indexOf( '#' );\n                    if ( posRoleHintSeparator > 0 )\n                    {\n                        roleHint = role.substring( posRoleHintSeparator + 1 );\n\n                        role = role.substring( 0, posRoleHintSeparator );\n                    }\n\n                    // TODO: remove deprecated expression\n                    requirements.put( parameter.getName(), new Requirement( role, roleHint ) );\n                }\n                else if ( parameter.getRequirement() != null )\n                {\n                    requirements.put( parameter.getName(), parameter.getRequirement() );\n                }\n                // don't show readonly parameters in help\n                else if ( type != DescriptorType.LIMITED_FOR_HELP_MOJO || parameter.isEditable() )\n                {\n                    // treat it as a normal parameter.\n\n                    w.startElement( \"parameter\" );\n\n                    GeneratorUtils.element( w, \"name\", parameter.getName() );\n\n                    if ( parameter.getAlias() != null )\n                    {\n                        GeneratorUtils.element( w, \"alias\", parameter.getAlias() );\n                    }\n\n                    GeneratorUtils.element( w, \"type\", parameter.getType() );\n\n                    if ( type == DescriptorType.XHTML && javadocLinkGenerator != null )\n                    {\n                        // skip primitives which never has javadoc\n                        if ( parameter.getType().indexOf( '.' ) == -1 )\n                        {\n                            LOG.debug( \"Javadoc URLs are not available for primitive types like {}\",\n                                       parameter.getType() );\n                        }\n                        else\n                        {\n                            try\n                            {\n                                URI uri = javadocLinkGenerator.createLink( parameter.getType() );\n                                GeneratorUtils.element( w, \"typeJavadocUrl\", uri.toString() );\n                            } \n                            catch ( IllegalArgumentException e )\n                            {\n                                LOG.warn( \"Could not get javadoc URL for type {} of parameter {} from goal {}: {}\",\n                                          parameter.getType(), parameter.getName(), mojoDescriptor.getGoal(),\n                                          e.getMessage() );\n                            }\n                        }\n                    }\n                    if ( parameter.getSince() != null )\n                    {\n                        w.startElement( \"since\" );\n\n                        if ( StringUtils.isEmpty( parameter.getSince() ) )\n                        {\n                            w.writeText( \"No version given\" );\n                        }\n                        else\n                        {\n                            w.writeText( parameter.getSince() );\n                        }\n\n                        w.endElement();\n                    }\n\n                    if ( parameter.getDeprecated() != null )\n                    {\n                        if ( StringUtils.isEmpty( parameter.getDeprecated() ) )\n                        {\n                            GeneratorUtils.element( w, \"deprecated\", \"No reason given\" );\n                        }\n                        else\n                        {\n                            GeneratorUtils.element( w, \"deprecated\", \n                                                    getTextValue( type, containsXhtmlTextValues,\n                                                                  parameter.getDeprecated() ) );\n                        }\n                    }\n\n                    if ( parameter.getImplementation() != null )\n                    {\n                        GeneratorUtils.element( w, \"implementation\", parameter.getImplementation() );\n                    }\n\n                    GeneratorUtils.element( w, \"required\", Boolean.toString( parameter.isRequired() ) );\n\n                    GeneratorUtils.element( w, \"editable\", Boolean.toString( parameter.isEditable() ) );\n\n                    GeneratorUtils.element( w, \"description\", getTextValue( type, containsXhtmlTextValues,\n                                                                            parameter.getDescription() ) );\n\n                    if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) || StringUtils.isNotEmpty(\n                        parameter.getExpression() ) )\n                    {\n                        configuration.add( parameter );\n                    }\n\n                    w.endElement();\n                }\n\n            }\n        }\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Configuration\n        // ----------------------------------------------------------------------\n\n        if ( !configuration.isEmpty() )\n        {\n            w.startElement( \"configuration\" );\n\n            for ( Parameter parameter : configuration )\n            {\n                if ( type == DescriptorType.LIMITED_FOR_HELP_MOJO && !parameter.isEditable() )\n                {\n                    // don't show readonly parameters in help\n                    continue;\n                }\n\n                w.startElement( parameter.getName() );\n\n                String parameterType = parameter.getType();\n                if ( StringUtils.isNotEmpty( parameterType ) )\n                {\n                    w.addAttribute( \"implementation\", parameterType );\n                }\n\n                if ( parameter.getDefaultValue() != null )\n                {\n                    w.addAttribute( \"default-value\", parameter.getDefaultValue() );\n                }\n\n                if ( StringUtils.isNotEmpty( parameter.getExpression() ) )\n                {\n                    w.writeText( parameter.getExpression() );\n                }\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        if ( !requirements.isEmpty() && type != DescriptorType.LIMITED_FOR_HELP_MOJO )\n        {\n            w.startElement( \"requirements\" );\n\n            for ( Map.Entry<String, Requirement> entry : requirements.entrySet() )\n            {\n                String key = entry.getKey();\n                Requirement requirement = entry.getValue();\n\n                w.startElement( \"requirement\" );\n\n                GeneratorUtils.element( w, \"role\", requirement.getRole() );\n\n                if ( StringUtils.isNotEmpty( requirement.getRoleHint() ) )\n                {\n                    GeneratorUtils.element( w, \"role-hint\", requirement.getRoleHint() );\n                }\n\n                GeneratorUtils.element( w, \"field-name\", key );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        w.endElement();\n    }\n\n    /**\n     * Get the expression value, eventually surrounding it with <code>${ }<\/code>.\n     *\n     * @param parameter the parameter\n     * @return the expression value\n     */\n    private String getExpression( Parameter parameter )\n    {\n        String expression = parameter.getExpression();\n        if ( StringUtils.isNotBlank( expression ) && !expression.contains( \"${\" ) )\n        {\n            expression = \"${\" + expression.trim() + \"}\";\n            parameter.setExpression( expression );\n        }\n        return expression;\n    }\n}\n","lineNo":656}
{"Refactored Sample":"package org.apache.maven.tools.plugin.scanner;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\n\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.extractor.GroupKey;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractorComparator;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * @author jdcasey\n */\n@Named\npublic class DefaultMojoScanner\n    extends AbstractLogEnabled\n    implements MojoScanner\n{\n\n    private Map<String, MojoDescriptorExtractor> mojoDescriptorExtractors;\n\n    /**\n     * The names of the active extractors\n     */\n    private Set<String> activeExtractors;\n\n    /**\n     * Default constructor\n     *\n     * @param extractors not null\n     */\n    @Inject\n    public DefaultMojoScanner( Map<String, MojoDescriptorExtractor> extractors )\n    {\n        this.mojoDescriptorExtractors = extractors;\n\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"standalone-scanner-logger\" ) );\n    }\n\n    /**\n     * Empty constructor\n     */\n    public DefaultMojoScanner()\n    {\n        // nop\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void populatePluginDescriptor( PluginToolsRequest request )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        Logger logger = getLogger();\n\n        int numMojoDescriptors = 0;\n\n        List<MojoDescriptorExtractor> orderedExtractors = getOrderedExtractors();\n\n        logger.debug( \"Using \" + orderedExtractors.size() + \" mojo extractors.\" );\n\n        HashMap<String, Integer> groupStats = new HashMap<>();\n\n        for ( MojoDescriptorExtractor extractor : orderedExtractors )\n        {\n            GroupKey groupKey = extractor.getGroupKey();\n            String extractorId = extractor.getName();\n\n            logger.debug( \"Applying \" + extractorId + \" mojo extractor\" );\n\n            List<MojoDescriptor> extractorDescriptors = extractor.execute( request );\n\n            int extractorDescriptorsCount = extractorDescriptors.size();\n\n            logger.info( extractorId + \" mojo extractor found \" + extractorDescriptorsCount\n                             + \" mojo descriptor\" + ( extractorDescriptorsCount > 1 ? \"s\" : \"\" ) + \".\" );\n            numMojoDescriptors += extractorDescriptorsCount;\n\n            if ( extractor.isDeprecated() &&  extractorDescriptorsCount > 0 )\n            {\n                logger.warn( \"\" );\n                logger.warn( \"Deprecated extractor \" + extractorId\n                             + \" extracted \" + extractorDescriptorsCount\n                             + \" descriptor\" + ( extractorDescriptorsCount > 1 ? \"s\" : \"\" )\n                             + \". Upgrade your Mojo definitions.\" );\n                if ( GroupKey.JAVA_GROUP.equals( groupKey.getGroup() ) )\n                {\n                    logger.warn( \"You should use Mojo Annotations instead of Javadoc tags.\" );\n                }\n                logger.warn( \"\" );\n            }\n\n            if ( groupStats.containsKey( groupKey.getGroup() ) )\n            {\n                groupStats.put( groupKey.getGroup(),\n                    groupStats.get( groupKey.getGroup() ) + extractorDescriptorsCount );\n            }\n            else\n            {\n                groupStats.put( groupKey.getGroup(), extractorDescriptorsCount );\n            }\n\n            for ( MojoDescriptor descriptor : extractorDescriptors )\n            {\n                logger.debug( \"Adding mojo: \" + descriptor + \" to plugin descriptor.\" );\n\n                descriptor.setPluginDescriptor( request.getPluginDescriptor() );\n\n                request.getPluginDescriptor().addMojo( descriptor );\n            }\n        }\n\n        logger.debug( \"Discovered descriptors by groups: \" + groupStats );\n\n        if ( numMojoDescriptors == 0 && !request.isSkipErrorNoDescriptorsFound() )\n        {\n            throw new InvalidPluginDescriptorException(\n                \"No mojo definitions were found for plugin: \" + request.getPluginDescriptor().getPluginLookupKey()\n                    + \".\" );\n        }\n    }\n\n    /**\n     * Returns a list of extractors sorted by {@link MojoDescriptorExtractor#getGroupKey()}s, never {@code null}.\n     */\n    private List<MojoDescriptorExtractor> getOrderedExtractors() throws ExtractionException\n    {\n        Set<String> extractors = activeExtractors;\n\n        if ( extractors == null )\n        {\n            extractors = new HashSet<>( mojoDescriptorExtractors.keySet() );\n        }\n\n        ArrayList<MojoDescriptorExtractor> orderedExtractors = new ArrayList<>();\n        for ( String extractorId : extractors )\n        {\n            MojoDescriptorExtractor extractor = mojoDescriptorExtractors.get( extractorId );\n\n            if ( extractor == null )\n            {\n                throw new ExtractionException( \"No mojo extractor with '\" + extractorId + \"' id.\" );\n            }\n\n            orderedExtractors.add( extractor );\n        }\n\n        Collections.sort( orderedExtractors, MojoDescriptorExtractorComparator.INSTANCE );\n\n        return orderedExtractors;\n    }\n\n    @Override\n    public void setActiveExtractors( Set<String> extractors )\n    {\n        if ( extractors == null )\n        {\n            this.activeExtractors = null;\n        }\n        else\n        {\n            this.activeExtractors = new HashSet<>();\n\n            for ( String extractor : extractors )\n            {\n                if ( StringUtils.isNotEmpty( extractor ) )\n                {\n                    this.activeExtractors.add( extractor );\n                }\n            }\n        }\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.scanner;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\n\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * @author jdcasey\n */\n@Named\npublic class DefaultMojoScanner\n    extends AbstractLogEnabled\n    implements MojoScanner\n{\n\n    private Map<String, MojoDescriptorExtractor> mojoDescriptorExtractors;\n\n    /**\n     * The names of the active extractors\n     */\n    private Set<String> activeExtractors;\n\n    /**\n     * Default constructor\n     *\n     * @param extractors not null\n     */\n    @Inject\n    public DefaultMojoScanner( Map<String, MojoDescriptorExtractor> extractors )\n    {\n        this.mojoDescriptorExtractors = extractors;\n\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"standalone-scanner-logger\" ) );\n    }\n\n    /**\n     * Empty constructor\n     */\n    public DefaultMojoScanner()\n    {\n        // nop\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void populatePluginDescriptor( PluginToolsRequest request )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        Logger logger = getLogger();\n        Set<String> activeExtractorsInternal = getActiveExtractors();\n\n        logger.debug( \"Using \" + activeExtractorsInternal.size() + \" mojo extractors.\" );\n\n        int numMojoDescriptors = 0;\n\n        for ( String extractorId : activeExtractorsInternal )\n        {\n            MojoDescriptorExtractor extractor = mojoDescriptorExtractors.get( extractorId );\n\n            if ( extractor == null )\n            {\n                throw new ExtractionException( \"No mojo extractor with '\" + extractorId + \"' id.\" );\n            }\n\n            logger.debug( \"Applying \" + extractorId + \" mojo extractor\" );\n\n            List<MojoDescriptor> extractorDescriptors = extractor.execute( request );\n\n            logger.info( extractorId + \" mojo extractor found \" + extractorDescriptors.size()\n                             + \" mojo descriptor\" + ( extractorDescriptors.size() > 1 ? \"s\" : \"\" ) + \".\" );\n            numMojoDescriptors += extractorDescriptors.size();\n\n            for ( MojoDescriptor descriptor : extractorDescriptors )\n            {\n                logger.debug( \"Adding mojo: \" + descriptor + \" to plugin descriptor.\" );\n\n                descriptor.setPluginDescriptor( request.getPluginDescriptor() );\n\n                request.getPluginDescriptor().addMojo( descriptor );\n            }\n        }\n\n        if ( numMojoDescriptors == 0 && !request.isSkipErrorNoDescriptorsFound() )\n        {\n            throw new InvalidPluginDescriptorException(\n                \"No mojo definitions were found for plugin: \" + request.getPluginDescriptor().getPluginLookupKey()\n                    + \".\" );\n        }\n    }\n\n    /**\n     * Gets the name of the active extractors.\n     *\n     * @return A Set containing the names of the active extractors.\n     */\n    protected Set<String> getActiveExtractors()\n    {\n        Set<String> result = activeExtractors;\n\n        if ( result == null )\n        {\n            result = new HashSet<>( mojoDescriptorExtractors.keySet() );\n        }\n\n        return result;\n    }\n\n    @Override\n    public void setActiveExtractors( Set<String> extractors )\n    {\n        if ( extractors == null )\n        {\n            this.activeExtractors = null;\n        }\n        else\n        {\n            this.activeExtractors = new HashSet<>();\n\n            for ( String extractor : extractors )\n            {\n                if ( StringUtils.isNotEmpty( extractor ) )\n                {\n                    this.activeExtractors.add( extractor );\n                }\n            }\n        }\n    }\n\n}\n","lineNo":108}
{"Refactored Sample":"package org.apache.maven.plugin.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.IncludesArtifactFilter;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.generator.Generator;\nimport org.apache.maven.tools.plugin.generator.GeneratorException;\nimport org.apache.maven.tools.plugin.generator.GeneratorUtils;\nimport org.apache.maven.tools.plugin.scanner.MojoScanner;\nimport org.codehaus.plexus.component.repository.ComponentDependency;\nimport org.codehaus.plexus.util.ReaderFactory;\nimport org.sonatype.plexus.build.incremental.BuildContext;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Abstract class for this Plugin.\n *\n * @author <a href=\"mailto:jason@maven.org\">Jason van Zyl<\/a>\n *\n */\npublic abstract class AbstractGeneratorMojo\n    extends AbstractMojo\n{\n    /**\n     * The project currently being built.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true )\n    protected MavenProject project;\n\n    /**\n     * The component used for scanning the source tree for mojos.\n     */\n    @Component\n    protected MojoScanner mojoScanner;\n\n    @Component\n    protected BuildContext buildContext;\n\n    /**\n     * The file encoding of the source files.\n     *\n     * @since 2.5\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    protected String encoding;\n\n    /**\n     * The goal prefix that will appear before the \":\".\n     */\n    @Parameter\n    protected String goalPrefix;\n\n    /**\n     * By default an exception is throw if no mojo descriptor is found. As the maven-plugin is defined in core, the\n     * descriptor generator mojo is bound to generate-resources phase.\n     * But for annotations, the compiled classes are needed, so skip error\n     *\n     * @since 3.0\n     */\n    @Parameter( property = \"maven.plugin.skipErrorNoDescriptorsFound\", defaultValue = \"false\" )\n    protected boolean skipErrorNoDescriptorsFound;\n\n    /**\n     * <p>\n     * The role names of mojo extractors to use.\n     * <\/p>\n     * <p>\n     * If not set, all mojo extractors will be used. If set to an empty extractor name, no mojo extractors\n     * will be used.\n     * <\/p>\n     * Example:\n     * <pre>\n     *  &lt;!-- Use all mojo extractors --&gt;\n     *  &lt;extractors/&gt;\n     *\n     *  &lt;!-- Use no mojo extractors --&gt;\n     *  &lt;extractors&gt;\n     *      &lt;extractor/&gt;\n     *  &lt;/extractors&gt;\n     *\n     *  &lt;!-- Use only bsh mojo extractor --&gt;\n     *  &lt;extractors&gt;\n     *      &lt;extractor&gt;bsh&lt;/extractor&gt;\n     *  &lt;/extractors&gt;\n     * <\/pre>\n     */\n    @Parameter\n    protected Set<String> extractors;\n\n    /**\n     * Set this to \"true\" to skip invoking any goals or reports of the plugin.\n     *\n     * @since 2.8\n     */\n    @Parameter( defaultValue = \"false\", property = \"maven.plugin.skip\" )\n    protected boolean skip;\n\n    /**\n     * Specify the dependencies as {@code groupId:artifactId} containing (abstract) Mojos, to filter\n     * dependencies scanned at runtime and focus on dependencies that are really useful to Mojo analysis.\n     * By default, the value is {@code null} and all dependencies are scanned (as before this parameter was added).\n     * If specified in the configuration with no children, no dependencies are scanned.\n     * \n     * @since 3.5\n     */\n    @Parameter\n    private List<String> mojoDependencies;\n\n    /**\n     * List of Remote Repositories used by the resolver\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${project.remoteArtifactRepositories}\", required = true, readonly = true )\n    protected List<ArtifactRepository> remoteRepos;\n\n    /**\n     * Location of the local repository.\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${localRepository}\", required = true, readonly = true )\n    protected ArtifactRepository local;\n\n    /**\n     * Maven plugin packaging types. Default is single \"maven-plugin\".\n     * \n     * @since 3.3\n     */\n    @Parameter\n    protected List<String> packagingTypes = Arrays.asList( \"maven-plugin\" );\n\n    /**\n     * @return the output directory where files will be generated.\n     */\n    protected abstract File getOutputDirectory();\n\n    /**\n     * @return the wanted <code>Generator<\/code> implementation.\n     */\n    protected abstract Generator createGenerator();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !packagingTypes.contains( project.getPackaging() ) )\n        {\n            getLog().info( \"Unsupported packaging type \" + project.getPackaging() + \", execution skipped\" );\n            return;\n        }\n        if ( skip )\n        {\n            getLog().warn( \"Execution skipped\" );\n            return;\n        }\n\n        if ( !\"maven-plugin\".equalsIgnoreCase( project.getArtifactId() )\n            && project.getArtifactId().toLowerCase().startsWith( \"maven-\" )\n            && project.getArtifactId().toLowerCase().endsWith( \"-plugin\" ) \n            && !\"org.apache.maven.plugins\".equals( project.getGroupId() ) )\n        {\n            getLog().error( \"\\n\\nArtifact Ids of the format maven-___-plugin are reserved for \\n\"\n                                + \"plugins in the Group Id org.apache.maven.plugins\\n\"\n                                + \"Please change your artifactId to the format ___-maven-plugin\\n\"\n                                + \"In the future this error will break the build.\\n\\n\" );\n        }\n\n        String defaultGoalPrefix = getDefaultGoalPrefix( project );\n          \n        if ( goalPrefix == null )\n        {\n            goalPrefix = defaultGoalPrefix;\n        }\n        else if ( !goalPrefix.equals( defaultGoalPrefix ) )\n        {\n            getLog().warn(\n                \"\\n\\nGoal prefix is specified as: '\" + goalPrefix + \"'. \" + \"Maven currently expects it to be '\"\n                    + defaultGoalPrefix + \"'.\\n\" );\n        }\n\n        mojoScanner.setActiveExtractors( extractors );\n\n        // TODO: could use this more, eg in the writing of the plugin descriptor!\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.setGroupId( project.getGroupId() );\n\n        pluginDescriptor.setArtifactId( project.getArtifactId() );\n\n        pluginDescriptor.setVersion( project.getVersion() );\n\n        pluginDescriptor.setGoalPrefix( goalPrefix );\n\n        pluginDescriptor.setName( project.getName() );\n\n        pluginDescriptor.setDescription( project.getDescription() );\n\n        if ( encoding == null || encoding.length() < 1 )\n        {\n            getLog().warn( \"Using platform encoding (\" + ReaderFactory.FILE_ENCODING\n                               + \" actually) to read mojo source files, i.e. build is platform dependent!\" );\n        }\n        else\n        {\n            getLog().info( \"Using '\" + encoding + \"' encoding to read mojo source files.\" );\n        }\n\n        try\n        {\n            List<ComponentDependency> deps = GeneratorUtils.toComponentDependencies( project.getArtifacts() );\n            pluginDescriptor.setDependencies( deps );\n\n            PluginToolsRequest request = new DefaultPluginToolsRequest( project, pluginDescriptor );\n            request.setEncoding( encoding );\n            request.setSkipErrorNoDescriptorsFound( skipErrorNoDescriptorsFound );\n            request.setDependencies( filterMojoDependencies() );\n            request.setLocal( this.local );\n            request.setRemoteRepos( this.remoteRepos );\n\n            mojoScanner.populatePluginDescriptor( request );\n\n            File outputDirectory = getOutputDirectory();\n            outputDirectory.mkdirs();\n\n            createGenerator().execute( outputDirectory, request );\n            buildContext.refresh( outputDirectory );\n        }\n        catch ( GeneratorException e )\n        {\n            throw new MojoExecutionException( \"Error writing plugin descriptor\", e );\n        }\n        catch ( InvalidPluginDescriptorException | ExtractionException e )\n        {\n            throw new MojoExecutionException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                              e );\n        }\n        catch ( LinkageError e )\n        {\n            throw new MojoExecutionException( \"The API of the mojo scanner is not compatible with this plugin version.\"\n                + \" Please check the plugin dependencies configured in the POM and ensure the versions match.\", e );\n        }\n    }\n\n    static String getDefaultGoalPrefix( MavenProject project )\n    {\n        String defaultGoalPrefix;\n        if ( \"maven-plugin\".equalsIgnoreCase( project.getArtifactId() ) )\n        {\n            defaultGoalPrefix = project.getGroupId().substring( project.getGroupId().lastIndexOf( '.' ) + 1 );\n        }\n        else\n        {\n            defaultGoalPrefix = PluginDescriptor.getGoalPrefixFromArtifactId( project.getArtifactId() );\n        }\n        return defaultGoalPrefix;\n    }\n\n    /**\n     * Get dependencies filtered with mojoDependencies configuration.\n     * \n     * @return eventually filtered dependencies, or even <code>null<\/code> if configured with empty mojoDependencies\n     * list\n     * @see #mojoDependencies\n     */\n    private Set<Artifact> filterMojoDependencies()\n    {\n        Set<Artifact> filteredArtifacts;\n        if ( mojoDependencies == null )\n        {\n            filteredArtifacts = new LinkedHashSet<>( project.getArtifacts() );\n        }\n        else if ( mojoDependencies.size() == 0 )\n        {\n            filteredArtifacts = null;\n        }\n        else\n        {\n            filteredArtifacts = new LinkedHashSet<>();\n            \n            ArtifactFilter filter = new IncludesArtifactFilter( mojoDependencies );\n\n            for ( Artifact artifact : project.getArtifacts() )\n            {\n                if ( filter.include( artifact ) )\n                {\n                    filteredArtifacts.add( artifact );\n                }\n            }\n        }\n\n        return filteredArtifacts;\n    }\n}\n","Smelly Sample":"package org.apache.maven.plugin.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.IncludesArtifactFilter;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.generator.Generator;\nimport org.apache.maven.tools.plugin.generator.GeneratorException;\nimport org.apache.maven.tools.plugin.generator.GeneratorUtils;\nimport org.apache.maven.tools.plugin.scanner.MojoScanner;\nimport org.codehaus.plexus.component.repository.ComponentDependency;\nimport org.codehaus.plexus.util.ReaderFactory;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Abstract class for this Plugin.\n *\n * @author <a href=\"mailto:jason@maven.org\">Jason van Zyl<\/a>\n *\n */\npublic abstract class AbstractGeneratorMojo\n    extends AbstractMojo\n{\n    /**\n     * The project currently being built.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true )\n    protected MavenProject project;\n\n    /**\n     * The component used for scanning the source tree for mojos.\n     */\n    @Component\n    protected MojoScanner mojoScanner;\n\n    /**\n     * The file encoding of the source files.\n     *\n     * @since 2.5\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    protected String encoding;\n\n    /**\n     * The goal prefix that will appear before the \":\".\n     */\n    @Parameter\n    protected String goalPrefix;\n\n    /**\n     * By default an exception is throw if no mojo descriptor is found. As the maven-plugin is defined in core, the\n     * descriptor generator mojo is bound to generate-resources phase.\n     * But for annotations, the compiled classes are needed, so skip error\n     *\n     * @since 3.0\n     */\n    @Parameter( property = \"maven.plugin.skipErrorNoDescriptorsFound\", defaultValue = \"false\" )\n    protected boolean skipErrorNoDescriptorsFound;\n\n    /**\n     * <p>\n     * The role names of mojo extractors to use.\n     * <\/p>\n     * <p>\n     * If not set, all mojo extractors will be used. If set to an empty extractor name, no mojo extractors\n     * will be used.\n     * <\/p>\n     * Example:\n     * <pre>\n     *  &lt;!-- Use all mojo extractors --&gt;\n     *  &lt;extractors/&gt;\n     *\n     *  &lt;!-- Use no mojo extractors --&gt;\n     *  &lt;extractors&gt;\n     *      &lt;extractor/&gt;\n     *  &lt;/extractors&gt;\n     *\n     *  &lt;!-- Use only bsh mojo extractor --&gt;\n     *  &lt;extractors&gt;\n     *      &lt;extractor&gt;bsh&lt;/extractor&gt;\n     *  &lt;/extractors&gt;\n     * <\/pre>\n     */\n    @Parameter\n    protected Set<String> extractors;\n\n    /**\n     * Set this to \"true\" to skip invoking any goals or reports of the plugin.\n     *\n     * @since 2.8\n     */\n    @Parameter( defaultValue = \"false\", property = \"maven.plugin.skip\" )\n    protected boolean skip;\n\n    /**\n     * Specify the dependencies as {@code groupId:artifactId} containing (abstract) Mojos, to filter\n     * dependencies scanned at runtime and focus on dependencies that are really useful to Mojo analysis.\n     * By default, the value is {@code null} and all dependencies are scanned (as before this parameter was added).\n     * If specified in the configuration with no children, no dependencies are scanned.\n     * \n     * @since 3.5\n     */\n    @Parameter\n    private List<String> mojoDependencies;\n\n    /**\n     * List of Remote Repositories used by the resolver\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${project.remoteArtifactRepositories}\", required = true, readonly = true )\n    protected List<ArtifactRepository> remoteRepos;\n\n    /**\n     * Location of the local repository.\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${localRepository}\", required = true, readonly = true )\n    protected ArtifactRepository local;\n\n    /**\n     * Maven plugin packaging types. Default is single \"maven-plugin\".\n     * \n     * @since 3.3\n     */\n    @Parameter\n    protected List<String> packagingTypes = Arrays.asList( \"maven-plugin\" );\n\n    /**\n     * @return the output directory where files will be generated.\n     */\n    protected abstract File getOutputDirectory();\n\n    /**\n     * @return the wanted <code>Generator<\/code> implementation.\n     */\n    protected abstract Generator createGenerator();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !packagingTypes.contains( project.getPackaging() ) )\n        {\n            getLog().info( \"Unsupported packaging type \" + project.getPackaging() + \", execution skipped\" );\n            return;\n        }\n        if ( skip )\n        {\n            getLog().warn( \"Execution skipped\" );\n            return;\n        }\n\n        if ( !\"maven-plugin\".equalsIgnoreCase( project.getArtifactId() )\n            && project.getArtifactId().toLowerCase().startsWith( \"maven-\" )\n            && project.getArtifactId().toLowerCase().endsWith( \"-plugin\" ) \n            && !\"org.apache.maven.plugins\".equals( project.getGroupId() ) )\n        {\n            getLog().error( \"\\n\\nArtifact Ids of the format maven-___-plugin are reserved for \\n\"\n                                + \"plugins in the Group Id org.apache.maven.plugins\\n\"\n                                + \"Please change your artifactId to the format ___-maven-plugin\\n\"\n                                + \"In the future this error will break the build.\\n\\n\" );\n        }\n\n        String defaultGoalPrefix = getDefaultGoalPrefix( project );\n          \n        if ( goalPrefix == null )\n        {\n            goalPrefix = defaultGoalPrefix;\n        }\n        else if ( !goalPrefix.equals( defaultGoalPrefix ) )\n        {\n            getLog().warn(\n                \"\\n\\nGoal prefix is specified as: '\" + goalPrefix + \"'. \" + \"Maven currently expects it to be '\"\n                    + defaultGoalPrefix + \"'.\\n\" );\n        }\n\n        mojoScanner.setActiveExtractors( extractors );\n\n        // TODO: could use this more, eg in the writing of the plugin descriptor!\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.setGroupId( project.getGroupId() );\n\n        pluginDescriptor.setArtifactId( project.getArtifactId() );\n\n        pluginDescriptor.setVersion( project.getVersion() );\n\n        pluginDescriptor.setGoalPrefix( goalPrefix );\n\n        pluginDescriptor.setName( project.getName() );\n\n        pluginDescriptor.setDescription( project.getDescription() );\n\n        if ( encoding == null || encoding.length() < 1 )\n        {\n            getLog().warn( \"Using platform encoding (\" + ReaderFactory.FILE_ENCODING\n                               + \" actually) to read mojo source files, i.e. build is platform dependent!\" );\n        }\n        else\n        {\n            getLog().info( \"Using '\" + encoding + \"' encoding to read mojo source files.\" );\n        }\n\n        try\n        {\n            List<ComponentDependency> deps = GeneratorUtils.toComponentDependencies( project.getArtifacts() );\n            pluginDescriptor.setDependencies( deps );\n\n            PluginToolsRequest request = new DefaultPluginToolsRequest( project, pluginDescriptor );\n            request.setEncoding( encoding );\n            request.setSkipErrorNoDescriptorsFound( skipErrorNoDescriptorsFound );\n            request.setDependencies( filterMojoDependencies() );\n            request.setLocal( this.local );\n            request.setRemoteRepos( this.remoteRepos );\n\n            mojoScanner.populatePluginDescriptor( request );\n\n            getOutputDirectory().mkdirs();\n\n            createGenerator().execute( getOutputDirectory(), request );\n        }\n        catch ( GeneratorException e )\n        {\n            throw new MojoExecutionException( \"Error writing plugin descriptor\", e );\n        }\n        catch ( InvalidPluginDescriptorException | ExtractionException e )\n        {\n            throw new MojoExecutionException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                              e );\n        }\n        catch ( LinkageError e )\n        {\n            throw new MojoExecutionException( \"The API of the mojo scanner is not compatible with this plugin version.\"\n                + \" Please check the plugin dependencies configured in the POM and ensure the versions match.\", e );\n        }\n    }\n\n    static String getDefaultGoalPrefix( MavenProject project )\n    {\n        String defaultGoalPrefix;\n        if ( \"maven-plugin\".equalsIgnoreCase( project.getArtifactId() ) )\n        {\n            defaultGoalPrefix = project.getGroupId().substring( project.getGroupId().lastIndexOf( '.' ) + 1 );\n        }\n        else\n        {\n            defaultGoalPrefix = PluginDescriptor.getGoalPrefixFromArtifactId( project.getArtifactId() );\n        }\n        return defaultGoalPrefix;\n    }\n\n    /**\n     * Get dependencies filtered with mojoDependencies configuration.\n     * \n     * @return eventually filtered dependencies, or even <code>null<\/code> if configured with empty mojoDependencies\n     * list\n     * @see #mojoDependencies\n     */\n    private Set<Artifact> filterMojoDependencies()\n    {\n        Set<Artifact> filteredArtifacts;\n        if ( mojoDependencies == null )\n        {\n            filteredArtifacts = new LinkedHashSet<>( project.getArtifacts() );\n        }\n        else if ( mojoDependencies.size() == 0 )\n        {\n            filteredArtifacts = null;\n        }\n        else\n        {\n            filteredArtifacts = new LinkedHashSet<>();\n            \n            ArtifactFilter filter = new IncludesArtifactFilter( mojoDependencies );\n\n            for ( Artifact artifact : project.getArtifacts() )\n            {\n                if ( filter.include( artifact ) )\n                {\n                    filteredArtifacts.add( artifact );\n                }\n            }\n        }\n\n        return filteredArtifacts;\n    }\n}\n","lineNo":261}
{"Refactored Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.velocity.VelocityContext;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.PropertyUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.velocity.VelocityComponent;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.commons.ClassRemapper;\nimport org.objectweb.asm.commons.Remapper;\nimport org.objectweb.asm.commons.SimpleRemapper;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Generates an <code>HelpMojo<\/code> class from <code>help-class-source.vm<\/code> template.\n * The generated mojo reads help content from <code>META-INF/maven/${groupId}/${artifactId}/plugin-help.xml<\/code>\n * resource, which is generated by this {@link PluginDescriptorGenerator}.\n * <p>Notice that the help mojo source needs to be generated before compilation, but when Java annotations are used,\n * plugin descriptor content is available only after compilation (detecting annotations in .class files):\n * help mojo source can be generated with empty package only (and no plugin descriptor available yet), then needs\n * to be updated after compilation - through {@link #rewriteHelpMojo(PluginToolsRequest, Log)} which is called from\n * plugin descriptor XML generation.<\/p>\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    /**\n     * Default generated class name\n     */\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    /**\n     * Help properties file, to store data about generated source.\n     */\n    private static final String HELP_PROPERTIES_FILENAME = \"maven-plugin-help.properties\";\n\n    /**\n     * Default goal\n     */\n    private static final String HELP_GOAL = \"help\";\n\n    private String helpPackageName;\n\n    private boolean useAnnotations;\n\n    private VelocityComponent velocityComponent;\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws GeneratorException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n\n        String helpImplementation = getImplementation( pluginDescriptor );\n\n        @SuppressWarnings( \"unchecked\" ) List<MojoDescriptor> mojoDescriptors = pluginDescriptor.getMojos();\n\n        if ( mojoDescriptors != null )\n        {\n            // Verify that no help goal already exists\n            MojoDescriptor descriptor = pluginDescriptor.getMojo( HELP_GOAL );\n\n            if ( ( descriptor != null ) && !descriptor.getImplementation().equals( helpImplementation ) )\n            {\n                if ( getLogger().isWarnEnabled() )\n                {\n                    getLogger().warn( \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                          + \") already exists in this plugin. SKIPPED THE \" + helpImplementation\n                                          + \" GENERATION.\\n\" );\n                }\n\n                return;\n            }\n        }\n\n        writeHelpPropertiesFile( request, destinationDirectory );\n\n        useAnnotations = request.getProject().getArtifactMap().containsKey(\n            \"org.apache.maven.plugin-tools:maven-plugin-annotations\" );\n\n        try\n        {\n            String sourcePath = helpImplementation.replace( '.', File.separatorChar ) + \".java\";\n\n            File helpClass = new File( destinationDirectory, sourcePath );\n            helpClass.getParentFile().mkdirs();\n\n            String helpClassSources =\n                getHelpClassSources( getPluginHelpPath( request.getProject() ), pluginDescriptor );\n\n            FileUtils.fileWrite( helpClass, request.getEncoding(), helpClassSources );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n    }\n\n    public PluginHelpGenerator setHelpPackageName( String helpPackageName )\n    {\n        this.helpPackageName = helpPackageName;\n        return this;\n    }\n\n    public VelocityComponent getVelocityComponent()\n    {\n        return velocityComponent;\n    }\n\n    public PluginHelpGenerator setVelocityComponent( VelocityComponent velocityComponent )\n    {\n        this.velocityComponent = velocityComponent;\n        return this;\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    private String getHelpClassSources( String pluginHelpPath, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        Properties properties = new Properties();\n        VelocityContext context = new VelocityContext( properties );\n        if ( this.helpPackageName != null )\n        {\n            properties.put( \"helpPackageName\", this.helpPackageName );\n        }\n        else\n        {\n            properties.put( \"helpPackageName\", \"\" );\n        }\n        properties.put( \"pluginHelpPath\", pluginHelpPath );\n        properties.put( \"artifactId\", pluginDescriptor.getArtifactId() );\n        properties.put( \"goalPrefix\", pluginDescriptor.getGoalPrefix() );\n        properties.put( \"useAnnotations\", useAnnotations );\n\n        StringWriter stringWriter = new StringWriter();\n\n        // plugin-tools sources are UTF-8 (and even ASCII in this case))\n        try ( InputStream is = //\n                 Thread.currentThread().getContextClassLoader().getResourceAsStream( \"help-class-source.vm\" ); //\n             InputStreamReader isReader = new InputStreamReader( is, UTF_8 ) )\n        {\n            //isReader =\n            velocityComponent.getEngine().evaluate( context, stringWriter, \"\", isReader );\n        }\n        return stringWriter.toString();\n    }\n\n    /**\n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *                         <code>null<\/code>.\n     * @return The implementation.\n     */\n    private String getImplementation( PluginDescriptor pluginDescriptor )\n    {\n        if ( StringUtils.isEmpty( helpPackageName ) )\n        {\n            helpPackageName = GeneratorUtils.discoverPackageName( pluginDescriptor );\n        }\n\n        return StringUtils.isEmpty( helpPackageName )\n            ? HELP_MOJO_CLASS_NAME\n            : helpPackageName + '.' + HELP_MOJO_CLASS_NAME;\n    }\n\n    /**\n     * Write help properties files for later use to eventually rewrite Help Mojo.\n     *\n     * @param request\n     * @throws GeneratorException\n     * @see {@link #rewriteHelpMojo(PluginToolsRequest, Log)}\n     */\n    private void writeHelpPropertiesFile( PluginToolsRequest request, File destinationDirectory )\n        throws GeneratorException\n    {\n        Properties properties = new Properties();\n        properties.put( \"helpPackageName\", helpPackageName == null ? \"\" : helpPackageName );\n        properties.put( \"destinationDirectory\", destinationDirectory.getAbsolutePath() );\n\n        File tmpPropertiesFile = new File( request.getProject().getBuild().getDirectory(), HELP_PROPERTIES_FILENAME );\n\n        if ( tmpPropertiesFile.exists() )\n        {\n            tmpPropertiesFile.delete();\n        }\n        else if ( !tmpPropertiesFile.getParentFile().exists() )\n        {\n            tmpPropertiesFile.getParentFile().mkdirs();\n        }\n\n        try ( FileOutputStream fos = new FileOutputStream( tmpPropertiesFile ) )\n        {\n            properties.store( fos, \"maven plugin help mojo generation informations\" );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n    }\n\n    static String getPluginHelpPath( MavenProject mavenProject )\n    {\n        return \"META-INF/maven/\" + mavenProject.getGroupId() + \"/\" + mavenProject.getArtifactId() + \"/plugin-help.xml\";\n    }\n\n    /**\n     * Rewrite Help Mojo to match actual Mojos package name if it was not available at source generation\n     * time. This is used at descriptor generation time.\n     *\n     * @param request\n     * @throws GeneratorException\n     */\n    static void rewriteHelpMojo( PluginToolsRequest request, Log log )\n        throws GeneratorException\n    {\n        File tmpPropertiesFile = new File( request.getProject().getBuild().getDirectory(), HELP_PROPERTIES_FILENAME );\n\n        if ( !tmpPropertiesFile.exists() )\n        {\n            return;\n        }\n\n        Properties properties;\n        try\n        {\n            properties = PropertyUtils.loadProperties( tmpPropertiesFile );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n\n        String helpPackageName = properties.getProperty( \"helpPackageName\" );\n\n        // if helpPackageName property is empty, we have to rewrite the class with a better package name than empty\n        if ( StringUtils.isEmpty( helpPackageName ) )\n        {\n            String destDir = properties.getProperty( \"destinationDirectory\" );\n            File destinationDirectory;\n            if ( StringUtils.isEmpty( destDir ) )\n            {\n                // writeHelpPropertiesFile() creates 2 properties: find one without the other should not be possible\n                log.warn( \"\\n\\nUnexpected situation: destinationDirectory not defined in \" + HELP_PROPERTIES_FILENAME\n                              + \" during help mojo source generation but expected during XML descriptor generation.\" );\n                log.warn( \"Please check helpmojo goal version used in previous build phase.\" );\n                log.warn( \"If you just upgraded to plugin-tools >= 3.2 you must run a clean build at least once.\" );\n                destinationDirectory = new File( \"target/generated-sources/plugin\" );\n                log.warn( \"Trying default location: \" + destinationDirectory );\n            }\n            else\n            {\n                destinationDirectory = new File( destDir );\n            }\n            String helpMojoImplementation = rewriteHelpClassToMojoPackage( request, destinationDirectory, log );\n\n            if ( helpMojoImplementation != null )\n            {\n                // rewrite plugin descriptor with new HelpMojo implementation class\n                updateHelpMojoDescriptor( request.getPluginDescriptor(), helpMojoImplementation );\n            }\n        }\n    }\n\n    private static String rewriteHelpClassToMojoPackage( PluginToolsRequest request, File destinationDirectory,\n                                                         Log log )\n        throws GeneratorException\n    {\n        String destinationPackage = GeneratorUtils.discoverPackageName( request.getPluginDescriptor() );\n        if ( StringUtils.isEmpty( destinationPackage ) )\n        {\n            return null;\n        }\n        String packageAsDirectory = StringUtils.replace( destinationPackage, '.', '/' );\n\n        String outputDirectory = request.getProject().getBuild().getOutputDirectory();\n        File helpClassFile = new File( outputDirectory, HELP_MOJO_CLASS_NAME + \".class\" );\n        if ( !helpClassFile.exists() )\n        {\n            return null;\n        }\n\n        // rewrite help mojo source\n        File helpSourceFile = new File( destinationDirectory, HELP_MOJO_CLASS_NAME + \".java\" );\n        if ( !helpSourceFile.exists() )\n        {\n            log.warn( \"HelpMojo.java not found in default location: \" + helpSourceFile.getAbsolutePath() );\n            log.warn( \"Help goal source won't be moved to package: \" + destinationPackage );\n        }\n        else\n        {\n            File helpSourceFileNew =\n                new File( destinationDirectory, packageAsDirectory + '/' + HELP_MOJO_CLASS_NAME + \".java\" );\n            if ( !helpSourceFileNew.getParentFile().exists() )\n            {\n                helpSourceFileNew.getParentFile().mkdirs();\n            }\n            Charset encoding = Charset.forName( request.getEncoding() );\n            try ( Reader sourceReader = new InputStreamReader( new FileInputStream( helpSourceFile ), //\n                                                              encoding ); //\n                 PrintWriter sourceWriter = new PrintWriter(\n                     new OutputStreamWriter( new FileOutputStream( helpSourceFileNew ), //\n                                             encoding ) ) )\n            {\n                sourceWriter.println( \"package \" + destinationPackage + \";\" );\n                IOUtil.copy( sourceReader, sourceWriter );\n            }\n            catch ( IOException e )\n            {\n                throw new GeneratorException( e.getMessage(), e );\n            }\n            helpSourceFileNew.setLastModified( helpSourceFile.lastModified() );\n            helpSourceFile.delete();\n        }\n\n        // rewrite help mojo .class\n        File rewriteHelpClassFile =\n            new File( outputDirectory + '/' + packageAsDirectory, HELP_MOJO_CLASS_NAME + \".class\" );\n        if ( !rewriteHelpClassFile.getParentFile().exists() )\n        {\n            rewriteHelpClassFile.getParentFile().mkdirs();\n        }\n\n        ClassReader cr;\n        try ( FileInputStream fileInputStream = new FileInputStream( helpClassFile ) )\n        {\n            cr = new ClassReader( fileInputStream );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n\n        ClassWriter cw = new ClassWriter( 0 );\n\n        Remapper packageRemapper =\n            new SimpleRemapper( HELP_MOJO_CLASS_NAME, packageAsDirectory + '/' + HELP_MOJO_CLASS_NAME );\n        ClassVisitor cv = new ClassRemapper( cw, packageRemapper );\n\n        try\n        {\n            cr.accept( cv, ClassReader.EXPAND_FRAMES );\n        }\n        catch ( Throwable e )\n        {\n            throw new GeneratorException( \"ASM issue processing class-file \" + helpClassFile.getPath(), e );\n        }\n\n        byte[] renamedClass = cw.toByteArray();\n        try ( FileOutputStream fos = new FileOutputStream( rewriteHelpClassFile ) )\n        {\n            fos.write( renamedClass );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( \"Error rewriting help class: \" + e.getMessage(), e );\n        }\n\n        helpClassFile.delete();\n\n        return destinationPackage + \".HelpMojo\";\n    }\n\n    private static void updateHelpMojoDescriptor( PluginDescriptor pluginDescriptor, String helpMojoImplementation )\n    {\n        MojoDescriptor mojoDescriptor = pluginDescriptor.getMojo( HELP_GOAL );\n\n        if ( mojoDescriptor != null )\n        {\n            mojoDescriptor.setImplementation( helpMojoImplementation );\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.velocity.VelocityContext;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.PropertyUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.velocity.VelocityComponent;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.commons.ClassRemapper;\nimport org.objectweb.asm.commons.Remapper;\nimport org.objectweb.asm.commons.SimpleRemapper;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Generates an <code>HelpMojo<\/code> class from <code>help-class-source.vm<\/code> template.\n * The generated mojo reads help content from <code>META-INF/maven/${groupId}/${artifactId}/plugin-help.xml<\/code>\n * resource, which is generated by this {@link PluginDescriptorGenerator}.\n * <p>Notice that the help mojo source needs to be generated before compilation, but when Java annotations are used,\n * plugin descriptor content is available only after compilation (detecting annotations in .class files):\n * help mojo source can be generated with empty package only (and no plugin descriptor available yet), then needs\n * to be updated after compilation - through {@link #rewriteHelpMojo(PluginToolsRequest, Log)} which is called from\n * plugin descriptor XML generation.<\/p>\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    /**\n     * Default generated class name\n     */\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    /**\n     * Help properties file, to store data about generated source.\n     */\n    private static final String HELP_PROPERTIES_FILENAME = \"maven-plugin-help.properties\";\n\n    /**\n     * Default goal\n     */\n    private static final String HELP_GOAL = \"help\";\n\n    private String helpPackageName;\n\n    private boolean useAnnotations;\n\n    private VelocityComponent velocityComponent;\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws GeneratorException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n\n        String helpImplementation = getImplementation( pluginDescriptor );\n\n        @SuppressWarnings( \"unchecked\" ) List<MojoDescriptor> mojoDescriptors = pluginDescriptor.getMojos();\n\n        if ( mojoDescriptors != null )\n        {\n            // Verify that no help goal already exists\n            MojoDescriptor descriptor = pluginDescriptor.getMojo( HELP_GOAL );\n\n            if ( ( descriptor != null ) && !descriptor.getImplementation().equals( helpImplementation ) )\n            {\n                if ( getLogger().isWarnEnabled() )\n                {\n                    getLogger().warn( \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                          + \") already exists in this plugin. SKIPPED THE \" + helpImplementation\n                                          + \" GENERATION.\\n\" );\n                }\n\n                return;\n            }\n        }\n\n        writeHelpPropertiesFile( request, destinationDirectory );\n\n        useAnnotations = request.getProject().getArtifactMap().containsKey(\n            \"org.apache.maven.plugin-tools:maven-plugin-annotations\" );\n\n        try\n        {\n            String sourcePath = helpImplementation.replace( '.', File.separatorChar ) + \".java\";\n\n            File helpClass = new File( destinationDirectory, sourcePath );\n            helpClass.getParentFile().mkdirs();\n\n            String helpClassSources =\n                getHelpClassSources( getPluginHelpPath( request.getProject() ), pluginDescriptor );\n\n            FileUtils.fileWrite( helpClass, request.getEncoding(), helpClassSources );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n    }\n\n    public PluginHelpGenerator setHelpPackageName( String helpPackageName )\n    {\n        this.helpPackageName = helpPackageName;\n        return this;\n    }\n\n    public VelocityComponent getVelocityComponent()\n    {\n        return velocityComponent;\n    }\n\n    public PluginHelpGenerator setVelocityComponent( VelocityComponent velocityComponent )\n    {\n        this.velocityComponent = velocityComponent;\n        return this;\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    private String getHelpClassSources( String pluginHelpPath, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        Properties properties = new Properties();\n        VelocityContext context = new VelocityContext( properties );\n        if ( this.helpPackageName != null )\n        {\n            properties.put( \"helpPackageName\", this.helpPackageName );\n        }\n        else\n        {\n            properties.put( \"helpPackageName\", \"\" );\n        }\n        properties.put( \"pluginHelpPath\", pluginHelpPath );\n        properties.put( \"artifactId\", pluginDescriptor.getArtifactId() );\n        properties.put( \"goalPrefix\", pluginDescriptor.getGoalPrefix() );\n        properties.put( \"useAnnotations\", useAnnotations );\n\n        StringWriter stringWriter = new StringWriter();\n\n        // plugin-tools sources are UTF-8 (and even ASCII in this case))\n        try ( InputStream is = //\n                 Thread.currentThread().getContextClassLoader().getResourceAsStream( \"help-class-source.vm\" ); //\n             InputStreamReader isReader = new InputStreamReader( is, \"UTF-8\" ) )\n        {\n            //isReader =\n            velocityComponent.getEngine().evaluate( context, stringWriter, \"\", isReader );\n        }\n        catch ( UnsupportedEncodingException e )\n        {\n            // not supposed to happen since UTF-8 is supposed to be supported by any JVM\n        }\n        return stringWriter.toString();\n    }\n\n    /**\n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *                         <code>null<\/code>.\n     * @return The implementation.\n     */\n    private String getImplementation( PluginDescriptor pluginDescriptor )\n    {\n        if ( StringUtils.isEmpty( helpPackageName ) )\n        {\n            helpPackageName = GeneratorUtils.discoverPackageName( pluginDescriptor );\n        }\n\n        return StringUtils.isEmpty( helpPackageName )\n            ? HELP_MOJO_CLASS_NAME\n            : helpPackageName + '.' + HELP_MOJO_CLASS_NAME;\n    }\n\n    /**\n     * Write help properties files for later use to eventually rewrite Help Mojo.\n     *\n     * @param request\n     * @throws GeneratorException\n     * @see {@link #rewriteHelpMojo(PluginToolsRequest, Log)}\n     */\n    private void writeHelpPropertiesFile( PluginToolsRequest request, File destinationDirectory )\n        throws GeneratorException\n    {\n        Properties properties = new Properties();\n        properties.put( \"helpPackageName\", helpPackageName == null ? \"\" : helpPackageName );\n        properties.put( \"destinationDirectory\", destinationDirectory.getAbsolutePath() );\n\n        File tmpPropertiesFile = new File( request.getProject().getBuild().getDirectory(), HELP_PROPERTIES_FILENAME );\n\n        if ( tmpPropertiesFile.exists() )\n        {\n            tmpPropertiesFile.delete();\n        }\n        else if ( !tmpPropertiesFile.getParentFile().exists() )\n        {\n            tmpPropertiesFile.getParentFile().mkdirs();\n        }\n\n        try ( FileOutputStream fos = new FileOutputStream( tmpPropertiesFile ) )\n        {\n            properties.store( fos, \"maven plugin help mojo generation informations\" );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n    }\n\n    static String getPluginHelpPath( MavenProject mavenProject )\n    {\n        return \"META-INF/maven/\" + mavenProject.getGroupId() + \"/\" + mavenProject.getArtifactId() + \"/plugin-help.xml\";\n    }\n\n    /**\n     * Rewrite Help Mojo to match actual Mojos package name if it was not available at source generation\n     * time. This is used at descriptor generation time.\n     *\n     * @param request\n     * @throws GeneratorException\n     */\n    static void rewriteHelpMojo( PluginToolsRequest request, Log log )\n        throws GeneratorException\n    {\n        File tmpPropertiesFile = new File( request.getProject().getBuild().getDirectory(), HELP_PROPERTIES_FILENAME );\n\n        if ( !tmpPropertiesFile.exists() )\n        {\n            return;\n        }\n\n        Properties properties;\n        try\n        {\n            properties = PropertyUtils.loadProperties( tmpPropertiesFile );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n\n        String helpPackageName = properties.getProperty( \"helpPackageName\" );\n\n        // if helpPackageName property is empty, we have to rewrite the class with a better package name than empty\n        if ( StringUtils.isEmpty( helpPackageName ) )\n        {\n            String destDir = properties.getProperty( \"destinationDirectory\" );\n            File destinationDirectory;\n            if ( StringUtils.isEmpty( destDir ) )\n            {\n                // writeHelpPropertiesFile() creates 2 properties: find one without the other should not be possible\n                log.warn( \"\\n\\nUnexpected situation: destinationDirectory not defined in \" + HELP_PROPERTIES_FILENAME\n                              + \" during help mojo source generation but expected during XML descriptor generation.\" );\n                log.warn( \"Please check helpmojo goal version used in previous build phase.\" );\n                log.warn( \"If you just upgraded to plugin-tools >= 3.2 you must run a clean build at least once.\" );\n                destinationDirectory = new File( \"target/generated-sources/plugin\" );\n                log.warn( \"Trying default location: \" + destinationDirectory );\n            }\n            else\n            {\n                destinationDirectory = new File( destDir );\n            }\n            String helpMojoImplementation = rewriteHelpClassToMojoPackage( request, destinationDirectory, log );\n\n            if ( helpMojoImplementation != null )\n            {\n                // rewrite plugin descriptor with new HelpMojo implementation class\n                updateHelpMojoDescriptor( request.getPluginDescriptor(), helpMojoImplementation );\n            }\n        }\n    }\n\n    private static String rewriteHelpClassToMojoPackage( PluginToolsRequest request, File destinationDirectory,\n                                                         Log log )\n        throws GeneratorException\n    {\n        String destinationPackage = GeneratorUtils.discoverPackageName( request.getPluginDescriptor() );\n        if ( StringUtils.isEmpty( destinationPackage ) )\n        {\n            return null;\n        }\n        String packageAsDirectory = StringUtils.replace( destinationPackage, '.', '/' );\n\n        String outputDirectory = request.getProject().getBuild().getOutputDirectory();\n        File helpClassFile = new File( outputDirectory, HELP_MOJO_CLASS_NAME + \".class\" );\n        if ( !helpClassFile.exists() )\n        {\n            return null;\n        }\n\n        // rewrite help mojo source\n        File helpSourceFile = new File( destinationDirectory, HELP_MOJO_CLASS_NAME + \".java\" );\n        if ( !helpSourceFile.exists() )\n        {\n            log.warn( \"HelpMojo.java not found in default location: \" + helpSourceFile.getAbsolutePath() );\n            log.warn( \"Help goal source won't be moved to package: \" + destinationPackage );\n        }\n        else\n        {\n            File helpSourceFileNew =\n                new File( destinationDirectory, packageAsDirectory + '/' + HELP_MOJO_CLASS_NAME + \".java\" );\n            if ( !helpSourceFileNew.getParentFile().exists() )\n            {\n                helpSourceFileNew.getParentFile().mkdirs();\n            }\n            try ( Reader sourceReader = new InputStreamReader( new FileInputStream( helpSourceFile ), //\n                                                              request.getEncoding() ); //\n                 PrintWriter sourceWriter = new PrintWriter(\n                     new OutputStreamWriter( new FileOutputStream( helpSourceFileNew ), //\n                                             request.getEncoding() ) ) )\n            {\n                sourceWriter.println( \"package \" + destinationPackage + \";\" );\n                IOUtil.copy( sourceReader, sourceWriter );\n            }\n            catch ( IOException e )\n            {\n                throw new GeneratorException( e.getMessage(), e );\n            }\n            helpSourceFileNew.setLastModified( helpSourceFile.lastModified() );\n            helpSourceFile.delete();\n        }\n\n        // rewrite help mojo .class\n        File rewriteHelpClassFile =\n            new File( outputDirectory + '/' + packageAsDirectory, HELP_MOJO_CLASS_NAME + \".class\" );\n        if ( !rewriteHelpClassFile.getParentFile().exists() )\n        {\n            rewriteHelpClassFile.getParentFile().mkdirs();\n        }\n\n        ClassReader cr;\n        try ( FileInputStream fileInputStream = new FileInputStream( helpClassFile ) )\n        {\n            cr = new ClassReader( fileInputStream );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n\n        ClassWriter cw = new ClassWriter( 0 );\n\n        Remapper packageRemapper =\n            new SimpleRemapper( HELP_MOJO_CLASS_NAME, packageAsDirectory + '/' + HELP_MOJO_CLASS_NAME );\n        ClassVisitor cv = new ClassRemapper( cw, packageRemapper );\n\n        try\n        {\n            cr.accept( cv, ClassReader.EXPAND_FRAMES );\n        }\n        catch ( Throwable e )\n        {\n            throw new GeneratorException( \"ASM issue processing class-file \" + helpClassFile.getPath(), e );\n        }\n\n        byte[] renamedClass = cw.toByteArray();\n        try ( FileOutputStream fos = new FileOutputStream( rewriteHelpClassFile ) )\n        {\n            fos.write( renamedClass );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( \"Error rewriting help class: \" + e.getMessage(), e );\n        }\n\n        helpClassFile.delete();\n\n        return destinationPackage + \".HelpMojo\";\n    }\n\n    private static void updateHelpMojoDescriptor( PluginDescriptor pluginDescriptor, String helpMojoImplementation )\n    {\n        MojoDescriptor mojoDescriptor = pluginDescriptor.getMojo( HELP_GOAL );\n\n        if ( mojoDescriptor != null )\n        {\n            mojoDescriptor.setImplementation( helpMojoImplementation );\n        }\n    }\n}\n","lineNo":362}
{"Refactored Sample":"package org.apache.maven.plugins.plugin.descriptor;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptorBuilder;\nimport org.codehaus.plexus.configuration.PlexusConfiguration;\nimport org.codehaus.plexus.configuration.PlexusConfigurationException;\n\n/**\n * Reads the plugin descriptor and adds the fix for MNG-6109 when using Maven-3.3.9 and before.\n * Class can be removed once Maven 3.5.0 is the prerequisite for this plugin.\n * \n * @author Robert Scholte\n * @since 3.5.1\n */\npublic class MNG6109PluginDescriptorBuilder extends PluginDescriptorBuilder\n{\n\n    @Override\n    public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDescriptor pluginDescriptor )\n        throws PlexusConfigurationException\n    {\n        MojoDescriptor mojoDescriptor = super.buildComponentDescriptor( c, pluginDescriptor );\n        \n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] parameterConfigurations = c.getChild( \"parameters\" ).getChildren( \"parameter\" );\n\n        for ( PlexusConfiguration d : parameterConfigurations )\n        {\n            String parameterName = d.getChild( \"name\" ).getValue();\n            Parameter pd = (Parameter) mojoDescriptor.getParameterMap().get( parameterName );\n            \n            String parameterSince = d.getChild( \"since\" ).getValue();\n            pd.setSince( parameterSince );\n        }\n        \n        return mojoDescriptor;\n    }\n}\n","Smelly Sample":"package org.apache.maven.plugins.plugin.descriptor;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptorBuilder;\nimport org.codehaus.plexus.configuration.PlexusConfiguration;\nimport org.codehaus.plexus.configuration.PlexusConfigurationException;\n\n/**\n * Reads the plugin descriptor and adds the fix for MNG-6109 when using Maven-3.3.9 and before.\n * Class can be removed once Maven 3.5.0 is the prerequisite for this plugin.\n * \n * @author Robert Scholte\n * @since 3.5.1\n */\npublic class MNG6109PluginDescriptorBuilder extends PluginDescriptorBuilder\n{\n\n    @Override\n    public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDescriptor pluginDescriptor )\n        throws PlexusConfigurationException\n    {\n        MojoDescriptor mojoDescriptor = super.buildComponentDescriptor( c, pluginDescriptor );\n        \n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] parameterConfigurations = c.getChild( \"parameters\" ).getChildren( \"parameter\" );\n\n        for ( PlexusConfiguration d : parameterConfigurations )\n        {\n            String parameterName = d.getChild( \"name\" ).getValue();\n            \n            String parameterSince = d.getChild( \"since\" ).getValue();\n            \n            mojoDescriptor.getParameterMap().get( parameterName ).setSince( parameterSince );\n        }\n        \n        return mojoDescriptor;\n    }\n}\n","lineNo":54}
{"Refactored Sample":"package org.apache.maven.plugin.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.IncludesArtifactFilter;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.generator.Generator;\nimport org.apache.maven.tools.plugin.generator.GeneratorException;\nimport org.apache.maven.tools.plugin.generator.GeneratorUtils;\nimport org.apache.maven.tools.plugin.scanner.MojoScanner;\nimport org.codehaus.plexus.component.repository.ComponentDependency;\nimport org.codehaus.plexus.util.ReaderFactory;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Abstract class for this Plugin.\n *\n * @author <a href=\"mailto:jason@maven.org\">Jason van Zyl<\/a>\n * @version $Id$\n */\npublic abstract class AbstractGeneratorMojo\n    extends AbstractMojo\n{\n    /**\n     * The project currently being built.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true )\n    protected MavenProject project;\n\n    /**\n     * The component used for scanning the source tree for mojos.\n     */\n    @Component\n    protected MojoScanner mojoScanner;\n\n    /**\n     * The file encoding of the source files.\n     *\n     * @since 2.5\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    protected String encoding;\n\n    /**\n     * The goal prefix that will appear before the \":\".\n     */\n    @Parameter\n    protected String goalPrefix;\n\n    /**\n     * By default an exception is throw if no mojo descriptor is found. As the maven-plugin is defined in core, the\n     * descriptor generator mojo is bound to generate-resources phase.\n     * But for annotations, the compiled classes are needed, so skip error\n     *\n     * @since 3.0\n     */\n    @Parameter( property = \"maven.plugin.skipErrorNoDescriptorsFound\", defaultValue = \"false\" )\n    protected boolean skipErrorNoDescriptorsFound;\n\n    /**\n     * The role names of mojo extractors to use.\n     * <p/>\n     * If not set, all mojo extractors will be used. If set to an empty extractor name, no mojo extractors\n     * will be used.\n     * <p/>\n     * Example:\n     * <p/>\n     * <pre>\n     *  &lt;!-- Use all mojo extractors --&gt;\n     *  &lt;extractors/&gt;\n     *\n     *  &lt;!-- Use no mojo extractors --&gt;\n     *  &lt;extractors&gt;\n     *      &lt;extractor/&gt;\n     *  &lt;/extractors&gt;\n     *\n     *  &lt;!-- Use only bsh mojo extractor --&gt;\n     *  &lt;extractors&gt;\n     *      &lt;extractor&gt;bsh&lt;/extractor&gt;\n     *  &lt;/extractors&gt;\n     * <\/pre>\n     */\n    @Parameter\n    protected Set<String> extractors;\n\n    /**\n     * Set this to \"true\" to skip invoking any goals or reports of the plugin.\n     *\n     * @since 2.8\n     */\n    @Parameter( defaultValue = \"false\", property = \"maven.plugin.skip\" )\n    protected boolean skip;\n\n    /**\n     * The set of dependencies for the current project\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${project.artifacts}\", required = true, readonly = true )\n    protected Set<Artifact> dependencies;\n    \n    /**\n     * Specify the dependencies as {@code groupId:artifactId} containing (abstract) Mojos. \n     * If none is specified, all dependencies are scanned.\n     * If an empty list is specified, no dependencies are scanned.\n     * \n     * @since 3.5\n     */\n    @Parameter\n    private List<String> mojoDependencies;\n\n    /**\n     * List of Remote Repositories used by the resolver\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${project.remoteArtifactRepositories}\", required = true, readonly = true )\n    protected List<ArtifactRepository> remoteRepos;\n\n    /**\n     * Location of the local repository.\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${localRepository}\", required = true, readonly = true )\n    protected ArtifactRepository local;\n\n    /**\n     * Maven plugin packaging types. Default is single \"maven-plugin\".\n     * \n     * @since 3.3\n     */\n    @Parameter\n    protected List<String> packagingTypes = Arrays.asList( \"maven-plugin\" );\n\n    /**\n     * @return the output directory where files will be generated.\n     */\n    protected abstract File getOutputDirectory();\n\n    /**\n     * @return the wanted <code>Generator<\/code> implementation.\n     */\n    protected abstract Generator createGenerator();\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !packagingTypes.contains( project.getPackaging() ) )\n        {\n            getLog().warn( \"Unsupported packaging type \" + project.getPackaging() + \", execution skipped\" );\n            return;\n        }\n        if ( skip )\n        {\n            getLog().warn( \"Execution skipped\" );\n            return;\n        }\n\n        if ( project.getArtifactId().toLowerCase().startsWith( \"maven-\" )\n            && project.getArtifactId().toLowerCase().endsWith( \"-plugin\" ) && !\"org.apache.maven.plugins\".equals(\n            project.getGroupId() ) )\n        {\n            getLog().error( \"\\n\\nArtifact Ids of the format maven-___-plugin are reserved for \\n\"\n                                + \"plugins in the Group Id org.apache.maven.plugins\\n\"\n                                + \"Please change your artifactId to the format ___-maven-plugin\\n\"\n                                + \"In the future this error will break the build.\\n\\n\" );\n        }\n\n        String defaultGoalPrefix = PluginDescriptor.getGoalPrefixFromArtifactId( project.getArtifactId() );\n        if ( goalPrefix == null )\n        {\n            goalPrefix = defaultGoalPrefix;\n        }\n        else if ( !goalPrefix.equals( defaultGoalPrefix ) )\n        {\n            getLog().warn(\n                \"\\n\\nGoal prefix is specified as: '\" + goalPrefix + \"'. \" + \"Maven currently expects it to be '\"\n                    + defaultGoalPrefix + \"'.\\n\" );\n        }\n\n        mojoScanner.setActiveExtractors( extractors );\n\n        // TODO: could use this more, eg in the writing of the plugin descriptor!\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.setGroupId( project.getGroupId() );\n\n        pluginDescriptor.setArtifactId( project.getArtifactId() );\n\n        pluginDescriptor.setVersion( project.getVersion() );\n\n        pluginDescriptor.setGoalPrefix( goalPrefix );\n\n        pluginDescriptor.setName( project.getName() );\n\n        pluginDescriptor.setDescription( project.getDescription() );\n\n        if ( encoding == null || encoding.length() < 1 )\n        {\n            getLog().warn( \"Using platform encoding (\" + ReaderFactory.FILE_ENCODING\n                               + \" actually) to read mojo source files, i.e. build is platform dependent!\" );\n        }\n        else\n        {\n            getLog().info( \"Using '\" + encoding + \"' encoding to read mojo source files.\" );\n        }\n\n        Set<Artifact> requestDependencies;\n        if ( mojoDependencies == null )\n        {\n            requestDependencies = dependencies;\n        }\n        else if ( mojoDependencies == null )\n        {\n            requestDependencies = null;\n        }\n        else\n        {\n            requestDependencies = new LinkedHashSet<Artifact>();\n            \n            ArtifactFilter filter = new IncludesArtifactFilter( mojoDependencies );\n\n            for ( Artifact artifact : dependencies )\n            {\n                if ( filter.include( artifact ) )\n                {\n                    requestDependencies.add( artifact );\n                }\n            }\n        }\n        \n        \n        try\n        {\n            List<ComponentDependency> deps = GeneratorUtils.toComponentDependencies( project.getRuntimeDependencies() );\n            pluginDescriptor.setDependencies( deps );\n\n            PluginToolsRequest request = new DefaultPluginToolsRequest( project, pluginDescriptor );\n            request.setEncoding( encoding );\n            request.setSkipErrorNoDescriptorsFound( skipErrorNoDescriptorsFound );\n            request.setDependencies( requestDependencies );\n            request.setLocal( this.local );\n            request.setRemoteRepos( this.remoteRepos );\n\n            mojoScanner.populatePluginDescriptor( request );\n\n            getOutputDirectory().mkdirs();\n\n            createGenerator().execute( getOutputDirectory(), request );\n        }\n        catch ( GeneratorException e )\n        {\n            throw new MojoExecutionException( \"Error writing plugin descriptor\", e );\n        }\n        catch ( InvalidPluginDescriptorException e )\n        {\n            throw new MojoExecutionException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                              e );\n        }\n        catch ( ExtractionException e )\n        {\n            throw new MojoExecutionException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                              e );\n        }\n        catch ( LinkageError e )\n        {\n            throw new MojoExecutionException( \"The API of the mojo scanner is not compatible with this plugin version.\"\n                + \" Please check the plugin dependencies configured in the POM and ensure the versions match.\", e );\n        }\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.plugin.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.generator.Generator;\nimport org.apache.maven.tools.plugin.generator.GeneratorException;\nimport org.apache.maven.tools.plugin.generator.GeneratorUtils;\nimport org.apache.maven.tools.plugin.scanner.MojoScanner;\nimport org.codehaus.plexus.component.repository.ComponentDependency;\nimport org.codehaus.plexus.util.ReaderFactory;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Abstract class for this Plugin.\n *\n * @author <a href=\"mailto:jason@maven.org\">Jason van Zyl<\/a>\n * @version $Id$\n */\npublic abstract class AbstractGeneratorMojo\n    extends AbstractMojo\n{\n    /**\n     * The project currently being built.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true )\n    protected MavenProject project;\n\n    /**\n     * The component used for scanning the source tree for mojos.\n     */\n    @Component\n    protected MojoScanner mojoScanner;\n\n    /**\n     * The file encoding of the source files.\n     *\n     * @since 2.5\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    protected String encoding;\n\n    /**\n     * The goal prefix that will appear before the \":\".\n     */\n    @Parameter\n    protected String goalPrefix;\n\n    /**\n     * By default an exception is throw if no mojo descriptor is found. As the maven-plugin is defined in core, the\n     * descriptor generator mojo is bound to generate-resources phase.\n     * But for annotations, the compiled classes are needed, so skip error\n     *\n     * @since 3.0\n     */\n    @Parameter( property = \"maven.plugin.skipErrorNoDescriptorsFound\", defaultValue = \"false\" )\n    protected boolean skipErrorNoDescriptorsFound;\n\n    /**\n     * The role names of mojo extractors to use.\n     * <p/>\n     * If not set, all mojo extractors will be used. If set to an empty extractor name, no mojo extractors\n     * will be used.\n     * <p/>\n     * Example:\n     * <p/>\n     * <pre>\n     *  &lt;!-- Use all mojo extractors --&gt;\n     *  &lt;extractors/&gt;\n     *\n     *  &lt;!-- Use no mojo extractors --&gt;\n     *  &lt;extractors&gt;\n     *      &lt;extractor/&gt;\n     *  &lt;/extractors&gt;\n     *\n     *  &lt;!-- Use only bsh mojo extractor --&gt;\n     *  &lt;extractors&gt;\n     *      &lt;extractor&gt;bsh&lt;/extractor&gt;\n     *  &lt;/extractors&gt;\n     * <\/pre>\n     */\n    @Parameter\n    protected Set<String> extractors;\n\n    /**\n     * Set this to \"true\" to skip invoking any goals or reports of the plugin.\n     *\n     * @since 2.8\n     */\n    @Parameter( defaultValue = \"false\", property = \"maven.plugin.skip\" )\n    protected boolean skip;\n\n    /**\n     * The set of dependencies for the current project\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${project.artifacts}\", required = true, readonly = true )\n    protected Set<Artifact> dependencies;\n\n    /**\n     * List of Remote Repositories used by the resolver\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${project.remoteArtifactRepositories}\", required = true, readonly = true )\n    protected List<ArtifactRepository> remoteRepos;\n\n    /**\n     * Location of the local repository.\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${localRepository}\", required = true, readonly = true )\n    protected ArtifactRepository local;\n\n    /**\n     * Maven plugin packaging types. Default is single \"maven-plugin\".\n     * \n     * @since 3.3\n     */\n    @Parameter\n    protected List<String> packagingTypes = Arrays.asList( \"maven-plugin\" );\n\n    /**\n     * @return the output directory where files will be generated.\n     */\n    protected abstract File getOutputDirectory();\n\n    /**\n     * @return the wanted <code>Generator<\/code> implementation.\n     */\n    protected abstract Generator createGenerator();\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !packagingTypes.contains( project.getPackaging() ) )\n        {\n            getLog().warn( \"Unsupported packaging type \" + project.getPackaging() + \", execution skipped\" );\n            return;\n        }\n        if ( skip )\n        {\n            getLog().warn( \"Execution skipped\" );\n            return;\n        }\n\n        if ( project.getArtifactId().toLowerCase().startsWith( \"maven-\" )\n            && project.getArtifactId().toLowerCase().endsWith( \"-plugin\" ) && !\"org.apache.maven.plugins\".equals(\n            project.getGroupId() ) )\n        {\n            getLog().error( \"\\n\\nArtifact Ids of the format maven-___-plugin are reserved for \\n\"\n                                + \"plugins in the Group Id org.apache.maven.plugins\\n\"\n                                + \"Please change your artifactId to the format ___-maven-plugin\\n\"\n                                + \"In the future this error will break the build.\\n\\n\" );\n        }\n\n        String defaultGoalPrefix = PluginDescriptor.getGoalPrefixFromArtifactId( project.getArtifactId() );\n        if ( goalPrefix == null )\n        {\n            goalPrefix = defaultGoalPrefix;\n        }\n        else if ( !goalPrefix.equals( defaultGoalPrefix ) )\n        {\n            getLog().warn(\n                \"\\n\\nGoal prefix is specified as: '\" + goalPrefix + \"'. \" + \"Maven currently expects it to be '\"\n                    + defaultGoalPrefix + \"'.\\n\" );\n        }\n\n        mojoScanner.setActiveExtractors( extractors );\n\n        // TODO: could use this more, eg in the writing of the plugin descriptor!\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.setGroupId( project.getGroupId() );\n\n        pluginDescriptor.setArtifactId( project.getArtifactId() );\n\n        pluginDescriptor.setVersion( project.getVersion() );\n\n        pluginDescriptor.setGoalPrefix( goalPrefix );\n\n        pluginDescriptor.setName( project.getName() );\n\n        pluginDescriptor.setDescription( project.getDescription() );\n\n        if ( encoding == null || encoding.length() < 1 )\n        {\n            getLog().warn( \"Using platform encoding (\" + ReaderFactory.FILE_ENCODING\n                               + \" actually) to read mojo source files, i.e. build is platform dependent!\" );\n        }\n        else\n        {\n            getLog().info( \"Using '\" + encoding + \"' encoding to read mojo source files.\" );\n        }\n\n        try\n        {\n            List<ComponentDependency> deps = GeneratorUtils.toComponentDependencies( project.getRuntimeDependencies() );\n            pluginDescriptor.setDependencies( deps );\n\n            PluginToolsRequest request = new DefaultPluginToolsRequest( project, pluginDescriptor );\n            request.setEncoding( encoding );\n            request.setSkipErrorNoDescriptorsFound( skipErrorNoDescriptorsFound );\n            request.setDependencies( dependencies );\n            request.setLocal( this.local );\n            request.setRemoteRepos( this.remoteRepos );\n\n            mojoScanner.populatePluginDescriptor( request );\n\n            getOutputDirectory().mkdirs();\n\n            createGenerator().execute( getOutputDirectory(), request );\n        }\n        catch ( GeneratorException e )\n        {\n            throw new MojoExecutionException( \"Error writing plugin descriptor\", e );\n        }\n        catch ( InvalidPluginDescriptorException e )\n        {\n            throw new MojoExecutionException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                              e );\n        }\n        catch ( ExtractionException e )\n        {\n            throw new MojoExecutionException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                              e );\n        }\n        catch ( LinkageError e )\n        {\n            throw new MojoExecutionException( \"The API of the mojo scanner is not compatible with this plugin version.\"\n                + \" Please check the plugin dependencies configured in the POM and ensure the versions match.\", e );\n        }\n    }\n\n}\n","lineNo":246}
{"Refactored Sample":"package org.apache.maven.plugin.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.Renderer;\nimport org.apache.maven.model.Plugin;\nimport org.apache.maven.model.ReportPlugin;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.AbstractMavenReport;\nimport org.apache.maven.reporting.AbstractMavenReportRenderer;\nimport org.apache.maven.reporting.MavenReportException;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.generator.GeneratorException;\nimport org.apache.maven.tools.plugin.generator.GeneratorUtils;\nimport org.apache.maven.tools.plugin.generator.PluginXdocGenerator;\nimport org.apache.maven.tools.plugin.scanner.MojoScanner;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.component.repository.ComponentDependency;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.Xpp3Dom;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.ResourceBundle;\nimport java.util.Set;\n\n/**\n * Generates the Plugin's documentation report: <code>plugin-info.html<\/code> plugin overview page,\n * and one <code><i>goal<\/i>-mojo.html<\/code> per goal.\n *\n * @author <a href=\"snicoll@apache.org\">Stephane Nicoll<\/a>\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.0\n */\n@Mojo( name = \"report\", threadSafe = true )\n@Execute( phase = LifecyclePhase.PROCESS_CLASSES )\npublic class PluginReport\n    extends AbstractMavenReport\n{\n    /**\n     * Report output directory for mojos' documentation.\n     */\n    @Parameter( defaultValue = \"${project.build.directory}/generated-site/xdoc\" )\n    private File outputDirectory;\n\n    /**\n     * Doxia Site Renderer.\n     */\n    @Component\n    private Renderer siteRenderer;\n\n    /**\n     * The Maven Project.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true )\n    private MavenProject project;\n\n    /**\n     * Mojo scanner tools.\n     */\n    @Component\n    protected MojoScanner mojoScanner;\n\n    /**\n     * The file encoding of the source files.\n     *\n     * @since 2.7\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specify some requirements to execute this plugin.\n     * Example:\n     * <pre>\n     * &lt;requirements&gt;\n     *   &lt;maven&gt;2.0&lt;/maven&gt;\n     *   &lt;jdk&gt;1.4&lt;/jdk&gt;\n     *   &lt;memory&gt;256m&lt;/memory&gt;\n     *   &lt;diskSpace&gt;1m&lt;/diskSpace&gt;\n     *   &lt;others&gt;\n     *     &lt;property&gt;\n     *       &lt;name&gt;SVN&lt;/name&gt;\n     *       &lt;value&gt;1.4.6&lt;/value&gt;\n     *     &lt;/property&gt;\n     *   &lt;/others&gt;\n     * &lt;/requirements&gt;\n     * <\/pre>\n     */\n    @Parameter\n    private Requirements requirements;\n\n    /**\n     * The goal prefix that will appear before the \":\".\n     * By default, this plugin applies a heuristic to derive a heuristic from\n     * the plugin's artifactId.\n     * <p/>\n     * It removes any occurrences of the regular expression <strong>-?maven-?<\/strong>,\n     * and then removes any occurrences of <strong>-?plugin-?<\/strong>.\n     * <p>\n     * For example, horsefeature-maven-plugin becomes horsefeature.\n     * <\/p>\n     * <p>\n     * (There is a special for maven-plugin-plugin; it is mapped to 'plugin'.\n     * <\/p>\n     *\n     * @since 2.4\n     */\n    @Parameter( property = \"goalPrefix\" )\n    protected String goalPrefix;\n\n    /**\n     * Set this to \"true\" to skip invoking any goals or reports of the plugin.\n     *\n     * @since 2.8\n     */\n    @Parameter( defaultValue = \"false\", property = \"maven.plugin.skip\" )\n    private boolean skip;\n\n    /**\n     * Set this to \"true\" to skip generating the report.\n     *\n     * @since 2.8\n     */\n    @Parameter( defaultValue = \"false\", property = \"maven.plugin.report.skip\" )\n    private boolean skipReport;\n\n    /**\n     * The set of dependencies for the current project\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${project.artifacts}\", required = true, readonly = true )\n    protected Set<Artifact> dependencies;\n\n    /**\n     * List of Remote Repositories used by the resolver\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${project.remoteArtifactRepositories}\", required = true, readonly = true )\n    protected List<ArtifactRepository> remoteRepos;\n\n    /**\n     * Location of the local repository.\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${localRepository}\", required = true, readonly = true )\n    protected ArtifactRepository local;\n\n    /**\n     * {@inheritDoc}\n     */\n    protected Renderer getSiteRenderer()\n    {\n        return siteRenderer;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected String getOutputDirectory()\n    {\n        // PLUGIN-191: output directory of plugin.html, not *-mojo.xml\n        return project.getReporting().getOutputDirectory();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected MavenProject getProject()\n    {\n        return project;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean canGenerateReport()\n    {\n        return \"maven-plugin\".equals( project.getPackaging() );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings( \"unchecked\" )\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( !canGenerateReport() )\n        {\n            return;\n        }\n        if ( skip || skipReport )\n        {\n            getLog().info( \"Maven Plugin Plugin Report generation skipped.\" );\n            return;\n        }\n\n        PluginDescriptor pluginDescriptor = extractPluginDescriptor();\n\n        // Generate the mojos' documentation\n        generateMojosDocumentation( pluginDescriptor, locale );\n\n        // Write the overview\n        PluginOverviewRenderer r =\n            new PluginOverviewRenderer( project, requirements, getSink(), pluginDescriptor, locale );\n        r.render();\n    }\n\n    private PluginDescriptor extractPluginDescriptor()\n        throws MavenReportException\n    {\n        // Copy from AbstractGeneratorMojo#execute()\n        String defaultGoalPrefix = PluginDescriptor.getGoalPrefixFromArtifactId( project.getArtifactId() );\n        if ( goalPrefix == null )\n        {\n            goalPrefix = defaultGoalPrefix;\n        }\n        else\n        {\n            getLog().warn( \"\\n\\nGoal prefix is specified as: '\" + goalPrefix + \"'. Maven currently expects it to be '\"\n                               + defaultGoalPrefix + \"'.\\n\" );\n        }\n\n        // TODO: could use this more, eg in the writing of the plugin descriptor!\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.setGroupId( project.getGroupId() );\n\n        pluginDescriptor.setArtifactId( project.getArtifactId() );\n\n        pluginDescriptor.setVersion( project.getVersion() );\n\n        pluginDescriptor.setGoalPrefix( goalPrefix );\n\n        try\n        {\n            List<ComponentDependency> deps = GeneratorUtils.toComponentDependencies( project.getRuntimeDependencies() );\n            pluginDescriptor.setDependencies( deps );\n\n            PluginToolsRequest request = new DefaultPluginToolsRequest( project, pluginDescriptor );\n            request.setEncoding( encoding );\n            request.setSkipErrorNoDescriptorsFound( true );\n            request.setDependencies( dependencies );\n            request.setLocal( this.local );\n            request.setRemoteRepos( this.remoteRepos );\n\n            try\n            {\n                mojoScanner.populatePluginDescriptor( request );\n            }\n            catch ( InvalidPluginDescriptorException e )\n            {\n                // this is OK, it happens to lifecycle plugins. Allow generation to proceed.\n                getLog().debug( \"Plugin without mojos.\", e );\n            }\n        }\n        catch ( ExtractionException e )\n        {\n            throw new MavenReportException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                            e );\n        }\n        return pluginDescriptor;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription( Locale locale )\n    {\n        return getBundle( locale ).getString( \"report.plugin.description\" );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getName( Locale locale )\n    {\n        return getBundle( locale ).getString( \"report.plugin.name\" );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getOutputName()\n    {\n        return \"plugin-info\";\n    }\n\n    /**\n     * Generate the mojos documentation, as xdoc files.\n     *\n     * @param pluginDescriptor not null\n     * @param locale           not null\n     * @throws MavenReportException if any\n     */\n    private void generateMojosDocumentation( PluginDescriptor pluginDescriptor, Locale locale )\n        throws MavenReportException\n    {\n        try\n        {\n            File outputDir = outputDirectory;\n            outputDir.mkdirs();\n\n            PluginXdocGenerator generator = new PluginXdocGenerator( project, locale );\n            PluginToolsRequest pluginToolsRequest = new DefaultPluginToolsRequest( project, pluginDescriptor );\n            generator.execute( outputDir, pluginToolsRequest );\n        }\n        catch ( GeneratorException e )\n        {\n            throw new MavenReportException( \"Error writing plugin documentation\", e );\n        }\n\n    }\n\n    /**\n     * @param locale not null\n     * @return the bundle for this report\n     */\n    protected static ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"plugin-report\", locale, PluginReport.class.getClassLoader() );\n    }\n\n    /**\n     * Generates an overview page with the list of goals\n     * and a link to the goal's page.\n     */\n    static class PluginOverviewRenderer\n        extends AbstractMavenReportRenderer\n    {\n        private final MavenProject project;\n\n        private final Requirements requirements;\n\n        private final PluginDescriptor pluginDescriptor;\n\n        private final Locale locale;\n\n        /**\n         * @param project          not null\n         * @param requirements     not null\n         * @param sink             not null\n         * @param pluginDescriptor not null\n         * @param locale           not null\n         */\n        public PluginOverviewRenderer( MavenProject project, Requirements requirements, Sink sink,\n                                       PluginDescriptor pluginDescriptor, Locale locale )\n        {\n            super( sink );\n\n            this.project = project;\n\n            this.requirements = ( requirements == null ? new Requirements() : requirements );\n\n            this.pluginDescriptor = pluginDescriptor;\n\n            this.locale = locale;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public String getTitle()\n        {\n            return getBundle( locale ).getString( \"report.plugin.title\" );\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @SuppressWarnings( { \"unchecked\", \"rawtypes\" } )\n        public void renderBody()\n        {\n            startSection( getTitle() );\n\n            if ( !( pluginDescriptor.getMojos() != null && pluginDescriptor.getMojos().size() > 0 ) )\n            {\n                paragraph( getBundle( locale ).getString( \"report.plugin.goals.nogoal\" ) );\n                endSection();\n                return;\n            }\n\n            paragraph( getBundle( locale ).getString( \"report.plugin.goals.intro\" ) );\n\n            boolean hasMavenReport = false;\n            for ( Iterator<MojoDescriptor> i = pluginDescriptor.getMojos().iterator(); i.hasNext(); )\n            {\n                MojoDescriptor mojo = i.next();\n\n                if ( GeneratorUtils.isMavenReport( mojo.getImplementation(), project ) )\n                {\n                    hasMavenReport = true;\n                }\n            }\n\n            startTable();\n\n            String goalColumnName = getBundle( locale ).getString( \"report.plugin.goals.column.goal\" );\n            String isMavenReport = getBundle( locale ).getString( \"report.plugin.goals.column.isMavenReport\" );\n            String descriptionColumnName = getBundle( locale ).getString( \"report.plugin.goals.column.description\" );\n            if ( hasMavenReport )\n            {\n                tableHeader( new String[]{ goalColumnName, isMavenReport, descriptionColumnName } );\n            }\n            else\n            {\n                tableHeader( new String[]{ goalColumnName, descriptionColumnName } );\n            }\n\n            List<MojoDescriptor> mojos = new ArrayList<MojoDescriptor>();\n            mojos.addAll( pluginDescriptor.getMojos() );\n            PluginUtils.sortMojos( mojos );\n            for ( MojoDescriptor mojo : mojos )\n            {\n                String goalName = mojo.getFullGoalName();\n\n                /*\n                 * Added ./ to define a relative path\n                 * @see AbstractMavenReportRenderer#getValidHref(java.lang.String)\n                 */\n                String goalDocumentationLink = \"./\" + mojo.getGoal() + \"-mojo.html\";\n\n                String description;\n                if ( StringUtils.isNotEmpty( mojo.getDeprecated() ) )\n                {\n                    description =\n                        \"<strong>\" + getBundle( locale ).getString( \"report.plugin.goal.deprecated\" ) + \"<\/strong> \"\n                            + GeneratorUtils.makeHtmlValid( mojo.getDeprecated() );\n                }\n                else if ( StringUtils.isNotEmpty( mojo.getDescription() ) )\n                {\n                    description = GeneratorUtils.makeHtmlValid( mojo.getDescription() );\n                }\n                else\n                {\n                    description = getBundle( locale ).getString( \"report.plugin.goal.nodescription\" );\n                }\n\n                sink.tableRow();\n                tableCell( createLinkPatternedText( goalName, goalDocumentationLink ) );\n                if ( hasMavenReport )\n                {\n                    if ( GeneratorUtils.isMavenReport( mojo.getImplementation(), project ) )\n                    {\n                        sink.tableCell();\n                        sink.text( getBundle( locale ).getString( \"report.plugin.isReport\" ) );\n                        sink.tableCell_();\n                    }\n                    else\n                    {\n                        sink.tableCell();\n                        sink.text( getBundle( locale ).getString( \"report.plugin.isNotReport\" ) );\n                        sink.tableCell_();\n                    }\n                }\n                tableCell( description, true );\n                sink.tableRow_();\n            }\n\n            endTable();\n\n            startSection( getBundle( locale ).getString( \"report.plugin.systemrequirements\" ) );\n\n            paragraph( getBundle( locale ).getString( \"report.plugin.systemrequirements.intro\" ) );\n\n            startTable();\n\n            String maven = discoverMavenRequirement( project, requirements );\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.maven\" ) );\n            tableCell( ( maven != null\n                ? maven\n                : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            String jdk = discoverJdkRequirement( project, requirements );\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.jdk\" ) );\n            tableCell(\n                ( jdk != null ? jdk : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.memory\" ) );\n            tableCell( ( StringUtils.isNotEmpty( requirements.getMemory() )\n                ? requirements.getMemory()\n                : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.diskspace\" ) );\n            tableCell( ( StringUtils.isNotEmpty( requirements.getDiskSpace() )\n                ? requirements.getDiskSpace()\n                : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            if ( requirements.getOthers() != null && requirements.getOthers().size() > 0 )\n            {\n                for ( Iterator it = requirements.getOthers().keySet().iterator(); it.hasNext(); )\n                {\n                    String key = it.next().toString();\n\n                    sink.tableRow();\n                    tableCell( key );\n                    tableCell( ( StringUtils.isNotEmpty( requirements.getOthers().getProperty( key ) )\n                        ? requirements.getOthers().getProperty( key )\n                        : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n                    sink.tableRow_();\n                }\n            }\n            endTable();\n\n            endSection();\n\n            renderUsageSection( hasMavenReport );\n\n            endSection();\n        }\n\n        /**\n         * Render the section about the usage of the plugin.\n         *\n         * @param hasMavenReport If the plugin has a report or not\n         */\n        private void renderUsageSection( boolean hasMavenReport )\n        {\n            startSection( getBundle( locale ).getString( \"report.plugin.usage\" ) );\n\n            // Configuration\n            sink.paragraph();\n            text( getBundle( locale ).getString( \"report.plugin.usage.intro\" ) );\n            sink.paragraph_();\n\n            StringBuilder sb = new StringBuilder();\n            sb.append( \"<project>\" ).append( '\\n' );\n            sb.append( \"  ...\" ).append( '\\n' );\n            sb.append( \"  <build>\" ).append( '\\n' );\n            sb.append(\n                \"    <!-- \" + getBundle( locale ).getString( \"report.plugin.usage.pluginManagement\" ) + \" -->\" ).append(\n                '\\n' );\n            sb.append( \"    <pluginManagement>\" ).append( '\\n' );\n            sb.append( \"      <plugins>\" ).append( '\\n' );\n            sb.append( \"        <plugin>\" ).append( '\\n' );\n            sb.append( \"          <groupId>\" ).append( pluginDescriptor.getGroupId() ).append( \"<\/groupId>\" ).append(\n                '\\n' );\n            sb.append( \"          <artifactId>\" ).append( pluginDescriptor.getArtifactId() ).append(\n                \"<\/artifactId>\" ).append( '\\n' );\n            sb.append( \"          <version>\" ).append( pluginDescriptor.getVersion() ).append( \"<\/version>\" ).append(\n                '\\n' );\n            sb.append( \"        <\/plugin>\" ).append( '\\n' );\n            sb.append( \"        ...\" ).append( '\\n' );\n            sb.append( \"      <\/plugins>\" ).append( '\\n' );\n            sb.append( \"    <\/pluginManagement>\" ).append( '\\n' );\n            sb.append( \"    <!-- \" + getBundle( locale ).getString( \"report.plugin.usage.plugins\" ) + \" -->\" ).append(\n                '\\n' );\n            sb.append( \"    <plugins>\" ).append( '\\n' );\n            sb.append( \"      <plugin>\" ).append( '\\n' );\n            sb.append( \"        <groupId>\" ).append( pluginDescriptor.getGroupId() ).append( \"<\/groupId>\" ).append(\n                '\\n' );\n            sb.append( \"        <artifactId>\" ).append( pluginDescriptor.getArtifactId() ).append(\n                \"<\/artifactId>\" ).append( '\\n' );\n            sb.append( \"        <version>\" ).append( pluginDescriptor.getVersion() ).append( \"<\/version>\" ).append(\n                '\\n' );\n            sb.append( \"      <\/plugin>\" ).append( '\\n' );\n            sb.append( \"      ...\" ).append( '\\n' );\n            sb.append( \"    <\/plugins>\" ).append( '\\n' );\n            sb.append( \"  <\/build>\" ).append( '\\n' );\n\n            if ( hasMavenReport )\n            {\n                sb.append( \"  ...\" ).append( '\\n' );\n                sb.append(\n                    \"  <!-- \" + getBundle( locale ).getString( \"report.plugin.usage.reporting\" ) + \" -->\" ).append(\n                    '\\n' );\n                sb.append( \"  <reporting>\" ).append( '\\n' );\n                sb.append( \"    <plugins>\" ).append( '\\n' );\n                sb.append( \"      <plugin>\" ).append( '\\n' );\n                sb.append( \"        <groupId>\" ).append( pluginDescriptor.getGroupId() ).append( \"<\/groupId>\" ).append(\n                    '\\n' );\n                sb.append( \"        <artifactId>\" ).append( pluginDescriptor.getArtifactId() ).append(\n                    \"<\/artifactId>\" ).append( '\\n' );\n                sb.append( \"        <version>\" ).append( pluginDescriptor.getVersion() ).append( \"<\/version>\" ).append(\n                    '\\n' );\n                sb.append( \"      <\/plugin>\" ).append( '\\n' );\n                sb.append( \"      ...\" ).append( '\\n' );\n                sb.append( \"    <\/plugins>\" ).append( '\\n' );\n                sb.append( \"  <\/reporting>\" ).append( '\\n' );\n            }\n\n            sb.append( \"  ...\" ).append( '\\n' );\n            sb.append( \"<\/project>\" ).append( '\\n' );\n\n            verbatimText( sb.toString() );\n\n            sink.paragraph();\n            linkPatternedText( getBundle( locale ).getString( \"report.plugin.configuration.end\" ) );\n            sink.paragraph_();\n\n            endSection();\n        }\n\n        /**\n         * Try to lookup on the Maven prerequisites property.\n         * If not specified, uses the value defined by the user.\n         *\n         * @param project      not null\n         * @param requirements not null\n         * @return the Maven version\n         */\n        private static String discoverMavenRequirement( MavenProject project, Requirements requirements )\n        {\n            String maven = requirements.getMaven();\n            if ( maven == null )\n            {\n                maven = ( project.getPrerequisites() != null ? project.getPrerequisites().getMaven() : null );\n            }\n            if ( maven == null )\n            {\n                maven = \"2.0\";\n            }\n\n            return maven;\n        }\n\n        /**\n         * <ol>\n         * <li>use configured jdk requirement<\/li>\n         * <li>use <code>target<\/code> configuration of <code>org.apache.maven.plugins:maven-compiler-plugin<\/code><\/li>\n         * <li>use <code>target<\/code> configuration of <code>org.apache.maven.plugins:maven-compiler-plugin<\/code> in\n         * <code>pluginManagement<\/code><\/li>\n         * <li>use <code>maven.compiler.target<\/code> property<\/li>\n         * <\/ol>\n         *\n         * @param project      not null\n         * @param requirements not null\n         * @return the JDK version\n         */\n        private static String discoverJdkRequirement( MavenProject project, Requirements requirements )\n        {\n            String jdk = requirements.getJdk();\n\n            if ( jdk != null )\n            {\n                return jdk;\n            }\n\n            Plugin compiler = getCompilerPlugin( project.getBuild().getPluginsAsMap() );\n\n            jdk = getTarget( compiler );\n            if ( jdk != null )\n            {\n                return jdk;\n            }\n\n            Plugin compilerManagement = getCompilerPlugin( project.getPluginManagement().getPluginsAsMap() );\n\n            jdk = getTarget( compilerManagement );\n            if ( jdk != null )\n            {\n                return jdk;\n            }\n\n            // default value\n            jdk = project.getProperties().getProperty( \"maven.compiler.target\" );\n            if ( jdk != null )\n            {\n                return jdk;\n            }\n\n            String version = getVersion( compiler );\n\n            if ( version == null )\n            {\n                version = getVersion( compilerManagement );\n            }\n\n            if ( version != null )\n            {\n                return \"Default target for maven-compiler-plugin version \" + version;\n            }\n\n            return \"Unknown\";\n        }\n\n        private static Plugin getCompilerPlugin( Map<String, Object> pluginsAsMap )\n        {\n            for ( Map.Entry<String, Object> entry : pluginsAsMap.entrySet() )\n            {\n                if ( entry.getKey().equals( \"org.apache.maven.plugins:maven-compiler-plugin\" ) )\n                {\n                    return (Plugin) entry.getValue();\n                }\n            }\n            return null;\n        }\n\n        private static String getTarget( Plugin plugin )\n        {\n            if ( plugin != null )\n            {\n                Xpp3Dom pluginConf = (Xpp3Dom) plugin.getConfiguration();\n\n                if ( pluginConf != null )\n                {\n                    Xpp3Dom target = pluginConf.getChild( \"target\" );\n\n                    if ( target != null )\n                    {\n                        return target.getValue();\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        private static String getVersion( Plugin plugin )\n        {\n            if ( plugin != null )\n            {\n                return plugin.getVersion();\n            }\n\n            return null;\n        }\n\n        /**\n         * @param pluginsAsMap could be null\n         * @return the value of the <code>target<\/code> in the configuration of <code>maven-compiler-plugin<\/code>.\n         */\n        private static String discoverJdkRequirementFromPlugins( Map<String, Object> pluginsAsMap, Properties props )\n        {\n            if ( pluginsAsMap == null )\n            {\n                return null;\n            }\n\n            // default value\n            String jdk = props.getProperty( \"maven.compiler.target\" );\n\n            String backupJdk = null;\n            for ( Map.Entry<String, Object> entry : pluginsAsMap.entrySet() )\n            {\n                if ( !entry.getKey().equals( \"org.apache.maven.plugins:maven-compiler-plugin\" ) )\n                {\n                    continue;\n                }\n\n                Object value = entry.getValue();\n                Xpp3Dom pluginConf = null;\n\n                backupJdk = \"Default version for maven-compiler-plugin\";\n                if ( value instanceof Plugin )\n                {\n                    Plugin plugin = (Plugin) value;\n                    backupJdk = \"Default target for maven-compiler-plugin version \" + plugin.getVersion();\n                    pluginConf = (Xpp3Dom) plugin.getConfiguration();\n                }\n\n                if ( value instanceof ReportPlugin )\n                {\n                    ReportPlugin reportPlugin = (ReportPlugin) value;\n                    backupJdk = \"Default target for maven-compiler-plugin version \" + reportPlugin.getVersion();\n                    pluginConf = (Xpp3Dom) reportPlugin.getConfiguration();\n                }\n\n                if ( pluginConf == null )\n                {\n                    continue;\n                }\n\n                Xpp3Dom target = pluginConf.getChild( \"target\" );\n                if ( target != null )\n                {\n                    jdk = target.getValue();\n                }\n            }\n\n            return ( jdk == null ) ? backupJdk : jdk;\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.plugin.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.Renderer;\nimport org.apache.maven.model.Plugin;\nimport org.apache.maven.model.ReportPlugin;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.AbstractMavenReport;\nimport org.apache.maven.reporting.AbstractMavenReportRenderer;\nimport org.apache.maven.reporting.MavenReportException;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.generator.GeneratorException;\nimport org.apache.maven.tools.plugin.generator.GeneratorUtils;\nimport org.apache.maven.tools.plugin.generator.PluginXdocGenerator;\nimport org.apache.maven.tools.plugin.scanner.MojoScanner;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.component.repository.ComponentDependency;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.Xpp3Dom;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.ResourceBundle;\nimport java.util.Set;\n\n/**\n * Generates the Plugin's documentation report: <code>plugin-info.html<\/code> plugin overview page,\n * and one <code><i>goal<\/i>-mojo.html<\/code> per goal.\n *\n * @author <a href=\"snicoll@apache.org\">Stephane Nicoll<\/a>\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.0\n */\n@Mojo( name = \"report\", threadSafe = true )\n@Execute( phase = LifecyclePhase.PROCESS_CLASSES )\npublic class PluginReport\n    extends AbstractMavenReport\n{\n    /**\n     * Report output directory for mojos' documentation.\n     */\n    @Parameter( defaultValue = \"${project.build.directory}/generated-site/xdoc\" )\n    private File outputDirectory;\n\n    /**\n     * Doxia Site Renderer.\n     */\n    @Component\n    private Renderer siteRenderer;\n\n    /**\n     * The Maven Project.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true )\n    private MavenProject project;\n\n    /**\n     * Mojo scanner tools.\n     */\n    @Component\n    protected MojoScanner mojoScanner;\n\n    /**\n     * The file encoding of the source files.\n     *\n     * @since 2.7\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specify some requirements to execute this plugin.\n     * Example:\n     * <pre>\n     * &lt;requirements&gt;\n     *   &lt;maven&gt;2.0&lt;/maven&gt;\n     *   &lt;jdk&gt;1.4&lt;/jdk&gt;\n     *   &lt;memory&gt;256m&lt;/memory&gt;\n     *   &lt;diskSpace&gt;1m&lt;/diskSpace&gt;\n     *   &lt;others&gt;\n     *     &lt;property&gt;\n     *       &lt;name&gt;SVN&lt;/name&gt;\n     *       &lt;value&gt;1.4.6&lt;/value&gt;\n     *     &lt;/property&gt;\n     *   &lt;/others&gt;\n     * &lt;/requirements&gt;\n     * <\/pre>\n     */\n    @Parameter\n    private Requirements requirements;\n\n    /**\n     * The goal prefix that will appear before the \":\".\n     * By default, this plugin applies a heuristic to derive a heuristic from\n     * the plugin's artifactId.\n     * <p/>\n     * It removes any occurrences of the regular expression <strong>-?maven-?<\/strong>,\n     * and then removes any occurrences of <strong>-?plugin-?<\/strong>.\n     * <p>\n     * For example, horsefeature-maven-plugin becomes horsefeature.\n     * <\/p>\n     * <p>\n     * (There is a special for maven-plugin-plugin; it is mapped to 'plugin'.\n     * <\/p>\n     *\n     * @since 2.4\n     */\n    @Parameter( property = \"goalPrefix\" )\n    protected String goalPrefix;\n\n    /**\n     * Set this to \"true\" to skip invoking any goals or reports of the plugin.\n     *\n     * @since 2.8\n     */\n    @Parameter( defaultValue = \"false\", property = \"maven.plugin.skip\" )\n    private boolean skip;\n\n    /**\n     * Set this to \"true\" to skip generating the report.\n     *\n     * @since 2.8\n     */\n    @Parameter( defaultValue = \"false\", property = \"maven.plugin.report.skip\" )\n    private boolean skipReport;\n\n    /**\n     * The set of dependencies for the current project\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${project.artifacts}\", required = true, readonly = true )\n    protected Set<Artifact> dependencies;\n\n    /**\n     * List of Remote Repositories used by the resolver\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${project.remoteArtifactRepositories}\", required = true, readonly = true )\n    protected List<ArtifactRepository> remoteRepos;\n\n    /**\n     * Location of the local repository.\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${localRepository}\", required = true, readonly = true )\n    protected ArtifactRepository local;\n\n    /**\n     * {@inheritDoc}\n     */\n    protected Renderer getSiteRenderer()\n    {\n        return siteRenderer;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected String getOutputDirectory()\n    {\n        // PLUGIN-191: output directory of plugin.html, not *-mojo.xml\n        return project.getReporting().getOutputDirectory();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected MavenProject getProject()\n    {\n        return project;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean canGenerateReport()\n    {\n        return \"maven-plugin\".equals( project.getPackaging() );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings( \"unchecked\" )\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( !canGenerateReport() )\n        {\n            return;\n        }\n        if ( skip || skipReport )\n        {\n            getLog().info( \"Maven Plugin Plugin Report generation skipped.\" );\n            return;\n        }\n\n        PluginDescriptor pluginDescriptor = extractPluginDescriptor();\n\n        // Generate the mojos' documentation\n        generateMojosDocumentation( pluginDescriptor, locale );\n\n        // Write the overview\n        PluginOverviewRenderer r =\n            new PluginOverviewRenderer( project, requirements, getSink(), pluginDescriptor, locale );\n        r.render();\n    }\n\n    private PluginDescriptor extractPluginDescriptor()\n        throws MavenReportException\n    {\n        // Copy from AbstractGeneratorMojo#execute()\n        String defaultGoalPrefix = PluginDescriptor.getGoalPrefixFromArtifactId( project.getArtifactId() );\n        if ( goalPrefix == null )\n        {\n            goalPrefix = defaultGoalPrefix;\n        }\n        else\n        {\n            getLog().warn( \"\\n\\nGoal prefix is specified as: '\" + goalPrefix + \"'. Maven currently expects it to be '\"\n                               + defaultGoalPrefix + \"'.\\n\" );\n        }\n\n        // TODO: could use this more, eg in the writing of the plugin descriptor!\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.setGroupId( project.getGroupId() );\n\n        pluginDescriptor.setArtifactId( project.getArtifactId() );\n\n        pluginDescriptor.setVersion( project.getVersion() );\n\n        pluginDescriptor.setGoalPrefix( goalPrefix );\n\n        try\n        {\n            List<ComponentDependency> deps = GeneratorUtils.toComponentDependencies( project.getRuntimeDependencies() );\n            pluginDescriptor.setDependencies( deps );\n\n            PluginToolsRequest request = new DefaultPluginToolsRequest( project, pluginDescriptor );\n            request.setEncoding( encoding );\n            request.setSkipErrorNoDescriptorsFound( true );\n            request.setDependencies( dependencies );\n            request.setLocal( this.local );\n            request.setRemoteRepos( this.remoteRepos );\n\n            try\n            {\n                mojoScanner.populatePluginDescriptor( request );\n            }\n            catch ( InvalidPluginDescriptorException e )\n            {\n                // this is OK, it happens to lifecycle plugins. Allow generation to proceed.\n                getLog().debug( \"Plugin without mojos.\", e );\n            }\n        }\n        catch ( ExtractionException e )\n        {\n            throw new MavenReportException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                            e );\n        }\n        return pluginDescriptor;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription( Locale locale )\n    {\n        return getBundle( locale ).getString( \"report.plugin.description\" );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getName( Locale locale )\n    {\n        return getBundle( locale ).getString( \"report.plugin.name\" );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getOutputName()\n    {\n        return \"plugin-info\";\n    }\n\n    /**\n     * Generate the mojos documentation, as xdoc files.\n     *\n     * @param pluginDescriptor not null\n     * @param locale           not null\n     * @throws MavenReportException if any\n     */\n    private void generateMojosDocumentation( PluginDescriptor pluginDescriptor, Locale locale )\n        throws MavenReportException\n    {\n        try\n        {\n            File outputDir = outputDirectory;\n            outputDir.mkdirs();\n\n            PluginXdocGenerator generator = new PluginXdocGenerator( project, locale );\n            PluginToolsRequest pluginToolsRequest = new DefaultPluginToolsRequest( project, pluginDescriptor );\n            generator.execute( outputDir, pluginToolsRequest );\n        }\n        catch ( GeneratorException e )\n        {\n            throw new MavenReportException( \"Error writing plugin documentation\", e );\n        }\n\n    }\n\n    /**\n     * @param locale not null\n     * @return the bundle for this report\n     */\n    protected static ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"plugin-report\", locale, PluginReport.class.getClassLoader() );\n    }\n\n    /**\n     * Generates an overview page with the list of goals\n     * and a link to the goal's page.\n     */\n    static class PluginOverviewRenderer\n        extends AbstractMavenReportRenderer\n    {\n        private final MavenProject project;\n\n        private final Requirements requirements;\n\n        private final PluginDescriptor pluginDescriptor;\n\n        private final Locale locale;\n\n        /**\n         * @param project          not null\n         * @param requirements     not null\n         * @param sink             not null\n         * @param pluginDescriptor not null\n         * @param locale           not null\n         */\n        public PluginOverviewRenderer( MavenProject project, Requirements requirements, Sink sink,\n                                       PluginDescriptor pluginDescriptor, Locale locale )\n        {\n            super( sink );\n\n            this.project = project;\n\n            this.requirements = ( requirements == null ? new Requirements() : requirements );\n\n            this.pluginDescriptor = pluginDescriptor;\n\n            this.locale = locale;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public String getTitle()\n        {\n            return getBundle( locale ).getString( \"report.plugin.title\" );\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @SuppressWarnings( { \"unchecked\", \"rawtypes\" } )\n        public void renderBody()\n        {\n            startSection( getTitle() );\n\n            if ( !( pluginDescriptor.getMojos() != null && pluginDescriptor.getMojos().size() > 0 ) )\n            {\n                paragraph( getBundle( locale ).getString( \"report.plugin.goals.nogoal\" ) );\n                endSection();\n                return;\n            }\n\n            paragraph( getBundle( locale ).getString( \"report.plugin.goals.intro\" ) );\n\n            boolean hasMavenReport = false;\n            for ( Iterator<MojoDescriptor> i = pluginDescriptor.getMojos().iterator(); i.hasNext(); )\n            {\n                MojoDescriptor mojo = i.next();\n\n                if ( GeneratorUtils.isMavenReport( mojo.getImplementation(), project ) )\n                {\n                    hasMavenReport = true;\n                }\n            }\n\n            startTable();\n\n            String goalColumnName = getBundle( locale ).getString( \"report.plugin.goals.column.goal\" );\n            String isMavenReport = getBundle( locale ).getString( \"report.plugin.goals.column.isMavenReport\" );\n            String descriptionColumnName = getBundle( locale ).getString( \"report.plugin.goals.column.description\" );\n            if ( hasMavenReport )\n            {\n                tableHeader( new String[]{ goalColumnName, isMavenReport, descriptionColumnName } );\n            }\n            else\n            {\n                tableHeader( new String[]{ goalColumnName, descriptionColumnName } );\n            }\n\n            List<MojoDescriptor> mojos = new ArrayList<MojoDescriptor>();\n            mojos.addAll( pluginDescriptor.getMojos() );\n            PluginUtils.sortMojos( mojos );\n            for ( MojoDescriptor mojo : mojos )\n            {\n                String goalName = mojo.getFullGoalName();\n\n                /*\n                 * Added ./ to define a relative path\n                 * @see AbstractMavenReportRenderer#getValidHref(java.lang.String)\n                 */\n                String goalDocumentationLink = \"./\" + mojo.getGoal() + \"-mojo.html\";\n\n                String description;\n                if ( StringUtils.isNotEmpty( mojo.getDeprecated() ) )\n                {\n                    description =\n                        \"<strong>\" + getBundle( locale ).getString( \"report.plugin.goal.deprecated\" ) + \"<\/strong> \"\n                            + GeneratorUtils.makeHtmlValid( mojo.getDeprecated() );\n                }\n                else if ( StringUtils.isNotEmpty( mojo.getDescription() ) )\n                {\n                    description = GeneratorUtils.makeHtmlValid( mojo.getDescription() );\n                }\n                else\n                {\n                    description = getBundle( locale ).getString( \"report.plugin.goal.nodescription\" );\n                }\n\n                sink.tableRow();\n                tableCell( createLinkPatternedText( goalName, goalDocumentationLink ) );\n                if ( hasMavenReport )\n                {\n                    if ( GeneratorUtils.isMavenReport( mojo.getImplementation(), project ) )\n                    {\n                        sink.tableCell();\n                        sink.text( getBundle( locale ).getString( \"report.plugin.isReport\" ) );\n                        sink.tableCell_();\n                    }\n                    else\n                    {\n                        sink.tableCell();\n                        sink.text( getBundle( locale ).getString( \"report.plugin.isNotReport\" ) );\n                        sink.tableCell_();\n                    }\n                }\n                tableCell( description, true );\n                sink.tableRow_();\n            }\n\n            endTable();\n\n            startSection( getBundle( locale ).getString( \"report.plugin.systemrequirements\" ) );\n\n            paragraph( getBundle( locale ).getString( \"report.plugin.systemrequirements.intro\" ) );\n\n            startTable();\n\n            String maven = discoverMavenRequirement( project, requirements );\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.maven\" ) );\n            tableCell( ( maven != null\n                ? maven\n                : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            String jdk = discoverJdkRequirement( project, requirements );\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.jdk\" ) );\n            tableCell(\n                ( jdk != null ? jdk : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.memory\" ) );\n            tableCell( ( StringUtils.isNotEmpty( requirements.getMemory() )\n                ? requirements.getMemory()\n                : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.diskspace\" ) );\n            tableCell( ( StringUtils.isNotEmpty( requirements.getDiskSpace() )\n                ? requirements.getDiskSpace()\n                : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            if ( requirements.getOthers() != null && requirements.getOthers().size() > 0 )\n            {\n                for ( Iterator it = requirements.getOthers().keySet().iterator(); it.hasNext(); )\n                {\n                    String key = it.next().toString();\n\n                    sink.tableRow();\n                    tableCell( key );\n                    tableCell( ( StringUtils.isNotEmpty( requirements.getOthers().getProperty( key ) )\n                        ? requirements.getOthers().getProperty( key )\n                        : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n                    sink.tableRow_();\n                }\n            }\n            endTable();\n\n            endSection();\n\n            renderUsageSection( hasMavenReport );\n\n            endSection();\n        }\n\n        /**\n         * Render the section about the usage of the plugin.\n         *\n         * @param hasMavenReport If the plugin has a report or not\n         */\n        private void renderUsageSection( boolean hasMavenReport )\n        {\n            startSection( getBundle( locale ).getString( \"report.plugin.usage\" ) );\n\n            // Configuration\n            sink.paragraph();\n            text( getBundle( locale ).getString( \"report.plugin.usage.intro\" ) );\n            sink.paragraph_();\n\n            StringBuilder sb = new StringBuilder();\n            sb.append( \"<project>\" ).append( '\\n' );\n            sb.append( \"  ...\" ).append( '\\n' );\n            sb.append( \"  <build>\" ).append( '\\n' );\n            sb.append(\n                \"    <!-- \" + getBundle( locale ).getString( \"report.plugin.usage.pluginManagement\" ) + \" -->\" ).append(\n                '\\n' );\n            sb.append( \"    <pluginManagement>\" ).append( '\\n' );\n            sb.append( \"      <plugins>\" ).append( '\\n' );\n            sb.append( \"        <plugin>\" ).append( '\\n' );\n            sb.append( \"          <groupId>\" ).append( pluginDescriptor.getGroupId() ).append( \"<\/groupId>\" ).append(\n                '\\n' );\n            sb.append( \"          <artifactId>\" ).append( pluginDescriptor.getArtifactId() ).append(\n                \"<\/artifactId>\" ).append( '\\n' );\n            sb.append( \"          <version>\" ).append( pluginDescriptor.getVersion() ).append( \"<\/version>\" ).append(\n                '\\n' );\n            sb.append( \"        <\/plugin>\" ).append( '\\n' );\n            sb.append( \"        ...\" ).append( '\\n' );\n            sb.append( \"      <\/plugins>\" ).append( '\\n' );\n            sb.append( \"    <\/pluginManagement>\" ).append( '\\n' );\n            sb.append( \"    <!-- \" + getBundle( locale ).getString( \"report.plugin.usage.plugins\" ) + \" -->\" ).append(\n                '\\n' );\n            sb.append( \"    <plugins>\" ).append( '\\n' );\n            sb.append( \"      <plugin>\" ).append( '\\n' );\n            sb.append( \"        <groupId>\" ).append( pluginDescriptor.getGroupId() ).append( \"<\/groupId>\" ).append(\n                '\\n' );\n            sb.append( \"        <artifactId>\" ).append( pluginDescriptor.getArtifactId() ).append(\n                \"<\/artifactId>\" ).append( '\\n' );\n            sb.append( \"        <version>\" ).append( pluginDescriptor.getVersion() ).append( \"<\/version>\" ).append(\n                '\\n' );\n            sb.append( \"      <\/plugin>\" ).append( '\\n' );\n            sb.append( \"      ...\" ).append( '\\n' );\n            sb.append( \"    <\/plugins>\" ).append( '\\n' );\n            sb.append( \"  <\/build>\" ).append( '\\n' );\n\n            if ( hasMavenReport )\n            {\n                sb.append( \"  ...\" ).append( '\\n' );\n                sb.append(\n                    \"  <!-- \" + getBundle( locale ).getString( \"report.plugin.usage.reporting\" ) + \" -->\" ).append(\n                    '\\n' );\n                sb.append( \"  <reporting>\" ).append( '\\n' );\n                sb.append( \"    <plugins>\" ).append( '\\n' );\n                sb.append( \"      <plugin>\" ).append( '\\n' );\n                sb.append( \"        <groupId>\" ).append( pluginDescriptor.getGroupId() ).append( \"<\/groupId>\" ).append(\n                    '\\n' );\n                sb.append( \"        <artifactId>\" ).append( pluginDescriptor.getArtifactId() ).append(\n                    \"<\/artifactId>\" ).append( '\\n' );\n                sb.append( \"        <version>\" ).append( pluginDescriptor.getVersion() ).append( \"<\/version>\" ).append(\n                    '\\n' );\n                sb.append( \"      <\/plugin>\" ).append( '\\n' );\n                sb.append( \"      ...\" ).append( '\\n' );\n                sb.append( \"    <\/plugins>\" ).append( '\\n' );\n                sb.append( \"  <\/reporting>\" ).append( '\\n' );\n            }\n\n            sb.append( \"  ...\" ).append( '\\n' );\n            sb.append( \"<\/project>\" ).append( '\\n' );\n\n            verbatimText( sb.toString() );\n\n            sink.paragraph();\n            linkPatternedText( getBundle( locale ).getString( \"report.plugin.configuration.end\" ) );\n            sink.paragraph_();\n\n            endSection();\n        }\n\n        /**\n         * Try to lookup on the Maven prerequisites property.\n         * If not specified, uses the value defined by the user.\n         *\n         * @param project      not null\n         * @param requirements not null\n         * @return the Maven version\n         */\n        private static String discoverMavenRequirement( MavenProject project, Requirements requirements )\n        {\n            String maven = requirements.getMaven();\n            if ( maven == null )\n            {\n                maven = ( project.getPrerequisites() != null ? project.getPrerequisites().getMaven() : null );\n            }\n            if ( maven == null )\n            {\n                maven = \"2.0\";\n            }\n\n            return maven;\n        }\n\n        /**\n         * Try to lookup on the <code>org.apache.maven.plugins:maven-compiler-plugin<\/code> plugin to\n         * find the value of the <code>target<\/code> option.\n         * If not specified, uses the value defined by the user.\n         * If not specified, uses the value of the system property <code>java.specification.version<\/code>.\n         *\n         * @param project      not null\n         * @param requirements not null\n         * @return the JDK version\n         */\n        private static String discoverJdkRequirement( MavenProject project, Requirements requirements )\n        {\n            String jdk = requirements.getJdk();\n            if ( jdk == null )\n            {\n                jdk = discoverJdkRequirementFromPlugins( project.getBuild().getPluginsAsMap(),\n                                                         project.getProperties() );\n            }\n            if ( jdk == null && project.getPluginManagement() != null )\n            {\n                jdk =\n                    discoverJdkRequirementFromPlugins( project.getPluginManagement().getPluginsAsMap(),\n                                                       project.getProperties() );\n            }\n            if ( jdk == null )\n            {\n                jdk = \"Unknown\";\n            }\n\n            return jdk;\n        }\n\n        /**\n         * @param pluginsAsMap could be null\n         * @return the value of the <code>target<\/code> in the configuration of <code>maven-compiler-plugin<\/code>.\n         */\n        private static String discoverJdkRequirementFromPlugins( Map<String, Object> pluginsAsMap, Properties props )\n        {\n            if ( pluginsAsMap == null )\n            {\n                return null;\n            }\n\n            // default value\n            String jdk = props.getProperty( \"maven.compiler.target\" );\n\n            String backupJdk = null;\n            for ( Map.Entry<String, Object> entry : pluginsAsMap.entrySet() )\n            {\n                if ( !entry.getKey().equals( \"org.apache.maven.plugins:maven-compiler-plugin\" ) )\n                {\n                    continue;\n                }\n\n                Object value = entry.getValue();\n                Xpp3Dom pluginConf = null;\n\n                backupJdk = \"Default version for maven-compiler-plugin\";\n                if ( value instanceof Plugin )\n                {\n                    Plugin plugin = (Plugin) value;\n                    backupJdk = \"Default target for maven-compiler-plugin version \" + plugin.getVersion();\n                    pluginConf = (Xpp3Dom) plugin.getConfiguration();\n                }\n\n                if ( value instanceof ReportPlugin )\n                {\n                    ReportPlugin reportPlugin = (ReportPlugin) value;\n                    backupJdk = \"Default target for maven-compiler-plugin version \" + reportPlugin.getVersion();\n                    pluginConf = (Xpp3Dom) reportPlugin.getConfiguration();\n                }\n\n                if ( pluginConf == null )\n                {\n                    continue;\n                }\n\n                Xpp3Dom target = pluginConf.getChild( \"target\" );\n                if ( target != null )\n                {\n                    jdk = target.getValue();\n                }\n            }\n\n            return ( jdk == null ) ? backupJdk : jdk;\n        }\n    }\n}\n","lineNo":695}
{"Refactored Sample":"package org.apache.maven.plugin.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.generator.Generator;\nimport org.apache.maven.tools.plugin.generator.GeneratorException;\nimport org.apache.maven.tools.plugin.generator.GeneratorUtils;\nimport org.apache.maven.tools.plugin.scanner.MojoScanner;\nimport org.codehaus.plexus.component.repository.ComponentDependency;\nimport org.codehaus.plexus.util.ReaderFactory;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Abstract class for this Plugin.\n *\n * @author <a href=\"mailto:jason@maven.org\">Jason van Zyl<\/a>\n * @version $Id$\n */\npublic abstract class AbstractGeneratorMojo\n    extends AbstractMojo\n{\n    /**\n     * The project currently being built.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true )\n    protected MavenProject project;\n\n    /**\n     * The component used for scanning the source tree for mojos.\n     */\n    @Component\n    protected MojoScanner mojoScanner;\n\n    /**\n     * The file encoding of the source files.\n     *\n     * @since 2.5\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    protected String encoding;\n\n    /**\n     * The goal prefix that will appear before the \":\".\n     */\n    @Parameter\n    protected String goalPrefix;\n\n    /**\n     * By default an exception is throw if no mojo descriptor is found. As the maven-plugin is defined in core, the\n     * descriptor generator mojo is bound to generate-resources phase.\n     * But for annotations, the compiled classes are needed, so skip error\n     *\n     * @since 3.0\n     */\n    @Parameter( property = \"maven.plugin.skipErrorNoDescriptorsFound\", defaultValue = \"false\" )\n    protected boolean skipErrorNoDescriptorsFound;\n\n    /**\n     * The role names of mojo extractors to use.\n     * <p/>\n     * If not set, all mojo extractors will be used. If set to an empty extractor name, no mojo extractors\n     * will be used.\n     * <p/>\n     * Example:\n     * <p/>\n     * <pre>\n     *  &lt;!-- Use all mojo extractors --&gt;\n     *  &lt;extractors/&gt;\n     *\n     *  &lt;!-- Use no mojo extractors --&gt;\n     *  &lt;extractors&gt;\n     *      &lt;extractor/&gt;\n     *  &lt;/extractors&gt;\n     *\n     *  &lt;!-- Use only bsh mojo extractor --&gt;\n     *  &lt;extractors&gt;\n     *      &lt;extractor&gt;bsh&lt;/extractor&gt;\n     *  &lt;/extractors&gt;\n     * <\/pre>\n     */\n    @Parameter\n    protected Set<String> extractors;\n\n    /**\n     * Set this to \"true\" to skip invoking any goals or reports of the plugin.\n     *\n     * @since 2.8\n     */\n    @Parameter( defaultValue = \"false\", property = \"maven.plugin.skip\" )\n    protected boolean skip;\n\n    /**\n     * The set of dependencies for the current project\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${project.artifacts}\", required = true, readonly = true )\n    protected Set<Artifact> dependencies;\n\n    /**\n     * List of Remote Repositories used by the resolver\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${project.remoteArtifactRepositories}\", required = true, readonly = true )\n    protected List<ArtifactRepository> remoteRepos;\n\n    /**\n     * Location of the local repository.\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${localRepository}\", required = true, readonly = true )\n    protected ArtifactRepository local;\n\n    /**\n     * Maven plugin packaging types. Default is single \"maven-plugin\".\n     * \n     * @since 3.3\n     */\n    @Parameter\n    protected List<String> packagingTypes = Arrays.asList( \"maven-plugin\" );\n\n    /**\n     * @return the output directory where files will be generated.\n     */\n    protected abstract File getOutputDirectory();\n\n    /**\n     * @return the wanted <code>Generator<\/code> implementation.\n     */\n    protected abstract Generator createGenerator();\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !packagingTypes.contains( project.getPackaging() ) )\n        {\n            getLog().warn( \"Unsupported packaging type \" + project.getPackaging() + \", execution skipped\" );\n            return;\n        }\n        if ( skip )\n        {\n            getLog().warn( \"Execution skipped\" );\n            return;\n        }\n\n        if ( project.getArtifactId().toLowerCase().startsWith( \"maven-\" )\n            && project.getArtifactId().toLowerCase().endsWith( \"-plugin\" ) && !\"org.apache.maven.plugins\".equals(\n            project.getGroupId() ) )\n        {\n            getLog().error( \"\\n\\nArtifact Ids of the format maven-___-plugin are reserved for \\n\"\n                                + \"plugins in the Group Id org.apache.maven.plugins\\n\"\n                                + \"Please change your artifactId to the format ___-maven-plugin\\n\"\n                                + \"In the future this error will break the build.\\n\\n\" );\n        }\n\n        String defaultGoalPrefix = PluginDescriptor.getGoalPrefixFromArtifactId( project.getArtifactId() );\n        if ( goalPrefix == null )\n        {\n            goalPrefix = defaultGoalPrefix;\n        }\n        else if ( !goalPrefix.equals( defaultGoalPrefix ) )\n        {\n            getLog().warn(\n                \"\\n\\nGoal prefix is specified as: '\" + goalPrefix + \"'. \" + \"Maven currently expects it to be '\"\n                    + defaultGoalPrefix + \"'.\\n\" );\n        }\n\n        mojoScanner.setActiveExtractors( extractors );\n\n        // TODO: could use this more, eg in the writing of the plugin descriptor!\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.setGroupId( project.getGroupId() );\n\n        pluginDescriptor.setArtifactId( project.getArtifactId() );\n\n        pluginDescriptor.setVersion( project.getVersion() );\n\n        pluginDescriptor.setGoalPrefix( goalPrefix );\n\n        pluginDescriptor.setName( project.getName() );\n\n        pluginDescriptor.setDescription( project.getDescription() );\n\n        if ( encoding == null || encoding.length() < 1 )\n        {\n            getLog().warn( \"Using platform encoding (\" + ReaderFactory.FILE_ENCODING\n                               + \" actually) to read mojo metadata, i.e. build is platform dependent!\" );\n        }\n        else\n        {\n            getLog().info( \"Using '\" + encoding + \"' encoding to read mojo metadata.\" );\n        }\n\n        try\n        {\n            List<ComponentDependency> deps = GeneratorUtils.toComponentDependencies( project.getRuntimeDependencies() );\n            pluginDescriptor.setDependencies( deps );\n\n            PluginToolsRequest request = new DefaultPluginToolsRequest( project, pluginDescriptor );\n            request.setEncoding( encoding );\n            request.setSkipErrorNoDescriptorsFound( skipErrorNoDescriptorsFound );\n            request.setDependencies( dependencies );\n            request.setLocal( this.local );\n            request.setRemoteRepos( this.remoteRepos );\n\n            mojoScanner.populatePluginDescriptor( request );\n\n            getOutputDirectory().mkdirs();\n\n            createGenerator().execute( getOutputDirectory(), request );\n        }\n        catch ( GeneratorException e )\n        {\n            throw new MojoExecutionException( \"Error writing plugin descriptor\", e );\n        }\n        catch ( InvalidPluginDescriptorException e )\n        {\n            throw new MojoExecutionException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                              e );\n        }\n        catch ( ExtractionException e )\n        {\n            throw new MojoExecutionException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                              e );\n        }\n        catch ( LinkageError e )\n        {\n            throw new MojoExecutionException( \"The API of the mojo scanner is not compatible with this plugin version.\"\n                + \" Please check the plugin dependencies configured in the POM and ensure the versions match.\", e );\n        }\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.plugin.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.generator.Generator;\nimport org.apache.maven.tools.plugin.generator.GeneratorException;\nimport org.apache.maven.tools.plugin.generator.GeneratorUtils;\nimport org.apache.maven.tools.plugin.scanner.MojoScanner;\nimport org.codehaus.plexus.util.ReaderFactory;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Abstract class for this Plugin.\n *\n * @author <a href=\"mailto:jason@maven.org\">Jason van Zyl<\/a>\n * @version $Id$\n */\npublic abstract class AbstractGeneratorMojo\n    extends AbstractMojo\n{\n    /**\n     * The project currently being built.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true )\n    protected MavenProject project;\n\n    /**\n     * The component used for scanning the source tree for mojos.\n     */\n    @Component\n    protected MojoScanner mojoScanner;\n\n    /**\n     * The file encoding of the source files.\n     *\n     * @since 2.5\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    protected String encoding;\n\n    /**\n     * The goal prefix that will appear before the \":\".\n     */\n    @Parameter\n    protected String goalPrefix;\n\n    /**\n     * By default an exception is throw if no mojo descriptor is found. As the maven-plugin is defined in core, the\n     * descriptor generator mojo is bound to generate-resources phase.\n     * But for annotations, the compiled classes are needed, so skip error\n     *\n     * @since 3.0\n     */\n    @Parameter( property = \"maven.plugin.skipErrorNoDescriptorsFound\", defaultValue = \"false\" )\n    protected boolean skipErrorNoDescriptorsFound;\n\n    /**\n     * The role names of mojo extractors to use.\n     * <p/>\n     * If not set, all mojo extractors will be used. If set to an empty extractor name, no mojo extractors\n     * will be used.\n     * <p/>\n     * Example:\n     * <p/>\n     * <pre>\n     *  &lt;!-- Use all mojo extractors --&gt;\n     *  &lt;extractors/&gt;\n     *\n     *  &lt;!-- Use no mojo extractors --&gt;\n     *  &lt;extractors&gt;\n     *      &lt;extractor/&gt;\n     *  &lt;/extractors&gt;\n     *\n     *  &lt;!-- Use only bsh mojo extractor --&gt;\n     *  &lt;extractors&gt;\n     *      &lt;extractor&gt;bsh&lt;/extractor&gt;\n     *  &lt;/extractors&gt;\n     * <\/pre>\n     */\n    @Parameter\n    protected Set<String> extractors;\n\n    /**\n     * Set this to \"true\" to skip invoking any goals or reports of the plugin.\n     *\n     * @since 2.8\n     */\n    @Parameter( defaultValue = \"false\", property = \"maven.plugin.skip\" )\n    protected boolean skip;\n\n    /**\n     * The set of dependencies for the current project\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${project.artifacts}\", required = true, readonly = true )\n    protected Set<Artifact> dependencies;\n\n    /**\n     * List of Remote Repositories used by the resolver\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${project.remoteArtifactRepositories}\", required = true, readonly = true )\n    protected List<ArtifactRepository> remoteRepos;\n\n    /**\n     * Location of the local repository.\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${localRepository}\", required = true, readonly = true )\n    protected ArtifactRepository local;\n\n    /**\n     * Maven plugin packaging types. Default is single \"maven-plugin\".\n     * \n     * @since 3.3\n     */\n    @Parameter\n    protected List<String> packagingTypes = Arrays.asList( \"maven-plugin\" );\n\n    /**\n     * @return the output directory where files will be generated.\n     */\n    protected abstract File getOutputDirectory();\n\n    /**\n     * @return the wanted <code>Generator<\/code> implementation.\n     */\n    protected abstract Generator createGenerator();\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !packagingTypes.contains( project.getPackaging() ) )\n        {\n            getLog().warn( \"Unsupported packaging type \" + project.getPackaging() + \", execution skipped\" );\n            return;\n        }\n        if ( skip )\n        {\n            getLog().warn( \"Execution skipped\" );\n            return;\n        }\n\n        if ( project.getArtifactId().toLowerCase().startsWith( \"maven-\" )\n            && project.getArtifactId().toLowerCase().endsWith( \"-plugin\" ) && !\"org.apache.maven.plugins\".equals(\n            project.getGroupId() ) )\n        {\n            getLog().error( \"\\n\\nArtifact Ids of the format maven-___-plugin are reserved for \\n\"\n                                + \"plugins in the Group Id org.apache.maven.plugins\\n\"\n                                + \"Please change your artifactId to the format ___-maven-plugin\\n\"\n                                + \"In the future this error will break the build.\\n\\n\" );\n        }\n\n        String defaultGoalPrefix = PluginDescriptor.getGoalPrefixFromArtifactId( project.getArtifactId() );\n        if ( goalPrefix == null )\n        {\n            goalPrefix = defaultGoalPrefix;\n        }\n        else if ( !goalPrefix.equals( defaultGoalPrefix ) )\n        {\n            getLog().warn(\n                \"\\n\\nGoal prefix is specified as: '\" + goalPrefix + \"'. \" + \"Maven currently expects it to be '\"\n                    + defaultGoalPrefix + \"'.\\n\" );\n        }\n\n        mojoScanner.setActiveExtractors( extractors );\n\n        // TODO: could use this more, eg in the writing of the plugin descriptor!\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.setGroupId( project.getGroupId() );\n\n        pluginDescriptor.setArtifactId( project.getArtifactId() );\n\n        pluginDescriptor.setVersion( project.getVersion() );\n\n        pluginDescriptor.setGoalPrefix( goalPrefix );\n\n        pluginDescriptor.setName( project.getName() );\n\n        pluginDescriptor.setDescription( project.getDescription() );\n\n        if ( encoding == null || encoding.length() < 1 )\n        {\n            getLog().warn( \"Using platform encoding (\" + ReaderFactory.FILE_ENCODING\n                               + \" actually) to read mojo metadata, i.e. build is platform dependent!\" );\n        }\n        else\n        {\n            getLog().info( \"Using '\" + encoding + \"' encoding to read mojo metadata.\" );\n        }\n\n        try\n        {\n            pluginDescriptor.setDependencies( GeneratorUtils.toComponentDependencies( project.getRuntimeDependencies() ) );\n\n            PluginToolsRequest request = new DefaultPluginToolsRequest( project, pluginDescriptor );\n            request.setEncoding( encoding );\n            request.setSkipErrorNoDescriptorsFound( skipErrorNoDescriptorsFound );\n            request.setDependencies( dependencies );\n            request.setLocal( this.local );\n            request.setRemoteRepos( this.remoteRepos );\n\n            mojoScanner.populatePluginDescriptor( request );\n\n            getOutputDirectory().mkdirs();\n\n            createGenerator().execute( getOutputDirectory(), request );\n        }\n        catch ( GeneratorException e )\n        {\n            throw new MojoExecutionException( \"Error writing plugin descriptor\", e );\n        }\n        catch ( InvalidPluginDescriptorException e )\n        {\n            throw new MojoExecutionException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                              e );\n        }\n        catch ( ExtractionException e )\n        {\n            throw new MojoExecutionException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                              e );\n        }\n        catch ( LinkageError e )\n        {\n            throw new MojoExecutionException( \"The API of the mojo scanner is not compatible with this plugin version.\"\n                + \" Please check the plugin dependencies configured in the POM and ensure the versions match.\", e );\n        }\n    }\n\n}\n","lineNo":235}
{"Refactored Sample":"package org.apache.maven.plugin.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.Renderer;\nimport org.apache.maven.model.Plugin;\nimport org.apache.maven.model.ReportPlugin;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.AbstractMavenReport;\nimport org.apache.maven.reporting.AbstractMavenReportRenderer;\nimport org.apache.maven.reporting.MavenReportException;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.generator.GeneratorException;\nimport org.apache.maven.tools.plugin.generator.GeneratorUtils;\nimport org.apache.maven.tools.plugin.generator.PluginXdocGenerator;\nimport org.apache.maven.tools.plugin.scanner.MojoScanner;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.component.repository.ComponentDependency;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.Xpp3Dom;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.ResourceBundle;\nimport java.util.Set;\n\n/**\n * Generates the Plugin's documentation report.\n *\n * @author <a href=\"snicoll@apache.org\">Stephane Nicoll<\/a>\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.0\n */\n@Mojo( name = \"report\", threadSafe = true )\n@Execute( phase = LifecyclePhase.PROCESS_CLASSES )\npublic class PluginReport\n    extends AbstractMavenReport\n{\n    /**\n     * Report output directory for mojo pages.\n     */\n    @Parameter( defaultValue = \"${project.build.directory}/generated-site/xdoc\" )\n    private File outputDirectory;\n\n    /**\n     * Doxia Site Renderer.\n     */\n    @Component\n    private Renderer siteRenderer;\n\n    /**\n     * The Maven Project.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true )\n    private MavenProject project;\n\n    /**\n     * Mojo scanner tools.\n     */\n    @Component\n    protected MojoScanner mojoScanner;\n\n    /**\n     * The file encoding of the source files.\n     *\n     * @since 2.7\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specify some requirements to execute this plugin.\n     * Example:\n     * <pre>\n     * &lt;requirements&gt;\n     *   &lt;maven&gt;2.0&lt;/maven&gt;\n     *   &lt;jdk&gt;1.4&lt;/jdk&gt;\n     *   &lt;memory&gt;256m&lt;/memory&gt;\n     *   &lt;diskSpace&gt;1m&lt;/diskSpace&gt;\n     *   &lt;others&gt;\n     *     &lt;property&gt;\n     *       &lt;name&gt;SVN&lt;/name&gt;\n     *       &lt;value&gt;1.4.6&lt;/value&gt;\n     *     &lt;/property&gt;\n     *   &lt;/others&gt;\n     * &lt;/requirements&gt;\n     * <\/pre>\n     */\n    @Parameter\n    private Requirements requirements;\n\n    /**\n     * The goal prefix that will appear before the \":\".\n     * By default, this plugin applies a heuristic to derive a heuristic from\n     * the plugin's artifactId.\n     * <p/>\n     * It removes any occurrences of the regular expression <strong>-?maven-?<\/strong>,\n     * and then removes any occurrences of <strong>-?plugin-?<\/strong>.\n     * <p>\n     * For example, horsefeature-maven-plugin becomes horsefeature.\n     * <\/p>\n     * <p>\n     * (There is a special for maven-plugin-plugin; it is mapped to 'plugin'.\n     * <\/p>\n     *\n     * @since 2.4\n     */\n    @Parameter( property = \"goalPrefix\" )\n    protected String goalPrefix;\n\n    /**\n     * Set this to \"true\" to skip invoking any goals or reports of the plugin.\n     *\n     * @since 2.8\n     */\n    @Parameter( defaultValue = \"false\", property = \"maven.plugin.skip\" )\n    private boolean skip;\n\n    /**\n     * Set this to \"true\" to skip generating the report.\n     *\n     * @since 2.8\n     */\n    @Parameter( defaultValue = \"false\", property = \"maven.plugin.report.skip\" )\n    private boolean skipReport;\n\n    /**\n     * The set of dependencies for the current project\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${project.artifacts}\", required = true, readonly = true )\n    protected Set<Artifact> dependencies;\n\n    /**\n     * List of Remote Repositories used by the resolver\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${project.remoteArtifactRepositories}\", required = true, readonly = true )\n    protected List<ArtifactRepository> remoteRepos;\n\n    /**\n     * Location of the local repository.\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${localRepository}\", required = true, readonly = true )\n    protected ArtifactRepository local;\n\n    /**\n     * {@inheritDoc}\n     */\n    protected Renderer getSiteRenderer()\n    {\n        return siteRenderer;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected String getOutputDirectory()\n    {\n        // PLUGIN-191: output directory of plugin.html, not *-mojo.xml\n        return project.getReporting().getOutputDirectory();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected MavenProject getProject()\n    {\n        return project;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean canGenerateReport()\n    {\n        return \"maven-plugin\".equals( project.getPackaging() );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings( \"unchecked\" )\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( !canGenerateReport() )\n        {\n            return;\n        }\n        if ( skip || skipReport )\n        {\n            getLog().info( \"Maven Plugin Plugin Report generation skipped.\" );\n            return;\n        }\n\n        // Copy from AbstractGeneratorMojo#execute()\n        String defaultGoalPrefix = PluginDescriptor.getGoalPrefixFromArtifactId( project.getArtifactId() );\n        if ( goalPrefix == null )\n        {\n            goalPrefix = defaultGoalPrefix;\n        }\n        else\n        {\n            getLog().warn( \"\\n\\nGoal prefix is specified as: '\" + goalPrefix + \"'. Maven currently expects it to be '\"\n                               + defaultGoalPrefix + \"'.\\n\" );\n        }\n\n        // TODO: could use this more, eg in the writing of the plugin descriptor!\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.setGroupId( project.getGroupId() );\n\n        pluginDescriptor.setArtifactId( project.getArtifactId() );\n\n        pluginDescriptor.setVersion( project.getVersion() );\n\n        pluginDescriptor.setGoalPrefix( goalPrefix );\n\n        try\n        {\n            List<ComponentDependency> deps = GeneratorUtils.toComponentDependencies( project.getRuntimeDependencies() );\n            pluginDescriptor.setDependencies( deps );\n\n            PluginToolsRequest request = new DefaultPluginToolsRequest( project, pluginDescriptor );\n            request.setEncoding( encoding );\n            request.setSkipErrorNoDescriptorsFound( true );\n            request.setDependencies( dependencies );\n            request.setLocal( this.local );\n            request.setRemoteRepos( this.remoteRepos );\n\n\n            try\n            {\n                mojoScanner.populatePluginDescriptor( request );\n            }\n            catch ( InvalidPluginDescriptorException e )\n            {\n                // this is OK, it happens to lifecycle plugins. Allow generation to proceed.\n                getLog().debug( \"Plugin without mojos.\", e );\n\n            }\n\n            // Generate the plugin's documentation\n            generatePluginDocumentation( pluginDescriptor, locale );\n\n            // Write the overview\n            PluginOverviewRenderer r =\n                new PluginOverviewRenderer( project, requirements, getSink(), pluginDescriptor, locale );\n            r.render();\n        }\n\n        catch ( ExtractionException e )\n        {\n            throw new MavenReportException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                            e );\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription( Locale locale )\n    {\n        return getBundle( locale ).getString( \"report.plugin.description\" );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getName( Locale locale )\n    {\n        return getBundle( locale ).getString( \"report.plugin.name\" );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getOutputName()\n    {\n        return \"plugin-info\";\n    }\n\n    /**\n     * @param pluginDescriptor not null\n     * @param locale           not null\n     * @throws MavenReportException if any\n     */\n    private void generatePluginDocumentation( PluginDescriptor pluginDescriptor, Locale locale )\n        throws MavenReportException\n    {\n        try\n        {\n            File outputDir = outputDirectory;\n            outputDir.mkdirs();\n\n            PluginXdocGenerator generator = new PluginXdocGenerator( project, locale );\n            PluginToolsRequest pluginToolsRequest = new DefaultPluginToolsRequest( project, pluginDescriptor );\n            generator.execute( outputDir, pluginToolsRequest );\n        }\n        catch ( GeneratorException e )\n        {\n            throw new MavenReportException( \"Error writing plugin documentation\", e );\n        }\n\n    }\n\n    /**\n     * @param locale not null\n     * @return the bundle for this report\n     */\n    protected static ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"plugin-report\", locale, PluginReport.class.getClassLoader() );\n    }\n\n    /**\n     * Generates an overview page with the list of goals\n     * and a link to the goal's page.\n     */\n    static class PluginOverviewRenderer\n        extends AbstractMavenReportRenderer\n    {\n        private final MavenProject project;\n\n        private final Requirements requirements;\n\n        private final PluginDescriptor pluginDescriptor;\n\n        private final Locale locale;\n\n        /**\n         * @param project          not null\n         * @param requirements     not null\n         * @param sink             not null\n         * @param pluginDescriptor not null\n         * @param locale           not null\n         */\n        public PluginOverviewRenderer( MavenProject project, Requirements requirements, Sink sink,\n                                       PluginDescriptor pluginDescriptor, Locale locale )\n        {\n            super( sink );\n\n            this.project = project;\n\n            this.requirements = ( requirements == null ? new Requirements() : requirements );\n\n            this.pluginDescriptor = pluginDescriptor;\n\n            this.locale = locale;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public String getTitle()\n        {\n            return getBundle( locale ).getString( \"report.plugin.title\" );\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @SuppressWarnings( { \"unchecked\", \"rawtypes\" } )\n        public void renderBody()\n        {\n            startSection( getTitle() );\n\n            if ( !( pluginDescriptor.getMojos() != null && pluginDescriptor.getMojos().size() > 0 ) )\n            {\n                paragraph( getBundle( locale ).getString( \"report.plugin.goals.nogoal\" ) );\n                endSection();\n                return;\n            }\n\n            paragraph( getBundle( locale ).getString( \"report.plugin.goals.intro\" ) );\n\n            boolean hasMavenReport = false;\n            for ( Iterator<MojoDescriptor> i = pluginDescriptor.getMojos().iterator(); i.hasNext(); )\n            {\n                MojoDescriptor mojo = i.next();\n\n                if ( GeneratorUtils.isMavenReport( mojo.getImplementation(), project ) )\n                {\n                    hasMavenReport = true;\n                }\n            }\n\n            startTable();\n\n            String goalColumnName = getBundle( locale ).getString( \"report.plugin.goals.column.goal\" );\n            String isMavenReport = getBundle( locale ).getString( \"report.plugin.goals.column.isMavenReport\" );\n            String descriptionColumnName = getBundle( locale ).getString( \"report.plugin.goals.column.description\" );\n            if ( hasMavenReport )\n            {\n                tableHeader( new String[]{ goalColumnName, isMavenReport, descriptionColumnName } );\n            }\n            else\n            {\n                tableHeader( new String[]{ goalColumnName, descriptionColumnName } );\n            }\n\n            List<MojoDescriptor> mojos = new ArrayList<MojoDescriptor>();\n            mojos.addAll( pluginDescriptor.getMojos() );\n            PluginUtils.sortMojos( mojos );\n            for ( MojoDescriptor mojo : mojos )\n            {\n                String goalName = mojo.getFullGoalName();\n\n                /*\n                 * Added ./ to define a relative path\n                 * @see AbstractMavenReportRenderer#getValidHref(java.lang.String)\n                 */\n                String goalDocumentationLink = \"./\" + mojo.getGoal() + \"-mojo.html\";\n\n                String description;\n                if ( StringUtils.isNotEmpty( mojo.getDeprecated() ) )\n                {\n                    description =\n                        \"<strong>\" + getBundle( locale ).getString( \"report.plugin.goal.deprecated\" ) + \"<\/strong> \"\n                            + GeneratorUtils.makeHtmlValid( mojo.getDeprecated() );\n                }\n                else if ( StringUtils.isNotEmpty( mojo.getDescription() ) )\n                {\n                    description = GeneratorUtils.makeHtmlValid( mojo.getDescription() );\n                }\n                else\n                {\n                    description = getBundle( locale ).getString( \"report.plugin.goal.nodescription\" );\n                }\n\n                sink.tableRow();\n                tableCell( createLinkPatternedText( goalName, goalDocumentationLink ) );\n                if ( hasMavenReport )\n                {\n                    if ( GeneratorUtils.isMavenReport( mojo.getImplementation(), project ) )\n                    {\n                        sink.tableCell();\n                        sink.text( getBundle( locale ).getString( \"report.plugin.isReport\" ) );\n                        sink.tableCell_();\n                    }\n                    else\n                    {\n                        sink.tableCell();\n                        sink.text( getBundle( locale ).getString( \"report.plugin.isNotReport\" ) );\n                        sink.tableCell_();\n                    }\n                }\n                tableCell( description, true );\n                sink.tableRow_();\n            }\n\n            endTable();\n\n            startSection( getBundle( locale ).getString( \"report.plugin.systemrequirements\" ) );\n\n            paragraph( getBundle( locale ).getString( \"report.plugin.systemrequirements.intro\" ) );\n\n            startTable();\n\n            String maven = discoverMavenRequirement( project, requirements );\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.maven\" ) );\n            tableCell( ( maven != null\n                ? maven\n                : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            String jdk = discoverJdkRequirement( project, requirements );\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.jdk\" ) );\n            tableCell(\n                ( jdk != null ? jdk : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.memory\" ) );\n            tableCell( ( StringUtils.isNotEmpty( requirements.getMemory() )\n                ? requirements.getMemory()\n                : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.diskspace\" ) );\n            tableCell( ( StringUtils.isNotEmpty( requirements.getDiskSpace() )\n                ? requirements.getDiskSpace()\n                : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            if ( requirements.getOthers() != null && requirements.getOthers().size() > 0 )\n            {\n                for ( Iterator it = requirements.getOthers().keySet().iterator(); it.hasNext(); )\n                {\n                    String key = it.next().toString();\n\n                    sink.tableRow();\n                    tableCell( key );\n                    tableCell( ( StringUtils.isNotEmpty( requirements.getOthers().getProperty( key ) )\n                        ? requirements.getOthers().getProperty( key )\n                        : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n                    sink.tableRow_();\n                }\n            }\n            endTable();\n\n            endSection();\n\n            renderUsageSection( hasMavenReport );\n\n            endSection();\n        }\n\n        /**\n         * Render the section about the usage of the plugin.\n         *\n         * @param hasMavenReport If the plugin has a report or not\n         */\n        private void renderUsageSection( boolean hasMavenReport )\n        {\n            startSection( getBundle( locale ).getString( \"report.plugin.usage\" ) );\n\n            // Configuration\n            sink.paragraph();\n            text( getBundle( locale ).getString( \"report.plugin.usage.intro\" ) );\n            sink.paragraph_();\n\n            StringBuilder sb = new StringBuilder();\n            sb.append( \"<project>\" ).append( '\\n' );\n            sb.append( \"  ...\" ).append( '\\n' );\n            sb.append( \"  <build>\" ).append( '\\n' );\n            sb.append(\n                \"    <!-- \" + getBundle( locale ).getString( \"report.plugin.usage.pluginManagement\" ) + \" -->\" ).append(\n                '\\n' );\n            sb.append( \"    <pluginManagement>\" ).append( '\\n' );\n            sb.append( \"      <plugins>\" ).append( '\\n' );\n            sb.append( \"        <plugin>\" ).append( '\\n' );\n            sb.append( \"          <groupId>\" ).append( pluginDescriptor.getGroupId() ).append( \"<\/groupId>\" ).append(\n                '\\n' );\n            sb.append( \"          <artifactId>\" ).append( pluginDescriptor.getArtifactId() ).append(\n                \"<\/artifactId>\" ).append( '\\n' );\n            sb.append( \"          <version>\" ).append( pluginDescriptor.getVersion() ).append( \"<\/version>\" ).append(\n                '\\n' );\n            sb.append( \"        <\/plugin>\" ).append( '\\n' );\n            sb.append( \"        ...\" ).append( '\\n' );\n            sb.append( \"      <\/plugins>\" ).append( '\\n' );\n            sb.append( \"    <\/pluginManagement>\" ).append( '\\n' );\n            sb.append( \"    <!-- \" + getBundle( locale ).getString( \"report.plugin.usage.plugins\" ) + \" -->\" ).append(\n                '\\n' );\n            sb.append( \"    <plugins>\" ).append( '\\n' );\n            sb.append( \"      <plugin>\" ).append( '\\n' );\n            sb.append( \"        <groupId>\" ).append( pluginDescriptor.getGroupId() ).append( \"<\/groupId>\" ).append(\n                '\\n' );\n            sb.append( \"        <artifactId>\" ).append( pluginDescriptor.getArtifactId() ).append(\n                \"<\/artifactId>\" ).append( '\\n' );\n            sb.append( \"        <version>\" ).append( pluginDescriptor.getVersion() ).append( \"<\/version>\" ).append(\n                '\\n' );\n            sb.append( \"      <\/plugin>\" ).append( '\\n' );\n            sb.append( \"      ...\" ).append( '\\n' );\n            sb.append( \"    <\/plugins>\" ).append( '\\n' );\n            sb.append( \"  <\/build>\" ).append( '\\n' );\n\n            if ( hasMavenReport )\n            {\n                sb.append( \"  ...\" ).append( '\\n' );\n                sb.append(\n                    \"  <!-- \" + getBundle( locale ).getString( \"report.plugin.usage.reporting\" ) + \" -->\" ).append(\n                    '\\n' );\n                sb.append( \"  <reporting>\" ).append( '\\n' );\n                sb.append( \"    <plugins>\" ).append( '\\n' );\n                sb.append( \"      <plugin>\" ).append( '\\n' );\n                sb.append( \"        <groupId>\" ).append( pluginDescriptor.getGroupId() ).append( \"<\/groupId>\" ).append(\n                    '\\n' );\n                sb.append( \"        <artifactId>\" ).append( pluginDescriptor.getArtifactId() ).append(\n                    \"<\/artifactId>\" ).append( '\\n' );\n                sb.append( \"        <version>\" ).append( pluginDescriptor.getVersion() ).append( \"<\/version>\" ).append(\n                    '\\n' );\n                sb.append( \"      <\/plugin>\" ).append( '\\n' );\n                sb.append( \"      ...\" ).append( '\\n' );\n                sb.append( \"    <\/plugins>\" ).append( '\\n' );\n                sb.append( \"  <\/reporting>\" ).append( '\\n' );\n            }\n\n            sb.append( \"  ...\" ).append( '\\n' );\n            sb.append( \"<\/project>\" ).append( '\\n' );\n\n            verbatimText( sb.toString() );\n\n            sink.paragraph();\n            linkPatternedText( getBundle( locale ).getString( \"report.plugin.configuration.end\" ) );\n            sink.paragraph_();\n\n            endSection();\n        }\n\n        /**\n         * Try to lookup on the Maven prerequisites property.\n         * If not specified, uses the value defined by the user.\n         *\n         * @param project      not null\n         * @param requirements not null\n         * @return the Maven version\n         */\n        private static String discoverMavenRequirement( MavenProject project, Requirements requirements )\n        {\n            String maven = requirements.getMaven();\n            if ( maven == null )\n            {\n                maven = ( project.getPrerequisites() != null ? project.getPrerequisites().getMaven() : null );\n            }\n            if ( maven == null )\n            {\n                maven = \"2.0\";\n            }\n\n            return maven;\n        }\n\n        /**\n         * Try to lookup on the <code>org.apache.maven.plugins:maven-compiler-plugin<\/code> plugin to\n         * find the value of the <code>target<\/code> option.\n         * If not specified, uses the value defined by the user.\n         * If not specified, uses the value of the system property <code>java.specification.version<\/code>.\n         *\n         * @param project      not null\n         * @param requirements not null\n         * @return the JDK version\n         */\n        private static String discoverJdkRequirement( MavenProject project, Requirements requirements )\n        {\n            String jdk = requirements.getJdk();\n            if ( jdk == null )\n            {\n                jdk = discoverJdkRequirementFromPlugins( project.getBuild().getPluginsAsMap(),\n                                                         project.getProperties() );\n            }\n            if ( jdk == null && project.getPluginManagement() != null )\n            {\n                jdk =\n                    discoverJdkRequirementFromPlugins( project.getPluginManagement().getPluginsAsMap(),\n                                                       project.getProperties() );\n            }\n            if ( jdk == null )\n            {\n                jdk = \"Unknown\";\n            }\n\n            return jdk;\n        }\n\n        /**\n         * @param pluginsAsMap could be null\n         * @return the value of the <code>target<\/code> in the configuration of <code>maven-compiler-plugin<\/code>.\n         */\n        private static String discoverJdkRequirementFromPlugins( Map<String, Object> pluginsAsMap, Properties props )\n        {\n            if ( pluginsAsMap == null )\n            {\n                return null;\n            }\n\n            // default value\n            String jdk = props.getProperty( \"maven.compiler.target\" );\n\n            String backupJdk = null;\n            for ( Map.Entry<String, Object> entry : pluginsAsMap.entrySet() )\n            {\n                if ( !entry.getKey().equals( \"org.apache.maven.plugins:maven-compiler-plugin\" ) )\n                {\n                    continue;\n                }\n\n                Object value = entry.getValue();\n                Xpp3Dom pluginConf = null;\n\n                backupJdk = \"Default version for maven-compiler-plugin\";\n                if ( value instanceof Plugin )\n                {\n                    Plugin plugin = (Plugin) value;\n                    backupJdk = \"Default target for maven-compiler-plugin version \" + plugin.getVersion();\n                    pluginConf = (Xpp3Dom) plugin.getConfiguration();\n                }\n\n                if ( value instanceof ReportPlugin )\n                {\n                    ReportPlugin reportPlugin = (ReportPlugin) value;\n                    backupJdk = \"Default target for maven-compiler-plugin version \" + reportPlugin.getVersion();\n                    pluginConf = (Xpp3Dom) reportPlugin.getConfiguration();\n                }\n\n                if ( pluginConf == null )\n                {\n                    continue;\n                }\n\n                Xpp3Dom target = pluginConf.getChild( \"target\" );\n                if ( target != null )\n                {\n                    jdk = target.getValue();\n                }\n            }\n\n            return ( jdk == null ) ? backupJdk : jdk;\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.plugin.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.Renderer;\nimport org.apache.maven.model.Plugin;\nimport org.apache.maven.model.ReportPlugin;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.AbstractMavenReport;\nimport org.apache.maven.reporting.AbstractMavenReportRenderer;\nimport org.apache.maven.reporting.MavenReportException;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.generator.GeneratorException;\nimport org.apache.maven.tools.plugin.generator.GeneratorUtils;\nimport org.apache.maven.tools.plugin.generator.PluginXdocGenerator;\nimport org.apache.maven.tools.plugin.scanner.MojoScanner;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.Xpp3Dom;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.ResourceBundle;\nimport java.util.Set;\n\n/**\n * Generates the Plugin's documentation report.\n *\n * @author <a href=\"snicoll@apache.org\">Stephane Nicoll<\/a>\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.0\n */\n@Mojo( name = \"report\", threadSafe = true )\n@Execute( phase = LifecyclePhase.PROCESS_CLASSES )\npublic class PluginReport\n    extends AbstractMavenReport\n{\n    /**\n     * Report output directory for mojo pages.\n     */\n    @Parameter( defaultValue = \"${project.build.directory}/generated-site/xdoc\" )\n    private File outputDirectory;\n\n    /**\n     * Doxia Site Renderer.\n     */\n    @Component\n    private Renderer siteRenderer;\n\n    /**\n     * The Maven Project.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true )\n    private MavenProject project;\n\n    /**\n     * Mojo scanner tools.\n     */\n    @Component\n    protected MojoScanner mojoScanner;\n\n    /**\n     * The file encoding of the source files.\n     *\n     * @since 2.7\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specify some requirements to execute this plugin.\n     * Example:\n     * <pre>\n     * &lt;requirements&gt;\n     *   &lt;maven&gt;2.0&lt;/maven&gt;\n     *   &lt;jdk&gt;1.4&lt;/jdk&gt;\n     *   &lt;memory&gt;256m&lt;/memory&gt;\n     *   &lt;diskSpace&gt;1m&lt;/diskSpace&gt;\n     *   &lt;others&gt;\n     *     &lt;property&gt;\n     *       &lt;name&gt;SVN&lt;/name&gt;\n     *       &lt;value&gt;1.4.6&lt;/value&gt;\n     *     &lt;/property&gt;\n     *   &lt;/others&gt;\n     * &lt;/requirements&gt;\n     * <\/pre>\n     */\n    @Parameter\n    private Requirements requirements;\n\n    /**\n     * The goal prefix that will appear before the \":\".\n     * By default, this plugin applies a heuristic to derive a heuristic from\n     * the plugin's artifactId.\n     * <p/>\n     * It removes any occurrences of the regular expression <strong>-?maven-?<\/strong>,\n     * and then removes any occurrences of <strong>-?plugin-?<\/strong>.\n     * <p>\n     * For example, horsefeature-maven-plugin becomes horsefeature.\n     * <\/p>\n     * <p>\n     * (There is a special for maven-plugin-plugin; it is mapped to 'plugin'.\n     * <\/p>\n     *\n     * @since 2.4\n     */\n    @Parameter( property = \"goalPrefix\" )\n    protected String goalPrefix;\n\n    /**\n     * Set this to \"true\" to skip invoking any goals or reports of the plugin.\n     *\n     * @since 2.8\n     */\n    @Parameter( defaultValue = \"false\", property = \"maven.plugin.skip\" )\n    private boolean skip;\n\n    /**\n     * Set this to \"true\" to skip generating the report.\n     *\n     * @since 2.8\n     */\n    @Parameter( defaultValue = \"false\", property = \"maven.plugin.report.skip\" )\n    private boolean skipReport;\n\n    /**\n     * The set of dependencies for the current project\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${project.artifacts}\", required = true, readonly = true )\n    protected Set<Artifact> dependencies;\n\n    /**\n     * List of Remote Repositories used by the resolver\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${project.remoteArtifactRepositories}\", required = true, readonly = true )\n    protected List<ArtifactRepository> remoteRepos;\n\n    /**\n     * Location of the local repository.\n     *\n     * @since 3.0\n     */\n    @Parameter( defaultValue = \"${localRepository}\", required = true, readonly = true )\n    protected ArtifactRepository local;\n\n    /**\n     * {@inheritDoc}\n     */\n    protected Renderer getSiteRenderer()\n    {\n        return siteRenderer;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected String getOutputDirectory()\n    {\n        // PLUGIN-191: output directory of plugin.html, not *-mojo.xml\n        return project.getReporting().getOutputDirectory();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected MavenProject getProject()\n    {\n        return project;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean canGenerateReport()\n    {\n        return \"maven-plugin\".equals( project.getPackaging() );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings( \"unchecked\" )\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( !canGenerateReport() )\n        {\n            return;\n        }\n        if ( skip || skipReport )\n        {\n            getLog().info( \"Maven Plugin Plugin Report generation skipped.\" );\n            return;\n        }\n\n        // Copy from AbstractGeneratorMojo#execute()\n        String defaultGoalPrefix = PluginDescriptor.getGoalPrefixFromArtifactId( project.getArtifactId() );\n        if ( goalPrefix == null )\n        {\n            goalPrefix = defaultGoalPrefix;\n        }\n        else\n        {\n            getLog().warn( \"\\n\\nGoal prefix is specified as: '\" + goalPrefix + \"'. Maven currently expects it to be '\"\n                               + defaultGoalPrefix + \"'.\\n\" );\n        }\n\n        // TODO: could use this more, eg in the writing of the plugin descriptor!\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.setGroupId( project.getGroupId() );\n\n        pluginDescriptor.setArtifactId( project.getArtifactId() );\n\n        pluginDescriptor.setVersion( project.getVersion() );\n\n        pluginDescriptor.setGoalPrefix( goalPrefix );\n\n        try\n        {\n            pluginDescriptor.setDependencies( GeneratorUtils.toComponentDependencies( project.getRuntimeDependencies() ) );\n\n            PluginToolsRequest request = new DefaultPluginToolsRequest( project, pluginDescriptor );\n            request.setEncoding( encoding );\n            request.setSkipErrorNoDescriptorsFound( true );\n            request.setDependencies( dependencies );\n            request.setLocal( this.local );\n            request.setRemoteRepos( this.remoteRepos );\n\n\n            try\n            {\n                mojoScanner.populatePluginDescriptor( request );\n            }\n            catch ( InvalidPluginDescriptorException e )\n            {\n                // this is OK, it happens to lifecycle plugins. Allow generation to proceed.\n                getLog().debug( \"Plugin without mojos.\", e );\n\n            }\n\n            // Generate the plugin's documentation\n            generatePluginDocumentation( pluginDescriptor, locale );\n\n            // Write the overview\n            PluginOverviewRenderer r =\n                new PluginOverviewRenderer( project, requirements, getSink(), pluginDescriptor, locale );\n            r.render();\n        }\n\n        catch ( ExtractionException e )\n        {\n            throw new MavenReportException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                            e );\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription( Locale locale )\n    {\n        return getBundle( locale ).getString( \"report.plugin.description\" );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getName( Locale locale )\n    {\n        return getBundle( locale ).getString( \"report.plugin.name\" );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getOutputName()\n    {\n        return \"plugin-info\";\n    }\n\n    /**\n     * @param pluginDescriptor not null\n     * @param locale           not null\n     * @throws MavenReportException if any\n     */\n    private void generatePluginDocumentation( PluginDescriptor pluginDescriptor, Locale locale )\n        throws MavenReportException\n    {\n        try\n        {\n            File outputDir = outputDirectory;\n            outputDir.mkdirs();\n\n            PluginXdocGenerator generator = new PluginXdocGenerator( project, locale );\n            PluginToolsRequest pluginToolsRequest = new DefaultPluginToolsRequest( project, pluginDescriptor );\n            generator.execute( outputDir, pluginToolsRequest );\n        }\n        catch ( GeneratorException e )\n        {\n            throw new MavenReportException( \"Error writing plugin documentation\", e );\n        }\n\n    }\n\n    /**\n     * @param locale not null\n     * @return the bundle for this report\n     */\n    protected static ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"plugin-report\", locale, PluginReport.class.getClassLoader() );\n    }\n\n    /**\n     * Generates an overview page with the list of goals\n     * and a link to the goal's page.\n     */\n    static class PluginOverviewRenderer\n        extends AbstractMavenReportRenderer\n    {\n        private final MavenProject project;\n\n        private final Requirements requirements;\n\n        private final PluginDescriptor pluginDescriptor;\n\n        private final Locale locale;\n\n        /**\n         * @param project          not null\n         * @param requirements     not null\n         * @param sink             not null\n         * @param pluginDescriptor not null\n         * @param locale           not null\n         */\n        public PluginOverviewRenderer( MavenProject project, Requirements requirements, Sink sink,\n                                       PluginDescriptor pluginDescriptor, Locale locale )\n        {\n            super( sink );\n\n            this.project = project;\n\n            this.requirements = ( requirements == null ? new Requirements() : requirements );\n\n            this.pluginDescriptor = pluginDescriptor;\n\n            this.locale = locale;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public String getTitle()\n        {\n            return getBundle( locale ).getString( \"report.plugin.title\" );\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @SuppressWarnings( { \"unchecked\", \"rawtypes\" } )\n        public void renderBody()\n        {\n            startSection( getTitle() );\n\n            if ( !( pluginDescriptor.getMojos() != null && pluginDescriptor.getMojos().size() > 0 ) )\n            {\n                paragraph( getBundle( locale ).getString( \"report.plugin.goals.nogoal\" ) );\n                endSection();\n                return;\n            }\n\n            paragraph( getBundle( locale ).getString( \"report.plugin.goals.intro\" ) );\n\n            boolean hasMavenReport = false;\n            for ( Iterator<MojoDescriptor> i = pluginDescriptor.getMojos().iterator(); i.hasNext(); )\n            {\n                MojoDescriptor mojo = i.next();\n\n                if ( GeneratorUtils.isMavenReport( mojo.getImplementation(), project ) )\n                {\n                    hasMavenReport = true;\n                }\n            }\n\n            startTable();\n\n            String goalColumnName = getBundle( locale ).getString( \"report.plugin.goals.column.goal\" );\n            String isMavenReport = getBundle( locale ).getString( \"report.plugin.goals.column.isMavenReport\" );\n            String descriptionColumnName = getBundle( locale ).getString( \"report.plugin.goals.column.description\" );\n            if ( hasMavenReport )\n            {\n                tableHeader( new String[]{ goalColumnName, isMavenReport, descriptionColumnName } );\n            }\n            else\n            {\n                tableHeader( new String[]{ goalColumnName, descriptionColumnName } );\n            }\n\n            List<MojoDescriptor> mojos = new ArrayList<MojoDescriptor>();\n            mojos.addAll( pluginDescriptor.getMojos() );\n            PluginUtils.sortMojos( mojos );\n            for ( MojoDescriptor mojo : mojos )\n            {\n                String goalName = mojo.getFullGoalName();\n\n                /*\n                 * Added ./ to define a relative path\n                 * @see AbstractMavenReportRenderer#getValidHref(java.lang.String)\n                 */\n                String goalDocumentationLink = \"./\" + mojo.getGoal() + \"-mojo.html\";\n\n                String description;\n                if ( StringUtils.isNotEmpty( mojo.getDeprecated() ) )\n                {\n                    description =\n                        \"<strong>\" + getBundle( locale ).getString( \"report.plugin.goal.deprecated\" ) + \"<\/strong> \"\n                            + GeneratorUtils.makeHtmlValid( mojo.getDeprecated() );\n                }\n                else if ( StringUtils.isNotEmpty( mojo.getDescription() ) )\n                {\n                    description = GeneratorUtils.makeHtmlValid( mojo.getDescription() );\n                }\n                else\n                {\n                    description = getBundle( locale ).getString( \"report.plugin.goal.nodescription\" );\n                }\n\n                sink.tableRow();\n                tableCell( createLinkPatternedText( goalName, goalDocumentationLink ) );\n                if ( hasMavenReport )\n                {\n                    if ( GeneratorUtils.isMavenReport( mojo.getImplementation(), project ) )\n                    {\n                        sink.tableCell();\n                        sink.text( getBundle( locale ).getString( \"report.plugin.isReport\" ) );\n                        sink.tableCell_();\n                    }\n                    else\n                    {\n                        sink.tableCell();\n                        sink.text( getBundle( locale ).getString( \"report.plugin.isNotReport\" ) );\n                        sink.tableCell_();\n                    }\n                }\n                tableCell( description, true );\n                sink.tableRow_();\n            }\n\n            endTable();\n\n            startSection( getBundle( locale ).getString( \"report.plugin.systemrequirements\" ) );\n\n            paragraph( getBundle( locale ).getString( \"report.plugin.systemrequirements.intro\" ) );\n\n            startTable();\n\n            String maven = discoverMavenRequirement( project, requirements );\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.maven\" ) );\n            tableCell( ( maven != null\n                ? maven\n                : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            String jdk = discoverJdkRequirement( project, requirements );\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.jdk\" ) );\n            tableCell(\n                ( jdk != null ? jdk : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.memory\" ) );\n            tableCell( ( StringUtils.isNotEmpty( requirements.getMemory() )\n                ? requirements.getMemory()\n                : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.diskspace\" ) );\n            tableCell( ( StringUtils.isNotEmpty( requirements.getDiskSpace() )\n                ? requirements.getDiskSpace()\n                : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            if ( requirements.getOthers() != null && requirements.getOthers().size() > 0 )\n            {\n                for ( Iterator it = requirements.getOthers().keySet().iterator(); it.hasNext(); )\n                {\n                    String key = it.next().toString();\n\n                    sink.tableRow();\n                    tableCell( key );\n                    tableCell( ( StringUtils.isNotEmpty( requirements.getOthers().getProperty( key ) )\n                        ? requirements.getOthers().getProperty( key )\n                        : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n                    sink.tableRow_();\n                }\n            }\n            endTable();\n\n            endSection();\n\n            renderUsageSection( hasMavenReport );\n\n            endSection();\n        }\n\n        /**\n         * Render the section about the usage of the plugin.\n         *\n         * @param hasMavenReport If the plugin has a report or not\n         */\n        private void renderUsageSection( boolean hasMavenReport )\n        {\n            startSection( getBundle( locale ).getString( \"report.plugin.usage\" ) );\n\n            // Configuration\n            sink.paragraph();\n            text( getBundle( locale ).getString( \"report.plugin.usage.intro\" ) );\n            sink.paragraph_();\n\n            StringBuilder sb = new StringBuilder();\n            sb.append( \"<project>\" ).append( '\\n' );\n            sb.append( \"  ...\" ).append( '\\n' );\n            sb.append( \"  <build>\" ).append( '\\n' );\n            sb.append(\n                \"    <!-- \" + getBundle( locale ).getString( \"report.plugin.usage.pluginManagement\" ) + \" -->\" ).append(\n                '\\n' );\n            sb.append( \"    <pluginManagement>\" ).append( '\\n' );\n            sb.append( \"      <plugins>\" ).append( '\\n' );\n            sb.append( \"        <plugin>\" ).append( '\\n' );\n            sb.append( \"          <groupId>\" ).append( pluginDescriptor.getGroupId() ).append( \"<\/groupId>\" ).append(\n                '\\n' );\n            sb.append( \"          <artifactId>\" ).append( pluginDescriptor.getArtifactId() ).append(\n                \"<\/artifactId>\" ).append( '\\n' );\n            sb.append( \"          <version>\" ).append( pluginDescriptor.getVersion() ).append( \"<\/version>\" ).append(\n                '\\n' );\n            sb.append( \"        <\/plugin>\" ).append( '\\n' );\n            sb.append( \"        ...\" ).append( '\\n' );\n            sb.append( \"      <\/plugins>\" ).append( '\\n' );\n            sb.append( \"    <\/pluginManagement>\" ).append( '\\n' );\n            sb.append( \"    <!-- \" + getBundle( locale ).getString( \"report.plugin.usage.plugins\" ) + \" -->\" ).append(\n                '\\n' );\n            sb.append( \"    <plugins>\" ).append( '\\n' );\n            sb.append( \"      <plugin>\" ).append( '\\n' );\n            sb.append( \"        <groupId>\" ).append( pluginDescriptor.getGroupId() ).append( \"<\/groupId>\" ).append(\n                '\\n' );\n            sb.append( \"        <artifactId>\" ).append( pluginDescriptor.getArtifactId() ).append(\n                \"<\/artifactId>\" ).append( '\\n' );\n            sb.append( \"        <version>\" ).append( pluginDescriptor.getVersion() ).append( \"<\/version>\" ).append(\n                '\\n' );\n            sb.append( \"      <\/plugin>\" ).append( '\\n' );\n            sb.append( \"      ...\" ).append( '\\n' );\n            sb.append( \"    <\/plugins>\" ).append( '\\n' );\n            sb.append( \"  <\/build>\" ).append( '\\n' );\n\n            if ( hasMavenReport )\n            {\n                sb.append( \"  ...\" ).append( '\\n' );\n                sb.append(\n                    \"  <!-- \" + getBundle( locale ).getString( \"report.plugin.usage.reporting\" ) + \" -->\" ).append(\n                    '\\n' );\n                sb.append( \"  <reporting>\" ).append( '\\n' );\n                sb.append( \"    <plugins>\" ).append( '\\n' );\n                sb.append( \"      <plugin>\" ).append( '\\n' );\n                sb.append( \"        <groupId>\" ).append( pluginDescriptor.getGroupId() ).append( \"<\/groupId>\" ).append(\n                    '\\n' );\n                sb.append( \"        <artifactId>\" ).append( pluginDescriptor.getArtifactId() ).append(\n                    \"<\/artifactId>\" ).append( '\\n' );\n                sb.append( \"        <version>\" ).append( pluginDescriptor.getVersion() ).append( \"<\/version>\" ).append(\n                    '\\n' );\n                sb.append( \"      <\/plugin>\" ).append( '\\n' );\n                sb.append( \"      ...\" ).append( '\\n' );\n                sb.append( \"    <\/plugins>\" ).append( '\\n' );\n                sb.append( \"  <\/reporting>\" ).append( '\\n' );\n            }\n\n            sb.append( \"  ...\" ).append( '\\n' );\n            sb.append( \"<\/project>\" ).append( '\\n' );\n\n            verbatimText( sb.toString() );\n\n            sink.paragraph();\n            linkPatternedText( getBundle( locale ).getString( \"report.plugin.configuration.end\" ) );\n            sink.paragraph_();\n\n            endSection();\n        }\n\n        /**\n         * Try to lookup on the Maven prerequisites property.\n         * If not specified, uses the value defined by the user.\n         *\n         * @param project      not null\n         * @param requirements not null\n         * @return the Maven version\n         */\n        private static String discoverMavenRequirement( MavenProject project, Requirements requirements )\n        {\n            String maven = requirements.getMaven();\n            if ( maven == null )\n            {\n                maven = ( project.getPrerequisites() != null ? project.getPrerequisites().getMaven() : null );\n            }\n            if ( maven == null )\n            {\n                maven = \"2.0\";\n            }\n\n            return maven;\n        }\n\n        /**\n         * Try to lookup on the <code>org.apache.maven.plugins:maven-compiler-plugin<\/code> plugin to\n         * find the value of the <code>target<\/code> option.\n         * If not specified, uses the value defined by the user.\n         * If not specified, uses the value of the system property <code>java.specification.version<\/code>.\n         *\n         * @param project      not null\n         * @param requirements not null\n         * @return the JDK version\n         */\n        private static String discoverJdkRequirement( MavenProject project, Requirements requirements )\n        {\n            String jdk = requirements.getJdk();\n            if ( jdk == null )\n            {\n                jdk = discoverJdkRequirementFromPlugins( project.getBuild().getPluginsAsMap(), project.getProperties() );\n            }\n            if ( jdk == null && project.getPluginManagement() != null )\n            {\n                jdk =\n                    discoverJdkRequirementFromPlugins( project.getPluginManagement().getPluginsAsMap(),\n                                                       project.getProperties() );\n            }\n            if ( jdk == null )\n            {\n                jdk = \"Unknown\";\n            }\n\n            return jdk;\n        }\n\n        /**\n         * @param pluginsAsMap could be null\n         * @return the value of the <code>target<\/code> in the configuration of <code>maven-compiler-plugin<\/code>.\n         */\n        private static String discoverJdkRequirementFromPlugins( Map<String, Object> pluginsAsMap, Properties props )\n        {\n            if ( pluginsAsMap == null )\n            {\n                return null;\n            }\n\n            // default value\n            String jdk = props.getProperty( \"maven.compiler.target\" );\n\n            String backupJdk = null;\n            for ( Map.Entry<String, Object> entry : pluginsAsMap.entrySet() )\n            {\n                if ( !entry.getKey().equals( \"org.apache.maven.plugins:maven-compiler-plugin\" ) )\n                {\n                    continue;\n                }\n\n                Object value = entry.getValue();\n                Xpp3Dom pluginConf = null;\n\n                backupJdk = \"Default version for maven-compiler-plugin\";\n                if ( value instanceof Plugin )\n                {\n                    Plugin plugin = (Plugin) value;\n                    backupJdk = \"Default target for maven-compiler-plugin version \" + plugin.getVersion();\n                    pluginConf = (Xpp3Dom) plugin.getConfiguration();\n                }\n\n                if ( value instanceof ReportPlugin )\n                {\n                    ReportPlugin reportPlugin = (ReportPlugin) value;\n                    backupJdk = \"Default target for maven-compiler-plugin version \" + reportPlugin.getVersion();\n                    pluginConf = (Xpp3Dom) reportPlugin.getConfiguration();\n                }\n\n                if ( pluginConf == null )\n                {\n                    continue;\n                }\n\n                Xpp3Dom target = pluginConf.getChild( \"target\" );\n                if ( target != null )\n                {\n                    jdk = target.getValue();\n                }\n            }\n\n            return ( jdk == null ) ? backupJdk : jdk;\n        }\n    }\n}\n","lineNo":262}
{"Refactored Sample":"package org.apache.maven.tools.plugin.annotations;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport com.thoughtworks.qdox.JavaDocBuilder;\nimport com.thoughtworks.qdox.model.DocletTag;\nimport com.thoughtworks.qdox.model.JavaClass;\nimport com.thoughtworks.qdox.model.JavaField;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.plugin.descriptor.DuplicateParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ComponentAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ExecuteAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.MojoAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ParameterAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotatedClass;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScanner;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScannerRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.archiver.UnArchiver;\nimport org.codehaus.plexus.archiver.manager.ArchiverManager;\nimport org.codehaus.plexus.archiver.manager.NoSuchArchiverException;\nimport org.codehaus.plexus.component.annotations.Component;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * JavaMojoDescriptorExtractor, a MojoDescriptor extractor to read descriptors from java classes with annotations.\n * Notice that source files are also parsed to get description, since and deprecation information.\n *\n * @author Olivier Lamy\n * @since 3.0\n */\n@Component( role = MojoDescriptorExtractor.class, hint = \"java-annotations\" )\npublic class JavaAnnotationsMojoDescriptorExtractor\n    extends AbstractLogEnabled\n    implements MojoDescriptorExtractor\n{\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private MojoAnnotationsScanner mojoAnnotationsScanner;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArtifactResolver artifactResolver;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArtifactFactory artifactFactory;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArchiverManager archiverManager;\n\n    public List<MojoDescriptor> execute( PluginToolsRequest request )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = scanAnnotations( request );\n\n        Map<String, JavaClass> javaClassesMap = scanJavadoc( request, mojoAnnotatedClasses.values() );\n\n        populateDataFromJavadoc( mojoAnnotatedClasses, javaClassesMap );\n\n        return toMojoDescriptors( mojoAnnotatedClasses, request.getPluginDescriptor() );\n    }\n\n    private Map<String, MojoAnnotatedClass> scanAnnotations( PluginToolsRequest request )\n        throws ExtractionException\n    {\n        MojoAnnotationsScannerRequest mojoAnnotationsScannerRequest = new MojoAnnotationsScannerRequest();\n\n        File output = new File( request.getProject().getBuild().getOutputDirectory() );\n        mojoAnnotationsScannerRequest.setClassesDirectories( Arrays.asList( output ) );\n\n        mojoAnnotationsScannerRequest.setDependencies( request.getDependencies() );\n\n        mojoAnnotationsScannerRequest.setProject( request.getProject() );\n\n        return mojoAnnotationsScanner.scan( mojoAnnotationsScannerRequest );\n    }\n\n    private Map<String, JavaClass> scanJavadoc( PluginToolsRequest request,\n                                                Collection<MojoAnnotatedClass> mojoAnnotatedClasses )\n        throws ExtractionException\n    {\n        // found artifact from reactors to scan sources\n        // we currently only scan sources from reactors\n        List<MavenProject> mavenProjects = new ArrayList<MavenProject>();\n\n        // if we need to scan sources from external artifacts\n        Set<Artifact> externalArtifacts = new HashSet<Artifact>();\n\n        for ( MojoAnnotatedClass mojoAnnotatedClass : mojoAnnotatedClasses )\n        {\n            if ( StringUtils.equals( mojoAnnotatedClass.getArtifact().getArtifactId(),\n                                     request.getProject().getArtifact().getArtifactId() ) )\n            {\n                continue;\n            }\n\n            if ( !isMojoAnnnotatedClassCandidate( mojoAnnotatedClass ) )\n            {\n                // we don't scan sources for classes without mojo annotations\n                continue;\n            }\n\n            MavenProject mavenProject =\n                getFromProjectReferences( mojoAnnotatedClass.getArtifact(), request.getProject() );\n\n            if ( mavenProject != null )\n            {\n                mavenProjects.add( mavenProject );\n            }\n            else\n            {\n                externalArtifacts.add( mojoAnnotatedClass.getArtifact() );\n            }\n        }\n\n        Map<String, JavaClass> javaClassesMap = new HashMap<String, JavaClass>();\n\n        // try to get artifact with sources classifier, extract somewhere then scan for @since, @deprecated\n        for ( Artifact artifact : externalArtifacts )\n        {\n            // parameter for test-sources too ?? olamy I need that for it test only\n            if ( StringUtils.equalsIgnoreCase( \"tests\", artifact.getClassifier() ) )\n            {\n                javaClassesMap.putAll( discoverClassesFromSourcesJar( artifact, request, \"test-sources\" ) );\n            }\n            else\n            {\n                javaClassesMap.putAll( discoverClassesFromSourcesJar( artifact, request, \"sources\" ) );\n            }\n\n        }\n\n        for ( MavenProject mavenProject : mavenProjects )\n        {\n            javaClassesMap.putAll( discoverClasses( request.getEncoding(), mavenProject ) );\n        }\n\n        javaClassesMap.putAll( discoverClasses( request ) );\n\n        return javaClassesMap;\n    }\n\n    private boolean isMojoAnnnotatedClassCandidate( MojoAnnotatedClass mojoAnnotatedClass )\n    {\n        return mojoAnnotatedClass != null && mojoAnnotatedClass.hasAnnotations();\n    }\n\n    protected Map<String, JavaClass> discoverClassesFromSourcesJar( Artifact artifact, PluginToolsRequest request,\n                                                                    String classifier )\n        throws ExtractionException\n    {\n        try\n        {\n            Artifact sourcesArtifact =\n                artifactFactory.createArtifactWithClassifier( artifact.getGroupId(), artifact.getArtifactId(),\n                                                              artifact.getVersion(), artifact.getType(), classifier );\n\n            artifactResolver.resolve( sourcesArtifact, request.getRemoteRepos(), request.getLocal() );\n\n            if ( sourcesArtifact.getFile() == null || !sourcesArtifact.getFile().exists() )\n            {\n                // could not get artifact sources\n                return Collections.emptyMap();\n            }\n\n            // extract sources to target/maven-plugin-plugin-sources/${groupId}/${artifact}/sources\n            File extractDirectory = new File( request.getProject().getBuild().getDirectory(),\n                                              \"maven-plugin-plugin-sources/\" + sourcesArtifact.getGroupId() + \"/\"\n                                                  + sourcesArtifact.getArtifactId() + \"/\" + sourcesArtifact.getVersion()\n                                                  + \"/\" + sourcesArtifact.getClassifier() );\n            extractDirectory.mkdirs();\n\n            UnArchiver unArchiver = archiverManager.getUnArchiver( \"jar\" );\n            unArchiver.setSourceFile( sourcesArtifact.getFile() );\n            unArchiver.setDestDirectory( extractDirectory );\n            unArchiver.extract();\n\n            return discoverClasses( request.getEncoding(), Arrays.asList( extractDirectory ) );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            //throw new ExtractionException( e.getMessage(), e );\n            getLogger().debug( \"skip ArtifactNotFoundException:\" + e.getMessage() );\n            getLogger().warn(\n                \"Unable to get sources artifact for \" + artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\"\n                    + artifact.getVersion() + \". Some javadoc tags (@since, @deprecated and comments) won't be used\" );\n            return Collections.emptyMap();\n        }\n        catch ( NoSuchArchiverException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n\n    /**\n     * from sources scan to get @since and @deprecated and description of classes and fields.\n     *\n     * @param mojoAnnotatedClasses\n     * @param javaClassesMap\n     */\n    protected void populateDataFromJavadoc( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                            Map<String, JavaClass> javaClassesMap )\n    {\n\n        for ( Map.Entry<String, MojoAnnotatedClass> entry : mojoAnnotatedClasses.entrySet() )\n        {\n            JavaClass javaClass = javaClassesMap.get( entry.getKey() );\n            if ( javaClass == null )\n            {\n                continue;\n            }\n\n            // populate class-level content\n            MojoAnnotationContent mojoAnnotationContent = entry.getValue().getMojo();\n            if ( mojoAnnotationContent != null )\n            {\n                mojoAnnotationContent.setDescription( javaClass.getComment() );\n\n                DocletTag since = findInClassHierarchy( javaClass, \"since\" );\n                if ( since != null )\n                {\n                    mojoAnnotationContent.setSince( since.getValue() );\n                }\n\n                DocletTag deprecated = findInClassHierarchy( javaClass, \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    mojoAnnotationContent.setDeprecated( deprecated.getValue() );\n                }\n            }\n\n            Map<String, JavaField> fieldsMap = extractFieldParameterTags( javaClass, javaClassesMap );\n\n            // populate parameters\n            Map<String, ParameterAnnotationContent> parameters =\n                getParametersParentHierarchy( entry.getValue(), new HashMap<String, ParameterAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n            parameters = new TreeMap<String, ParameterAnnotationContent>( parameters );\n            for ( Map.Entry<String, ParameterAnnotationContent> parameter : parameters.entrySet() )\n            {\n                JavaField javaField = fieldsMap.get( parameter.getKey() );\n                if ( javaField == null )\n                {\n                    continue;\n                }\n\n                ParameterAnnotationContent parameterAnnotationContent = parameter.getValue();\n                parameterAnnotationContent.setDescription( javaField.getComment() );\n\n                DocletTag deprecated = javaField.getTagByName( \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    parameterAnnotationContent.setDeprecated( deprecated.getValue() );\n                }\n\n                DocletTag since = javaField.getTagByName( \"since\" );\n                if ( since != null )\n                {\n                    parameterAnnotationContent.setSince( since.getValue() );\n                }\n            }\n\n            // populate components\n            Map<String, ComponentAnnotationContent> components = entry.getValue().getComponents();\n            for ( Map.Entry<String, ComponentAnnotationContent> component : components.entrySet() )\n            {\n                JavaField javaField = fieldsMap.get( component.getKey() );\n                if ( javaField == null )\n                {\n                    continue;\n                }\n\n                ComponentAnnotationContent componentAnnotationContent = component.getValue();\n                componentAnnotationContent.setDescription( javaField.getComment() );\n\n                DocletTag deprecated = javaField.getTagByName( \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    componentAnnotationContent.setDeprecated( deprecated.getValue() );\n                }\n\n                DocletTag since = javaField.getTagByName( \"since\" );\n                if ( since != null )\n                {\n                    componentAnnotationContent.setSince( since.getValue() );\n                }\n            }\n\n        }\n\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName   not null\n     * @return docletTag instance\n     */\n    private DocletTag findInClassHierarchy( JavaClass javaClass, String tagName )\n    {\n        DocletTag tag = javaClass.getTagByName( tagName );\n\n        if ( tag == null )\n        {\n            JavaClass superClass = javaClass.getSuperJavaClass();\n\n            if ( superClass != null )\n            {\n                tag = findInClassHierarchy( superClass, tagName );\n            }\n        }\n\n        return tag;\n    }\n\n    /**\n     * extract fields that are either parameters or components.\n     *\n     * @param javaClass not null\n     * @return map with Mojo parameters names as keys\n     */\n    private Map<String, JavaField> extractFieldParameterTags( JavaClass javaClass,\n                                                              Map<String, JavaClass> javaClassesMap )\n    {\n        Map<String, JavaField> rawParams = new TreeMap<String, com.thoughtworks.qdox.model.JavaField>();\n\n        // we have to add the parent fields first, so that they will be overwritten by the local fields if\n        // that actually happens...\n        JavaClass superClass = javaClass.getSuperJavaClass();\n\n        if ( superClass != null )\n        {\n            if ( superClass.getFields().length > 0 )\n            {\n                rawParams = extractFieldParameterTags( superClass, javaClassesMap );\n            }\n            // maybe sources comes from scan of sources artifact\n            superClass = javaClassesMap.get( superClass.getFullyQualifiedName() );\n            if ( superClass != null )\n            {\n                rawParams = extractFieldParameterTags( superClass, javaClassesMap );\n            }\n        }\n        else\n        {\n\n            rawParams = new TreeMap<String, JavaField>();\n        }\n\n        JavaField[] classFields = javaClass.getFields();\n\n        if ( classFields != null )\n        {\n            for ( JavaField field : classFields )\n            {\n                rawParams.put( field.getName(), field );\n            }\n        }\n        return rawParams;\n    }\n\n    protected Map<String, JavaClass> discoverClasses( final PluginToolsRequest request )\n    {\n        return discoverClasses( request.getEncoding(), request.getProject() );\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    protected Map<String, JavaClass> discoverClasses( final String encoding, final MavenProject project )\n    {\n        List<File> sources = new ArrayList<File>();\n\n        for ( String source : (List<String>) project.getCompileSourceRoots() )\n        {\n            sources.add( new File( source ) );\n        }\n\n        // TODO be more dynamic\n        File generatedPlugin = new File( project.getBasedir(), \"target/generated-sources/plugin\" );\n        if ( !project.getCompileSourceRoots().contains( generatedPlugin.getAbsolutePath() )\n            && generatedPlugin.exists() )\n        {\n            sources.add( generatedPlugin );\n        }\n\n        return discoverClasses( encoding, sources );\n    }\n\n    protected Map<String, JavaClass> discoverClasses( final String encoding, List<File> sourceDirectories )\n    {\n        JavaDocBuilder builder = new JavaDocBuilder();\n        builder.setEncoding( encoding );\n\n        for ( File source : sourceDirectories )\n        {\n            builder.addSourceTree( source );\n        }\n\n        JavaClass[] javaClasses = builder.getClasses();\n\n        if ( javaClasses == null || javaClasses.length < 1 )\n        {\n            return Collections.emptyMap();\n        }\n\n        Map<String, JavaClass> javaClassMap = new HashMap<String, JavaClass>( javaClasses.length );\n\n        for ( JavaClass javaClass : javaClasses )\n        {\n            javaClassMap.put( javaClass.getFullyQualifiedName(), javaClass );\n        }\n\n        return javaClassMap;\n    }\n\n    private List<MojoDescriptor> toMojoDescriptors( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                                    PluginDescriptor pluginDescriptor )\n        throws DuplicateParameterException, InvalidParameterException\n    {\n        List<MojoDescriptor> mojoDescriptors = new ArrayList<MojoDescriptor>( mojoAnnotatedClasses.size() );\n        for ( MojoAnnotatedClass mojoAnnotatedClass : mojoAnnotatedClasses.values() )\n        {\n            // no mojo so skip it\n            if ( mojoAnnotatedClass.getMojo() == null )\n            {\n                continue;\n            }\n\n            ExtendedMojoDescriptor mojoDescriptor = new ExtendedMojoDescriptor();\n\n            //mojoDescriptor.setRole( mojoAnnotatedClass.getClassName() );\n            //mojoDescriptor.setRoleHint( \"default\" );\n            mojoDescriptor.setImplementation( mojoAnnotatedClass.getClassName() );\n            mojoDescriptor.setLanguage( \"java\" );\n\n            MojoAnnotationContent mojo = mojoAnnotatedClass.getMojo();\n\n            mojoDescriptor.setDescription( mojo.getDescription() );\n            mojoDescriptor.setSince( mojo.getSince() );\n            mojo.setDeprecated( mojo.getDeprecated() );\n\n            mojoDescriptor.setProjectRequired( mojo.requiresProject() );\n\n            mojoDescriptor.setRequiresReports( mojo.requiresReports() );\n\n            mojoDescriptor.setComponentConfigurator( mojo.configurator() );\n\n            mojoDescriptor.setInheritedByDefault( mojo.inheritByDefault() );\n\n            mojoDescriptor.setInstantiationStrategy( mojo.instantiationStrategy().id() );\n\n            mojoDescriptor.setAggregator( mojo.aggregator() );\n            mojoDescriptor.setDependencyResolutionRequired( mojo.requiresDependencyResolution().id() );\n            mojoDescriptor.setDependencyCollectionRequired( mojo.requiresDependencyCollection().id() );\n\n            mojoDescriptor.setDirectInvocationOnly( mojo.requiresDirectInvocation() );\n            mojoDescriptor.setDeprecated( mojo.getDeprecated() );\n            mojoDescriptor.setThreadSafe( mojo.threadSafe() );\n\n            ExecuteAnnotationContent execute = findExecuteInParentHierarchy( mojoAnnotatedClass, mojoAnnotatedClasses );\n            if ( execute != null )\n            {\n                mojoDescriptor.setExecuteGoal( execute.goal() );\n                mojoDescriptor.setExecuteLifecycle( execute.lifecycle() );\n                if ( execute.phase() != null )\n                {\n                    mojoDescriptor.setExecutePhase( execute.phase().id() );\n                }\n            }\n\n            mojoDescriptor.setExecutionStrategy( mojo.executionStrategy() );\n            // ???\n            //mojoDescriptor.alwaysExecute(mojo.a)\n\n            mojoDescriptor.setGoal( mojo.name() );\n            mojoDescriptor.setOnlineRequired( mojo.requiresOnline() );\n\n            mojoDescriptor.setPhase( mojo.defaultPhase().id() );\n\n            // Parameter annotations\n            Map<String, ParameterAnnotationContent> parameters =\n                getParametersParentHierarchy( mojoAnnotatedClass, new HashMap<String, ParameterAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n\n            for ( ParameterAnnotationContent parameterAnnotationContent : new TreeSet<ParameterAnnotationContent>(\n                parameters.values() ) )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                String name =\n                    StringUtils.isEmpty( parameterAnnotationContent.name() ) ? parameterAnnotationContent.getFieldName()\n                                    : parameterAnnotationContent.name();\n                parameter.setName( name );\n                parameter.setAlias( parameterAnnotationContent.alias() );\n                parameter.setDefaultValue( parameterAnnotationContent.defaultValue() );\n                parameter.setDeprecated( parameterAnnotationContent.getDeprecated() );\n                parameter.setDescription( parameterAnnotationContent.getDescription() );\n                parameter.setEditable( !parameterAnnotationContent.readonly() );\n                String property = parameterAnnotationContent.property();\n                if ( StringUtils.contains( property, '$' ) || StringUtils.contains( property, '{' )\n                    || StringUtils.contains( property, '}' ) )\n                {\n                    throw new InvalidParameterException(\n                        \"Invalid property for parameter '\" + parameter.getName() + \"', \" + \"forbidden characters ${}: \"\n                            + property, null );\n                }\n                parameter.setExpression( StringUtils.isEmpty( property ) ? \"\" : \"${\" + property + \"}\" );\n                parameter.setType( parameterAnnotationContent.getClassName() );\n                parameter.setSince( parameterAnnotationContent.getSince() );\n                parameter.setRequired( parameterAnnotationContent.required() );\n\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            // Component annotations\n            Map<String, ComponentAnnotationContent> components =\n                getComponentsParentHierarchy( mojoAnnotatedClass, new HashMap<String, ComponentAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n\n            for ( ComponentAnnotationContent componentAnnotationContent : new TreeSet<ComponentAnnotationContent>(\n                components.values() ) )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                parameter.setName( componentAnnotationContent.getFieldName() );\n\n                // recognize Maven-injected objects as components annotations instead of parameters\n                String expression = PluginUtils.MAVEN_COMPONENTS.get( componentAnnotationContent.getRoleClassName() );\n                if ( expression == null )\n                {\n                    // normal component\n                    parameter.setRequirement( new Requirement( componentAnnotationContent.getRoleClassName(),\n                                                               componentAnnotationContent.hint() ) );\n                }\n                else\n                {\n                    // not a component but a Maven object to be transformed into an expression/property: deprecated\n                    getLogger().warn( \"Deprecated @Component annotation for '\" + parameter.getName() + \"' field in \"\n                                          + mojoAnnotatedClass.getClassName()\n                                          + \": replace with @Parameter( default-value = \\\"\" + expression\n                                          + \"\\\", readonly = true )\" );\n                    parameter.setDefaultValue( expression );\n                    parameter.setType( componentAnnotationContent.getRoleClassName() );\n                    parameter.setRequired( true );\n                }\n                parameter.setDeprecated( componentAnnotationContent.getDeprecated() );\n                parameter.setSince( componentAnnotationContent.getSince() );\n\n                // same behaviour as JavaMojoDescriptorExtractor\n                //parameter.setRequired( ... );\n                parameter.setEditable( false );\n\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            mojoDescriptor.setPluginDescriptor( pluginDescriptor );\n\n            mojoDescriptors.add( mojoDescriptor );\n        }\n        return mojoDescriptors;\n    }\n\n    protected ExecuteAnnotationContent findExecuteInParentHierarchy( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                 Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        if ( mojoAnnotatedClass.getExecute() != null )\n        {\n            return mojoAnnotatedClass.getExecute();\n        }\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( StringUtils.isEmpty( parentClassName ) )\n        {\n            return null;\n        }\n        MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n        if ( parent == null )\n        {\n            return null;\n        }\n        return findExecuteInParentHierarchy( parent, mojoAnnotatedClasses );\n    }\n\n\n    protected Map<String, ParameterAnnotationContent> getParametersParentHierarchy(\n        MojoAnnotatedClass mojoAnnotatedClass, Map<String, ParameterAnnotationContent> parameters,\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        List<ParameterAnnotationContent> parameterAnnotationContents = new ArrayList<ParameterAnnotationContent>();\n\n        parameterAnnotationContents =\n            getParametersParent( mojoAnnotatedClass, parameterAnnotationContents, mojoAnnotatedClasses );\n\n        // move to parent first to build the Map\n        Collections.reverse( parameterAnnotationContents );\n\n        Map<String, ParameterAnnotationContent> map =\n            new HashMap<String, ParameterAnnotationContent>( parameterAnnotationContents.size() );\n\n        for ( ParameterAnnotationContent parameterAnnotationContent : parameterAnnotationContents )\n        {\n            map.put( parameterAnnotationContent.getFieldName(), parameterAnnotationContent );\n        }\n        return map;\n    }\n\n    protected List<ParameterAnnotationContent> getParametersParent( MojoAnnotatedClass mojoAnnotatedClass,\n                                                        List<ParameterAnnotationContent> parameterAnnotationContents,\n                                                        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        parameterAnnotationContents.addAll( mojoAnnotatedClass.getParameters().values() );\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( parentClassName != null )\n        {\n            MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n            if ( parent != null )\n            {\n                return getParametersParent( parent, parameterAnnotationContents, mojoAnnotatedClasses );\n            }\n        }\n        return parameterAnnotationContents;\n    }\n\n    protected Map<String, ComponentAnnotationContent> getComponentsParentHierarchy(\n        MojoAnnotatedClass mojoAnnotatedClass, Map<String, ComponentAnnotationContent> components,\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        List<ComponentAnnotationContent> componentAnnotationContents = new ArrayList<ComponentAnnotationContent>();\n\n        componentAnnotationContents =\n            getComponentParent( mojoAnnotatedClass, componentAnnotationContents, mojoAnnotatedClasses );\n\n        // move to parent first to build the Map\n        Collections.reverse( componentAnnotationContents );\n\n        Map<String, ComponentAnnotationContent> map =\n            new HashMap<String, ComponentAnnotationContent>( componentAnnotationContents.size() );\n\n        for ( ComponentAnnotationContent componentAnnotationContent : componentAnnotationContents )\n        {\n            map.put( componentAnnotationContent.getFieldName(), componentAnnotationContent );\n        }\n        return map;\n    }\n\n    protected List<ComponentAnnotationContent> getComponentParent( MojoAnnotatedClass mojoAnnotatedClass,\n                                                       List<ComponentAnnotationContent> componentAnnotationContents,\n                                                       Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        componentAnnotationContents.addAll( mojoAnnotatedClass.getComponents().values() );\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( parentClassName != null )\n        {\n            MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n            if ( parent != null )\n            {\n                return getComponentParent( parent, componentAnnotationContents, mojoAnnotatedClasses );\n            }\n        }\n        return componentAnnotationContents;\n    }\n\n    protected MavenProject getFromProjectReferences( Artifact artifact, MavenProject project )\n    {\n        if ( project.getProjectReferences() == null || project.getProjectReferences().isEmpty() )\n        {\n            return null;\n        }\n        @SuppressWarnings( \"unchecked\" ) Collection<MavenProject> mavenProjects =\n            project.getProjectReferences().values();\n        for ( MavenProject mavenProject : mavenProjects )\n        {\n            if ( StringUtils.equals( mavenProject.getId(), artifact.getId() ) )\n            {\n                return mavenProject;\n            }\n        }\n        return null;\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.annotations;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport com.thoughtworks.qdox.JavaDocBuilder;\nimport com.thoughtworks.qdox.model.DocletTag;\nimport com.thoughtworks.qdox.model.JavaClass;\nimport com.thoughtworks.qdox.model.JavaField;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.plugin.descriptor.DuplicateParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ComponentAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ExecuteAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.MojoAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ParameterAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotatedClass;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScanner;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScannerRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.archiver.UnArchiver;\nimport org.codehaus.plexus.archiver.manager.ArchiverManager;\nimport org.codehaus.plexus.archiver.manager.NoSuchArchiverException;\nimport org.codehaus.plexus.component.annotations.Component;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * JavaMojoDescriptorExtractor, a MojoDescriptor extractor to read descriptors from java classes with annotations.\n * Notice that source files are also parsed to get description, since and deprecation information.\n *\n * @author Olivier Lamy\n * @since 3.0\n */\n@Component( role = MojoDescriptorExtractor.class, hint = \"java-annotations\" )\npublic class JavaAnnotationsMojoDescriptorExtractor\n    extends AbstractLogEnabled\n    implements MojoDescriptorExtractor\n{\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private MojoAnnotationsScanner mojoAnnotationsScanner;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArtifactResolver artifactResolver;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArtifactFactory artifactFactory;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArchiverManager archiverManager;\n\n    public List<MojoDescriptor> execute( PluginToolsRequest request )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = scanAnnotations( request );\n\n        Map<String, JavaClass> javaClassesMap = scanJavadoc( request, mojoAnnotatedClasses.values() );\n\n        populateDataFromJavadoc( mojoAnnotatedClasses, javaClassesMap );\n\n        return toMojoDescriptors( mojoAnnotatedClasses, request.getPluginDescriptor() );\n    }\n\n    private Map<String, MojoAnnotatedClass> scanAnnotations( PluginToolsRequest request )\n        throws ExtractionException\n    {\n        MojoAnnotationsScannerRequest mojoAnnotationsScannerRequest = new MojoAnnotationsScannerRequest();\n\n        File output = new File( request.getProject().getBuild().getOutputDirectory() );\n        mojoAnnotationsScannerRequest.setClassesDirectories( Arrays.asList( output ) );\n\n        mojoAnnotationsScannerRequest.setDependencies( request.getDependencies() );\n\n        mojoAnnotationsScannerRequest.setProject( request.getProject() );\n\n        return mojoAnnotationsScanner.scan( mojoAnnotationsScannerRequest );\n    }\n\n    private Map<String, JavaClass> scanJavadoc( PluginToolsRequest request,\n                                                Collection<MojoAnnotatedClass> mojoAnnotatedClasses )\n        throws ExtractionException\n    {\n        // found artifact from reactors to scan sources\n        // we currently only scan sources from reactors\n        List<MavenProject> mavenProjects = new ArrayList<MavenProject>();\n\n        // if we need to scan sources from external artifacts\n        Set<Artifact> externalArtifacts = new HashSet<Artifact>();\n\n        for ( MojoAnnotatedClass mojoAnnotatedClass : mojoAnnotatedClasses )\n        {\n            if ( StringUtils.equals( mojoAnnotatedClass.getArtifact().getArtifactId(),\n                                     request.getProject().getArtifact().getArtifactId() ) )\n            {\n                continue;\n            }\n\n            if ( !isMojoAnnnotatedClassCandidate( mojoAnnotatedClass ) )\n            {\n                // we don't scan sources for classes without mojo annotations\n                continue;\n            }\n\n            MavenProject mavenProject =\n                getFromProjectReferences( mojoAnnotatedClass.getArtifact(), request.getProject() );\n\n            if ( mavenProject != null )\n            {\n                mavenProjects.add( mavenProject );\n            }\n            else\n            {\n                externalArtifacts.add( mojoAnnotatedClass.getArtifact() );\n            }\n        }\n\n        Map<String, JavaClass> javaClassesMap = new HashMap<String, JavaClass>();\n\n        // try to get artifact with sources classifier, extract somewhere then scan for @since, @deprecated\n        for ( Artifact artifact : externalArtifacts )\n        {\n            // parameter for test-sources too ?? olamy I need that for it test only\n            if ( StringUtils.equalsIgnoreCase( \"tests\", artifact.getClassifier() ) )\n            {\n                javaClassesMap.putAll( discoverClassesFromSourcesJar( artifact, request, \"test-sources\" ) );\n            }\n            else\n            {\n                javaClassesMap.putAll( discoverClassesFromSourcesJar( artifact, request, \"sources\" ) );\n            }\n\n        }\n\n        for ( MavenProject mavenProject : mavenProjects )\n        {\n            javaClassesMap.putAll( discoverClasses( request.getEncoding(), mavenProject ) );\n        }\n\n        javaClassesMap.putAll( discoverClasses( request ) );\n\n        return javaClassesMap;\n    }\n\n    private boolean isMojoAnnnotatedClassCandidate( MojoAnnotatedClass mojoAnnotatedClass )\n    {\n        return mojoAnnotatedClass != null && mojoAnnotatedClass.hasAnnotations();\n    }\n\n    protected Map<String, JavaClass> discoverClassesFromSourcesJar( Artifact artifact, PluginToolsRequest request,\n                                                                    String classifier )\n        throws ExtractionException\n    {\n        try\n        {\n            Artifact sourcesArtifact =\n                artifactFactory.createArtifactWithClassifier( artifact.getGroupId(), artifact.getArtifactId(),\n                                                              artifact.getVersion(), artifact.getType(), classifier );\n\n            artifactResolver.resolve( sourcesArtifact, request.getRemoteRepos(), request.getLocal() );\n\n            if ( sourcesArtifact.getFile() == null || !sourcesArtifact.getFile().exists() )\n            {\n                // could not get artifact sources\n                return Collections.emptyMap();\n            }\n\n            // extract sources to target/maven-plugin-plugin-sources/${groupId}/${artifact}/sources\n            File extractDirectory = new File( request.getProject().getBuild().getDirectory(),\n                                              \"maven-plugin-plugin-sources/\" + sourcesArtifact.getGroupId() + \"/\"\n                                                  + sourcesArtifact.getArtifactId() + \"/\" + sourcesArtifact.getVersion()\n                                                  + \"/\" + sourcesArtifact.getClassifier() );\n            extractDirectory.mkdirs();\n\n            UnArchiver unArchiver = archiverManager.getUnArchiver( \"jar\" );\n            unArchiver.setSourceFile( sourcesArtifact.getFile() );\n            unArchiver.setDestDirectory( extractDirectory );\n            unArchiver.extract();\n\n            return discoverClasses( request.getEncoding(), Arrays.asList( extractDirectory ) );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            //throw new ExtractionException( e.getMessage(), e );\n            getLogger().debug( \"skip ArtifactNotFoundException:\" + e.getMessage() );\n            getLogger().warn(\n                \"Unable to get sources artifact for \" + artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\"\n                    + artifact.getVersion() + \". Some javadoc tags (@since, @deprecated and comments) won't be used\" );\n            return Collections.emptyMap();\n        }\n        catch ( NoSuchArchiverException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n\n    /**\n     * from sources scan to get @since and @deprecated and description of classes and fields.\n     *\n     * @param mojoAnnotatedClasses\n     * @param javaClassesMap\n     */\n    protected void populateDataFromJavadoc( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                            Map<String, JavaClass> javaClassesMap )\n    {\n\n        for ( Map.Entry<String, MojoAnnotatedClass> entry : mojoAnnotatedClasses.entrySet() )\n        {\n            JavaClass javaClass = javaClassesMap.get( entry.getKey() );\n            if ( javaClass == null )\n            {\n                continue;\n            }\n\n            // populate class-level content\n            MojoAnnotationContent mojoAnnotationContent = entry.getValue().getMojo();\n            if ( mojoAnnotationContent != null )\n            {\n                mojoAnnotationContent.setDescription( javaClass.getComment() );\n\n                DocletTag since = findInClassHierarchy( javaClass, \"since\" );\n                if ( since != null )\n                {\n                    mojoAnnotationContent.setSince( since.getValue() );\n                }\n\n                DocletTag deprecated = findInClassHierarchy( javaClass, \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    mojoAnnotationContent.setDeprecated( deprecated.getValue() );\n                }\n            }\n\n            Map<String, JavaField> fieldsMap = extractFieldParameterTags( javaClass, javaClassesMap );\n\n            // populate parameters\n            Map<String, ParameterAnnotationContent> parameters =\n                getParametersParentHierarchy( entry.getValue(), new HashMap<String, ParameterAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n            for ( Map.Entry<String, ParameterAnnotationContent> parameter : new TreeMap<String, ParameterAnnotationContent>(\n                parameters ).entrySet() )\n            {\n                JavaField javaField = fieldsMap.get( parameter.getKey() );\n                if ( javaField == null )\n                {\n                    continue;\n                }\n\n                ParameterAnnotationContent parameterAnnotationContent = parameter.getValue();\n                parameterAnnotationContent.setDescription( javaField.getComment() );\n\n                DocletTag deprecated = javaField.getTagByName( \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    parameterAnnotationContent.setDeprecated( deprecated.getValue() );\n                }\n\n                DocletTag since = javaField.getTagByName( \"since\" );\n                if ( since != null )\n                {\n                    parameterAnnotationContent.setSince( since.getValue() );\n                }\n            }\n\n            // populate components\n            for ( Map.Entry<String, ComponentAnnotationContent> component : entry.getValue().getComponents().entrySet() )\n            {\n                JavaField javaField = fieldsMap.get( component.getKey() );\n                if ( javaField == null )\n                {\n                    continue;\n                }\n\n                ComponentAnnotationContent componentAnnotationContent = component.getValue();\n                componentAnnotationContent.setDescription( javaField.getComment() );\n\n                DocletTag deprecated = javaField.getTagByName( \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    componentAnnotationContent.setDeprecated( deprecated.getValue() );\n                }\n\n                DocletTag since = javaField.getTagByName( \"since\" );\n                if ( since != null )\n                {\n                    componentAnnotationContent.setSince( since.getValue() );\n                }\n            }\n\n        }\n\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName   not null\n     * @return docletTag instance\n     */\n    private DocletTag findInClassHierarchy( JavaClass javaClass, String tagName )\n    {\n        DocletTag tag = javaClass.getTagByName( tagName );\n\n        if ( tag == null )\n        {\n            JavaClass superClass = javaClass.getSuperJavaClass();\n\n            if ( superClass != null )\n            {\n                tag = findInClassHierarchy( superClass, tagName );\n            }\n        }\n\n        return tag;\n    }\n\n    /**\n     * extract fields that are either parameters or components.\n     *\n     * @param javaClass not null\n     * @return map with Mojo parameters names as keys\n     */\n    private Map<String, JavaField> extractFieldParameterTags( JavaClass javaClass,\n                                                              Map<String, JavaClass> javaClassesMap )\n    {\n        Map<String, JavaField> rawParams = new TreeMap<String, com.thoughtworks.qdox.model.JavaField>();\n\n        // we have to add the parent fields first, so that they will be overwritten by the local fields if\n        // that actually happens...\n        JavaClass superClass = javaClass.getSuperJavaClass();\n\n        if ( superClass != null )\n        {\n            if ( superClass.getFields().length > 0 )\n            {\n                rawParams = extractFieldParameterTags( superClass, javaClassesMap );\n            }\n            // maybe sources comes from scan of sources artifact\n            superClass = javaClassesMap.get( superClass.getFullyQualifiedName() );\n            if ( superClass != null )\n            {\n                rawParams = extractFieldParameterTags( superClass, javaClassesMap );\n            }\n        }\n        else\n        {\n\n            rawParams = new TreeMap<String, JavaField>();\n        }\n\n        JavaField[] classFields = javaClass.getFields();\n\n        if ( classFields != null )\n        {\n            for ( JavaField field : classFields )\n            {\n                rawParams.put( field.getName(), field );\n            }\n        }\n        return rawParams;\n    }\n\n    protected Map<String, JavaClass> discoverClasses( final PluginToolsRequest request )\n    {\n        return discoverClasses( request.getEncoding(), request.getProject() );\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    protected Map<String, JavaClass> discoverClasses( final String encoding, final MavenProject project )\n    {\n        List<File> sources = new ArrayList<File>();\n\n        for ( String source : (List<String>) project.getCompileSourceRoots() )\n        {\n            sources.add( new File( source ) );\n        }\n\n        // TODO be more dynamic\n        File generatedPlugin = new File( project.getBasedir(), \"target/generated-sources/plugin\" );\n        if ( !project.getCompileSourceRoots().contains( generatedPlugin.getAbsolutePath() )\n            && generatedPlugin.exists() )\n        {\n            sources.add( generatedPlugin );\n        }\n\n        return discoverClasses( encoding, sources );\n    }\n\n    protected Map<String, JavaClass> discoverClasses( final String encoding, List<File> sourceDirectories )\n    {\n        JavaDocBuilder builder = new JavaDocBuilder();\n        builder.setEncoding( encoding );\n\n        for ( File source : sourceDirectories )\n        {\n            builder.addSourceTree( source );\n        }\n\n        JavaClass[] javaClasses = builder.getClasses();\n\n        if ( javaClasses == null || javaClasses.length < 1 )\n        {\n            return Collections.emptyMap();\n        }\n\n        Map<String, JavaClass> javaClassMap = new HashMap<String, JavaClass>( javaClasses.length );\n\n        for ( JavaClass javaClass : javaClasses )\n        {\n            javaClassMap.put( javaClass.getFullyQualifiedName(), javaClass );\n        }\n\n        return javaClassMap;\n    }\n\n    private List<MojoDescriptor> toMojoDescriptors( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                                    PluginDescriptor pluginDescriptor )\n        throws DuplicateParameterException, InvalidParameterException\n    {\n        List<MojoDescriptor> mojoDescriptors = new ArrayList<MojoDescriptor>( mojoAnnotatedClasses.size() );\n        for ( MojoAnnotatedClass mojoAnnotatedClass : mojoAnnotatedClasses.values() )\n        {\n            // no mojo so skip it\n            if ( mojoAnnotatedClass.getMojo() == null )\n            {\n                continue;\n            }\n\n            ExtendedMojoDescriptor mojoDescriptor = new ExtendedMojoDescriptor();\n\n            //mojoDescriptor.setRole( mojoAnnotatedClass.getClassName() );\n            //mojoDescriptor.setRoleHint( \"default\" );\n            mojoDescriptor.setImplementation( mojoAnnotatedClass.getClassName() );\n            mojoDescriptor.setLanguage( \"java\" );\n\n            MojoAnnotationContent mojo = mojoAnnotatedClass.getMojo();\n\n            mojoDescriptor.setDescription( mojo.getDescription() );\n            mojoDescriptor.setSince( mojo.getSince() );\n            mojo.setDeprecated( mojo.getDeprecated() );\n\n            mojoDescriptor.setProjectRequired( mojo.requiresProject() );\n\n            mojoDescriptor.setRequiresReports( mojo.requiresReports() );\n\n            mojoDescriptor.setComponentConfigurator( mojo.configurator() );\n\n            mojoDescriptor.setInheritedByDefault( mojo.inheritByDefault() );\n\n            mojoDescriptor.setInstantiationStrategy( mojo.instantiationStrategy().id() );\n\n            mojoDescriptor.setAggregator( mojo.aggregator() );\n            mojoDescriptor.setDependencyResolutionRequired( mojo.requiresDependencyResolution().id() );\n            mojoDescriptor.setDependencyCollectionRequired( mojo.requiresDependencyCollection().id() );\n\n            mojoDescriptor.setDirectInvocationOnly( mojo.requiresDirectInvocation() );\n            mojoDescriptor.setDeprecated( mojo.getDeprecated() );\n            mojoDescriptor.setThreadSafe( mojo.threadSafe() );\n\n            ExecuteAnnotationContent execute = findExecuteInParentHierarchy( mojoAnnotatedClass, mojoAnnotatedClasses );\n            if ( execute != null )\n            {\n                mojoDescriptor.setExecuteGoal( execute.goal() );\n                mojoDescriptor.setExecuteLifecycle( execute.lifecycle() );\n                if ( execute.phase() != null )\n                {\n                    mojoDescriptor.setExecutePhase( execute.phase().id() );\n                }\n            }\n\n            mojoDescriptor.setExecutionStrategy( mojo.executionStrategy() );\n            // ???\n            //mojoDescriptor.alwaysExecute(mojo.a)\n\n            mojoDescriptor.setGoal( mojo.name() );\n            mojoDescriptor.setOnlineRequired( mojo.requiresOnline() );\n\n            mojoDescriptor.setPhase( mojo.defaultPhase().id() );\n\n            // Parameter annotations\n            Map<String, ParameterAnnotationContent> parameters =\n                getParametersParentHierarchy( mojoAnnotatedClass, new HashMap<String, ParameterAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n\n            for ( ParameterAnnotationContent parameterAnnotationContent : new TreeSet<ParameterAnnotationContent>(\n                parameters.values() ) )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                String name =\n                    StringUtils.isEmpty( parameterAnnotationContent.name() ) ? parameterAnnotationContent.getFieldName()\n                                    : parameterAnnotationContent.name();\n                parameter.setName( name );\n                parameter.setAlias( parameterAnnotationContent.alias() );\n                parameter.setDefaultValue( parameterAnnotationContent.defaultValue() );\n                parameter.setDeprecated( parameterAnnotationContent.getDeprecated() );\n                parameter.setDescription( parameterAnnotationContent.getDescription() );\n                parameter.setEditable( !parameterAnnotationContent.readonly() );\n                String property = parameterAnnotationContent.property();\n                if ( StringUtils.contains( property, '$' ) || StringUtils.contains( property, '{' )\n                    || StringUtils.contains( property, '}' ) )\n                {\n                    throw new InvalidParameterException(\n                        \"Invalid property for parameter '\" + parameter.getName() + \"', \" + \"forbidden characters ${}: \"\n                            + property, null );\n                }\n                parameter.setExpression( StringUtils.isEmpty( property ) ? \"\" : \"${\" + property + \"}\" );\n                parameter.setType( parameterAnnotationContent.getClassName() );\n                parameter.setSince( parameterAnnotationContent.getSince() );\n                parameter.setRequired( parameterAnnotationContent.required() );\n\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            // Component annotations\n            Map<String, ComponentAnnotationContent> components =\n                getComponentsParentHierarchy( mojoAnnotatedClass, new HashMap<String, ComponentAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n\n            for ( ComponentAnnotationContent componentAnnotationContent : new TreeSet<ComponentAnnotationContent>(\n                components.values() ) )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                parameter.setName( componentAnnotationContent.getFieldName() );\n\n                // recognize Maven-injected objects as components annotations instead of parameters\n                String expression = PluginUtils.MAVEN_COMPONENTS.get( componentAnnotationContent.getRoleClassName() );\n                if ( expression == null )\n                {\n                    // normal component\n                    parameter.setRequirement( new Requirement( componentAnnotationContent.getRoleClassName(),\n                                                               componentAnnotationContent.hint() ) );\n                }\n                else\n                {\n                    // not a component but a Maven object to be transformed into an expression/property: deprecated\n                    getLogger().warn( \"Deprecated @Component annotation for '\" + parameter.getName() + \"' field in \" +\n                                          mojoAnnotatedClass.getClassName() +\n                                          \": replace with @Parameter( default-value = \\\"\" + expression + \"\\\", readonly = true )\" );\n                    parameter.setDefaultValue( expression );\n                    parameter.setType( componentAnnotationContent.getRoleClassName() );\n                    parameter.setRequired( true );\n                }\n                parameter.setDeprecated( componentAnnotationContent.getDeprecated() );\n                parameter.setSince( componentAnnotationContent.getSince() );\n\n                // same behaviour as JavaMojoDescriptorExtractor\n                //parameter.setRequired( ... );\n                parameter.setEditable( false );\n\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            mojoDescriptor.setPluginDescriptor( pluginDescriptor );\n\n            mojoDescriptors.add( mojoDescriptor );\n        }\n        return mojoDescriptors;\n    }\n\n    protected ExecuteAnnotationContent findExecuteInParentHierarchy( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                     Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        if ( mojoAnnotatedClass.getExecute() != null )\n        {\n            return mojoAnnotatedClass.getExecute();\n        }\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( StringUtils.isEmpty( parentClassName ) )\n        {\n            return null;\n        }\n        MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n        if ( parent == null )\n        {\n            return null;\n        }\n        return findExecuteInParentHierarchy( parent, mojoAnnotatedClasses );\n    }\n\n\n    protected Map<String, ParameterAnnotationContent> getParametersParentHierarchy(\n        MojoAnnotatedClass mojoAnnotatedClass, Map<String, ParameterAnnotationContent> parameters,\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        List<ParameterAnnotationContent> parameterAnnotationContents = new ArrayList<ParameterAnnotationContent>();\n\n        parameterAnnotationContents =\n            getParametersParent( mojoAnnotatedClass, parameterAnnotationContents, mojoAnnotatedClasses );\n\n        // move to parent first to build the Map\n        Collections.reverse( parameterAnnotationContents );\n\n        Map<String, ParameterAnnotationContent> map =\n            new HashMap<String, ParameterAnnotationContent>( parameterAnnotationContents.size() );\n\n        for ( ParameterAnnotationContent parameterAnnotationContent : parameterAnnotationContents )\n        {\n            map.put( parameterAnnotationContent.getFieldName(), parameterAnnotationContent );\n        }\n        return map;\n    }\n\n    protected List<ParameterAnnotationContent> getParametersParent( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                    List<ParameterAnnotationContent> parameterAnnotationContents,\n                                                                    Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        parameterAnnotationContents.addAll( mojoAnnotatedClass.getParameters().values() );\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( parentClassName != null )\n        {\n            MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n            if ( parent != null )\n            {\n                return getParametersParent( parent, parameterAnnotationContents, mojoAnnotatedClasses );\n            }\n        }\n        return parameterAnnotationContents;\n    }\n\n    protected Map<String, ComponentAnnotationContent> getComponentsParentHierarchy(\n        MojoAnnotatedClass mojoAnnotatedClass, Map<String, ComponentAnnotationContent> components,\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        List<ComponentAnnotationContent> componentAnnotationContents = new ArrayList<ComponentAnnotationContent>();\n\n        componentAnnotationContents =\n            getComponentParent( mojoAnnotatedClass, componentAnnotationContents, mojoAnnotatedClasses );\n\n        // move to parent first to build the Map\n        Collections.reverse( componentAnnotationContents );\n\n        Map<String, ComponentAnnotationContent> map =\n            new HashMap<String, ComponentAnnotationContent>( componentAnnotationContents.size() );\n\n        for ( ComponentAnnotationContent componentAnnotationContent : componentAnnotationContents )\n        {\n            map.put( componentAnnotationContent.getFieldName(), componentAnnotationContent );\n        }\n        return map;\n    }\n\n    protected List<ComponentAnnotationContent> getComponentParent( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                   List<ComponentAnnotationContent> componentAnnotationContents,\n                                                                   Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        componentAnnotationContents.addAll( mojoAnnotatedClass.getComponents().values() );\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( parentClassName != null )\n        {\n            MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n            if ( parent != null )\n            {\n                return getComponentParent( parent, componentAnnotationContents, mojoAnnotatedClasses );\n            }\n        }\n        return componentAnnotationContents;\n    }\n\n    protected MavenProject getFromProjectReferences( Artifact artifact, MavenProject project )\n    {\n        if ( project.getProjectReferences() == null || project.getProjectReferences().isEmpty() )\n        {\n            return null;\n        }\n        @SuppressWarnings( \"unchecked\" ) Collection<MavenProject> mavenProjects =\n            project.getProjectReferences().values();\n        for ( MavenProject mavenProject : mavenProjects )\n        {\n            if ( StringUtils.equals( mavenProject.getId(), artifact.getId() ) )\n            {\n                return mavenProject;\n            }\n        }\n        return null;\n    }\n\n}\n","lineNo":312}
{"Refactored Sample":"package org.apache.maven.tools.plugin.annotations.scanner;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ComponentAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ExecuteAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.MojoAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ParameterAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoAnnotationVisitor;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoClassVisitor;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoFieldVisitor;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.DirectoryScanner;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.reflection.Reflector;\nimport org.codehaus.plexus.util.reflection.ReflectorException;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.Type;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\n/**\n * @author Olivier Lamy\n * @since 3.0\n */\n@org.codehaus.plexus.component.annotations.Component( role = MojoAnnotationsScanner.class )\npublic class DefaultMojoAnnotationsScanner\n    extends AbstractLogEnabled\n    implements MojoAnnotationsScanner\n{\n    private Reflector reflector = new Reflector();\n\n    public Map<String, MojoAnnotatedClass> scan( MojoAnnotationsScannerRequest request )\n        throws ExtractionException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n\n        try\n        {\n            for ( Artifact dependency : request.getDependencies() )\n            {\n                scan( mojoAnnotatedClasses, dependency.getFile(), request.getIncludePatterns(), dependency, true );\n            }\n\n            for ( File classDirectory : request.getClassesDirectories() )\n            {\n                scan( mojoAnnotatedClasses, classDirectory, request.getIncludePatterns(),\n                      request.getProject().getArtifact(), false );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n\n        return mojoAnnotatedClasses;\n    }\n\n    protected void scan( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses, File source,\n                         List<String> includePatterns, Artifact artifact, boolean excludeMojo )\n        throws IOException, ExtractionException\n    {\n        if ( source == null || ! source.exists() )\n        {\n            return;\n        }\n\n        Map<String, MojoAnnotatedClass> scanResult;\n        if ( source.isDirectory() )\n        {\n            scanResult = scanDirectory( source, includePatterns, artifact, excludeMojo );\n        }\n        else\n        {\n            scanResult = scanArchive( source, artifact, excludeMojo );\n        }\n\n        mojoAnnotatedClasses.putAll( scanResult );\n    }\n\n    /**\n     * @param archiveFile\n     * @param artifact\n     * @param excludeMojo     for dependencies, we exclude Mojo annotations found\n     * @return\n     * @throws IOException\n     * @throws ExtractionException\n     */\n    protected Map<String, MojoAnnotatedClass> scanArchive( File archiveFile, Artifact artifact, boolean excludeMojo )\n        throws IOException, ExtractionException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n\n        ZipInputStream archiveStream = new ZipInputStream( new FileInputStream( archiveFile ) );\n\n        try\n        {\n            for ( ZipEntry zipEntry = archiveStream.getNextEntry(); zipEntry != null;\n                  zipEntry = archiveStream.getNextEntry() )\n            {\n                if ( !zipEntry.getName().endsWith( \".class\" ) )\n                {\n                    continue;\n                }\n\n                analyzeClassStream( mojoAnnotatedClasses, archiveStream, artifact, excludeMojo );\n            }\n        }\n        finally\n        {\n            IOUtil.close( archiveStream );\n        }\n\n        return mojoAnnotatedClasses;\n    }\n\n    /**\n     * @param classDirectory\n     * @param includePatterns\n     * @param artifact\n     * @param excludeMojo     for dependencies, we exclude Mojo annotations found\n     * @return\n     * @throws IOException\n     * @throws ExtractionException\n     */\n    protected Map<String, MojoAnnotatedClass> scanDirectory( File classDirectory, List<String> includePatterns,\n                                                             Artifact artifact, boolean excludeMojo )\n        throws IOException, ExtractionException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n\n        DirectoryScanner scanner = new DirectoryScanner();\n        scanner.setBasedir( classDirectory );\n        scanner.addDefaultExcludes();\n        if ( includePatterns != null )\n        {\n            scanner.setIncludes( includePatterns.toArray( new String[includePatterns.size()] ) );\n        }\n        scanner.scan();\n        String[] classFiles = scanner.getIncludedFiles();\n\n        for ( String classFile : classFiles )\n        {\n            if ( !classFile.endsWith( \".class\" ) )\n            {\n                continue;\n            }\n\n            InputStream is = new BufferedInputStream( new FileInputStream( new File( classDirectory, classFile ) ) );\n            try\n            {\n                analyzeClassStream( mojoAnnotatedClasses, is, artifact, excludeMojo );\n            }\n            finally\n            {\n                IOUtil.close( is );\n            }\n        }\n        return mojoAnnotatedClasses;\n    }\n\n    private void analyzeClassStream( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses, InputStream is,\n                                     Artifact artifact, boolean excludeMojo )\n        throws IOException, ExtractionException\n    {\n        MojoClassVisitor mojoClassVisitor = new MojoClassVisitor( getLogger() );\n\n        ClassReader rdr = new ClassReader( is );\n        rdr.accept( mojoClassVisitor, ClassReader.SKIP_FRAMES | ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG );\n\n        analyzeVisitors( mojoClassVisitor );\n\n        MojoAnnotatedClass mojoAnnotatedClass = mojoClassVisitor.getMojoAnnotatedClass();\n\n        if ( excludeMojo )\n        {\n            mojoAnnotatedClass.setMojo( null );\n        }\n\n        if ( mojoAnnotatedClass != null ) // see MPLUGIN-206 we can have intermediate classes without annotations\n        {\n            if ( getLogger().isDebugEnabled() && mojoAnnotatedClass.hasAnnotations() )\n            {\n                getLogger().debug( \"found MojoAnnotatedClass:\" + mojoAnnotatedClass.getClassName() + \":\"\n                                       + mojoAnnotatedClass );\n            }\n            mojoAnnotatedClass.setArtifact( artifact );\n            mojoAnnotatedClasses.put( mojoAnnotatedClass.getClassName(), mojoAnnotatedClass );\n        }\n    }\n\n    protected void populateAnnotationContent( Object content, MojoAnnotationVisitor mojoAnnotationVisitor )\n        throws ReflectorException\n    {\n        for ( Map.Entry<String, Object> entry : mojoAnnotationVisitor.getAnnotationValues().entrySet() )\n        {\n            reflector.invoke( content, entry.getKey(), new Object[] { entry.getValue() } );\n        }\n    }\n\n    protected void analyzeVisitors( MojoClassVisitor mojoClassVisitor )\n        throws ExtractionException\n    {\n        final MojoAnnotatedClass mojoAnnotatedClass = mojoClassVisitor.getMojoAnnotatedClass();\n\n        try\n        {\n            // @Mojo annotation\n            MojoAnnotationVisitor mojoAnnotationVisitor = mojoClassVisitor.getAnnotationVisitor( Mojo.class );\n            if ( mojoAnnotationVisitor != null )\n            {\n                MojoAnnotationContent mojoAnnotationContent = new MojoAnnotationContent();\n                populateAnnotationContent( mojoAnnotationContent, mojoAnnotationVisitor );\n                mojoAnnotatedClass.setMojo( mojoAnnotationContent );\n            }\n\n            // @Execute annotation\n            mojoAnnotationVisitor = mojoClassVisitor.getAnnotationVisitor( Execute.class );\n            if ( mojoAnnotationVisitor != null )\n            {\n                ExecuteAnnotationContent executeAnnotationContent = new ExecuteAnnotationContent();\n                populateAnnotationContent( executeAnnotationContent, mojoAnnotationVisitor );\n                mojoAnnotatedClass.setExecute( executeAnnotationContent );\n            }\n\n            // @Parameter annotations\n            List<MojoFieldVisitor> mojoFieldVisitors = mojoClassVisitor.findFieldWithAnnotation( Parameter.class );\n            for ( MojoFieldVisitor mojoFieldVisitor : mojoFieldVisitors )\n            {\n                ParameterAnnotationContent parameterAnnotationContent =\n                    new ParameterAnnotationContent( mojoFieldVisitor.getFieldName(), mojoFieldVisitor.getClassName() );\n                if ( mojoFieldVisitor.getMojoAnnotationVisitor() != null )\n                {\n                    populateAnnotationContent( parameterAnnotationContent,\n                                               mojoFieldVisitor.getMojoAnnotationVisitor() );\n                }\n\n                mojoAnnotatedClass.getParameters().put( parameterAnnotationContent.getFieldName(),\n                                                        parameterAnnotationContent );\n            }\n\n            // @Component annotations\n            mojoFieldVisitors = mojoClassVisitor.findFieldWithAnnotation( Component.class );\n            for ( MojoFieldVisitor mojoFieldVisitor : mojoFieldVisitors )\n            {\n                ComponentAnnotationContent componentAnnotationContent =\n                    new ComponentAnnotationContent( mojoFieldVisitor.getFieldName() );\n\n                MojoAnnotationVisitor annotationVisitor = mojoFieldVisitor.getMojoAnnotationVisitor();\n                if ( annotationVisitor != null )\n                {\n                    for ( Map.Entry<String, Object> entry : annotationVisitor.getAnnotationValues().entrySet() )\n                    {\n                        String methodName = entry.getKey();\n                        if ( StringUtils.equals( \"role\", methodName ) )\n                        {\n                            Type type = (Type) entry.getValue();\n                            componentAnnotationContent.setRoleClassName( type.getClassName() );\n                        }\n                        else\n                        {\n                            reflector.invoke( componentAnnotationContent, entry.getKey(),\n                                              new Object[]{ entry.getValue() } );\n                        }\n                    }\n\n                    if ( StringUtils.isEmpty( componentAnnotationContent.getRoleClassName() ) )\n                    {\n                        componentAnnotationContent.setRoleClassName( mojoFieldVisitor.getClassName() );\n                    }\n                }\n                mojoAnnotatedClass.getComponents().put( componentAnnotationContent.getFieldName(),\n                                                        componentAnnotationContent );\n            }\n        }\n        catch ( ReflectorException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.annotations.scanner;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ComponentAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ExecuteAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.MojoAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ParameterAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoAnnotationVisitor;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoClassVisitor;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoFieldVisitor;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.DirectoryScanner;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.reflection.Reflector;\nimport org.codehaus.plexus.util.reflection.ReflectorException;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.Type;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\n/**\n * @author Olivier Lamy\n * @since 3.0\n */\n@org.codehaus.plexus.component.annotations.Component( role = MojoAnnotationsScanner.class )\npublic class DefaultMojoAnnotationsScanner\n    extends AbstractLogEnabled\n    implements MojoAnnotationsScanner\n{\n    private Reflector reflector = new Reflector();\n\n    public Map<String, MojoAnnotatedClass> scan( MojoAnnotationsScannerRequest request )\n        throws ExtractionException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n\n        try\n        {\n            for ( Artifact dependency : request.getDependencies() )\n            {\n                scan( mojoAnnotatedClasses, dependency.getFile(), request.getIncludePatterns(), dependency, true );\n            }\n\n            for ( File classDirectory : request.getClassesDirectories() )\n            {\n                scan( mojoAnnotatedClasses, classDirectory, request.getIncludePatterns(),\n                      request.getProject().getArtifact(), false );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n\n        return mojoAnnotatedClasses;\n    }\n\n    protected void scan( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses, File source,\n                         List<String> includePatterns, Artifact artifact, boolean excludeMojo )\n        throws IOException, ExtractionException\n    {\n        if ( source == null || ! source.exists() )\n        {\n            return;\n        }\n\n        Map<String, MojoAnnotatedClass> scanResult;\n        if ( source.isDirectory() )\n        {\n            scanResult = scanDirectory( source, includePatterns, artifact, excludeMojo );\n        }\n        else\n        {\n            scanResult = scanArchive( source, artifact, excludeMojo );\n        }\n\n        mojoAnnotatedClasses.putAll( scanResult );\n    }\n\n    /**\n     * @param archiveFile\n     * @param artifact\n     * @param excludeMojo     for dependencies, we exclude Mojo annotations found\n     * @return\n     * @throws IOException\n     * @throws ExtractionException\n     */\n    protected Map<String, MojoAnnotatedClass> scanArchive( File archiveFile, Artifact artifact, boolean excludeMojo )\n        throws IOException, ExtractionException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n\n        ZipInputStream archiveStream = new ZipInputStream( new FileInputStream( archiveFile ) );\n\n        try\n        {\n            for ( ZipEntry zipEntry = archiveStream.getNextEntry(); zipEntry != null;\n                  zipEntry = archiveStream.getNextEntry() )\n            {\n                if ( !zipEntry.getName().endsWith( \".class\" ) )\n                {\n                    continue;\n                }\n\n                analyzeClassStream( mojoAnnotatedClasses, archiveStream, artifact, excludeMojo );\n            }\n        }\n        finally\n        {\n            IOUtil.close( archiveStream );\n        }\n\n        return mojoAnnotatedClasses;\n    }\n\n    /**\n     * @param classDirectory\n     * @param includePatterns\n     * @param artifact\n     * @param excludeMojo     for dependencies, we exclude Mojo annotations found\n     * @return\n     * @throws IOException\n     * @throws ExtractionException\n     */\n    protected Map<String, MojoAnnotatedClass> scanDirectory( File classDirectory, List<String> includePatterns,\n                                                             Artifact artifact, boolean excludeMojo )\n        throws IOException, ExtractionException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n\n        DirectoryScanner scanner = new DirectoryScanner();\n        scanner.setBasedir( classDirectory );\n        scanner.addDefaultExcludes();\n        if ( includePatterns != null )\n        {\n            scanner.setIncludes( includePatterns.toArray( new String[includePatterns.size()] ) );\n        }\n        scanner.scan();\n        String[] classFiles = scanner.getIncludedFiles();\n\n        for ( String classFile : classFiles )\n        {\n            if ( !classFile.endsWith( \".class\" ) )\n            {\n                continue;\n            }\n\n            InputStream is = new BufferedInputStream( new FileInputStream( new File( classDirectory, classFile ) ) );\n            try\n            {\n                analyzeClassStream( mojoAnnotatedClasses, is, artifact, excludeMojo );\n            }\n            finally\n            {\n                IOUtil.close( is );\n            }\n        }\n        return mojoAnnotatedClasses;\n    }\n\n    private void analyzeClassStream( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses, InputStream is,\n                                     Artifact artifact, boolean excludeMojo )\n        throws IOException, ExtractionException\n    {\n        MojoClassVisitor mojoClassVisitor = new MojoClassVisitor( getLogger() );\n\n        ClassReader rdr = new ClassReader( is );\n        rdr.accept( mojoClassVisitor, ClassReader.SKIP_FRAMES | ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG );\n\n        analyzeVisitors( mojoClassVisitor );\n\n        MojoAnnotatedClass mojoAnnotatedClass = mojoClassVisitor.getMojoAnnotatedClass();\n\n        if ( excludeMojo )\n        {\n            mojoAnnotatedClass.setMojo( null );\n        }\n\n        if ( mojoAnnotatedClass != null ) // see MPLUGIN-206 we can have intermediate classes without annotations\n        {\n            if ( getLogger().isDebugEnabled() && mojoAnnotatedClass.hasAnnotations() )\n            {\n                getLogger().debug( \"found MojoAnnotatedClass:\" + mojoAnnotatedClass.getClassName() + \":\"\n                                       + mojoAnnotatedClass );\n            }\n            mojoAnnotatedClass.setArtifact( artifact );\n            mojoAnnotatedClasses.put( mojoAnnotatedClass.getClassName(), mojoAnnotatedClass );\n        }\n    }\n\n    protected void populateAnnotationContent( Object content, MojoAnnotationVisitor mojoAnnotationVisitor )\n        throws ReflectorException\n    {\n        for ( Map.Entry<String, Object> entry : mojoAnnotationVisitor.getAnnotationValues().entrySet() )\n        {\n            reflector.invoke( content, entry.getKey(), new Object[] { entry.getValue() } );\n        }\n    }\n\n    protected void analyzeVisitors( MojoClassVisitor mojoClassVisitor )\n        throws ExtractionException\n    {\n        final MojoAnnotatedClass mojoAnnotatedClass = mojoClassVisitor.getMojoAnnotatedClass();\n\n        try\n        {\n            // @Mojo annotation\n            MojoAnnotationVisitor mojoAnnotationVisitor = mojoClassVisitor.getAnnotationVisitor( Mojo.class );\n            if ( mojoAnnotationVisitor != null )\n            {\n                MojoAnnotationContent mojoAnnotationContent = new MojoAnnotationContent();\n                populateAnnotationContent( mojoAnnotationContent, mojoAnnotationVisitor );\n                mojoAnnotatedClass.setMojo( mojoAnnotationContent );\n            }\n\n            // @Execute annotation\n            mojoAnnotationVisitor = mojoClassVisitor.getAnnotationVisitor( Execute.class );\n            if ( mojoAnnotationVisitor != null )\n            {\n                ExecuteAnnotationContent executeAnnotationContent = new ExecuteAnnotationContent();\n                populateAnnotationContent( executeAnnotationContent, mojoAnnotationVisitor );\n                mojoAnnotatedClass.setExecute( executeAnnotationContent );\n            }\n\n            // @Parameter annotations\n            List<MojoFieldVisitor> mojoFieldVisitors = mojoClassVisitor.findFieldWithAnnotation( Parameter.class );\n            for ( MojoFieldVisitor mojoFieldVisitor : mojoFieldVisitors )\n            {\n                ParameterAnnotationContent parameterAnnotationContent =\n                    new ParameterAnnotationContent( mojoFieldVisitor.getFieldName(), mojoFieldVisitor.getClassName() );\n                if ( mojoFieldVisitor.getMojoAnnotationVisitor() != null )\n                {\n                    populateAnnotationContent( parameterAnnotationContent, mojoFieldVisitor.getMojoAnnotationVisitor() );\n                }\n\n                mojoAnnotatedClass.getParameters().put( parameterAnnotationContent.getFieldName(),\n                                                        parameterAnnotationContent );\n            }\n\n            // @Component annotations\n            mojoFieldVisitors = mojoClassVisitor.findFieldWithAnnotation( Component.class );\n            for ( MojoFieldVisitor mojoFieldVisitor : mojoFieldVisitors )\n            {\n                ComponentAnnotationContent componentAnnotationContent =\n                    new ComponentAnnotationContent( mojoFieldVisitor.getFieldName() );\n\n                if ( mojoFieldVisitor.getMojoAnnotationVisitor() != null )\n                {\n                    for ( Map.Entry<String, Object> entry : mojoFieldVisitor.getMojoAnnotationVisitor().getAnnotationValues().entrySet() )\n                    {\n                        String methodName = entry.getKey();\n                        if ( StringUtils.equals( \"role\", methodName ) )\n                        {\n                            Type type = (Type) entry.getValue();\n                            componentAnnotationContent.setRoleClassName( type.getClassName() );\n                        }\n                        else\n                        {\n                            reflector.invoke( componentAnnotationContent, entry.getKey(),\n                                              new Object[]{ entry.getValue() } );\n                        }\n                    }\n\n                    if ( StringUtils.isEmpty( componentAnnotationContent.getRoleClassName() ) )\n                    {\n                        componentAnnotationContent.setRoleClassName( mojoFieldVisitor.getClassName() );\n                    }\n                }\n                mojoAnnotatedClass.getComponents().put( componentAnnotationContent.getFieldName(),\n                                                        componentAnnotationContent );\n            }\n        }\n        catch ( ReflectorException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n}\n","lineNo":282}
{"Refactored Sample":"package org.apache.maven.tools.plugin.annotations;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport com.thoughtworks.qdox.JavaDocBuilder;\nimport com.thoughtworks.qdox.model.DocletTag;\nimport com.thoughtworks.qdox.model.JavaClass;\nimport com.thoughtworks.qdox.model.JavaField;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.plugin.descriptor.DuplicateParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ComponentAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ExecuteAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.MojoAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ParameterAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotatedClass;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScanner;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScannerRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.archiver.UnArchiver;\nimport org.codehaus.plexus.archiver.manager.ArchiverManager;\nimport org.codehaus.plexus.archiver.manager.NoSuchArchiverException;\nimport org.codehaus.plexus.component.annotations.Component;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * JavaMojoDescriptorExtractor, a MojoDescriptor extractor to read descriptors from java classes with annotations.\n *\n * @author Olivier Lamy\n * @since 3.0\n */\n@Component( role = MojoDescriptorExtractor.class, hint = \"java-annotations\" )\npublic class JavaAnnotationsMojoDescriptorExtractor\n    extends AbstractLogEnabled\n    implements MojoDescriptorExtractor\n{\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private MojoAnnotationsScanner mojoAnnotationsScanner;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArtifactResolver artifactResolver;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArtifactFactory artifactFactory;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArchiverManager archiverManager;\n\n    public List<MojoDescriptor> execute( MavenProject project, PluginDescriptor pluginDescriptor )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        return execute( new DefaultPluginToolsRequest( project, pluginDescriptor ) );\n    }\n\n    public List<MojoDescriptor> execute( PluginToolsRequest request )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = scanAnnotations( request );\n\n        Map<String, JavaClass> javaClassesMap = scanJavadoc( request, mojoAnnotatedClasses.values() );\n\n        populateDataFromJavadoc( mojoAnnotatedClasses, javaClassesMap );\n\n        return toMojoDescriptors( mojoAnnotatedClasses, request.getPluginDescriptor() );\n    }\n\n    private Map<String, MojoAnnotatedClass> scanAnnotations( PluginToolsRequest request )\n        throws ExtractionException\n    {\n        MojoAnnotationsScannerRequest mojoAnnotationsScannerRequest = new MojoAnnotationsScannerRequest();\n\n        File output = new File( request.getProject().getBuild().getOutputDirectory() );\n        mojoAnnotationsScannerRequest.setClassesDirectories( Arrays.asList( output ) );\n\n        mojoAnnotationsScannerRequest.setDependencies( request.getDependencies() );\n\n        mojoAnnotationsScannerRequest.setProject( request.getProject() );\n\n        return mojoAnnotationsScanner.scan( mojoAnnotationsScannerRequest );\n    }\n\n    private Map<String, JavaClass> scanJavadoc( PluginToolsRequest request,\n                                                Collection<MojoAnnotatedClass> mojoAnnotatedClasses )\n        throws ExtractionException\n    {\n        // found artifact from reactors to scan sources\n        // we currently only scan sources from reactors\n        List<MavenProject> mavenProjects = new ArrayList<MavenProject>();\n\n        // if we need to scan sources from external artifacts\n        Set<Artifact> externalArtifacts = new HashSet<Artifact>();\n\n        for ( MojoAnnotatedClass mojoAnnotatedClass : mojoAnnotatedClasses )\n        {\n            if ( StringUtils.equals( mojoAnnotatedClass.getArtifact().getArtifactId(),\n                                     request.getProject().getArtifact().getArtifactId() ) )\n            {\n                continue;\n            }\n\n            if ( !isMojoAnnnotatedClassCandidate( mojoAnnotatedClass ) )\n            {\n                // we don't scan sources for classes without mojo annotations\n                continue;\n            }\n\n            MavenProject mavenProject =\n                getFromProjectReferences( mojoAnnotatedClass.getArtifact(), request.getProject() );\n\n            if ( mavenProject != null )\n            {\n                mavenProjects.add( mavenProject );\n            }\n            else\n            {\n                externalArtifacts.add( mojoAnnotatedClass.getArtifact() );\n            }\n        }\n\n        Map<String, JavaClass> javaClassesMap = new HashMap<String, JavaClass>();\n\n        // try to get artifact with sources classifier, extract somewhere then scan for @since, @deprecated\n        for ( Artifact artifact : externalArtifacts )\n        {\n            // parameter for test-sources too ?? olamy I need that for it test only\n            if ( StringUtils.equalsIgnoreCase( \"tests\", artifact.getClassifier() ) )\n            {\n                javaClassesMap.putAll( discoverClassesFromSourcesJar( artifact, request, \"test-sources\" ) );\n            }\n            else\n            {\n                javaClassesMap.putAll( discoverClassesFromSourcesJar( artifact, request, \"sources\" ) );\n            }\n\n        }\n\n        for ( MavenProject mavenProject : mavenProjects )\n        {\n            javaClassesMap.putAll( discoverClasses( request.getEncoding(), mavenProject ) );\n        }\n\n        javaClassesMap.putAll( discoverClasses( request ) );\n\n        return javaClassesMap;\n    }\n\n    private boolean isMojoAnnnotatedClassCandidate( MojoAnnotatedClass mojoAnnotatedClass )\n    {\n        if ( mojoAnnotatedClass == null )\n        {\n            return false;\n        }\n        return ( !mojoAnnotatedClass.getComponents().isEmpty() || !mojoAnnotatedClass.getParameters().isEmpty()\n            || mojoAnnotatedClass.getExecute() != null || mojoAnnotatedClass.getMojo() != null );\n\n    }\n\n    protected Map<String, JavaClass> discoverClassesFromSourcesJar( Artifact artifact, PluginToolsRequest request,\n                                                                    String classifier )\n        throws ExtractionException\n    {\n        try\n        {\n            Artifact sourcesArtifact =\n                artifactFactory.createArtifactWithClassifier( artifact.getGroupId(), artifact.getArtifactId(),\n                                                              artifact.getVersion(), artifact.getType(), classifier );\n\n            artifactResolver.resolve( sourcesArtifact, request.getRemoteRepos(), request.getLocal() );\n\n            if ( sourcesArtifact.getFile() == null || !sourcesArtifact.getFile().exists() )\n            {\n                // could not get artifact sources\n                return Collections.emptyMap();\n            }\n\n            // extract sources to target/maven-plugin-plugin-sources/${groupId}/${artifact}/sources\n            File extractDirectory = new File( request.getProject().getBuild().getDirectory(),\n                                              \"maven-plugin-plugin-sources/\" + sourcesArtifact.getGroupId() + \"/\"\n                                                  + sourcesArtifact.getArtifactId() + \"/\" + sourcesArtifact.getVersion()\n                                                  + \"/\" + sourcesArtifact.getClassifier() );\n            extractDirectory.mkdirs();\n\n            UnArchiver unArchiver = archiverManager.getUnArchiver( \"jar\" );\n            unArchiver.setSourceFile( sourcesArtifact.getFile() );\n            unArchiver.setDestDirectory( extractDirectory );\n            unArchiver.extract();\n\n            return discoverClasses( request.getEncoding(), Arrays.asList( extractDirectory ) );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            //throw new ExtractionException( e.getMessage(), e );\n            getLogger().debug( \"skip ArtifactNotFoundException:\" + e.getMessage() );\n            getLogger().warn(\n                \"Unable to get sources artifact for \" + artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\"\n                    + artifact.getVersion() + \". Some javadoc tags (@since, @deprecated and comments) won't be used\" );\n            return Collections.emptyMap();\n        }\n        catch ( NoSuchArchiverException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n\n    /**\n     * from sources scan to get @since and @deprecated and description of classes and fields.\n     *\n     * @param mojoAnnotatedClasses\n     * @param javaClassesMap\n     */\n    protected void populateDataFromJavadoc( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                            Map<String, JavaClass> javaClassesMap )\n    {\n\n        for ( Map.Entry<String, MojoAnnotatedClass> entry : mojoAnnotatedClasses.entrySet() )\n        {\n            JavaClass javaClass = javaClassesMap.get( entry.getKey() );\n            if ( javaClass == null )\n            {\n                continue;\n            }\n\n            // populate class-level content\n            MojoAnnotationContent mojoAnnotationContent = entry.getValue().getMojo();\n            if ( mojoAnnotationContent != null )\n            {\n                mojoAnnotationContent.setDescription( javaClass.getComment() );\n\n                DocletTag since = findInClassHierarchy( javaClass, \"since\" );\n                if ( since != null )\n                {\n                    mojoAnnotationContent.setSince( since.getValue() );\n                }\n\n                DocletTag deprecated = findInClassHierarchy( javaClass, \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    mojoAnnotationContent.setDeprecated( deprecated.getValue() );\n                }\n            }\n\n            Map<String, JavaField> fieldsMap = extractFieldParameterTags( javaClass, javaClassesMap );\n\n            // populate parameters\n            Map<String, ParameterAnnotationContent> parameters =\n                getParametersParentHierarchy( entry.getValue(), new HashMap<String, ParameterAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n            for ( Map.Entry<String, ParameterAnnotationContent> parameter : new TreeMap<String, ParameterAnnotationContent>(\n                parameters ).entrySet() )\n            {\n                JavaField javaField = fieldsMap.get( parameter.getKey() );\n                if ( javaField == null )\n                {\n                    continue;\n                }\n\n                ParameterAnnotationContent parameterAnnotationContent = parameter.getValue();\n                parameterAnnotationContent.setDescription( javaField.getComment() );\n\n                DocletTag deprecated = javaField.getTagByName( \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    parameterAnnotationContent.setDeprecated( deprecated.getValue() );\n                }\n\n                DocletTag since = javaField.getTagByName( \"since\" );\n                if ( since != null )\n                {\n                    parameterAnnotationContent.setSince( since.getValue() );\n                }\n            }\n\n            // populate components\n            for ( Map.Entry<String, ComponentAnnotationContent> component : entry.getValue().getComponents().entrySet() )\n            {\n                JavaField javaField = fieldsMap.get( component.getKey() );\n                if ( javaField == null )\n                {\n                    continue;\n                }\n\n                ComponentAnnotationContent componentAnnotationContent = component.getValue();\n                componentAnnotationContent.setDescription( javaField.getComment() );\n\n                DocletTag deprecated = javaField.getTagByName( \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    componentAnnotationContent.setDeprecated( deprecated.getValue() );\n                }\n\n                DocletTag since = javaField.getTagByName( \"since\" );\n                if ( since != null )\n                {\n                    componentAnnotationContent.setSince( since.getValue() );\n                }\n            }\n\n        }\n\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName   not null\n     * @return docletTag instance\n     */\n    private DocletTag findInClassHierarchy( JavaClass javaClass, String tagName )\n    {\n        DocletTag tag = javaClass.getTagByName( tagName );\n\n        if ( tag == null )\n        {\n            JavaClass superClass = javaClass.getSuperJavaClass();\n\n            if ( superClass != null )\n            {\n                tag = findInClassHierarchy( superClass, tagName );\n            }\n        }\n\n        return tag;\n    }\n\n    /**\n     * extract fields that are either parameters or components.\n     *\n     * @param javaClass not null\n     * @return map with Mojo parameters names as keys\n     */\n    private Map<String, JavaField> extractFieldParameterTags( JavaClass javaClass,\n                                                              Map<String, JavaClass> javaClassesMap )\n    {\n        Map<String, JavaField> rawParams = new TreeMap<String, com.thoughtworks.qdox.model.JavaField>();\n\n        // we have to add the parent fields first, so that they will be overwritten by the local fields if\n        // that actually happens...\n        JavaClass superClass = javaClass.getSuperJavaClass();\n\n        if ( superClass != null )\n        {\n            if ( superClass.getFields().length > 0 )\n            {\n                rawParams = extractFieldParameterTags( superClass, javaClassesMap );\n            }\n            // maybe sources comes from scan of sources artifact\n            superClass = javaClassesMap.get( superClass.getFullyQualifiedName() );\n            if ( superClass != null )\n            {\n                rawParams = extractFieldParameterTags( superClass, javaClassesMap );\n            }\n        }\n        else\n        {\n\n            rawParams = new TreeMap<String, JavaField>();\n        }\n\n        JavaField[] classFields = javaClass.getFields();\n\n        if ( classFields != null )\n        {\n            for ( JavaField field : classFields )\n            {\n                rawParams.put( field.getName(), field );\n            }\n        }\n        return rawParams;\n    }\n\n    protected Map<String, JavaClass> discoverClasses( final PluginToolsRequest request )\n    {\n        return discoverClasses( request.getEncoding(), request.getProject() );\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    protected Map<String, JavaClass> discoverClasses( final String encoding, final MavenProject project )\n    {\n        List<File> sources = new ArrayList<File>();\n\n        for ( String source : (List<String>) project.getCompileSourceRoots() )\n        {\n            sources.add( new File( source ) );\n        }\n\n        // TODO be more dynamic\n        File generatedPlugin = new File( project.getBasedir(), \"target/generated-sources/plugin\" );\n        if ( !project.getCompileSourceRoots().contains( generatedPlugin.getAbsolutePath() )\n            && generatedPlugin.exists() )\n        {\n            sources.add( generatedPlugin );\n        }\n\n        return discoverClasses( encoding, sources );\n    }\n\n    protected Map<String, JavaClass> discoverClasses( final String encoding, List<File> sourceDirectories )\n    {\n        JavaDocBuilder builder = new JavaDocBuilder();\n        builder.setEncoding( encoding );\n\n        for ( File source : sourceDirectories )\n        {\n            builder.addSourceTree( source );\n        }\n\n        JavaClass[] javaClasses = builder.getClasses();\n\n        if ( javaClasses == null || javaClasses.length < 1 )\n        {\n            return Collections.emptyMap();\n        }\n\n        Map<String, JavaClass> javaClassMap = new HashMap<String, JavaClass>( javaClasses.length );\n\n        for ( JavaClass javaClass : javaClasses )\n        {\n            javaClassMap.put( javaClass.getFullyQualifiedName(), javaClass );\n        }\n\n        return javaClassMap;\n    }\n\n    private List<MojoDescriptor> toMojoDescriptors( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                                    PluginDescriptor pluginDescriptor )\n        throws DuplicateParameterException, InvalidParameterException\n    {\n        List<MojoDescriptor> mojoDescriptors = new ArrayList<MojoDescriptor>( mojoAnnotatedClasses.size() );\n        for ( MojoAnnotatedClass mojoAnnotatedClass : mojoAnnotatedClasses.values() )\n        {\n            // no mojo so skip it\n            if ( mojoAnnotatedClass.getMojo() == null )\n            {\n                continue;\n            }\n\n            ExtendedMojoDescriptor mojoDescriptor = new ExtendedMojoDescriptor();\n\n            //mojoDescriptor.setRole( mojoAnnotatedClass.getClassName() );\n            //mojoDescriptor.setRoleHint( \"default\" );\n            mojoDescriptor.setImplementation( mojoAnnotatedClass.getClassName() );\n            mojoDescriptor.setLanguage( \"java\" );\n\n            MojoAnnotationContent mojo = mojoAnnotatedClass.getMojo();\n\n            mojoDescriptor.setDescription( mojo.getDescription() );\n            mojoDescriptor.setSince( mojo.getSince() );\n            mojo.setDeprecated( mojo.getDeprecated() );\n\n            mojoDescriptor.setProjectRequired( mojo.requiresProject() );\n\n            mojoDescriptor.setRequiresReports( mojo.requiresReports() );\n\n            mojoDescriptor.setComponentConfigurator( mojo.configurator() );\n\n            mojoDescriptor.setInheritedByDefault( mojo.inheritByDefault() );\n\n            mojoDescriptor.setInstantiationStrategy( mojo.instantiationStrategy().id() );\n\n            mojoDescriptor.setAggregator( mojo.aggregator() );\n            mojoDescriptor.setDependencyResolutionRequired( mojo.requiresDependencyResolution().id() );\n            mojoDescriptor.setDependencyCollectionRequired( mojo.requiresDependencyCollection().id() );\n\n            mojoDescriptor.setDirectInvocationOnly( mojo.requiresDirectInvocation() );\n            mojoDescriptor.setDeprecated( mojo.getDeprecated() );\n            mojoDescriptor.setThreadSafe( mojo.threadSafe() );\n\n            ExecuteAnnotationContent execute = findExecuteInParentHierarchy( mojoAnnotatedClass, mojoAnnotatedClasses );\n            if ( execute != null )\n            {\n                mojoDescriptor.setExecuteGoal( execute.goal() );\n                mojoDescriptor.setExecuteLifecycle( execute.lifecycle() );\n                if ( execute.phase() != null )\n                {\n                    mojoDescriptor.setExecutePhase( execute.phase().id() );\n                }\n            }\n\n            mojoDescriptor.setExecutionStrategy( mojo.executionStrategy() );\n            // ???\n            //mojoDescriptor.alwaysExecute(mojo.a)\n\n            mojoDescriptor.setGoal( mojo.name() );\n            mojoDescriptor.setOnlineRequired( mojo.requiresOnline() );\n\n            mojoDescriptor.setPhase( mojo.defaultPhase().id() );\n\n            // Parameter annotations\n            Map<String, ParameterAnnotationContent> parameters =\n                getParametersParentHierarchy( mojoAnnotatedClass, new HashMap<String, ParameterAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n\n            for ( ParameterAnnotationContent parameterAnnotationContent : new TreeSet<ParameterAnnotationContent>(\n                parameters.values() ) )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                String name =\n                    StringUtils.isEmpty( parameterAnnotationContent.name() ) ? parameterAnnotationContent.getFieldName()\n                                    : parameterAnnotationContent.name();\n                parameter.setName( name );\n                parameter.setAlias( parameterAnnotationContent.alias() );\n                parameter.setDefaultValue( parameterAnnotationContent.defaultValue() );\n                parameter.setDeprecated( parameterAnnotationContent.getDeprecated() );\n                parameter.setDescription( parameterAnnotationContent.getDescription() );\n                parameter.setEditable( !parameterAnnotationContent.readonly() );\n                String property = parameterAnnotationContent.property();\n                if ( StringUtils.contains( property, '$' ) || StringUtils.contains( property, '{' )\n                    || StringUtils.contains( property, '}' ) )\n                {\n                    throw new InvalidParameterException(\n                        \"Invalid property for parameter '\" + parameter.getName() + \"', \" + \"forbidden characters ${}: \"\n                            + property, null );\n                }\n                parameter.setExpression( StringUtils.isEmpty( property ) ? \"\" : \"${\" + property + \"}\" );\n                parameter.setType( parameterAnnotationContent.getClassName() );\n                parameter.setSince( parameterAnnotationContent.getSince() );\n                parameter.setRequired( parameterAnnotationContent.required() );\n\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            // Component annotations\n            Map<String, ComponentAnnotationContent> components =\n                getComponentsParentHierarchy( mojoAnnotatedClass, new HashMap<String, ComponentAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n\n            for ( ComponentAnnotationContent componentAnnotationContent : new TreeSet<ComponentAnnotationContent>(\n                components.values() ) )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                parameter.setName( componentAnnotationContent.getFieldName() );\n\n                // recognize Maven-injected objects as components annotations instead of parameters\n                String expression = PluginUtils.MAVEN_COMPONENTS.get( componentAnnotationContent.getRoleClassName() );\n                if ( expression == null )\n                {\n                    // normal component\n                    parameter.setRequirement( new Requirement( componentAnnotationContent.getRoleClassName(),\n                                                               componentAnnotationContent.hint() ) );\n                }\n                else\n                {\n                    // not a component but a Maven object to be transformed into an expression/property: deprecated\n                    getLogger().warn( \"Deprecated @component for \" + parameter.getName() + \" field in \"\n                                          + mojoAnnotatedClass.getClassName() + \".\"\n                                          + \": replace with @parameter name=\\\"\" + expression + \"\\\" @readonly\" );\n                    parameter.setDefaultValue( expression );\n                    parameter.setType( componentAnnotationContent.getRoleClassName() );\n                    parameter.setRequired( true );\n                }\n                parameter.setDeprecated( componentAnnotationContent.getDeprecated() );\n                parameter.setSince( componentAnnotationContent.getSince() );\n\n                // same behaviour as JavaMojoDescriptorExtractor\n                //parameter.setRequired( ... );\n                parameter.setEditable( false );\n\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            mojoDescriptor.setPluginDescriptor( pluginDescriptor );\n\n            mojoDescriptors.add( mojoDescriptor );\n        }\n        return mojoDescriptors;\n    }\n\n    protected ExecuteAnnotationContent findExecuteInParentHierarchy( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                     Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n\n        if ( mojoAnnotatedClass.getExecute() != null )\n        {\n            return mojoAnnotatedClass.getExecute();\n        }\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( StringUtils.isEmpty( parentClassName ) )\n        {\n            return null;\n        }\n        MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n        if ( parent == null )\n        {\n            return null;\n        }\n        return findExecuteInParentHierarchy( parent, mojoAnnotatedClasses );\n    }\n\n\n    protected Map<String, ParameterAnnotationContent> getParametersParentHierarchy(\n        MojoAnnotatedClass mojoAnnotatedClass, Map<String, ParameterAnnotationContent> parameters,\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        List<ParameterAnnotationContent> parameterAnnotationContents = new ArrayList<ParameterAnnotationContent>();\n\n        parameterAnnotationContents =\n            getParametersParent( mojoAnnotatedClass, parameterAnnotationContents, mojoAnnotatedClasses );\n\n        // move to parent first to build the Map\n        Collections.reverse( parameterAnnotationContents );\n\n        Map<String, ParameterAnnotationContent> map =\n            new HashMap<String, ParameterAnnotationContent>( parameterAnnotationContents.size() );\n\n        for ( ParameterAnnotationContent parameterAnnotationContent : parameterAnnotationContents )\n        {\n            map.put( parameterAnnotationContent.getFieldName(), parameterAnnotationContent );\n        }\n        return map;\n    }\n\n    protected List<ParameterAnnotationContent> getParametersParent( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                    List<ParameterAnnotationContent> parameterAnnotationContents,\n                                                                    Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        parameterAnnotationContents.addAll( mojoAnnotatedClass.getParameters().values() );\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( parentClassName != null )\n        {\n            MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n            if ( parent != null )\n            {\n                return getParametersParent( parent, parameterAnnotationContents, mojoAnnotatedClasses );\n            }\n        }\n        return parameterAnnotationContents;\n    }\n\n    protected Map<String, ComponentAnnotationContent> getComponentsParentHierarchy(\n        MojoAnnotatedClass mojoAnnotatedClass, Map<String, ComponentAnnotationContent> components,\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        List<ComponentAnnotationContent> componentAnnotationContents = new ArrayList<ComponentAnnotationContent>();\n\n        componentAnnotationContents =\n            getComponentParent( mojoAnnotatedClass, componentAnnotationContents, mojoAnnotatedClasses );\n\n        // move to parent first to build the Map\n        Collections.reverse( componentAnnotationContents );\n\n        Map<String, ComponentAnnotationContent> map =\n            new HashMap<String, ComponentAnnotationContent>( componentAnnotationContents.size() );\n\n        for ( ComponentAnnotationContent componentAnnotationContent : componentAnnotationContents )\n        {\n            map.put( componentAnnotationContent.getFieldName(), componentAnnotationContent );\n        }\n        return map;\n    }\n\n    protected List<ComponentAnnotationContent> getComponentParent( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                   List<ComponentAnnotationContent> componentAnnotationContents,\n                                                                   Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        componentAnnotationContents.addAll( mojoAnnotatedClass.getComponents().values() );\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( parentClassName != null )\n        {\n            MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n            if ( parent != null )\n            {\n                return getComponentParent( parent, componentAnnotationContents, mojoAnnotatedClasses );\n            }\n        }\n        return componentAnnotationContents;\n    }\n\n    protected MavenProject getFromProjectReferences( Artifact artifact, MavenProject project )\n    {\n        if ( project.getProjectReferences() == null || project.getProjectReferences().isEmpty() )\n        {\n            return null;\n        }\n        @SuppressWarnings( \"unchecked\" ) Collection<MavenProject> mavenProjects =\n            project.getProjectReferences().values();\n        for ( MavenProject mavenProject : mavenProjects )\n        {\n            if ( StringUtils.equals( mavenProject.getId(), artifact.getId() ) )\n            {\n                return mavenProject;\n            }\n        }\n        return null;\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.annotations;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport com.thoughtworks.qdox.JavaDocBuilder;\nimport com.thoughtworks.qdox.model.DocletTag;\nimport com.thoughtworks.qdox.model.JavaClass;\nimport com.thoughtworks.qdox.model.JavaField;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.plugin.descriptor.DuplicateParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ComponentAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ExecuteAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.MojoAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ParameterAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotatedClass;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScanner;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScannerRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.archiver.UnArchiver;\nimport org.codehaus.plexus.archiver.manager.ArchiverManager;\nimport org.codehaus.plexus.archiver.manager.NoSuchArchiverException;\nimport org.codehaus.plexus.component.annotations.Component;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * JavaMojoDescriptorExtractor, a MojoDescriptor extractor to read descriptors from java classes with annotations.\n *\n * @author Olivier Lamy\n * @since 3.0\n */\n@Component( role = MojoDescriptorExtractor.class, hint = \"java-annotations\" )\npublic class JavaAnnotationsMojoDescriptorExtractor\n    extends AbstractLogEnabled\n    implements MojoDescriptorExtractor\n{\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private MojoAnnotationsScanner mojoAnnotationsScanner;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArtifactResolver artifactResolver;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArtifactFactory artifactFactory;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArchiverManager archiverManager;\n\n    public List<MojoDescriptor> execute( MavenProject project, PluginDescriptor pluginDescriptor )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        return execute( new DefaultPluginToolsRequest( project, pluginDescriptor ) );\n    }\n\n    public List<MojoDescriptor> execute( PluginToolsRequest request )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = scanAnnotations( request );\n\n        Map<String, JavaClass> javaClassesMap = scanJavadoc( request, mojoAnnotatedClasses.values() );\n\n        populateDataFromJavadoc( mojoAnnotatedClasses, javaClassesMap );\n\n        return toMojoDescriptors( mojoAnnotatedClasses, request.getPluginDescriptor() );\n    }\n\n    private Map<String, MojoAnnotatedClass> scanAnnotations( PluginToolsRequest request )\n        throws ExtractionException\n    {\n        MojoAnnotationsScannerRequest mojoAnnotationsScannerRequest = new MojoAnnotationsScannerRequest();\n\n        File output = new File( request.getProject().getBuild().getOutputDirectory() );\n        mojoAnnotationsScannerRequest.setClassesDirectories( Arrays.asList( output ) );\n\n        mojoAnnotationsScannerRequest.setDependencies( request.getDependencies() );\n\n        mojoAnnotationsScannerRequest.setProject( request.getProject() );\n\n        return mojoAnnotationsScanner.scan( mojoAnnotationsScannerRequest );\n    }\n\n    private Map<String, JavaClass> scanJavadoc( PluginToolsRequest request,\n                                                Collection<MojoAnnotatedClass> mojoAnnotatedClasses )\n        throws ExtractionException\n    {\n        // found artifact from reactors to scan sources\n        // we currently only scan sources from reactors\n        List<MavenProject> mavenProjects = new ArrayList<MavenProject>();\n\n        // if we need to scan sources from external artifacts\n        Set<Artifact> externalArtifacts = new HashSet<Artifact>();\n\n        for ( MojoAnnotatedClass mojoAnnotatedClass : mojoAnnotatedClasses )\n        {\n            if ( StringUtils.equals( mojoAnnotatedClass.getArtifact().getArtifactId(),\n                                     request.getProject().getArtifact().getArtifactId() ) )\n            {\n                continue;\n            }\n\n            if ( !isMojoAnnnotatedClassCandidate( mojoAnnotatedClass ) )\n            {\n                // we don't scan sources for classes without mojo annotations\n                continue;\n            }\n\n            MavenProject mavenProject =\n                getFromProjectReferences( mojoAnnotatedClass.getArtifact(), request.getProject() );\n\n            if ( mavenProject != null )\n            {\n                mavenProjects.add( mavenProject );\n            }\n            else\n            {\n                externalArtifacts.add( mojoAnnotatedClass.getArtifact() );\n            }\n        }\n\n        Map<String, JavaClass> javaClassesMap = new HashMap<String, JavaClass>();\n\n        // try to get artifact with sources classifier, extract somewhere then scan for @since, @deprecated\n        for ( Artifact artifact : externalArtifacts )\n        {\n            // parameter for test-sources too ?? olamy I need that for it test only\n            if ( StringUtils.equalsIgnoreCase( \"tests\", artifact.getClassifier() ) )\n            {\n                javaClassesMap.putAll( discoverClassesFromSourcesJar( artifact, request, \"test-sources\" ) );\n            }\n            else\n            {\n                javaClassesMap.putAll( discoverClassesFromSourcesJar( artifact, request, \"sources\" ) );\n            }\n\n        }\n\n        for ( MavenProject mavenProject : mavenProjects )\n        {\n            javaClassesMap.putAll( discoverClasses( request.getEncoding(), mavenProject ) );\n        }\n\n        javaClassesMap.putAll( discoverClasses( request ) );\n\n        return javaClassesMap;\n    }\n\n    private boolean isMojoAnnnotatedClassCandidate( MojoAnnotatedClass mojoAnnotatedClass )\n    {\n        if ( mojoAnnotatedClass == null )\n        {\n            return false;\n        }\n        return ( !mojoAnnotatedClass.getComponents().isEmpty() || !mojoAnnotatedClass.getParameters().isEmpty()\n            || mojoAnnotatedClass.getExecute() != null || mojoAnnotatedClass.getMojo() != null );\n\n    }\n\n    protected Map<String, JavaClass> discoverClassesFromSourcesJar( Artifact artifact, PluginToolsRequest request,\n                                                                    String classifier )\n        throws ExtractionException\n    {\n        try\n        {\n            Artifact sourcesArtifact =\n                artifactFactory.createArtifactWithClassifier( artifact.getGroupId(), artifact.getArtifactId(),\n                                                              artifact.getVersion(), artifact.getType(), classifier );\n\n            artifactResolver.resolve( sourcesArtifact, request.getRemoteRepos(), request.getLocal() );\n\n            if ( sourcesArtifact.getFile() == null || !sourcesArtifact.getFile().exists() )\n            {\n                // could not get artifact sources\n                return Collections.emptyMap();\n            }\n\n            // extract sources to target/maven-plugin-plugin-sources/${groupId}/${artifact}/sources\n            File extractDirectory = new File( request.getProject().getBuild().getDirectory(),\n                                              \"maven-plugin-plugin-sources/\" + sourcesArtifact.getGroupId() + \"/\"\n                                                  + sourcesArtifact.getArtifactId() + \"/\" + sourcesArtifact.getVersion()\n                                                  + \"/\" + sourcesArtifact.getClassifier() );\n            extractDirectory.mkdirs();\n\n            UnArchiver unArchiver = archiverManager.getUnArchiver( \"jar\" );\n            unArchiver.setSourceFile( sourcesArtifact.getFile() );\n            unArchiver.setDestDirectory( extractDirectory );\n            unArchiver.extract();\n\n            return discoverClasses( request.getEncoding(), Arrays.asList( extractDirectory ) );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            //throw new ExtractionException( e.getMessage(), e );\n            getLogger().debug( \"skip ArtifactNotFoundException:\" + e.getMessage() );\n            getLogger().warn(\n                \"Unable to get sources artifact for \" + artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\"\n                    + artifact.getVersion() + \". Some javadoc tags (@since, @deprecated and comments) won't be used\" );\n            return Collections.emptyMap();\n        }\n        catch ( NoSuchArchiverException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n\n    /**\n     * from sources scan to get @since and @deprecated and description of classes and fields.\n     *\n     * @param mojoAnnotatedClasses\n     * @param javaClassesMap\n     */\n    protected void populateDataFromJavadoc( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                            Map<String, JavaClass> javaClassesMap )\n    {\n\n        for ( Map.Entry<String, MojoAnnotatedClass> entry : mojoAnnotatedClasses.entrySet() )\n        {\n            JavaClass javaClass = javaClassesMap.get( entry.getKey() );\n            if ( javaClass == null )\n            {\n                continue;\n            }\n\n            // populate class-level content\n            MojoAnnotationContent mojoAnnotationContent = entry.getValue().getMojo();\n            if ( mojoAnnotationContent != null )\n            {\n                mojoAnnotationContent.setDescription( javaClass.getComment() );\n\n                DocletTag since = findInClassHierarchy( javaClass, \"since\" );\n                if ( since != null )\n                {\n                    mojoAnnotationContent.setSince( since.getValue() );\n                }\n\n                DocletTag deprecated = findInClassHierarchy( javaClass, \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    mojoAnnotationContent.setDeprecated( deprecated.getValue() );\n                }\n            }\n\n            Map<String, JavaField> fieldsMap = extractFieldParameterTags( javaClass, javaClassesMap );\n\n            // populate parameters\n            Map<String, ParameterAnnotationContent> parameters =\n                getParametersParentHierarchy( entry.getValue(), new HashMap<String, ParameterAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n            for ( Map.Entry<String, ParameterAnnotationContent> parameter : new TreeMap<String, ParameterAnnotationContent>(\n                parameters ).entrySet() )\n            {\n                JavaField javaField = fieldsMap.get( parameter.getKey() );\n                if ( javaField == null )\n                {\n                    continue;\n                }\n\n                ParameterAnnotationContent parameterAnnotationContent = parameter.getValue();\n                parameterAnnotationContent.setDescription( javaField.getComment() );\n\n                DocletTag deprecated = javaField.getTagByName( \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    parameterAnnotationContent.setDeprecated( deprecated.getValue() );\n                }\n\n                DocletTag since = javaField.getTagByName( \"since\" );\n                if ( since != null )\n                {\n                    parameterAnnotationContent.setSince( since.getValue() );\n                }\n            }\n\n            // populate components\n            for ( Map.Entry<String, ComponentAnnotationContent> component : entry.getValue().getComponents().entrySet() )\n            {\n                JavaField javaField = fieldsMap.get( component.getKey() );\n                if ( javaField == null )\n                {\n                    continue;\n                }\n\n                ComponentAnnotationContent componentAnnotationContent = component.getValue();\n                componentAnnotationContent.setDescription( javaField.getComment() );\n\n                DocletTag deprecated = javaField.getTagByName( \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    componentAnnotationContent.setDeprecated( deprecated.getValue() );\n                }\n\n                DocletTag since = javaField.getTagByName( \"since\" );\n                if ( since != null )\n                {\n                    componentAnnotationContent.setSince( since.getValue() );\n                }\n            }\n\n        }\n\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName   not null\n     * @return docletTag instance\n     */\n    private DocletTag findInClassHierarchy( JavaClass javaClass, String tagName )\n    {\n        DocletTag tag = javaClass.getTagByName( tagName );\n\n        if ( tag == null )\n        {\n            JavaClass superClass = javaClass.getSuperJavaClass();\n\n            if ( superClass != null )\n            {\n                tag = findInClassHierarchy( superClass, tagName );\n            }\n        }\n\n        return tag;\n    }\n\n    /**\n     * extract fields that are either parameters or components.\n     *\n     * @param javaClass not null\n     * @return map with Mojo parameters names as keys\n     */\n    private Map<String, JavaField> extractFieldParameterTags( JavaClass javaClass,\n                                                              Map<String, JavaClass> javaClassesMap )\n    {\n        Map<String, JavaField> rawParams = new TreeMap<String, com.thoughtworks.qdox.model.JavaField>();\n\n        // we have to add the parent fields first, so that they will be overwritten by the local fields if\n        // that actually happens...\n        JavaClass superClass = javaClass.getSuperJavaClass();\n\n        if ( superClass != null )\n        {\n            if ( superClass.getFields().length > 0 )\n            {\n                rawParams = extractFieldParameterTags( superClass, javaClassesMap );\n            }\n            // maybe sources comes from scan of sources artifact\n            superClass = javaClassesMap.get( superClass.getFullyQualifiedName() );\n            if ( superClass != null )\n            {\n                rawParams = extractFieldParameterTags( superClass, javaClassesMap );\n            }\n        }\n        else\n        {\n\n            rawParams = new TreeMap<String, JavaField>();\n        }\n\n        JavaField[] classFields = javaClass.getFields();\n\n        if ( classFields != null )\n        {\n            for ( JavaField field : classFields )\n            {\n                rawParams.put( field.getName(), field );\n            }\n        }\n        return rawParams;\n    }\n\n    protected Map<String, JavaClass> discoverClasses( final PluginToolsRequest request )\n    {\n        return discoverClasses( request.getEncoding(), request.getProject() );\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    protected Map<String, JavaClass> discoverClasses( final String encoding, final MavenProject project )\n    {\n        List<File> sources = new ArrayList<File>();\n\n        for ( String source : (List<String>) project.getCompileSourceRoots() )\n        {\n            sources.add( new File( source ) );\n        }\n\n        // TODO be more dynamic\n        File generatedPlugin = new File( project.getBasedir(), \"target/generated-sources/plugin\" );\n        if ( !project.getCompileSourceRoots().contains( generatedPlugin.getAbsolutePath() )\n            && generatedPlugin.exists() )\n        {\n            sources.add( generatedPlugin );\n        }\n\n        return discoverClasses( encoding, sources );\n    }\n\n    protected Map<String, JavaClass> discoverClasses( final String encoding, List<File> sourceDirectories )\n    {\n        JavaDocBuilder builder = new JavaDocBuilder();\n        builder.setEncoding( encoding );\n\n        for ( File source : sourceDirectories )\n        {\n            builder.addSourceTree( source );\n        }\n\n        JavaClass[] javaClasses = builder.getClasses();\n\n        if ( javaClasses == null || javaClasses.length < 1 )\n        {\n            return Collections.emptyMap();\n        }\n\n        Map<String, JavaClass> javaClassMap = new HashMap<String, JavaClass>( javaClasses.length );\n\n        for ( JavaClass javaClass : javaClasses )\n        {\n            javaClassMap.put( javaClass.getFullyQualifiedName(), javaClass );\n        }\n\n        return javaClassMap;\n    }\n\n    private List<MojoDescriptor> toMojoDescriptors( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                                    PluginDescriptor pluginDescriptor )\n        throws DuplicateParameterException, InvalidParameterException\n    {\n        List<MojoDescriptor> mojoDescriptors = new ArrayList<MojoDescriptor>( mojoAnnotatedClasses.size() );\n        for ( MojoAnnotatedClass mojoAnnotatedClass : mojoAnnotatedClasses.values() )\n        {\n            // no mojo so skip it\n            if ( mojoAnnotatedClass.getMojo() == null )\n            {\n                continue;\n            }\n\n            ExtendedMojoDescriptor mojoDescriptor = new ExtendedMojoDescriptor();\n\n            //mojoDescriptor.setRole( mojoAnnotatedClass.getClassName() );\n            //mojoDescriptor.setRoleHint( \"default\" );\n            mojoDescriptor.setImplementation( mojoAnnotatedClass.getClassName() );\n            mojoDescriptor.setLanguage( \"java\" );\n\n            MojoAnnotationContent mojo = mojoAnnotatedClass.getMojo();\n\n            mojoDescriptor.setDescription( mojo.getDescription() );\n            mojoDescriptor.setSince( mojo.getSince() );\n            mojo.setDeprecated( mojo.getDeprecated() );\n\n            mojoDescriptor.setProjectRequired( mojo.requiresProject() );\n\n            mojoDescriptor.setRequiresReports( mojo.requiresReports() );\n\n            mojoDescriptor.setComponentConfigurator( mojo.configurator() );\n\n            mojoDescriptor.setInheritedByDefault( mojo.inheritByDefault() );\n\n            mojoDescriptor.setInstantiationStrategy( mojo.instantiationStrategy().id() );\n\n            mojoDescriptor.setAggregator( mojo.aggregator() );\n            mojoDescriptor.setDependencyResolutionRequired( mojo.requiresDependencyResolution().id() );\n            mojoDescriptor.setDependencyCollectionRequired( mojo.requiresDependencyCollection().id() );\n\n            mojoDescriptor.setDirectInvocationOnly( mojo.requiresDirectInvocation() );\n            mojoDescriptor.setDeprecated( mojo.getDeprecated() );\n            mojoDescriptor.setThreadSafe( mojo.threadSafe() );\n\n            ExecuteAnnotationContent execute = findExecuteInParentHierarchy( mojoAnnotatedClass, mojoAnnotatedClasses );\n            if ( execute != null )\n            {\n                mojoDescriptor.setExecuteGoal( execute.goal() );\n                mojoDescriptor.setExecuteLifecycle( execute.lifecycle() );\n                if ( execute.phase() != null )\n                {\n                    mojoDescriptor.setExecutePhase( execute.phase().id() );\n                }\n            }\n\n            mojoDescriptor.setExecutionStrategy( mojo.executionStrategy() );\n            // ???\n            //mojoDescriptor.alwaysExecute(mojo.a)\n\n            mojoDescriptor.setGoal( mojo.name() );\n            mojoDescriptor.setOnlineRequired( mojo.requiresOnline() );\n\n            mojoDescriptor.setPhase( mojo.defaultPhase().id() );\n\n            // Parameter annotations\n            Map<String, ParameterAnnotationContent> parameters =\n                getParametersParentHierarchy( mojoAnnotatedClass, new HashMap<String, ParameterAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n\n            for ( ParameterAnnotationContent parameterAnnotationContent : new TreeSet<ParameterAnnotationContent>(\n                parameters.values() ) )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                parameter.setName( parameterAnnotationContent.getFieldName() );\n                parameter.setAlias( parameterAnnotationContent.alias() );\n                parameter.setDefaultValue( parameterAnnotationContent.defaultValue() );\n                parameter.setDeprecated( parameterAnnotationContent.getDeprecated() );\n                parameter.setDescription( parameterAnnotationContent.getDescription() );\n                parameter.setEditable( !parameterAnnotationContent.readonly() );\n                String property = parameterAnnotationContent.property();\n                if ( StringUtils.contains( property, '$' ) || StringUtils.contains( property, '{' )\n                    || StringUtils.contains( property, '}' ) )\n                {\n                    throw new InvalidParameterException(\n                        \"Invalid property for parameter '\" + parameter.getName() + \"', \" + \"forbidden characters ${}: \"\n                            + property, null );\n                }\n                parameter.setExpression( StringUtils.isEmpty( property ) ? \"\" : \"${\" + property + \"}\" );\n                parameter.setType( parameterAnnotationContent.getClassName() );\n                parameter.setSince( parameterAnnotationContent.getSince() );\n                parameter.setRequired( parameterAnnotationContent.required() );\n\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            // Component annotations\n            Map<String, ComponentAnnotationContent> components =\n                getComponentsParentHierarchy( mojoAnnotatedClass, new HashMap<String, ComponentAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n\n            for ( ComponentAnnotationContent componentAnnotationContent : new TreeSet<ComponentAnnotationContent>(\n                components.values() ) )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                parameter.setName( componentAnnotationContent.getFieldName() );\n\n                // recognize Maven-injected objects as components annotations instead of parameters\n                String expression = PluginUtils.MAVEN_COMPONENTS.get( componentAnnotationContent.getRoleClassName() );\n                if ( expression == null )\n                {\n                    // normal component\n                    parameter.setRequirement( new Requirement( componentAnnotationContent.getRoleClassName(),\n                                                               componentAnnotationContent.hint() ) );\n                }\n                else\n                {\n                    // not a component but a Maven object to be transformed into an expression/property: deprecated\n                    getLogger().warn( \"Deprecated @component for \" + parameter.getName() + \" field in \"\n                                          + mojoAnnotatedClass.getClassName() + \".\"\n                                          + \": replace with @parameter name=\\\"\" + expression + \"\\\" @readonly\" );\n                    parameter.setDefaultValue( expression );\n                    parameter.setType( componentAnnotationContent.getRoleClassName() );\n                    parameter.setRequired( true );\n                }\n                parameter.setDeprecated( componentAnnotationContent.getDeprecated() );\n                parameter.setSince( componentAnnotationContent.getSince() );\n\n                // same behaviour as JavaMojoDescriptorExtractor\n                //parameter.setRequired( ... );\n                parameter.setEditable( false );\n\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            mojoDescriptor.setPluginDescriptor( pluginDescriptor );\n\n            mojoDescriptors.add( mojoDescriptor );\n        }\n        return mojoDescriptors;\n    }\n\n    protected ExecuteAnnotationContent findExecuteInParentHierarchy( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                     Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n\n        if ( mojoAnnotatedClass.getExecute() != null )\n        {\n            return mojoAnnotatedClass.getExecute();\n        }\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( StringUtils.isEmpty( parentClassName ) )\n        {\n            return null;\n        }\n        MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n        if ( parent == null )\n        {\n            return null;\n        }\n        return findExecuteInParentHierarchy( parent, mojoAnnotatedClasses );\n    }\n\n\n    protected Map<String, ParameterAnnotationContent> getParametersParentHierarchy(\n        MojoAnnotatedClass mojoAnnotatedClass, Map<String, ParameterAnnotationContent> parameters,\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        List<ParameterAnnotationContent> parameterAnnotationContents = new ArrayList<ParameterAnnotationContent>();\n\n        parameterAnnotationContents =\n            getParametersParent( mojoAnnotatedClass, parameterAnnotationContents, mojoAnnotatedClasses );\n\n        // move to parent first to build the Map\n        Collections.reverse( parameterAnnotationContents );\n\n        Map<String, ParameterAnnotationContent> map =\n            new HashMap<String, ParameterAnnotationContent>( parameterAnnotationContents.size() );\n\n        for ( ParameterAnnotationContent parameterAnnotationContent : parameterAnnotationContents )\n        {\n            map.put( parameterAnnotationContent.getFieldName(), parameterAnnotationContent );\n        }\n        return map;\n    }\n\n    protected List<ParameterAnnotationContent> getParametersParent( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                    List<ParameterAnnotationContent> parameterAnnotationContents,\n                                                                    Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        parameterAnnotationContents.addAll( mojoAnnotatedClass.getParameters().values() );\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( parentClassName != null )\n        {\n            MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n            if ( parent != null )\n            {\n                return getParametersParent( parent, parameterAnnotationContents, mojoAnnotatedClasses );\n            }\n        }\n        return parameterAnnotationContents;\n    }\n\n    protected Map<String, ComponentAnnotationContent> getComponentsParentHierarchy(\n        MojoAnnotatedClass mojoAnnotatedClass, Map<String, ComponentAnnotationContent> components,\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        List<ComponentAnnotationContent> componentAnnotationContents = new ArrayList<ComponentAnnotationContent>();\n\n        componentAnnotationContents =\n            getComponentParent( mojoAnnotatedClass, componentAnnotationContents, mojoAnnotatedClasses );\n\n        // move to parent first to build the Map\n        Collections.reverse( componentAnnotationContents );\n\n        Map<String, ComponentAnnotationContent> map =\n            new HashMap<String, ComponentAnnotationContent>( componentAnnotationContents.size() );\n\n        for ( ComponentAnnotationContent componentAnnotationContent : componentAnnotationContents )\n        {\n            map.put( componentAnnotationContent.getFieldName(), componentAnnotationContent );\n        }\n        return map;\n    }\n\n    protected List<ComponentAnnotationContent> getComponentParent( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                   List<ComponentAnnotationContent> componentAnnotationContents,\n                                                                   Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        componentAnnotationContents.addAll( mojoAnnotatedClass.getComponents().values() );\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( parentClassName != null )\n        {\n            MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n            if ( parent != null )\n            {\n                return getComponentParent( parent, componentAnnotationContents, mojoAnnotatedClasses );\n            }\n        }\n        return componentAnnotationContents;\n    }\n\n    protected MavenProject getFromProjectReferences( Artifact artifact, MavenProject project )\n    {\n        if ( project.getProjectReferences() == null || project.getProjectReferences().isEmpty() )\n        {\n            return null;\n        }\n        @SuppressWarnings( \"unchecked\" ) Collection<MavenProject> mavenProjects =\n            project.getProjectReferences().values();\n        for ( MavenProject mavenProject : mavenProjects )\n        {\n            if ( StringUtils.equals( mavenProject.getId(), artifact.getId() ) )\n            {\n                return mavenProject;\n            }\n        }\n        return null;\n    }\n\n}\n","lineNo":547}
{"Refactored Sample":"package org.apache.maven.tools.plugin.annotations.scanner;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ComponentAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ExecuteAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.MojoAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ParameterAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoAnnotationVisitor;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoClassVisitor;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoFieldVisitor;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.DirectoryScanner;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.reflection.Reflector;\nimport org.codehaus.plexus.util.reflection.ReflectorException;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.Type;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\n/**\n * @author Olivier Lamy\n * @since 3.0\n */\n@org.codehaus.plexus.component.annotations.Component( role = MojoAnnotationsScanner.class )\npublic class DefaultMojoAnnotationsScanner\n    extends AbstractLogEnabled\n    implements MojoAnnotationsScanner\n{\n    private Reflector reflector = new Reflector();\n\n    public Map<String, MojoAnnotatedClass> scan( MojoAnnotationsScannerRequest request )\n        throws ExtractionException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n\n        try\n        {\n            for ( Artifact dependency : request.getDependencies() )\n            {\n                scan( mojoAnnotatedClasses, dependency.getFile(), request.getIncludePatterns(), dependency, true );\n            }\n\n            for ( File classDirectory : request.getClassesDirectories() )\n            {\n                scan( mojoAnnotatedClasses, classDirectory, request.getIncludePatterns(),\n                      request.getProject().getArtifact(), false );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n\n        return mojoAnnotatedClasses;\n    }\n\n    protected void scan( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses, File source,\n                         List<String> includePatterns, Artifact artifact, boolean excludeMojo )\n        throws IOException, ExtractionException\n    {\n        if ( source == null || ! source.exists() )\n        {\n            return;\n        }\n\n        Map<String, MojoAnnotatedClass> scanResult;\n        if ( source.isDirectory() )\n        {\n            scanResult = scanDirectory( source, includePatterns, artifact, excludeMojo );\n        }\n        else\n        {\n            scanResult = scanArchive( source, artifact, excludeMojo );\n        }\n\n        mojoAnnotatedClasses.putAll( scanResult );\n    }\n\n    /**\n     * @param archiveFile\n     * @param artifact\n     * @param excludeMojo     for dependencies, we exclude Mojo annotations found\n     * @return\n     * @throws IOException\n     * @throws ExtractionException\n     */\n    protected Map<String, MojoAnnotatedClass> scanArchive( File archiveFile, Artifact artifact, boolean excludeMojo )\n        throws IOException, ExtractionException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n\n        ZipInputStream archiveStream = new ZipInputStream( new FileInputStream( archiveFile ) );\n\n        try\n        {\n            for ( ZipEntry zipEntry = archiveStream.getNextEntry(); zipEntry != null;\n                  zipEntry = archiveStream.getNextEntry() )\n            {\n                if ( !zipEntry.getName().endsWith( \".class\" ) )\n                {\n                    continue;\n                }\n\n                analyzeClassStream( mojoAnnotatedClasses, archiveStream, artifact, excludeMojo );\n            }\n        }\n        finally\n        {\n            IOUtil.close( archiveStream );\n        }\n        return mojoAnnotatedClasses;\n    }\n\n    /**\n     * @param classDirectory\n     * @param includePatterns\n     * @param artifact\n     * @param excludeMojo     for dependencies, we exclude Mojo annotations found\n     * @return\n     * @throws IOException\n     * @throws ExtractionException\n     */\n    protected Map<String, MojoAnnotatedClass> scanDirectory( File classDirectory, List<String> includePatterns,\n                                                             Artifact artifact, boolean excludeMojo )\n        throws IOException, ExtractionException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n\n        DirectoryScanner scanner = new DirectoryScanner();\n        scanner.setBasedir( classDirectory );\n        scanner.addDefaultExcludes();\n        if ( includePatterns != null )\n        {\n            scanner.setIncludes( includePatterns.toArray( new String[includePatterns.size()] ) );\n        }\n        scanner.scan();\n        String[] classFiles = scanner.getIncludedFiles();\n\n        for ( String classFile : classFiles )\n        {\n            if ( !classFile.endsWith( \".class\" ) )\n            {\n                continue;\n            }\n\n            InputStream is = new BufferedInputStream( new FileInputStream( new File( classDirectory, classFile ) ) );\n            try\n            {\n                analyzeClassStream( mojoAnnotatedClasses, is, artifact, excludeMojo );\n            }\n            finally\n            {\n                IOUtil.close( is );\n            }\n        }\n        return mojoAnnotatedClasses;\n    }\n\n    private void analyzeClassStream( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses, InputStream is,\n                                     Artifact artifact, boolean excludeMojo )\n        throws IOException, ExtractionException\n    {\n        MojoClassVisitor mojoClassVisitor = new MojoClassVisitor( getLogger() );\n\n        ClassReader rdr = new ClassReader( is );\n        rdr.accept( mojoClassVisitor, ClassReader.SKIP_FRAMES | ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG );\n\n        analyzeVisitors( mojoClassVisitor );\n\n        MojoAnnotatedClass mojoAnnotatedClass = mojoClassVisitor.getMojoAnnotatedClass();\n\n        if ( excludeMojo )\n        {\n            mojoAnnotatedClass.setMojo( null );\n        }\n\n        if ( isStoreClass( mojoAnnotatedClass ) != null )\n        {\n            if ( getLogger().isDebugEnabled() )\n            {\n                getLogger().debug( \"found MojoAnnotatedClass:\" + mojoAnnotatedClass.getClassName() + \":\"\n                                       + mojoAnnotatedClass );\n            }\n            mojoAnnotatedClass.setArtifact( artifact );\n            mojoAnnotatedClasses.put( mojoAnnotatedClass.getClassName(), mojoAnnotatedClass );\n        }\n    }\n\n    private MojoAnnotatedClass isStoreClass( MojoAnnotatedClass mojoAnnotatedClass )\n    {\n        // see MPLUGIN-206 we can have intermediate classes without annotations\n        if ( mojoAnnotatedClass == null )\n        {\n            return null;\n        }\n        return mojoAnnotatedClass;\n        /**\n         if ( !mojoAnnotatedClass.getComponents().isEmpty() || !mojoAnnotatedClass.getParameters().isEmpty()\n         || mojoAnnotatedClass.getExecute() != null || mojoAnnotatedClass.getMojo() != null )\n         {\n         return mojoAnnotatedClass;\n         }\n         return null;\n         **/\n    }\n\n    protected void populateAnnotationContent( Object content, MojoAnnotationVisitor mojoAnnotationVisitor )\n        throws ReflectorException\n    {\n        for ( Map.Entry<String, Object> entry : mojoAnnotationVisitor.getAnnotationValues().entrySet() )\n        {\n            reflector.invoke( content, entry.getKey(), new Object[] { entry.getValue() } );\n        }\n    }\n\n    protected void analyzeVisitors( MojoClassVisitor mojoClassVisitor )\n        throws ExtractionException\n    {\n        final MojoAnnotatedClass mojoAnnotatedClass = mojoClassVisitor.getMojoAnnotatedClass();\n\n        try\n        {\n            // @Mojo annotations\n            MojoAnnotationVisitor mojoAnnotationVisitor =\n                mojoClassVisitor.getAnnotationVisitorMap().get( Mojo.class.getName() );\n            if ( mojoAnnotationVisitor != null )\n            {\n                MojoAnnotationContent mojoAnnotationContent = new MojoAnnotationContent();\n                populateAnnotationContent( mojoAnnotationContent, mojoAnnotationVisitor );\n                mojoAnnotatedClass.setMojo( mojoAnnotationContent );\n            }\n\n            // @Execute annotations\n            mojoAnnotationVisitor = mojoClassVisitor.getAnnotationVisitorMap().get( Execute.class.getName() );\n            if ( mojoAnnotationVisitor != null )\n            {\n                ExecuteAnnotationContent executeAnnotationContent = new ExecuteAnnotationContent();\n                populateAnnotationContent( executeAnnotationContent, mojoAnnotationVisitor );\n                mojoAnnotatedClass.setExecute( executeAnnotationContent );\n            }\n\n            // @Parameter annotations\n            List<MojoFieldVisitor> mojoFieldVisitors =\n                mojoClassVisitor.findFieldWithAnnotationClass( Parameter.class.getName() );\n            for ( MojoFieldVisitor mojoFieldVisitor : mojoFieldVisitors )\n            {\n                ParameterAnnotationContent parameterAnnotationContent =\n                    new ParameterAnnotationContent( mojoFieldVisitor.getFieldName(), mojoFieldVisitor.getClassName() );\n                if ( mojoFieldVisitor.getMojoAnnotationVisitor() != null )\n                {\n                    populateAnnotationContent( parameterAnnotationContent, mojoFieldVisitor.getMojoAnnotationVisitor() );\n                }\n                mojoAnnotatedClass.getParameters().put( parameterAnnotationContent.getFieldName(),\n                                                        parameterAnnotationContent );\n            }\n\n            // @Component annotations\n            mojoFieldVisitors = mojoClassVisitor.findFieldWithAnnotationClass( Component.class.getName() );\n            for ( MojoFieldVisitor mojoFieldVisitor : mojoFieldVisitors )\n            {\n                ComponentAnnotationContent componentAnnotationContent =\n                    new ComponentAnnotationContent( mojoFieldVisitor.getFieldName() );\n\n                if ( mojoFieldVisitor.getMojoAnnotationVisitor() != null )\n                {\n                    for ( Map.Entry<String, Object> entry : mojoFieldVisitor.getMojoAnnotationVisitor().getAnnotationValues().entrySet() )\n                    {\n                        String methodName = entry.getKey();\n                        if ( StringUtils.equals( \"role\", methodName ) )\n                        {\n                            Type type = (Type) entry.getValue();\n                            componentAnnotationContent.setRoleClassName( type.getClassName() );\n                        }\n                        else\n                        {\n                            reflector.invoke( componentAnnotationContent, entry.getKey(),\n                                              new Object[]{ entry.getValue() } );\n                        }\n                    }\n\n                    if ( StringUtils.isEmpty( componentAnnotationContent.getRoleClassName() ) )\n                    {\n                        componentAnnotationContent.setRoleClassName( mojoFieldVisitor.getClassName() );\n                    }\n                }\n                mojoAnnotatedClass.getComponents().put( componentAnnotationContent.getFieldName(),\n                                                        componentAnnotationContent );\n            }\n        }\n        catch ( ReflectorException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.annotations.scanner;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ComponentAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ExecuteAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.MojoAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ParameterAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoAnnotationVisitor;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoClassVisitor;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoFieldVisitor;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.DirectoryScanner;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.reflection.Reflector;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.Type;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\n/**\n * @author Olivier Lamy\n * @since 3.0\n */\n@org.codehaus.plexus.component.annotations.Component( role = MojoAnnotationsScanner.class )\npublic class DefaultMojoAnnotationsScanner\n    extends AbstractLogEnabled\n    implements MojoAnnotationsScanner\n{\n    private Reflector reflector = new Reflector();\n\n    public Map<String, MojoAnnotatedClass> scan( MojoAnnotationsScannerRequest request )\n        throws ExtractionException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n        try\n        {\n\n            for ( Artifact dependency : request.getDependencies() )\n            {\n                File dependencyFile = dependency.getFile();\n                if ( dependencyFile != null && dependencyFile.exists() )\n                {\n                    if ( dependencyFile.isDirectory() )\n                    {\n                        mojoAnnotatedClasses.putAll(\n                            scanDirectory( dependencyFile, request.getIncludePatterns(), dependency, true ) );\n                    }\n                    else\n                    {\n                        mojoAnnotatedClasses.putAll(\n                            scanFile( dependencyFile, request.getIncludePatterns(), dependency, true ) );\n                    }\n                }\n            }\n\n            for ( File classDirectory : request.getClassesDirectories() )\n            {\n                if ( classDirectory.exists() && classDirectory.isDirectory() )\n                {\n                    mojoAnnotatedClasses.putAll(\n                        scanDirectory( classDirectory, request.getIncludePatterns(), request.getProject().getArtifact(),\n                                       false ) );\n                }\n            }\n\n            return mojoAnnotatedClasses;\n        }\n        catch ( IOException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n\n    /**\n     * @param archiveFile\n     * @param includePatterns\n     * @param artifact\n     * @param excludeMojo     for dependencies we exclude Mojo annotations found\n     * @return\n     * @throws IOException\n     * @throws ExtractionException\n     */\n    protected Map<String, MojoAnnotatedClass> scanFile( File archiveFile, List<String> includePatterns,\n                                                        Artifact artifact, boolean excludeMojo )\n        throws IOException, ExtractionException\n    {\n        if ( !archiveFile.exists() )\n        {\n            return Collections.emptyMap();\n        }\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n        ZipInputStream archiveStream = new ZipInputStream( new FileInputStream( archiveFile ) );\n\n        try\n        {\n            for ( ZipEntry zipEntry = archiveStream.getNextEntry(); zipEntry != null;\n                  zipEntry = archiveStream.getNextEntry() )\n            {\n                if ( zipEntry.getName().endsWith( \".class\" ) )\n                {\n                    MojoClassVisitor mojoClassVisitor = new MojoClassVisitor( getLogger() );\n\n                    ClassReader rdr = new ClassReader( archiveStream );\n                    rdr.accept( mojoClassVisitor,\n                                ClassReader.SKIP_FRAMES | ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG );\n                    analyzeVisitors( mojoClassVisitor );\n                    if ( excludeMojo )\n                    {\n                        mojoClassVisitor.getMojoAnnotatedClass().setMojo( null );\n                    }\n                    if ( isStoreClass( mojoClassVisitor.getMojoAnnotatedClass() ) != null )\n                    {\n                        if ( getLogger().isDebugEnabled() )\n                        {\n                            getLogger().debug( \"found MojoAnnotatedClass:\"\n                                                   + mojoClassVisitor.getMojoAnnotatedClass().getClassName() + \":\"\n                                                   + mojoClassVisitor.getMojoAnnotatedClass() );\n                        }\n                        mojoClassVisitor.getMojoAnnotatedClass().setArtifact( artifact );\n                        mojoAnnotatedClasses.put( mojoClassVisitor.getMojoAnnotatedClass().getClassName(),\n                                                  mojoClassVisitor.getMojoAnnotatedClass() );\n                    }\n                }\n            }\n        }\n        finally\n        {\n            IOUtil.close( archiveStream );\n        }\n        return mojoAnnotatedClasses;\n    }\n\n    /**\n     * @param classDirectory\n     * @param includePatterns\n     * @param artifact\n     * @param excludeMojo     for dependencies we exclude Mojo annotations found\n     * @return\n     * @throws IOException\n     * @throws ExtractionException\n     */\n    protected Map<String, MojoAnnotatedClass> scanDirectory( File classDirectory, List<String> includePatterns,\n                                                             Artifact artifact, boolean excludeMojo )\n        throws IOException, ExtractionException\n    {\n        if ( !classDirectory.exists() )\n        {\n            return Collections.emptyMap();\n        }\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n        DirectoryScanner scanner = new DirectoryScanner();\n        scanner.setBasedir( classDirectory );\n        scanner.addDefaultExcludes();\n        if ( includePatterns != null )\n        {\n            scanner.setIncludes( includePatterns.toArray( new String[includePatterns.size()] ) );\n        }\n        scanner.scan();\n        String[] classFiles = scanner.getIncludedFiles();\n\n        for ( String classFile : classFiles )\n        {\n            if ( !classFile.endsWith( \".class\" ) )\n            {\n                continue;\n            }\n\n            InputStream is = new BufferedInputStream( new FileInputStream( new File( classDirectory, classFile ) ) );\n            try\n            {\n                MojoClassVisitor mojoClassVisitor = new MojoClassVisitor( getLogger() );\n                ClassReader rdr = new ClassReader( is );\n                rdr.accept( mojoClassVisitor,\n                            ClassReader.SKIP_FRAMES | ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG );\n                analyzeVisitors( mojoClassVisitor );\n\n                MojoAnnotatedClass mojoAnnotatedClass = mojoClassVisitor.getMojoAnnotatedClass();\n\n                if ( excludeMojo )\n                {\n                    mojoAnnotatedClass.setMojo( null );\n                }\n\n                if ( isStoreClass( mojoAnnotatedClass ) != null )\n                {\n                    if ( getLogger().isDebugEnabled() )\n                    {\n                        getLogger().debug( \"found MojoAnnotatedClass:\" + mojoAnnotatedClass.getClassName() + \":\"\n                                               + mojoAnnotatedClass );\n                    }\n                    mojoAnnotatedClass.setArtifact( artifact );\n                    mojoAnnotatedClasses.put( mojoAnnotatedClass.getClassName(), mojoAnnotatedClass );\n                }\n            }\n            finally\n            {\n                IOUtil.close( is );\n            }\n        }\n        return mojoAnnotatedClasses;\n    }\n\n    private MojoAnnotatedClass isStoreClass( MojoAnnotatedClass mojoAnnotatedClass )\n    {\n        // see MPLUGIN-206 we can have intermediate classes without annotations\n        if ( mojoAnnotatedClass == null )\n        {\n            return null;\n        }\n        return mojoAnnotatedClass;\n        /**\n         if ( !mojoAnnotatedClass.getComponents().isEmpty() || !mojoAnnotatedClass.getParameters().isEmpty()\n         || mojoAnnotatedClass.getExecute() != null || mojoAnnotatedClass.getMojo() != null )\n         {\n         return mojoAnnotatedClass;\n         }\n         return null;\n         **/\n    }\n\n\n    protected void analyzeVisitors( MojoClassVisitor mojoClassVisitor )\n        throws ExtractionException\n    {\n\n        try\n        {\n            MojoAnnotationVisitor mojoAnnotationVisitor =\n                mojoClassVisitor.getAnnotationVisitorMap().get( Mojo.class.getName() );\n            if ( mojoAnnotationVisitor != null )\n            {\n                MojoAnnotationContent mojoAnnotationContent = new MojoAnnotationContent();\n                for ( Map.Entry<String, Object> entry : mojoAnnotationVisitor.getAnnotationValues().entrySet() )\n                {\n                    reflector.invoke( mojoAnnotationContent, entry.getKey(), new Object[]{ entry.getValue() } );\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().setMojo( mojoAnnotationContent );\n            }\n\n            mojoAnnotationVisitor = mojoClassVisitor.getAnnotationVisitorMap().get( Execute.class.getName() );\n            if ( mojoAnnotationVisitor != null )\n            {\n                ExecuteAnnotationContent executeAnnotationContent = new ExecuteAnnotationContent();\n\n                for ( Map.Entry<String, Object> entry : mojoAnnotationVisitor.getAnnotationValues().entrySet() )\n                {\n                    reflector.invoke( executeAnnotationContent, entry.getKey(), new Object[]{ entry.getValue() } );\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().setExecute( executeAnnotationContent );\n            }\n\n            List<MojoFieldVisitor> mojoFieldVisitors =\n                mojoClassVisitor.findFieldWithAnnotationClass( Parameter.class.getName() );\n\n            for ( MojoFieldVisitor mojoFieldVisitor : mojoFieldVisitors )\n            {\n                ParameterAnnotationContent parameterAnnotationContent =\n                    new ParameterAnnotationContent( mojoFieldVisitor.getFieldName(), mojoFieldVisitor.getClassName() );\n                if ( mojoFieldVisitor.getMojoAnnotationVisitor() != null )\n                {\n                    for ( Map.Entry<String, Object> entry : mojoFieldVisitor.getMojoAnnotationVisitor().getAnnotationValues().entrySet() )\n                    {\n                        reflector.invoke( parameterAnnotationContent, entry.getKey(),\n                                          new Object[]{ entry.getValue() } );\n                    }\n\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().getParameters().put( parameterAnnotationContent.getFieldName(),\n                                                                              parameterAnnotationContent );\n            }\n\n            mojoFieldVisitors = mojoClassVisitor.findFieldWithAnnotationClass( Component.class.getName() );\n\n            for ( MojoFieldVisitor mojoFieldVisitor : mojoFieldVisitors )\n            {\n                ComponentAnnotationContent componentAnnotationContent =\n                    new ComponentAnnotationContent( mojoFieldVisitor.getFieldName() );\n\n                if ( mojoFieldVisitor.getMojoAnnotationVisitor() != null )\n                {\n                    for ( Map.Entry<String, Object> entry : mojoFieldVisitor.getMojoAnnotationVisitor().getAnnotationValues().entrySet() )\n                    {\n                        String methodName = entry.getKey();\n                        if ( StringUtils.equals( \"role\", methodName ) )\n                        {\n                            Type type = (Type) entry.getValue();\n                            componentAnnotationContent.setRoleClassName( type.getClassName() );\n                        }\n                        else\n                        {\n                            reflector.invoke( componentAnnotationContent, entry.getKey(),\n                                              new Object[]{ entry.getValue() } );\n                        }\n                    }\n                    if ( StringUtils.isEmpty( componentAnnotationContent.getRoleClassName() ) )\n                    {\n                        componentAnnotationContent.setRoleClassName( mojoFieldVisitor.getClassName() );\n                    }\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().getComponents().put( componentAnnotationContent.getFieldName(),\n                                                                              componentAnnotationContent );\n            }\n\n        }\n        catch ( Exception e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n}\n","lineNo":254}
{"Refactored Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.velocity.VelocityContext;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.PropertyUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.velocity.VelocityComponent;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.commons.Remapper;\nimport org.objectweb.asm.commons.RemappingClassAdapter;\nimport org.objectweb.asm.commons.SimpleRemapper;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Generates an <code>HelpMojo<\/code> class from <code>help-class-source.vm<\/code> template.\n * The generated mojo reads help content from <code>META-INF/maven/${groupId}/${artifactId}/plugin-help.xml<\/code> resource,\n * which is generated by this {@link PluginDescriptorGenerator}.\n * <p>Notice that the help mojo source needs to be generated before compilation, but when Java 5 annotations are used,\n * plugin descriptor content is available only after compilation (detecting annotations in .class files):\n * help mojo source can be generated with empty package only (and no plugin descriptor available yet), then needs\n * to be updated after compilation - through {@link #rewriteHelpMojo(PluginToolsRequest)} which is called from plugin\n * descriptor XML generation.<\/p>\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    /**\n     * Default generated class name\n     */\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    /**\n     * Help properties file, to store data about generated source.\n     */\n    private static final String HELP_PROPERTIES_FILENAME = \"maven-plugin-help.properties\";\n\n    /**\n     * Default goal\n     */\n    private static final String HELP_GOAL = \"help\";\n\n    private String helpPackageName;\n\n    private boolean useAnnotations;\n\n    private VelocityComponent velocityComponent;\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws GeneratorException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n\n        String helpImplementation = getImplementation( pluginDescriptor );\n\n        @SuppressWarnings( \"unchecked\" )\n        List<MojoDescriptor> mojoDescriptors = pluginDescriptor.getMojos();\n\n        if ( mojoDescriptors != null )\n        {\n            // Verify that no help goal already exists\n            MojoDescriptor descriptor = pluginDescriptor.getMojo( HELP_GOAL );\n\n            if ( ( descriptor != null ) && !descriptor.getImplementation().equals( helpImplementation ) )\n            {\n                if ( getLogger().isWarnEnabled() )\n                {\n                    getLogger().warn( \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                          + \") already exists in this plugin. SKIPPED THE \" + helpImplementation\n                                          + \" GENERATION.\\n\" );\n                }\n\n                return;\n            }\n        }\n\n        writeHelpPropertiesFile( request, destinationDirectory );\n        \n        useAnnotations = request.getProject().getArtifactMap().containsKey( \"org.apache.maven.plugin-tools:maven-plugin-annotations\" );\n\n        try\n        {\n            String sourcePath = helpImplementation.replace( '.', File.separatorChar ) + \".java\";\n\n            File helpClass = new File( destinationDirectory, sourcePath );\n            helpClass.getParentFile().mkdirs();\n\n            String helpClassSources = getHelpClassSources( getPluginHelpPath( request.getProject() ), pluginDescriptor );\n\n            FileUtils.fileWrite( helpClass, request.getEncoding(), helpClassSources );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n    }\n\n    public PluginHelpGenerator setHelpPackageName( String helpPackageName )\n    {\n        this.helpPackageName = helpPackageName;\n        return this;\n    }\n    \n    public VelocityComponent getVelocityComponent()\n    {\n        return velocityComponent;\n    }\n\n    public PluginHelpGenerator setVelocityComponent( VelocityComponent velocityComponent )\n    {\n        this.velocityComponent = velocityComponent;\n        return this;\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    private String getHelpClassSources( String pluginHelpPath, PluginDescriptor pluginDescriptor )\n    {\n        Properties properties = new Properties();\n        VelocityContext context = new VelocityContext( properties );\n        if ( this.helpPackageName != null )\n        {\n            properties.put( \"helpPackageName\", this.helpPackageName );\n        }\n        else\n        {\n            properties.put( \"helpPackageName\", \"\" );\n        }\n        properties.put( \"pluginHelpPath\", pluginHelpPath );\n        properties.put( \"artifactId\", pluginDescriptor.getArtifactId() );\n        properties.put( \"goalPrefix\", pluginDescriptor.getGoalPrefix() );\n        properties.put( \"useAnnotations\", useAnnotations );\n\n        StringWriter stringWriter = new StringWriter();\n\n        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream( \"help-class-source.vm\" );\n        InputStreamReader isReader = null;\n        try\n        {\n            isReader = new InputStreamReader( is, \"UTF-8\" ); // plugin-tools sources are UTF-8 (and even ASCII in this case)\n            velocityComponent.getEngine().evaluate( context, stringWriter, \"\", isReader );\n        }\n        catch ( UnsupportedEncodingException e )\n        {\n            // not supposed to happen since UTF-8 is supposed to be supported by any JVM\n        }\n        finally\n        {\n            IOUtil.close( is );\n            IOUtil.close( isReader );\n        }\n\n        return stringWriter.toString();\n    }\n\n    /**\n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *                         <code>null<\/code>.\n     * @return The implementation.\n     */\n    private String getImplementation( PluginDescriptor pluginDescriptor )\n    {\n        if ( StringUtils.isEmpty( helpPackageName ) )\n        {\n            helpPackageName = GeneratorUtils.discoverPackageName( pluginDescriptor );\n        }\n\n        return StringUtils.isEmpty( helpPackageName ) ? HELP_MOJO_CLASS_NAME : helpPackageName + '.' + HELP_MOJO_CLASS_NAME;\n    }\n\n    /**\n     * Write help properties files for later use to eventually rewrite Help Mojo.\n     *\n     * @param request\n     * @throws GeneratorException\n     * @see {@link #rewriteHelpMojo(PluginToolsRequest)}\n     */\n    private void writeHelpPropertiesFile( PluginToolsRequest request, File destinationDirectory )\n        throws GeneratorException\n    {\n        Properties properties = new Properties();\n        properties.put( \"helpPackageName\", helpPackageName == null ? \"\" : helpPackageName );\n        properties.put( \"destinationDirectory\", destinationDirectory.getAbsolutePath() );\n\n        File tmpPropertiesFile =\n            new File( request.getProject().getBuild().getDirectory(), HELP_PROPERTIES_FILENAME );\n\n        if ( tmpPropertiesFile.exists() )\n        {\n            tmpPropertiesFile.delete();\n        }\n        else if ( !tmpPropertiesFile.getParentFile().exists() )\n        {\n            tmpPropertiesFile.getParentFile().mkdirs();\n        }\n\n        FileOutputStream fos = null;\n        try\n        {\n            fos = new FileOutputStream( tmpPropertiesFile );\n            properties.store( fos, \"maven plugin help mojo generation informations\" );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( fos );\n        }\n    }\n\n    static String getPluginHelpPath( MavenProject mavenProject )\n    {\n        return \"META-INF/maven/\" + mavenProject.getGroupId() + \"/\" + mavenProject.getArtifactId() + \"/plugin-help.xml\";\n    }\n\n    /**\n     * Rewrite Help Mojo to match actual Mojos package name if it was not available at source generation\n     * time. This is used at descriptor generation time.\n     *\n     * @param request\n     * @throws GeneratorException\n     */\n    static void rewriteHelpMojo( PluginToolsRequest request, Logger log )\n        throws GeneratorException\n    {\n        File tmpPropertiesFile =\n            new File( request.getProject().getBuild().getDirectory(), HELP_PROPERTIES_FILENAME );\n\n        if ( !tmpPropertiesFile.exists() )\n        {\n            return;\n        }\n\n        Properties properties = PropertyUtils.loadProperties( tmpPropertiesFile );\n\n        String helpPackageName = properties.getProperty( \"helpPackageName\" );\n\n        // if helpPackageName property is empty, we have to rewrite the class with a better package name than empty\n        if ( StringUtils.isEmpty( helpPackageName ) )\n        {\n            String destDir = properties.getProperty( \"destinationDirectory\" );\n            File destinationDirectory;\n            if ( StringUtils.isEmpty( destDir ) )\n            {\n                // writeHelpPropertiesFile() creates 2 properties: find one without the other should not be possible\n                log.warn( \"\\n\\nUnexpected situation: destinationDirectory not defined in \" + HELP_PROPERTIES_FILENAME\n                    + \" during help mojo source generation but expected during XML descriptor generation.\" );\n                log.warn( \"Please check helpmojo goal version used in previous build phase.\" );\n                destinationDirectory = new File( \"target/generated-sources/plugin\" );\n                log.warn( \"Trying default location: \" + destinationDirectory );\n            }\n            else\n            {\n                destinationDirectory = new File( destDir );\n            }\n            String helpMojoImplementation = rewriteHelpClassToMojoPackage( request, destinationDirectory, log );\n\n            if ( helpMojoImplementation != null )\n            {\n                // rewrite plugin descriptor with new HelpMojo implementation class\n                updateHelpMojoDescriptor( request.getPluginDescriptor(), helpMojoImplementation );\n            }\n        }\n    }\n\n    private static String rewriteHelpClassToMojoPackage( PluginToolsRequest request, File destinationDirectory, Logger log )\n        throws GeneratorException\n    {\n        String destinationPackage = GeneratorUtils.discoverPackageName( request.getPluginDescriptor() );\n        if ( StringUtils.isEmpty( destinationPackage ) )\n        {\n            return null;\n        }\n        String packageAsDirectory = StringUtils.replace( destinationPackage, '.', '/' );\n\n        String outputDirectory = request.getProject().getBuild().getOutputDirectory();\n        File helpClassFile = new File( outputDirectory, HELP_MOJO_CLASS_NAME + \".class\" );\n        if ( !helpClassFile.exists() )\n        {\n            return null;\n        }\n\n        // rewrite help mojo source\n        File helpSourceFile = new File( destinationDirectory, HELP_MOJO_CLASS_NAME + \".java\" );\n        if ( !helpSourceFile.exists() )\n        {\n            log.warn( \"HelpMojo.java not found in default location: \" + helpSourceFile.getAbsolutePath() );\n            log.warn( \"Help goal source won't be moved to package: \" + destinationPackage );\n        }\n        else\n        {\n            File helpSourceFileNew = new File( destinationDirectory, packageAsDirectory + '/' + HELP_MOJO_CLASS_NAME + \".java\" );\n            if ( !helpSourceFileNew.getParentFile().exists() )\n            {\n                helpSourceFileNew.getParentFile().mkdirs();\n            }\n            Reader sourceReader = null;\n            PrintWriter sourceWriter = null;\n            try\n            {\n                sourceReader = new InputStreamReader( new FileInputStream( helpSourceFile ), request.getEncoding() );\n                sourceWriter =\n                    new PrintWriter( new OutputStreamWriter( new FileOutputStream( helpSourceFileNew ),\n                                                             request.getEncoding() ) );\n    \n                sourceWriter.println( \"package \" + destinationPackage + \";\" );\n                IOUtil.copy( sourceReader, sourceWriter );\n            }\n            catch ( IOException e )\n            {\n                throw new GeneratorException( e.getMessage(), e );\n            }\n            finally\n            {\n                IOUtil.close( sourceReader );\n                IOUtil.close( sourceWriter );\n            }\n            helpSourceFileNew.setLastModified( helpSourceFile.lastModified() );\n            helpSourceFile.delete();\n        }\n\n        // rewrite help mojo .class\n        File rewriteHelpClassFile =\n            new File( outputDirectory + '/' + packageAsDirectory, HELP_MOJO_CLASS_NAME + \".class\" );\n        if ( !rewriteHelpClassFile.getParentFile().exists() )\n        {\n            rewriteHelpClassFile.getParentFile().mkdirs();\n        }\n\n        FileInputStream fileInputStream = null;\n        ClassReader cr = null;\n        try\n        {\n            fileInputStream = new FileInputStream( helpClassFile );\n            cr = new ClassReader( fileInputStream );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( fileInputStream );\n        }\n\n        ClassWriter cw = new ClassWriter( 0 );\n\n        Remapper packageRemapper =\n            new SimpleRemapper( HELP_MOJO_CLASS_NAME, packageAsDirectory + '/' + HELP_MOJO_CLASS_NAME );\n        ClassVisitor cv = new RemappingClassAdapter( cw, packageRemapper );\n\n        try\n        {\n            cr.accept( cv, ClassReader.EXPAND_FRAMES );\n        }\n        catch ( Throwable e )\n        {\n            throw new GeneratorException( \"ASM issue processing class-file \" + helpClassFile.getPath(), e );\n        }\n\n        byte[] renamedClass = cw.toByteArray();\n        FileOutputStream fos = null;\n        try\n        {\n            fos = new FileOutputStream( rewriteHelpClassFile );\n            fos.write( renamedClass );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( \"Error rewriting help class: \" + e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( fos );\n        }\n\n        helpClassFile.delete();\n\n        return destinationPackage + \".HelpMojo\";\n    }\n\n    private static void updateHelpMojoDescriptor( PluginDescriptor pluginDescriptor, String helpMojoImplementation )\n    {\n        MojoDescriptor mojoDescriptor = pluginDescriptor.getMojo( HELP_GOAL );\n\n        if ( mojoDescriptor != null )\n        {\n            mojoDescriptor.setImplementation( helpMojoImplementation );\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.velocity.VelocityContext;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.PropertyUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.velocity.VelocityComponent;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.commons.Remapper;\nimport org.objectweb.asm.commons.RemappingClassAdapter;\nimport org.objectweb.asm.commons.SimpleRemapper;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Generates an <code>HelpMojo<\/code> class from <code>help-class-source.vm<\/code> template.\n * The generated mojo reads help content from <code>META-INF/maven/${groupId}/${artifactId}/plugin-help.xml<\/code> resource,\n * which is generated by this {@link PluginDescriptorGenerator}.\n * <p>Notice that the help mojo source needs to be generated before compilation, but when Java 5 annotations are used,\n * plugin descriptor content is available only after compilation (detecting annotations in .class files):\n * help mojo source can be generated with empty package only (and no plugin descriptor available yet), then needs\n * to be updated after compilation - through {@link #rewriteHelpMojo(PluginToolsRequest)} which is called from plugin\n * descriptor XML generation.<\/p>\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    /**\n     * Default generated class name\n     */\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    /**\n     * Help properties file, to store data about generated source.\n     */\n    private static final String HELP_PROPERTIES_FILENAME = \"maven-plugin-help.properties\";\n\n    /**\n     * Default goal\n     */\n    private static final String HELP_GOAL = \"help\";\n\n    private String helpPackageName;\n\n    private boolean useAnnotations;\n\n    private VelocityComponent velocityComponent;\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws GeneratorException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n\n        String helpImplementation = getImplementation( pluginDescriptor );\n\n        @SuppressWarnings( \"unchecked\" )\n        List<MojoDescriptor> mojoDescriptors = pluginDescriptor.getMojos();\n\n        if ( mojoDescriptors != null )\n        {\n            // Verify that no help goal already exists\n            MojoDescriptor descriptor = pluginDescriptor.getMojo( HELP_GOAL );\n\n            if ( ( descriptor != null ) && !descriptor.getImplementation().equals( helpImplementation ) )\n            {\n                if ( getLogger().isWarnEnabled() )\n                {\n                    getLogger().warn( \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                          + \") already exists in this plugin. SKIPPED THE \" + helpImplementation\n                                          + \" GENERATION.\\n\" );\n                }\n\n                return;\n            }\n        }\n\n        writeHelpPropertiesFile( request, destinationDirectory );\n        \n        useAnnotations = request.getProject().getArtifactMap().containsKey( \"org.apache.maven.plugin-tools:maven-plugin-annotations\" );\n\n        try\n        {\n            String sourcePath = helpImplementation.replace( '.', File.separatorChar ) + \".java\";\n\n            File helpClass = new File( destinationDirectory, sourcePath );\n            helpClass.getParentFile().mkdirs();\n\n            String helpClassSources = getHelpClassSources( getPluginHelpPath( request.getProject() ), pluginDescriptor );\n\n            FileUtils.fileWrite( helpClass, request.getEncoding(), helpClassSources );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n    }\n\n    public PluginHelpGenerator setHelpPackageName( String helpPackageName )\n    {\n        this.helpPackageName = helpPackageName;\n        return this;\n    }\n    \n    public VelocityComponent getVelocityComponent()\n    {\n        return velocityComponent;\n    }\n\n    public PluginHelpGenerator setVelocityComponent( VelocityComponent velocityComponent )\n    {\n        this.velocityComponent = velocityComponent;\n        return this;\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    private String getHelpClassSources( String pluginHelpPath, PluginDescriptor pluginDescriptor )\n    {\n        Properties properties = new Properties();\n        VelocityContext context = new VelocityContext( properties );\n        if ( this.helpPackageName != null )\n        {\n            properties.put( \"helpPackageName\", this.helpPackageName );\n        }\n        else\n        {\n            properties.put( \"helpPackageName\", \"\" );\n        }\n        properties.put( \"pluginHelpPath\", pluginHelpPath );\n        properties.put( \"artifactId\", pluginDescriptor.getArtifactId() );\n        properties.put( \"goalPrefix\", pluginDescriptor.getGoalPrefix() );\n        properties.put( \"useAnnotations\", useAnnotations );\n\n        StringWriter stringWriter = new StringWriter();\n\n        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream( \"help-class-source.vm\" );\n        InputStreamReader isReader = null;\n        try\n        {\n            isReader = new InputStreamReader( is, \"UTF-8\" ); // plugin-tools sources are UTF-8 (and even ASCII in this case)\n            velocityComponent.getEngine().evaluate( context, stringWriter, \"\", isReader );\n        }\n        catch ( UnsupportedEncodingException e )\n        {\n            // not supposed to happen since UTF-8 is supposed to be supported by any JVM\n        }\n        finally\n        {\n            IOUtil.close( is );\n            IOUtil.close( isReader );\n        }\n\n        return stringWriter.toString();\n    }\n\n    /**\n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *                         <code>null<\/code>.\n     * @return The implementation.\n     */\n    private String getImplementation( PluginDescriptor pluginDescriptor )\n    {\n        if ( StringUtils.isEmpty( helpPackageName ) )\n        {\n            helpPackageName = GeneratorUtils.discoverPackageName( pluginDescriptor );\n        }\n\n        return StringUtils.isEmpty( helpPackageName ) ? HELP_MOJO_CLASS_NAME : helpPackageName + '.' + HELP_MOJO_CLASS_NAME;\n    }\n\n    /**\n     * Write help properties files for later use to eventually rewrite Help Mojo.\n     *\n     * @param request\n     * @throws GeneratorException\n     * @see {@link #rewriteHelpMojo(PluginToolsRequest)}\n     */\n    private void writeHelpPropertiesFile( PluginToolsRequest request, File destinationDirectory )\n        throws GeneratorException\n    {\n        Properties properties = new Properties();\n        properties.put( \"helpPackageName\", helpPackageName == null ? \"\" : helpPackageName );\n        properties.put( \"destinationDirectory\", destinationDirectory.getAbsolutePath() );\n\n        File tmpPropertiesFile =\n            new File( request.getProject().getBuild().getDirectory(), HELP_PROPERTIES_FILENAME );\n\n        if ( tmpPropertiesFile.exists() )\n        {\n            tmpPropertiesFile.delete();\n        }\n        else if ( !tmpPropertiesFile.getParentFile().exists() )\n        {\n            tmpPropertiesFile.getParentFile().mkdirs();\n        }\n\n        FileOutputStream fos = null;\n        try\n        {\n            fos = new FileOutputStream( tmpPropertiesFile );\n            properties.store( fos, \"maven plugin help mojo generation informations\" );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( fos );\n        }\n    }\n\n    static String getPluginHelpPath( MavenProject mavenProject )\n    {\n        return \"META-INF/maven/\" + mavenProject.getGroupId() + \"/\" + mavenProject.getArtifactId() + \"/plugin-help.xml\";\n    }\n\n    /**\n     * Rewrite Help Mojo to match actual Mojos package name if it was not available at source generation\n     * time. This is used at descriptor generation time.\n     *\n     * @param request\n     * @throws GeneratorException\n     */\n    static void rewriteHelpMojo( PluginToolsRequest request )\n        throws GeneratorException\n    {\n        File tmpPropertiesFile =\n            new File( request.getProject().getBuild().getDirectory(), HELP_PROPERTIES_FILENAME );\n\n        if ( !tmpPropertiesFile.exists() )\n        {\n            return;\n        }\n\n        Properties properties = PropertyUtils.loadProperties( tmpPropertiesFile );\n\n        String helpPackageName = properties.getProperty( \"helpPackageName\" );\n\n        // if helpPackageName property is empty, we have to rewrite the class with a better package name than empty\n        if ( StringUtils.isEmpty( helpPackageName ) )\n        {\n            File destinationDirectory = new File( properties.getProperty( \"destinationDirectory\" ) );\n            String helpMojoImplementation = rewriteHelpClassToMojoPackage( request, destinationDirectory );\n\n            if ( helpMojoImplementation != null )\n            {\n                // rewrite plugin descriptor with new HelpMojo implementation class\n                updateHelpMojoDescriptor( request.getPluginDescriptor(), helpMojoImplementation );\n            }\n        }\n    }\n\n    private static String rewriteHelpClassToMojoPackage( PluginToolsRequest request, File destinationDirectory )\n        throws GeneratorException\n    {\n        String destinationPackage = GeneratorUtils.discoverPackageName( request.getPluginDescriptor() );\n        if ( StringUtils.isEmpty( destinationPackage ) )\n        {\n            return null;\n        }\n        String packageAsDirectory = StringUtils.replace( destinationPackage, '.', '/' );\n\n        String outputDirectory = request.getProject().getBuild().getOutputDirectory();\n        File helpClassFile = new File( outputDirectory, HELP_MOJO_CLASS_NAME + \".class\" );\n        if ( !helpClassFile.exists() )\n        {\n            return null;\n        }\n\n        // rewrite help mojo source\n        File helpSourceFile = new File( destinationDirectory, HELP_MOJO_CLASS_NAME + \".java\" );\n        File helpSourceFileNew = new File( destinationDirectory, packageAsDirectory + '/' + HELP_MOJO_CLASS_NAME + \".java\" );\n        if ( !helpSourceFileNew.getParentFile().exists() )\n        {\n            helpSourceFileNew.getParentFile().mkdirs();\n        }\n        Reader sourceReader = null;\n        PrintWriter sourceWriter = null;\n        try\n        {\n            sourceReader = new InputStreamReader( new FileInputStream( helpSourceFile ), request.getEncoding() );\n            sourceWriter =\n                new PrintWriter( new OutputStreamWriter( new FileOutputStream( helpSourceFileNew ),\n                                                         request.getEncoding() ) );\n\n            sourceWriter.println( \"package \" + destinationPackage + \";\" );\n            IOUtil.copy( sourceReader, sourceWriter );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( sourceReader );\n            IOUtil.close( sourceWriter );\n        }\n        helpSourceFileNew.setLastModified( helpSourceFile.lastModified() );\n        helpSourceFile.delete();\n\n        // rewrite help mojo .class\n        File rewriteHelpClassFile =\n            new File( outputDirectory + '/' + packageAsDirectory, HELP_MOJO_CLASS_NAME + \".class\" );\n        if ( !rewriteHelpClassFile.getParentFile().exists() )\n        {\n            rewriteHelpClassFile.getParentFile().mkdirs();\n        }\n\n        FileInputStream fileInputStream = null;\n        ClassReader cr = null;\n        try\n        {\n            fileInputStream = new FileInputStream( helpClassFile );\n            cr = new ClassReader( fileInputStream );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( fileInputStream );\n        }\n\n        ClassWriter cw = new ClassWriter( 0 );\n\n        Remapper packageRemapper =\n            new SimpleRemapper( HELP_MOJO_CLASS_NAME, packageAsDirectory + '/' + HELP_MOJO_CLASS_NAME );\n        ClassVisitor cv = new RemappingClassAdapter( cw, packageRemapper );\n\n        try\n        {\n            cr.accept( cv, ClassReader.EXPAND_FRAMES );\n        }\n        catch ( Throwable e )\n        {\n            throw new GeneratorException( \"ASM issue processing class-file \" + helpClassFile.getPath(), e );\n        }\n\n        byte[] renamedClass = cw.toByteArray();\n        FileOutputStream fos = null;\n        try\n        {\n            fos = new FileOutputStream( rewriteHelpClassFile );\n            fos.write( renamedClass );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( \"Error rewriting help class: \" + e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( fos );\n        }\n\n        helpClassFile.delete();\n\n        return destinationPackage + \".HelpMojo\";\n    }\n\n    private static void updateHelpMojoDescriptor( PluginDescriptor pluginDescriptor, String helpMojoImplementation )\n    {\n        MojoDescriptor mojoDescriptor = pluginDescriptor.getMojo( HELP_GOAL );\n\n        if ( mojoDescriptor != null )\n        {\n            mojoDescriptor.setImplementation( helpMojoImplementation );\n        }\n    }\n}\n","lineNo":306}
{"Refactored Sample":"package org.apache.maven.tools.plugin.annotations.scanner;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ComponentAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ExecuteAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.MojoAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ParameterAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoAnnotationVisitor;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoClassVisitor;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoFieldVisitor;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.DirectoryScanner;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.reflection.Reflector;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.Type;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\n/**\n * @author Olivier Lamy\n * @since 3.0\n */\n@org.codehaus.plexus.component.annotations.Component( role = MojoAnnotationsScanner.class )\npublic class DefaultMojoAnnotationsScanner\n    extends AbstractLogEnabled\n    implements MojoAnnotationsScanner\n{\n    private Reflector reflector = new Reflector();\n\n    public Map<String, MojoAnnotatedClass> scan( MojoAnnotationsScannerRequest request )\n        throws ExtractionException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n        try\n        {\n\n            for ( Artifact dependency : request.getDependencies() )\n            {\n                File dependencyFile = dependency.getFile();\n                if ( dependencyFile != null && dependencyFile.exists() )\n                {\n                    if ( dependencyFile.isDirectory() )\n                    {\n                        mojoAnnotatedClasses.putAll(\n                            scanDirectory( dependencyFile, request.getIncludePatterns(), dependency, true ) );\n                    }\n                    else\n                    {\n                        mojoAnnotatedClasses.putAll(\n                            scanFile( dependencyFile, request.getIncludePatterns(), dependency, true ) );\n                    }\n                }\n            }\n\n            for ( File classDirectory : request.getClassesDirectories() )\n            {\n                if ( classDirectory.exists() && classDirectory.isDirectory() )\n                {\n                    mojoAnnotatedClasses.putAll(\n                        scanDirectory( classDirectory, request.getIncludePatterns(), request.getProject().getArtifact(),\n                                       false ) );\n                }\n            }\n\n            return mojoAnnotatedClasses;\n        }\n        catch ( IOException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n\n    /**\n     * @param archiveFile\n     * @param includePatterns\n     * @param artifact\n     * @param excludeMojo     for dependencies we exclude Mojo annotations found\n     * @return\n     * @throws IOException\n     * @throws ExtractionException\n     */\n    protected Map<String, MojoAnnotatedClass> scanFile( File archiveFile, List<String> includePatterns,\n                                                        Artifact artifact, boolean excludeMojo )\n        throws IOException, ExtractionException\n    {\n        if ( !archiveFile.exists() )\n        {\n            return Collections.emptyMap();\n        }\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n        ZipInputStream archiveStream = new ZipInputStream( new FileInputStream( archiveFile ) );\n\n        try\n        {\n            for ( ZipEntry zipEntry = archiveStream.getNextEntry(); zipEntry != null;\n                  zipEntry = archiveStream.getNextEntry() )\n            {\n                if ( zipEntry.getName().endsWith( \".class\" ) )\n                {\n                    MojoClassVisitor mojoClassVisitor = new MojoClassVisitor( getLogger() );\n\n                    ClassReader rdr = new ClassReader( archiveStream );\n                    rdr.accept( mojoClassVisitor,\n                                ClassReader.SKIP_FRAMES | ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG );\n                    analyzeVisitors( mojoClassVisitor );\n                    if ( excludeMojo )\n                    {\n                        mojoClassVisitor.getMojoAnnotatedClass().setMojo( null );\n                    }\n                    if ( isStoreClass( mojoClassVisitor.getMojoAnnotatedClass() ) != null )\n                    {\n                        getLogger().debug(\n                            \"found MojoAnnotatedClass:\" + mojoClassVisitor.getMojoAnnotatedClass().getClassName() + \":\"\n                                + mojoClassVisitor.getMojoAnnotatedClass() );\n                        mojoClassVisitor.getMojoAnnotatedClass().setArtifact( artifact );\n                        mojoAnnotatedClasses.put( mojoClassVisitor.getMojoAnnotatedClass().getClassName(),\n                                                  mojoClassVisitor.getMojoAnnotatedClass() );\n                    }\n                }\n            }\n        }\n        finally\n        {\n            IOUtil.close( archiveStream );\n        }\n        return mojoAnnotatedClasses;\n    }\n\n    /**\n     * @param classDirectory\n     * @param includePatterns\n     * @param artifact\n     * @param excludeMojo     for dependencies we exclude Mojo annotations found\n     * @return\n     * @throws IOException\n     * @throws ExtractionException\n     */\n    protected Map<String, MojoAnnotatedClass> scanDirectory( File classDirectory, List<String> includePatterns,\n                                                             Artifact artifact, boolean excludeMojo )\n        throws IOException, ExtractionException\n    {\n        if ( !classDirectory.exists() )\n        {\n            return Collections.emptyMap();\n        }\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n        DirectoryScanner scanner = new DirectoryScanner();\n        scanner.setBasedir( classDirectory );\n        scanner.addDefaultExcludes();\n        if ( includePatterns != null )\n        {\n            scanner.setIncludes( includePatterns.toArray( new String[includePatterns.size()] ) );\n        }\n        scanner.scan();\n        String[] classFiles = scanner.getIncludedFiles();\n\n        for ( String classFile : classFiles )\n        {\n            if ( !classFile.endsWith( \".class\" ) )\n            {\n                continue;\n            }\n\n            InputStream is = new BufferedInputStream( new FileInputStream( new File( classDirectory, classFile ) ) );\n            try\n            {\n                MojoClassVisitor mojoClassVisitor = new MojoClassVisitor( getLogger() );\n                ClassReader rdr = new ClassReader( is );\n                rdr.accept( mojoClassVisitor,\n                            ClassReader.SKIP_FRAMES | ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG );\n                analyzeVisitors( mojoClassVisitor );\n\n                MojoAnnotatedClass mojoAnnotatedClass = mojoClassVisitor.getMojoAnnotatedClass();\n\n                if ( excludeMojo )\n                {\n                    mojoAnnotatedClass.setMojo( null );\n                }\n\n                if ( isStoreClass( mojoAnnotatedClass ) != null )\n                {\n                    getLogger().debug( \"found MojoAnnotatedClass:\" + mojoAnnotatedClass.getClassName() + \":\"\n                                           + mojoAnnotatedClass );\n                    mojoAnnotatedClass.setArtifact( artifact );\n                    mojoAnnotatedClasses.put( mojoAnnotatedClass.getClassName(), mojoAnnotatedClass );\n                }\n            }\n            finally\n            {\n                IOUtil.close( is );\n            }\n        }\n        return mojoAnnotatedClasses;\n    }\n\n    private MojoAnnotatedClass isStoreClass( MojoAnnotatedClass mojoAnnotatedClass )\n    {\n        // see MPLUGIN-206 we can have intermediate classes without annotations\n        if ( mojoAnnotatedClass == null )\n        {\n            return null;\n        }\n        return mojoAnnotatedClass;\n        /**\n         if ( !mojoAnnotatedClass.getComponents().isEmpty() || !mojoAnnotatedClass.getParameters().isEmpty()\n         || mojoAnnotatedClass.getExecute() != null || mojoAnnotatedClass.getMojo() != null )\n         {\n         return mojoAnnotatedClass;\n         }\n         return null;\n         **/\n    }\n\n\n    protected void analyzeVisitors( MojoClassVisitor mojoClassVisitor )\n        throws ExtractionException\n    {\n\n        try\n        {\n            MojoAnnotationVisitor mojoAnnotationVisitor =\n                mojoClassVisitor.getAnnotationVisitorMap().get( Mojo.class.getName() );\n            if ( mojoAnnotationVisitor != null )\n            {\n                MojoAnnotationContent mojoAnnotationContent = new MojoAnnotationContent();\n                for ( Map.Entry<String, Object> entry : mojoAnnotationVisitor.getAnnotationValues().entrySet() )\n                {\n                    reflector.invoke( mojoAnnotationContent, entry.getKey(), new Object[]{ entry.getValue() } );\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().setMojo( mojoAnnotationContent );\n            }\n\n            mojoAnnotationVisitor = mojoClassVisitor.getAnnotationVisitorMap().get( Execute.class.getName() );\n            if ( mojoAnnotationVisitor != null )\n            {\n                ExecuteAnnotationContent executeAnnotationContent = new ExecuteAnnotationContent();\n\n                for ( Map.Entry<String, Object> entry : mojoAnnotationVisitor.getAnnotationValues().entrySet() )\n                {\n                    reflector.invoke( executeAnnotationContent, entry.getKey(), new Object[]{ entry.getValue() } );\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().setExecute( executeAnnotationContent );\n            }\n\n            List<MojoFieldVisitor> mojoFieldVisitors =\n                mojoClassVisitor.findFieldWithAnnotationClass( Parameter.class.getName() );\n\n            for ( MojoFieldVisitor mojoFieldVisitor : mojoFieldVisitors )\n            {\n                ParameterAnnotationContent parameterAnnotationContent =\n                    new ParameterAnnotationContent( mojoFieldVisitor.getFieldName(), mojoFieldVisitor.getClassName() );\n                if ( mojoFieldVisitor.getMojoAnnotationVisitor() != null )\n                {\n                    for ( Map.Entry<String, Object> entry : mojoFieldVisitor.getMojoAnnotationVisitor().getAnnotationValues().entrySet() )\n                    {\n                        reflector.invoke( parameterAnnotationContent, entry.getKey(),\n                                          new Object[]{ entry.getValue() } );\n                    }\n\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().getParameters().put( parameterAnnotationContent.getFieldName(),\n                                                                              parameterAnnotationContent );\n            }\n\n            mojoFieldVisitors = mojoClassVisitor.findFieldWithAnnotationClass( Component.class.getName() );\n\n            for ( MojoFieldVisitor mojoFieldVisitor : mojoFieldVisitors )\n            {\n                ComponentAnnotationContent componentAnnotationContent =\n                    new ComponentAnnotationContent( mojoFieldVisitor.getFieldName() );\n\n                if ( mojoFieldVisitor.getMojoAnnotationVisitor() != null )\n                {\n                    for ( Map.Entry<String, Object> entry : mojoFieldVisitor.getMojoAnnotationVisitor().getAnnotationValues().entrySet() )\n                    {\n                        String methodName = entry.getKey();\n                        if ( StringUtils.equals( \"role\", methodName ) )\n                        {\n                            Type type = (Type) entry.getValue();\n                            componentAnnotationContent.setRoleClassName( type.getClassName() );\n                        }\n                        else\n                        {\n                            reflector.invoke( componentAnnotationContent, entry.getKey(),\n                                              new Object[]{ entry.getValue() } );\n                        }\n                    }\n                    if ( StringUtils.isEmpty( componentAnnotationContent.getRoleClassName() ) )\n                    {\n                        componentAnnotationContent.setRoleClassName( mojoFieldVisitor.getClassName() );\n                    }\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().getComponents().put( componentAnnotationContent.getFieldName(),\n                                                                              componentAnnotationContent );\n            }\n\n        }\n        catch ( Exception e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.annotations.scanner;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ComponentAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ExecuteAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.MojoAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ParameterAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoAnnotationVisitor;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoClassVisitor;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoFieldVisitor;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.DirectoryScanner;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.reflection.Reflector;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.Type;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\n/**\n * @author Olivier Lamy\n * @since 3.0\n */\n@org.codehaus.plexus.component.annotations.Component( role = MojoAnnotationsScanner.class )\npublic class DefaultMojoAnnotationsScanner\n    extends AbstractLogEnabled\n    implements MojoAnnotationsScanner\n{\n    private Reflector reflector = new Reflector();\n\n    public Map<String, MojoAnnotatedClass> scan( MojoAnnotationsScannerRequest request )\n        throws ExtractionException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n        try\n        {\n\n            for ( Artifact dependency : request.getDependencies() )\n            {\n                File dependencyFile = dependency.getFile();\n                if ( dependencyFile != null && dependencyFile.exists() )\n                {\n                    if ( dependencyFile.isDirectory() )\n                    {\n                        mojoAnnotatedClasses.putAll(\n                            scanDirectory( dependencyFile, request.getIncludePatterns(), dependency, true ) );\n                    }\n                    else\n                    {\n                        mojoAnnotatedClasses.putAll(\n                            scanFile( dependencyFile, request.getIncludePatterns(), dependency, true ) );\n                    }\n                }\n            }\n\n            for ( File classDirectory : request.getClassesDirectories() )\n            {\n                if ( classDirectory.exists() && classDirectory.isDirectory() )\n                {\n                    mojoAnnotatedClasses.putAll(\n                        scanDirectory( classDirectory, request.getIncludePatterns(), request.getProject().getArtifact(),\n                                       false ) );\n                }\n            }\n\n            return mojoAnnotatedClasses;\n        }\n        catch ( IOException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n\n    /**\n     * @param archiveFile\n     * @param includePatterns\n     * @param artifact\n     * @param excludeMojo     for dependencies we exclude Mojo annotations found\n     * @return\n     * @throws IOException\n     * @throws ExtractionException\n     */\n    protected Map<String, MojoAnnotatedClass> scanFile( File archiveFile, List<String> includePatterns,\n                                                        Artifact artifact, boolean excludeMojo )\n        throws IOException, ExtractionException\n    {\n        if ( !archiveFile.exists() )\n        {\n            return Collections.emptyMap();\n        }\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n        ZipInputStream archiveStream = new ZipInputStream( new FileInputStream( archiveFile ) );\n\n        try\n        {\n            for ( ZipEntry zipEntry = archiveStream.getNextEntry(); zipEntry != null;\n                  zipEntry = archiveStream.getNextEntry() )\n            {\n                if ( zipEntry.getName().endsWith( \".class\" ) )\n                {\n                    MojoClassVisitor mojoClassVisitor = new MojoClassVisitor( getLogger() );\n\n                    ClassReader rdr = new ClassReader( archiveStream );\n                    rdr.accept( mojoClassVisitor,\n                                ClassReader.SKIP_FRAMES | ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG );\n                    analyzeVisitors( mojoClassVisitor );\n                    if ( excludeMojo )\n                    {\n                        mojoClassVisitor.getMojoAnnotatedClass().setMojo( null );\n                    }\n                    if ( isStoreClass( mojoClassVisitor.getMojoAnnotatedClass() ) != null )\n                    {\n                        getLogger().debug(\n                            \"found MojoAnnotatedClass:\" + mojoClassVisitor.getMojoAnnotatedClass().getClassName() + \":\"\n                                + mojoClassVisitor.getMojoAnnotatedClass() );\n                        mojoClassVisitor.getMojoAnnotatedClass().setArtifact( artifact );\n                        mojoAnnotatedClasses.put( mojoClassVisitor.getMojoAnnotatedClass().getClassName(),\n                                                  mojoClassVisitor.getMojoAnnotatedClass() );\n                    }\n                }\n            }\n        }\n        finally\n        {\n            IOUtil.close( archiveStream );\n        }\n        return mojoAnnotatedClasses;\n    }\n\n    /**\n     * @param classDirectory\n     * @param includePatterns\n     * @param artifact\n     * @param excludeMojo     for dependencies we exclude Mojo annotations found\n     * @return\n     * @throws IOException\n     * @throws ExtractionException\n     */\n    protected Map<String, MojoAnnotatedClass> scanDirectory( File classDirectory, List<String> includePatterns,\n                                                             Artifact artifact, boolean excludeMojo )\n        throws IOException, ExtractionException\n    {\n        if ( !classDirectory.exists() )\n        {\n            return Collections.emptyMap();\n        }\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n        DirectoryScanner scanner = new DirectoryScanner();\n        scanner.setBasedir( classDirectory );\n        scanner.addDefaultExcludes();\n        if ( includePatterns != null )\n        {\n            scanner.setIncludes( includePatterns.toArray( new String[includePatterns.size()] ) );\n        }\n        scanner.scan();\n        String[] classFiles = scanner.getIncludedFiles();\n\n        for ( String classFile : classFiles )\n        {\n            InputStream is = new BufferedInputStream( new FileInputStream( new File( classDirectory, classFile ) ) );\n            try\n            {\n\n                if ( classFile.endsWith( \".class\" ) )\n                {\n                    MojoClassVisitor mojoClassVisitor = new MojoClassVisitor( getLogger() );\n                    ClassReader rdr = new ClassReader( is );\n                    rdr.accept( mojoClassVisitor,\n                                ClassReader.SKIP_FRAMES | ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG );\n                    analyzeVisitors( mojoClassVisitor );\n                    if ( excludeMojo )\n                    {\n                        mojoClassVisitor.getMojoAnnotatedClass().setMojo( null );\n                    }\n                    if ( isStoreClass( mojoClassVisitor.getMojoAnnotatedClass() ) != null )\n                    {\n                        getLogger().debug(\n                            \"found MojoAnnotatedClass:\" + mojoClassVisitor.getMojoAnnotatedClass().getClassName() + \":\"\n                                + mojoClassVisitor.getMojoAnnotatedClass() );\n                        mojoClassVisitor.getMojoAnnotatedClass().setArtifact( artifact );\n                        mojoAnnotatedClasses.put( mojoClassVisitor.getMojoAnnotatedClass().getClassName(),\n                                                  mojoClassVisitor.getMojoAnnotatedClass() );\n                    }\n\n                }\n            }\n            finally\n            {\n                IOUtil.close( is );\n            }\n\n        }\n        return mojoAnnotatedClasses;\n    }\n\n    private MojoAnnotatedClass isStoreClass( MojoAnnotatedClass mojoAnnotatedClass )\n    {\n        // see MPLUGIN-206 we can have intermediate classes without annotations\n        if ( mojoAnnotatedClass == null )\n        {\n            return null;\n        }\n        return mojoAnnotatedClass;\n        /**\n         if ( !mojoAnnotatedClass.getComponents().isEmpty() || !mojoAnnotatedClass.getParameters().isEmpty()\n         || mojoAnnotatedClass.getExecute() != null || mojoAnnotatedClass.getMojo() != null )\n         {\n         return mojoAnnotatedClass;\n         }\n         return null;\n         **/\n    }\n\n\n    protected void analyzeVisitors( MojoClassVisitor mojoClassVisitor )\n        throws ExtractionException\n    {\n\n        try\n        {\n            MojoAnnotationVisitor mojoAnnotationVisitor =\n                mojoClassVisitor.getAnnotationVisitorMap().get( Mojo.class.getName() );\n            if ( mojoAnnotationVisitor != null )\n            {\n                MojoAnnotationContent mojoAnnotationContent = new MojoAnnotationContent();\n                for ( Map.Entry<String, Object> entry : mojoAnnotationVisitor.getAnnotationValues().entrySet() )\n                {\n                    reflector.invoke( mojoAnnotationContent, entry.getKey(), new Object[]{ entry.getValue() } );\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().setMojo( mojoAnnotationContent );\n            }\n\n            mojoAnnotationVisitor = mojoClassVisitor.getAnnotationVisitorMap().get( Execute.class.getName() );\n            if ( mojoAnnotationVisitor != null )\n            {\n                ExecuteAnnotationContent executeAnnotationContent = new ExecuteAnnotationContent();\n\n                for ( Map.Entry<String, Object> entry : mojoAnnotationVisitor.getAnnotationValues().entrySet() )\n                {\n                    reflector.invoke( executeAnnotationContent, entry.getKey(), new Object[]{ entry.getValue() } );\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().setExecute( executeAnnotationContent );\n            }\n\n            List<MojoFieldVisitor> mojoFieldVisitors =\n                mojoClassVisitor.findFieldWithAnnotationClass( Parameter.class.getName() );\n\n            for ( MojoFieldVisitor mojoFieldVisitor : mojoFieldVisitors )\n            {\n                ParameterAnnotationContent parameterAnnotationContent =\n                    new ParameterAnnotationContent( mojoFieldVisitor.getFieldName(), mojoFieldVisitor.getClassName() );\n                if ( mojoFieldVisitor.getMojoAnnotationVisitor() != null )\n                {\n                    for ( Map.Entry<String, Object> entry : mojoFieldVisitor.getMojoAnnotationVisitor().getAnnotationValues().entrySet() )\n                    {\n                        reflector.invoke( parameterAnnotationContent, entry.getKey(),\n                                          new Object[]{ entry.getValue() } );\n                    }\n\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().getParameters().put( parameterAnnotationContent.getFieldName(),\n                                                                              parameterAnnotationContent );\n            }\n\n            mojoFieldVisitors = mojoClassVisitor.findFieldWithAnnotationClass( Component.class.getName() );\n\n            for ( MojoFieldVisitor mojoFieldVisitor : mojoFieldVisitors )\n            {\n                ComponentAnnotationContent componentAnnotationContent =\n                    new ComponentAnnotationContent( mojoFieldVisitor.getFieldName() );\n\n                if ( mojoFieldVisitor.getMojoAnnotationVisitor() != null )\n                {\n                    for ( Map.Entry<String, Object> entry : mojoFieldVisitor.getMojoAnnotationVisitor().getAnnotationValues().entrySet() )\n                    {\n                        String methodName = entry.getKey();\n                        if ( StringUtils.equals( \"role\", methodName ) )\n                        {\n                            Type type = (Type) entry.getValue();\n                            componentAnnotationContent.setRoleClassName( type.getClassName() );\n                        }\n                        else\n                        {\n                            reflector.invoke( componentAnnotationContent, entry.getKey(),\n                                              new Object[]{ entry.getValue() } );\n                        }\n                    }\n                    if ( StringUtils.isEmpty( componentAnnotationContent.getRoleClassName() ) )\n                    {\n                        componentAnnotationContent.setRoleClassName( mojoFieldVisitor.getClassName() );\n                    }\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().getComponents().put( componentAnnotationContent.getFieldName(),\n                                                                              componentAnnotationContent );\n            }\n\n        }\n        catch ( Exception e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n}\n","lineNo":209}
{"Refactored Sample":"package org.apache.maven.tools.plugin.annotations;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport com.thoughtworks.qdox.JavaDocBuilder;\nimport com.thoughtworks.qdox.model.DocletTag;\nimport com.thoughtworks.qdox.model.JavaClass;\nimport com.thoughtworks.qdox.model.JavaField;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.plugin.descriptor.DuplicateParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ComponentAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ExecuteAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.MojoAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ParameterAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotatedClass;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScanner;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScannerRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.archiver.UnArchiver;\nimport org.codehaus.plexus.archiver.manager.ArchiverManager;\nimport org.codehaus.plexus.archiver.manager.NoSuchArchiverException;\nimport org.codehaus.plexus.component.annotations.Component;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * JavaMojoDescriptorExtractor, a MojoDescriptor extractor to read descriptors from java classes with annotations.\n *\n * @author Olivier Lamy\n * @since 3.0\n */\n@Component( role = MojoDescriptorExtractor.class, hint = \"java-annotations\" )\npublic class JavaAnnotationsMojoDescriptorExtractor\n    extends AbstractLogEnabled\n    implements MojoDescriptorExtractor\n{\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private MojoAnnotationsScanner mojoAnnotationsScanner;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArtifactResolver artifactResolver;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArtifactFactory artifactFactory;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArchiverManager archiverManager;\n\n    public List<MojoDescriptor> execute( MavenProject project, PluginDescriptor pluginDescriptor )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        return execute( new DefaultPluginToolsRequest( project, pluginDescriptor ) );\n    }\n\n    public List<MojoDescriptor> execute( PluginToolsRequest request )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = scanAnnotations( request );\n\n        Map<String, JavaClass> javaClassesMap = scanJavadoc( request, mojoAnnotatedClasses.values() );\n\n        populateDataFromJavadoc( mojoAnnotatedClasses, javaClassesMap );\n\n        return toMojoDescriptors( mojoAnnotatedClasses, request.getPluginDescriptor() );\n    }\n\n    private Map<String, MojoAnnotatedClass> scanAnnotations( PluginToolsRequest request )\n        throws ExtractionException\n    {\n        MojoAnnotationsScannerRequest mojoAnnotationsScannerRequest = new MojoAnnotationsScannerRequest();\n\n        File output = new File( request.getProject().getBuild().getOutputDirectory() );\n        mojoAnnotationsScannerRequest.setClassesDirectories( Arrays.asList( output ) );\n\n        mojoAnnotationsScannerRequest.setDependencies( request.getDependencies() );\n\n        mojoAnnotationsScannerRequest.setProject( request.getProject() );\n\n        return mojoAnnotationsScanner.scan( mojoAnnotationsScannerRequest );\n    }\n\n    private Map<String, JavaClass> scanJavadoc( PluginToolsRequest request,\n                                                Collection<MojoAnnotatedClass> mojoAnnotatedClasses )\n        throws ExtractionException\n    {\n        // found artifact from reactors to scan sources\n        // we currently only scan sources from reactors\n        List<MavenProject> mavenProjects = new ArrayList<MavenProject>();\n\n        // if we need to scan sources from external artifacts\n        Set<Artifact> externalArtifacts = new HashSet<Artifact>();\n\n        for ( MojoAnnotatedClass mojoAnnotatedClass : mojoAnnotatedClasses )\n        {\n            if ( StringUtils.equals( mojoAnnotatedClass.getArtifact().getArtifactId(),\n                                     request.getProject().getArtifact().getArtifactId() ) )\n            {\n                continue;\n            }\n\n            if ( !isMojoAnnnotatedClassCandidate( mojoAnnotatedClass ) )\n            {\n                // we don't scan sources for classes without mojo annotations\n                continue;\n            }\n\n            MavenProject mavenProject =\n                getFromProjectReferences( mojoAnnotatedClass.getArtifact(), request.getProject() );\n\n            if ( mavenProject != null )\n            {\n                mavenProjects.add( mavenProject );\n            }\n            else\n            {\n                externalArtifacts.add( mojoAnnotatedClass.getArtifact() );\n            }\n        }\n\n        Map<String, JavaClass> javaClassesMap = new HashMap<String, JavaClass>();\n\n        // try to get artifact with sources classifier, extract somewhere then scan for @since, @deprecated\n        for ( Artifact artifact : externalArtifacts )\n        {\n            // parameter for test-sources too ?? olamy I need that for it test only\n            if ( StringUtils.equalsIgnoreCase( \"tests\", artifact.getClassifier() ) )\n            {\n                javaClassesMap.putAll( discoverClassesFromSourcesJar( artifact, request, \"test-sources\" ) );\n            }\n            else\n            {\n                javaClassesMap.putAll( discoverClassesFromSourcesJar( artifact, request, \"sources\" ) );\n            }\n\n        }\n\n        for ( MavenProject mavenProject : mavenProjects )\n        {\n            javaClassesMap.putAll( discoverClasses( request.getEncoding(), mavenProject ) );\n        }\n\n        javaClassesMap.putAll( discoverClasses( request ) );\n\n        return javaClassesMap;\n    }\n\n    private boolean isMojoAnnnotatedClassCandidate( MojoAnnotatedClass mojoAnnotatedClass )\n    {\n        if ( mojoAnnotatedClass == null )\n        {\n            return false;\n        }\n        return ( !mojoAnnotatedClass.getComponents().isEmpty() || !mojoAnnotatedClass.getParameters().isEmpty()\n            || mojoAnnotatedClass.getExecute() != null || mojoAnnotatedClass.getMojo() != null );\n\n    }\n\n    protected Map<String, JavaClass> discoverClassesFromSourcesJar( Artifact artifact, PluginToolsRequest request,\n                                                                    String classifier )\n        throws ExtractionException\n    {\n        try\n        {\n            Artifact sourcesArtifact =\n                artifactFactory.createArtifactWithClassifier( artifact.getGroupId(), artifact.getArtifactId(),\n                                                              artifact.getVersion(), artifact.getType(), classifier );\n\n            artifactResolver.resolve( sourcesArtifact, request.getRemoteRepos(), request.getLocal() );\n\n            if ( sourcesArtifact.getFile() == null || !sourcesArtifact.getFile().exists() )\n            {\n                // could not get artifact sources\n                return Collections.emptyMap();\n            }\n\n            // extract sources to target/maven-plugin-plugin-sources/${groupId}/${artifact}/sources\n            File extractDirectory = new File( request.getProject().getBuild().getDirectory(),\n                                              \"maven-plugin-plugin-sources/\" + sourcesArtifact.getGroupId() + \"/\"\n                                                  + sourcesArtifact.getArtifactId() + \"/\" + sourcesArtifact.getVersion()\n                                                  + \"/\" + sourcesArtifact.getClassifier() );\n            extractDirectory.mkdirs();\n\n            UnArchiver unArchiver = archiverManager.getUnArchiver( \"jar\" );\n            unArchiver.setSourceFile( sourcesArtifact.getFile() );\n            unArchiver.setDestDirectory( extractDirectory );\n            unArchiver.extract();\n\n            return discoverClasses( request.getEncoding(), Arrays.asList( extractDirectory ) );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            //throw new ExtractionException( e.getMessage(), e );\n            getLogger().debug( \"skip ArtifactNotFoundException:\" + e.getMessage() );\n            getLogger().warn(\n                \"Unable to get sources artifact for \" + artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\"\n                    + artifact.getVersion() + \". Some javadoc tags (@since, @deprecated and comments) won't be used\" );\n            return Collections.emptyMap();\n        }\n        catch ( NoSuchArchiverException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n\n    /**\n     * from sources scan to get @since and @deprecated and description of classes and fields.\n     *\n     * @param mojoAnnotatedClasses\n     * @param javaClassesMap\n     */\n    protected void populateDataFromJavadoc( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                            Map<String, JavaClass> javaClassesMap )\n    {\n\n        for ( Map.Entry<String, MojoAnnotatedClass> entry : mojoAnnotatedClasses.entrySet() )\n        {\n            JavaClass javaClass = javaClassesMap.get( entry.getKey() );\n            if ( javaClass == null )\n            {\n                continue;\n            }\n\n            // populate class-level content\n            MojoAnnotationContent mojoAnnotationContent = entry.getValue().getMojo();\n            if ( mojoAnnotationContent != null )\n            {\n                mojoAnnotationContent.setDescription( javaClass.getComment() );\n\n                DocletTag since = findInClassHierarchy( javaClass, \"since\" );\n                if ( since != null )\n                {\n                    mojoAnnotationContent.setSince( since.getValue() );\n                }\n\n                DocletTag deprecated = findInClassHierarchy( javaClass, \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    mojoAnnotationContent.setDeprecated( deprecated.getValue() );\n                }\n            }\n\n            Map<String, JavaField> fieldsMap = extractFieldParameterTags( javaClass, javaClassesMap );\n\n            // populate parameters\n            Map<String, ParameterAnnotationContent> parameters =\n                getParametersParentHierarchy( entry.getValue(), new HashMap<String, ParameterAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n            for ( Map.Entry<String, ParameterAnnotationContent> parameter : new TreeMap<String, ParameterAnnotationContent>(\n                parameters ).entrySet() )\n            {\n                JavaField javaField = fieldsMap.get( parameter.getKey() );\n                if ( javaField == null )\n                {\n                    continue;\n                }\n\n                ParameterAnnotationContent parameterAnnotationContent = parameter.getValue();\n                parameterAnnotationContent.setDescription( javaField.getComment() );\n\n                DocletTag deprecated = javaField.getTagByName( \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    parameterAnnotationContent.setDeprecated( deprecated.getValue() );\n                }\n\n                DocletTag since = javaField.getTagByName( \"since\" );\n                if ( since != null )\n                {\n                    parameterAnnotationContent.setSince( since.getValue() );\n                }\n            }\n\n            // populate components\n            for ( Map.Entry<String, ComponentAnnotationContent> component : entry.getValue().getComponents().entrySet() )\n            {\n                JavaField javaField = fieldsMap.get( component.getKey() );\n                if ( javaField == null )\n                {\n                    continue;\n                }\n\n                ComponentAnnotationContent componentAnnotationContent = component.getValue();\n                componentAnnotationContent.setDescription( javaField.getComment() );\n\n                DocletTag deprecated = javaField.getTagByName( \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    componentAnnotationContent.setDeprecated( deprecated.getValue() );\n                }\n\n                DocletTag since = javaField.getTagByName( \"since\" );\n                if ( since != null )\n                {\n                    componentAnnotationContent.setSince( since.getValue() );\n                }\n            }\n\n        }\n\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName   not null\n     * @return docletTag instance\n     */\n    private DocletTag findInClassHierarchy( JavaClass javaClass, String tagName )\n    {\n        DocletTag tag = javaClass.getTagByName( tagName );\n\n        if ( tag == null )\n        {\n            JavaClass superClass = javaClass.getSuperJavaClass();\n\n            if ( superClass != null )\n            {\n                tag = findInClassHierarchy( superClass, tagName );\n            }\n        }\n\n        return tag;\n    }\n\n    /**\n     * extract fields that are either parameters or components.\n     *\n     * @param javaClass not null\n     * @return map with Mojo parameters names as keys\n     */\n    private Map<String, JavaField> extractFieldParameterTags( JavaClass javaClass,\n                                                              Map<String, JavaClass> javaClassesMap )\n    {\n        Map<String, JavaField> rawParams = new TreeMap<String, com.thoughtworks.qdox.model.JavaField>();\n\n        // we have to add the parent fields first, so that they will be overwritten by the local fields if\n        // that actually happens...\n        JavaClass superClass = javaClass.getSuperJavaClass();\n\n        if ( superClass != null )\n        {\n            if ( superClass.getFields().length > 0 )\n            {\n                rawParams = extractFieldParameterTags( superClass, javaClassesMap );\n            }\n            // maybe sources comes from scan of sources artifact\n            superClass = javaClassesMap.get( superClass.getFullyQualifiedName() );\n            if ( superClass != null )\n            {\n                rawParams = extractFieldParameterTags( superClass, javaClassesMap );\n            }\n        }\n        else\n        {\n\n            rawParams = new TreeMap<String, JavaField>();\n        }\n\n        JavaField[] classFields = javaClass.getFields();\n\n        if ( classFields != null )\n        {\n            for ( JavaField field : classFields )\n            {\n                rawParams.put( field.getName(), field );\n            }\n        }\n        return rawParams;\n    }\n\n    protected Map<String, JavaClass> discoverClasses( final PluginToolsRequest request )\n    {\n        return discoverClasses( request.getEncoding(), request.getProject() );\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    protected Map<String, JavaClass> discoverClasses( final String encoding, final MavenProject project )\n    {\n        List<File> sources = new ArrayList<File>();\n\n        for ( String source : (List<String>) project.getCompileSourceRoots() )\n        {\n            sources.add( new File( source ) );\n        }\n\n        // TODO be more dynamic\n        File generatedPlugin = new File( project.getBasedir(), \"target/generated-sources/plugin\" );\n        if ( !project.getCompileSourceRoots().contains( generatedPlugin.getAbsolutePath() )\n            && generatedPlugin.exists() )\n        {\n            sources.add( generatedPlugin );\n        }\n\n        return discoverClasses( encoding, sources );\n    }\n\n    protected Map<String, JavaClass> discoverClasses( final String encoding, List<File> sourceDirectories )\n    {\n        JavaDocBuilder builder = new JavaDocBuilder();\n        builder.setEncoding( encoding );\n\n        for ( File source : sourceDirectories )\n        {\n            builder.addSourceTree( source );\n        }\n\n        JavaClass[] javaClasses = builder.getClasses();\n\n        if ( javaClasses == null || javaClasses.length < 1 )\n        {\n            return Collections.emptyMap();\n        }\n\n        Map<String, JavaClass> javaClassMap = new HashMap<String, JavaClass>( javaClasses.length );\n\n        for ( JavaClass javaClass : javaClasses )\n        {\n            javaClassMap.put( javaClass.getFullyQualifiedName(), javaClass );\n        }\n\n        return javaClassMap;\n    }\n\n    private List<MojoDescriptor> toMojoDescriptors( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                                    PluginDescriptor pluginDescriptor )\n        throws DuplicateParameterException, InvalidParameterException\n    {\n        List<MojoDescriptor> mojoDescriptors = new ArrayList<MojoDescriptor>( mojoAnnotatedClasses.size() );\n        for ( MojoAnnotatedClass mojoAnnotatedClass : mojoAnnotatedClasses.values() )\n        {\n            // no mojo so skip it\n            if ( mojoAnnotatedClass.getMojo() == null )\n            {\n                continue;\n            }\n\n            ExtendedMojoDescriptor mojoDescriptor = new ExtendedMojoDescriptor();\n\n            //mojoDescriptor.setRole( mojoAnnotatedClass.getClassName() );\n            //mojoDescriptor.setRoleHint( \"default\" );\n            mojoDescriptor.setImplementation( mojoAnnotatedClass.getClassName() );\n            mojoDescriptor.setLanguage( \"java\" );\n\n            MojoAnnotationContent mojo = mojoAnnotatedClass.getMojo();\n\n            mojoDescriptor.setDescription( mojo.getDescription() );\n            mojoDescriptor.setSince( mojo.getSince() );\n            mojo.setDeprecated( mojo.getDeprecated() );\n\n            mojoDescriptor.setProjectRequired( mojo.requiresProject() );\n\n            mojoDescriptor.setRequiresReports( mojo.requiresReports() );\n\n            mojoDescriptor.setComponentConfigurator( mojo.configurator() );\n\n            mojoDescriptor.setInheritedByDefault( mojo.inheritByDefault() );\n\n            String instantiationStrategy = mojo.instantiationStrategy().id();\n            if ( instantiationStrategy == null )\n            {\n                /* Perhaps the original spelling is there. */\n                instantiationStrategy = mojo.instanciationStrategy().id();\n            }\n            mojoDescriptor.setInstantiationStrategy(instantiationStrategy);\n\n            mojoDescriptor.setAggregator( mojo.aggregator() );\n            mojoDescriptor.setDependencyResolutionRequired( mojo.requiresDependencyResolution().id() );\n            mojoDescriptor.setDependencyCollectionRequired( mojo.requiresDependencyCollection().id() );\n\n            mojoDescriptor.setDirectInvocationOnly( mojo.requiresDirectInvocation() );\n            mojoDescriptor.setDeprecated( mojo.getDeprecated() );\n            mojoDescriptor.setThreadSafe( mojo.threadSafe() );\n\n            ExecuteAnnotationContent execute = findExecuteInParentHierarchy( mojoAnnotatedClass, mojoAnnotatedClasses );\n            if ( execute != null )\n            {\n                mojoDescriptor.setExecuteGoal( execute.goal() );\n                mojoDescriptor.setExecuteLifecycle( execute.lifecycle() );\n                if ( execute.phase() != null )\n                {\n                    mojoDescriptor.setExecutePhase( execute.phase().id() );\n                }\n            }\n\n            mojoDescriptor.setExecutionStrategy( mojo.executionStrategy() );\n            // ???\n            //mojoDescriptor.alwaysExecute(mojo.a)\n\n            mojoDescriptor.setGoal( mojo.name() );\n            mojoDescriptor.setOnlineRequired( mojo.requiresOnline() );\n\n            mojoDescriptor.setPhase( mojo.defaultPhase().id() );\n\n            // Parameter annotations\n            Map<String, ParameterAnnotationContent> parameters =\n                getParametersParentHierarchy( mojoAnnotatedClass, new HashMap<String, ParameterAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n\n            for ( ParameterAnnotationContent parameterAnnotationContent : new TreeSet<ParameterAnnotationContent>(\n                parameters.values() ) )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                parameter.setName( parameterAnnotationContent.getFieldName() );\n                parameter.setAlias( parameterAnnotationContent.alias() );\n                parameter.setDefaultValue( parameterAnnotationContent.defaultValue() );\n                parameter.setDeprecated( parameterAnnotationContent.getDeprecated() );\n                parameter.setDescription( parameterAnnotationContent.getDescription() );\n                parameter.setEditable( !parameterAnnotationContent.readonly() );\n                String property = parameterAnnotationContent.property();\n                if ( StringUtils.contains( property, '$' ) || StringUtils.contains( property, '{' )\n                    || StringUtils.contains( property, '}' ) )\n                {\n                    throw new InvalidParameterException(\n                        \"Invalid property for parameter '\" + parameter.getName() + \"', \" + \"forbidden characters ${}: \"\n                            + property, null );\n                }\n                parameter.setExpression( StringUtils.isEmpty( property ) ? \"\" : \"${\" + property + \"}\" );\n                parameter.setType( parameterAnnotationContent.getClassName() );\n                parameter.setSince( parameterAnnotationContent.getSince() );\n                parameter.setRequired( parameterAnnotationContent.required() );\n\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            // Component annotations\n            Map<String, ComponentAnnotationContent> components =\n                getComponentsParentHierarchy( mojoAnnotatedClass, new HashMap<String, ComponentAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n\n            for ( ComponentAnnotationContent componentAnnotationContent : new TreeSet<ComponentAnnotationContent>(\n                components.values() ) )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                parameter.setName( componentAnnotationContent.getFieldName() );\n\n                // recognize Maven-injected objects as components annotations instead of parameters\n                String expression = PluginUtils.MAVEN_COMPONENTS.get( componentAnnotationContent.getRoleClassName() );\n                if ( expression == null )\n                {\n                    // normal component\n                    parameter.setRequirement( new Requirement( componentAnnotationContent.getRoleClassName(),\n                                                               componentAnnotationContent.hint() ) );\n                }\n                else\n                {\n                    // not a component but a Maven object to be transformed into an expression/property\n                    parameter.setDefaultValue( expression );\n                    parameter.setType( componentAnnotationContent.getRoleClassName() );\n                    parameter.setRequired( true );\n                }\n                parameter.setDeprecated( componentAnnotationContent.getDeprecated() );\n                parameter.setSince( componentAnnotationContent.getSince() );\n\n                // same behaviour as JavaMojoDescriptorExtractor\n                //parameter.setRequired( ... );\n                parameter.setEditable( false );\n\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            mojoDescriptor.setPluginDescriptor( pluginDescriptor );\n\n            mojoDescriptors.add( mojoDescriptor );\n        }\n        return mojoDescriptors;\n    }\n\n    protected ExecuteAnnotationContent findExecuteInParentHierarchy( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                     Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n\n        if ( mojoAnnotatedClass.getExecute() != null )\n        {\n            return mojoAnnotatedClass.getExecute();\n        }\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( StringUtils.isEmpty( parentClassName ) )\n        {\n            return null;\n        }\n        MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n        if ( parent == null )\n        {\n            return null;\n        }\n        return findExecuteInParentHierarchy( parent, mojoAnnotatedClasses );\n    }\n\n\n    protected Map<String, ParameterAnnotationContent> getParametersParentHierarchy(\n        MojoAnnotatedClass mojoAnnotatedClass, Map<String, ParameterAnnotationContent> parameters,\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        List<ParameterAnnotationContent> parameterAnnotationContents = new ArrayList<ParameterAnnotationContent>();\n\n        parameterAnnotationContents =\n            getParametersParent( mojoAnnotatedClass, parameterAnnotationContents, mojoAnnotatedClasses );\n\n        // move to parent first to build the Map\n        Collections.reverse( parameterAnnotationContents );\n\n        Map<String, ParameterAnnotationContent> map =\n            new HashMap<String, ParameterAnnotationContent>( parameterAnnotationContents.size() );\n\n        for ( ParameterAnnotationContent parameterAnnotationContent : parameterAnnotationContents )\n        {\n            map.put( parameterAnnotationContent.getFieldName(), parameterAnnotationContent );\n        }\n        return map;\n    }\n\n    protected List<ParameterAnnotationContent> getParametersParent( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                    List<ParameterAnnotationContent> parameterAnnotationContents,\n                                                                    Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        parameterAnnotationContents.addAll( mojoAnnotatedClass.getParameters().values() );\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( parentClassName != null )\n        {\n            MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n            if ( parent != null )\n            {\n                return getParametersParent( parent, parameterAnnotationContents, mojoAnnotatedClasses );\n            }\n        }\n        return parameterAnnotationContents;\n    }\n\n    protected Map<String, ComponentAnnotationContent> getComponentsParentHierarchy(\n        MojoAnnotatedClass mojoAnnotatedClass, Map<String, ComponentAnnotationContent> components,\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        List<ComponentAnnotationContent> componentAnnotationContents = new ArrayList<ComponentAnnotationContent>();\n\n        componentAnnotationContents =\n            getComponentParent( mojoAnnotatedClass, componentAnnotationContents, mojoAnnotatedClasses );\n\n        // move to parent first to build the Map\n        Collections.reverse( componentAnnotationContents );\n\n        Map<String, ComponentAnnotationContent> map =\n            new HashMap<String, ComponentAnnotationContent>( componentAnnotationContents.size() );\n\n        for ( ComponentAnnotationContent componentAnnotationContent : componentAnnotationContents )\n        {\n            map.put( componentAnnotationContent.getFieldName(), componentAnnotationContent );\n        }\n        return map;\n    }\n\n    protected List<ComponentAnnotationContent> getComponentParent( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                   List<ComponentAnnotationContent> componentAnnotationContents,\n                                                                   Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        componentAnnotationContents.addAll( mojoAnnotatedClass.getComponents().values() );\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( parentClassName != null )\n        {\n            MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n            if ( parent != null )\n            {\n                return getComponentParent( parent, componentAnnotationContents, mojoAnnotatedClasses );\n            }\n        }\n        return componentAnnotationContents;\n    }\n\n    protected MavenProject getFromProjectReferences( Artifact artifact, MavenProject project )\n    {\n        if ( project.getProjectReferences() == null || project.getProjectReferences().isEmpty() )\n        {\n            return null;\n        }\n        @SuppressWarnings( \"unchecked\" ) Collection<MavenProject> mavenProjects =\n            project.getProjectReferences().values();\n        for ( MavenProject mavenProject : mavenProjects )\n        {\n            if ( StringUtils.equals( mavenProject.getId(), artifact.getId() ) )\n            {\n                return mavenProject;\n            }\n        }\n        return null;\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.annotations;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport com.thoughtworks.qdox.JavaDocBuilder;\nimport com.thoughtworks.qdox.model.DocletTag;\nimport com.thoughtworks.qdox.model.JavaClass;\nimport com.thoughtworks.qdox.model.JavaField;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.plugin.descriptor.DuplicateParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ComponentAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ExecuteAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.MojoAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ParameterAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotatedClass;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScanner;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScannerRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.archiver.UnArchiver;\nimport org.codehaus.plexus.archiver.manager.ArchiverManager;\nimport org.codehaus.plexus.archiver.manager.NoSuchArchiverException;\nimport org.codehaus.plexus.component.annotations.Component;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * JavaMojoDescriptorExtractor, a MojoDescriptor extractor to read descriptors from java classes with annotations.\n *\n * @author Olivier Lamy\n * @since 3.0\n */\n@Component( role = MojoDescriptorExtractor.class, hint = \"java-annotations\" )\npublic class JavaAnnotationsMojoDescriptorExtractor\n    extends AbstractLogEnabled\n    implements MojoDescriptorExtractor\n{\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private MojoAnnotationsScanner mojoAnnotationsScanner;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArtifactResolver artifactResolver;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArtifactFactory artifactFactory;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArchiverManager archiverManager;\n\n    public List<MojoDescriptor> execute( MavenProject project, PluginDescriptor pluginDescriptor )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        return execute( new DefaultPluginToolsRequest( project, pluginDescriptor ) );\n    }\n\n    public List<MojoDescriptor> execute( PluginToolsRequest request )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = scanAnnotations( request );\n\n        Map<String, JavaClass> javaClassesMap = scanJavadoc( request, mojoAnnotatedClasses.values() );\n\n        populateDataFromJavadoc( mojoAnnotatedClasses, javaClassesMap );\n\n        return toMojoDescriptors( mojoAnnotatedClasses, request.getPluginDescriptor() );\n    }\n\n    private Map<String, MojoAnnotatedClass> scanAnnotations( PluginToolsRequest request )\n        throws ExtractionException\n    {\n        MojoAnnotationsScannerRequest mojoAnnotationsScannerRequest = new MojoAnnotationsScannerRequest();\n\n        File output = new File( request.getProject().getBuild().getOutputDirectory() );\n        mojoAnnotationsScannerRequest.setClassesDirectories( Arrays.asList( output ) );\n\n        mojoAnnotationsScannerRequest.setDependencies( request.getDependencies() );\n\n        mojoAnnotationsScannerRequest.setProject( request.getProject() );\n\n        return mojoAnnotationsScanner.scan( mojoAnnotationsScannerRequest );\n    }\n\n    private Map<String, JavaClass> scanJavadoc( PluginToolsRequest request,\n                                                Collection<MojoAnnotatedClass> mojoAnnotatedClasses )\n        throws ExtractionException\n    {\n        // found artifact from reactors to scan sources\n        // we currently only scan sources from reactors\n        List<MavenProject> mavenProjects = new ArrayList<MavenProject>();\n\n        // if we need to scan sources from external artifacts\n        Set<Artifact> externalArtifacts = new HashSet<Artifact>();\n\n        for ( MojoAnnotatedClass mojoAnnotatedClass : mojoAnnotatedClasses )\n        {\n            if ( StringUtils.equals( mojoAnnotatedClass.getArtifact().getArtifactId(),\n                                     request.getProject().getArtifact().getArtifactId() ) )\n            {\n                continue;\n            }\n\n            if ( !isMojoAnnnotatedClassCandidate( mojoAnnotatedClass ) )\n            {\n                // we don't scan sources for classes without mojo annotations\n                continue;\n            }\n\n            MavenProject mavenProject =\n                getFromProjectReferences( mojoAnnotatedClass.getArtifact(), request.getProject() );\n\n            if ( mavenProject != null )\n            {\n                mavenProjects.add( mavenProject );\n            }\n            else\n            {\n                externalArtifacts.add( mojoAnnotatedClass.getArtifact() );\n            }\n        }\n\n        Map<String, JavaClass> javaClassesMap = new HashMap<String, JavaClass>();\n\n        // try to get artifact with sources classifier, extract somewhere then scan for @since, @deprecated\n        for ( Artifact artifact : externalArtifacts )\n        {\n            // parameter for test-sources too ?? olamy I need that for it test only\n            if ( StringUtils.equalsIgnoreCase( \"tests\", artifact.getClassifier() ) )\n            {\n                javaClassesMap.putAll( discoverClassesFromSourcesJar( artifact, request, \"test-sources\" ) );\n            }\n            else\n            {\n                javaClassesMap.putAll( discoverClassesFromSourcesJar( artifact, request, \"sources\" ) );\n            }\n\n        }\n\n        for ( MavenProject mavenProject : mavenProjects )\n        {\n            javaClassesMap.putAll( discoverClasses( request.getEncoding(), mavenProject ) );\n        }\n\n        javaClassesMap.putAll( discoverClasses( request ) );\n\n        return javaClassesMap;\n    }\n\n    private boolean isMojoAnnnotatedClassCandidate( MojoAnnotatedClass mojoAnnotatedClass )\n    {\n        if ( mojoAnnotatedClass == null )\n        {\n            return false;\n        }\n        return ( !mojoAnnotatedClass.getComponents().isEmpty() || !mojoAnnotatedClass.getParameters().isEmpty()\n            || mojoAnnotatedClass.getExecute() != null || mojoAnnotatedClass.getMojo() != null );\n\n    }\n\n    protected Map<String, JavaClass> discoverClassesFromSourcesJar( Artifact artifact, PluginToolsRequest request,\n                                                                    String classifier )\n        throws ExtractionException\n    {\n        try\n        {\n            Artifact sourcesArtifact =\n                artifactFactory.createArtifactWithClassifier( artifact.getGroupId(), artifact.getArtifactId(),\n                                                              artifact.getVersion(), artifact.getType(), classifier );\n\n            artifactResolver.resolve( sourcesArtifact, request.getRemoteRepos(), request.getLocal() );\n\n            if ( sourcesArtifact.getFile() == null || !sourcesArtifact.getFile().exists() )\n            {\n                // could not get artifact sources\n                return Collections.emptyMap();\n            }\n\n            // extract sources to target/maven-plugin-plugin-sources/${groupId}/${artifact}/sources\n            File extractDirectory = new File( request.getProject().getBuild().getDirectory(),\n                                              \"maven-plugin-plugin-sources/\" + sourcesArtifact.getGroupId() + \"/\"\n                                                  + sourcesArtifact.getArtifactId() + \"/\" + sourcesArtifact.getVersion()\n                                                  + \"/\" + sourcesArtifact.getClassifier() );\n            extractDirectory.mkdirs();\n\n            UnArchiver unArchiver = archiverManager.getUnArchiver( \"jar\" );\n            unArchiver.setSourceFile( sourcesArtifact.getFile() );\n            unArchiver.setDestDirectory( extractDirectory );\n            unArchiver.extract();\n\n            return discoverClasses( request.getEncoding(), Arrays.asList( extractDirectory ) );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            //throw new ExtractionException( e.getMessage(), e );\n            getLogger().debug( \"skip ArtifactNotFoundException:\" + e.getMessage() );\n            getLogger().warn(\n                \"Unable to get sources artifact for \" + artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\"\n                    + artifact.getVersion() + \". Some javadoc tags (@since, @deprecated and comments) won't be used\" );\n            return Collections.emptyMap();\n        }\n        catch ( NoSuchArchiverException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n\n    /**\n     * from sources scan to get @since and @deprecated and description of classes and fields.\n     *\n     * @param mojoAnnotatedClasses\n     * @param javaClassesMap\n     */\n    protected void populateDataFromJavadoc( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                            Map<String, JavaClass> javaClassesMap )\n    {\n\n        for ( Map.Entry<String, MojoAnnotatedClass> entry : mojoAnnotatedClasses.entrySet() )\n        {\n            JavaClass javaClass = javaClassesMap.get( entry.getKey() );\n            if ( javaClass == null )\n            {\n                continue;\n            }\n\n            // populate class-level content\n            MojoAnnotationContent mojoAnnotationContent = entry.getValue().getMojo();\n            if ( mojoAnnotationContent != null )\n            {\n                mojoAnnotationContent.setDescription( javaClass.getComment() );\n\n                DocletTag since = findInClassHierarchy( javaClass, \"since\" );\n                if ( since != null )\n                {\n                    mojoAnnotationContent.setSince( since.getValue() );\n                }\n\n                DocletTag deprecated = findInClassHierarchy( javaClass, \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    mojoAnnotationContent.setDeprecated( deprecated.getValue() );\n                }\n            }\n\n            Map<String, JavaField> fieldsMap = extractFieldParameterTags( javaClass, javaClassesMap );\n\n            // populate parameters\n            Map<String, ParameterAnnotationContent> parameters =\n                getParametersParentHierarchy( entry.getValue(), new HashMap<String, ParameterAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n            for ( Map.Entry<String, ParameterAnnotationContent> parameter : new TreeMap<String, ParameterAnnotationContent>(\n                parameters ).entrySet() )\n            {\n                JavaField javaField = fieldsMap.get( parameter.getKey() );\n                if ( javaField == null )\n                {\n                    continue;\n                }\n\n                ParameterAnnotationContent parameterAnnotationContent = parameter.getValue();\n                parameterAnnotationContent.setDescription( javaField.getComment() );\n\n                DocletTag deprecated = javaField.getTagByName( \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    parameterAnnotationContent.setDeprecated( deprecated.getValue() );\n                }\n\n                DocletTag since = javaField.getTagByName( \"since\" );\n                if ( since != null )\n                {\n                    parameterAnnotationContent.setSince( since.getValue() );\n                }\n            }\n\n            // populate components\n            for ( Map.Entry<String, ComponentAnnotationContent> component : entry.getValue().getComponents().entrySet() )\n            {\n                JavaField javaField = fieldsMap.get( component.getKey() );\n                if ( javaField == null )\n                {\n                    continue;\n                }\n\n                ComponentAnnotationContent componentAnnotationContent = component.getValue();\n                componentAnnotationContent.setDescription( javaField.getComment() );\n\n                DocletTag deprecated = javaField.getTagByName( \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    componentAnnotationContent.setDeprecated( deprecated.getValue() );\n                }\n\n                DocletTag since = javaField.getTagByName( \"since\" );\n                if ( since != null )\n                {\n                    componentAnnotationContent.setSince( since.getValue() );\n                }\n            }\n\n        }\n\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName   not null\n     * @return docletTag instance\n     */\n    private DocletTag findInClassHierarchy( JavaClass javaClass, String tagName )\n    {\n        DocletTag tag = javaClass.getTagByName( tagName );\n\n        if ( tag == null )\n        {\n            JavaClass superClass = javaClass.getSuperJavaClass();\n\n            if ( superClass != null )\n            {\n                tag = findInClassHierarchy( superClass, tagName );\n            }\n        }\n\n        return tag;\n    }\n\n    /**\n     * extract fields that are either parameters or components.\n     *\n     * @param javaClass not null\n     * @return map with Mojo parameters names as keys\n     */\n    private Map<String, JavaField> extractFieldParameterTags( JavaClass javaClass,\n                                                              Map<String, JavaClass> javaClassesMap )\n    {\n        Map<String, JavaField> rawParams = new TreeMap<String, com.thoughtworks.qdox.model.JavaField>();\n\n        // we have to add the parent fields first, so that they will be overwritten by the local fields if\n        // that actually happens...\n        JavaClass superClass = javaClass.getSuperJavaClass();\n\n        if ( superClass != null )\n        {\n            if ( superClass.getFields().length > 0 )\n            {\n                rawParams = extractFieldParameterTags( superClass, javaClassesMap );\n            }\n            // maybe sources comes from scan of sources artifact\n            superClass = javaClassesMap.get( superClass.getFullyQualifiedName() );\n            if ( superClass != null )\n            {\n                rawParams = extractFieldParameterTags( superClass, javaClassesMap );\n            }\n        }\n        else\n        {\n\n            rawParams = new TreeMap<String, JavaField>();\n        }\n\n        JavaField[] classFields = javaClass.getFields();\n\n        if ( classFields != null )\n        {\n            for ( JavaField field : classFields )\n            {\n                rawParams.put( field.getName(), field );\n            }\n        }\n        return rawParams;\n    }\n\n    protected Map<String, JavaClass> discoverClasses( final PluginToolsRequest request )\n    {\n        return discoverClasses( request.getEncoding(), request.getProject() );\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    protected Map<String, JavaClass> discoverClasses( final String encoding, final MavenProject project )\n    {\n        List<File> sources = new ArrayList<File>();\n\n        for ( String source : (List<String>) project.getCompileSourceRoots() )\n        {\n            sources.add( new File( source ) );\n        }\n\n        // TODO be more dynamic\n        File generatedPlugin = new File( project.getBasedir(), \"target/generated-sources/plugin\" );\n        if ( !project.getCompileSourceRoots().contains( generatedPlugin.getAbsolutePath() )\n            && generatedPlugin.exists() )\n        {\n            sources.add( generatedPlugin );\n        }\n\n        return discoverClasses( encoding, sources );\n    }\n\n    protected Map<String, JavaClass> discoverClasses( final String encoding, List<File> sourceDirectories )\n    {\n        JavaDocBuilder builder = new JavaDocBuilder();\n        builder.setEncoding( encoding );\n\n        for ( File source : sourceDirectories )\n        {\n            builder.addSourceTree( source );\n        }\n\n        JavaClass[] javaClasses = builder.getClasses();\n\n        if ( javaClasses == null || javaClasses.length < 1 )\n        {\n            return Collections.emptyMap();\n        }\n\n        Map<String, JavaClass> javaClassMap = new HashMap<String, JavaClass>( javaClasses.length );\n\n        for ( JavaClass javaClass : javaClasses )\n        {\n            javaClassMap.put( javaClass.getFullyQualifiedName(), javaClass );\n        }\n\n        return javaClassMap;\n    }\n\n    private List<MojoDescriptor> toMojoDescriptors( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                                    PluginDescriptor pluginDescriptor )\n        throws DuplicateParameterException, InvalidParameterException\n    {\n        List<MojoDescriptor> mojoDescriptors = new ArrayList<MojoDescriptor>( mojoAnnotatedClasses.size() );\n        for ( MojoAnnotatedClass mojoAnnotatedClass : mojoAnnotatedClasses.values() )\n        {\n            // no mojo so skip it\n            if ( mojoAnnotatedClass.getMojo() == null )\n            {\n                continue;\n            }\n\n            ExtendedMojoDescriptor mojoDescriptor = new ExtendedMojoDescriptor();\n\n            //mojoDescriptor.setRole( mojoAnnotatedClass.getClassName() );\n            //mojoDescriptor.setRoleHint( \"default\" );\n            mojoDescriptor.setImplementation( mojoAnnotatedClass.getClassName() );\n            mojoDescriptor.setLanguage( \"java\" );\n\n            MojoAnnotationContent mojo = mojoAnnotatedClass.getMojo();\n\n            mojoDescriptor.setDescription( mojo.getDescription() );\n            mojoDescriptor.setSince( mojo.getSince() );\n            mojo.setDeprecated( mojo.getDeprecated() );\n\n            mojoDescriptor.setProjectRequired( mojo.requiresProject() );\n\n            mojoDescriptor.setRequiresReports( mojo.requiresReports() );\n\n            mojoDescriptor.setComponentConfigurator( mojo.configurator() );\n\n            mojoDescriptor.setInheritedByDefault( mojo.inheritByDefault() );\n\n            mojoDescriptor.setInstantiationStrategy( mojo.instantiationStrategy().id() );\n\n            mojoDescriptor.setAggregator( mojo.aggregator() );\n            mojoDescriptor.setDependencyResolutionRequired( mojo.requiresDependencyResolution().id() );\n            mojoDescriptor.setDependencyCollectionRequired( mojo.requiresDependencyCollection().id() );\n\n            mojoDescriptor.setDirectInvocationOnly( mojo.requiresDirectInvocation() );\n            mojoDescriptor.setDeprecated( mojo.getDeprecated() );\n            mojoDescriptor.setThreadSafe( mojo.threadSafe() );\n\n            ExecuteAnnotationContent execute = findExecuteInParentHierarchy( mojoAnnotatedClass, mojoAnnotatedClasses );\n            if ( execute != null )\n            {\n                mojoDescriptor.setExecuteGoal( execute.goal() );\n                mojoDescriptor.setExecuteLifecycle( execute.lifecycle() );\n                if ( execute.phase() != null )\n                {\n                    mojoDescriptor.setExecutePhase( execute.phase().id() );\n                }\n            }\n\n            mojoDescriptor.setExecutionStrategy( mojo.executionStrategy() );\n            // ???\n            //mojoDescriptor.alwaysExecute(mojo.a)\n\n            mojoDescriptor.setGoal( mojo.name() );\n            mojoDescriptor.setOnlineRequired( mojo.requiresOnline() );\n\n            mojoDescriptor.setPhase( mojo.defaultPhase().id() );\n\n            // Parameter annotations\n            Map<String, ParameterAnnotationContent> parameters =\n                getParametersParentHierarchy( mojoAnnotatedClass, new HashMap<String, ParameterAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n\n            for ( ParameterAnnotationContent parameterAnnotationContent : new TreeSet<ParameterAnnotationContent>(\n                parameters.values() ) )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                parameter.setName( parameterAnnotationContent.getFieldName() );\n                parameter.setAlias( parameterAnnotationContent.alias() );\n                parameter.setDefaultValue( parameterAnnotationContent.defaultValue() );\n                parameter.setDeprecated( parameterAnnotationContent.getDeprecated() );\n                parameter.setDescription( parameterAnnotationContent.getDescription() );\n                parameter.setEditable( !parameterAnnotationContent.readonly() );\n                String property = parameterAnnotationContent.property();\n                if ( StringUtils.contains( property, '$' ) || StringUtils.contains( property, '{' )\n                    || StringUtils.contains( property, '}' ) )\n                {\n                    throw new InvalidParameterException(\n                        \"Invalid property for parameter '\" + parameter.getName() + \"', \" + \"forbidden characters ${}: \"\n                            + property, null );\n                }\n                parameter.setExpression( StringUtils.isEmpty( property ) ? \"\" : \"${\" + property + \"}\" );\n                parameter.setType( parameterAnnotationContent.getClassName() );\n                parameter.setSince( parameterAnnotationContent.getSince() );\n                parameter.setRequired( parameterAnnotationContent.required() );\n\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            // Component annotations\n            Map<String, ComponentAnnotationContent> components =\n                getComponentsParentHierarchy( mojoAnnotatedClass, new HashMap<String, ComponentAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n\n            for ( ComponentAnnotationContent componentAnnotationContent : new TreeSet<ComponentAnnotationContent>(\n                components.values() ) )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                parameter.setName( componentAnnotationContent.getFieldName() );\n\n                // recognize Maven-injected objects as components annotations instead of parameters\n                String expression = PluginUtils.MAVEN_COMPONENTS.get( componentAnnotationContent.getRoleClassName() );\n                if ( expression == null )\n                {\n                    // normal component\n                    parameter.setRequirement( new Requirement( componentAnnotationContent.getRoleClassName(),\n                                                               componentAnnotationContent.hint() ) );\n                }\n                else\n                {\n                    // not a component but a Maven object to be transformed into an expression/property\n                    parameter.setDefaultValue( expression );\n                    parameter.setType( componentAnnotationContent.getRoleClassName() );\n                    parameter.setRequired( true );\n                }\n                parameter.setDeprecated( componentAnnotationContent.getDeprecated() );\n                parameter.setSince( componentAnnotationContent.getSince() );\n\n                // same behaviour as JavaMojoDescriptorExtractor\n                //parameter.setRequired( ... );\n                parameter.setEditable( false );\n\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            mojoDescriptor.setPluginDescriptor( pluginDescriptor );\n\n            mojoDescriptors.add( mojoDescriptor );\n        }\n        return mojoDescriptors;\n    }\n\n    protected ExecuteAnnotationContent findExecuteInParentHierarchy( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                     Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n\n        if ( mojoAnnotatedClass.getExecute() != null )\n        {\n            return mojoAnnotatedClass.getExecute();\n        }\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( StringUtils.isEmpty( parentClassName ) )\n        {\n            return null;\n        }\n        MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n        if ( parent == null )\n        {\n            return null;\n        }\n        return findExecuteInParentHierarchy( parent, mojoAnnotatedClasses );\n    }\n\n\n    protected Map<String, ParameterAnnotationContent> getParametersParentHierarchy(\n        MojoAnnotatedClass mojoAnnotatedClass, Map<String, ParameterAnnotationContent> parameters,\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        List<ParameterAnnotationContent> parameterAnnotationContents = new ArrayList<ParameterAnnotationContent>();\n\n        parameterAnnotationContents =\n            getParametersParent( mojoAnnotatedClass, parameterAnnotationContents, mojoAnnotatedClasses );\n\n        // move to parent first to build the Map\n        Collections.reverse( parameterAnnotationContents );\n\n        Map<String, ParameterAnnotationContent> map =\n            new HashMap<String, ParameterAnnotationContent>( parameterAnnotationContents.size() );\n\n        for ( ParameterAnnotationContent parameterAnnotationContent : parameterAnnotationContents )\n        {\n            map.put( parameterAnnotationContent.getFieldName(), parameterAnnotationContent );\n        }\n        return map;\n    }\n\n    protected List<ParameterAnnotationContent> getParametersParent( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                    List<ParameterAnnotationContent> parameterAnnotationContents,\n                                                                    Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        parameterAnnotationContents.addAll( mojoAnnotatedClass.getParameters().values() );\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( parentClassName != null )\n        {\n            MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n            if ( parent != null )\n            {\n                return getParametersParent( parent, parameterAnnotationContents, mojoAnnotatedClasses );\n            }\n        }\n        return parameterAnnotationContents;\n    }\n\n    protected Map<String, ComponentAnnotationContent> getComponentsParentHierarchy(\n        MojoAnnotatedClass mojoAnnotatedClass, Map<String, ComponentAnnotationContent> components,\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        List<ComponentAnnotationContent> componentAnnotationContents = new ArrayList<ComponentAnnotationContent>();\n\n        componentAnnotationContents =\n            getComponentParent( mojoAnnotatedClass, componentAnnotationContents, mojoAnnotatedClasses );\n\n        // move to parent first to build the Map\n        Collections.reverse( componentAnnotationContents );\n\n        Map<String, ComponentAnnotationContent> map =\n            new HashMap<String, ComponentAnnotationContent>( componentAnnotationContents.size() );\n\n        for ( ComponentAnnotationContent componentAnnotationContent : componentAnnotationContents )\n        {\n            map.put( componentAnnotationContent.getFieldName(), componentAnnotationContent );\n        }\n        return map;\n    }\n\n    protected List<ComponentAnnotationContent> getComponentParent( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                   List<ComponentAnnotationContent> componentAnnotationContents,\n                                                                   Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        componentAnnotationContents.addAll( mojoAnnotatedClass.getComponents().values() );\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( parentClassName != null )\n        {\n            MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n            if ( parent != null )\n            {\n                return getComponentParent( parent, componentAnnotationContents, mojoAnnotatedClasses );\n            }\n        }\n        return componentAnnotationContents;\n    }\n\n    protected MavenProject getFromProjectReferences( Artifact artifact, MavenProject project )\n    {\n        if ( project.getProjectReferences() == null || project.getProjectReferences().isEmpty() )\n        {\n            return null;\n        }\n        @SuppressWarnings( \"unchecked\" ) Collection<MavenProject> mavenProjects =\n            project.getProjectReferences().values();\n        for ( MavenProject mavenProject : mavenProjects )\n        {\n            if ( StringUtils.equals( mavenProject.getId(), artifact.getId() ) )\n            {\n                return mavenProject;\n            }\n        }\n        return null;\n    }\n\n}\n","lineNo":507}
{"Refactored Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.velocity.VelocityContext;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.PropertyUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.velocity.VelocityComponent;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.commons.Remapper;\nimport org.objectweb.asm.commons.RemappingClassAdapter;\nimport org.objectweb.asm.commons.SimpleRemapper;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.StringWriter;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Generates an <code>HelpMojo<\/code> class.\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    /**\n     * Default generated class name\n     */\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    /**\n     * Help properties file, to store data about generated source.\n     */\n    private static final String HELP_PROPERTIES_FILENAME = \"maven-plugin-help.properties\";\n\n    /**\n     * Default goal\n     */\n    private static final String HELP_GOAL = \"help\";\n\n    private String helpPackageName;\n\n    private VelocityComponent velocityComponent;\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws GeneratorException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n\n        String helpImplementation = getImplementation( pluginDescriptor );\n\n        @SuppressWarnings( \"unchecked\" )\n        List<MojoDescriptor> mojoDescriptors = pluginDescriptor.getMojos();\n\n        if ( mojoDescriptors != null )\n        {\n            // Verify that no help goal already exists\n            for ( MojoDescriptor descriptor : mojoDescriptors )\n            {\n                if ( HELP_GOAL.equals( descriptor.getGoal() )\n                    && !descriptor.getImplementation().equals( helpImplementation ) )\n                {\n                    if ( getLogger().isWarnEnabled() )\n                    {\n                        getLogger().warn( \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                              + \") already exists in this plugin. SKIPPED THE \"\n                                              + helpImplementation + \" GENERATION.\\n\" );\n                    }\n\n                    return;\n                }\n            }\n        }\n\n        writeHelpPropertiesFile( request );\n\n        try\n        {\n            String sourcePath = helpImplementation.replace( '.', File.separatorChar ) + \".java\";\n\n            File helpClass = new File( destinationDirectory, sourcePath );\n            helpClass.getParentFile().mkdirs();\n\n            MavenProject mavenProject = request.getProject();\n            String pluginResourcesPath = \"META-INF/maven/\" + mavenProject.getGroupId() + \"/\" + mavenProject.getArtifactId();\n\n            String helpClassSources = getHelpClassSources( pluginResourcesPath, pluginDescriptor );\n\n            FileUtils.fileWrite( helpClass, request.getEncoding(), helpClassSources );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n    }\n\n    public PluginHelpGenerator setHelpPackageName( String helpPackageName )\n    {\n        this.helpPackageName = helpPackageName;\n        return this;\n    }\n\n    public VelocityComponent getVelocityComponent()\n    {\n        return velocityComponent;\n    }\n\n    public PluginHelpGenerator setVelocityComponent( VelocityComponent velocityComponent )\n    {\n        this.velocityComponent = velocityComponent;\n        return this;\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    private String getHelpClassSources( String pluginResourcesPath, PluginDescriptor pluginDescriptor )\n    {\n        Properties properties = new Properties();\n        VelocityContext context = new VelocityContext( properties );\n        if ( this.helpPackageName != null )\n        {\n            properties.put( \"helpPackageName\", this.helpPackageName );\n        }\n        else\n        {\n            properties.put( \"helpPackageName\", \"\" );\n        }\n        properties.put( \"pluginHelpPath\", pluginResourcesPath + \"/plugin-help.xml\" );\n        properties.put( \"artifactId\", pluginDescriptor.getArtifactId() );\n        properties.put( \"goalPrefix\", pluginDescriptor.getGoalPrefix() );\n\n        // FIXME encoding !\n\n        StringWriter stringWriter = new StringWriter();\n\n        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream( \"help-class-source.vm\" );\n        InputStreamReader isReader = new InputStreamReader( is );\n        velocityComponent.getEngine().evaluate( context, stringWriter, \"\", isReader );\n\n        return stringWriter.toString();\n    }\n\n    /**\n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *                         <code>null<\/code>.\n     * @return The implementation.\n     */\n    private String getImplementation( PluginDescriptor pluginDescriptor )\n    {\n        String packageName = helpPackageName;\n        if ( StringUtils.isEmpty( packageName ) )\n        {\n            packageName = GeneratorUtils.discoverPackageName( pluginDescriptor );\n        }\n\n        return StringUtils.isEmpty( packageName ) ? HELP_MOJO_CLASS_NAME : packageName + '.' + HELP_MOJO_CLASS_NAME;\n    }\n\n    /**\n     * Write help properties files for later use to eventually rewrite Help Mojo.\n     *\n     * @param request\n     * @throws GeneratorException\n     * @see {@link #rewriteHelpMojo(PluginToolsRequest)}\n     */\n    private void writeHelpPropertiesFile( PluginToolsRequest request )\n        throws GeneratorException\n    {\n        Properties properties = new Properties();\n        properties.put( \"helpPackageName\", helpPackageName == null ? \"\" : helpPackageName );\n\n        File tmpPropertiesFile =\n            new File( request.getProject().getBuild().getDirectory(), HELP_PROPERTIES_FILENAME );\n\n        if ( tmpPropertiesFile.exists() )\n        {\n            tmpPropertiesFile.delete();\n        }\n        else if ( !tmpPropertiesFile.getParentFile().exists() )\n        {\n            tmpPropertiesFile.getParentFile().mkdirs();\n        }\n\n        FileOutputStream fos = null;\n        try\n        {\n            fos = new FileOutputStream( tmpPropertiesFile );\n            properties.store( fos, \"maven plugin help mojo generation informations\" );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( fos );\n        }\n    }\n\n    /**\n     * Rewrite Help Mojo to match actual Mojos package name if it was not available at source generation\n     * time. This is used at descriptor generation time.\n     *\n     * @param request\n     * @throws GeneratorException\n     */\n    static void rewriteHelpMojo( PluginToolsRequest request )\n        throws GeneratorException\n    {\n        File tmpPropertiesFile =\n            new File( request.getProject().getBuild().getDirectory(), HELP_PROPERTIES_FILENAME );\n\n        if ( !tmpPropertiesFile.exists() )\n        {\n            return;\n        }\n\n        Properties properties = PropertyUtils.loadProperties( tmpPropertiesFile );\n\n        String helpPackageName = properties.getProperty( \"helpPackageName\" );\n\n        // if helpPackageName property is empty, we have to rewrite the class with a better package name than empty\n        if ( StringUtils.isEmpty( helpPackageName ) )\n        {\n            String helpMojoImplementation = rewriteHelpClassToMojoPackage( request );\n\n            if ( helpMojoImplementation != null )\n            {\n                // rewrite plugin descriptor with new HelpMojo implementation class\n                updateHelpMojoDescriptor( request.getPluginDescriptor(), helpMojoImplementation );\n            }\n        }\n    }\n\n    private static String rewriteHelpClassToMojoPackage( PluginToolsRequest request )\n        throws GeneratorException\n    {\n        String destinationPackage = GeneratorUtils.discoverPackageName( request.getPluginDescriptor() );\n        if ( StringUtils.isEmpty( destinationPackage ) )\n        {\n            return null;\n        }\n        String packageAsDirectory = StringUtils.replace( destinationPackage, '.', '/' );\n\n        String outputDirectory = request.getProject().getBuild().getOutputDirectory();\n        File helpClassFile = new File( outputDirectory, HELP_MOJO_CLASS_NAME + \".class\" );\n        if ( !helpClassFile.exists() )\n        {\n            return null;\n        }\n\n        File rewriteHelpClassFile =\n            new File( outputDirectory + '/' + packageAsDirectory, HELP_MOJO_CLASS_NAME + \".class\" );\n        if ( !rewriteHelpClassFile.getParentFile().exists() )\n        {\n            rewriteHelpClassFile.getParentFile().mkdirs();\n        }\n\n        FileInputStream fileInputStream = null;\n        ClassReader cr = null;\n        try\n        {\n            fileInputStream = new FileInputStream( helpClassFile );\n            cr = new ClassReader( fileInputStream );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( fileInputStream );\n        }\n\n        ClassWriter cw = new ClassWriter( 0 );\n\n        Remapper packageRemapper =\n            new SimpleRemapper( HELP_MOJO_CLASS_NAME, packageAsDirectory + '/' + HELP_MOJO_CLASS_NAME );\n        ClassVisitor cv = new RemappingClassAdapter( cw, packageRemapper );\n\n        try\n        {\n            cr.accept( cv, ClassReader.EXPAND_FRAMES );\n        }\n        catch ( Throwable e )\n        {\n            throw new GeneratorException( \"ASM issue processing class-file \" + helpClassFile.getPath(), e );\n        }\n\n        byte[] renamedClass = cw.toByteArray();\n        FileOutputStream fos = null;\n        try\n        {\n            fos = new FileOutputStream( rewriteHelpClassFile );\n            fos.write( renamedClass );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( \"Error rewriting help class: \" + e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( fos );\n        }\n\n        helpClassFile.delete();\n\n        return destinationPackage + \".HelpMojo\";\n    }\n\n    private static void updateHelpMojoDescriptor( PluginDescriptor pluginDescriptor, String helpMojoImplementation )\n    {\n        MojoDescriptor mojoDescriptor = pluginDescriptor.getMojo( \"help\" );\n\n        if ( mojoDescriptor != null )\n        {\n            mojoDescriptor.setImplementation( helpMojoImplementation );\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.velocity.VelocityContext;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.velocity.VelocityComponent;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.StringWriter;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Generates an <code>HelpMojo<\/code> class.\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    /**\n     * Default generated class name\n     */\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    /**\n     * Default goal\n     */\n    private static final String HELP_GOAL = \"help\";\n\n    private String helpPackageName;\n\n    private VelocityComponent velocityComponent;\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws GeneratorException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n\n        String helpImplementation = getImplementation( pluginDescriptor );\n\n        @SuppressWarnings( \"unchecked\" )\n        List<MojoDescriptor> mojoDescriptors = pluginDescriptor.getMojos();\n\n        if ( mojoDescriptors != null )\n        {\n            // Verify that no help goal already exists\n            for ( MojoDescriptor descriptor : mojoDescriptors )\n            {\n                if ( HELP_GOAL.equals( descriptor.getGoal() )\n                    && !descriptor.getImplementation().equals( helpImplementation ) )\n                {\n                    if ( getLogger().isWarnEnabled() )\n                    {\n                        getLogger().warn( \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                              + \") already exists in this plugin. SKIPPED THE \"\n                                              + helpImplementation + \" GENERATION.\\n\" );\n                    }\n\n                    return;\n                }\n            }\n        }\n\n        writeHelpPropertiesFile( request );\n\n        try\n        {\n            String sourcePath = helpImplementation.replace( '.', File.separatorChar ) + \".java\";\n\n            File helpClass = new File( destinationDirectory, sourcePath );\n            helpClass.getParentFile().mkdirs();\n\n            MavenProject mavenProject = request.getProject();\n            String pluginResourcesPath = \"META-INF/maven/\" + mavenProject.getGroupId() + \"/\" + mavenProject.getArtifactId();\n\n            String helpClassSources = getHelpClassSources( pluginResourcesPath, pluginDescriptor );\n\n            FileUtils.fileWrite( helpClass, request.getEncoding(), helpClassSources );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n    }\n\n    public PluginHelpGenerator setHelpPackageName( String helpPackageName )\n    {\n        this.helpPackageName = helpPackageName;\n        return this;\n    }\n\n    public VelocityComponent getVelocityComponent()\n    {\n        return velocityComponent;\n    }\n\n    public PluginHelpGenerator setVelocityComponent( VelocityComponent velocityComponent )\n    {\n        this.velocityComponent = velocityComponent;\n        return this;\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    private String getHelpClassSources( String pluginResourcesPath, PluginDescriptor pluginDescriptor )\n    {\n        Properties properties = new Properties();\n        VelocityContext context = new VelocityContext( properties );\n        if ( this.helpPackageName != null )\n        {\n            properties.put( \"helpPackageName\", this.helpPackageName );\n        }\n        else\n        {\n            properties.put( \"helpPackageName\", \"\" );\n        }\n        properties.put( \"pluginHelpPath\", pluginResourcesPath + \"/plugin-help.xml\" );\n        properties.put( \"artifactId\", pluginDescriptor.getArtifactId() );\n        properties.put( \"goalPrefix\", pluginDescriptor.getGoalPrefix() );\n\n        // FIXME encoding !\n\n        StringWriter stringWriter = new StringWriter();\n\n        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream( \"help-class-source.vm\" );\n        InputStreamReader isReader = new InputStreamReader( is );\n        velocityComponent.getEngine().evaluate( context, stringWriter, \"\", isReader );\n\n        return stringWriter.toString();\n    }\n\n    /**\n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *                         <code>null<\/code>.\n     * @return The implementation.\n     */\n    private String getImplementation( PluginDescriptor pluginDescriptor )\n    {\n        String packageName = helpPackageName;\n        if ( StringUtils.isEmpty( packageName ) )\n        {\n            packageName = GeneratorUtils.discoverPackageName( pluginDescriptor );\n        }\n\n        return StringUtils.isEmpty( packageName ) ? HELP_MOJO_CLASS_NAME : packageName + '.' + HELP_MOJO_CLASS_NAME;\n    }\n\n    private void writeHelpPropertiesFile( PluginToolsRequest request )\n        throws GeneratorException\n    {\n        Properties properties = new Properties();\n        properties.put( \"helpPackageName\", helpPackageName == null ? \"\" : helpPackageName );\n\n        File tmpPropertiesFile =\n            new File( request.getProject().getBuild().getDirectory(), \"maven-plugin-help.properties\" );\n\n        if ( tmpPropertiesFile.exists() )\n        {\n            tmpPropertiesFile.delete();\n        }\n        else if ( !tmpPropertiesFile.getParentFile().exists() )\n        {\n            tmpPropertiesFile.getParentFile().mkdirs();\n        }\n\n        FileOutputStream fos = null;\n        try\n        {\n            fos = new FileOutputStream( tmpPropertiesFile );\n            properties.store( fos, \"maven plugin help mojo generation informations\" );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( fos );\n        }\n    }\n}\n","lineNo":299}
{"Refactored Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.velocity.VelocityContext;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.velocity.VelocityComponent;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.StringWriter;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Generates an <code>HelpMojo<\/code> class.\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    /**\n     * Default generated class name\n     */\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    /**\n     * Default goal\n     */\n    private static final String HELP_GOAL = \"help\";\n\n    private String helpPackageName;\n\n    private VelocityComponent velocityComponent;\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws GeneratorException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n\n        String helpImplementation = getImplementation( pluginDescriptor );\n\n        @SuppressWarnings( \"unchecked\" )\n        List<MojoDescriptor> mojoDescriptors = pluginDescriptor.getMojos();\n\n        if ( mojoDescriptors != null )\n        {\n            // Verify that no help goal already exists\n            for ( MojoDescriptor descriptor : mojoDescriptors )\n            {\n                if ( HELP_GOAL.equals( descriptor.getGoal() )\n                    && !descriptor.getImplementation().equals( helpImplementation ) )\n                {\n                    if ( getLogger().isWarnEnabled() )\n                    {\n                        getLogger().warn( \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                              + \") already exists in this plugin. SKIPPED THE \"\n                                              + helpImplementation + \" GENERATION.\\n\" );\n                    }\n\n                    return;\n                }\n            }\n        }\n\n        Properties properties = new Properties();\n        properties.put( \"helpPackageName\", helpPackageName == null ? \"\" : helpPackageName );\n\n        MavenProject mavenProject = request.getProject();\n\n        File tmpPropertiesFile =\n            new File( request.getProject().getBuild().getDirectory(), \"maven-plugin-help.properties\" );\n        if ( tmpPropertiesFile.exists() )\n        {\n            tmpPropertiesFile.delete();\n        }\n        else\n        {\n            if ( !tmpPropertiesFile.getParentFile().exists() )\n            {\n                tmpPropertiesFile.getParentFile().mkdirs();\n            }\n        }\n        FileOutputStream fos = null;\n        try\n        {\n            fos = new FileOutputStream( tmpPropertiesFile );\n            properties.store( fos, \"maven plugin help generation informations\" );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( fos );\n        }\n\n        try\n        {\n            String sourcePath = helpImplementation.replace( '.', File.separatorChar ) + \".java\";\n\n            File helpClass = new File( destinationDirectory, sourcePath );\n            helpClass.getParentFile().mkdirs();\n\n            String pluginResourcesPath = \"META-INF/maven/\" + mavenProject.getGroupId() + \"/\" + mavenProject.getArtifactId();\n\n            String helpClassSources = getHelpClassSources( pluginResourcesPath, pluginDescriptor );\n\n            FileUtils.fileWrite( helpClass, request.getEncoding(), helpClassSources );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n    }\n\n    public PluginHelpGenerator setHelpPackageName( String helpPackageName )\n    {\n        this.helpPackageName = helpPackageName;\n        return this;\n    }\n\n    public VelocityComponent getVelocityComponent()\n    {\n        return velocityComponent;\n    }\n\n    public PluginHelpGenerator setVelocityComponent( VelocityComponent velocityComponent )\n    {\n        this.velocityComponent = velocityComponent;\n        return this;\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    protected String getHelpClassSources( String pluginResourcesPath, PluginDescriptor pluginDescriptor )\n    {\n        Properties properties = new Properties();\n        VelocityContext context = new VelocityContext( properties );\n        if ( this.helpPackageName != null )\n        {\n            properties.put( \"helpPackageName\", this.helpPackageName );\n        }\n        else\n        {\n            properties.put( \"helpPackageName\", \"\" );\n        }\n        properties.put( \"pluginHelpPath\", pluginResourcesPath + \"/plugin-help.xml\" );\n        properties.put( \"artifactId\", pluginDescriptor.getArtifactId() );\n        properties.put( \"goalPrefix\", pluginDescriptor.getGoalPrefix() );\n\n        // FIXME encoding !\n\n        StringWriter stringWriter = new StringWriter();\n\n        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream( \"help-class-source.vm\" );\n        InputStreamReader isReader = new InputStreamReader( is );\n        velocityComponent.getEngine().evaluate( context, stringWriter, \"\", isReader );\n\n        return stringWriter.toString();\n    }\n\n\n    /**\n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *                         <code>null<\/code>.\n     * @return The implementation.\n     */\n    private String getImplementation( PluginDescriptor pluginDescriptor )\n    {\n        String packageName = helpPackageName;\n        if ( StringUtils.isEmpty( packageName ) )\n        {\n            packageName = GeneratorUtils.discoverPackageName( pluginDescriptor );\n        }\n\n        return StringUtils.isEmpty( packageName ) ? HELP_MOJO_CLASS_NAME : packageName + '.' + HELP_MOJO_CLASS_NAME;\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.velocity.VelocityContext;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.velocity.VelocityComponent;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Generates an <code>HelpMojo<\/code> class.\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    /**\n     * Default generated class name\n     */\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    /**\n     * Default goal\n     */\n    private static final String HELP_GOAL = \"help\";\n\n    private String helpPackageName;\n\n    private VelocityComponent velocityComponent;\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws GeneratorException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n\n        String helpImplementation = getImplementation( pluginDescriptor );\n\n        @SuppressWarnings( \"unchecked\" )\n        List<MojoDescriptor> mojoDescriptors = pluginDescriptor.getMojos();\n\n        if ( mojoDescriptors != null )\n        {\n            // Verify that no help goal already exists\n            for ( MojoDescriptor descriptor : mojoDescriptors )\n            {\n                if ( HELP_GOAL.equals( descriptor.getGoal() )\n                    && !descriptor.getImplementation().equals( helpImplementation ) )\n                {\n                    if ( getLogger().isWarnEnabled() )\n                    {\n                        getLogger().warn( \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                              + \") already exists in this plugin. SKIPPED THE \"\n                                              + helpImplementation + \" GENERATION.\\n\" );\n                    }\n\n                    return;\n                }\n            }\n        }\n\n        Properties properties = new Properties();\n        properties.put( \"helpPackageName\", helpPackageName == null ? \"\" : helpPackageName );\n\n        MavenProject mavenProject = request.getProject();\n\n        File tmpPropertiesFile =\n            new File( request.getProject().getBuild().getDirectory(), \"maven-plugin-help.properties\" );\n        if ( tmpPropertiesFile.exists() )\n        {\n            tmpPropertiesFile.delete();\n        }\n        else\n        {\n            if ( !tmpPropertiesFile.getParentFile().exists() )\n            {\n                tmpPropertiesFile.getParentFile().mkdirs();\n            }\n        }\n        FileOutputStream fos = null;\n        try\n        {\n            fos = new FileOutputStream( tmpPropertiesFile );\n            properties.store( fos, \"maven plugin help generation informations\" );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( fos );\n        }\n\n        String sourcePath = helpImplementation.replace( '.', File.separatorChar ) + \".java\";\n        File helpClass = new File( destinationDirectory, sourcePath );\n        helpClass.getParentFile().mkdirs();\n\n        Writer writer = null;\n        try\n        {\n            String pluginResourcesPath = \"META-INF/maven/\" + mavenProject.getGroupId() + \"/\" + mavenProject.getArtifactId();\n\n            writer = new OutputStreamWriter( new FileOutputStream( helpClass ), request.getEncoding() );\n            writer.write( getHelpClassSources( pluginResourcesPath, pluginDescriptor ) );\n            writer.flush();\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    public PluginHelpGenerator setHelpPackageName( String helpPackageName )\n    {\n        this.helpPackageName = helpPackageName;\n        return this;\n    }\n\n    public VelocityComponent getVelocityComponent()\n    {\n        return velocityComponent;\n    }\n\n    public PluginHelpGenerator setVelocityComponent( VelocityComponent velocityComponent )\n    {\n        this.velocityComponent = velocityComponent;\n        return this;\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    protected String getHelpClassSources( String pluginResourcesPath, PluginDescriptor pluginDescriptor )\n    {\n        Properties properties = new Properties();\n        VelocityContext context = new VelocityContext( properties );\n        if ( this.helpPackageName != null )\n        {\n            properties.put( \"helpPackageName\", this.helpPackageName );\n        }\n        else\n        {\n            properties.put( \"helpPackageName\", \"\" );\n        }\n        properties.put( \"pluginHelpPath\", pluginResourcesPath + \"/plugin-help.xml\" );\n        properties.put( \"artifactId\", pluginDescriptor.getArtifactId() );\n        properties.put( \"goalPrefix\", pluginDescriptor.getGoalPrefix() );\n\n        // FIXME encoding !\n\n        StringWriter stringWriter = new StringWriter();\n\n        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream( \"help-class-source.vm\" );\n        InputStreamReader isReader = new InputStreamReader( is );\n        velocityComponent.getEngine().evaluate( context, stringWriter, \"\", isReader );\n\n        return stringWriter.toString();\n    }\n\n\n    /**\n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *                         <code>null<\/code>.\n     * @return The implementation.\n     */\n    private String getImplementation( PluginDescriptor pluginDescriptor )\n    {\n        String packageName = helpPackageName;\n        if ( StringUtils.isEmpty( packageName ) )\n        {\n            packageName = GeneratorUtils.discoverPackageName( pluginDescriptor );\n        }\n\n        return StringUtils.isEmpty( packageName ) ? HELP_MOJO_CLASS_NAME : packageName + '.' + HELP_MOJO_CLASS_NAME;\n    }\n}\n","lineNo":157}
{"Refactored Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.DuplicateMojoDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.PropertyUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.PrettyPrintXMLWriter;\nimport org.codehaus.plexus.util.xml.XMLWriter;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.commons.RemappingClassAdapter;\nimport org.objectweb.asm.commons.SimpleRemapper;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\n/**\n * Generate a <a href=\"/ref/current/maven-plugin-api/plugin.html\">Maven Plugin Descriptor XML file<\/a> and\n * corresponding help content.\n *\n * @version $Id$\n * @todo add example usage tag that can be shown in the doco\n * @todo need to add validation directives so that systems embedding maven2 can\n * get validation directives to help users in IDEs.\n */\npublic class PluginDescriptorGenerator\n    implements Generator\n{\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws GeneratorException\n    {\n\n        File tmpPropertiesFile =\n            new File( request.getProject().getBuild().getDirectory(), \"maven-plugin-help.properties\" );\n\n        if ( tmpPropertiesFile.exists() )\n        {\n            Properties properties = PropertyUtils.loadProperties( tmpPropertiesFile );\n\n            String helpPackageName = properties.getProperty( \"helpPackageName\" );\n\n            // if helpPackageName property is empty we have to rewrite the class with a better package name than empty\n            if ( StringUtils.isEmpty( helpPackageName ) )\n            {\n                String helpMojoImplementation = rewriteHelpClassToMojoPackage( request );\n                if ( helpMojoImplementation != null )\n                {\n                    // rewrite plugin descriptor with new HelpMojo implementation class\n                    rewriteDescriptor( request.getPluginDescriptor(), helpMojoImplementation );\n                }\n\n            }\n        }\n\n        try\n        {\n            // write complete plugin.xml descriptor\n            File f = new File( destinationDirectory, \"plugin.xml\" );\n            writeDescriptor( f, request, false );\n\n            // write plugin-help.xml help-descriptor\n            MavenProject mavenProject = request.getProject();\n            String pluginHelpFilePath =\n                \"META-INF/maven/\" + mavenProject.getGroupId() + \"/\" + mavenProject.getArtifactId() + \"/plugin-help.xml\";\n            f = new File( request.getProject().getBuild().getOutputDirectory(), pluginHelpFilePath );\n            writeDescriptor( f, request, true );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n        catch ( DuplicateMojoDescriptorException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n    }\n\n    private String getVersion()\n    {\n        Package p = this.getClass().getPackage();\n        String version = ( p == null ) ? null : p.getSpecificationVersion();\n        return ( version == null ) ? \"SNAPSHOT\" : version;\n    }\n\n    public void writeDescriptor( File destinationFile, PluginToolsRequest request, boolean helpDescriptor )\n        throws IOException, DuplicateMojoDescriptorException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n\n        if ( destinationFile.exists() )\n        {\n            destinationFile.delete();\n        }\n        else\n        {\n            if ( !destinationFile.getParentFile().exists() )\n            {\n                destinationFile.getParentFile().mkdirs();\n            }\n        }\n\n        String encoding = \"UTF-8\";\n\n        Writer writer = null;\n        try\n        {\n            writer = new OutputStreamWriter( new FileOutputStream( destinationFile ), encoding );\n\n            XMLWriter w = new PrettyPrintXMLWriter( writer, encoding, null );\n\n            w.writeMarkup( \"\\n<!-- Generated by maven-plugin-tools \" + getVersion() + \" on \" + new SimpleDateFormat(\n                \"yyyy-MM-dd\" ).format( new Date() ) + \" -->\\n\\n\" );\n\n            w.startElement( \"plugin\" );\n\n            GeneratorUtils.element( w, \"name\", pluginDescriptor.getName() );\n\n            GeneratorUtils.element( w, \"description\", pluginDescriptor.getDescription(), helpDescriptor );\n\n            GeneratorUtils.element( w, \"groupId\", pluginDescriptor.getGroupId() );\n\n            GeneratorUtils.element( w, \"artifactId\", pluginDescriptor.getArtifactId() );\n\n            GeneratorUtils.element( w, \"version\", pluginDescriptor.getVersion() );\n\n            GeneratorUtils.element( w, \"goalPrefix\", pluginDescriptor.getGoalPrefix() );\n\n            if ( !helpDescriptor )\n            {\n                GeneratorUtils.element( w, \"isolatedRealm\", String.valueOf( pluginDescriptor.isIsolatedRealm() ) );\n\n                GeneratorUtils.element( w, \"inheritedByDefault\",\n                                        String.valueOf( pluginDescriptor.isInheritedByDefault() ) );\n            }\n\n            w.startElement( \"mojos\" );\n\n            if ( pluginDescriptor.getMojos() != null )\n            {\n                @SuppressWarnings( \"unchecked\" ) List<MojoDescriptor> descriptors = pluginDescriptor.getMojos();\n\n                if ( helpDescriptor )\n                {\n                    PluginUtils.sortMojos( descriptors );\n                }\n\n                for ( MojoDescriptor descriptor : descriptors )\n                {\n                    processMojoDescriptor( descriptor, w, helpDescriptor );\n                }\n            }\n\n            w.endElement();\n\n            if ( !helpDescriptor )\n            {\n                GeneratorUtils.writeDependencies( w, pluginDescriptor );\n            }\n\n            w.endElement();\n\n            writer.flush();\n\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        processMojoDescriptor( mojoDescriptor, w, false );\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @param w              not null\n     * @param helpDescriptor will clean html content from description fields\n     */\n    protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, XMLWriter w, boolean helpDescriptor )\n    {\n        w.startElement( \"mojo\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"goal\" );\n        w.writeText( mojoDescriptor.getGoal() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        String description = mojoDescriptor.getDescription();\n\n        if ( description != null )\n        {\n            w.startElement( \"description\" );\n            if ( helpDescriptor )\n            {\n                w.writeText( GeneratorUtils.toText( mojoDescriptor.getDescription() ) );\n            }\n            else\n            {\n                w.writeText( mojoDescriptor.getDescription() );\n            }\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.isDependencyResolutionRequired() ) )\n        {\n            GeneratorUtils.element( w, \"requiresDependencyResolution\",\n                                    mojoDescriptor.isDependencyResolutionRequired() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"requiresDirectInvocation\",\n                                String.valueOf( mojoDescriptor.isDirectInvocationOnly() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"requiresProject\", String.valueOf( mojoDescriptor.isProjectRequired() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"requiresReports\", String.valueOf( mojoDescriptor.isRequiresReports() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"aggregator\", String.valueOf( mojoDescriptor.isAggregator() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"requiresOnline\", String.valueOf( mojoDescriptor.isOnlineRequired() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"inheritedByDefault\", String.valueOf( mojoDescriptor.isInheritedByDefault() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getPhase() ) )\n        {\n            GeneratorUtils.element( w, \"phase\", mojoDescriptor.getPhase() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getExecutePhase() ) )\n        {\n            GeneratorUtils.element( w, \"executePhase\", mojoDescriptor.getExecutePhase() );\n        }\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getExecuteGoal() ) )\n        {\n            GeneratorUtils.element( w, \"executeGoal\", mojoDescriptor.getExecuteGoal() );\n        }\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getExecuteLifecycle() ) )\n        {\n            GeneratorUtils.element( w, \"executeLifecycle\", mojoDescriptor.getExecuteLifecycle() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"implementation\" );\n        w.writeText( mojoDescriptor.getImplementation() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"language\" );\n        w.writeText( mojoDescriptor.getLanguage() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getComponentConfigurator() ) )\n        {\n            w.startElement( \"configurator\" );\n            w.writeText( mojoDescriptor.getComponentConfigurator() );\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getComponentComposer() ) )\n        {\n            w.startElement( \"composer\" );\n            w.writeText( mojoDescriptor.getComponentComposer() );\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"instantiationStrategy\" );\n        w.writeText( mojoDescriptor.getInstantiationStrategy() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Strategy for handling repeated reference to mojo in\n        // the calculated (decorated, resolved) execution stack\n        // ----------------------------------------------------------------------\n        w.startElement( \"executionStrategy\" );\n        w.writeText( mojoDescriptor.getExecutionStrategy() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getSince() != null )\n        {\n            w.startElement( \"since\" );\n\n            if ( StringUtils.isEmpty( mojoDescriptor.getSince() ) )\n            {\n                w.writeText( \"No version given\" );\n            }\n            else\n            {\n                w.writeText( mojoDescriptor.getSince() );\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getDeprecated() != null )\n        {\n            w.startElement( \"deprecated\" );\n\n            if ( StringUtils.isEmpty( mojoDescriptor.getDeprecated() ) )\n            {\n                w.writeText( \"No reason given\" );\n            }\n            else\n            {\n                w.writeText( mojoDescriptor.getDeprecated() );\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Extended (3.0) descriptor\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor instanceof ExtendedMojoDescriptor )\n        {\n            ExtendedMojoDescriptor extendedMojoDescriptor = (ExtendedMojoDescriptor) mojoDescriptor;\n            if ( extendedMojoDescriptor.getDependencyCollectionRequired() != null )\n            {\n                GeneratorUtils.element( w, \"requiresDependencyCollection\",\n                                        extendedMojoDescriptor.getDependencyCollectionRequired() );\n            }\n\n            GeneratorUtils.element( w, \"threadSafe\", String.valueOf( extendedMojoDescriptor.isThreadSafe() ) );\n        }\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        @SuppressWarnings( \"unchecked\" ) List<Parameter> parameters = mojoDescriptor.getParameters();\n\n        w.startElement( \"parameters\" );\n\n        Map<String, Requirement> requirements = new LinkedHashMap<String, Requirement>();\n\n        Set<Parameter> configuration = new LinkedHashSet<Parameter>();\n\n        if ( parameters != null )\n        {\n            if ( helpDescriptor )\n            {\n                PluginUtils.sortMojoParameters( parameters );\n            }\n\n            for ( Parameter parameter : parameters )\n            {\n                String expression = getExpression( parameter );\n\n                if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${component.\" ) )\n                {\n                    // treat it as a component...a requirement, in other words.\n\n                    // remove \"component.\" plus expression delimiters\n                    String role = expression.substring( \"${component.\".length(), expression.length() - 1 );\n\n                    String roleHint = null;\n\n                    int posRoleHintSeparator = role.indexOf( \"#\" );\n                    if ( posRoleHintSeparator > 0 )\n                    {\n                        roleHint = role.substring( posRoleHintSeparator + 1 );\n\n                        role = role.substring( 0, posRoleHintSeparator );\n                    }\n\n                    // TODO: remove deprecated expression\n                    requirements.put( parameter.getName(), new Requirement( role, roleHint ) );\n                }\n                else if ( parameter.getRequirement() != null )\n                {\n                    requirements.put( parameter.getName(), parameter.getRequirement() );\n                }\n                else if ( !helpDescriptor || parameter.isEditable() ) // don't show readonly parameters in help\n                {\n                    // treat it as a normal parameter.\n\n                    w.startElement( \"parameter\" );\n\n                    GeneratorUtils.element( w, \"name\", parameter.getName() );\n\n                    if ( parameter.getAlias() != null )\n                    {\n                        GeneratorUtils.element( w, \"alias\", parameter.getAlias() );\n                    }\n\n                    GeneratorUtils.element( w, \"type\", parameter.getType() );\n\n                    if ( parameter.getSince() != null )\n                    {\n                        w.startElement( \"since\" );\n\n                        if ( StringUtils.isEmpty( parameter.getSince() ) )\n                        {\n                            w.writeText( \"No version given\" );\n                        }\n                        else\n                        {\n                            w.writeText( parameter.getSince() );\n                        }\n\n                        w.endElement();\n                    }\n\n                    if ( parameter.getDeprecated() != null )\n                    {\n                        if ( StringUtils.isEmpty( parameter.getDeprecated() ) )\n                        {\n                            GeneratorUtils.element( w, \"deprecated\", \"No reason given\" );\n                        }\n                        else\n                        {\n                            GeneratorUtils.element( w, \"deprecated\", parameter.getDeprecated() );\n                        }\n                    }\n\n                    if ( parameter.getImplementation() != null )\n                    {\n                        GeneratorUtils.element( w, \"implementation\", parameter.getImplementation() );\n                    }\n\n                    GeneratorUtils.element( w, \"required\", Boolean.toString( parameter.isRequired() ) );\n\n                    GeneratorUtils.element( w, \"editable\", Boolean.toString( parameter.isEditable() ) );\n\n                    GeneratorUtils.element( w, \"description\", parameter.getDescription(), helpDescriptor );\n\n                    if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) || StringUtils.isNotEmpty(\n                        parameter.getExpression() ) )\n                    {\n                        configuration.add( parameter );\n                    }\n\n                    w.endElement();\n                }\n\n            }\n        }\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Configuration\n        // ----------------------------------------------------------------------\n\n        if ( !configuration.isEmpty() )\n        {\n            w.startElement( \"configuration\" );\n\n            for ( Parameter parameter : configuration )\n            {\n                if ( helpDescriptor && !parameter.isEditable() )\n                {\n                    // don't show readonly parameters in help\n                    continue;\n                }\n\n                w.startElement( parameter.getName() );\n\n                String type = parameter.getType();\n                if ( StringUtils.isNotEmpty( type ) )\n                {\n                    w.addAttribute( \"implementation\", type );\n                }\n\n                if ( parameter.getDefaultValue() != null )\n                {\n                    w.addAttribute( \"default-value\", parameter.getDefaultValue() );\n                }\n\n                if ( StringUtils.isNotEmpty( parameter.getExpression() ) )\n                {\n                    w.writeText( parameter.getExpression() );\n                }\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        if ( !requirements.isEmpty() && !helpDescriptor )\n        {\n            w.startElement( \"requirements\" );\n\n            for ( Map.Entry<String, Requirement> entry : requirements.entrySet() )\n            {\n                String key = entry.getKey();\n                Requirement requirement = entry.getValue();\n\n                w.startElement( \"requirement\" );\n\n                GeneratorUtils.element( w, \"role\", requirement.getRole() );\n\n                if ( StringUtils.isNotEmpty( requirement.getRoleHint() ) )\n                {\n                    GeneratorUtils.element( w, \"role-hint\", requirement.getRoleHint() );\n                }\n\n                GeneratorUtils.element( w, \"field-name\", key );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        w.endElement();\n    }\n\n    /**\n     * Get the expression value, eventually surrounding it with <code>${ }<\/code>.\n     *\n     * @param parameter the parameter\n     * @return the expression value\n     */\n    private String getExpression( Parameter parameter )\n    {\n        String expression = parameter.getExpression();\n        if ( StringUtils.isNotBlank( expression ) && !expression.contains( \"${\" ) )\n        {\n            expression = \"${\" + expression.trim() + \"}\";\n            parameter.setExpression( expression );\n        }\n        return expression;\n    }\n\n    protected String rewriteHelpClassToMojoPackage( PluginToolsRequest request )\n        throws GeneratorException\n    {\n        String destinationPackage = GeneratorUtils.discoverPackageName( request.getPluginDescriptor() );\n        if ( StringUtils.isEmpty( destinationPackage ) )\n        {\n            return null;\n        }\n        File helpClassFile = new File( request.getProject().getBuild().getOutputDirectory(), \"HelpMojo.class\" );\n        if ( !helpClassFile.exists() )\n        {\n            return null;\n        }\n        File rewriteHelpClassFile = new File(\n            request.getProject().getBuild().getOutputDirectory() + \"/\" + StringUtils.replace( destinationPackage, \".\",\n                                                                                              \"/\" ), \"HelpMojo.class\" );\n        if ( !rewriteHelpClassFile.getParentFile().exists() )\n        {\n            rewriteHelpClassFile.getParentFile().mkdirs();\n        }\n\n        FileInputStream fileInputStream = null;\n\n        ClassReader cr = null;\n        try\n        {\n            fileInputStream = new FileInputStream( helpClassFile );\n            cr = new ClassReader( fileInputStream );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( fileInputStream );\n        }\n\n        ClassWriter cw = new ClassWriter( 0 );\n\n        ClassVisitor cv = new RemappingClassAdapter( cw, new SimpleRemapper( \"HelpMojo\",\n                                                                             StringUtils.replace( destinationPackage,\n                                                                                                  \".\", \"/\" )\n                                                                                 + \"/HelpMojo\" ) );\n\n        try\n        {\n            cr.accept( cv, ClassReader.EXPAND_FRAMES );\n        }\n        catch ( Throwable e )\n        {\n            throw new GeneratorException( \"ASM issue processing classFile \" + helpClassFile.getPath(), e );\n        }\n\n        byte[] renamedClass = cw.toByteArray();\n        FileOutputStream fos = null;\n        try\n        {\n            fos = new FileOutputStream( rewriteHelpClassFile );\n            fos.write( renamedClass );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( \"Error rewriting help class: \" + e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( fos );\n        }\n        helpClassFile.delete();\n        return destinationPackage + \".HelpMojo\";\n    }\n\n\n    private void rewriteDescriptor( PluginDescriptor pluginDescriptor, String helpMojoImplementation )\n    {\n        MojoDescriptor mojoDescriptor = pluginDescriptor.getMojo( \"help\" );\n        if ( mojoDescriptor != null )\n        {\n            mojoDescriptor.setImplementation( helpMojoImplementation );\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.DuplicateMojoDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.PropertyUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.PrettyPrintXMLWriter;\nimport org.codehaus.plexus.util.xml.XMLWriter;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.commons.RemappingClassAdapter;\nimport org.objectweb.asm.commons.SimpleRemapper;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\n/**\n * Generate a <a href=\"/ref/current/maven-plugin-api/plugin.html\">Maven Plugin Descriptor XML file<\/a> and\n * corresponding help content.\n *\n * @version $Id$\n * @todo add example usage tag that can be shown in the doco\n * @todo need to add validation directives so that systems embedding maven2 can\n * get validation directives to help users in IDEs.\n */\npublic class PluginDescriptorGenerator\n    implements Generator\n{\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws GeneratorException\n    {\n\n        File tmpPropertiesFile =\n            new File( request.getProject().getBuild().getDirectory(), \"maven-plugin-help.properties\" );\n\n        if ( tmpPropertiesFile.exists() )\n        {\n            Properties properties = PropertyUtils.loadProperties( tmpPropertiesFile );\n\n            String helpPackageName = properties.getProperty( \"helpPackageName\" );\n\n            // if helpPackageName property is empty we have to rewrite the class with a better package name than empty\n            if ( StringUtils.isEmpty( helpPackageName ) )\n            {\n                String helpMojoImplementation = rewriteHelpClassToMojoPackage( request );\n                if ( helpMojoImplementation != null )\n                {\n                    // rewrite plugin descriptor with new HelpMojo implementation class\n                    rewriteDescriptor( request.getPluginDescriptor(), helpMojoImplementation );\n                }\n\n            }\n        }\n\n        try\n        {\n            // write complete plugin.xml descriptor\n            File f = new File( destinationDirectory, \"plugin.xml\" );\n            writeDescriptor( f, request, false );\n\n            // write plugin-help.xml help-descriptor\n            MavenProject mavenProject = request.getProject();\n            String pluginHelpFilePath =\n                \"META-INF/maven/\" + mavenProject.getGroupId() + \"/\" + mavenProject.getArtifactId()\n                    + \"/plugin-help.xml\";\n            f = new File( request.getProject().getBuild().getOutputDirectory(), pluginHelpFilePath );\n            writeDescriptor( f, request, true );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n        catch ( DuplicateMojoDescriptorException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n    }\n\n    private String getVersion()\n    {\n        Package p = this.getClass().getPackage();\n        String version = ( p == null ) ? null : p.getSpecificationVersion();\n        return ( version == null ) ? \"SNAPSHOT\" : version;\n    }\n\n    public void writeDescriptor( File destinationFile, PluginToolsRequest request, boolean helpDescriptor )\n        throws IOException, DuplicateMojoDescriptorException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n\n        if ( destinationFile.exists() )\n        {\n            destinationFile.delete();\n        }\n        else\n        {\n            if ( !destinationFile.getParentFile().exists() )\n            {\n                destinationFile.getParentFile().mkdirs();\n            }\n        }\n\n        String encoding = \"UTF-8\";\n\n        Writer writer = null;\n        try\n        {\n            writer = new OutputStreamWriter( new FileOutputStream( destinationFile ), encoding );\n\n            XMLWriter w = new PrettyPrintXMLWriter( writer, encoding, null );\n\n            w.writeMarkup( \"\\n<!-- Generated by maven-plugin-tools \" + getVersion() + \" on \"\n                + new SimpleDateFormat( \"yyyy-MM-dd\" ).format( new Date() ) + \" -->\\n\\n\" );\n\n            w.startElement( \"plugin\" );\n\n            GeneratorUtils.element( w, \"name\", pluginDescriptor.getName() );\n\n            GeneratorUtils.element( w, \"description\", pluginDescriptor.getDescription(), helpDescriptor );\n\n            GeneratorUtils.element( w, \"groupId\", pluginDescriptor.getGroupId() );\n\n            GeneratorUtils.element( w, \"artifactId\", pluginDescriptor.getArtifactId() );\n\n            GeneratorUtils.element( w, \"version\", pluginDescriptor.getVersion() );\n\n            GeneratorUtils.element( w, \"goalPrefix\", pluginDescriptor.getGoalPrefix() );\n\n            if ( !helpDescriptor )\n            {\n                GeneratorUtils.element( w, \"isolatedRealm\", String.valueOf( pluginDescriptor.isIsolatedRealm() ) );\n\n                GeneratorUtils.element( w, \"inheritedByDefault\", String.valueOf( pluginDescriptor.isInheritedByDefault() ) );\n            }\n\n            w.startElement( \"mojos\" );\n\n            if ( pluginDescriptor.getMojos() != null )\n            {\n                @SuppressWarnings( \"unchecked\" ) List<MojoDescriptor> descriptors = pluginDescriptor.getMojos();\n\n                if ( helpDescriptor )\n                {\n                    PluginUtils.sortMojos( descriptors );\n                }\n\n                for ( MojoDescriptor descriptor : descriptors )\n                {\n                    processMojoDescriptor( descriptor, w, helpDescriptor );\n                }\n            }\n\n            w.endElement();\n\n            if ( !helpDescriptor )\n            {\n                GeneratorUtils.writeDependencies( w, pluginDescriptor );\n            }\n\n            w.endElement();\n\n            writer.flush();\n\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        processMojoDescriptor( mojoDescriptor, w, false );\n    }\n\n    /**\n     * @param mojoDescriptor   not null\n     * @param w                not null\n     * @param helpDescriptor will clean html content from description fields\n     */\n    protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, XMLWriter w, boolean helpDescriptor )\n    {\n        w.startElement( \"mojo\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"goal\" );\n        w.writeText( mojoDescriptor.getGoal() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        String description = mojoDescriptor.getDescription();\n\n        if ( description != null )\n        {\n            w.startElement( \"description\" );\n            if ( helpDescriptor )\n            {\n                w.writeText( GeneratorUtils.toText( mojoDescriptor.getDescription() ) );\n            }\n            else\n            {\n                w.writeText( mojoDescriptor.getDescription() );\n            }\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.isDependencyResolutionRequired() ) )\n        {\n            GeneratorUtils.element( w, \"requiresDependencyResolution\", mojoDescriptor.isDependencyResolutionRequired() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"requiresDirectInvocation\", String.valueOf( mojoDescriptor.isDirectInvocationOnly() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"requiresProject\", String.valueOf( mojoDescriptor.isProjectRequired() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"requiresReports\", String.valueOf( mojoDescriptor.isRequiresReports() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"aggregator\", String.valueOf( mojoDescriptor.isAggregator() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"requiresOnline\", String.valueOf( mojoDescriptor.isOnlineRequired() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        GeneratorUtils.element( w, \"inheritedByDefault\", String.valueOf( mojoDescriptor.isInheritedByDefault() ) );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getPhase() ) )\n        {\n            GeneratorUtils.element( w, \"phase\", mojoDescriptor.getPhase() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getExecutePhase() ) )\n        {\n            GeneratorUtils.element( w, \"executePhase\", mojoDescriptor.getExecutePhase() );\n        }\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getExecuteGoal() ) )\n        {\n            GeneratorUtils.element( w, \"executeGoal\", mojoDescriptor.getExecuteGoal() );\n        }\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getExecuteLifecycle() ) )\n        {\n            GeneratorUtils.element( w, \"executeLifecycle\", mojoDescriptor.getExecuteLifecycle() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"implementation\" );\n        w.writeText( mojoDescriptor.getImplementation() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"language\" );\n        w.writeText( mojoDescriptor.getLanguage() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getComponentConfigurator() ) )\n        {\n            w.startElement( \"configurator\" );\n            w.writeText( mojoDescriptor.getComponentConfigurator() );\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getComponentComposer() ) )\n        {\n            w.startElement( \"composer\" );\n            w.writeText( mojoDescriptor.getComponentComposer() );\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"instantiationStrategy\" );\n        w.writeText( mojoDescriptor.getInstantiationStrategy() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Strategy for handling repeated reference to mojo in\n        // the calculated (decorated, resolved) execution stack\n        // ----------------------------------------------------------------------\n        w.startElement( \"executionStrategy\" );\n        w.writeText( mojoDescriptor.getExecutionStrategy() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getSince() != null )\n        {\n            w.startElement( \"since\" );\n\n            if ( StringUtils.isEmpty( mojoDescriptor.getSince() ) )\n            {\n                w.writeText( \"No version given\" );\n            }\n            else\n            {\n                w.writeText( mojoDescriptor.getSince() );\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getDeprecated() != null )\n        {\n            w.startElement( \"deprecated\" );\n\n            if ( StringUtils.isEmpty( mojoDescriptor.getDeprecated() ) )\n            {\n                w.writeText( \"No reason given\" );\n            }\n            else\n            {\n                w.writeText( mojoDescriptor.getDeprecated() );\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Extended (3.0) descriptor\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor instanceof ExtendedMojoDescriptor )\n        {\n            ExtendedMojoDescriptor extendedMojoDescriptor = (ExtendedMojoDescriptor) mojoDescriptor;\n            if ( extendedMojoDescriptor.getDependencyCollectionRequired() != null )\n            {\n                GeneratorUtils.element( w, \"requiresDependencyCollection\",\n                                     extendedMojoDescriptor.getDependencyCollectionRequired() );\n            }\n\n            GeneratorUtils.element( w, \"threadSafe\", String.valueOf( extendedMojoDescriptor.isThreadSafe() ) );\n        }\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        @SuppressWarnings( \"unchecked\" ) List<Parameter> parameters = mojoDescriptor.getParameters();\n\n        w.startElement( \"parameters\" );\n\n        Map<String, Requirement> requirements = new LinkedHashMap<String, Requirement>();\n\n        Set<Parameter> configuration = new LinkedHashSet<Parameter>();\n\n        if ( parameters != null )\n        {\n            if ( helpDescriptor )\n            {\n                PluginUtils.sortMojoParameters( parameters );\n            }\n\n            for ( Parameter parameter : parameters )\n            {\n                String expression = getExpression( parameter );\n\n                if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${component.\" ) )\n                {\n                    // treat it as a component...a requirement, in other words.\n\n                    // remove \"component.\" plus expression delimiters\n                    String role = expression.substring( \"${component.\".length(), expression.length() - 1 );\n\n                    String roleHint = null;\n\n                    int posRoleHintSeparator = role.indexOf( \"#\" );\n                    if ( posRoleHintSeparator > 0 )\n                    {\n                        roleHint = role.substring( posRoleHintSeparator + 1 );\n\n                        role = role.substring( 0, posRoleHintSeparator );\n                    }\n\n                    // TODO: remove deprecated expression\n                    requirements.put( parameter.getName(), new Requirement( role, roleHint ) );\n                }\n                else if ( parameter.getRequirement() != null )\n                {\n                    requirements.put( parameter.getName(), parameter.getRequirement() );\n                }\n                else if ( !helpDescriptor || parameter.isEditable() ) // don't show readonly parameters in help\n                {\n                    // treat it as a normal parameter.\n\n                    w.startElement( \"parameter\" );\n\n                    GeneratorUtils.element( w, \"name\", parameter.getName() );\n\n                    if ( parameter.getAlias() != null )\n                    {\n                        GeneratorUtils.element( w, \"alias\", parameter.getAlias() );\n                    }\n\n                    GeneratorUtils.element( w, \"type\", parameter.getType() );\n\n                    if ( parameter.getSince() != null )\n                    {\n                        w.startElement( \"since\" );\n\n                        if ( StringUtils.isEmpty( parameter.getSince() ) )\n                        {\n                            w.writeText( \"No version given\" );\n                        }\n                        else\n                        {\n                            w.writeText( parameter.getSince() );\n                        }\n\n                        w.endElement();\n                    }\n\n                    if ( parameter.getDeprecated() != null )\n                    {\n                        if ( StringUtils.isEmpty( parameter.getDeprecated() ) )\n                        {\n                            GeneratorUtils.element( w, \"deprecated\", \"No reason given\" );\n                        }\n                        else\n                        {\n                            GeneratorUtils.element( w, \"deprecated\", parameter.getDeprecated() );\n                        }\n                    }\n\n                    if ( parameter.getImplementation() != null )\n                    {\n                        GeneratorUtils.element( w, \"implementation\", parameter.getImplementation() );\n                    }\n\n                    GeneratorUtils.element( w, \"required\", Boolean.toString( parameter.isRequired() ) );\n\n                    GeneratorUtils.element( w, \"editable\", Boolean.toString( parameter.isEditable() ) );\n\n                    GeneratorUtils.element( w, \"description\", parameter.getDescription(), helpDescriptor );\n\n                    if ( StringUtils.isNotEmpty( parameter.getDefaultValue() )\n                        || StringUtils.isNotEmpty( parameter.getExpression() ) )\n                    {\n                        configuration.add( parameter );\n                    }\n\n                    w.endElement();\n                }\n\n            }\n        }\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Configuration\n        // ----------------------------------------------------------------------\n\n        if ( !configuration.isEmpty() )\n        {\n            w.startElement( \"configuration\" );\n\n            for ( Parameter parameter : configuration )\n            {\n                if ( helpDescriptor && !parameter.isEditable() )\n                {\n                    // don't show readonly parameters in help\n                    continue;\n                }\n\n                w.startElement( parameter.getName() );\n\n                String type = parameter.getType();\n                if ( StringUtils.isNotEmpty( type ) )\n                {\n                    w.addAttribute( \"implementation\", type );\n                }\n\n                if ( parameter.getDefaultValue() != null )\n                {\n                    w.addAttribute( \"default-value\", parameter.getDefaultValue() );\n                }\n\n                if ( StringUtils.isNotEmpty( parameter.getExpression() ) )\n                {\n                    w.writeText( parameter.getExpression() );\n                }\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        if ( !requirements.isEmpty() && !helpDescriptor )\n        {\n            w.startElement( \"requirements\" );\n\n            for ( Map.Entry<String, Requirement> entry : requirements.entrySet() )\n            {\n                String key = entry.getKey();\n                Requirement requirement = entry.getValue();\n\n                w.startElement( \"requirement\" );\n\n                GeneratorUtils.element( w, \"role\", requirement.getRole() );\n\n                if ( StringUtils.isNotEmpty( requirement.getRoleHint() ) )\n                {\n                    GeneratorUtils.element( w, \"role-hint\", requirement.getRoleHint() );\n                }\n\n                GeneratorUtils.element( w, \"field-name\", key );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        w.endElement();\n    }\n\n    /**\n     * Get the expression value, eventually surrounding it with <code>${ }<\/code>.\n     * \n     * @param parameter the parameter\n     * @return the expression value\n     */\n    private String getExpression( Parameter parameter )\n    {\n        String expression = parameter.getExpression();\n        if ( StringUtils.isNotBlank( expression ) && !expression.contains( \"${\" ) )\n        {\n            expression = \"${\" + expression.trim() + \"}\";\n            parameter.setExpression( expression );\n        }\n        return expression;\n    }\n\n    protected String rewriteHelpClassToMojoPackage( PluginToolsRequest request )\n        throws GeneratorException\n    {\n        String destinationPackage = GeneratorUtils.discoverPackageName( request.getPluginDescriptor() );\n        if ( StringUtils.isEmpty( destinationPackage ) )\n        {\n            return null;\n        }\n        File helpClassFile = new File( request.getProject().getBuild().getOutputDirectory(), \"HelpMojo.class\" );\n        if ( !helpClassFile.exists() )\n        {\n            return null;\n        }\n        File rewriteHelpClassFile = new File(\n            request.getProject().getBuild().getOutputDirectory() + \"/\" + StringUtils.replace( destinationPackage, \".\",\n                                                                                              \"/\" ), \"HelpMojo.class\" );\n        if ( !rewriteHelpClassFile.getParentFile().exists() )\n        {\n            rewriteHelpClassFile.getParentFile().mkdirs();\n        }\n\n        ClassReader cr = null;\n        try\n        {\n            cr = new ClassReader( new FileInputStream( helpClassFile ) );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n\n        ClassWriter cw = new ClassWriter( 0 );\n\n        ClassVisitor cv = new RemappingClassAdapter( cw, new SimpleRemapper( \"HelpMojo\",\n                                                                             StringUtils.replace( destinationPackage,\n                                                                                                  \".\", \"/\" )\n                                                                                 + \"/HelpMojo\" ) );\n\n        try\n        {\n            cr.accept( cv, ClassReader.EXPAND_FRAMES );\n        }\n        catch ( Throwable e )\n        {\n            throw new GeneratorException( \"ASM issue processing classFile \" + helpClassFile.getPath(), e );\n        }\n\n        byte[] renamedClass = cw.toByteArray();\n        FileOutputStream fos = null;\n        try\n        {\n            fos = new FileOutputStream( rewriteHelpClassFile );\n            fos.write( renamedClass );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( \"Error rewriting help class: \" + e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( fos );\n        }\n        helpClassFile.delete();\n        return destinationPackage + \".HelpMojo\";\n    }\n\n\n    private void rewriteDescriptor( PluginDescriptor pluginDescriptor, String helpMojoImplementation )\n    {\n        MojoDescriptor mojoDescriptor = pluginDescriptor.getMojo( \"help\" );\n        if ( mojoDescriptor != null )\n        {\n            mojoDescriptor.setImplementation( helpMojoImplementation );\n        }\n    }\n}\n","lineNo":668}
{"Refactored Sample":"package org.apache.maven.script.ant;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.DependencyResolutionRequiredException;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.ContextEnabled;\nimport org.apache.maven.plugin.MojoExecution;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.PluginParameterExpressionEvaluator;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.path.PathTranslator;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.PropertyHelper;\nimport org.apache.tools.ant.types.Path;\nimport org.codehaus.plexus.archiver.ArchiverException;\nimport org.codehaus.plexus.archiver.UnArchiver;\nimport org.codehaus.plexus.archiver.zip.ZipUnArchiver;\nimport org.codehaus.plexus.component.MapOrientedComponent;\nimport org.codehaus.plexus.component.configurator.ComponentConfigurationException;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluator;\nimport org.codehaus.plexus.component.factory.ant.AntComponentExecutionException;\nimport org.codehaus.plexus.component.factory.ant.AntScriptInvoker;\nimport org.codehaus.plexus.component.repository.ComponentRequirement;\nimport org.codehaus.plexus.logging.LogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class AntMojoWrapper\n    extends AbstractMojo\n    implements ContextEnabled, MapOrientedComponent, LogEnabled\n{\n\n    private Map<String, Object> pluginContext;\n    \n    private final AntScriptInvoker scriptInvoker;\n\n    private Project antProject;\n\n    private MavenProject mavenProject;\n\n    private MojoExecution mojoExecution;\n\n    private MavenSession session;\n    \n    private PathTranslator pathTranslator;\n\n    private Logger logger;\n    \n    private transient List<String> unconstructedParts = new ArrayList<String>();\n\n    public AntMojoWrapper( AntScriptInvoker scriptInvoker )\n    {\n        this.scriptInvoker = scriptInvoker;\n    }\n\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( antProject == null )\n        {\n            antProject = scriptInvoker.getProject();\n        }\n        \n        Map<String, Object> allConfig = new HashMap<String, Object>();\n        if ( pluginContext != null && !pluginContext.isEmpty() )\n        {\n            allConfig.putAll( pluginContext );\n        }\n        \n        @SuppressWarnings( \"unchecked\" )\n        Map<String, PathTranslator> refs = scriptInvoker.getReferences();\n        if ( refs != null )\n        {\n            allConfig.putAll( refs );\n            \n            for ( Map.Entry<String, PathTranslator> entry : refs.entrySet() )\n            {\n                if ( entry.getKey().startsWith( PathTranslator.class.getName() ) )\n                {\n                    pathTranslator = entry.getValue();\n                }\n            }\n        }\n\n        mavenProject = (MavenProject) allConfig.get( \"project\" );\n        \n        mojoExecution = (MojoExecution) allConfig.get( \"mojoExecution\" );\n        \n        session = (MavenSession) allConfig.get( \"session\" );\n        \n        unpackFileBasedResources();\n\n        addClasspathReferences();\n        \n        if ( logger.isDebugEnabled() && !unconstructedParts.isEmpty() )\n        {\n            StringBuffer buffer = new StringBuffer();\n            \n            buffer.append( \"The following standard Maven Ant-mojo support objects could not be created:\\n\\n\" );\n            \n            for ( String part : unconstructedParts )\n            {\n                buffer.append( \"\\n-  \" ).append( part );\n            }\n            \n            buffer.append( \"\\n\\nMaven project, session, mojo-execution, or path-translation parameter information is \" );\n            buffer.append( \"\\nmissing from this mojo's plugin descriptor.\" );\n            buffer.append( \"\\n\\nPerhaps this Ant-based mojo depends on maven-script-ant < 2.1.0, \" );\n            buffer.append( \"or used maven-plugin-tools-ant < 2.2 during release?\\n\\n\" );\n            \n            logger.debug( buffer.toString() );\n        }\n\n        try\n        {\n            scriptInvoker.invoke();\n        }\n        catch ( AntComponentExecutionException e )\n        {\n            throw new MojoExecutionException( \"Failed to execute: \" + e.getMessage(), e );\n        }\n        \n        unconstructedParts.clear();\n    }\n\n    public void setPluginContext( Map pluginContext )\n    {\n        this.pluginContext = pluginContext;\n    }\n\n    public Map getPluginContext()\n    {\n        return pluginContext;\n    }\n\n    public void addComponentRequirement( ComponentRequirement requirementDescriptor, Object requirementValue )\n        throws ComponentConfigurationException\n    {\n        scriptInvoker.addComponentRequirement( requirementDescriptor, requirementValue );\n    }\n\n    public void setComponentConfiguration( Map componentConfiguration )\n        throws ComponentConfigurationException\n    {\n        scriptInvoker.setComponentConfiguration( componentConfiguration );\n        antProject = scriptInvoker.getProject();\n    }\n\n    private void unpackFileBasedResources()\n        throws MojoExecutionException\n    {\n        if ( mojoExecution == null || mavenProject == null )\n        {\n            unconstructedParts.add( \"Unpacked Ant build scripts (in Maven build directory).\" );\n            \n            return;\n        }\n        \n        // What we need to write out any resources in the plugin to the target directory of the\n        // mavenProject using the Ant-based plugin:\n        //\n        // 1. Need a reference to the plugin JAR itself\n        // 2. Need a reference to the ${basedir} of the mavenProject\n\n        PluginDescriptor pluginDescriptor = mojoExecution.getMojoDescriptor().getPluginDescriptor();\n        \n        File pluginJar = pluginDescriptor.getPluginArtifact().getFile();\n\n        String resourcesPath = pluginDescriptor.getArtifactId();\n\n        File outputDirectory = new File( mavenProject.getBuild().getDirectory() );\n\n        try\n        {\n            UnArchiver ua = new ZipUnArchiver( pluginJar );\n\n            ua.extract( resourcesPath, outputDirectory );\n        }\n        catch ( ArchiverException e )\n        {\n            throw new MojoExecutionException( \"Error extracting resources from your Ant-based plugin.\", e );\n        }\n    }\n\n    private void addClasspathReferences()\n        throws MojoExecutionException\n    {\n        try\n        {\n            if ( mavenProject != null && session != null && pathTranslator != null )\n            {\n                ExpressionEvaluator exprEvaluator =\n                    new PluginParameterExpressionEvaluator( session, mojoExecution, pathTranslator, logger, mavenProject,\n                                                            mavenProject.getProperties() );\n                \n                PropertyHelper propertyHelper = PropertyHelper.getPropertyHelper( antProject );\n                propertyHelper.setNext( new AntPropertyHelper( exprEvaluator, mavenProject.getArtifacts(), getLog() ) );\n            }\n            else\n            {\n                unconstructedParts.add( \"Maven parameter expression evaluator for Ant properties.\" );\n            }\n\n            @SuppressWarnings( \"unchecked\" )\n            Map<String, Object> references = scriptInvoker.getReferences();\n\n            if ( mavenProject != null )\n            {\n\n                // Compile classpath\n                Path p = new Path( antProject );\n\n                p.setPath( StringUtils.join( mavenProject.getCompileClasspathElements().iterator(), File.pathSeparator ) );\n\n                /* maven.dependency.classpath it's deprecated as it's equal to maven.compile.classpath */\n                references.put( \"maven.dependency.classpath\", p );\n                antProject.addReference( \"maven.dependency.classpath\", p );\n                \n                references.put( \"maven.compile.classpath\", p );\n                antProject.addReference( \"maven.compile.classpath\", p );\n\n                // Runtime classpath\n                p = new Path( antProject );\n\n                p.setPath( StringUtils.join( mavenProject.getRuntimeClasspathElements().iterator(), File.pathSeparator ) );\n\n                references.put( \"maven.runtime.classpath\", p );\n                antProject.addReference( \"maven.runtime.classpath\", p );\n\n                // Test classpath\n                p = new Path( antProject );\n\n                p.setPath( StringUtils.join( mavenProject.getTestClasspathElements().iterator(), File.pathSeparator ) );\n\n                references.put( \"maven.test.classpath\", p );\n                antProject.addReference( \"maven.test.classpath\", p );\n\n            }\n            else\n            {\n                unconstructedParts.add( \"Maven standard project-based classpath references.\" );\n            }\n            \n            if ( mojoExecution != null )\n            {\n                // Plugin dependency classpath\n\n                Path p = getPathFromArtifacts( mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifacts(), antProject );\n                \n                references.put( \"maven.plugin.classpath\", p );\n                antProject.addReference( \"maven.plugin.classpath\", p );\n            }\n            else\n            {\n                unconstructedParts.add( \"Maven standard plugin-based classpath references.\" );\n            }\n        }\n        catch ( DependencyResolutionRequiredException e )\n        {\n            throw new MojoExecutionException( \"Error creating classpath references for Ant-based plugin scripts.\", e  );\n        }\n    }\n\n    public Path getPathFromArtifacts( Collection<Artifact> artifacts, Project antProject )\n        throws DependencyResolutionRequiredException\n    {\n        List<String> list = new ArrayList<String>( artifacts.size() );\n\n        for ( Artifact a : artifacts )\n        {\n            File file = a.getFile();\n\n            if ( file == null )\n            {\n                throw new DependencyResolutionRequiredException( a );\n            }\n\n            list.add( file.getPath() );\n        }\n\n        Path p = new Path( antProject );\n\n        p.setPath( StringUtils.join( list.iterator(), File.pathSeparator ) );\n\n        return p;\n    }\n\n    public Project getAntProject()\n    {\n        return antProject;\n    }\n\n    public void setAntProject( Project antProject )\n    {\n        this.antProject = antProject;\n    }\n\n    public MavenProject getMavenProject()\n    {\n        return mavenProject;\n    }\n\n    public void setMavenProject( MavenProject mavenProject )\n    {\n        this.mavenProject = mavenProject;\n    }\n\n    public MojoExecution getMojoExecution()\n    {\n        return mojoExecution;\n    }\n\n    public void setMojoExecution( MojoExecution mojoExecution )\n    {\n        this.mojoExecution = mojoExecution;\n    }\n\n    public MavenSession getSession()\n    {\n        return session;\n    }\n\n    public void setSession( MavenSession session )\n    {\n        this.session = session;\n    }\n\n    public PathTranslator getPathTranslator()\n    {\n        return pathTranslator;\n    }\n\n    public void setPathTranslator( PathTranslator pathTranslator )\n    {\n        this.pathTranslator = pathTranslator;\n    }\n\n    public AntScriptInvoker getScriptInvoker()\n    {\n        return scriptInvoker;\n    }\n\n    public void enableLogging( Logger logger )\n    {\n        this.logger = logger;\n    }\n}\n","Smelly Sample":"package org.apache.maven.script.ant;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.DependencyResolutionRequiredException;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.ContextEnabled;\nimport org.apache.maven.plugin.MojoExecution;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.PluginParameterExpressionEvaluator;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.path.PathTranslator;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.PropertyHelper;\nimport org.apache.tools.ant.types.Path;\nimport org.codehaus.plexus.archiver.ArchiverException;\nimport org.codehaus.plexus.archiver.UnArchiver;\nimport org.codehaus.plexus.archiver.zip.ZipUnArchiver;\nimport org.codehaus.plexus.component.MapOrientedComponent;\nimport org.codehaus.plexus.component.configurator.ComponentConfigurationException;\nimport org.codehaus.plexus.component.configurator.expression.ExpressionEvaluator;\nimport org.codehaus.plexus.component.factory.ant.AntComponentExecutionException;\nimport org.codehaus.plexus.component.factory.ant.AntScriptInvoker;\nimport org.codehaus.plexus.component.repository.ComponentRequirement;\nimport org.codehaus.plexus.logging.LogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n\npublic class AntMojoWrapper\n    extends AbstractMojo\n    implements ContextEnabled, MapOrientedComponent, LogEnabled\n{\n\n    private Map pluginContext;\n    \n    private final AntScriptInvoker scriptInvoker;\n\n    private Project antProject;\n\n    private MavenProject mavenProject;\n\n    private MojoExecution mojoExecution;\n\n    private MavenSession session;\n    \n    private PathTranslator pathTranslator;\n\n    private Logger logger;\n    \n    private transient List unconstructedParts = new ArrayList();\n\n    public AntMojoWrapper( AntScriptInvoker scriptInvoker )\n    {\n        this.scriptInvoker = scriptInvoker;\n    }\n\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( antProject == null )\n        {\n            antProject = scriptInvoker.getProject();\n        }\n        \n        Map allConfig = new HashMap();\n        if ( pluginContext != null && !pluginContext.isEmpty() )\n        {\n            allConfig.putAll( pluginContext );\n        }\n        \n        Map refs = scriptInvoker.getReferences();\n        if ( refs != null )\n        {\n            allConfig.putAll( refs );\n            \n            for ( Iterator it = refs.entrySet().iterator(); it.hasNext(); )\n            {\n                Map.Entry entry = (Map.Entry) it.next();\n                String key = (String) entry.getKey();\n                if ( key.startsWith( PathTranslator.class.getName() ) )\n                {\n                    pathTranslator = (PathTranslator) entry.getValue();\n                }\n            }\n        }\n\n        mavenProject = (MavenProject) allConfig.get( \"project\" );\n        \n        mojoExecution = (MojoExecution) allConfig.get( \"mojoExecution\" );\n        \n        session = (MavenSession) allConfig.get( \"session\" );\n        \n        unpackFileBasedResources();\n\n        addClasspathReferences();\n        \n        if ( logger.isDebugEnabled() && !unconstructedParts.isEmpty() )\n        {\n            StringBuffer buffer = new StringBuffer();\n            \n            buffer.append( \"The following standard Maven Ant-mojo support objects could not be created:\\n\\n\" );\n            \n            for ( Iterator it = unconstructedParts.iterator(); it.hasNext(); )\n            {\n                String part = (String) it.next();\n                buffer.append( \"\\n-  \" ).append( part );\n            }\n            \n            buffer.append( \"\\n\\nMaven project, session, mojo-execution, or path-translation parameter information is \" );\n            buffer.append( \"\\nmissing from this mojo's plugin descriptor.\" );\n            buffer.append( \"\\n\\nPerhaps this Ant-based mojo depends on maven-script-ant < 2.1.0, \" );\n            buffer.append( \"or used maven-plugin-tools-ant < 2.2 during release?\\n\\n\" );\n            \n            logger.debug( buffer.toString() );\n        }\n\n        try\n        {\n            scriptInvoker.invoke();\n        }\n        catch ( AntComponentExecutionException e )\n        {\n            throw new MojoExecutionException( \"Failed to execute: \" + e.getMessage(), e );\n        }\n        \n        unconstructedParts.clear();\n    }\n\n    public void setPluginContext( Map pluginContext )\n    {\n        this.pluginContext = pluginContext;\n    }\n\n    public Map getPluginContext()\n    {\n        return pluginContext;\n    }\n\n    public void addComponentRequirement( ComponentRequirement requirementDescriptor, Object requirementValue )\n        throws ComponentConfigurationException\n    {\n        scriptInvoker.addComponentRequirement( requirementDescriptor, requirementValue );\n    }\n\n    public void setComponentConfiguration( Map componentConfiguration )\n        throws ComponentConfigurationException\n    {\n        scriptInvoker.setComponentConfiguration( componentConfiguration );\n        antProject = scriptInvoker.getProject();\n    }\n\n    private void unpackFileBasedResources()\n        throws MojoExecutionException\n    {\n        if ( mojoExecution == null || mavenProject == null )\n        {\n            unconstructedParts.add( \"Unpacked Ant build scripts (in Maven build directory).\" );\n            \n            return;\n        }\n        \n        // What we need to write out any resources in the plugin to the target directory of the\n        // mavenProject using the Ant-based plugin:\n        //\n        // 1. Need a reference to the plugin JAR itself\n        // 2. Need a reference to the ${basedir} of the mavenProject\n\n        PluginDescriptor pluginDescriptor = mojoExecution.getMojoDescriptor().getPluginDescriptor();\n        \n        File pluginJar = pluginDescriptor.getPluginArtifact().getFile();\n\n        String resourcesPath = pluginDescriptor.getArtifactId();\n\n        File outputDirectory = new File( mavenProject.getBuild().getDirectory() );\n\n        try\n        {\n            UnArchiver ua = new ZipUnArchiver( pluginJar );\n\n            ua.extract( resourcesPath, outputDirectory );\n        }\n        catch ( ArchiverException e )\n        {\n            throw new MojoExecutionException( \"Error extracting resources from your Ant-based plugin.\", e );\n        }\n    }\n\n    private void addClasspathReferences()\n        throws MojoExecutionException\n    {\n        try\n        {\n            if ( mavenProject != null && session != null && pathTranslator != null )\n            {\n                ExpressionEvaluator exprEvaluator =\n                    new PluginParameterExpressionEvaluator( session, mojoExecution, pathTranslator, logger, mavenProject,\n                                                            mavenProject.getProperties() );\n                \n                PropertyHelper propertyHelper = PropertyHelper.getPropertyHelper( antProject );\n                propertyHelper.setNext( new AntPropertyHelper( exprEvaluator, mavenProject.getArtifacts(), getLog() ) );\n            }\n            else\n            {\n                unconstructedParts.add( \"Maven parameter expression evaluator for Ant properties.\" );\n            }\n\n            if ( mavenProject != null )\n            {\n                // Compile classpath\n                Path p = new Path( antProject );\n\n                p.setPath( StringUtils.join( mavenProject.getCompileClasspathElements().iterator(), File.pathSeparator ) );\n\n                /* maven.dependency.classpath it's deprecated as it's equal to maven.compile.classpath */\n                scriptInvoker.getReferences().put( \"maven.dependency.classpath\", p );\n                antProject.addReference( \"maven.dependency.classpath\", p );\n                \n                scriptInvoker.getReferences().put( \"maven.compile.classpath\", p );\n                antProject.addReference( \"maven.compile.classpath\", p );\n\n                // Runtime classpath\n                p = new Path( antProject );\n\n                p.setPath( StringUtils.join( mavenProject.getRuntimeClasspathElements().iterator(), File.pathSeparator ) );\n\n                scriptInvoker.getReferences().put( \"maven.runtime.classpath\", p );\n                antProject.addReference( \"maven.runtime.classpath\", p );\n\n                // Test classpath\n                p = new Path( antProject );\n\n                p.setPath( StringUtils.join( mavenProject.getTestClasspathElements().iterator(), File.pathSeparator ) );\n\n                scriptInvoker.getReferences().put( \"maven.test.classpath\", p );\n                antProject.addReference( \"maven.test.classpath\", p );\n\n            }\n            else\n            {\n                unconstructedParts.add( \"Maven standard project-based classpath references.\" );\n            }\n            \n            if ( mojoExecution != null )\n            {\n                // Plugin dependency classpath\n\n                Path p = getPathFromArtifacts( mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifacts(), antProject );\n                \n                scriptInvoker.getReferences().put( \"maven.plugin.classpath\", p );\n                antProject.addReference( \"maven.plugin.classpath\", p );\n            }\n            else\n            {\n                unconstructedParts.add( \"Maven standard plugin-based classpath references.\" );\n            }\n        }\n        catch ( DependencyResolutionRequiredException e )\n        {\n            throw new MojoExecutionException( \"Error creating classpath references for Ant-based plugin scripts.\", e  );\n        }\n    }\n\n    public Path getPathFromArtifacts( Collection artifacts,\n                                      Project antProject )\n        throws DependencyResolutionRequiredException\n    {\n        List list = new ArrayList( artifacts.size() );\n\n        for ( Iterator i = artifacts.iterator(); i.hasNext(); )\n        {\n            Artifact a = (Artifact) i.next();\n\n            File file = a.getFile();\n\n            if ( file == null )\n            {\n                throw new DependencyResolutionRequiredException( a );\n            }\n\n            list.add( file.getPath() );\n        }\n\n        Path p = new Path( antProject );\n\n        p.setPath( StringUtils.join( list.iterator(), File.pathSeparator ) );\n\n        return p;\n    }\n\n    public Project getAntProject()\n    {\n        return antProject;\n    }\n\n    public void setAntProject( Project antProject )\n    {\n        this.antProject = antProject;\n    }\n\n    public MavenProject getMavenProject()\n    {\n        return mavenProject;\n    }\n\n    public void setMavenProject( MavenProject mavenProject )\n    {\n        this.mavenProject = mavenProject;\n    }\n\n    public MojoExecution getMojoExecution()\n    {\n        return mojoExecution;\n    }\n\n    public void setMojoExecution( MojoExecution mojoExecution )\n    {\n        this.mojoExecution = mojoExecution;\n    }\n\n    public MavenSession getSession()\n    {\n        return session;\n    }\n\n    public void setSession( MavenSession session )\n    {\n        this.session = session;\n    }\n\n    public PathTranslator getPathTranslator()\n    {\n        return pathTranslator;\n    }\n\n    public void setPathTranslator( PathTranslator pathTranslator )\n    {\n        this.pathTranslator = pathTranslator;\n    }\n\n    public AntScriptInvoker getScriptInvoker()\n    {\n        return scriptInvoker;\n    }\n\n    public void enableLogging( Logger logger )\n    {\n        this.logger = logger;\n    }\n}\n","lineNo":233}
{"Refactored Sample":"package org.apache.maven.tools.plugin.annotations;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport com.thoughtworks.qdox.JavaDocBuilder;\nimport com.thoughtworks.qdox.model.DocletTag;\nimport com.thoughtworks.qdox.model.JavaClass;\nimport com.thoughtworks.qdox.model.JavaField;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.plugin.descriptor.DuplicateParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ComponentAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ExecuteAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.MojoAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ParameterAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotatedClass;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScanner;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScannerRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.codehaus.plexus.archiver.UnArchiver;\nimport org.codehaus.plexus.archiver.manager.ArchiverManager;\nimport org.codehaus.plexus.archiver.manager.NoSuchArchiverException;\nimport org.codehaus.plexus.component.annotations.Component;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * JavaMojoDescriptorExtractor, a MojoDescriptor extractor to read descriptors from java classes with annotations.\n *\n * @author Olivier Lamy\n * @since 3.0\n */\n@Component( role = MojoDescriptorExtractor.class, hint = \"java-annotations\" )\npublic class JavaAnnotationsMojoDescriptorExtractor\n    extends AbstractLogEnabled\n    implements MojoDescriptorExtractor\n{\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private MojoAnnotationsScanner mojoAnnotationsScanner;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArtifactResolver artifactResolver;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArtifactFactory artifactFactory;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArchiverManager archiverManager;\n\n    public List<MojoDescriptor> execute( MavenProject project, PluginDescriptor pluginDescriptor )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        return execute( new DefaultPluginToolsRequest( project, pluginDescriptor ) );\n    }\n\n    public List<MojoDescriptor> execute( PluginToolsRequest request )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = scanAnnotations( request );\n\n        Map<String, JavaClass> javaClassesMap = scanJavadoc( request, mojoAnnotatedClasses.values() );\n\n        populateDataFromJavadoc( mojoAnnotatedClasses, javaClassesMap );\n\n        return toMojoDescriptors( mojoAnnotatedClasses, request, javaClassesMap );\n    }\n\n    private Map<String, MojoAnnotatedClass> scanAnnotations( PluginToolsRequest request )\n        throws ExtractionException\n    {\n        MojoAnnotationsScannerRequest mojoAnnotationsScannerRequest = new MojoAnnotationsScannerRequest();\n\n        File output = new File( request.getProject().getBuild().getOutputDirectory() );\n        mojoAnnotationsScannerRequest.setClassesDirectories( Arrays.asList( output ) );\n\n        mojoAnnotationsScannerRequest.setDependencies( request.getDependencies() );\n\n        mojoAnnotationsScannerRequest.setProject( request.getProject() );\n\n        return mojoAnnotationsScanner.scan( mojoAnnotationsScannerRequest );\n    }\n\n    private Map<String, JavaClass> scanJavadoc( PluginToolsRequest request,\n                                                Collection<MojoAnnotatedClass> mojoAnnotatedClasses )\n        throws ExtractionException\n    {\n        // found artifact from reactors to scan sources\n        // we currently only scan sources from reactors\n        List<MavenProject> mavenProjects = new ArrayList<MavenProject>();\n\n        // if we need to scan sources from external artifacts\n        Set<Artifact> externalArtifacts = new HashSet<Artifact>();\n\n        for ( MojoAnnotatedClass mojoAnnotatedClass : mojoAnnotatedClasses )\n        {\n            if ( !StringUtils.equals( mojoAnnotatedClass.getArtifact().getArtifactId(),\n                                      request.getProject().getArtifact().getArtifactId() ) )\n            {\n                MavenProject mavenProject =\n                    getFromProjectReferences( mojoAnnotatedClass.getArtifact(), request.getProject() );\n                if ( mavenProject != null )\n                {\n                    mavenProjects.add( mavenProject );\n                }\n                else\n                {\n                    externalArtifacts.add( mojoAnnotatedClass.getArtifact() );\n                }\n            }\n        }\n\n        Map<String, JavaClass> javaClassesMap = new HashMap<String, JavaClass>();\n\n        // try to get artifact with classifier sources\n        // extract somewhere then scan doclet for @since, @deprecated\n        for ( Artifact artifact : externalArtifacts )\n        {\n            // parameter for test-sources too ?? olamy I need that for it test only\n            if ( StringUtils.equalsIgnoreCase( \"tests\", artifact.getClassifier() ) )\n            {\n                javaClassesMap.putAll( discoverClassesFromSourcesJar( artifact, request, \"test-sources\" ) );\n            }\n            else\n            {\n                javaClassesMap.putAll( discoverClassesFromSourcesJar( artifact, request, \"sources\" ) );\n            }\n\n        }\n\n        for ( MavenProject mavenProject : mavenProjects )\n        {\n            javaClassesMap.putAll( discoverClasses( request.getEncoding(), mavenProject ) );\n        }\n\n        javaClassesMap.putAll( discoverClasses( request ) );\n\n        return javaClassesMap;\n    }\n\n    protected Map<String, JavaClass> discoverClassesFromSourcesJar( Artifact artifact, PluginToolsRequest request,\n                                                                    String classifier )\n        throws ExtractionException\n    {\n        try\n        {\n            Artifact sourcesArtifact =\n                artifactFactory.createArtifactWithClassifier( artifact.getGroupId(), artifact.getArtifactId(),\n                                                              artifact.getVersion(), artifact.getType(), classifier );\n\n            artifactResolver.resolve( sourcesArtifact, request.getRemoteRepos(), request.getLocal() );\n            if ( sourcesArtifact.getFile() != null && sourcesArtifact.getFile().exists() )\n            {\n                File extractDirectory = new File( request.getProject().getBuild().getDirectory(),\n                                                  \"maven-plugin-plugin-sources/\" + sourcesArtifact.getGroupId() + \"/\"\n                                                      + sourcesArtifact.getArtifactId() + \"/\"\n                                                      + sourcesArtifact.getVersion() + \"/\"\n                                                      + sourcesArtifact.getClassifier() );\n                if ( !extractDirectory.exists() )\n                {\n                    extractDirectory.mkdirs();\n                }\n                // extract sources in a directory\n                //target/maven-plugin-plugin/${groupId}/${artifact}/sources\n                UnArchiver unArchiver = archiverManager.getUnArchiver( \"jar\" );\n                unArchiver.setSourceFile( sourcesArtifact.getFile() );\n                unArchiver.setDestDirectory( extractDirectory );\n                unArchiver.extract();\n\n                return discoverClasses( request.getEncoding(), Arrays.asList( extractDirectory ) );\n            }\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            //throw new ExtractionException( e.getMessage(), e );\n            getLogger().debug( \"skip ArtifactNotFoundException:\" + e.getMessage() );\n            getLogger().warn(\n                \"Impossible to get sources artifact for \" + artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\"\n                    + artifact.getVersion() + \". Some javadoc tags (@since, @deprecated and comments) won't be used\" );\n        }\n        catch ( NoSuchArchiverException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n        return Collections.emptyMap();\n    }\n\n    /**\n     * from sources scan to get @since and @deprecated and description of classes and fields.\n     *\n     * @param mojoAnnotatedClasses\n     * @param javaClassesMap\n     */\n    protected void populateDataFromJavadoc( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                            Map<String, JavaClass> javaClassesMap )\n    {\n\n        for ( Map.Entry<String, MojoAnnotatedClass> entry : mojoAnnotatedClasses.entrySet() )\n        {\n            JavaClass javaClass = javaClassesMap.get( entry.getKey() );\n            if ( javaClass != null )\n            {\n                MojoAnnotationContent mojoAnnotationContent = entry.getValue().getMojo();\n                if ( mojoAnnotationContent != null )\n                {\n                    mojoAnnotationContent.setDescription( javaClass.getComment() );\n                    DocletTag since = findInClassHierarchy( javaClass, \"since\" );\n                    if ( since != null )\n                    {\n                        mojoAnnotationContent.setSince( since.getValue() );\n                    }\n\n                    DocletTag deprecated = findInClassHierarchy( javaClass, \"deprecated\" );\n                    if ( deprecated != null )\n                    {\n                        mojoAnnotationContent.setDeprecated( deprecated.getValue() );\n                    }\n                }\n                Map<String, JavaField> fieldsMap =\n                    extractFieldParameterTags( javaClass, javaClassesMap, mojoAnnotatedClasses );\n                Map<String, ParameterAnnotationContent> parameters =\n                    getParametersParentHierarchy( entry.getValue(), new HashMap<String, ParameterAnnotationContent>(),\n                                                  mojoAnnotatedClasses );\n                for ( Map.Entry<String, ParameterAnnotationContent> parameter : new TreeMap<String, ParameterAnnotationContent>(\n                    parameters ).entrySet() )\n                {\n                    JavaField javaField = fieldsMap.get( parameter.getKey() );\n                    if ( javaField != null )\n                    {\n                        ParameterAnnotationContent parameterAnnotationContent = parameter.getValue();\n                        DocletTag deprecated = javaField.getTagByName( \"deprecated\" );\n                        if ( deprecated != null )\n                        {\n                            parameterAnnotationContent.setDeprecated( deprecated.getValue() );\n                        }\n                        DocletTag since = javaField.getTagByName( \"since\" );\n                        if ( since != null )\n                        {\n                            parameterAnnotationContent.setSince( since.getValue() );\n                        }\n                        parameterAnnotationContent.setDescription( javaField.getComment() );\n                    }\n                }\n\n                for ( Map.Entry<String, ComponentAnnotationContent> component : entry.getValue().getComponents().entrySet() )\n                {\n                    JavaField javaField = fieldsMap.get( component.getKey() );\n                    if ( javaField != null )\n                    {\n                        ComponentAnnotationContent componentAnnotationContent = component.getValue();\n                        DocletTag deprecated = javaField.getTagByName( \"deprecated\" );\n                        if ( deprecated != null )\n                        {\n                            componentAnnotationContent.setDeprecated( deprecated.getValue() );\n                        }\n                        DocletTag since = javaField.getTagByName( \"since\" );\n                        if ( since != null )\n                        {\n                            componentAnnotationContent.setSince( since.getValue() );\n                        }\n                        componentAnnotationContent.setDescription( javaField.getComment() );\n                    }\n                }\n\n            }\n        }\n\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName   not null\n     * @return docletTag instance\n     */\n    private DocletTag findInClassHierarchy( JavaClass javaClass, String tagName )\n    {\n        DocletTag tag = javaClass.getTagByName( tagName );\n\n        if ( tag == null )\n        {\n            JavaClass superClass = javaClass.getSuperJavaClass();\n\n            if ( superClass != null )\n            {\n                tag = findInClassHierarchy( superClass, tagName );\n            }\n        }\n\n        return tag;\n    }\n\n    /**\n     * extract fields that are either parameters or components.\n     *\n     * @param javaClass not null\n     * @return map with Mojo parameters names as keys\n     */\n    private Map<String, JavaField> extractFieldParameterTags( JavaClass javaClass,\n                                                              Map<String, JavaClass> javaClassesMap,\n                                                              Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        Map<String, JavaField> rawParams = new TreeMap<String, com.thoughtworks.qdox.model.JavaField>();\n\n        // we have to add the parent fields first, so that they will be overwritten by the local fields if\n        // that actually happens...\n        JavaClass superClass = javaClass.getSuperJavaClass();\n\n        if ( superClass != null )\n        {\n            if ( superClass.getFields().length > 0 )\n            {\n                rawParams = extractFieldParameterTags( superClass, javaClassesMap, mojoAnnotatedClasses );\n            }\n            // maybe sources comes from scan of sources artifact\n            superClass = javaClassesMap.get( superClass.getFullyQualifiedName() );\n            if ( superClass != null )\n            {\n                rawParams = extractFieldParameterTags( superClass, javaClassesMap, mojoAnnotatedClasses );\n            }\n        }\n        else\n        {\n\n            rawParams = new TreeMap<String, JavaField>();\n        }\n\n        JavaField[] classFields = javaClass.getFields();\n\n        if ( classFields != null )\n        {\n            for ( JavaField field : classFields )\n            {\n                rawParams.put( field.getName(), field );\n            }\n        }\n        return rawParams;\n    }\n\n    protected Map<String, JavaClass> discoverClasses( final PluginToolsRequest request )\n    {\n        return discoverClasses( request.getEncoding(), request.getProject() );\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    protected Map<String, JavaClass> discoverClasses( final String encoding, final MavenProject project )\n    {\n        List<File> sources = new ArrayList<File>();\n\n        for ( String source : (List<String>) project.getCompileSourceRoots() )\n        {\n            sources.add( new File( source ) );\n        }\n\n        // TODO be more dynamic\n        File generatedPlugin = new File( project.getBasedir(), \"target/generated-sources/plugin\" );\n        if ( !project.getCompileSourceRoots().contains( generatedPlugin.getAbsolutePath() )\n            && generatedPlugin.exists() )\n        {\n            sources.add( generatedPlugin );\n        }\n\n        return discoverClasses( encoding, sources );\n    }\n\n    protected Map<String, JavaClass> discoverClasses( final String encoding, List<File> sourceDirectories )\n    {\n        JavaDocBuilder builder = new JavaDocBuilder();\n        builder.setEncoding( encoding );\n\n        for ( File source : sourceDirectories )\n        {\n            builder.addSourceTree( source );\n        }\n\n        JavaClass[] javaClasses = builder.getClasses();\n\n        if ( javaClasses == null || javaClasses.length < 1 )\n        {\n            return Collections.emptyMap();\n        }\n\n        Map<String, JavaClass> javaClassMap = new HashMap<String, JavaClass>( javaClasses.length );\n\n        for ( JavaClass javaClass : javaClasses )\n        {\n            javaClassMap.put( javaClass.getFullyQualifiedName(), javaClass );\n        }\n\n        return javaClassMap;\n    }\n\n    private List<MojoDescriptor> toMojoDescriptors( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                                    PluginToolsRequest request, Map<String, JavaClass> javaClassesMap )\n        throws DuplicateParameterException, InvalidParameterException\n    {\n        List<MojoDescriptor> mojoDescriptors = new ArrayList<MojoDescriptor>( mojoAnnotatedClasses.size() );\n        for ( MojoAnnotatedClass mojoAnnotatedClass : mojoAnnotatedClasses.values() )\n        {\n            // no mojo so skip it\n            if ( mojoAnnotatedClass.getMojo() == null )\n            {\n                continue;\n            }\n\n            ExtendedMojoDescriptor mojoDescriptor = new ExtendedMojoDescriptor();\n\n            //mojoDescriptor.setRole( mojoAnnotatedClass.getClassName() );\n            //mojoDescriptor.setRoleHint( \"default\" );\n            mojoDescriptor.setImplementation( mojoAnnotatedClass.getClassName() );\n            mojoDescriptor.setLanguage( \"java\" );\n\n            MojoAnnotationContent mojo = mojoAnnotatedClass.getMojo();\n\n            mojoDescriptor.setDescription( mojo.getDescription() );\n            mojoDescriptor.setSince( mojo.getSince() );\n            mojo.setDeprecated( mojo.getDeprecated() );\n\n            mojoDescriptor.setAggregator( mojo.aggregator() );\n            mojoDescriptor.setDependencyResolutionRequired( mojo.requiresDependencyResolution().id() );\n            mojoDescriptor.setDependencyCollectionRequired( mojo.requiresDependencyCollection().id() );\n\n            mojoDescriptor.setDirectInvocationOnly( mojo.requiresDirectInvocation() );\n            mojoDescriptor.setDeprecated( mojo.getDeprecated() );\n            mojoDescriptor.setThreadSafe( mojo.threadSafe() );\n\n            ExecuteAnnotationContent execute = findExecuteInParentHierarchy( mojoAnnotatedClass, mojoAnnotatedClasses );\n            if ( execute != null )\n            {\n                mojoDescriptor.setExecuteGoal( execute.goal() );\n                mojoDescriptor.setExecuteLifecycle( execute.lifecycle() );\n                mojoDescriptor.setExecutePhase( execute.phase().id() );\n            }\n\n            mojoDescriptor.setExecutionStrategy( mojo.executionStrategy() );\n            // ???\n            //mojoDescriptor.alwaysExecute(mojo.a)\n\n            mojoDescriptor.setGoal( mojo.name() );\n            mojoDescriptor.setOnlineRequired( mojo.requiresOnline() );\n\n            mojoDescriptor.setPhase( mojo.defaultPhase().id() );\n\n            Map<String, ParameterAnnotationContent> parameters =\n                getParametersParentHierarchy( mojoAnnotatedClass, new HashMap<String, ParameterAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n\n            for ( ParameterAnnotationContent parameterAnnotationContent : new TreeSet<ParameterAnnotationContent>(\n                parameters.values() ) )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                parameter.setName( parameterAnnotationContent.getFieldName() );\n                parameter.setAlias( parameterAnnotationContent.alias() );\n                parameter.setDefaultValue( parameterAnnotationContent.defaultValue() );\n                parameter.setDeprecated( parameterAnnotationContent.getDeprecated() );\n                parameter.setDescription( parameterAnnotationContent.getDescription() );\n                parameter.setEditable( !parameterAnnotationContent.readonly() );\n                String property = parameterAnnotationContent.property();\n                if ( StringUtils.contains( property, '$' ) || StringUtils.contains( property, '{' )\n                    || StringUtils.contains( property, '}' ) )\n                {\n                    throw new InvalidParameterException( \"Invalid property for parameter '\" + parameter.getName() + \"', \"\n                                                         + \"forbidden characters ${}: \" + property, null );\n                }\n                parameter.setExpression( StringUtils.isEmpty( property ) ? \"\" : \"${\" + property + \"}\" );\n                parameter.setType( parameterAnnotationContent.getClassName() );\n                parameter.setSince( parameterAnnotationContent.getSince() );\n                parameter.setRequired( parameterAnnotationContent.required() );\n\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            Map<String, ComponentAnnotationContent> components =\n                getComponentsParentHierarchy( mojoAnnotatedClass, new HashMap<String, ComponentAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n\n            for ( ComponentAnnotationContent componentAnnotationContent : new TreeSet<ComponentAnnotationContent>(\n                components.values() ) )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                parameter.setName( componentAnnotationContent.getFieldName() );\n                parameter.setRequirement(\n                    new Requirement( componentAnnotationContent.role(), componentAnnotationContent.roleHint() ) );\n                parameter.setDeprecated( componentAnnotationContent.getDeprecated() );\n                parameter.setSince( componentAnnotationContent.getSince() );\n\n                // same behaviour as JavaMojoDescriptorExtractor\n                //parameter.setRequired( ... );\n                parameter.setEditable( false );\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            mojoDescriptor.setPluginDescriptor( request.getPluginDescriptor() );\n\n            mojoDescriptors.add( mojoDescriptor );\n        }\n        return mojoDescriptors;\n    }\n\n\n    protected ExecuteAnnotationContent findExecuteInParentHierarchy( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                     Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n\n        if ( mojoAnnotatedClass.getExecute() != null )\n        {\n            return mojoAnnotatedClass.getExecute();\n        }\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( StringUtils.isEmpty( parentClassName ) )\n        {\n            return null;\n        }\n        MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n        if ( parent == null )\n        {\n            return null;\n        }\n        return findExecuteInParentHierarchy( parent, mojoAnnotatedClasses );\n    }\n\n\n    protected Map<String, ParameterAnnotationContent> getParametersParentHierarchy(\n        MojoAnnotatedClass mojoAnnotatedClass, Map<String, ParameterAnnotationContent> parameters,\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        List<ParameterAnnotationContent> parameterAnnotationContents = new ArrayList<ParameterAnnotationContent>();\n\n        parameterAnnotationContents =\n            getParametersParent( mojoAnnotatedClass, parameterAnnotationContents, mojoAnnotatedClasses );\n\n        // move to parent first to build the Map\n        Collections.reverse( parameterAnnotationContents );\n\n        Map<String, ParameterAnnotationContent> map =\n            new HashMap<String, ParameterAnnotationContent>( parameterAnnotationContents.size() );\n\n        for ( ParameterAnnotationContent parameterAnnotationContent : parameterAnnotationContents )\n        {\n            map.put( parameterAnnotationContent.getFieldName(), parameterAnnotationContent );\n        }\n        return map;\n    }\n\n    protected List<ParameterAnnotationContent> getParametersParent( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                    List<ParameterAnnotationContent> parameterAnnotationContents,\n                                                                    Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        parameterAnnotationContents.addAll( mojoAnnotatedClass.getParameters().values() );\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( parentClassName != null )\n        {\n            MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n            if ( parent != null )\n            {\n                return getParametersParent( parent, parameterAnnotationContents, mojoAnnotatedClasses );\n            }\n        }\n        return parameterAnnotationContents;\n    }\n\n\n    protected Map<String, ComponentAnnotationContent> getComponentsParentHierarchy(\n        MojoAnnotatedClass mojoAnnotatedClass, Map<String, ComponentAnnotationContent> components,\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        List<ComponentAnnotationContent> componentAnnotationContents = new ArrayList<ComponentAnnotationContent>();\n\n        componentAnnotationContents =\n            getComponentParent( mojoAnnotatedClass, componentAnnotationContents, mojoAnnotatedClasses );\n\n        // move to parent first to build the Map\n        Collections.reverse( componentAnnotationContents );\n\n        Map<String, ComponentAnnotationContent> map =\n            new HashMap<String, ComponentAnnotationContent>( componentAnnotationContents.size() );\n\n        for ( ComponentAnnotationContent componentAnnotationContent : componentAnnotationContents )\n        {\n            map.put( componentAnnotationContent.getFieldName(), componentAnnotationContent );\n        }\n        return map;\n    }\n\n    protected List<ComponentAnnotationContent> getComponentParent( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                   List<ComponentAnnotationContent> componentAnnotationContents,\n                                                                   Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        componentAnnotationContents.addAll( mojoAnnotatedClass.getComponents().values() );\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( parentClassName != null )\n        {\n            MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n            if ( parent != null )\n            {\n                return getComponentParent( parent, componentAnnotationContents, mojoAnnotatedClasses );\n            }\n        }\n        return componentAnnotationContents;\n    }\n\n    protected MavenProject getFromProjectReferences( Artifact artifact, MavenProject project )\n    {\n        if ( project.getProjectReferences() == null || project.getProjectReferences().isEmpty() )\n        {\n            return null;\n        }\n        @SuppressWarnings( \"unchecked\" )\n        Collection<MavenProject> mavenProjects = project.getProjectReferences().values();\n        for ( MavenProject mavenProject : mavenProjects )\n        {\n            if ( StringUtils.equals( mavenProject.getId(), artifact.getId() ) )\n            {\n                return mavenProject;\n            }\n        }\n        return null;\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.annotations;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport com.thoughtworks.qdox.JavaDocBuilder;\nimport com.thoughtworks.qdox.model.DocletTag;\nimport com.thoughtworks.qdox.model.JavaClass;\nimport com.thoughtworks.qdox.model.JavaField;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.plugin.descriptor.DuplicateParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ComponentAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ExecuteAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.MojoAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ParameterAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotatedClass;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScanner;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScannerRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.codehaus.plexus.archiver.UnArchiver;\nimport org.codehaus.plexus.archiver.manager.ArchiverManager;\nimport org.codehaus.plexus.archiver.manager.NoSuchArchiverException;\nimport org.codehaus.plexus.component.annotations.Component;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * JavaMojoDescriptorExtractor, a MojoDescriptor extractor to read descriptors from java classes with annotations.\n *\n * @author Olivier Lamy\n * @since 3.0\n */\n@Component( role = MojoDescriptorExtractor.class, hint = \"java-annotations\" )\npublic class JavaAnnotationsMojoDescriptorExtractor\n    extends AbstractLogEnabled\n    implements MojoDescriptorExtractor\n{\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private MojoAnnotationsScanner mojoAnnotationsScanner;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArtifactResolver artifactResolver;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArtifactFactory artifactFactory;\n\n    @org.codehaus.plexus.component.annotations.Requirement\n    private ArchiverManager archiverManager;\n\n    public List<MojoDescriptor> execute( MavenProject project, PluginDescriptor pluginDescriptor )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        return execute( new DefaultPluginToolsRequest( project, pluginDescriptor ) );\n    }\n\n    public List<MojoDescriptor> execute( PluginToolsRequest request )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n\n        MojoAnnotationsScannerRequest mojoAnnotationsScannerRequest = new MojoAnnotationsScannerRequest();\n\n        mojoAnnotationsScannerRequest.setClassesDirectories(\n            Arrays.asList( new File( request.getProject().getBuild().getOutputDirectory() ) ) );\n\n        mojoAnnotationsScannerRequest.setDependencies( request.getDependencies() );\n\n        mojoAnnotationsScannerRequest.setProject( request.getProject() );\n\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses =\n            mojoAnnotationsScanner.scan( mojoAnnotationsScannerRequest );\n\n        // found artifact from reactors to scan sources\n        // we currently only scan sources from reactors\n        List<MavenProject> mavenProjects = new ArrayList<MavenProject>();\n\n        // if we need to scan sources from external artifacts\n        Set<Artifact> externalArtifacts = new HashSet<Artifact>();\n\n        for ( MojoAnnotatedClass mojoAnnotatedClass : mojoAnnotatedClasses.values() )\n        {\n            if ( !StringUtils.equals( mojoAnnotatedClass.getArtifact().getArtifactId(),\n                                      request.getProject().getArtifact().getArtifactId() ) )\n            {\n                MavenProject mavenProject =\n                    getFromProjectReferences( mojoAnnotatedClass.getArtifact(), request.getProject() );\n                if ( mavenProject != null )\n                {\n                    mavenProjects.add( mavenProject );\n                }\n                else\n                {\n                    externalArtifacts.add( mojoAnnotatedClass.getArtifact() );\n                }\n            }\n        }\n\n        Map<String, JavaClass> javaClassesMap = new HashMap<String, JavaClass>();\n\n        // try to get artifact with classifier sources\n        // extract somewhere then scan doclet for @since, @deprecated\n        for ( Artifact artifact : externalArtifacts )\n        {\n            // parameter for test-sources too ?? olamy I need that for it test only\n            if ( StringUtils.equalsIgnoreCase( \"tests\", artifact.getClassifier() ) )\n            {\n                javaClassesMap.putAll( discoverClassesFromSourcesJar( artifact, request, \"test-sources\" ) );\n            }\n            else\n            {\n                javaClassesMap.putAll( discoverClassesFromSourcesJar( artifact, request, \"sources\" ) );\n            }\n\n        }\n\n        for ( MavenProject mavenProject : mavenProjects )\n        {\n            javaClassesMap.putAll( discoverClasses( request.getEncoding(), mavenProject ) );\n        }\n\n        javaClassesMap.putAll( discoverClasses( request ) );\n\n        populateDataFromJavadoc( mojoAnnotatedClasses, javaClassesMap );\n\n        return toMojoDescriptors( mojoAnnotatedClasses, request, javaClassesMap );\n\n    }\n\n\n    protected Map<String, JavaClass> discoverClassesFromSourcesJar( Artifact artifact, PluginToolsRequest request,\n                                                                    String classifier )\n        throws ExtractionException\n    {\n        try\n        {\n            Artifact sourcesArtifact =\n                artifactFactory.createArtifactWithClassifier( artifact.getGroupId(), artifact.getArtifactId(),\n                                                              artifact.getVersion(), artifact.getType(), classifier );\n\n            artifactResolver.resolve( sourcesArtifact, request.getRemoteRepos(), request.getLocal() );\n            if ( sourcesArtifact.getFile() != null && sourcesArtifact.getFile().exists() )\n            {\n                File extractDirectory = new File( request.getProject().getBuild().getDirectory(),\n                                                  \"maven-plugin-plugin-sources/\" + sourcesArtifact.getGroupId() + \"/\"\n                                                      + sourcesArtifact.getArtifactId() + \"/\"\n                                                      + sourcesArtifact.getVersion() + \"/\"\n                                                      + sourcesArtifact.getClassifier() );\n                if ( !extractDirectory.exists() )\n                {\n                    extractDirectory.mkdirs();\n                }\n                // extract sources in a directory\n                //target/maven-plugin-plugin/${groupId}/${artifact}/sources\n                UnArchiver unArchiver = archiverManager.getUnArchiver( \"jar\" );\n                unArchiver.setSourceFile( sourcesArtifact.getFile() );\n                unArchiver.setDestDirectory( extractDirectory );\n                unArchiver.extract();\n\n                return discoverClasses( request.getEncoding(), Arrays.asList( extractDirectory ) );\n            }\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            //throw new ExtractionException( e.getMessage(), e );\n            getLogger().debug( \"skip ArtifactNotFoundException:\" + e.getMessage() );\n            getLogger().warn(\n                \"Impossible to get sources artifact for \" + artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\"\n                    + artifact.getVersion() + \". Some javadoc tags (@since, @deprecated and comments) won't be used\" );\n        }\n        catch ( NoSuchArchiverException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n        return Collections.emptyMap();\n    }\n\n    /**\n     * from sources scan to get @since and @deprecated and description of classes and fields.\n     *\n     * @param mojoAnnotatedClasses\n     * @param javaClassesMap\n     */\n    protected void populateDataFromJavadoc( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                            Map<String, JavaClass> javaClassesMap )\n    {\n\n        for ( Map.Entry<String, MojoAnnotatedClass> entry : mojoAnnotatedClasses.entrySet() )\n        {\n            JavaClass javaClass = javaClassesMap.get( entry.getKey() );\n            if ( javaClass != null )\n            {\n                MojoAnnotationContent mojoAnnotationContent = entry.getValue().getMojo();\n                if ( mojoAnnotationContent != null )\n                {\n                    mojoAnnotationContent.setDescription( javaClass.getComment() );\n                    DocletTag since = findInClassHierarchy( javaClass, \"since\" );\n                    if ( since != null )\n                    {\n                        mojoAnnotationContent.setSince( since.getValue() );\n                    }\n\n                    DocletTag deprecated = findInClassHierarchy( javaClass, \"deprecated\" );\n                    if ( deprecated != null )\n                    {\n                        mojoAnnotationContent.setDeprecated( deprecated.getValue() );\n                    }\n                }\n                Map<String, JavaField> fieldsMap =\n                    extractFieldParameterTags( javaClass, javaClassesMap, mojoAnnotatedClasses );\n                Map<String, ParameterAnnotationContent> parameters =\n                    getParametersParentHierarchy( entry.getValue(), new HashMap<String, ParameterAnnotationContent>(),\n                                                  mojoAnnotatedClasses );\n                for ( Map.Entry<String, ParameterAnnotationContent> parameter : new TreeMap<String, ParameterAnnotationContent>(\n                    parameters ).entrySet() )\n                {\n                    JavaField javaField = fieldsMap.get( parameter.getKey() );\n                    if ( javaField != null )\n                    {\n                        ParameterAnnotationContent parameterAnnotationContent = parameter.getValue();\n                        DocletTag deprecated = javaField.getTagByName( \"deprecated\" );\n                        if ( deprecated != null )\n                        {\n                            parameterAnnotationContent.setDeprecated( deprecated.getValue() );\n                        }\n                        DocletTag since = javaField.getTagByName( \"since\" );\n                        if ( since != null )\n                        {\n                            parameterAnnotationContent.setSince( since.getValue() );\n                        }\n                        parameterAnnotationContent.setDescription( javaField.getComment() );\n                    }\n                }\n\n                for ( Map.Entry<String, ComponentAnnotationContent> component : entry.getValue().getComponents().entrySet() )\n                {\n                    JavaField javaField = fieldsMap.get( component.getKey() );\n                    if ( javaField != null )\n                    {\n                        ComponentAnnotationContent componentAnnotationContent = component.getValue();\n                        DocletTag deprecated = javaField.getTagByName( \"deprecated\" );\n                        if ( deprecated != null )\n                        {\n                            componentAnnotationContent.setDeprecated( deprecated.getValue() );\n                        }\n                        DocletTag since = javaField.getTagByName( \"since\" );\n                        if ( since != null )\n                        {\n                            componentAnnotationContent.setSince( since.getValue() );\n                        }\n                        componentAnnotationContent.setDescription( javaField.getComment() );\n                    }\n                }\n\n            }\n        }\n\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName   not null\n     * @return docletTag instance\n     */\n    private DocletTag findInClassHierarchy( JavaClass javaClass, String tagName )\n    {\n        DocletTag tag = javaClass.getTagByName( tagName );\n\n        if ( tag == null )\n        {\n            JavaClass superClass = javaClass.getSuperJavaClass();\n\n            if ( superClass != null )\n            {\n                tag = findInClassHierarchy( superClass, tagName );\n            }\n        }\n\n        return tag;\n    }\n\n    /**\n     * extract fields that are either parameters or components.\n     *\n     * @param javaClass not null\n     * @return map with Mojo parameters names as keys\n     */\n    private Map<String, JavaField> extractFieldParameterTags( JavaClass javaClass,\n                                                              Map<String, JavaClass> javaClassesMap,\n                                                              Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        Map<String, JavaField> rawParams = new TreeMap<String, com.thoughtworks.qdox.model.JavaField>();\n\n        // we have to add the parent fields first, so that they will be overwritten by the local fields if\n        // that actually happens...\n        JavaClass superClass = javaClass.getSuperJavaClass();\n\n        if ( superClass != null )\n        {\n            if ( superClass.getFields().length > 0 )\n            {\n                rawParams = extractFieldParameterTags( superClass, javaClassesMap, mojoAnnotatedClasses );\n            }\n            // maybe sources comes from scan of sources artifact\n            superClass = javaClassesMap.get( superClass.getFullyQualifiedName() );\n            if ( superClass != null )\n            {\n                rawParams = extractFieldParameterTags( superClass, javaClassesMap, mojoAnnotatedClasses );\n            }\n        }\n        else\n        {\n\n            rawParams = new TreeMap<String, JavaField>();\n        }\n\n        JavaField[] classFields = javaClass.getFields();\n\n        if ( classFields != null )\n        {\n            for ( JavaField field : classFields )\n            {\n                rawParams.put( field.getName(), field );\n            }\n        }\n        return rawParams;\n    }\n\n    protected Map<String, JavaClass> discoverClasses( final PluginToolsRequest request )\n    {\n        return discoverClasses( request.getEncoding(), request.getProject() );\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    protected Map<String, JavaClass> discoverClasses( final String encoding, final MavenProject project )\n    {\n        List<File> sources = new ArrayList<File>();\n\n        for ( String source : (List<String>) project.getCompileSourceRoots() )\n        {\n            sources.add( new File( source ) );\n        }\n\n        // TODO be more dynamic\n        File generatedPlugin = new File( project.getBasedir(), \"target/generated-sources/plugin\" );\n        if ( !project.getCompileSourceRoots().contains( generatedPlugin.getAbsolutePath() )\n            && generatedPlugin.exists() )\n        {\n            sources.add( generatedPlugin );\n        }\n\n        return discoverClasses( encoding, sources );\n    }\n\n    protected Map<String, JavaClass> discoverClasses( final String encoding, List<File> sourceDirectories )\n    {\n        JavaDocBuilder builder = new JavaDocBuilder();\n        builder.setEncoding( encoding );\n\n        for ( File source : sourceDirectories )\n        {\n            builder.addSourceTree( source );\n        }\n\n        JavaClass[] javaClasses = builder.getClasses();\n\n        if ( javaClasses == null || javaClasses.length < 1 )\n        {\n            return Collections.emptyMap();\n        }\n\n        Map<String, JavaClass> javaClassMap = new HashMap<String, JavaClass>( javaClasses.length );\n\n        for ( JavaClass javaClass : javaClasses )\n        {\n            javaClassMap.put( javaClass.getFullyQualifiedName(), javaClass );\n        }\n\n        return javaClassMap;\n    }\n\n    private List<MojoDescriptor> toMojoDescriptors( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                                    PluginToolsRequest request, Map<String, JavaClass> javaClassesMap )\n        throws DuplicateParameterException, InvalidParameterException\n    {\n        List<MojoDescriptor> mojoDescriptors = new ArrayList<MojoDescriptor>( mojoAnnotatedClasses.size() );\n        for ( MojoAnnotatedClass mojoAnnotatedClass : mojoAnnotatedClasses.values() )\n        {\n            // no mojo so skip it\n            if ( mojoAnnotatedClass.getMojo() == null )\n            {\n                continue;\n            }\n\n            ExtendedMojoDescriptor mojoDescriptor = new ExtendedMojoDescriptor();\n\n            //mojoDescriptor.setRole( mojoAnnotatedClass.getClassName() );\n            //mojoDescriptor.setRoleHint( \"default\" );\n            mojoDescriptor.setImplementation( mojoAnnotatedClass.getClassName() );\n            mojoDescriptor.setLanguage( \"java\" );\n\n            MojoAnnotationContent mojo = mojoAnnotatedClass.getMojo();\n\n            mojoDescriptor.setDescription( mojo.getDescription() );\n            mojoDescriptor.setSince( mojo.getSince() );\n            mojo.setDeprecated( mojo.getDeprecated() );\n\n            mojoDescriptor.setAggregator( mojo.aggregator() );\n            mojoDescriptor.setDependencyResolutionRequired( mojo.requiresDependencyResolution().id() );\n            mojoDescriptor.setDependencyCollectionRequired( mojo.requiresDependencyCollection().id() );\n\n            mojoDescriptor.setDirectInvocationOnly( mojo.requiresDirectInvocation() );\n            mojoDescriptor.setDeprecated( mojo.getDeprecated() );\n            mojoDescriptor.setThreadSafe( mojo.threadSafe() );\n\n            ExecuteAnnotationContent execute = findExecuteInParentHierarchy( mojoAnnotatedClass, mojoAnnotatedClasses );\n            if ( execute != null )\n            {\n                mojoDescriptor.setExecuteGoal( execute.goal() );\n                mojoDescriptor.setExecuteLifecycle( execute.lifecycle() );\n                mojoDescriptor.setExecutePhase( execute.phase().id() );\n            }\n\n            mojoDescriptor.setExecutionStrategy( mojo.executionStrategy() );\n            // ???\n            //mojoDescriptor.alwaysExecute(mojo.a)\n\n            mojoDescriptor.setGoal( mojo.name() );\n            mojoDescriptor.setOnlineRequired( mojo.requiresOnline() );\n\n            mojoDescriptor.setPhase( mojo.defaultPhase().id() );\n\n            Map<String, ParameterAnnotationContent> parameters =\n                getParametersParentHierarchy( mojoAnnotatedClass, new HashMap<String, ParameterAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n\n            for ( ParameterAnnotationContent parameterAnnotationContent : new TreeSet<ParameterAnnotationContent>(\n                parameters.values() ) )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                parameter.setName( parameterAnnotationContent.getFieldName() );\n                parameter.setAlias( parameterAnnotationContent.alias() );\n                parameter.setDefaultValue( parameterAnnotationContent.defaultValue() );\n                parameter.setDeprecated( parameterAnnotationContent.getDeprecated() );\n                parameter.setDescription( parameterAnnotationContent.getDescription() );\n                parameter.setEditable( !parameterAnnotationContent.readonly() );\n                String property = parameterAnnotationContent.property();\n                if ( StringUtils.contains( property, '$' ) || StringUtils.contains( property, '{' )\n                    || StringUtils.contains( property, '}' ) )\n                {\n                    throw new InvalidParameterException( \"Invalid property for parameter '\" + parameter.getName() + \"', \"\n                                                         + \"forbidden characters ${}: \" + property, null );\n                }\n                parameter.setExpression( StringUtils.isEmpty( property ) ? \"\" : \"${\" + property + \"}\" );\n                parameter.setType( parameterAnnotationContent.getClassName() );\n                parameter.setSince( parameterAnnotationContent.getSince() );\n                parameter.setRequired( parameterAnnotationContent.required() );\n\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            Map<String, ComponentAnnotationContent> components =\n                getComponentsParentHierarchy( mojoAnnotatedClass, new HashMap<String, ComponentAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n\n            for ( ComponentAnnotationContent componentAnnotationContent : new TreeSet<ComponentAnnotationContent>(\n                components.values() ) )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                parameter.setName( componentAnnotationContent.getFieldName() );\n                parameter.setRequirement(\n                    new Requirement( componentAnnotationContent.role(), componentAnnotationContent.roleHint() ) );\n                parameter.setDeprecated( componentAnnotationContent.getDeprecated() );\n                parameter.setSince( componentAnnotationContent.getSince() );\n\n                // same behaviour as JavaMojoDescriptorExtractor\n                //parameter.setRequired( ... );\n                parameter.setEditable( false );\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            mojoDescriptor.setPluginDescriptor( request.getPluginDescriptor() );\n\n            mojoDescriptors.add( mojoDescriptor );\n        }\n        return mojoDescriptors;\n    }\n\n\n    protected ExecuteAnnotationContent findExecuteInParentHierarchy( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                     Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n\n        if ( mojoAnnotatedClass.getExecute() != null )\n        {\n            return mojoAnnotatedClass.getExecute();\n        }\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( StringUtils.isEmpty( parentClassName ) )\n        {\n            return null;\n        }\n        MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n        if ( parent == null )\n        {\n            return null;\n        }\n        return findExecuteInParentHierarchy( parent, mojoAnnotatedClasses );\n    }\n\n\n    protected Map<String, ParameterAnnotationContent> getParametersParentHierarchy(\n        MojoAnnotatedClass mojoAnnotatedClass, Map<String, ParameterAnnotationContent> parameters,\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        List<ParameterAnnotationContent> parameterAnnotationContents = new ArrayList<ParameterAnnotationContent>();\n\n        parameterAnnotationContents =\n            getParametersParent( mojoAnnotatedClass, parameterAnnotationContents, mojoAnnotatedClasses );\n\n        // move to parent first to build the Map\n        Collections.reverse( parameterAnnotationContents );\n\n        Map<String, ParameterAnnotationContent> map =\n            new HashMap<String, ParameterAnnotationContent>( parameterAnnotationContents.size() );\n\n        for ( ParameterAnnotationContent parameterAnnotationContent : parameterAnnotationContents )\n        {\n            map.put( parameterAnnotationContent.getFieldName(), parameterAnnotationContent );\n        }\n        return map;\n    }\n\n    protected List<ParameterAnnotationContent> getParametersParent( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                    List<ParameterAnnotationContent> parameterAnnotationContents,\n                                                                    Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        parameterAnnotationContents.addAll( mojoAnnotatedClass.getParameters().values() );\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( parentClassName != null )\n        {\n            MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n            if ( parent != null )\n            {\n                return getParametersParent( parent, parameterAnnotationContents, mojoAnnotatedClasses );\n            }\n        }\n        return parameterAnnotationContents;\n    }\n\n\n    protected Map<String, ComponentAnnotationContent> getComponentsParentHierarchy(\n        MojoAnnotatedClass mojoAnnotatedClass, Map<String, ComponentAnnotationContent> components,\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        List<ComponentAnnotationContent> componentAnnotationContents = new ArrayList<ComponentAnnotationContent>();\n\n        componentAnnotationContents =\n            getComponentParent( mojoAnnotatedClass, componentAnnotationContents, mojoAnnotatedClasses );\n\n        // move to parent first to build the Map\n        Collections.reverse( componentAnnotationContents );\n\n        Map<String, ComponentAnnotationContent> map =\n            new HashMap<String, ComponentAnnotationContent>( componentAnnotationContents.size() );\n\n        for ( ComponentAnnotationContent componentAnnotationContent : componentAnnotationContents )\n        {\n            map.put( componentAnnotationContent.getFieldName(), componentAnnotationContent );\n        }\n        return map;\n    }\n\n    protected List<ComponentAnnotationContent> getComponentParent( MojoAnnotatedClass mojoAnnotatedClass,\n                                                                   List<ComponentAnnotationContent> componentAnnotationContents,\n                                                                   Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        componentAnnotationContents.addAll( mojoAnnotatedClass.getComponents().values() );\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( parentClassName != null )\n        {\n            MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n            if ( parent != null )\n            {\n                return getComponentParent( parent, componentAnnotationContents, mojoAnnotatedClasses );\n            }\n        }\n        return componentAnnotationContents;\n    }\n\n    protected MavenProject getFromProjectReferences( Artifact artifact, MavenProject project )\n    {\n        if ( project.getProjectReferences() == null || project.getProjectReferences().isEmpty() )\n        {\n            return null;\n        }\n        @SuppressWarnings( \"unchecked\" )\n        Collection<MavenProject> mavenProjects = project.getProjectReferences().values();\n        for ( MavenProject mavenProject : mavenProjects )\n        {\n            if ( StringUtils.equals( mavenProject.getId(), artifact.getId() ) )\n            {\n                return mavenProject;\n            }\n        }\n        return null;\n    }\n\n}\n","lineNo":117}
{"Refactored Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.DuplicateMojoDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.PrettyPrintXMLWriter;\nimport org.codehaus.plexus.util.xml.XMLWriter;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.commons.RemappingClassAdapter;\nimport org.objectweb.asm.commons.SimpleRemapper;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\n/**\n * @version $Id$\n * @todo add example usage tag that can be shown in the doco\n * @todo need to add validation directives so that systems embedding maven2 can\n * get validation directives to help users in IDEs.\n */\npublic class PluginDescriptorGenerator\n    implements Generator\n{\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws GeneratorException\n    {\n\n        File tmpPropertiesFile =\n            new File( request.getProject().getBuild().getDirectory(), \"maven-plugin-help.properties\" );\n\n        if ( tmpPropertiesFile.exists() )\n        {\n            Properties properties = new Properties();\n            FileInputStream fis = null;\n            try\n            {\n                fis = new FileInputStream( tmpPropertiesFile );\n                properties.load( fis );\n            }\n            catch ( IOException e )\n            {\n                throw new GeneratorException( e.getMessage(), e );\n            }\n            finally\n            {\n                IOUtil.close( fis );\n            }\n            String helpPackageName = properties.getProperty( \"helpPackageName\" );\n            // if helpPackageName property is empty we have to rewrite the class with a better package name than empty\n            if ( StringUtils.isEmpty( helpPackageName ) )\n            {\n                String helpMojoImplementation = rewriteHelpClassToMojoPackage( request );\n                if ( helpMojoImplementation != null )\n                {\n                    // rewrite plugin descriptor with new HelpMojo implementation class\n                    rewriteDescriptor( request.getPluginDescriptor(), helpMojoImplementation );\n                }\n\n            }\n        }\n\n        try\n        {\n            File f = new File( destinationDirectory, \"plugin.xml\" );\n            writeDescriptor( f, request, false );\n            MavenProject mavenProject = request.getProject();\n            String pluginDescriptionFilePath =\n                \"META-INF/maven/\" + mavenProject.getGroupId() + \"/\" + mavenProject.getArtifactId()\n                    + \"/plugin-description.xml\";\n            f = new File( request.getProject().getBuild().getOutputDirectory(), pluginDescriptionFilePath );\n            writeDescriptor( f, request, true );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n        catch ( DuplicateMojoDescriptorException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n    }\n\n    public void writeDescriptor( File destinationFile, PluginToolsRequest request, boolean cleanDescription )\n        throws IOException, DuplicateMojoDescriptorException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n\n        if ( destinationFile.exists() )\n        {\n            destinationFile.delete();\n        }\n        else\n        {\n            if ( !destinationFile.getParentFile().exists() )\n            {\n                destinationFile.getParentFile().mkdirs();\n            }\n        }\n\n        String encoding = \"UTF-8\";\n\n        Writer writer = null;\n        try\n        {\n            writer = new OutputStreamWriter( new FileOutputStream( destinationFile ), encoding );\n\n            XMLWriter w = new PrettyPrintXMLWriter( writer, encoding, null );\n\n            w.startElement( \"plugin\" );\n\n            PluginUtils.element( w, \"name\", pluginDescriptor.getName() );\n            if ( cleanDescription )\n            {\n                PluginUtils.element( w, \"description\", PluginUtils.toText( pluginDescriptor.getDescription() ) );\n            }\n            else\n            {\n                PluginUtils.element( w, \"description\", pluginDescriptor.getDescription() );\n            }\n\n            PluginUtils.element( w, \"groupId\", pluginDescriptor.getGroupId() );\n\n            PluginUtils.element( w, \"artifactId\", pluginDescriptor.getArtifactId() );\n\n            PluginUtils.element( w, \"version\", pluginDescriptor.getVersion() );\n\n            PluginUtils.element( w, \"goalPrefix\", pluginDescriptor.getGoalPrefix() );\n\n            PluginUtils.element( w, \"isolatedRealm\", \"\" + pluginDescriptor.isIsolatedRealm() );\n\n            PluginUtils.element( w, \"inheritedByDefault\", \"\" + pluginDescriptor.isInheritedByDefault() );\n\n            w.startElement( \"mojos\" );\n\n            if ( pluginDescriptor.getMojos() != null )\n            {\n                @SuppressWarnings( \"unchecked\" ) List<MojoDescriptor> descriptors = pluginDescriptor.getMojos();\n                for ( MojoDescriptor descriptor : descriptors )\n                {\n                    processMojoDescriptor( descriptor, w, cleanDescription );\n                }\n            }\n\n            w.endElement();\n\n            PluginUtils.writeDependencies( w, pluginDescriptor );\n\n            w.endElement();\n\n            writer.flush();\n\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        processMojoDescriptor( mojoDescriptor, w, false );\n    }\n\n    /**\n     * @param mojoDescriptor   not null\n     * @param w                not null\n     * @param cleanDescription will clean html content from description fields\n     */\n    protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, XMLWriter w, boolean cleanDescription )\n    {\n        w.startElement( \"mojo\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"goal\" );\n        w.writeText( mojoDescriptor.getGoal() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        String description = mojoDescriptor.getDescription();\n\n        if ( description != null )\n        {\n            w.startElement( \"description\" );\n            if ( cleanDescription )\n            {\n                w.writeText( PluginUtils.toText( mojoDescriptor.getDescription() ) );\n            }\n            else\n            {\n                w.writeText( mojoDescriptor.getDescription() );\n            }\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.isDependencyResolutionRequired() != null )\n        {\n            PluginUtils.element( w, \"requiresDependencyResolution\", mojoDescriptor.isDependencyResolutionRequired() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        PluginUtils.element( w, \"requiresDirectInvocation\", \"\" + mojoDescriptor.isDirectInvocationOnly() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        PluginUtils.element( w, \"requiresProject\", \"\" + mojoDescriptor.isProjectRequired() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        PluginUtils.element( w, \"requiresReports\", \"\" + mojoDescriptor.isRequiresReports() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        PluginUtils.element( w, \"aggregator\", \"\" + mojoDescriptor.isAggregator() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        PluginUtils.element( w, \"requiresOnline\", \"\" + mojoDescriptor.isOnlineRequired() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        PluginUtils.element( w, \"inheritedByDefault\", \"\" + mojoDescriptor.isInheritedByDefault() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getPhase() != null )\n        {\n            PluginUtils.element( w, \"phase\", mojoDescriptor.getPhase() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getExecutePhase() != null )\n        {\n            PluginUtils.element( w, \"executePhase\", mojoDescriptor.getExecutePhase() );\n        }\n\n        if ( mojoDescriptor.getExecuteGoal() != null )\n        {\n            PluginUtils.element( w, \"executeGoal\", mojoDescriptor.getExecuteGoal() );\n        }\n\n        if ( mojoDescriptor.getExecuteLifecycle() != null )\n        {\n            PluginUtils.element( w, \"executeLifecycle\", mojoDescriptor.getExecuteLifecycle() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"implementation\" );\n        w.writeText( mojoDescriptor.getImplementation() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"language\" );\n        w.writeText( mojoDescriptor.getLanguage() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getComponentConfigurator() != null )\n        {\n            w.startElement( \"configurator\" );\n            w.writeText( mojoDescriptor.getComponentConfigurator() );\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getComponentComposer() != null )\n        {\n            w.startElement( \"composer\" );\n            w.writeText( mojoDescriptor.getComponentComposer() );\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"instantiationStrategy\" );\n        w.writeText( mojoDescriptor.getInstantiationStrategy() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Strategy for handling repeated reference to mojo in\n        // the calculated (decorated, resolved) execution stack\n        // ----------------------------------------------------------------------\n        w.startElement( \"executionStrategy\" );\n        w.writeText( mojoDescriptor.getExecutionStrategy() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getDeprecated() != null )\n        {\n            w.startElement( \"deprecated\" );\n\n            if ( StringUtils.isEmpty( mojoDescriptor.getDeprecated() ) )\n            {\n                w.writeText( \"No reason given\" );\n            }\n            else\n            {\n                w.writeText( mojoDescriptor.getDeprecated() );\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Extended (3.0) descriptor\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor instanceof ExtendedMojoDescriptor )\n        {\n            ExtendedMojoDescriptor extendedMojoDescriptor = (ExtendedMojoDescriptor) mojoDescriptor;\n            if ( extendedMojoDescriptor.getDependencyCollectionRequired() != null )\n            {\n                PluginUtils.element( w, \"requiresDependencyCollection\",\n                                     extendedMojoDescriptor.getDependencyCollectionRequired() );\n            }\n\n            PluginUtils.element( w, \"threadSafe\", String.valueOf( extendedMojoDescriptor.isThreadSafe() ) );\n        }\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        @SuppressWarnings( \"unchecked\" ) List<Parameter> parameters = mojoDescriptor.getParameters();\n\n        w.startElement( \"parameters\" );\n\n        Map<String, Requirement> requirements = new LinkedHashMap<String, Requirement>();\n\n        Set<Parameter> configuration = new LinkedHashSet<Parameter>();\n\n        if ( parameters != null )\n        {\n            for ( Parameter parameter : parameters )\n            {\n                String expression = parameter.getExpression();\n\n                if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${component.\" ) )\n                {\n                    // treat it as a component...a requirement, in other words.\n\n                    // remove \"component.\" plus expression delimiters\n                    String role = expression.substring( \"${component.\".length(), expression.length() - 1 );\n\n                    String roleHint = null;\n\n                    int posRoleHintSeparator = role.indexOf( \"#\" );\n                    if ( posRoleHintSeparator > 0 )\n                    {\n                        roleHint = role.substring( posRoleHintSeparator + 1 );\n\n                        role = role.substring( 0, posRoleHintSeparator );\n                    }\n\n                    // TODO: remove deprecated expression\n                    requirements.put( parameter.getName(), new Requirement( role, roleHint ) );\n                }\n                else if ( parameter.getRequirement() != null )\n                {\n                    requirements.put( parameter.getName(), parameter.getRequirement() );\n                }\n                else\n                {\n                    // treat it as a normal parameter.\n\n                    w.startElement( \"parameter\" );\n\n                    PluginUtils.element( w, \"name\", parameter.getName() );\n\n                    if ( parameter.getAlias() != null )\n                    {\n                        PluginUtils.element( w, \"alias\", parameter.getAlias() );\n                    }\n\n                    PluginUtils.element( w, \"type\", parameter.getType() );\n\n                    if ( parameter.getDeprecated() != null )\n                    {\n                        if ( StringUtils.isEmpty( parameter.getDeprecated() ) )\n                        {\n                            PluginUtils.element( w, \"deprecated\", \"No reason given\" );\n                        }\n                        else\n                        {\n                            PluginUtils.element( w, \"deprecated\", parameter.getDeprecated() );\n                        }\n                    }\n\n                    if ( parameter.getImplementation() != null )\n                    {\n                        PluginUtils.element( w, \"implementation\", parameter.getImplementation() );\n                    }\n\n                    PluginUtils.element( w, \"required\", Boolean.toString( parameter.isRequired() ) );\n\n                    PluginUtils.element( w, \"editable\", Boolean.toString( parameter.isEditable() ) );\n                    if ( cleanDescription )\n                    {\n                        PluginUtils.element( w, \"description\", PluginUtils.toText( parameter.getDescription() ) );\n                    }\n                    else\n                    {\n                        PluginUtils.element( w, \"description\", parameter.getDescription() );\n                    }\n\n                    if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) || StringUtils.isNotEmpty(\n                        parameter.getExpression() ) )\n                    {\n                        configuration.add( parameter );\n                    }\n\n                    w.endElement();\n                }\n\n            }\n        }\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Configuration\n        // ----------------------------------------------------------------------\n\n        if ( !configuration.isEmpty() )\n        {\n            w.startElement( \"configuration\" );\n\n            for ( Parameter parameter : configuration )\n            {\n                w.startElement( parameter.getName() );\n\n                String type = parameter.getType();\n                if ( type != null )\n                {\n                    w.addAttribute( \"implementation\", type );\n                }\n\n                if ( parameter.getDefaultValue() != null )\n                {\n                    w.addAttribute( \"default-value\", parameter.getDefaultValue() );\n                }\n\n                if ( parameter.getExpression() != null )\n                {\n                    w.writeText( parameter.getExpression() );\n                }\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        if ( !requirements.isEmpty() )\n        {\n            w.startElement( \"requirements\" );\n\n            for ( Map.Entry<String, Requirement> entry : requirements.entrySet() )\n            {\n                String key = entry.getKey();\n                Requirement requirement = entry.getValue();\n\n                w.startElement( \"requirement\" );\n\n                PluginUtils.element( w, \"role\", requirement.getRole() );\n\n                if ( requirement.getRoleHint() != null )\n                {\n                    PluginUtils.element( w, \"role-hint\", requirement.getRoleHint() );\n                }\n\n                PluginUtils.element( w, \"field-name\", key );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        w.endElement();\n    }\n\n    protected String rewriteHelpClassToMojoPackage( PluginToolsRequest request )\n        throws GeneratorException\n    {\n        String destinationPackage = PluginUtils.discoverPackageName( request.getPluginDescriptor() );\n        if ( StringUtils.isEmpty( destinationPackage ) )\n        {\n            return null;\n        }\n        File helpClassFile = new File( request.getProject().getBuild().getOutputDirectory(), \"HelpMojo.class\" );\n        if ( !helpClassFile.exists() )\n        {\n            return null;\n        }\n        File rewriteHelpClassFile = new File(\n            request.getProject().getBuild().getOutputDirectory() + \"/\" + StringUtils.replace( destinationPackage, \".\",\n                                                                                              \"/\" ), \"HelpMojo.class\" );\n        if ( !rewriteHelpClassFile.getParentFile().exists() )\n        {\n            rewriteHelpClassFile.getParentFile().mkdirs();\n        }\n\n        ClassReader cr = null;\n        try\n        {\n            cr = new ClassReader( new FileInputStream( helpClassFile ) );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n\n        ClassWriter cw = new ClassWriter( 0 );\n\n        ClassVisitor cv = new RemappingClassAdapter( cw, new SimpleRemapper( \"HelpMojo\",\n                                                                             StringUtils.replace( destinationPackage,\n                                                                                                  \".\", \"/\" )\n                                                                                 + \"/HelpMojo\" ) );\n\n        try\n        {\n            cr.accept( cv, ClassReader.EXPAND_FRAMES );\n        }\n        catch ( Throwable e )\n        {\n            throw new GeneratorException( \"ASM issue processing classFile \" + helpClassFile.getPath(), e );\n        }\n\n        byte[] renamedClass = cw.toByteArray();\n        FileOutputStream fos = null;\n        try\n        {\n            fos = new FileOutputStream( rewriteHelpClassFile );\n            fos.write( renamedClass );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( \"Error rewriting help class: \" + e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( fos );\n        }\n        helpClassFile.delete();\n        return destinationPackage + \".HelpMojo\";\n    }\n\n\n    private void rewriteDescriptor( PluginDescriptor pluginDescriptor, String helpMojoImplementation )\n    {\n        MojoDescriptor mojoDescriptor = pluginDescriptor.getMojo( \"help\" );\n        if ( mojoDescriptor != null )\n        {\n            mojoDescriptor.setImplementation( helpMojoImplementation );\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.DuplicateMojoDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.PrettyPrintXMLWriter;\nimport org.codehaus.plexus.util.xml.XMLWriter;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.commons.RemappingClassAdapter;\nimport org.objectweb.asm.commons.SimpleRemapper;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\n/**\n * @version $Id$\n * @todo add example usage tag that can be shown in the doco\n * @todo need to add validation directives so that systems embedding maven2 can\n * get validation directives to help users in IDEs.\n */\npublic class PluginDescriptorGenerator\n    implements Generator\n{\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws GeneratorException\n    {\n\n        File tmpPropertiesFile =\n            new File( request.getProject().getBuild().getDirectory(), \"maven-plugin-help.properties\" );\n\n        if ( tmpPropertiesFile.exists() )\n        {\n            Properties properties = new Properties();\n            try\n            {\n                properties.load( new FileInputStream( tmpPropertiesFile ) );\n            }\n            catch ( IOException e )\n            {\n                throw new GeneratorException( e.getMessage(), e );\n            }\n            String helpPackageName = properties.getProperty( \"helpPackageName\" );\n            // if helpPackageName property is empty we have to rewrite the class with a better package name than empty\n            if ( StringUtils.isEmpty( helpPackageName ) )\n            {\n                String helpMojoImplementation = rewriteHelpClassToMojoPackage( request );\n                if ( helpMojoImplementation != null )\n                {\n                    // rewrite plugin descriptor with new HelpMojo implementation class\n                    rewriteDescriptor( request.getPluginDescriptor(), helpMojoImplementation );\n                }\n\n            }\n        }\n\n        try\n        {\n            File f = new File( destinationDirectory, \"plugin.xml\" );\n            writeDescriptor( f, request, false );\n            MavenProject mavenProject = request.getProject();\n            String pluginDescriptionFilePath =\n                \"META-INF/maven/\" + mavenProject.getGroupId() + \"/\" + mavenProject.getArtifactId()\n                    + \"/plugin-description.xml\";\n            f = new File( request.getProject().getBuild().getOutputDirectory(), pluginDescriptionFilePath );\n            writeDescriptor( f, request, true );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n        catch ( DuplicateMojoDescriptorException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n    }\n\n    public void writeDescriptor( File destinationFile, PluginToolsRequest request, boolean cleanDescription )\n        throws IOException, DuplicateMojoDescriptorException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n\n        if ( destinationFile.exists() )\n        {\n            destinationFile.delete();\n        }\n        else\n        {\n            if ( !destinationFile.getParentFile().exists() )\n            {\n                destinationFile.getParentFile().mkdirs();\n            }\n        }\n\n        String encoding = \"UTF-8\";\n\n        Writer writer = null;\n        try\n        {\n            writer = new OutputStreamWriter( new FileOutputStream( destinationFile ), encoding );\n\n            XMLWriter w = new PrettyPrintXMLWriter( writer, encoding, null );\n\n            w.startElement( \"plugin\" );\n\n            PluginUtils.element( w, \"name\", pluginDescriptor.getName() );\n            if ( cleanDescription )\n            {\n                PluginUtils.element( w, \"description\", PluginUtils.toText( pluginDescriptor.getDescription() ) );\n            }\n            else\n            {\n                PluginUtils.element( w, \"description\", pluginDescriptor.getDescription() );\n            }\n\n            PluginUtils.element( w, \"groupId\", pluginDescriptor.getGroupId() );\n\n            PluginUtils.element( w, \"artifactId\", pluginDescriptor.getArtifactId() );\n\n            PluginUtils.element( w, \"version\", pluginDescriptor.getVersion() );\n\n            PluginUtils.element( w, \"goalPrefix\", pluginDescriptor.getGoalPrefix() );\n\n            PluginUtils.element( w, \"isolatedRealm\", \"\" + pluginDescriptor.isIsolatedRealm() );\n\n            PluginUtils.element( w, \"inheritedByDefault\", \"\" + pluginDescriptor.isInheritedByDefault() );\n\n            w.startElement( \"mojos\" );\n\n            if ( pluginDescriptor.getMojos() != null )\n            {\n                @SuppressWarnings( \"unchecked\" )\n                List<MojoDescriptor> descriptors = pluginDescriptor.getMojos();\n                for ( MojoDescriptor descriptor : descriptors )\n                {\n                    processMojoDescriptor( descriptor, w, cleanDescription );\n                }\n            }\n\n            w.endElement();\n\n            PluginUtils.writeDependencies( w, pluginDescriptor );\n\n            w.endElement();\n\n            writer.flush();\n\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        processMojoDescriptor( mojoDescriptor, w, false );\n    }\n\n    /**\n     * @param mojoDescriptor   not null\n     * @param w                not null\n     * @param cleanDescription will clean html content from description fields\n     */\n    protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, XMLWriter w, boolean cleanDescription )\n    {\n        w.startElement( \"mojo\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"goal\" );\n        w.writeText( mojoDescriptor.getGoal() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        String description = mojoDescriptor.getDescription();\n\n        if ( description != null )\n        {\n            w.startElement( \"description\" );\n            if ( cleanDescription )\n            {\n                w.writeText( PluginUtils.toText( mojoDescriptor.getDescription() ) );\n            }\n            else\n            {\n                w.writeText( mojoDescriptor.getDescription() );\n            }\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.isDependencyResolutionRequired() != null )\n        {\n            PluginUtils.element( w, \"requiresDependencyResolution\", mojoDescriptor.isDependencyResolutionRequired() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        PluginUtils.element( w, \"requiresDirectInvocation\", \"\" + mojoDescriptor.isDirectInvocationOnly() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        PluginUtils.element( w, \"requiresProject\", \"\" + mojoDescriptor.isProjectRequired() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        PluginUtils.element( w, \"requiresReports\", \"\" + mojoDescriptor.isRequiresReports() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        PluginUtils.element( w, \"aggregator\", \"\" + mojoDescriptor.isAggregator() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        PluginUtils.element( w, \"requiresOnline\", \"\" + mojoDescriptor.isOnlineRequired() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        PluginUtils.element( w, \"inheritedByDefault\", \"\" + mojoDescriptor.isInheritedByDefault() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getPhase() != null )\n        {\n            PluginUtils.element( w, \"phase\", mojoDescriptor.getPhase() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getExecutePhase() != null )\n        {\n            PluginUtils.element( w, \"executePhase\", mojoDescriptor.getExecutePhase() );\n        }\n\n        if ( mojoDescriptor.getExecuteGoal() != null )\n        {\n            PluginUtils.element( w, \"executeGoal\", mojoDescriptor.getExecuteGoal() );\n        }\n\n        if ( mojoDescriptor.getExecuteLifecycle() != null )\n        {\n            PluginUtils.element( w, \"executeLifecycle\", mojoDescriptor.getExecuteLifecycle() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"implementation\" );\n        w.writeText( mojoDescriptor.getImplementation() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"language\" );\n        w.writeText( mojoDescriptor.getLanguage() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getComponentConfigurator() != null )\n        {\n            w.startElement( \"configurator\" );\n            w.writeText( mojoDescriptor.getComponentConfigurator() );\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getComponentComposer() != null )\n        {\n            w.startElement( \"composer\" );\n            w.writeText( mojoDescriptor.getComponentComposer() );\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"instantiationStrategy\" );\n        w.writeText( mojoDescriptor.getInstantiationStrategy() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Strategy for handling repeated reference to mojo in\n        // the calculated (decorated, resolved) execution stack\n        // ----------------------------------------------------------------------\n        w.startElement( \"executionStrategy\" );\n        w.writeText( mojoDescriptor.getExecutionStrategy() );\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getDeprecated() != null )\n        {\n            w.startElement( \"deprecated\" );\n\n            if ( StringUtils.isEmpty( mojoDescriptor.getDeprecated() ) )\n            {\n                w.writeText( \"No reason given\" );\n            }\n            else\n            {\n                w.writeText( mojoDescriptor.getDeprecated() );\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Extended (3.0) descriptor\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor instanceof ExtendedMojoDescriptor )\n        {\n            ExtendedMojoDescriptor extendedMojoDescriptor = (ExtendedMojoDescriptor) mojoDescriptor;\n            if ( extendedMojoDescriptor.getDependencyCollectionRequired() != null )\n            {\n                PluginUtils.element( w, \"requiresDependencyCollection\",\n                                     extendedMojoDescriptor.getDependencyCollectionRequired() );\n            }\n\n            PluginUtils.element( w, \"threadSafe\", String.valueOf( extendedMojoDescriptor.isThreadSafe() ) );\n        }\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        @SuppressWarnings( \"unchecked\" ) List<Parameter> parameters = mojoDescriptor.getParameters();\n\n        w.startElement( \"parameters\" );\n\n        Map<String, Requirement> requirements = new LinkedHashMap<String, Requirement>();\n\n        Set<Parameter> configuration = new LinkedHashSet<Parameter>();\n\n        if ( parameters != null )\n        {\n            for ( Parameter parameter : parameters )\n            {\n                String expression = parameter.getExpression();\n\n                if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${component.\" ) )\n                {\n                    // treat it as a component...a requirement, in other words.\n\n                    // remove \"component.\" plus expression delimiters\n                    String role = expression.substring( \"${component.\".length(), expression.length() - 1 );\n\n                    String roleHint = null;\n\n                    int posRoleHintSeparator = role.indexOf( \"#\" );\n                    if ( posRoleHintSeparator > 0 )\n                    {\n                        roleHint = role.substring( posRoleHintSeparator + 1 );\n\n                        role = role.substring( 0, posRoleHintSeparator );\n                    }\n\n                    // TODO: remove deprecated expression\n                    requirements.put( parameter.getName(), new Requirement( role, roleHint ) );\n                }\n                else if ( parameter.getRequirement() != null )\n                {\n                    requirements.put( parameter.getName(), parameter.getRequirement() );\n                }\n                else\n                {\n                    // treat it as a normal parameter.\n\n                    w.startElement( \"parameter\" );\n\n                    PluginUtils.element( w, \"name\", parameter.getName() );\n\n                    if ( parameter.getAlias() != null )\n                    {\n                        PluginUtils.element( w, \"alias\", parameter.getAlias() );\n                    }\n\n                    PluginUtils.element( w, \"type\", parameter.getType() );\n\n                    if ( parameter.getDeprecated() != null )\n                    {\n                        if ( StringUtils.isEmpty( parameter.getDeprecated() ) )\n                        {\n                            PluginUtils.element( w, \"deprecated\", \"No reason given\" );\n                        }\n                        else\n                        {\n                            PluginUtils.element( w, \"deprecated\", parameter.getDeprecated() );\n                        }\n                    }\n\n                    if ( parameter.getImplementation() != null )\n                    {\n                        PluginUtils.element( w, \"implementation\", parameter.getImplementation() );\n                    }\n\n                    PluginUtils.element( w, \"required\", Boolean.toString( parameter.isRequired() ) );\n\n                    PluginUtils.element( w, \"editable\", Boolean.toString( parameter.isEditable() ) );\n                    if ( cleanDescription )\n                    {\n                        PluginUtils.element( w, \"description\", PluginUtils.toText( parameter.getDescription() ) );\n                    }\n                    else\n                    {\n                        PluginUtils.element( w, \"description\", parameter.getDescription() );\n                    }\n\n                    if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) || StringUtils.isNotEmpty(\n                        parameter.getExpression() ) )\n                    {\n                        configuration.add( parameter );\n                    }\n\n                    w.endElement();\n                }\n\n            }\n        }\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Configuration\n        // ----------------------------------------------------------------------\n\n        if ( !configuration.isEmpty() )\n        {\n            w.startElement( \"configuration\" );\n\n            for ( Parameter parameter : configuration )\n            {\n                w.startElement( parameter.getName() );\n\n                String type = parameter.getType();\n                if ( type != null )\n                {\n                    w.addAttribute( \"implementation\", type );\n                }\n\n                if ( parameter.getDefaultValue() != null )\n                {\n                    w.addAttribute( \"default-value\", parameter.getDefaultValue() );\n                }\n\n                if ( parameter.getExpression() != null )\n                {\n                    w.writeText( parameter.getExpression() );\n                }\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        if ( !requirements.isEmpty() )\n        {\n            w.startElement( \"requirements\" );\n\n            for ( Map.Entry<String, Requirement> entry : requirements.entrySet() )\n            {\n                String key = entry.getKey();\n                Requirement requirement = entry.getValue();\n\n                w.startElement( \"requirement\" );\n\n                PluginUtils.element( w, \"role\", requirement.getRole() );\n\n                if ( requirement.getRoleHint() != null )\n                {\n                    PluginUtils.element( w, \"role-hint\", requirement.getRoleHint() );\n                }\n\n                PluginUtils.element( w, \"field-name\", key );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        w.endElement();\n    }\n\n    protected String rewriteHelpClassToMojoPackage( PluginToolsRequest request )\n        throws GeneratorException\n    {\n        String destinationPackage = PluginUtils.discoverPackageName( request.getPluginDescriptor() );\n        if ( StringUtils.isEmpty( destinationPackage ) )\n        {\n            return null;\n        }\n        File helpClassFile = new File( request.getProject().getBuild().getOutputDirectory(), \"HelpMojo.class\" );\n        if ( !helpClassFile.exists() )\n        {\n            return null;\n        }\n        File rewriteHelpClassFile = new File(\n            request.getProject().getBuild().getOutputDirectory() + \"/\" + StringUtils.replace( destinationPackage, \".\",\n                                                                                              \"/\" ), \"HelpMojo.class\" );\n        if ( !rewriteHelpClassFile.getParentFile().exists() )\n        {\n            rewriteHelpClassFile.getParentFile().mkdirs();\n        }\n\n        ClassReader cr = null;\n        try\n        {\n            cr = new ClassReader( new FileInputStream( helpClassFile ) );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n\n        ClassWriter cw = new ClassWriter( 0 );\n\n        ClassVisitor cv = new RemappingClassAdapter( cw, new SimpleRemapper( \"HelpMojo\",\n                                                                             StringUtils.replace( destinationPackage,\n                                                                                                  \".\", \"/\" )\n                                                                                 + \"/HelpMojo\" ) );\n\n        try\n        {\n            cr.accept( cv, ClassReader.EXPAND_FRAMES );\n        }\n        catch ( Throwable e )\n        {\n            throw new GeneratorException( \"ASM issue processing classFile \" + helpClassFile.getPath(), e );\n        }\n\n        byte[] renamedClass = cw.toByteArray();\n        FileOutputStream fos = null;\n        try\n        {\n            fos = new FileOutputStream( rewriteHelpClassFile );\n            fos.write( renamedClass );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( \"Error rewriting help class: \" + e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( fos );\n        }\n        helpClassFile.delete();\n        return destinationPackage + \".HelpMojo\";\n    }\n\n\n    private void rewriteDescriptor( PluginDescriptor pluginDescriptor, String helpMojoImplementation )\n    {\n        MojoDescriptor mojoDescriptor = pluginDescriptor.getMojo( \"help\" );\n        if ( mojoDescriptor != null )\n        {\n            mojoDescriptor.setImplementation( helpMojoImplementation );\n        }\n    }\n}\n","lineNo":77}
{"Refactored Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.velocity.VelocityComponent;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Generates an <code>HelpMojo<\/code> class.\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    /**\n     * Default generated class name\n     */\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    /**\n     * Default goal\n     */\n    private static final String HELP_GOAL = \"help\";\n\n    private String helpPackageName;\n\n    private VelocityComponent velocityComponent;\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws GeneratorException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n\n        String helpImplementation = getImplementation( pluginDescriptor );\n\n        @SuppressWarnings( \"unchecked\" )\n        List<MojoDescriptor> mojoDescriptors = pluginDescriptor.getMojos();\n\n        if ( mojoDescriptors != null )\n        {\n            // Verify that no help goal already exists\n            for ( MojoDescriptor descriptor : mojoDescriptors )\n            {\n                if ( HELP_GOAL.equals( descriptor.getGoal() )\n                    && !descriptor.getImplementation().equals( helpImplementation ) )\n                {\n                    if ( getLogger().isWarnEnabled() )\n                    {\n                        getLogger().warn( \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                              + \") already exists in this plugin. SKIPPED THE \"\n                                              + helpImplementation + \" GENERATION.\\n\" );\n                    }\n\n                    return;\n                }\n            }\n        }\n        Properties properties = new Properties();\n        properties.put( \"helpPackageName\", helpPackageName == null ? \"\" : helpPackageName );\n\n        MavenProject mavenProject = request.getProject();\n\n        String propertiesFilePath = \"META-INF/maven/\" + mavenProject.getGroupId() + \"/\" + mavenProject.getArtifactId();\n\n        File tmpPropertiesFile =\n            new File( request.getProject().getBuild().getDirectory(), \"maven-plugin-help.properties\" );\n        if ( tmpPropertiesFile.exists() )\n        {\n            tmpPropertiesFile.delete();\n        }\n        else\n        {\n            if ( !tmpPropertiesFile.getParentFile().exists() )\n            {\n                tmpPropertiesFile.getParentFile().mkdirs();\n            }\n        }\n        FileOutputStream fos = null;\n        try\n        {\n            fos = new FileOutputStream( tmpPropertiesFile );\n            properties.store( fos, \"maven plugin help generation informations\" );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        } finally {\n            IOUtil.close( fos );\n        }\n\n        String sourcePath = helpImplementation.replace( '.', File.separatorChar ) + \".java\";\n        File helpClass = new File( destinationDirectory, sourcePath );\n        helpClass.getParentFile().mkdirs();\n\n        Writer writer = null;\n        try\n        {\n            writer = new OutputStreamWriter( new FileOutputStream( helpClass ), request.getEncoding() );\n            writer.write( getHelpClassSources( propertiesFilePath ) );\n            writer.flush();\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    public PluginHelpGenerator setHelpPackageName( String helpPackageName )\n    {\n        this.helpPackageName = helpPackageName;\n        return this;\n    }\n\n    public VelocityComponent getVelocityComponent()\n    {\n        return velocityComponent;\n    }\n\n    public PluginHelpGenerator setVelocityComponent( VelocityComponent velocityComponent )\n    {\n        this.velocityComponent = velocityComponent;\n        return this;\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    protected String getHelpClassSources( String propertiesFilePath )\n    {\n        Properties properties = new Properties();\n        VelocityContext context = new VelocityContext( properties );\n        if ( this.helpPackageName != null )\n        {\n            properties.put( \"helpPackageName\", this.helpPackageName );\n        }\n        else\n        {\n            properties.put( \"helpPackageName\", \"\" );\n        }\n        properties.put( \"propertiesFilePath\", propertiesFilePath + \"/plugin-description.xml\" );\n        // FIXME encoding !\n\n        StringWriter stringWriter = new StringWriter();\n\n        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream( \"help-class-source.vm\" );\n        InputStreamReader isReader = new InputStreamReader( is );\n        velocityComponent.getEngine().evaluate( context, stringWriter, \"\", isReader );\n\n        return stringWriter.toString();\n    }\n\n\n    /**\n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *                         <code>null<\/code>.\n     * @return The implementation.\n     */\n    private String getImplementation( PluginDescriptor pluginDescriptor )\n    {\n        String packageName = helpPackageName;\n        if ( StringUtils.isEmpty( packageName ) )\n        {\n            packageName = PluginUtils.discoverPackageName( pluginDescriptor );\n        }\n\n        return StringUtils.isEmpty( packageName ) ? HELP_MOJO_CLASS_NAME : packageName + '.' + HELP_MOJO_CLASS_NAME;\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.velocity.VelocityComponent;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Generates an <code>HelpMojo<\/code> class.\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    /**\n     * Default generated class name\n     */\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    /**\n     * Default goal\n     */\n    private static final String HELP_GOAL = \"help\";\n\n    private String helpPackageName;\n\n    private VelocityComponent velocityComponent;\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n\n    /**\n     * {@inheritDoc}\n     */\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws GeneratorException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n\n        String helpImplementation = getImplementation( pluginDescriptor );\n\n        @SuppressWarnings( \"unchecked\" )\n        List<MojoDescriptor> mojoDescriptors = pluginDescriptor.getMojos();\n\n        if ( mojoDescriptors != null )\n        {\n            // Verify that no help goal already exists\n            for ( MojoDescriptor descriptor : mojoDescriptors )\n            {\n                if ( HELP_GOAL.equals( descriptor.getGoal() )\n                    && !descriptor.getImplementation().equals( helpImplementation ) )\n                {\n                    if ( getLogger().isWarnEnabled() )\n                    {\n                        getLogger().warn( \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                              + \") already exists in this plugin. SKIPPED THE \"\n                                              + helpImplementation + \" GENERATION.\\n\" );\n                    }\n\n                    return;\n                }\n            }\n        }\n        Properties properties = new Properties();\n        properties.put( \"helpPackageName\", helpPackageName == null ? \"\" : helpPackageName );\n\n        MavenProject mavenProject = request.getProject();\n\n        String propertiesFilePath = \"META-INF/maven/\" + mavenProject.getGroupId() + \"/\" + mavenProject.getArtifactId();\n\n        File tmpPropertiesFile =\n            new File( request.getProject().getBuild().getDirectory(), \"maven-plugin-help.properties\" );\n        if ( tmpPropertiesFile.exists() )\n        {\n            tmpPropertiesFile.delete();\n        }\n        else\n        {\n            if ( !tmpPropertiesFile.getParentFile().exists() )\n            {\n                tmpPropertiesFile.getParentFile().mkdirs();\n            }\n        }\n\n        try\n        {\n            properties.store( new FileOutputStream( tmpPropertiesFile ), \"maven plugin help generation informations\" );\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n\n        String sourcePath = helpImplementation.replace( '.', File.separatorChar ) + \".java\";\n        File helpClass = new File( destinationDirectory, sourcePath );\n        helpClass.getParentFile().mkdirs();\n\n        Writer writer = null;\n        try\n        {\n            writer = new OutputStreamWriter( new FileOutputStream( helpClass ), request.getEncoding() );\n            writer.write( getHelpClassSources( propertiesFilePath ) );\n            writer.flush();\n        }\n        catch ( IOException e )\n        {\n            throw new GeneratorException( e.getMessage(), e );\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    public PluginHelpGenerator setHelpPackageName( String helpPackageName )\n    {\n        this.helpPackageName = helpPackageName;\n        return this;\n    }\n\n    public VelocityComponent getVelocityComponent()\n    {\n        return velocityComponent;\n    }\n\n    public PluginHelpGenerator setVelocityComponent( VelocityComponent velocityComponent )\n    {\n        this.velocityComponent = velocityComponent;\n        return this;\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    protected String getHelpClassSources( String propertiesFilePath )\n    {\n        Properties properties = new Properties();\n        VelocityContext context = new VelocityContext( properties );\n        if ( this.helpPackageName != null )\n        {\n            properties.put( \"helpPackageName\", this.helpPackageName );\n        }\n        else\n        {\n            properties.put( \"helpPackageName\", \"\" );\n        }\n        properties.put( \"propertiesFilePath\", propertiesFilePath + \"/plugin-description.xml\" );\n        // FIXME encoding !\n\n        StringWriter stringWriter = new StringWriter();\n\n        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream( \"help-class-source.vm\" );\n        InputStreamReader isReader = new InputStreamReader( is );\n        velocityComponent.getEngine().evaluate( context, stringWriter, \"\", isReader );\n\n        return stringWriter.toString();\n    }\n\n\n    /**\n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *                         <code>null<\/code>.\n     * @return The implementation.\n     */\n    private String getImplementation( PluginDescriptor pluginDescriptor )\n    {\n        String packageName = helpPackageName;\n        if ( StringUtils.isEmpty( packageName ) )\n        {\n            packageName = PluginUtils.discoverPackageName( pluginDescriptor );\n        }\n\n        return StringUtils.isEmpty( packageName ) ? HELP_MOJO_CLASS_NAME : packageName + '.' + HELP_MOJO_CLASS_NAME;\n    }\n}\n","lineNo":136}
{"Refactored Sample":"package org.apache.maven.plugin.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.Renderer;\nimport org.apache.maven.model.Plugin;\nimport org.apache.maven.model.ReportPlugin;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.AbstractMavenReport;\nimport org.apache.maven.reporting.AbstractMavenReportRenderer;\nimport org.apache.maven.reporting.MavenReportException;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.generator.GeneratorException;\nimport org.apache.maven.tools.plugin.generator.PluginXdocGenerator;\nimport org.apache.maven.tools.plugin.scanner.MojoScanner;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.Xpp3Dom;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.ResourceBundle;\n\n/**\n * Generates the Plugin's documentation report.\n *\n * @author <a href=\"snicoll@apache.org\">Stephane Nicoll<\/a>\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @goal report\n * @execute phase=\"compile\"\n * @since 2.0\n */\npublic class PluginReport\n    extends AbstractMavenReport\n{\n    /**\n     * Report output directory.\n     *\n     * @parameter default-value=\"${project.build.directory}/generated-site/xdoc\"\n     */\n    private File outputDirectory;\n\n    /**\n     * Doxia Site Renderer.\n     *\n     * @component\n     */\n    private Renderer siteRenderer;\n\n    /**\n     * The Maven Project.\n     *\n     * @parameter expression=\"${project}\"\n     * @required\n     * @readonly\n     */\n    private MavenProject project;\n\n    /**\n     * Mojo scanner tools.\n     *\n     * @component\n     */\n    protected MojoScanner mojoScanner;\n\n    /**\n     * The file encoding of the source files.\n     *\n     * @parameter expression=\"${encoding}\" default-value=\"${project.build.sourceEncoding}\"\n     * @since 2.7\n     */\n    private String encoding;\n\n\n    /**\n     * Specify some requirements to execute this plugin.\n     * Example:\n     * <pre>\n     * &lt;requirements&gt;\n     *   &lt;maven&gt;2.0&lt;/maven&gt;\n     *   &lt;jdk&gt;1.4&lt;/jdk&gt;\n     *   &lt;memory&gt;256m&lt;/memory&gt;\n     *   &lt;diskSpace&gt;1m&lt;/diskSpace&gt;\n     *   &lt;others&gt;\n     *     &lt;property&gt;\n     *       &lt;name&gt;SVN&lt;/name&gt;\n     *       &lt;value&gt;1.4.6&lt;/value&gt;\n     *     &lt;/property&gt;\n     *   &lt;/others&gt;\n     * &lt;/requirements&gt;\n     * <\/pre>\n     *\n     * @parameter\n     */\n    private Requirements requirements;\n\n    /**\n     * The goal prefix that will appear before the \":\".\n     * By default, this plugin applies a heuristic to derive a heuristic from\n     * the plugin's artifactId.\n     * <p/>\n     * It removes any occurrences of the regular expression <strong>-?maven-?<\/strong>,\n     * and then removes any occurrences of <strong>-?plugin-?<\/strong>.\n     * <p>\n     * For example, horsefeature-maven-plugin becomes horsefeather.\n     * <\/p>\n     * <p>\n     * (There is a special for maven-plugin-plugin; it is mapped to 'plugin'.\n     * <\/p>\n     *\n     * @parameter expression=\"${goalPrefix}\"\n     * @since 2.4\n     */\n    protected String goalPrefix;\n\n    /**\n     * Set this to \"true\" to skip invoking any goals or reports of the plugin.\n     *\n     * @parameter default-value=\"false\" expression=\"${maven.plugin.skip}\"\n     * @since 2.8\n     */\n    private boolean skip;\n\n    /**\n     * Set this to \"true\" to skip generating the report.\n     *\n     * @parameter default-value=\"false\" expression=\"${maven.plugin.report.skip}\"\n     * @since 2.8\n     */\n    private boolean skipReport;\n\n    /**\n     * {@inheritDoc}\n     */\n    protected Renderer getSiteRenderer()\n    {\n        return siteRenderer;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected String getOutputDirectory()\n    {\n        return outputDirectory.getPath();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected MavenProject getProject()\n    {\n        return project;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean canGenerateReport()\n    {\n        return \"maven-plugin\".equals( project.getPackaging() );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings( \"unchecked\" )\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( !canGenerateReport() )\n        {\n            return;\n        }\n        if ( skip || skipReport )\n        {\n            getLog().info( \"Maven Plugin Plugin Report generation skipped.\" );\n            return;\n        }\n\n        // Copy from AbstractGeneratorMojo#execute()\n        String defaultGoalPrefix = PluginDescriptor.getGoalPrefixFromArtifactId( project.getArtifactId() );\n        if ( goalPrefix == null )\n        {\n            goalPrefix = defaultGoalPrefix;\n        }\n        else\n        {\n            getLog().warn( \"\\n\\nGoal prefix is specified as: '\" + goalPrefix + \"'. Maven currently expects it to be '\"\n                               + defaultGoalPrefix + \"'.\\n\" );\n        }\n\n        // TODO: could use this more, eg in the writing of the plugin descriptor!\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.setGroupId( project.getGroupId() );\n\n        pluginDescriptor.setArtifactId( project.getArtifactId() );\n\n        pluginDescriptor.setVersion( project.getVersion() );\n\n        pluginDescriptor.setGoalPrefix( goalPrefix );\n\n        try\n        {\n            pluginDescriptor.setDependencies( PluginUtils.toComponentDependencies( project.getRuntimeDependencies() ) );\n\n            PluginToolsRequest request = new DefaultPluginToolsRequest( project, pluginDescriptor );\n            request.setEncoding( encoding );\n\n            try\n            {\n                mojoScanner.populatePluginDescriptor( request );\n            }\n            catch ( InvalidPluginDescriptorException e )\n            {\n                // this is OK, it happens to lifecycle plugins. Allow generation to proceed.\n                getLog().debug( \"Plugin without mojos.\", e );\n\n            }\n\n            // Generate the plugin's documentation\n            generatePluginDocumentation( pluginDescriptor, locale );\n\n            // Write the overview\n            PluginOverviewRenderer r =\n                new PluginOverviewRenderer( project, requirements, getSink(), pluginDescriptor, locale );\n            r.render();\n        }\n\n        catch ( ExtractionException e )\n        {\n            throw new MavenReportException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                            e );\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription( Locale locale )\n    {\n        return getBundle( locale ).getString( \"report.plugin.description\" );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getName( Locale locale )\n    {\n        return getBundle( locale ).getString( \"report.plugin.name\" );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getOutputName()\n    {\n        return \"plugin-info\";\n    }\n\n    /**\n     * @param pluginDescriptor not null\n     * @param locale           not null\n     * @throws MavenReportException if any\n     */\n    private void generatePluginDocumentation( PluginDescriptor pluginDescriptor, Locale locale )\n        throws MavenReportException\n    {\n        try\n        {\n            File outputDir = new File( getOutputDirectory() );\n            outputDir.mkdirs();\n\n            PluginXdocGenerator generator = new PluginXdocGenerator( project, locale );\n            PluginToolsRequest pluginToolsRequest = new DefaultPluginToolsRequest( project, pluginDescriptor );\n            generator.execute( outputDir, pluginToolsRequest );\n        }\n        catch ( GeneratorException e )\n        {\n            throw new MavenReportException( \"Error writing plugin documentation\", e );\n        }\n\n    }\n\n    /**\n     * @param locale not null\n     * @return the bundle for this report\n     */\n    protected static ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"plugin-report\", locale, PluginReport.class.getClassLoader() );\n    }\n\n    /**\n     * Generates an overview page with the list of goals\n     * and a link to the goal's page.\n     */\n    static class PluginOverviewRenderer\n        extends AbstractMavenReportRenderer\n    {\n        private final MavenProject project;\n\n        private final Requirements requirements;\n\n        private final PluginDescriptor pluginDescriptor;\n\n        private final Locale locale;\n\n        /**\n         * @param project          not null\n         * @param requirements     not null\n         * @param sink             not null\n         * @param pluginDescriptor not null\n         * @param locale           not null\n         */\n        public PluginOverviewRenderer( MavenProject project, Requirements requirements, Sink sink,\n                                       PluginDescriptor pluginDescriptor, Locale locale )\n        {\n            super( sink );\n\n            this.project = project;\n\n            this.requirements = ( requirements == null ? new Requirements() : requirements );\n\n            this.pluginDescriptor = pluginDescriptor;\n\n            this.locale = locale;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public String getTitle()\n        {\n            return getBundle( locale ).getString( \"report.plugin.title\" );\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @SuppressWarnings( { \"unchecked\", \"rawtypes\" } )\n        public void renderBody()\n        {\n            startSection( getTitle() );\n\n            if ( !( pluginDescriptor.getMojos() != null && pluginDescriptor.getMojos().size() > 0 ) )\n            {\n                paragraph( getBundle( locale ).getString( \"report.plugin.goals.nogoal\" ) );\n                endSection();\n                return;\n            }\n\n            paragraph( getBundle( locale ).getString( \"report.plugin.goals.intro\" ) );\n\n            boolean hasMavenReport = false;\n            for ( Iterator<MojoDescriptor> i = pluginDescriptor.getMojos().iterator(); i.hasNext(); )\n            {\n                MojoDescriptor mojo = i.next();\n\n                if ( PluginUtils.isMavenReport( mojo.getImplementation(), project ) )\n                {\n                    hasMavenReport = true;\n                }\n            }\n\n            startTable();\n\n            String goalColumnName = getBundle( locale ).getString( \"report.plugin.goals.column.goal\" );\n            String isMavenReport = getBundle( locale ).getString( \"report.plugin.goals.column.isMavenReport\" );\n            String descriptionColumnName = getBundle( locale ).getString( \"report.plugin.goals.column.description\" );\n            if ( hasMavenReport )\n            {\n                tableHeader( new String[]{ goalColumnName, isMavenReport, descriptionColumnName } );\n            }\n            else\n            {\n                tableHeader( new String[]{ goalColumnName, descriptionColumnName } );\n            }\n\n            List<MojoDescriptor> mojos = new ArrayList<MojoDescriptor>();\n            mojos.addAll( pluginDescriptor.getMojos() );\n            PluginUtils.sortMojos( mojos );\n            for ( MojoDescriptor mojo : mojos )\n            {\n                String goalName = mojo.getFullGoalName();\n\n                /*\n                 * Added ./ to define a relative path\n                 * @see AbstractMavenReportRenderer#getValidHref(java.lang.String)\n                 */\n                String goalDocumentationLink = \"./\" + mojo.getGoal() + \"-mojo.html\";\n\n                String description;\n                if ( StringUtils.isNotEmpty( mojo.getDeprecated() ) )\n                {\n                    description =\n                        \"<strong>\" + getBundle( locale ).getString( \"report.plugin.goal.deprecated\" ) + \"<\/strong> \"\n                            + PluginUtils.makeHtmlValid( mojo.getDeprecated() );\n                }\n                else if ( StringUtils.isNotEmpty( mojo.getDescription() ) )\n                {\n                    description = PluginUtils.makeHtmlValid( mojo.getDescription() );\n                }\n                else\n                {\n                    description = getBundle( locale ).getString( \"report.plugin.goal.nodescription\" );\n                }\n\n                sink.tableRow();\n                tableCell( createLinkPatternedText( goalName, goalDocumentationLink ) );\n                if ( hasMavenReport )\n                {\n                    if ( PluginUtils.isMavenReport( mojo.getImplementation(), project ) )\n                    {\n                        sink.tableCell();\n                        sink.text( getBundle( locale ).getString( \"report.plugin.isReport\" ) );\n                        sink.tableCell_();\n                    }\n                    else\n                    {\n                        sink.tableCell();\n                        sink.text( getBundle( locale ).getString( \"report.plugin.isNotReport\" ) );\n                        sink.tableCell_();\n                    }\n                }\n                tableCell( description, true );\n                sink.tableRow_();\n            }\n\n            endTable();\n\n            startSection( getBundle( locale ).getString( \"report.plugin.systemrequirements\" ) );\n\n            paragraph( getBundle( locale ).getString( \"report.plugin.systemrequirements.intro\" ) );\n\n            startTable();\n\n            String maven = discoverMavenRequirement( project, requirements );\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.maven\" ) );\n            tableCell( ( maven != null\n                ? maven\n                : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            String jdk = discoverJdkRequirement( project, requirements );\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.jdk\" ) );\n            tableCell(\n                ( jdk != null ? jdk : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.memory\" ) );\n            tableCell( ( StringUtils.isNotEmpty( requirements.getMemory() )\n                ? requirements.getMemory()\n                : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.diskspace\" ) );\n            tableCell( ( StringUtils.isNotEmpty( requirements.getDiskSpace() )\n                ? requirements.getDiskSpace()\n                : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            if ( requirements.getOthers() != null && requirements.getOthers().size() > 0 )\n            {\n                for ( Iterator it = requirements.getOthers().keySet().iterator(); it.hasNext(); )\n                {\n                    String key = it.next().toString();\n\n                    sink.tableRow();\n                    tableCell( key );\n                    tableCell( ( StringUtils.isNotEmpty( requirements.getOthers().getProperty( key ) )\n                        ? requirements.getOthers().getProperty( key )\n                        : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n                    sink.tableRow_();\n                }\n            }\n            endTable();\n\n            endSection();\n\n            renderUsageSection( hasMavenReport );\n\n            endSection();\n        }\n\n        /**\n         * Render the section about the usage of the plugin.\n         *\n         * @param hasMavenReport If the plugin has a report or not\n         */\n        private void renderUsageSection( boolean hasMavenReport )\n        {\n            startSection( getBundle( locale ).getString( \"report.plugin.usage\" ) );\n\n            // Configuration\n            sink.paragraph();\n            text( getBundle( locale ).getString( \"report.plugin.usage.intro\" ) );\n            sink.paragraph_();\n\n            StringBuffer sb = new StringBuffer();\n            sb.append( \"<project>\" ).append( '\\n' );\n            sb.append( \"  ...\" ).append( '\\n' );\n            sb.append( \"  <build>\" ).append( '\\n' );\n            sb.append(\n                \"    <!-- \" + getBundle( locale ).getString( \"report.plugin.usage.pluginManagement\" ) + \" -->\" ).append(\n                '\\n' );\n            sb.append( \"    <pluginManagement>\" ).append( '\\n' );\n            sb.append( \"      <plugins>\" ).append( '\\n' );\n            sb.append( \"        <plugin>\" ).append( '\\n' );\n            sb.append( \"          <groupId>\" ).append( pluginDescriptor.getGroupId() ).append( \"<\/groupId>\" ).append(\n                '\\n' );\n            sb.append( \"          <artifactId>\" ).append( pluginDescriptor.getArtifactId() ).append(\n                \"<\/artifactId>\" ).append( '\\n' );\n            sb.append( \"          <version>\" ).append( pluginDescriptor.getVersion() ).append( \"<\/version>\" ).append(\n                '\\n' );\n            sb.append( \"        <\/plugin>\" ).append( '\\n' );\n            sb.append( \"        ...\" ).append( '\\n' );\n            sb.append( \"      <\/plugins>\" ).append( '\\n' );\n            sb.append( \"    <\/pluginManagement>\" ).append( '\\n' );\n            sb.append( \"    <!-- \" + getBundle( locale ).getString( \"report.plugin.usage.plugins\" ) + \" -->\" ).append(\n                '\\n' );\n            sb.append( \"    <plugins>\" ).append( '\\n' );\n            sb.append( \"      <plugin>\" ).append( '\\n' );\n            sb.append( \"        <groupId>\" ).append( pluginDescriptor.getGroupId() ).append( \"<\/groupId>\" ).append(\n                '\\n' );\n            sb.append( \"        <artifactId>\" ).append( pluginDescriptor.getArtifactId() ).append(\n                \"<\/artifactId>\" ).append( '\\n' );\n            sb.append( \"        <version>\" ).append( pluginDescriptor.getVersion() ).append( \"<\/version>\" ).append(\n                '\\n' );\n            sb.append( \"      <\/plugin>\" ).append( '\\n' );\n            sb.append( \"      ...\" ).append( '\\n' );\n            sb.append( \"    <\/plugins>\" ).append( '\\n' );\n            sb.append( \"  <\/build>\" ).append( '\\n' );\n\n            if ( hasMavenReport )\n            {\n                sb.append( \"  ...\" ).append( '\\n' );\n                sb.append(\n                    \"  <!-- \" + getBundle( locale ).getString( \"report.plugin.usage.reporting\" ) + \" -->\" ).append(\n                    '\\n' );\n                sb.append( \"  <reporting>\" ).append( '\\n' );\n                sb.append( \"    <plugins>\" ).append( '\\n' );\n                sb.append( \"      <plugin>\" ).append( '\\n' );\n                sb.append( \"        <groupId>\" ).append( pluginDescriptor.getGroupId() ).append( \"<\/groupId>\" ).append(\n                    '\\n' );\n                sb.append( \"        <artifactId>\" ).append( pluginDescriptor.getArtifactId() ).append(\n                    \"<\/artifactId>\" ).append( '\\n' );\n                sb.append( \"        <version>\" ).append( pluginDescriptor.getVersion() ).append( \"<\/version>\" ).append(\n                    '\\n' );\n                sb.append( \"      <\/plugin>\" ).append( '\\n' );\n                sb.append( \"      ...\" ).append( '\\n' );\n                sb.append( \"    <\/plugins>\" ).append( '\\n' );\n                sb.append( \"  <\/reporting>\" ).append( '\\n' );\n            }\n\n            sb.append( \"  ...\" ).append( '\\n' );\n            sb.append( \"<\/project>\" ).append( '\\n' );\n\n            verbatimText( sb.toString() );\n\n            sink.paragraph();\n            linkPatternedText( getBundle( locale ).getString( \"report.plugin.configuration.end\" ) );\n            sink.paragraph_();\n\n            endSection();\n        }\n\n        /**\n         * Try to lookup on the Maven prerequisites property.\n         * If not specified, uses the value defined by the user.\n         *\n         * @param project      not null\n         * @param requirements not null\n         * @return the Maven version\n         */\n        private static String discoverMavenRequirement( MavenProject project, Requirements requirements )\n        {\n            String maven = requirements.getMaven();\n            if ( maven == null )\n            {\n                maven = ( project.getPrerequisites() != null ? project.getPrerequisites().getMaven() : null );\n            }\n            if ( maven == null )\n            {\n                maven = \"2.0\";\n            }\n\n            return maven;\n        }\n\n        /**\n         * Try to lookup on the <code>org.apache.maven.plugins:maven-compiler-plugin<\/code> plugin to\n         * find the value of the <code>target<\/code> option.\n         * If not specified, uses the value defined by the user.\n         * If not specified, uses the value of the system property <code>java.specification.version<\/code>.\n         *\n         * @param project      not null\n         * @param requirements not null\n         * @return the JDK version\n         */\n        private static String discoverJdkRequirement( MavenProject project, Requirements requirements )\n        {\n            String jdk = requirements.getJdk();\n            if ( jdk == null )\n            {\n                jdk = discoverJdkRequirementFromPlugins( project.getBuild().getPluginsAsMap() );\n            }\n            if ( jdk == null )\n            {\n                if ( project.getPluginManagement() != null )\n                {\n                    jdk = discoverJdkRequirementFromPlugins( project.getPluginManagement().getPluginsAsMap() );\n                }\n            }\n            if ( jdk == null )\n            {\n                jdk = \"Unknown\";\n            }\n\n            return jdk;\n        }\n\n        /**\n         * @param pluginsAsMap could be null\n         * @return the value of the <code>target<\/code> in the configuration of <code>maven-compiler-plugin<\/code>.\n         */\n        @SuppressWarnings( \"rawtypes\" )\n        private static String discoverJdkRequirementFromPlugins( Map pluginsAsMap )\n        {\n            if ( pluginsAsMap == null )\n            {\n                return null;\n            }\n\n            String jdk = null;\n            String backupJdk = null;\n            for ( Iterator it = pluginsAsMap.keySet().iterator(); it.hasNext(); )\n            {\n                String key = it.next().toString();\n\n                if ( !key.equals( \"org.apache.maven.plugins:maven-compiler-plugin\" ) )\n                {\n                    continue;\n                }\n\n                Object value = pluginsAsMap.get( key );\n                Xpp3Dom pluginConf = null;\n\n                backupJdk = \"Default version for maven-compiler-plugin\";\n                if ( value instanceof Plugin )\n                {\n                    Plugin plugin = (Plugin) value;\n                    backupJdk = \"Default target for maven-compiler-plugin version \" + plugin.getVersion();\n                    pluginConf = (Xpp3Dom) plugin.getConfiguration();\n                }\n\n                if ( value instanceof ReportPlugin )\n                {\n                    ReportPlugin reportPlugin = (ReportPlugin) value;\n                    backupJdk = \"Default target for maven-compiler-plugin version \" + reportPlugin.getVersion();\n                    pluginConf = (Xpp3Dom) reportPlugin.getConfiguration();\n                }\n\n                if ( pluginConf == null )\n                {\n                    continue;\n                }\n\n                if ( pluginConf.getChild( \"target\" ) == null )\n                {\n                    continue;\n                }\n\n                jdk = pluginConf.getChild( \"target\" ).getValue();\n            }\n\n            if ( jdk == null )\n            {\n                return backupJdk;\n            }\n            else\n            {\n                return jdk;\n            }\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.plugin.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.ResourceBundle;\n\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.Renderer;\nimport org.apache.maven.model.Plugin;\nimport org.apache.maven.model.ReportPlugin;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.AbstractMavenReport;\nimport org.apache.maven.reporting.AbstractMavenReportRenderer;\nimport org.apache.maven.reporting.MavenReportException;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.generator.PluginXdocGenerator;\nimport org.apache.maven.tools.plugin.scanner.MojoScanner;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.Xpp3Dom;\n\n/**\n * Generates the Plugin's documentation report.\n *\n * @author <a href=\"snicoll@apache.org\">Stephane Nicoll<\/a>\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.0\n * @goal report\n * @execute phase=\"compile\"\n */\npublic class PluginReport\n    extends AbstractMavenReport\n{\n    /**\n     * Report output directory.\n     *\n     * @parameter default-value=\"${project.build.directory}/generated-site/xdoc\"\n     */\n    private File outputDirectory;\n\n    /**\n     * Doxia Site Renderer.\n     *\n     * @component\n     */\n    private Renderer siteRenderer;\n\n    /**\n     * The Maven Project.\n     *\n     * @parameter expression=\"${project}\"\n     * @required\n     * @readonly\n     */\n    private MavenProject project;\n\n    /**\n     * Mojo scanner tools.\n     *\n     * @component\n     */\n    protected MojoScanner mojoScanner;\n\n   /**\n    * The file encoding of the source files.\n    *\n    * @parameter expression=\"${encoding}\" default-value=\"${project.build.sourceEncoding}\"\n    *\n    * @since 2.7\n    */\n    private String encoding;\n\n\n    /**\n     * Specify some requirements to execute this plugin.\n     * Example:\n     * <pre>\n     * &lt;requirements&gt;\n     *   &lt;maven&gt;2.0&lt;/maven&gt;\n     *   &lt;jdk&gt;1.4&lt;/jdk&gt;\n     *   &lt;memory&gt;256m&lt;/memory&gt;\n     *   &lt;diskSpace&gt;1m&lt;/diskSpace&gt;\n     *   &lt;others&gt;\n     *     &lt;property&gt;\n     *       &lt;name&gt;SVN&lt;/name&gt;\n     *       &lt;value&gt;1.4.6&lt;/value&gt;\n     *     &lt;/property&gt;\n     *   &lt;/others&gt;\n     * &lt;/requirements&gt;\n     * <\/pre>\n     *\n     * @parameter\n     */\n    private Requirements requirements;\n\n    /**\n     * The goal prefix that will appear before the \":\". \n     * By default, this plugin applies a heuristic to derive a heuristic from \n     * the plugin's artifactId. \n     * \n     * It removes any occurrences of the regular expression <strong>-?maven-?<\/strong>,\n     * and then removes any occurrences of <strong>-?plugin-?<\/strong>.\n     * <p>\n     * For example, horsefeature-maven-plugin becomes horsefeather.\n     * <\/p>\n     * <p>\n     * (There is a special for maven-plugin-plugin; it is mapped to 'plugin'.\n     * <\/p>\n     *\n     * @parameter expression=\"${goalPrefix}\"\n     * @since 2.4\n     */\n    protected String goalPrefix;\n\n    /**\n     * Set this to \"true\" to skip invoking any goals or reports of the plugin.\n     *\n     * @parameter default-value=\"false\" expression=\"${maven.plugin.skip}\"\n     * @since 2.8\n     */\n    private boolean skip;\n\n    /**\n     * Set this to \"true\" to skip generating the report.\n     *\n     * @parameter default-value=\"false\" expression=\"${maven.plugin.report.skip}\"\n     * @since 2.8\n     */\n    private boolean skipReport;\n\n    /** {@inheritDoc} */\n    protected Renderer getSiteRenderer()\n    {\n        return siteRenderer;\n    }\n\n    /** {@inheritDoc} */\n    protected String getOutputDirectory()\n    {\n        return outputDirectory.getPath();\n    }\n\n    /** {@inheritDoc} */\n    protected MavenProject getProject()\n    {\n        return project;\n    }\n\n    /** {@inheritDoc} */\n    public boolean canGenerateReport()\n    {\n        return \"maven-plugin\".equals( project.getPackaging() );\n    }\n\n    /** {@inheritDoc} */\n    @SuppressWarnings( \"unchecked\" )\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( !canGenerateReport() )\n        {\n            return;\n        }\n        if ( skip || skipReport )\n        {\n            getLog().info( \"Maven Plugin Plugin Report generation skipped.\" );\n            return;\n        }\n\n        // Copy from AbstractGeneratorMojo#execute()\n        String defaultGoalPrefix = PluginDescriptor.getGoalPrefixFromArtifactId( project.getArtifactId() );\n        if ( goalPrefix == null )\n        {\n            goalPrefix = defaultGoalPrefix;\n        }\n        else\n        {\n            getLog().warn(\n                           \"\\n\\nGoal prefix is specified as: '\" + goalPrefix + \"'. Maven currently expects it to be '\"\n                               + defaultGoalPrefix + \"'.\\n\" );\n        }\n\n        // TODO: could use this more, eg in the writing of the plugin descriptor!\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.setGroupId( project.getGroupId() );\n\n        pluginDescriptor.setArtifactId( project.getArtifactId() );\n\n        pluginDescriptor.setVersion( project.getVersion() );\n\n        pluginDescriptor.setGoalPrefix( goalPrefix );\n\n        try\n        {\n            pluginDescriptor.setDependencies( PluginUtils.toComponentDependencies( project.getRuntimeDependencies() ) );\n            \n            PluginToolsRequest request = new DefaultPluginToolsRequest( project, pluginDescriptor );\n            request.setEncoding( encoding );\n\n            try \n            {\n                mojoScanner.populatePluginDescriptor( request );\n            }\n            catch ( InvalidPluginDescriptorException e )\n            {\n                // this is OK, it happens to lifecycle plugins. Allow generation to proceed.\n                getLog().debug( \"Plugin without mojos.\", e );\n\n            }\n\n            // Generate the plugin's documentation\n            generatePluginDocumentation( pluginDescriptor, locale );\n\n            // Write the overview\n            PluginOverviewRenderer r = new PluginOverviewRenderer( project, requirements, getSink(), pluginDescriptor,\n                                                                   locale );\n            r.render();\n        }\n        \n        catch ( ExtractionException e )\n        {\n            throw new MavenReportException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                            e );\n        }\n    }\n\n    /** {@inheritDoc} */\n    public String getDescription( Locale locale )\n    {\n        return getBundle( locale ).getString( \"report.plugin.description\" );\n    }\n\n    /** {@inheritDoc} */\n    public String getName( Locale locale )\n    {\n        return getBundle( locale ).getString( \"report.plugin.name\" );\n    }\n\n    /** {@inheritDoc} */\n    public String getOutputName()\n    {\n        return \"plugin-info\";\n    }\n\n    /**\n     * @param pluginDescriptor not null\n     * @param locale not null\n     * @throws MavenReportException if any\n     */\n    private void generatePluginDocumentation( PluginDescriptor pluginDescriptor, Locale locale )\n        throws MavenReportException\n    {\n        try\n        {\n            File outputDir = new File( getOutputDirectory() );\n            outputDir.mkdirs();\n\n            PluginXdocGenerator generator = new PluginXdocGenerator( project, locale );\n            generator.execute( outputDir, pluginDescriptor );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Error writing plugin documentation\", e );\n        }\n\n    }\n\n    /**\n     * @param locale not null\n     * @return the bundle for this report\n     */\n    protected static ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"plugin-report\", locale, PluginReport.class.getClassLoader() );\n    }\n\n    /**\n     * Generates an overview page with the list of goals\n     * and a link to the goal's page.\n     */\n    static class PluginOverviewRenderer\n        extends AbstractMavenReportRenderer\n    {\n        private final MavenProject project;\n\n        private final Requirements requirements;\n\n        private final PluginDescriptor pluginDescriptor;\n\n        private final Locale locale;\n\n        /**\n         * @param project not null\n         * @param requirements not null\n         * @param sink not null\n         * @param pluginDescriptor not null\n         * @param locale not null\n         */\n        public PluginOverviewRenderer( MavenProject project, Requirements requirements, Sink sink,\n                                       PluginDescriptor pluginDescriptor, Locale locale )\n        {\n            super( sink );\n\n            this.project = project;\n\n            this.requirements = ( requirements == null ? new Requirements() : requirements );\n\n            this.pluginDescriptor = pluginDescriptor;\n\n            this.locale = locale;\n        }\n\n        /** {@inheritDoc} */\n        public String getTitle()\n        {\n            return getBundle( locale ).getString( \"report.plugin.title\" );\n        }\n\n        /** {@inheritDoc} */\n        @SuppressWarnings( { \"unchecked\", \"rawtypes\" } )\n        public void renderBody()\n        {\n            startSection( getTitle() );\n\n            if ( !( pluginDescriptor.getMojos() != null && pluginDescriptor.getMojos().size() > 0 ) )\n            {\n                paragraph( getBundle( locale ).getString( \"report.plugin.goals.nogoal\" ) );\n                endSection();\n                return;\n            }\n\n            paragraph( getBundle( locale ).getString( \"report.plugin.goals.intro\" ) );\n\n\n            boolean hasMavenReport = false;\n            for ( Iterator<MojoDescriptor> i = pluginDescriptor.getMojos().iterator(); i.hasNext(); )\n            {\n                MojoDescriptor mojo = i.next();\n\n                if ( PluginUtils.isMavenReport( mojo.getImplementation(), project ) )\n                {\n                    hasMavenReport = true;\n                }\n            }\n\n            startTable();\n\n            String goalColumnName = getBundle( locale ).getString( \"report.plugin.goals.column.goal\" );\n            String isMavenReport = getBundle( locale ).getString( \"report.plugin.goals.column.isMavenReport\" );\n            String descriptionColumnName = getBundle( locale ).getString( \"report.plugin.goals.column.description\" );\n            if ( hasMavenReport )\n            {\n                tableHeader( new String[] { goalColumnName, isMavenReport, descriptionColumnName } );\n            }\n            else\n            {\n                tableHeader( new String[] { goalColumnName, descriptionColumnName } );\n            }\n\n            List<MojoDescriptor> mojos = new ArrayList<MojoDescriptor>();\n            mojos.addAll( pluginDescriptor.getMojos() );\n            PluginUtils.sortMojos( mojos );\n            for ( MojoDescriptor mojo : mojos )\n            {\n                String goalName = mojo.getFullGoalName();\n\n                /*\n                 * Added ./ to define a relative path\n                 * @see AbstractMavenReportRenderer#getValidHref(java.lang.String)\n                 */\n                String goalDocumentationLink = \"./\" + mojo.getGoal() + \"-mojo.html\";\n\n                String description;\n                if ( StringUtils.isNotEmpty( mojo.getDeprecated() ) )\n                {\n                    description =\n                        \"<strong>\" + getBundle( locale ).getString( \"report.plugin.goal.deprecated\" ) + \"<\/strong> \"\n                            + PluginUtils.makeHtmlValid( mojo.getDeprecated() );\n                }\n                else if ( StringUtils.isNotEmpty( mojo.getDescription() ) )\n                {\n                    description = PluginUtils.makeHtmlValid( mojo.getDescription() );\n                }\n                else\n                {\n                    description = getBundle( locale ).getString( \"report.plugin.goal.nodescription\" );\n                }\n\n                sink.tableRow();\n                tableCell( createLinkPatternedText( goalName, goalDocumentationLink ) );\n                if ( hasMavenReport )\n                {\n                    if ( PluginUtils.isMavenReport( mojo.getImplementation(), project ) )\n                    {\n                        sink.tableCell();\n                        sink.text( getBundle( locale ).getString( \"report.plugin.isReport\" ) );\n                        sink.tableCell_();\n                    }\n                    else\n                    {\n                        sink.tableCell();\n                        sink.text( getBundle( locale ).getString( \"report.plugin.isNotReport\" ) );\n                        sink.tableCell_();\n                    }\n                }\n                tableCell( description, true );\n                sink.tableRow_();\n            }\n\n            endTable();\n\n            startSection( getBundle( locale ).getString( \"report.plugin.systemrequirements\" ) );\n\n            paragraph( getBundle( locale ).getString( \"report.plugin.systemrequirements.intro\" ) );\n\n            startTable();\n\n            String maven = discoverMavenRequirement( project, requirements );\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.maven\" ) );\n            tableCell( ( maven != null ? maven : getBundle( locale )\n                .getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            String jdk = discoverJdkRequirement( project, requirements );\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.jdk\" ) );\n            tableCell( ( jdk != null ? jdk : getBundle( locale )\n                .getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.memory\" ) );\n            tableCell( ( StringUtils.isNotEmpty( requirements.getMemory() )\n                ? requirements.getMemory()\n                : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            sink.tableRow();\n            tableCell( getBundle( locale ).getString( \"report.plugin.systemrequirements.diskspace\" ) );\n            tableCell( ( StringUtils.isNotEmpty( requirements.getDiskSpace() )\n                ? requirements.getDiskSpace()\n                : getBundle( locale ).getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n            sink.tableRow_();\n\n            if ( requirements.getOthers() != null && requirements.getOthers().size() > 0 )\n            {\n                for ( Iterator it = requirements.getOthers().keySet().iterator(); it.hasNext(); )\n                {\n                    String key = it.next().toString();\n\n                    sink.tableRow();\n                    tableCell( key );\n                    tableCell( ( StringUtils.isNotEmpty( requirements.getOthers().getProperty( key ) ) ? requirements\n                        .getOthers().getProperty( key ) : getBundle( locale )\n                        .getString( \"report.plugin.systemrequirements.nominimum\" ) ) );\n                    sink.tableRow_();\n                }\n            }\n            endTable();\n\n            endSection();\n\n            renderUsageSection( hasMavenReport );\n\n            endSection();\n        }\n\n        /**\n         * Render the section about the usage of the plugin.\n         *\n         * @param hasMavenReport If the plugin has a report or not\n         */\n        private void renderUsageSection( boolean hasMavenReport )\n        {\n            startSection( getBundle( locale ).getString( \"report.plugin.usage\" ) );\n\n            // Configuration\n            sink.paragraph();\n            text( getBundle( locale ).getString( \"report.plugin.usage.intro\" ) );\n            sink.paragraph_();\n\n            StringBuffer sb = new StringBuffer();\n            sb.append( \"<project>\" ).append( '\\n' );\n            sb.append( \"  ...\" ).append( '\\n' );\n            sb.append( \"  <build>\" ).append( '\\n' );\n            sb.append( \"    <!-- \" + getBundle( locale ).getString( \"report.plugin.usage.pluginManagement\" ) + \" -->\" )\n                .append( '\\n' );\n            sb.append( \"    <pluginManagement>\" ).append( '\\n' );\n            sb.append( \"      <plugins>\" ).append( '\\n' );\n            sb.append( \"        <plugin>\" ).append( '\\n' );\n            sb.append( \"          <groupId>\" ).append( pluginDescriptor.getGroupId() ).append( \"<\/groupId>\" )\n                .append( '\\n' );\n            sb.append( \"          <artifactId>\" ).append( pluginDescriptor.getArtifactId() ).append( \"<\/artifactId>\" )\n                .append( '\\n' );\n            sb.append( \"          <version>\" ).append( pluginDescriptor.getVersion() ).append( \"<\/version>\" )\n                .append( '\\n' );\n            sb.append( \"        <\/plugin>\" ).append( '\\n' );\n            sb.append( \"        ...\" ).append( '\\n' );\n            sb.append( \"      <\/plugins>\" ).append( '\\n' );\n            sb.append( \"    <\/pluginManagement>\" ).append( '\\n' );\n            sb.append( \"    <!-- \" + getBundle( locale ).getString( \"report.plugin.usage.plugins\" ) + \" -->\" )\n                .append( '\\n' );\n            sb.append( \"    <plugins>\" ).append( '\\n' );\n            sb.append( \"      <plugin>\" ).append( '\\n' );\n            sb.append( \"        <groupId>\" ).append( pluginDescriptor.getGroupId() ).append( \"<\/groupId>\" )\n                .append( '\\n' );\n            sb.append( \"        <artifactId>\" ).append( pluginDescriptor.getArtifactId() ).append( \"<\/artifactId>\" )\n                .append( '\\n' );\n            sb.append( \"        <version>\" ).append( pluginDescriptor.getVersion() ).append( \"<\/version>\" )\n            .append( '\\n' );\n            sb.append( \"      <\/plugin>\" ).append( '\\n' );\n            sb.append( \"      ...\" ).append( '\\n' );\n            sb.append( \"    <\/plugins>\" ).append( '\\n' );\n            sb.append( \"  <\/build>\" ).append( '\\n' );\n\n            if ( hasMavenReport )\n            {\n                sb.append( \"  ...\" ).append( '\\n' );\n                sb.append( \"  <!-- \" + getBundle( locale ).getString( \"report.plugin.usage.reporting\" ) + \" -->\" )\n                    .append( '\\n' );\n                sb.append( \"  <reporting>\" ).append( '\\n' );\n                sb.append( \"    <plugins>\" ).append( '\\n' );\n                sb.append( \"      <plugin>\" ).append( '\\n' );\n                sb.append( \"        <groupId>\" ).append( pluginDescriptor.getGroupId() ).append( \"<\/groupId>\" )\n                    .append( '\\n' );\n                sb.append( \"        <artifactId>\" ).append( pluginDescriptor.getArtifactId() ).append( \"<\/artifactId>\" )\n                    .append( '\\n' );\n                sb.append( \"        <version>\" ).append( pluginDescriptor.getVersion() ).append( \"<\/version>\" )\n                    .append( '\\n' );\n                sb.append( \"      <\/plugin>\" ).append( '\\n' );\n                sb.append( \"      ...\" ).append( '\\n' );\n                sb.append( \"    <\/plugins>\" ).append( '\\n' );\n                sb.append( \"  <\/reporting>\" ).append( '\\n' );\n            }\n\n            sb.append( \"  ...\" ).append( '\\n' );\n            sb.append( \"<\/project>\" ).append( '\\n' );\n\n            verbatimText( sb.toString() );\n\n            sink.paragraph();\n            linkPatternedText( getBundle( locale ).getString( \"report.plugin.configuration.end\" ) );\n            sink.paragraph_();\n\n            endSection();\n        }\n\n        /**\n         * Try to lookup on the Maven prerequisites property.\n         * If not specified, uses the value defined by the user.\n         *\n         * @param project not null\n         * @param requirements not null\n         * @return the Maven version\n         */\n        private static String discoverMavenRequirement( MavenProject project, Requirements requirements )\n        {\n            String maven = requirements.getMaven();\n            if ( maven == null )\n            {\n                maven = ( project.getPrerequisites() != null ? project.getPrerequisites().getMaven() : null );\n            }\n            if ( maven == null )\n            {\n                maven = \"2.0\";\n            }\n\n            return maven;\n        }\n\n        /**\n         * Try to lookup on the <code>org.apache.maven.plugins:maven-compiler-plugin<\/code> plugin to\n         * find the value of the <code>target<\/code> option.\n         * If not specified, uses the value defined by the user.\n         * If not specified, uses the value of the system property <code>java.specification.version<\/code>.\n         *\n         * @param project not null\n         * @param requirements not null\n         * @return the JDK version\n         */\n        private static String discoverJdkRequirement( MavenProject project, Requirements requirements )\n        {\n            String jdk = requirements.getJdk();\n            if ( jdk == null )\n            {\n                jdk = discoverJdkRequirementFromPlugins( project.getBuild().getPluginsAsMap() );\n            }\n            if ( jdk == null )\n            {\n                if ( project.getPluginManagement() != null )\n                {\n                    jdk = discoverJdkRequirementFromPlugins( project.getPluginManagement().getPluginsAsMap() );\n                }\n            }\n            if ( jdk == null )\n            {\n                jdk = \"Unknown\";\n            }\n\n            return jdk;\n        }\n\n        /**\n         * @param pluginsAsMap could be null\n         * @return the value of the <code>target<\/code> in the configuration of <code>maven-compiler-plugin<\/code>.\n         */\n        @SuppressWarnings( \"rawtypes\" )\n        private static String discoverJdkRequirementFromPlugins( Map pluginsAsMap )\n        {\n            if ( pluginsAsMap == null )\n            {\n                return null;\n            }\n\n            String jdk = null;\n            String backupJdk = null;\n            for ( Iterator it = pluginsAsMap.keySet().iterator(); it.hasNext(); )\n            {\n                String key = it.next().toString();\n\n                if ( !key.equals( \"org.apache.maven.plugins:maven-compiler-plugin\" ) )\n                {\n                    continue;\n                }\n\n                Object value = pluginsAsMap.get( key );\n                Xpp3Dom pluginConf = null;\n\n                backupJdk = \"Default version for maven-compiler-plugin\";\n                if ( value instanceof Plugin )\n                {\n                    Plugin plugin = (Plugin) value;\n                    backupJdk = \"Default target for maven-compiler-plugin version \" + plugin.getVersion();\n                    pluginConf = (Xpp3Dom) plugin.getConfiguration();\n                }\n\n                if ( value instanceof ReportPlugin )\n                {\n                    ReportPlugin reportPlugin = (ReportPlugin) value;\n                    backupJdk = \"Default target for maven-compiler-plugin version \" + reportPlugin.getVersion();\n                    pluginConf = (Xpp3Dom) reportPlugin.getConfiguration();\n                }\n\n                if ( pluginConf == null )\n                {\n                    continue;\n                }\n\n                if ( pluginConf.getChild( \"target\" ) == null )\n                {\n                    continue;\n                }\n\n                jdk = pluginConf.getChild( \"target\" ).getValue();\n            }\n\n            if ( jdk == null ) \n            {\n                return backupJdk;\n            }\n            else \n            {\n                return jdk;\n            }\n        }\n    }\n}\n","lineNo":304}
{"Refactored Sample":"package org.apache.maven.tools.plugin.annotations.scanner;\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ComponentAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ExecuteAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.MojoAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ParameterAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoAnnotationVisitor;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoClassVisitor;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoFieldVisitor;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.DirectoryScanner;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.reflection.Reflector;\nimport org.objectweb.asm.ClassReader;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\n/**\n * @author Olivier Lamy\n * @since 3.0\n */\npublic class DefaultMojoAnnotationsScanner\n    extends AbstractLogEnabled\n    implements MojoAnnotationsScanner\n{\n    private Reflector reflector = new Reflector();\n\n    public Map<String, MojoAnnotatedClass> scan( MojoAnnotationsScannerRequest request )\n        throws ExtractionException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n        try\n        {\n\n            for ( Artifact dependency : request.getDependencies() )\n            {\n                File dependencyFile = dependency.getFile();\n                if ( dependencyFile != null && dependencyFile.exists() )\n                {\n                    if ( dependencyFile.isDirectory() )\n                    {\n                        mojoAnnotatedClasses.putAll( scanDirectory( dependencyFile, request.getIncludePatterns() ) );\n                    }\n                    else\n                    {\n                        mojoAnnotatedClasses.putAll( scanFile( dependencyFile, request.getIncludePatterns() ) );\n                    }\n                }\n            }\n\n            for ( File classDirectory : request.getClassesDirectories() )\n            {\n                if ( classDirectory.exists() && classDirectory.isDirectory() )\n                {\n                    mojoAnnotatedClasses.putAll( scanDirectory( classDirectory, request.getIncludePatterns() ) );\n                }\n            }\n\n            return mojoAnnotatedClasses;\n        }\n        catch ( IOException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n\n    protected Map<String, MojoAnnotatedClass> scanFile( File archiveFile, List<String> includePatterns )\n        throws IOException, ExtractionException\n    {\n        if ( !archiveFile.exists() )\n        {\n            return Collections.emptyMap();\n        }\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n        ZipInputStream archiveStream = new ZipInputStream( new FileInputStream( archiveFile ) );\n\n        try\n        {\n            for ( ZipEntry zipEntry = archiveStream.getNextEntry(); zipEntry != null;\n                  zipEntry = archiveStream.getNextEntry() )\n            {\n                if ( zipEntry.getName().endsWith( \".class\" ) )\n                {\n                    MojoClassVisitor mojoClassVisitor = new MojoClassVisitor( getLogger() );\n\n                    ClassReader rdr = new ClassReader( archiveStream );\n                    rdr.accept( mojoClassVisitor,\n                                ClassReader.SKIP_FRAMES | ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG );\n                    analyzeVisitors( mojoClassVisitor );\n                    if ( isMojoAnnnotatedClassCandidate( mojoClassVisitor.getMojoAnnotatedClass() ) != null )\n                    {\n                        getLogger().debug(\n                            \"found MojoAnnotatedClass:\" + mojoClassVisitor.getMojoAnnotatedClass().getClassName() + \":\"\n                                + mojoClassVisitor.getMojoAnnotatedClass() );\n                        mojoAnnotatedClasses.put( mojoClassVisitor.getMojoAnnotatedClass().getClassName(),\n                                                  mojoClassVisitor.getMojoAnnotatedClass() );\n                    }\n                }\n            }\n        }\n        finally\n        {\n            IOUtil.close( archiveStream );\n        }\n        return mojoAnnotatedClasses;\n    }\n\n    protected Map<String, MojoAnnotatedClass> scanDirectory( File classDirectory, List<String> includePatterns )\n        throws IOException, ExtractionException\n    {\n        if ( !classDirectory.exists() )\n        {\n            return Collections.emptyMap();\n        }\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n        DirectoryScanner scanner = new DirectoryScanner();\n        scanner.setBasedir( classDirectory );\n        scanner.addDefaultExcludes();\n        if ( includePatterns != null )\n        {\n            scanner.setIncludes( includePatterns.toArray( new String[includePatterns.size()] ) );\n        }\n        scanner.scan();\n        String[] classFiles = scanner.getIncludedFiles();\n\n        for ( String classFile : classFiles )\n        {\n            InputStream is = new BufferedInputStream( new FileInputStream( new File( classDirectory, classFile ) ) );\n            try\n            {\n\n                if ( classFile.endsWith( \".class\" ) )\n                {\n                    MojoClassVisitor mojoClassVisitor = new MojoClassVisitor( getLogger() );\n                    ClassReader rdr = new ClassReader( is );\n                    rdr.accept( mojoClassVisitor,\n                                ClassReader.SKIP_FRAMES | ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG );\n                    analyzeVisitors( mojoClassVisitor );\n                    if ( isMojoAnnnotatedClassCandidate( mojoClassVisitor.getMojoAnnotatedClass() ) != null )\n                    {\n                        getLogger().debug(\n                            \"found MojoAnnotatedClass:\" + mojoClassVisitor.getMojoAnnotatedClass().getClassName() + \":\"\n                                + mojoClassVisitor.getMojoAnnotatedClass() );\n                        mojoAnnotatedClasses.put( mojoClassVisitor.getMojoAnnotatedClass().getClassName(),\n                                                  mojoClassVisitor.getMojoAnnotatedClass() );\n                    }\n\n                }\n            }\n            finally\n            {\n                IOUtil.close( is );\n            }\n\n        }\n        return mojoAnnotatedClasses;\n    }\n\n    private MojoAnnotatedClass isMojoAnnnotatedClassCandidate( MojoAnnotatedClass mojoAnnotatedClass )\n    {\n        if ( mojoAnnotatedClass == null )\n        {\n            return null;\n        }\n        if ( !mojoAnnotatedClass.getComponents().isEmpty() || !mojoAnnotatedClass.getParameters().isEmpty()\n            || mojoAnnotatedClass.getExecute() != null || mojoAnnotatedClass.getMojo() != null )\n        {\n            return mojoAnnotatedClass;\n        }\n        return null;\n    }\n\n    protected void analyzeVisitors( MojoClassVisitor mojoClassVisitor )\n        throws ExtractionException\n    {\n\n        try\n        {\n            MojoAnnotationVisitor mojoAnnotationVisitor =\n                mojoClassVisitor.getAnnotationVisitorMap().get( Mojo.class.getName() );\n            if ( mojoAnnotationVisitor != null )\n            {\n                MojoAnnotationContent mojoAnnotationContent = new MojoAnnotationContent();\n                for ( Map.Entry<String, Object> entry : mojoAnnotationVisitor.getAnnotationValues().entrySet() )\n                {\n                    reflector.invoke( mojoAnnotationContent, entry.getKey(), new Object[]{ entry.getValue() } );\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().setMojo( mojoAnnotationContent );\n            }\n\n            mojoAnnotationVisitor = mojoClassVisitor.getAnnotationVisitorMap().get( Execute.class.getName() );\n            if ( mojoAnnotationVisitor != null )\n            {\n                ExecuteAnnotationContent executeAnnotationContent = new ExecuteAnnotationContent();\n\n                for ( Map.Entry<String, Object> entry : mojoAnnotationVisitor.getAnnotationValues().entrySet() )\n                {\n                    reflector.invoke( executeAnnotationContent, entry.getKey(), new Object[]{ entry.getValue() } );\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().setExecute( executeAnnotationContent );\n            }\n\n            List<MojoFieldVisitor> mojoFieldVisitors =\n                mojoClassVisitor.findFieldWithAnnotationClass( Parameter.class.getName() );\n\n            for ( MojoFieldVisitor mojoFieldVisitor : mojoFieldVisitors )\n            {\n                ParameterAnnotationContent parameterAnnotationContent =\n                    new ParameterAnnotationContent( mojoFieldVisitor.getFieldName(), mojoFieldVisitor.getClassName() );\n                if ( mojoFieldVisitor.getMojoAnnotationVisitor() != null )\n                {\n                    for ( Map.Entry<String, Object> entry : mojoFieldVisitor.getMojoAnnotationVisitor().getAnnotationValues().entrySet() )\n                    {\n                        reflector.invoke( parameterAnnotationContent, entry.getKey(),\n                                          new Object[]{ entry.getValue() } );\n                    }\n\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().getParameters().put( parameterAnnotationContent.getFieldName(),\n                                                                              parameterAnnotationContent );\n            }\n\n            mojoFieldVisitors = mojoClassVisitor.findFieldWithAnnotationClass( Component.class.getName() );\n\n            for ( MojoFieldVisitor mojoFieldVisitor : mojoFieldVisitors )\n            {\n                ComponentAnnotationContent componentAnnotationContent =\n                    new ComponentAnnotationContent( mojoFieldVisitor.getFieldName() );\n\n                if ( mojoFieldVisitor.getMojoAnnotationVisitor() != null )\n                {\n                    for ( Map.Entry<String, Object> entry : mojoFieldVisitor.getMojoAnnotationVisitor().getAnnotationValues().entrySet() )\n                    {\n                        reflector.invoke( componentAnnotationContent, entry.getKey(),\n                                          new Object[]{ entry.getValue() } );\n                    }\n                    if ( StringUtils.isEmpty( componentAnnotationContent.role() ) )\n                    {\n                        componentAnnotationContent.role( mojoFieldVisitor.getClassName() );\n                    }\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().getComponents().put( componentAnnotationContent.getFieldName(),\n                                                                              componentAnnotationContent );\n            }\n\n        }\n        catch ( Exception e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.annotations.scanner;\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ComponentAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ExecuteAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.MojoAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ParameterAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoAnnotationVisitor;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoClassVisitor;\nimport org.apache.maven.tools.plugin.annotations.scanner.visitors.MojoFieldVisitor;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.DirectoryScanner;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.reflection.Reflector;\nimport org.objectweb.asm.ClassReader;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\n/**\n * @author Olivier Lamy\n * @since 3.0\n */\npublic class DefaultMojoAnnotationsScanner\n    extends AbstractLogEnabled\n    implements MojoAnnotationsScanner\n{\n    private Reflector reflector = new Reflector();\n\n    public Map<String, MojoAnnotatedClass> scan( MojoAnnotationsScannerRequest request )\n        throws ExtractionException\n    {\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n        try\n        {\n\n            for ( File dependency : request.getDependencies() )\n            {\n                if ( dependency.isDirectory() )\n                {\n                    mojoAnnotatedClasses.putAll( scanDirectory( dependency, request.getIncludePatterns() ) );\n                }\n                else\n                {\n                    mojoAnnotatedClasses.putAll( scanFile( dependency, request.getIncludePatterns() ) );\n                }\n\n            }\n\n            for ( File classDirectory : request.getClassesDirectories() )\n            {\n                if ( classDirectory.exists() && classDirectory.isDirectory() )\n                {\n                    mojoAnnotatedClasses.putAll( scanDirectory( classDirectory, request.getIncludePatterns() ) );\n                }\n            }\n\n            return mojoAnnotatedClasses;\n        }\n        catch ( IOException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n\n    protected Map<String, MojoAnnotatedClass> scanFile( File archiveFile, List<String> includePatterns )\n        throws IOException, ExtractionException\n    {\n        if ( !archiveFile.exists() )\n        {\n            return Collections.emptyMap();\n        }\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n        ZipInputStream archiveStream = new ZipInputStream( new FileInputStream( archiveFile ) );\n\n        try\n        {\n            for ( ZipEntry zipEntry = archiveStream.getNextEntry(); zipEntry != null;\n                  zipEntry = archiveStream.getNextEntry() )\n            {\n                if ( zipEntry.getName().endsWith( \".class\" ) )\n                {\n                    MojoClassVisitor mojoClassVisitor = new MojoClassVisitor( getLogger() );\n\n                    ClassReader rdr = new ClassReader( archiveStream );\n                    rdr.accept( mojoClassVisitor,\n                                ClassReader.SKIP_FRAMES | ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG );\n                    analyzeVisitors( mojoClassVisitor );\n                    if ( isMojoAnnnotatedClassCandidate( mojoClassVisitor.getMojoAnnotatedClass() ) != null )\n                    {\n                        getLogger().debug(\n                            \"found MojoAnnotatedClass:\" + mojoClassVisitor.getMojoAnnotatedClass().getClassName() + \":\"\n                                + mojoClassVisitor.getMojoAnnotatedClass() );\n                        mojoAnnotatedClasses.put( mojoClassVisitor.getMojoAnnotatedClass().getClassName(),\n                                                  mojoClassVisitor.getMojoAnnotatedClass() );\n                    }\n                }\n            }\n        }\n        finally\n        {\n            IOUtil.close( archiveStream );\n        }\n        return mojoAnnotatedClasses;\n    }\n\n    protected Map<String, MojoAnnotatedClass> scanDirectory( File classDirectory, List<String> includePatterns )\n        throws IOException, ExtractionException\n    {\n        if ( !classDirectory.exists() )\n        {\n            return Collections.emptyMap();\n        }\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses = new HashMap<String, MojoAnnotatedClass>();\n        DirectoryScanner scanner = new DirectoryScanner();\n        scanner.setBasedir( classDirectory );\n        scanner.addDefaultExcludes();\n        if ( includePatterns != null )\n        {\n            scanner.setIncludes( includePatterns.toArray( new String[includePatterns.size()] ) );\n        }\n        scanner.scan();\n        String[] classFiles = scanner.getIncludedFiles();\n\n        for ( String classFile : classFiles )\n        {\n            InputStream is = new BufferedInputStream( new FileInputStream( new File( classDirectory, classFile ) ) );\n            try\n            {\n\n                if ( classFile.endsWith( \".class\" ) )\n                {\n                    MojoClassVisitor mojoClassVisitor = new MojoClassVisitor( getLogger() );\n                    ClassReader rdr = new ClassReader( is );\n                    rdr.accept( mojoClassVisitor,\n                                ClassReader.SKIP_FRAMES | ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG );\n                    analyzeVisitors( mojoClassVisitor );\n                    if ( isMojoAnnnotatedClassCandidate( mojoClassVisitor.getMojoAnnotatedClass() ) != null )\n                    {\n                        getLogger().debug(\n                            \"found MojoAnnotatedClass:\" + mojoClassVisitor.getMojoAnnotatedClass().getClassName() + \":\"\n                                + mojoClassVisitor.getMojoAnnotatedClass() );\n                        mojoAnnotatedClasses.put( mojoClassVisitor.getMojoAnnotatedClass().getClassName(),\n                                                  mojoClassVisitor.getMojoAnnotatedClass() );\n                    }\n\n                }\n            }\n            finally\n            {\n                IOUtil.close( is );\n            }\n\n        }\n        return mojoAnnotatedClasses;\n    }\n\n    private MojoAnnotatedClass isMojoAnnnotatedClassCandidate( MojoAnnotatedClass mojoAnnotatedClass )\n    {\n        if ( mojoAnnotatedClass == null )\n        {\n            return null;\n        }\n        if ( !mojoAnnotatedClass.getComponents().isEmpty() || !mojoAnnotatedClass.getParameters().isEmpty()\n            || mojoAnnotatedClass.getExecute() != null || mojoAnnotatedClass.getMojo() != null )\n        {\n            return mojoAnnotatedClass;\n        }\n        return null;\n    }\n\n    protected void analyzeVisitors( MojoClassVisitor mojoClassVisitor )\n        throws ExtractionException\n    {\n\n        try\n        {\n            MojoAnnotationVisitor mojoAnnotationVisitor =\n                mojoClassVisitor.getAnnotationVisitorMap().get( Mojo.class.getName() );\n            if ( mojoAnnotationVisitor != null )\n            {\n                MojoAnnotationContent mojoAnnotationContent = new MojoAnnotationContent();\n                for ( Map.Entry<String, Object> entry : mojoAnnotationVisitor.getAnnotationValues().entrySet() )\n                {\n                    reflector.invoke( mojoAnnotationContent, entry.getKey(), new Object[]{ entry.getValue() } );\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().setMojo( mojoAnnotationContent );\n            }\n\n            mojoAnnotationVisitor = mojoClassVisitor.getAnnotationVisitorMap().get( Execute.class.getName() );\n            if ( mojoAnnotationVisitor != null )\n            {\n                ExecuteAnnotationContent executeAnnotationContent = new ExecuteAnnotationContent();\n\n                for ( Map.Entry<String, Object> entry : mojoAnnotationVisitor.getAnnotationValues().entrySet() )\n                {\n                    reflector.invoke( executeAnnotationContent, entry.getKey(), new Object[]{ entry.getValue() } );\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().setExecute( executeAnnotationContent );\n            }\n\n            List<MojoFieldVisitor> mojoFieldVisitors =\n                mojoClassVisitor.findFieldWithAnnotationClass( Parameter.class.getName() );\n\n            for ( MojoFieldVisitor mojoFieldVisitor : mojoFieldVisitors )\n            {\n                ParameterAnnotationContent parameterAnnotationContent =\n                    new ParameterAnnotationContent( mojoFieldVisitor.getFieldName(), mojoFieldVisitor.getClassName() );\n                if ( mojoFieldVisitor.getMojoAnnotationVisitor() != null )\n                {\n                    for ( Map.Entry<String, Object> entry : mojoFieldVisitor.getMojoAnnotationVisitor().getAnnotationValues().entrySet() )\n                    {\n                        reflector.invoke( parameterAnnotationContent, entry.getKey(),\n                                          new Object[]{ entry.getValue() } );\n                    }\n\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().getParameters().put( parameterAnnotationContent.getFieldName(),\n                                                                              parameterAnnotationContent );\n            }\n\n            mojoFieldVisitors = mojoClassVisitor.findFieldWithAnnotationClass( Component.class.getName() );\n\n            for ( MojoFieldVisitor mojoFieldVisitor : mojoFieldVisitors )\n            {\n                ComponentAnnotationContent componentAnnotationContent =\n                    new ComponentAnnotationContent( mojoFieldVisitor.getFieldName() );\n\n                if ( mojoFieldVisitor.getMojoAnnotationVisitor() != null )\n                {\n                    for ( Map.Entry<String, Object> entry : mojoFieldVisitor.getMojoAnnotationVisitor().getAnnotationValues().entrySet() )\n                    {\n                        reflector.invoke( componentAnnotationContent, entry.getKey(),\n                                          new Object[]{ entry.getValue() } );\n                    }\n                    if ( StringUtils.isEmpty( componentAnnotationContent.role() ) )\n                    {\n                        componentAnnotationContent.role( mojoFieldVisitor.getClassName() );\n                    }\n                }\n                mojoClassVisitor.getMojoAnnotatedClass().getComponents().put( componentAnnotationContent.getFieldName(),\n                                                                              componentAnnotationContent );\n            }\n\n        }\n        catch ( Exception e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n}\n","lineNo":72}
{"Refactored Sample":"package org.apache.maven.tools.plugin.annotations;\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport com.thoughtworks.qdox.JavaDocBuilder;\nimport com.thoughtworks.qdox.model.DocletTag;\nimport com.thoughtworks.qdox.model.JavaClass;\nimport com.thoughtworks.qdox.model.JavaField;\nimport org.apache.maven.artifact.DependencyResolutionRequiredException;\nimport org.apache.maven.plugin.descriptor.DuplicateParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ComponentAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ExecuteAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.MojoAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ParameterAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotatedClass;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScanner;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScannerRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\n/**\n * @author Olivier Lamy\n * @since 3.0\n */\npublic class JavaAnnotationsMojoDescriptorExtractor\n    extends AbstractLogEnabled\n    implements MojoDescriptorExtractor\n{\n\n    /**\n     * @requirement\n     */\n    MojoAnnotationsScanner mojoAnnotationsScanner;\n\n    public List<MojoDescriptor> execute( MavenProject project, PluginDescriptor pluginDescriptor )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        return execute( new DefaultPluginToolsRequest( project, pluginDescriptor ) );\n    }\n\n    public List<MojoDescriptor> execute( PluginToolsRequest request )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        try\n        {\n            MojoAnnotationsScannerRequest mojoAnnotationsScannerRequest = new MojoAnnotationsScannerRequest();\n\n            mojoAnnotationsScannerRequest.setClassesDirectories(\n                Arrays.asList( new File( request.getProject().getBuild().getOutputDirectory() ) ) );\n\n            mojoAnnotationsScannerRequest.setDependencies(\n                toFiles( request.getProject().getCompileClasspathElements() ) );\n\n            Map<String, MojoAnnotatedClass> mojoAnnotatedClasses =\n                mojoAnnotationsScanner.scan( mojoAnnotationsScannerRequest );\n\n            Map<String, JavaClass> javaClassesMap = discoverClasses( request );\n\n            populateDataFromJavadoc( mojoAnnotatedClasses, javaClassesMap );\n\n            return toMojoDescriptors( mojoAnnotatedClasses, request );\n        }\n        catch ( DependencyResolutionRequiredException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n\n    /**\n     * from sources scan to get @since and @deprecated and description of classes and fields.\n     *\n     * @param mojoAnnotatedClasses\n     * @param javaClassesMap\n     */\n    protected void populateDataFromJavadoc( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                            Map<String, JavaClass> javaClassesMap )\n    {\n\n        for ( Map.Entry<String, MojoAnnotatedClass> entry : mojoAnnotatedClasses.entrySet() )\n        {\n            JavaClass javaClass = javaClassesMap.get( entry.getKey() );\n            if ( javaClass != null )\n            {\n                MojoAnnotationContent mojoAnnotationContent = entry.getValue().getMojo();\n                if ( mojoAnnotationContent != null )\n                {\n                    mojoAnnotationContent.setDescription( javaClass.getComment() );\n                    DocletTag since = findInClassHierarchy( javaClass, \"since\" );\n                    if ( since != null )\n                    {\n                        mojoAnnotationContent.setSince( since.getValue() );\n                    }\n\n                    DocletTag deprecated = findInClassHierarchy( javaClass, \"deprecated\" );\n                    if ( deprecated != null )\n                    {\n                        mojoAnnotationContent.setDeprecated( deprecated.getValue() );\n                    }\n                }\n                Map<String, JavaField> fieldsMap = extractFieldParameterTags( javaClass );\n                for ( Map.Entry<String, ParameterAnnotationContent> parameter : entry.getValue().getParameters().entrySet() )\n                {\n                    JavaField javaField = fieldsMap.get( parameter.getKey() );\n                    if ( javaField != null )\n                    {\n                        ParameterAnnotationContent parameterAnnotationContent = parameter.getValue();\n                        DocletTag deprecated = javaField.getTagByName( \"deprecated\" );\n                        if ( deprecated != null )\n                        {\n                            parameterAnnotationContent.setDeprecated( deprecated.getValue() );\n                        }\n                        DocletTag since = javaField.getTagByName( \"since\" );\n                        if ( since != null )\n                        {\n                            parameterAnnotationContent.setSince( since.getValue() );\n                        }\n                        parameterAnnotationContent.setDescription( javaField.getComment() );\n                    }\n                }\n\n                for ( Map.Entry<String, ComponentAnnotationContent> component : entry.getValue().getComponents().entrySet() )\n                {\n                    JavaField javaField = fieldsMap.get( component.getKey() );\n                    if ( javaField != null )\n                    {\n                        ComponentAnnotationContent componentAnnotationContent = component.getValue();\n                        DocletTag deprecated = javaField.getTagByName( \"deprecated\" );\n                        if ( deprecated != null )\n                        {\n                            componentAnnotationContent.setDeprecated( deprecated.getValue() );\n                        }\n                        DocletTag since = javaField.getTagByName( \"since\" );\n                        if ( since != null )\n                        {\n                            componentAnnotationContent.setSince( since.getValue() );\n                        }\n                        componentAnnotationContent.setDescription( javaField.getComment() );\n                    }\n                }\n\n            }\n        }\n\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName   not null\n     * @return docletTag instance\n     */\n    private static DocletTag findInClassHierarchy( JavaClass javaClass, String tagName )\n    {\n        DocletTag tag = javaClass.getTagByName( tagName );\n\n        if ( tag == null )\n        {\n            JavaClass superClass = javaClass.getSuperJavaClass();\n\n            if ( superClass != null )\n            {\n                tag = findInClassHierarchy( superClass, tagName );\n            }\n        }\n\n        return tag;\n    }\n\n    /**\n     * extract fields that are either parameters or components.\n     *\n     * @param javaClass not null\n     * @return map with Mojo parameters names as keys\n     */\n    private Map<String, JavaField> extractFieldParameterTags( JavaClass javaClass )\n    {\n        Map<String, JavaField> rawParams;\n\n        // we have to add the parent fields first, so that they will be overwritten by the local fields if\n        // that actually happens...\n        JavaClass superClass = javaClass.getSuperJavaClass();\n\n        if ( superClass != null )\n        {\n            rawParams = extractFieldParameterTags( superClass );\n        }\n        else\n        {\n            rawParams = new TreeMap<String, JavaField>();\n        }\n\n        JavaField[] classFields = javaClass.getFields();\n\n        if ( classFields != null )\n        {\n            for ( JavaField field : classFields )\n            {\n                rawParams.put( field.getName(), field );\n            }\n        }\n        return rawParams;\n    }\n\n    protected Map<String, JavaClass> discoverClasses( final PluginToolsRequest request )\n    {\n        JavaDocBuilder builder = new JavaDocBuilder();\n        builder.setEncoding( request.getEncoding() );\n\n        MavenProject project = request.getProject();\n\n        for ( String source : (List<String>) project.getCompileSourceRoots() )\n        {\n            builder.addSourceTree( new File( source ) );\n        }\n\n        // TODO be more dynamic\n        File generatedPlugin = new File( project.getBasedir(), \"target/generated-sources/plugin\" );\n        if ( !project.getCompileSourceRoots().contains( generatedPlugin.getAbsolutePath() ) )\n        {\n            builder.addSourceTree( generatedPlugin );\n        }\n\n        JavaClass[] javaClasses = builder.getClasses();\n\n        if ( javaClasses == null || javaClasses.length < 1 )\n        {\n            return Collections.emptyMap();\n        }\n\n        Map<String, JavaClass> javaClassMap = new HashMap<String, JavaClass>( javaClasses.length );\n\n        for ( JavaClass javaClass : javaClasses )\n        {\n            javaClassMap.put( javaClass.getFullyQualifiedName(), javaClass );\n        }\n\n        return javaClassMap;\n    }\n\n    private List<File> toFiles( List<String> directories )\n    {\n        if ( directories == null )\n        {\n            return Collections.emptyList();\n        }\n        List<File> files = new ArrayList<File>( directories.size() );\n        for ( String directory : directories )\n        {\n            files.add( new File( directory ) );\n        }\n        return files;\n    }\n\n    private List<MojoDescriptor> toMojoDescriptors( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                                    PluginToolsRequest request )\n        throws DuplicateParameterException\n    {\n        List<MojoDescriptor> mojoDescriptors = new ArrayList<MojoDescriptor>( mojoAnnotatedClasses.size() );\n        for ( MojoAnnotatedClass mojoAnnotatedClass : mojoAnnotatedClasses.values() )\n        {\n            // no mojo so skip it\n            if ( mojoAnnotatedClass.getMojo() == null )\n            {\n                continue;\n            }\n\n            ExtendedMojoDescriptor mojoDescriptor = new ExtendedMojoDescriptor();\n\n            //mojoDescriptor.setRole( mojoAnnotatedClass.getClassName() );\n            //mojoDescriptor.setRoleHint( \"default\" );\n            mojoDescriptor.setImplementation( mojoAnnotatedClass.getClassName() );\n            mojoDescriptor.setLanguage( \"java\" );\n\n            MojoAnnotationContent mojo = mojoAnnotatedClass.getMojo();\n\n            mojoDescriptor.setDescription( mojo.getDescription() );\n            mojoDescriptor.setSince( mojo.getSince() );\n            mojo.setDeprecated( mojo.getDeprecated() );\n\n            mojoDescriptor.setAggregator( mojo.aggregator() );\n            mojoDescriptor.setDependencyResolutionRequired( mojo.requiresDependencyResolution() );\n            mojoDescriptor.setDependencyCollectionRequired( mojo.requiresDependencyCollection() );\n\n            mojoDescriptor.setDirectInvocationOnly( mojo.requiresDirectInvocation() );\n            mojoDescriptor.setDeprecated( mojo.getDeprecated() );\n            mojoDescriptor.setThreadSafe( mojo.threadSafe() );\n\n            ExecuteAnnotationContent execute = mojoAnnotatedClass.getExecute();\n\n            if ( execute != null )\n            {\n                mojoDescriptor.setExecuteGoal( execute.goal() );\n                mojoDescriptor.setExecuteLifecycle( execute.lifecycle() );\n                mojoDescriptor.setExecutePhase( execute.phase().id() );\n            }\n\n            mojoDescriptor.setExecutionStrategy( mojo.executionStrategy() );\n            // FIXME olamy wtf ?\n            //mojoDescriptor.alwaysExecute(mojo.a)\n\n            mojoDescriptor.setGoal( mojo.name() );\n            mojoDescriptor.setOnlineRequired( mojo.requiresOnline() );\n\n            mojoDescriptor.setPhase( mojo.defaultPhase().id() );\n\n            Map<String, ParameterAnnotationContent> parameters =\n                getParametersParentHierarchy( mojoAnnotatedClass, new HashMap<String, ParameterAnnotationContent>(),\n                                              mojoAnnotatedClasses );\n\n            for ( ParameterAnnotationContent parameterAnnotationContent : parameters.values() )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                parameter.setName( parameterAnnotationContent.getFieldName() );\n                parameter.setAlias( parameterAnnotationContent.alias() );\n                parameter.setDefaultValue( parameterAnnotationContent.defaultValue() );\n                parameter.setDeprecated( parameterAnnotationContent.getDeprecated() );\n                parameter.setDescription( parameterAnnotationContent.getDescription() );\n                parameter.setEditable( !parameterAnnotationContent.readonly() );\n                parameter.setExpression( parameterAnnotationContent.expression() );\n                parameter.setType( parameterAnnotationContent.getClassName() );\n                parameter.setRequired( parameterAnnotationContent.required() );\n\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            for ( ComponentAnnotationContent componentAnnotationContent : mojoAnnotatedClass.getComponents().values() )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                parameter.setName( componentAnnotationContent.getFieldName() );\n                parameter.setRequirement(\n                    new Requirement( componentAnnotationContent.role(), componentAnnotationContent.roleHint() ) );\n                parameter.setEditable( false );\n\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            mojoDescriptor.setPluginDescriptor( request.getPluginDescriptor() );\n\n            mojoDescriptors.add( mojoDescriptor );\n        }\n        return mojoDescriptors;\n    }\n\n    protected Map<String, ParameterAnnotationContent> getParametersParentHierarchy(\n        MojoAnnotatedClass mojoAnnotatedClass, Map<String, ParameterAnnotationContent> parameters,\n        Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        List<ParameterAnnotationContent> parameterAnnotationContents = new ArrayList<ParameterAnnotationContent>();\n\n        parameterAnnotationContents =\n            getParent( mojoAnnotatedClass, parameterAnnotationContents, mojoAnnotatedClasses );\n\n        // move to parent first to build the Map\n        Collections.reverse( parameterAnnotationContents );\n\n        Map<String, ParameterAnnotationContent> map =\n            new HashMap<String, ParameterAnnotationContent>( parameterAnnotationContents.size() );\n\n        for ( ParameterAnnotationContent parameterAnnotationContent : parameterAnnotationContents )\n        {\n            map.put( parameterAnnotationContent.getFieldName(), parameterAnnotationContent );\n        }\n        return map;\n    }\n\n    protected List<ParameterAnnotationContent> getParent( MojoAnnotatedClass mojoAnnotatedClass,\n                                                          List<ParameterAnnotationContent> parameterAnnotationContents,\n                                                          Map<String, MojoAnnotatedClass> mojoAnnotatedClasses )\n    {\n        parameterAnnotationContents.addAll( mojoAnnotatedClass.getParameters().values() );\n        String parentClassName = mojoAnnotatedClass.getParentClassName();\n        if ( parentClassName != null )\n        {\n            MojoAnnotatedClass parent = mojoAnnotatedClasses.get( parentClassName );\n            if ( parent != null )\n            {\n                return getParent( parent, parameterAnnotationContents, mojoAnnotatedClasses );\n            }\n        }\n        return parameterAnnotationContents;\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.annotations;\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport com.thoughtworks.qdox.JavaDocBuilder;\nimport com.thoughtworks.qdox.model.DocletTag;\nimport com.thoughtworks.qdox.model.JavaClass;\nimport com.thoughtworks.qdox.model.JavaField;\nimport org.apache.maven.artifact.DependencyResolutionRequiredException;\nimport org.apache.maven.plugin.descriptor.DuplicateParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ComponentAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ExecuteAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.MojoAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.datamodel.ParameterAnnotationContent;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotatedClass;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScanner;\nimport org.apache.maven.tools.plugin.annotations.scanner.MojoAnnotationsScannerRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\n/**\n * @author Olivier Lamy\n * @since 3.0\n */\npublic class JavaAnnotationsMojoDescriptorExtractor\n    extends AbstractLogEnabled\n    implements MojoDescriptorExtractor\n{\n\n    /**\n     * @requirement\n     */\n    MojoAnnotationsScanner mojoAnnotationsScanner;\n\n    public List<MojoDescriptor> execute( MavenProject project, PluginDescriptor pluginDescriptor )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        return execute( new DefaultPluginToolsRequest( project, pluginDescriptor ) );\n    }\n\n    public List<MojoDescriptor> execute( PluginToolsRequest request )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        try\n        {\n            MojoAnnotationsScannerRequest mojoAnnotationsScannerRequest = new MojoAnnotationsScannerRequest();\n\n            mojoAnnotationsScannerRequest.setClassesDirectories(\n                Arrays.asList( new File( request.getProject().getBuild().getOutputDirectory() ) ) );\n\n            mojoAnnotationsScannerRequest.setDependencies( request.getProject().getCompileClasspathElements() );\n\n            Map<String, MojoAnnotatedClass> mojoAnnotatedClasses =\n                mojoAnnotationsScanner.scan( mojoAnnotationsScannerRequest );\n\n            Map<String, JavaClass> javaClassesMap = discoverClasses( request );\n\n            populateDataFromJavadoc( mojoAnnotatedClasses, javaClassesMap );\n\n            return toMojoDescriptors( mojoAnnotatedClasses, request );\n        }\n        catch ( DependencyResolutionRequiredException e )\n        {\n            throw new ExtractionException( e.getMessage(), e );\n        }\n    }\n\n    /**\n     * from sources scan to get @since and @deprecated and description of classes and fields.\n     *\n     * @param mojoAnnotatedClasses\n     * @param javaClassesMap\n     */\n    protected void populateDataFromJavadoc( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                            Map<String, JavaClass> javaClassesMap )\n    {\n\n        for ( Map.Entry<String, MojoAnnotatedClass> entry : mojoAnnotatedClasses.entrySet() )\n        {\n            JavaClass javaClass = javaClassesMap.get( entry.getKey() );\n            if ( javaClass != null )\n            {\n                entry.getValue().getMojo().setDescription( javaClass.getComment() );\n                DocletTag since = findInClassHierarchy( javaClass, \"since\" );\n                if ( since != null )\n                {\n                    entry.getValue().getMojo().setSince( since.getValue() );\n                }\n\n                DocletTag deprecated = findInClassHierarchy( javaClass, \"deprecated\" );\n                if ( deprecated != null )\n                {\n                    entry.getValue().getMojo().setDeprecated( deprecated.getValue() );\n                }\n\n                Map<String, JavaField> fieldsMap = extractFieldParameterTags( javaClass );\n                for ( Map.Entry<String, ParameterAnnotationContent> parameter : entry.getValue().getParameters().entrySet() )\n                {\n                    JavaField javaField = fieldsMap.get( parameter.getKey() );\n                    if ( javaField != null )\n                    {\n                        ParameterAnnotationContent parameterAnnotationContent = parameter.getValue();\n                        deprecated = javaField.getTagByName( \"deprecated\" );\n                        if ( deprecated != null )\n                        {\n                            parameterAnnotationContent.setDeprecated( deprecated.getValue() );\n                        }\n                        since = javaField.getTagByName( \"since\" );\n                        if ( since != null )\n                        {\n                            parameterAnnotationContent.setSince( since.getValue() );\n                        }\n                        parameterAnnotationContent.setDescription( javaField.getComment() );\n                    }\n                }\n\n                for ( Map.Entry<String, ComponentAnnotationContent> component : entry.getValue().getComponents().entrySet() )\n                {\n                    JavaField javaField = fieldsMap.get( component.getKey() );\n                    if ( javaField != null )\n                    {\n                        ComponentAnnotationContent componentAnnotationContent = component.getValue();\n                        deprecated = javaField.getTagByName( \"deprecated\" );\n                        if ( deprecated != null )\n                        {\n                            componentAnnotationContent.setDeprecated( deprecated.getValue() );\n                        }\n                        since = javaField.getTagByName( \"since\" );\n                        if ( since != null )\n                        {\n                            componentAnnotationContent.setSince( since.getValue() );\n                        }\n                        componentAnnotationContent.setDescription( javaField.getComment() );\n                    }\n                }\n\n            }\n        }\n\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName   not null\n     * @return docletTag instance\n     */\n    private static DocletTag findInClassHierarchy( JavaClass javaClass, String tagName )\n    {\n        DocletTag tag = javaClass.getTagByName( tagName );\n\n        if ( tag == null )\n        {\n            JavaClass superClass = javaClass.getSuperJavaClass();\n\n            if ( superClass != null )\n            {\n                tag = findInClassHierarchy( superClass, tagName );\n            }\n        }\n\n        return tag;\n    }\n\n    /**\n     * extract fields that are either parameters or components.\n     *\n     * @param javaClass not null\n     * @return map with Mojo parameters names as keys\n     */\n    private Map<String, JavaField> extractFieldParameterTags( JavaClass javaClass )\n    {\n        Map<String, JavaField> rawParams;\n\n        // we have to add the parent fields first, so that they will be overwritten by the local fields if\n        // that actually happens...\n        JavaClass superClass = javaClass.getSuperJavaClass();\n\n        if ( superClass != null )\n        {\n            rawParams = extractFieldParameterTags( superClass );\n        }\n        else\n        {\n            rawParams = new TreeMap<String, JavaField>();\n        }\n\n        JavaField[] classFields = javaClass.getFields();\n\n        if ( classFields != null )\n        {\n            for ( JavaField field : classFields )\n            {\n                rawParams.put( field.getName(), field );\n            }\n        }\n        return rawParams;\n    }\n\n    protected Map<String, JavaClass> discoverClasses( final PluginToolsRequest request )\n    {\n        JavaDocBuilder builder = new JavaDocBuilder();\n        builder.setEncoding( request.getEncoding() );\n\n        MavenProject project = request.getProject();\n\n        for ( String source : (List<String>) project.getCompileSourceRoots() )\n        {\n            builder.addSourceTree( new File( source ) );\n        }\n\n        // TODO be more dynamic\n        File generatedPlugin = new File( project.getBasedir(), \"target/generated-sources/plugin\" );\n        if ( !project.getCompileSourceRoots().contains( generatedPlugin.getAbsolutePath() ) )\n        {\n            builder.addSourceTree( generatedPlugin );\n        }\n\n        JavaClass[] javaClasses = builder.getClasses();\n\n        if ( javaClasses == null || javaClasses.length < 1 )\n        {\n            return Collections.emptyMap();\n        }\n\n        Map<String, JavaClass> javaClassMap = new HashMap<String, JavaClass>( javaClasses.length );\n\n        for ( JavaClass javaClass : javaClasses )\n        {\n            javaClassMap.put( javaClass.getFullyQualifiedName(), javaClass );\n        }\n\n        return javaClassMap;\n    }\n\n    private List<File> toFiles( List<String> directories )\n    {\n        if ( directories == null )\n        {\n            return Collections.emptyList();\n        }\n        List<File> files = new ArrayList<File>( directories.size() );\n        for ( String directory : directories )\n        {\n            files.add( new File( directory ) );\n        }\n        return files;\n    }\n\n    private List<MojoDescriptor> toMojoDescriptors( Map<String, MojoAnnotatedClass> mojoAnnotatedClasses,\n                                                    PluginToolsRequest request )\n        throws DuplicateParameterException\n    {\n        List<MojoDescriptor> mojoDescriptors = new ArrayList<MojoDescriptor>( mojoAnnotatedClasses.size() );\n        for ( MojoAnnotatedClass mojoAnnotatedClass : mojoAnnotatedClasses.values() )\n        {\n            // no mojo so skip it\n            if ( mojoAnnotatedClass.getMojo() == null )\n            {\n                continue;\n            }\n\n            ExtendedMojoDescriptor mojoDescriptor = new ExtendedMojoDescriptor();\n\n            //mojoDescriptor.setRole( mojoAnnotatedClass.getClassName() );\n            //mojoDescriptor.setRoleHint( \"default\" );\n            mojoDescriptor.setImplementation( mojoAnnotatedClass.getClassName() );\n            mojoDescriptor.setLanguage( \"java\" );\n\n            MojoAnnotationContent mojo = mojoAnnotatedClass.getMojo();\n\n            mojoDescriptor.setDescription( mojo.getDescription() );\n            mojoDescriptor.setSince( mojo.getSince() );\n            mojo.setDeprecated( mojo.getDeprecated() );\n\n            mojoDescriptor.setAggregator( mojo.aggregator() );\n            mojoDescriptor.setDependencyResolutionRequired( mojo.requiresDependencyResolution() );\n            mojoDescriptor.setDependencyCollectionRequired( mojo.requiresDependencyCollection() );\n\n            mojoDescriptor.setDirectInvocationOnly( mojo.requiresDirectInvocation() );\n            mojoDescriptor.setDeprecated( mojo.getDeprecated() );\n            mojoDescriptor.setThreadSafe( mojo.threadSafe() );\n\n            ExecuteAnnotationContent execute = mojoAnnotatedClass.getExecute();\n\n            if ( execute != null )\n            {\n                mojoDescriptor.setExecuteGoal( execute.goal() );\n                mojoDescriptor.setExecuteLifecycle( execute.lifecycle() );\n                mojoDescriptor.setExecutePhase( execute.phase().id() );\n            }\n\n            mojoDescriptor.setExecutionStrategy( mojo.executionStrategy() );\n            // FIXME olamy wtf ?\n            //mojoDescriptor.alwaysExecute(mojo.a)\n\n            mojoDescriptor.setGoal( mojo.name() );\n            mojoDescriptor.setOnlineRequired( mojo.requiresOnline() );\n\n            mojoDescriptor.setPhase( mojo.defaultPhase().id() );\n\n            for ( ParameterAnnotationContent parameterAnnotationContent : mojoAnnotatedClass.getParameters().values() )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                parameter.setName( parameterAnnotationContent.getFieldName() );\n                parameter.setAlias( parameterAnnotationContent.alias() );\n                parameter.setDefaultValue( parameterAnnotationContent.defaultValue() );\n                parameter.setDeprecated( parameterAnnotationContent.getDeprecated() );\n                parameter.setDescription( parameterAnnotationContent.getDescription() );\n                parameter.setEditable( !parameterAnnotationContent.readonly() );\n                parameter.setExpression( parameterAnnotationContent.expression() );\n                parameter.setType( parameterAnnotationContent.getClassName() );\n                parameter.setRequired( parameterAnnotationContent.required() );\n\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            for ( ComponentAnnotationContent componentAnnotationContent : mojoAnnotatedClass.getComponents().values() )\n            {\n                org.apache.maven.plugin.descriptor.Parameter parameter =\n                    new org.apache.maven.plugin.descriptor.Parameter();\n                parameter.setName( componentAnnotationContent.getFieldName() );\n                parameter.setRequirement(\n                    new Requirement( componentAnnotationContent.role(), componentAnnotationContent.roleHint() ) );\n                parameter.setEditable( false );\n\n                mojoDescriptor.addParameter( parameter );\n            }\n\n            mojoDescriptor.setPluginDescriptor( request.getPluginDescriptor() );\n\n            mojoDescriptors.add( mojoDescriptor );\n        }\n        return mojoDescriptors;\n    }\n}\n","lineNo":118}
{"Refactored Sample":"package org.apache.maven.tools.plugin.extractor.java;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport com.thoughtworks.qdox.JavaDocBuilder;\nimport com.thoughtworks.qdox.model.DocletTag;\nimport com.thoughtworks.qdox.model.JavaClass;\nimport com.thoughtworks.qdox.model.JavaField;\nimport com.thoughtworks.qdox.model.Type;\n\nimport org.apache.maven.plugin.descriptor.InvalidParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\n\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\n/**\n * Extracts Mojo descriptors from <a href=\"http://java.sun.com/\">Java<\/a> sources.\n * <br/>\n * For more information about the usage tag, have a look to:\n * <a href=\"http://maven.apache.org/developers/mojo-api-specification.html\">\n * http://maven.apache.org/developers/mojo-api-specification.html<\/a>\n *\n * @todo need to add validation directives so that systems embedding maven2 can\n * get validation directives to help users in IDEs.\n * @version $Id$\n * @see org.apache.maven.plugin.descriptor.MojoDescriptor\n */\npublic class JavaMojoDescriptorExtractor\n    extends AbstractLogEnabled\n    implements MojoDescriptorExtractor, JavaMojoAnnotation\n{\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#INSTANTIATION_STRATEGY} instead of. */\n    public static final String MAVEN_PLUGIN_INSTANTIATION = JavaMojoAnnotation.INSTANTIATION_STRATEGY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#CONFIGURATOR} instead of. */\n    public static final String CONFIGURATOR = JavaMojoAnnotation.CONFIGURATOR;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER} instead of. */\n    public static final String PARAMETER = JavaMojoAnnotation.PARAMETER;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_EXPRESSION} instead of. */\n    public static final String PARAMETER_EXPRESSION = JavaMojoAnnotation.PARAMETER_EXPRESSION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_DEFAULT_VALUE} instead of. */\n    public static final String PARAMETER_DEFAULT_VALUE = JavaMojoAnnotation.PARAMETER_DEFAULT_VALUE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_ALIAS} instead of. */\n    public static final String PARAMETER_ALIAS = JavaMojoAnnotation.PARAMETER_ALIAS;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#SINCE} instead of. */\n    public static final String SINCE = JavaMojoAnnotation.SINCE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_IMPLEMENTATION} instead of. */\n    public static final String PARAMETER_IMPLEMENTATION = JavaMojoAnnotation.PARAMETER_IMPLEMENTATION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_PROPERTY} instead of. */\n    public static final String PARAMETER_PROPERTY = JavaMojoAnnotation.PARAMETER_PROPERTY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRED} instead of. */\n    public static final String REQUIRED = JavaMojoAnnotation.REQUIRED;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#DEPRECATED} instead of. */\n    public static final String DEPRECATED = JavaMojoAnnotation.DEPRECATED;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#READONLY} instead of. */\n    public static final String READONLY = JavaMojoAnnotation.READONLY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#GOAL} instead of. */\n    public static final String GOAL = JavaMojoAnnotation.GOAL;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PHASE} instead of. */\n    public static final String PHASE = JavaMojoAnnotation.PHASE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE} instead of. */\n    public static final String EXECUTE = JavaMojoAnnotation.EXECUTE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE_LIFECYCLE} instead of. */\n    public static final String EXECUTE_LIFECYCLE = JavaMojoAnnotation.EXECUTE_LIFECYCLE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE_PHASE} instead of. */\n    public static final String EXECUTE_PHASE = JavaMojoAnnotation.EXECUTE_PHASE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE_GOAL} instead of. */\n    public static final String EXECUTE_GOAL = JavaMojoAnnotation.EXECUTE_GOAL;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#DESCRIPTION} instead of. */\n    public static final String GOAL_DESCRIPTION = JavaMojoAnnotation.DESCRIPTION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_DEPENDENCY_RESOLUTION} instead of. */\n    public static final String GOAL_REQUIRES_DEPENDENCY_RESOLUTION = JavaMojoAnnotation.REQUIRES_DEPENDENCY_RESOLUTION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_PROJECT} instead of. */\n    public static final String GOAL_REQUIRES_PROJECT = JavaMojoAnnotation.REQUIRES_PROJECT;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_REPORTS} instead of. */\n    public static final String GOAL_REQUIRES_REPORTS = JavaMojoAnnotation.REQUIRES_REPORTS;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#AGGREGATOR} instead of. */\n    public static final String GOAL_IS_AGGREGATOR = JavaMojoAnnotation.AGGREGATOR;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_ONLINE} instead of. */\n    public static final String GOAL_REQUIRES_ONLINE = JavaMojoAnnotation.REQUIRES_ONLINE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#INHERIT_BY_DEFAULT} instead of. */\n    public static final String GOAL_INHERIT_BY_DEFAULT = JavaMojoAnnotation.INHERIT_BY_DEFAULT;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#MULTI_EXECUTION_STRATEGY} instead of. */\n    public static final String GOAL_MULTI_EXECUTION_STRATEGY = JavaMojoAnnotation.MULTI_EXECUTION_STRATEGY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_DIRECT_INVOCATION} instead of. */\n    public static final String GOAL_REQUIRES_DIRECT_INVOCATION = JavaMojoAnnotation.REQUIRES_DIRECT_INVOCATION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#COMPONENT} instead of. */\n    public static final String COMPONENT = JavaMojoAnnotation.COMPONENT;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#COMPONENT_ROLE} instead of. */\n    public static final String COMPONENT_ROLE = JavaMojoAnnotation.COMPONENT_ROLE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#COMPONENT_ROLEHINT} instead of. */\n    public static final String COMPONENT_ROLEHINT = JavaMojoAnnotation.COMPONENT_ROLEHINT;\n\n    /**\n     * @param parameter not null\n     * @param i positive number\n     * @throws InvalidParameterException if any\n     */\n    protected void validateParameter( Parameter parameter, int i )\n        throws InvalidParameterException\n    {\n        // TODO: remove when backward compatibility is no longer an issue.\n        String name = parameter.getName();\n\n        if ( name == null )\n        {\n            throw new InvalidParameterException( \"name\", i );\n        }\n\n        // TODO: remove when backward compatibility is no longer an issue.\n        String type = parameter.getType();\n\n        if ( type == null )\n        {\n            throw new InvalidParameterException( \"type\", i );\n        }\n\n        // TODO: remove when backward compatibility is no longer an issue.\n        String description = parameter.getDescription();\n\n        if ( description == null )\n        {\n            throw new InvalidParameterException( \"description\", i );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    // Mojo descriptor creation from @tags\n    // ----------------------------------------------------------------------\n\n    /**\n     * @param javaClass not null\n     * @return a mojo descriptor\n     * @throws InvalidPluginDescriptorException if any\n     */\n    protected MojoDescriptor createMojoDescriptor( JavaClass javaClass )\n        throws InvalidPluginDescriptorException\n    {\n        ExtendedMojoDescriptor mojoDescriptor = new ExtendedMojoDescriptor();\n        mojoDescriptor.setLanguage( \"java\" );\n        mojoDescriptor.setImplementation( javaClass.getFullyQualifiedName() );\n        mojoDescriptor.setDescription( javaClass.getComment() );\n\n        // ----------------------------------------------------------------------\n        // Mojo annotations in alphabetical order\n        // ----------------------------------------------------------------------\n\n        // Aggregator flag\n        DocletTag aggregator = findInClassHierarchy( javaClass, JavaMojoAnnotation.AGGREGATOR );\n        if ( aggregator != null )\n        {\n            mojoDescriptor.setAggregator( true );\n        }\n\n        // Configurator hint\n        DocletTag configurator = findInClassHierarchy( javaClass, JavaMojoAnnotation.CONFIGURATOR );\n        if ( configurator != null )\n        {\n            mojoDescriptor.setComponentConfigurator( configurator.getValue() );\n        }\n\n        // Additional phase to execute first\n        DocletTag execute = findInClassHierarchy( javaClass, JavaMojoAnnotation.EXECUTE );\n        if ( execute != null )\n        {\n            String executePhase = execute.getNamedParameter( JavaMojoAnnotation.EXECUTE_PHASE );\n            String executeGoal = execute.getNamedParameter( JavaMojoAnnotation.EXECUTE_GOAL );\n\n            if ( executePhase == null && executeGoal == null )\n            {\n                throw new InvalidPluginDescriptorException( \"@execute tag requires a 'phase' or 'goal' parameter\" );\n            }\n            else if ( executePhase != null && executeGoal != null )\n            {\n                throw new InvalidPluginDescriptorException(\n                    \"@execute tag can have only one of a 'phase' or 'goal' parameter\" );\n            }\n            mojoDescriptor.setExecutePhase( executePhase );\n            mojoDescriptor.setExecuteGoal( executeGoal );\n\n            String lifecycle = execute.getNamedParameter( JavaMojoAnnotation.EXECUTE_LIFECYCLE );\n            if ( lifecycle != null )\n            {\n                mojoDescriptor.setExecuteLifecycle( lifecycle );\n                if ( mojoDescriptor.getExecuteGoal() != null )\n                {\n                    throw new InvalidPluginDescriptorException(\n                        \"@execute lifecycle requires a phase instead of a goal\" );\n                }\n            }\n        }\n\n        // Goal name\n        DocletTag goal = findInClassHierarchy( javaClass, JavaMojoAnnotation.GOAL );\n        if ( goal != null )\n        {\n            mojoDescriptor.setGoal( goal.getValue() );\n        }\n\n        // inheritByDefault flag\n        boolean value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.INHERIT_BY_DEFAULT,\n                                mojoDescriptor.isInheritedByDefault() );\n        mojoDescriptor.setInheritedByDefault( value );\n\n        // instantiationStrategy\n        DocletTag tag = findInClassHierarchy( javaClass, JavaMojoAnnotation.INSTANTIATION_STRATEGY );\n        if ( tag != null )\n        {\n            mojoDescriptor.setInstantiationStrategy( tag.getValue() );\n        }\n        tag = findInClassHierarchy( javaClass, JavaMojoAnnotation.MULTI_EXECUTION_STRATEGY );\n        if ( tag != null )\n        {\n            mojoDescriptor.setExecutionStrategy( MojoDescriptor.MULTI_PASS_EXEC_STRATEGY );\n        }\n        else\n        {\n            mojoDescriptor.setExecutionStrategy( MojoDescriptor.SINGLE_PASS_EXEC_STRATEGY );\n        }\n\n        // Phase name\n        DocletTag phase = findInClassHierarchy( javaClass, JavaMojoAnnotation.PHASE );\n        if ( phase != null )\n        {\n            mojoDescriptor.setPhase( phase.getValue() );\n        }\n\n        // Dependency resolution flag\n        DocletTag requiresDependencyResolution =\n            findInClassHierarchy( javaClass, JavaMojoAnnotation.REQUIRES_DEPENDENCY_RESOLUTION );\n        if ( requiresDependencyResolution != null )\n        {\n            String v = requiresDependencyResolution.getValue();\n\n            if ( StringUtils.isEmpty( v ) )\n            {\n                v = \"runtime\";\n            }\n\n            mojoDescriptor.setDependencyResolutionRequired( v );\n        }\n\n        // Dependency collection flag\n        DocletTag requiresDependencyCollection =\n            findInClassHierarchy( javaClass, JavaMojoAnnotation.REQUIRES_DEPENDENCY_COLLECTION );\n        if ( requiresDependencyCollection != null )\n        {\n            String v = requiresDependencyCollection.getValue();\n\n            if ( StringUtils.isEmpty( v ) )\n            {\n                v = \"runtime\";\n            }\n\n            mojoDescriptor.setDependencyCollectionRequired( v );\n        }\n\n        // requiresDirectInvocation flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_DIRECT_INVOCATION,\n                                mojoDescriptor.isDirectInvocationOnly() );\n        mojoDescriptor.setDirectInvocationOnly( value );\n\n        // Online flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_ONLINE, mojoDescriptor.isOnlineRequired() );\n        mojoDescriptor.setOnlineRequired( value );\n\n        // Project flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_PROJECT, mojoDescriptor.isProjectRequired() );\n        mojoDescriptor.setProjectRequired( value );\n\n        // requiresReports flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_REPORTS, mojoDescriptor.isRequiresReports() );\n        mojoDescriptor.setRequiresReports( value );\n\n        // ----------------------------------------------------------------------\n        // Javadoc annotations in alphabetical order\n        // ----------------------------------------------------------------------\n\n        // Deprecation hint\n        DocletTag deprecated = javaClass.getTagByName( JavaMojoAnnotation.DEPRECATED );\n        if ( deprecated != null )\n        {\n            mojoDescriptor.setDeprecated( deprecated.getValue() );\n        }\n\n        // What version it was introduced in\n        DocletTag since = findInClassHierarchy( javaClass, JavaMojoAnnotation.SINCE );\n        if ( since != null )\n        {\n            mojoDescriptor.setSince( since.getValue() );\n        }\n\n        // Thread-safe mojo \n\n        value = getBooleanTagValue( javaClass, JavaMojoAnnotation.THREAD_SAFE, true, mojoDescriptor.isThreadSafe() );\n        mojoDescriptor.setThreadSafe( value );\n\n        extractParameters( mojoDescriptor, javaClass );\n\n        return mojoDescriptor;\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName not null\n     * @param defaultValue the wanted default value\n     * @return the boolean value of the given tagName\n     * @see #findInClassHierarchy(JavaClass, String)\n     */\n    private static boolean getBooleanTagValue( JavaClass javaClass, String tagName, boolean defaultValue )\n    {\n        DocletTag tag = findInClassHierarchy( javaClass, tagName );\n\n        if ( tag != null )\n        {\n            String value = tag.getValue();\n\n            if ( StringUtils.isNotEmpty( value ) )\n            {\n                defaultValue = Boolean.valueOf( value ).booleanValue();\n            }\n        }\n        return defaultValue;\n    }\n\n    /**\n     * @param javaClass     not null\n     * @param tagName       not null\n     * @param defaultForTag The wanted default value when only the tagname is present\n     * @param defaultValue  the wanted default value when the tag is not specified\n     * @return the boolean value of the given tagName\n     * @see #findInClassHierarchy(JavaClass, String)\n     */\n    private static boolean getBooleanTagValue( JavaClass javaClass, String tagName, boolean defaultForTag,\n                                               boolean defaultValue )\n    {\n        DocletTag tag = findInClassHierarchy( javaClass, tagName );\n\n        if ( tag != null )\n        {\n            String value = tag.getValue();\n\n            if ( StringUtils.isNotEmpty( value ) )\n            {\n                return Boolean.valueOf( value ).booleanValue();\n            }\n            else\n            {\n                return defaultForTag;\n            }\n        }\n        return defaultValue;\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName not null\n     * @return docletTag instance\n     */\n    private static DocletTag findInClassHierarchy( JavaClass javaClass, String tagName )\n    {\n        DocletTag tag = javaClass.getTagByName( tagName );\n\n        if ( tag == null )\n        {\n            JavaClass superClass = javaClass.getSuperJavaClass();\n\n            if ( superClass != null )\n            {\n                tag = findInClassHierarchy( superClass, tagName );\n            }\n        }\n\n        return tag;\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @param javaClass not null\n     * @throws InvalidPluginDescriptorException if any\n     */\n    private void extractParameters( MojoDescriptor mojoDescriptor, JavaClass javaClass )\n        throws InvalidPluginDescriptorException\n    {\n        // ---------------------------------------------------------------------------------\n        // We're resolving class-level, ancestor-class-field, local-class-field order here.\n        // ---------------------------------------------------------------------------------\n\n        Map<String, JavaField> rawParams = extractFieldParameterTags( javaClass );\n\n        for ( Map.Entry<String, JavaField> entry : rawParams.entrySet() )\n        {\n            JavaField field = entry.getValue();\n\n            Type type = field.getType();\n\n            Parameter pd = new Parameter();\n\n            if ( !type.isArray() )\n            {\n                pd.setType( type.getValue() );\n            }\n            else\n            {\n                StringBuffer value = new StringBuffer( type.getValue() );\n\n                int remaining = type.getDimensions();\n\n                while ( remaining-- > 0 )\n                {\n                    value.append( \"[]\" );\n                }\n\n                pd.setType( value.toString() );\n            }\n\n            pd.setDescription( field.getComment() );\n\n            DocletTag componentTag = field.getTagByName( JavaMojoAnnotation.COMPONENT );\n            if ( componentTag != null )\n            {\n                String role = componentTag.getNamedParameter( JavaMojoAnnotation.COMPONENT_ROLE );\n\n                if ( role == null )\n                {\n                    role = field.getType().toString();\n                }\n\n                String roleHint = componentTag.getNamedParameter( JavaMojoAnnotation.COMPONENT_ROLEHINT );\n\n                if ( roleHint == null )\n                {\n                    // support alternate syntax for better compatibility with the Plexus CDC.\n                    roleHint = componentTag.getNamedParameter( \"role-hint\" );\n                }\n\n                pd.setRequirement( new Requirement( role, roleHint ) );\n\n                pd.setName( entry.getKey() );\n\n                pd.setEditable( false );\n                /* TODO: or better like this? Need @component fields be editable for the user?\n                pd.setEditable( field.getTagByName( READONLY ) == null );\n                */\n            }\n            else\n            {\n                DocletTag parameter = field.getTagByName( JavaMojoAnnotation.PARAMETER );\n\n                // ----------------------------------------------------------------------\n                // We will look for a property name here first and use that if present\n                // i.e:\n                //\n                // @parameter property=\"project\"\n                //\n                // Which will become the name used for the configuration element which\n                // will in turn will allow plexus to use the corresponding setter.\n                // ----------------------------------------------------------------------\n\n                String property = parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_PROPERTY );\n\n                if ( !StringUtils.isEmpty( property ) )\n                {\n                    pd.setName( property );\n                }\n                else\n                {\n                    pd.setName( entry.getKey() );\n                }\n\n                pd.setRequired( field.getTagByName( JavaMojoAnnotation.REQUIRED ) != null );\n\n                pd.setEditable( field.getTagByName( JavaMojoAnnotation.READONLY ) == null );\n\n                DocletTag deprecationTag = field.getTagByName( JavaMojoAnnotation.DEPRECATED );\n\n                if ( deprecationTag != null )\n                {\n                    pd.setDeprecated( deprecationTag.getValue() );\n                }\n\n                DocletTag sinceTag = field.getTagByName( JavaMojoAnnotation.SINCE );\n                if ( sinceTag != null )\n                {\n                    pd.setSince( sinceTag.getValue() );\n                }\n\n                String alias = parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_ALIAS );\n\n                if ( !StringUtils.isEmpty( alias ) )\n                {\n                    pd.setAlias( alias );\n                }\n\n                String expression = parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_EXPRESSION );\n                pd.setExpression( expression );\n\n                if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${component.\" ) )\n                {\n                    getLogger().warn( javaClass.getFullyQualifiedName() + \"#\" + field.getName() + \":\" );\n                    getLogger().warn( \"  The syntax\" );\n                    getLogger().warn( \"    @parameter expression=\\\"${component.<role>#<roleHint>}\\\"\" );\n                    getLogger().warn( \"  is deprecated, please use\" );\n                    getLogger().warn( \"    @component role=\\\"<role>\\\" roleHint=\\\"<roleHint>\\\"\" );\n                    getLogger().warn( \"  instead.\" );\n                }\n\n                if ( \"${reports}\".equals( pd.getExpression() ) )\n                {\n                    mojoDescriptor.setRequiresReports( true );\n                }\n\n                pd.setDefaultValue( parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_DEFAULT_VALUE ) );\n\n                pd.setImplementation( parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_IMPLEMENTATION ) );\n            }\n\n            mojoDescriptor.addParameter( pd );\n        }\n    }\n\n    /**\n     * extract fields that are either parameters or components.\n     * \n     * @param javaClass not null\n     * @return map with Mojo parameters names as keys\n     */\n    private Map<String, JavaField> extractFieldParameterTags( JavaClass javaClass )\n    {\n        Map<String, JavaField> rawParams;\n\n        // we have to add the parent fields first, so that they will be overwritten by the local fields if\n        // that actually happens...\n        JavaClass superClass = javaClass.getSuperJavaClass();\n\n        if ( superClass != null )\n        {\n            rawParams = extractFieldParameterTags( superClass );\n        }\n        else\n        {\n            rawParams = new TreeMap<String, JavaField>();\n        }\n\n        JavaField[] classFields = javaClass.getFields();\n\n        if ( classFields != null )\n        {\n            for ( JavaField field : classFields )\n            {\n                if ( field.getTagByName( JavaMojoAnnotation.PARAMETER ) != null\n                    || field.getTagByName( JavaMojoAnnotation.COMPONENT ) != null )\n                {\n                    rawParams.put( field.getName(), field );\n                }\n            }\n        }\n        return rawParams;\n    }\n\n    /** {@inheritDoc} */\n    public List<MojoDescriptor> execute( MavenProject project, PluginDescriptor pluginDescriptor )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        return execute( new DefaultPluginToolsRequest( project, pluginDescriptor ) );\n    }\n    \n    /** {@inheritDoc} */\n    public List<MojoDescriptor> execute( PluginToolsRequest request )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        JavaClass[] javaClasses = discoverClasses( request );\n\n        List<MojoDescriptor> descriptors = new ArrayList<MojoDescriptor>();\n\n        for ( JavaClass javaClass : javaClasses )\n        {\n            DocletTag tag = javaClass.getTagByName( GOAL );\n\n            if ( tag != null )\n            {\n                MojoDescriptor mojoDescriptor = createMojoDescriptor( javaClass );\n                mojoDescriptor.setPluginDescriptor( request.getPluginDescriptor() );\n\n                // Validate the descriptor as best we can before allowing it to be processed.\n                validate( mojoDescriptor );\n\n                descriptors.add( mojoDescriptor );\n            }\n        }\n\n        return descriptors;\n    }\n\n    /**\n     * @param request The plugin request.\n     * @return an array of java class\n     */\n    @SuppressWarnings( \"unchecked\" )\n    protected JavaClass[] discoverClasses( final PluginToolsRequest request )\n    {\n        JavaDocBuilder builder = new JavaDocBuilder();\n        builder.setEncoding( request.getEncoding() );\n        \n        MavenProject project = request.getProject();\n\n        for ( String source : (List<String>) project.getCompileSourceRoots() )\n        {\n            builder.addSourceTree( new File( source ) );\n        }\n\n        // TODO be more dynamic\n        File generatedPlugin = new File( project.getBasedir(), \"target/generated-sources/plugin\" );\n        if ( !project.getCompileSourceRoots().contains( generatedPlugin.getAbsolutePath() ) )\n        {\n            builder.addSourceTree( generatedPlugin );\n        }\n\n        return builder.getClasses();\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @throws InvalidParameterException if any\n     */\n    protected void validate( MojoDescriptor mojoDescriptor )\n        throws InvalidParameterException\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<Parameter> parameters = mojoDescriptor.getParameters();\n\n        if ( parameters != null )\n        {\n            for ( int j = 0; j < parameters.size(); j++ )\n            {\n                validateParameter( parameters.get( j ), j );\n            }\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.extractor.java;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport com.thoughtworks.qdox.JavaDocBuilder;\nimport com.thoughtworks.qdox.model.DocletTag;\nimport com.thoughtworks.qdox.model.JavaClass;\nimport com.thoughtworks.qdox.model.JavaField;\nimport com.thoughtworks.qdox.model.Type;\n\nimport org.apache.maven.plugin.descriptor.InvalidParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\n\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\n/**\n * Extracts Mojo descriptors from <a href=\"http://java.sun.com/\">Java<\/a> sources.\n * <br/>\n * For more information about the usage tag, have a look to:\n * <a href=\"http://maven.apache.org/developers/mojo-api-specification.html\">\n * http://maven.apache.org/developers/mojo-api-specification.html<\/a>\n *\n * @todo need to add validation directives so that systems embedding maven2 can\n * get validation directives to help users in IDEs.\n * @version $Id$\n * @see org.apache.maven.plugin.descriptor.MojoDescriptor\n */\npublic class JavaMojoDescriptorExtractor\n    extends AbstractLogEnabled\n    implements MojoDescriptorExtractor, JavaMojoAnnotation\n{\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#INSTANTIATION_STRATEGY} instead of. */\n    public static final String MAVEN_PLUGIN_INSTANTIATION = JavaMojoAnnotation.INSTANTIATION_STRATEGY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#CONFIGURATOR} instead of. */\n    public static final String CONFIGURATOR = JavaMojoAnnotation.CONFIGURATOR;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER} instead of. */\n    public static final String PARAMETER = JavaMojoAnnotation.PARAMETER;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_EXPRESSION} instead of. */\n    public static final String PARAMETER_EXPRESSION = JavaMojoAnnotation.PARAMETER_EXPRESSION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_DEFAULT_VALUE} instead of. */\n    public static final String PARAMETER_DEFAULT_VALUE = JavaMojoAnnotation.PARAMETER_DEFAULT_VALUE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_ALIAS} instead of. */\n    public static final String PARAMETER_ALIAS = JavaMojoAnnotation.PARAMETER_ALIAS;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#SINCE} instead of. */\n    public static final String SINCE = JavaMojoAnnotation.SINCE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_IMPLEMENTATION} instead of. */\n    public static final String PARAMETER_IMPLEMENTATION = JavaMojoAnnotation.PARAMETER_IMPLEMENTATION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_PROPERTY} instead of. */\n    public static final String PARAMETER_PROPERTY = JavaMojoAnnotation.PARAMETER_PROPERTY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRED} instead of. */\n    public static final String REQUIRED = JavaMojoAnnotation.REQUIRED;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#DEPRECATED} instead of. */\n    public static final String DEPRECATED = JavaMojoAnnotation.DEPRECATED;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#READONLY} instead of. */\n    public static final String READONLY = JavaMojoAnnotation.READONLY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#GOAL} instead of. */\n    public static final String GOAL = JavaMojoAnnotation.GOAL;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PHASE} instead of. */\n    public static final String PHASE = JavaMojoAnnotation.PHASE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE} instead of. */\n    public static final String EXECUTE = JavaMojoAnnotation.EXECUTE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE_LIFECYCLE} instead of. */\n    public static final String EXECUTE_LIFECYCLE = JavaMojoAnnotation.EXECUTE_LIFECYCLE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE_PHASE} instead of. */\n    public static final String EXECUTE_PHASE = JavaMojoAnnotation.EXECUTE_PHASE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE_GOAL} instead of. */\n    public static final String EXECUTE_GOAL = JavaMojoAnnotation.EXECUTE_GOAL;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#DESCRIPTION} instead of. */\n    public static final String GOAL_DESCRIPTION = JavaMojoAnnotation.DESCRIPTION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_DEPENDENCY_RESOLUTION} instead of. */\n    public static final String GOAL_REQUIRES_DEPENDENCY_RESOLUTION = JavaMojoAnnotation.REQUIRES_DEPENDENCY_RESOLUTION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_PROJECT} instead of. */\n    public static final String GOAL_REQUIRES_PROJECT = JavaMojoAnnotation.REQUIRES_PROJECT;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_REPORTS} instead of. */\n    public static final String GOAL_REQUIRES_REPORTS = JavaMojoAnnotation.REQUIRES_REPORTS;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#AGGREGATOR} instead of. */\n    public static final String GOAL_IS_AGGREGATOR = JavaMojoAnnotation.AGGREGATOR;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_ONLINE} instead of. */\n    public static final String GOAL_REQUIRES_ONLINE = JavaMojoAnnotation.REQUIRES_ONLINE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#INHERIT_BY_DEFAULT} instead of. */\n    public static final String GOAL_INHERIT_BY_DEFAULT = JavaMojoAnnotation.INHERIT_BY_DEFAULT;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#MULTI_EXECUTION_STRATEGY} instead of. */\n    public static final String GOAL_MULTI_EXECUTION_STRATEGY = JavaMojoAnnotation.MULTI_EXECUTION_STRATEGY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_DIRECT_INVOCATION} instead of. */\n    public static final String GOAL_REQUIRES_DIRECT_INVOCATION = JavaMojoAnnotation.REQUIRES_DIRECT_INVOCATION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#COMPONENT} instead of. */\n    public static final String COMPONENT = JavaMojoAnnotation.COMPONENT;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#COMPONENT_ROLE} instead of. */\n    public static final String COMPONENT_ROLE = JavaMojoAnnotation.COMPONENT_ROLE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#COMPONENT_ROLEHINT} instead of. */\n    public static final String COMPONENT_ROLEHINT = JavaMojoAnnotation.COMPONENT_ROLEHINT;\n\n    /**\n     * @param parameter not null\n     * @param i positive number\n     * @throws InvalidParameterException if any\n     */\n    protected void validateParameter( Parameter parameter, int i )\n        throws InvalidParameterException\n    {\n        // TODO: remove when backward compatibility is no longer an issue.\n        String name = parameter.getName();\n\n        if ( name == null )\n        {\n            throw new InvalidParameterException( \"name\", i );\n        }\n\n        // TODO: remove when backward compatibility is no longer an issue.\n        String type = parameter.getType();\n\n        if ( type == null )\n        {\n            throw new InvalidParameterException( \"type\", i );\n        }\n\n        // TODO: remove when backward compatibility is no longer an issue.\n        String description = parameter.getDescription();\n\n        if ( description == null )\n        {\n            throw new InvalidParameterException( \"description\", i );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    // Mojo descriptor creation from @tags\n    // ----------------------------------------------------------------------\n\n    /**\n     * @param javaClass not null\n     * @return a mojo descriptor\n     * @throws InvalidPluginDescriptorException if any\n     */\n    protected MojoDescriptor createMojoDescriptor( JavaClass javaClass )\n        throws InvalidPluginDescriptorException\n    {\n        ExtendedMojoDescriptor mojoDescriptor = new ExtendedMojoDescriptor();\n        mojoDescriptor.setLanguage( \"java\" );\n        mojoDescriptor.setImplementation( javaClass.getFullyQualifiedName() );\n        mojoDescriptor.setDescription( javaClass.getComment() );\n\n        // ----------------------------------------------------------------------\n        // Mojo annotations in alphabetical order\n        // ----------------------------------------------------------------------\n\n        // Aggregator flag\n        DocletTag aggregator = findInClassHierarchy( javaClass, JavaMojoAnnotation.AGGREGATOR );\n        if ( aggregator != null )\n        {\n            mojoDescriptor.setAggregator( true );\n        }\n\n        // Configurator hint\n        DocletTag configurator = findInClassHierarchy( javaClass, JavaMojoAnnotation.CONFIGURATOR );\n        if ( configurator != null )\n        {\n            mojoDescriptor.setComponentConfigurator( configurator.getValue() );\n        }\n\n        // Additional phase to execute first\n        DocletTag execute = findInClassHierarchy( javaClass, JavaMojoAnnotation.EXECUTE );\n        if ( execute != null )\n        {\n            String executePhase = execute.getNamedParameter( JavaMojoAnnotation.EXECUTE_PHASE );\n            String executeGoal = execute.getNamedParameter( JavaMojoAnnotation.EXECUTE_GOAL );\n\n            if ( executePhase == null && executeGoal == null )\n            {\n                throw new InvalidPluginDescriptorException( \"@execute tag requires a 'phase' or 'goal' parameter\" );\n            }\n            else if ( executePhase != null && executeGoal != null )\n            {\n                throw new InvalidPluginDescriptorException(\n                    \"@execute tag can have only one of a 'phase' or 'goal' parameter\" );\n            }\n            mojoDescriptor.setExecutePhase( executePhase );\n            mojoDescriptor.setExecuteGoal( executeGoal );\n\n            String lifecycle = execute.getNamedParameter( JavaMojoAnnotation.EXECUTE_LIFECYCLE );\n            if ( lifecycle != null )\n            {\n                mojoDescriptor.setExecuteLifecycle( lifecycle );\n                if ( mojoDescriptor.getExecuteGoal() != null )\n                {\n                    throw new InvalidPluginDescriptorException(\n                        \"@execute lifecycle requires a phase instead of a goal\" );\n                }\n            }\n        }\n\n        // Goal name\n        DocletTag goal = findInClassHierarchy( javaClass, JavaMojoAnnotation.GOAL );\n        if ( goal != null )\n        {\n            mojoDescriptor.setGoal( goal.getValue() );\n        }\n\n        // inheritByDefault flag\n        boolean value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.INHERIT_BY_DEFAULT,\n                                mojoDescriptor.isInheritedByDefault() );\n        mojoDescriptor.setInheritedByDefault( value );\n\n        // instantiationStrategy\n        DocletTag tag = findInClassHierarchy( javaClass, JavaMojoAnnotation.INSTANTIATION_STRATEGY );\n        if ( tag != null )\n        {\n            mojoDescriptor.setInstantiationStrategy( tag.getValue() );\n        }\n        tag = findInClassHierarchy( javaClass, JavaMojoAnnotation.MULTI_EXECUTION_STRATEGY );\n        if ( tag != null )\n        {\n            mojoDescriptor.setExecutionStrategy( MojoDescriptor.MULTI_PASS_EXEC_STRATEGY );\n        }\n        else\n        {\n            mojoDescriptor.setExecutionStrategy( MojoDescriptor.SINGLE_PASS_EXEC_STRATEGY );\n        }\n\n        // Phase name\n        DocletTag phase = findInClassHierarchy( javaClass, JavaMojoAnnotation.PHASE );\n        if ( phase != null )\n        {\n            mojoDescriptor.setPhase( phase.getValue() );\n        }\n\n        // Dependency resolution flag\n        DocletTag requiresDependencyResolution =\n            findInClassHierarchy( javaClass, JavaMojoAnnotation.REQUIRES_DEPENDENCY_RESOLUTION );\n        if ( requiresDependencyResolution != null )\n        {\n            String v = requiresDependencyResolution.getValue();\n\n            if ( StringUtils.isEmpty( v ) )\n            {\n                v = \"runtime\";\n            }\n\n            mojoDescriptor.setDependencyResolutionRequired( v );\n        }\n\n        // Dependency collection flag\n        DocletTag requiresDependencyCollection =\n            findInClassHierarchy( javaClass, JavaMojoAnnotation.REQUIRES_DEPENDENCY_COLLECTION );\n        if ( requiresDependencyCollection != null )\n        {\n            String v = requiresDependencyCollection.getValue();\n\n            if ( StringUtils.isEmpty( v ) )\n            {\n                v = \"runtime\";\n            }\n\n            mojoDescriptor.setDependencyCollectionRequired( v );\n        }\n\n        // requiresDirectInvocation flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_DIRECT_INVOCATION,\n                                mojoDescriptor.isDirectInvocationOnly() );\n        mojoDescriptor.setDirectInvocationOnly( value );\n\n        // Online flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_ONLINE, mojoDescriptor.isOnlineRequired() );\n        mojoDescriptor.setOnlineRequired( value );\n\n        // Project flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_PROJECT, mojoDescriptor.isProjectRequired() );\n        mojoDescriptor.setProjectRequired( value );\n\n        // requiresReports flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_REPORTS, mojoDescriptor.isRequiresReports() );\n        mojoDescriptor.setRequiresReports( value );\n\n        // ----------------------------------------------------------------------\n        // Javadoc annotations in alphabetical order\n        // ----------------------------------------------------------------------\n\n        // Deprecation hint\n        DocletTag deprecated = javaClass.getTagByName( JavaMojoAnnotation.DEPRECATED );\n        if ( deprecated != null )\n        {\n            mojoDescriptor.setDeprecated( deprecated.getValue() );\n        }\n\n        // What version it was introduced in\n        DocletTag since = findInClassHierarchy( javaClass, JavaMojoAnnotation.SINCE );\n        if ( since != null )\n        {\n            mojoDescriptor.setSince( since.getValue() );\n        }\n\n        // Thread-safe mojo \n\n        value = getBooleanTagValue( javaClass, JavaMojoAnnotation.THREAD_SAFE, true, mojoDescriptor.isThreadSafe() );\n        mojoDescriptor.setThreadSafe( value );\n\n        extractParameters( mojoDescriptor, javaClass );\n\n        return mojoDescriptor;\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName not null\n     * @param defaultValue the wanted default value\n     * @return the boolean value of the given tagName\n     * @see #findInClassHierarchy(JavaClass, String)\n     */\n    private static boolean getBooleanTagValue( JavaClass javaClass, String tagName, boolean defaultValue )\n    {\n        DocletTag tag = findInClassHierarchy( javaClass, tagName );\n\n        if ( tag != null )\n        {\n            String value = tag.getValue();\n\n            if ( StringUtils.isNotEmpty( value ) )\n            {\n                defaultValue = Boolean.valueOf( value ).booleanValue();\n            }\n        }\n        return defaultValue;\n    }\n\n    /**\n     * @param javaClass     not null\n     * @param tagName       not null\n     * @param defaultForTag The wanted default value when only the tagname is present\n     * @param defaultValue  the wanted default value when the tag is not specified\n     * @return the boolean value of the given tagName\n     * @see #findInClassHierarchy(JavaClass, String)\n     */\n    private static boolean getBooleanTagValue( JavaClass javaClass, String tagName, boolean defaultForTag,\n                                               boolean defaultValue )\n    {\n        DocletTag tag = findInClassHierarchy( javaClass, tagName );\n\n        if ( tag != null )\n        {\n            String value = tag.getValue();\n\n            if ( StringUtils.isNotEmpty( value ) )\n            {\n                return Boolean.valueOf( value ).booleanValue();\n            }\n            else\n            {\n                return defaultForTag;\n            }\n        }\n        return defaultValue;\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName not null\n     * @return docletTag instance\n     */\n    private static DocletTag findInClassHierarchy( JavaClass javaClass, String tagName )\n    {\n        DocletTag tag = javaClass.getTagByName( tagName );\n\n        if ( tag == null )\n        {\n            JavaClass superClass = javaClass.getSuperJavaClass();\n\n            if ( superClass != null )\n            {\n                tag = findInClassHierarchy( superClass, tagName );\n            }\n        }\n\n        return tag;\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @param javaClass not null\n     * @throws InvalidPluginDescriptorException if any\n     */\n    private void extractParameters( MojoDescriptor mojoDescriptor, JavaClass javaClass )\n        throws InvalidPluginDescriptorException\n    {\n        // ---------------------------------------------------------------------------------\n        // We're resolving class-level, ancestor-class-field, local-class-field order here.\n        // ---------------------------------------------------------------------------------\n\n        Map<String, JavaField> rawParams = extractFieldParameterTags( javaClass );\n\n        for ( Map.Entry<String, JavaField> entry : rawParams.entrySet() )\n        {\n            JavaField field = entry.getValue();\n\n            Type type = field.getType();\n\n            Parameter pd = new Parameter();\n\n            if ( !type.isArray() )\n            {\n                pd.setType( type.getValue() );\n            }\n            else\n            {\n                StringBuffer value = new StringBuffer( type.getValue() );\n\n                int remaining = type.getDimensions();\n\n                while ( remaining-- > 0 )\n                {\n                    value.append( \"[]\" );\n                }\n\n                pd.setType( value.toString() );\n            }\n\n            pd.setDescription( field.getComment() );\n\n            DocletTag componentTag = field.getTagByName( JavaMojoAnnotation.COMPONENT );\n            if ( componentTag != null )\n            {\n                String role = componentTag.getNamedParameter( JavaMojoAnnotation.COMPONENT_ROLE );\n\n                if ( role == null )\n                {\n                    role = field.getType().toString();\n                }\n\n                String roleHint = componentTag.getNamedParameter( JavaMojoAnnotation.COMPONENT_ROLEHINT );\n\n                if ( roleHint == null )\n                {\n                    // support alternate syntax for better compatibility with the Plexus CDC.\n                    roleHint = componentTag.getNamedParameter( \"role-hint\" );\n                }\n\n                pd.setRequirement( new Requirement( role, roleHint ) );\n\n                pd.setName( entry.getKey() );\n\n                pd.setEditable( false );\n                /* TODO: or better like this? Need @component fields be editable for the user?\n                pd.setEditable( field.getTagByName( READONLY ) == null );\n                */\n            }\n            else\n            {\n                DocletTag parameter = field.getTagByName( JavaMojoAnnotation.PARAMETER );\n\n                // ----------------------------------------------------------------------\n                // We will look for a property name here first and use that if present\n                // i.e:\n                //\n                // @parameter property=\"project\"\n                //\n                // Which will become the name used for the configuration element which\n                // will in turn will allow plexus to use the corresponding setter.\n                // ----------------------------------------------------------------------\n\n                String property = parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_PROPERTY );\n\n                if ( !StringUtils.isEmpty( property ) )\n                {\n                    pd.setName( property );\n                }\n                else\n                {\n                    pd.setName( entry.getKey() );\n                }\n\n                pd.setRequired( field.getTagByName( JavaMojoAnnotation.REQUIRED ) != null );\n\n                pd.setEditable( field.getTagByName( JavaMojoAnnotation.READONLY ) == null );\n\n                DocletTag deprecationTag = field.getTagByName( JavaMojoAnnotation.DEPRECATED );\n\n                if ( deprecationTag != null )\n                {\n                    pd.setDeprecated( deprecationTag.getValue() );\n                }\n\n                DocletTag sinceTag = field.getTagByName( JavaMojoAnnotation.SINCE );\n                if ( sinceTag != null )\n                {\n                    pd.setSince( sinceTag.getValue() );\n                }\n\n                String alias = parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_ALIAS );\n\n                if ( !StringUtils.isEmpty( alias ) )\n                {\n                    pd.setAlias( alias );\n                }\n\n                String expression = parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_EXPRESSION );\n                pd.setExpression( expression );\n\n                if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${component.\" ) )\n                {\n                    getLogger().warn( javaClass.getFullyQualifiedName() + \"#\" + field.getName() + \":\" );\n                    getLogger().warn( \"  The syntax\" );\n                    getLogger().warn( \"    @parameter expression=\\\"${component.<role>#<roleHint>}\\\"\" );\n                    getLogger().warn( \"  is deprecated, please use\" );\n                    getLogger().warn( \"    @component role=\\\"<role>\\\" roleHint=\\\"<roleHint>\\\"\" );\n                    getLogger().warn( \"  instead.\" );\n                }\n\n                if ( \"${reports}\".equals( pd.getExpression() ) )\n                {\n                    mojoDescriptor.setRequiresReports( true );\n                }\n\n                pd.setDefaultValue( parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_DEFAULT_VALUE ) );\n\n                pd.setImplementation( parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_IMPLEMENTATION ) );\n            }\n\n            mojoDescriptor.addParameter( pd );\n        }\n    }\n\n    /**\n     * @param javaClass not null\n     * @return map with Mojo parameters names as keys\n     */\n    private Map<String, JavaField> extractFieldParameterTags( JavaClass javaClass )\n    {\n        Map<String, JavaField> rawParams;\n\n        // we have to add the parent fields first, so that they will be overwritten by the local fields if\n        // that actually happens...\n        JavaClass superClass = javaClass.getSuperJavaClass();\n\n        if ( superClass != null )\n        {\n            rawParams = extractFieldParameterTags( superClass );\n        }\n        else\n        {\n            rawParams = new TreeMap<String, JavaField>();\n        }\n\n        JavaField[] classFields = javaClass.getFields();\n\n        if ( classFields != null )\n        {\n            for ( int i = 0; i < classFields.length; i++ )\n            {\n                JavaField field = classFields[i];\n\n                if ( field.getTagByName( JavaMojoAnnotation.PARAMETER ) != null\n                    || field.getTagByName( JavaMojoAnnotation.COMPONENT ) != null )\n                {\n                    rawParams.put( field.getName(), field );\n                }\n            }\n        }\n        return rawParams;\n    }\n\n    /** {@inheritDoc} */\n    public List<MojoDescriptor> execute( MavenProject project, PluginDescriptor pluginDescriptor )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        return execute( new DefaultPluginToolsRequest( project, pluginDescriptor ) );\n    }\n    \n    /** {@inheritDoc} */\n    public List<MojoDescriptor> execute( PluginToolsRequest request )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        JavaClass[] javaClasses = discoverClasses( request );\n\n        List<MojoDescriptor> descriptors = new ArrayList<MojoDescriptor>();\n\n        for ( int i = 0; i < javaClasses.length; i++ )\n        {\n            DocletTag tag = javaClasses[i].getTagByName( GOAL );\n\n            if ( tag != null )\n            {\n                MojoDescriptor mojoDescriptor = createMojoDescriptor( javaClasses[i] );\n                mojoDescriptor.setPluginDescriptor( request.getPluginDescriptor() );\n\n                // Validate the descriptor as best we can before allowing it to be processed.\n                validate( mojoDescriptor );\n\n                descriptors.add( mojoDescriptor );\n            }\n        }\n\n        return descriptors;\n    }\n\n    /**\n     * @param request The plugin request.\n     * @return an array of java class\n     */\n    protected JavaClass[] discoverClasses( final PluginToolsRequest request )\n    {\n        JavaDocBuilder builder = new JavaDocBuilder();\n        builder.setEncoding( request.getEncoding() );\n        \n        MavenProject project = request.getProject();\n\n        for ( @SuppressWarnings( \"unchecked\" )\n        Iterator<String> i = project.getCompileSourceRoots().iterator(); i.hasNext(); )\n        {\n            builder.addSourceTree( new File( i.next() ) );\n        }\n\n        // TODO be more dynamic\n        if ( !project.getCompileSourceRoots()\n            .contains( new File( project.getBasedir(), \"target/generated-sources/plugin\" ).getAbsolutePath() ) )\n        {\n            builder.addSourceTree( new File( project.getBasedir(), \"target/generated-sources/plugin\" ) );\n        }\n\n        return builder.getClasses();\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @throws InvalidParameterException if any\n     */\n    protected void validate( MojoDescriptor mojoDescriptor )\n        throws InvalidParameterException\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<Parameter> parameters = mojoDescriptor.getParameters();\n\n        if ( parameters != null )\n        {\n            for ( int j = 0; j < parameters.size(); j++ )\n            {\n                validateParameter( parameters.get( j ), j );\n            }\n        }\n    }\n}\n","lineNo":680}
{"Refactored Sample":"package org.apache.maven.tools.plugin.extractor.java;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport junit.framework.TestCase;\nimport org.apache.maven.model.Model;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.apache.maven.tools.plugin.generator.Generator;\nimport org.apache.maven.tools.plugin.generator.PluginDescriptorGenerator;\nimport org.codehaus.plexus.component.repository.ComponentDependency;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.custommonkey.xmlunit.Diff;\nimport org.custommonkey.xmlunit.XMLUnit;\nimport org.w3c.dom.Document;\n\nimport java.io.File;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author jdcasey\n */\npublic class JavaMojoDescriptorExtractorTest\n    extends TestCase\n{\n    private File root;\n\n    protected void setUp()\n    {\n        File sourceFile = fileOf( \"dir-flag.txt\" );\n        root = sourceFile.getParentFile();\n    }\n\n    private File fileOf( String classpathResource )\n    {\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        URL resource = cl.getResource( classpathResource );\n\n        File result = null;\n        if ( resource != null )\n        {\n            result = FileUtils.toFile( resource );\n        }\n\n        return result;\n    }\n\n    private PluginToolsRequest createRequest( String directory )\n    {\n        Model model = new Model();\n        model.setArtifactId( \"maven-unitTesting-plugin\" );\n\n        MavenProject project = new MavenProject( model );\n\n        project.setFile( new File( root, \"pom.xml\" ) );\n        project.addCompileSourceRoot( new File( root, directory ).getPath() );\n\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n        pluginDescriptor.setGoalPrefix( \"test\" );\n        pluginDescriptor.setDependencies( new ArrayList<ComponentDependency>() );\n\n        return new DefaultPluginToolsRequest( project, pluginDescriptor ).setEncoding( \"UTF-8\" );\n    }\n\n    /**\n     * generate plugin.xml for a test resources directory content.\n     */\n    protected PluginDescriptor generate( String directory )\n        throws Exception\n    {\n        MojoDescriptorExtractor extractor = new JavaMojoDescriptorExtractor();\n        PluginToolsRequest request = createRequest( directory );\n\n        List<MojoDescriptor> mojoDescriptors = extractor.execute( request );\n\n        for ( MojoDescriptor mojoDescriptor : mojoDescriptors )\n        {\n            request.getPluginDescriptor().addMojo( mojoDescriptor );\n        }\n\n        Generator descriptorGenerator = new PluginDescriptorGenerator();\n\n        descriptorGenerator.execute( new File( root, directory ), request );\n\n        return request.getPluginDescriptor();\n    }\n\n    /**\n     * compare mojos from generated plugin.xml against plugin-expected.xml\n     */\n    protected void checkExpected( String directory )\n        throws Exception\n    {\n        File testDirectory = new File( root, directory );\n\n        XMLUnit.setIgnoreWhitespace( true );\n        XMLUnit.setIgnoreComments( true );\n        \n        Document expected =\n            XMLUnit.buildControlDocument( FileUtils.fileRead( new File( testDirectory, \"plugin-expected.xml\" ), \"UTF-8\" ) );\n        Document actual =\n            XMLUnit.buildTestDocument( FileUtils.fileRead( new File( testDirectory, \"plugin.xml\" ), \"UTF-8\" ) );\n\n        Diff diff = XMLUnit.compareXML( expected, actual );\n\n        if ( !diff.identical() )\n        {\n            fail( \"generated plugin.xml is not identital as plugin-expected.xml for \" + directory + \": \" + diff );\n        }\n    }\n\n    /**\n     * extract plugin descriptor for test resources directory and check against plugin-expected.xml\n     */\n    @SuppressWarnings( \"unchecked\" )\n    protected List<MojoDescriptor> extract( String directory )\n        throws Exception\n    {\n        PluginDescriptor descriptor = generate( directory );\n\n        checkExpected( directory );\n\n        return descriptor.getMojos();\n    }\n\n    public void testShouldFindTwoMojoDescriptorsInTestSourceDirectory()\n        throws Exception\n    {\n        List<MojoDescriptor> results = extract( \"source\" );\n        \n        assertEquals( \"Extracted mojos\", 2, results.size() );\n\n        for ( MojoDescriptor mojoDescriptor : results )\n        {\n            assertEquals( 1, mojoDescriptor.getParameters().size() );\n            Parameter parameter = (Parameter) mojoDescriptor.getParameters().get( 0 );\n            assertEquals( \"project\", parameter.getName() );\n            assertEquals( \"java.lang.String[]\", parameter.getType() );\n        }\n    }\n\n    public void testShouldPropagateImplementationParameter()\n        throws Exception\n    {\n        List<MojoDescriptor> results = extract( \"source2\" );\n\n        assertEquals( 1, results.size() );\n\n        MojoDescriptor mojoDescriptor = results.get( 0 );\n\n        @SuppressWarnings( \"unchecked\" )\n        List<Parameter> parameters = mojoDescriptor.getParameters();\n\n        assertEquals( 1, parameters.size() );\n\n        Parameter parameter = parameters.get( 0 );\n\n        assertEquals( \"Implementation parameter\", \"source2.sub.MyBla\", parameter.getImplementation() );\n    }\n\n    public void testMaven30Parameters()\n        throws Exception\n    {\n        List<MojoDescriptor> results = extract( \"source2\" );\n\n        assertEquals( 1, results.size() );\n\n        ExtendedMojoDescriptor mojoDescriptor = (ExtendedMojoDescriptor) results.get( 0 );\n        assertTrue( mojoDescriptor.isThreadSafe() );\n        assertEquals( \"test\", mojoDescriptor.getDependencyCollectionRequired() );\n    }\n\n    /**\n     * Check that the mojo descriptor extractor will ignore any annotations that are found.\n     * \n     * @throws Exception\n     */\n    public void testAnnotationInPlugin()\n        throws Exception\n    {\n        List<MojoDescriptor> results = extract( \"source3\" );\n\n        assertNull( results );\n    }\n    \n    /**\n     * Check that the mojo descriptor extractor will successfully parse sources with Java 1.5 language features like\n     * generics.\n     */\n    public void testJava15SyntaxParsing()\n        throws Exception\n    {\n        List<MojoDescriptor> results = extract( \"java-1.5\" );\n\n        assertEquals( 1, results.size() );\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.extractor.java;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport junit.framework.TestCase;\nimport org.apache.maven.model.Model;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.apache.maven.tools.plugin.generator.Generator;\nimport org.apache.maven.tools.plugin.generator.PluginDescriptorGenerator;\nimport org.codehaus.plexus.component.repository.ComponentDependency;\nimport org.codehaus.plexus.util.FileUtils;\n\nimport java.io.File;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author jdcasey\n */\npublic class JavaMojoDescriptorExtractorTest\n    extends TestCase\n{\n    private File root;\n\n    protected void setUp()\n    {\n        File sourceFile = fileOf( \"dir-flag.txt\" );\n        root = sourceFile.getParentFile();\n    }\n\n    private File fileOf( String classpathResource )\n    {\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        URL resource = cl.getResource( classpathResource );\n\n        File result = null;\n        if ( resource != null )\n        {\n            result = FileUtils.toFile( resource );\n        }\n\n        return result;\n    }\n\n    private PluginToolsRequest createRequest( String directory )\n    {\n        Model model = new Model();\n        model.setArtifactId( \"maven-unitTesting-plugin\" );\n\n        MavenProject project = new MavenProject( model );\n\n        project.setFile( new File( root, \"pom.xml\" ) );\n        project.addCompileSourceRoot( new File( root, directory ).getPath() );\n\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n        pluginDescriptor.setGoalPrefix( \"test\" );\n        pluginDescriptor.setDependencies( new ArrayList<ComponentDependency>() );\n\n        return new DefaultPluginToolsRequest( project, pluginDescriptor ).setEncoding( \"UTF-8\" );\n    }\n\n    protected PluginDescriptor generate( String directory )\n        throws Exception\n    {\n        MojoDescriptorExtractor extractor = new JavaMojoDescriptorExtractor();\n        PluginToolsRequest request = createRequest( directory );\n\n        List<MojoDescriptor> mojoDescriptors = extractor.execute( request );\n\n        for ( MojoDescriptor mojoDescriptor : mojoDescriptors )\n        {\n            request.getPluginDescriptor().addMojo( mojoDescriptor );\n        }\n\n        Generator descriptorGenerator = new PluginDescriptorGenerator();\n\n        descriptorGenerator.execute( new File( root, directory ), request );\n\n        return request.getPluginDescriptor();\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    protected List<MojoDescriptor> extract( String directory )\n        throws Exception\n    {\n        return generate( directory ).getMojos();\n    }\n\n    public void testShouldFindTwoMojoDescriptorsInTestSourceDirectory()\n        throws Exception\n    {\n        List<MojoDescriptor> results = extract( \"source\" );\n        \n        assertEquals( \"Extracted mojos\", 2, results.size() );\n\n        for ( MojoDescriptor mojoDescriptor : results )\n        {\n            assertEquals( 1, mojoDescriptor.getParameters().size() );\n            Parameter parameter = (Parameter) mojoDescriptor.getParameters().get( 0 );\n            assertEquals( \"project\", parameter.getName() );\n            assertEquals( \"java.lang.String[]\", parameter.getType() );\n        }\n    }\n\n    public void testShouldPropagateImplementationParameter()\n        throws Exception\n    {\n        List<MojoDescriptor> results = extract( \"source2\" );\n\n        assertEquals( 1, results.size() );\n\n        MojoDescriptor mojoDescriptor = results.get( 0 );\n\n        @SuppressWarnings( \"unchecked\" )\n        List<Parameter> parameters = mojoDescriptor.getParameters();\n\n        assertEquals( 1, parameters.size() );\n\n        Parameter parameter = parameters.get( 0 );\n\n        assertEquals( \"Implementation parameter\", \"source2.sub.MyBla\", parameter.getImplementation() );\n    }\n\n    public void testMaven30Parameters()\n        throws Exception\n    {\n        List<MojoDescriptor> results = extract( \"source2\" );\n\n        assertEquals( 1, results.size() );\n\n        ExtendedMojoDescriptor mojoDescriptor = (ExtendedMojoDescriptor) results.get( 0 );\n        assertTrue( mojoDescriptor.isThreadSafe() );\n        assertEquals( \"test\", mojoDescriptor.getDependencyCollectionRequired() );\n    }\n\n    /**\n     * Check that the mojo descriptor extractor will ignore any annotations that are found.\n     * \n     * @throws Exception\n     */\n    public void testAnnotationInPlugin()\n        throws Exception\n    {\n        List<MojoDescriptor> results = extract( \"source3\" );\n\n        assertNull( results );\n    }\n    \n    /**\n     * Check that the mojo descriptor extractor will successfully parse sources with Java 1.5 language features like\n     * generics.\n     */\n    public void testJava15SyntaxParsing()\n        throws Exception\n    {\n        List<MojoDescriptor> results = extract( \"java-1.5\" );\n\n        assertEquals( 1, results.size() );\n    }\n\n}\n","lineNo":144}
{"Refactored Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * Generates an <code>HelpMojo<\/code> class.\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    /** Line separator */\n    private static final String LS = System.getProperty( \"line.separator\" );\n\n    /** Default generated class name */\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    /** Default goal */\n    private static final String HELP_GOAL = \"help\";\n\n    private String helpPackageName;\n    \n    /** Flag to indicate if the generated help mojo should use Java 5 features */\n    private boolean useJava5;\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        execute( destinationDirectory, new DefaultPluginToolsRequest( null, pluginDescriptor ) );\n    }\n    \n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws IOException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n        \n        if ( pluginDescriptor.getMojos() == null || pluginDescriptor.getMojos().size() < 1 )\n        {\n            return;\n        }\n\n        MojoDescriptor helpDescriptor = makeHelpDescriptor( pluginDescriptor );\n\n        // Verify that no help goal already exists\n        for ( @SuppressWarnings( \"unchecked\" )\n        Iterator<MojoDescriptor> it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = it.next();\n\n            if ( descriptor.getGoal().equals( helpDescriptor.getGoal() )\n                && !descriptor.getImplementation().equals( helpDescriptor.getImplementation() ) )\n            {\n                if ( getLogger().isWarnEnabled() )\n                {\n                    getLogger().warn(\n                                      \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                          + \") already exists in this plugin. SKIPPED THE \"\n                                          + helpDescriptor.getImplementation() + \" GENERATION.\\n\" );\n                }\n\n                return;\n            }\n        }\n\n        String sourcePath = helpDescriptor.getImplementation().replace( '.', File.separatorChar ) + \".java\";\n        File helpClass = new File( destinationDirectory, sourcePath );\n        helpClass.getParentFile().mkdirs();\n\n        Writer writer = null;\n        try\n        {\n            writer = new OutputStreamWriter( new FileOutputStream( helpClass ), request.getEncoding() );\n            writeClass( writer, pluginDescriptor, helpDescriptor, useJava5 );\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    public PluginHelpGenerator setHelpPackageName( String helpPackageName )\n    {\n        this.helpPackageName = helpPackageName;\n        return this;\n    }\n\n    public PluginHelpGenerator setUseJava5( boolean useJava5 )\n    {\n        this.useJava5 = useJava5;\n        return this;\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * Creates a minimalistic mojo descriptor for the generated help goal.\n     *\n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *            <code>null<\/code>.\n     * @return The mojo descriptor for the generated help goal, never <code>null<\/code>.\n     */\n    private MojoDescriptor makeHelpDescriptor( PluginDescriptor pluginDescriptor )\n    {\n        MojoDescriptor descriptor = new MojoDescriptor();\n\n        descriptor.setPluginDescriptor( pluginDescriptor );\n\n        descriptor.setLanguage( \"java\" );\n\n        descriptor.setGoal( HELP_GOAL );\n\n        String packageName = helpPackageName;\n        if ( StringUtils.isEmpty( packageName ) )\n        {\n            packageName = discoverPackageName( pluginDescriptor );\n        }\n        if ( StringUtils.isNotEmpty( packageName ) )\n        {\n            descriptor.setImplementation( packageName + '.' + HELP_MOJO_CLASS_NAME );\n        }\n        else\n        {\n            descriptor.setImplementation( HELP_MOJO_CLASS_NAME );\n        }\n\n        descriptor.setDescription( \"Display help information on \" + pluginDescriptor.getArtifactId()\n            + \".<br/> Call <pre>  mvn \" + descriptor.getFullGoalName()\n            + \" -Ddetail=true -Dgoal=&lt;goal-name&gt;<\/pre> to display parameter details.\" );\n\n        try\n        {\n            Parameter param = new Parameter();\n            param.setName( \"detail\" );\n            param.setType( \"boolean\" );\n            param.setDescription( \"If <code>true<\/code>, display all settable properties for each goal.\" );\n            param.setDefaultValue( \"false\" );\n            param.setExpression( \"${detail}\" );\n            descriptor.addParameter( param );\n\n            param = new Parameter();\n            param.setName( \"goal\" );\n            param.setType( \"java.lang.String\" );\n            param.setDescription( \"The name of the goal for which to show help.\"\n                + \" If unspecified, all goals will be displayed.\" );\n            param.setExpression( \"${goal}\" );\n            descriptor.addParameter( param );\n\n            param = new Parameter();\n            param.setName( \"lineLength\" );\n            param.setType( \"int\" );\n            param.setDescription( \"The maximum length of a display line, should be positive.\" );\n            param.setDefaultValue( \"80\" );\n            param.setExpression( \"${lineLength}\" );\n            descriptor.addParameter( param );\n\n            param = new Parameter();\n            param.setName( \"indentSize\" );\n            param.setType( \"int\" );\n            param.setDescription( \"The number of spaces per indentation level, should be positive.\" );\n            param.setDefaultValue( \"2\" );\n            param.setExpression( \"${indentSize}\" );\n            descriptor.addParameter( param );\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( \"Failed to setup parameters for help goal\", e );\n        }\n\n        return descriptor;\n    }\n\n    /**\n     * Find the best package name, based on the number of hits of actual Mojo classes.\n     *\n     * @param pluginDescriptor not null\n     * @return the best name of the package for the generated mojo\n     */\n    private static String discoverPackageName( PluginDescriptor pluginDescriptor )\n    {\n        Map<String, Integer> packageNames = new HashMap<String, Integer>();\n        for ( @SuppressWarnings( \"unchecked\" )\n        Iterator<MojoDescriptor> it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = it.next();\n\n            String name = \"\";\n            int next = 1;\n\n            String impl = descriptor.getImplementation();\n            if ( impl.lastIndexOf( '.' ) != -1 )\n            {\n                name = impl.substring( 0, impl.lastIndexOf( '.' ) );\n                Integer count = packageNames.get( name );\n\n                if ( count != null )\n                {\n                    next = count.intValue() + 1;\n                }\n            }\n\n            packageNames.put( name, next );\n        }\n\n        String packageName = \"\";\n        int max = 0;\n        for ( Map.Entry<String, Integer> entry : packageNames.entrySet() )\n        {\n            int value = entry.getValue().intValue();\n            if ( value > max )\n            {\n                max = value;\n                packageName = entry.getKey();\n            }\n        }\n\n        return packageName;\n    }\n\n    /**\n     * Generates the <code>HelpMojo<\/code> class.\n     *\n     * @param writer not null\n     * @param pluginDescriptor not null\n     * @param helpDescriptor not null\n     * @param useJava5 If the generated code should use Java5 features\n     * @throws IOException if any\n     */\n    private static void writeClass( Writer writer, PluginDescriptor pluginDescriptor, MojoDescriptor helpDescriptor,\n                                    boolean useJava5 )\n        throws IOException\n    {\n        String packageName = \"\";\n        String simpleName = helpDescriptor.getImplementation();\n        int dot = simpleName.lastIndexOf( '.' );\n        if ( dot >= 0 )\n        {\n            packageName = simpleName.substring( 0, dot );\n            simpleName = simpleName.substring( dot + 1 );\n        }\n\n        if ( packageName.length() > 0 )\n        {\n            writer.write( \"package \" + packageName + \";\" + LS );\n            writer.write( LS );\n        }\n\n        writeImports( writer );\n        writer.write( LS );\n\n        writeMojoJavadoc( writer, pluginDescriptor, helpDescriptor );\n\n        if ( useJava5 )\n        {\n            writer.write( \"@SuppressWarnings( \\\"all\\\" )\" + LS );\n        }\n\n        writer.write( \"public class \" + simpleName + LS );\n        writer.write( \"    extends AbstractMojo\" + LS );\n        writer.write( \"{\" + LS );\n\n        writeVariables( writer, helpDescriptor );\n\n        writer.write( LS );\n\n        writeExecute( writer, pluginDescriptor, helpDescriptor );\n\n        writer.write( LS );\n        writeUtilities( writer, useJava5 );\n        writer.write( \"}\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @throws IOException if any\n     */\n    private static void writeImports( Writer writer )\n        throws IOException\n    {\n        writer.write( \"import java.util.ArrayList;\" + LS );\n        writer.write( \"import java.util.Iterator;\" + LS );\n        writer.write( \"import java.util.List;\" + LS );\n        writer.write( LS );\n        writer.write( \"import org.apache.maven.plugin.AbstractMojo;\" + LS );\n        writer.write( \"import org.apache.maven.plugin.MojoExecutionException;\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param pluginDescriptor not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeMojoJavadoc( Writer writer, PluginDescriptor pluginDescriptor,\n                                          MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        StringBuffer author = new StringBuffer();\n        author.append( PluginHelpGenerator.class.getName() );\n\n        String resource = \"META-INF/maven/org.apache.maven.plugin-tools/maven-plugin-tools-api/pom.properties\";\n        InputStream resourceAsStream = PluginHelpGenerator.class.getClassLoader().getResourceAsStream( resource );\n\n        if ( resourceAsStream != null )\n        {\n            try\n            {\n                Properties properties = new Properties();\n                properties.load( resourceAsStream );\n\n                author.append( \" (version \" ).append( properties.getProperty( \"version\", \"unknown\" ) ).append( \")\" );\n            }\n            catch ( IOException e )\n            {\n                // nope\n            }\n            finally\n            {\n                IOUtil.close( resourceAsStream );\n            }\n        }\n\n        writer.write( \"/**\" + LS );\n        writer.write( \" * \" + helpDescriptor.getDescription() + LS );\n        writer.write( \" *\" + LS );\n        writer.write( \" * @version generated on \" + new Date() + LS );\n        writer.write( \" * @author \" + author.toString() + LS );\n        writer.write( \" * @goal \" + helpDescriptor.getGoal() + LS );\n        writer.write( \" * @requiresProject false\" + LS );\n        writer.write( \" * @threadSafe\" + LS );\n        writer.write( \" */\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeVariables( Writer writer, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        for ( @SuppressWarnings( \"unchecked\" )\n        Iterator<Parameter> it = helpDescriptor.getParameters().iterator(); it.hasNext(); )\n        {\n            Parameter param = it.next();\n            writer.write( \"    /**\" + LS );\n            writer.write( \"     * \" + StringUtils.escape( param.getDescription() ) + LS );\n            writer.write( \"     * \" + LS );\n            writer.write( \"     * @parameter\" );\n            if ( StringUtils.isNotEmpty( param.getExpression() ) )\n            {\n                writer.write( \" expression=\\\"\" );\n                writer.write( StringUtils.escape( param.getExpression() ) );\n                writer.write( \"\\\"\" );\n            }\n            if ( StringUtils.isNotEmpty( param.getDefaultValue() ) )\n            {\n                writer.write( \" default-value=\\\"\" );\n                writer.write( StringUtils.escape( param.getDefaultValue() ) );\n                writer.write( \"\\\"\" );\n            }\n            writer.write( LS );\n            writer.write( \"     */\" + LS );\n            writer.write( \"    private \" + param.getType() + \" \" + param.getName() + \";\" + LS );\n            writer.write( LS );\n        }\n    }\n\n    /**\n     * @param writer not null\n     * @param pluginDescriptor not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeExecute( Writer writer, PluginDescriptor pluginDescriptor, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        List<MojoDescriptor> mojoDescriptors = new ArrayList<MojoDescriptor>();\n\n        mojoDescriptors.add( helpDescriptor );\n        for ( @SuppressWarnings( \"unchecked\" )\n        Iterator<MojoDescriptor> it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor mojoDescriptor = it.next();\n\n            if ( !helpDescriptor.getGoal().equals( mojoDescriptor.getGoal() ) )\n            {\n                mojoDescriptors.add( mojoDescriptor );\n            }\n        }\n\n        PluginUtils.sortMojos( mojoDescriptors );\n\n        writer.write( \"    /** {@inheritDoc} */\" + LS );\n        writer.write( \"    public void execute()\" + LS );\n        writer.write( \"        throws MojoExecutionException\" + LS );\n        writer.write( \"    {\" + LS );\n\n        writer.write( \"        if ( lineLength <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().warn( \\\"The parameter 'lineLength' should be positive, using '80' as \"\n            + \"default.\\\" );\" + LS );\n        writer.write( \"            lineLength = 80;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        if ( indentSize <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().warn( \\\"The parameter 'indentSize' should be positive, using '2' as \"\n            + \"default.\\\" );\" + LS );\n        writer.write( \"            indentSize = 2;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        StringBuffer sb = new StringBuffer();\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        append( sb, \\\"\" + StringUtils.escape( pluginDescriptor.getId() ) + \"\\\", 0 );\" + LS );\n        writer.write( \"        append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( LS );\n\n        if ( StringUtils.isNotEmpty( pluginDescriptor.getName() )\n            && ( pluginDescriptor.getName().indexOf( pluginDescriptor.getId() ) != -1 ) )\n        {\n            writer.write( \"        append( sb, \\\"\"\n                + StringUtils.escape( pluginDescriptor.getName() + \" \" + pluginDescriptor.getVersion() )\n                + \"\\\", 0 );\" + LS );\n        }\n        else\n        {\n            if ( StringUtils.isNotEmpty( pluginDescriptor.getName() ) )\n            {\n                writer.write( \"        append( sb, \\\"\" + StringUtils.escape( pluginDescriptor.getName() )\n                    + \"\\\", 0 );\" + LS );\n            }\n            else\n            {\n                writer.write( \"        append( sb, \\\"\" + StringUtils.escape( pluginDescriptor.getId() )\n                    + \"\\\", 0 );\" + LS );\n            }\n        }\n        writer.write( \"        append( sb, \\\"\" + toDescription( pluginDescriptor.getDescription() ) + \"\\\", 1 );\"\n            + LS );\n        writer.write( \"        append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        if ( goal == null || goal.length() <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            append( sb, \\\"This plugin has \" + mojoDescriptors.size() + \" \"\n            + ( mojoDescriptors.size() > 1 ? \"goals\" : \"goal\" ) + \":\\\", 0 );\" + LS );\n        writer.write( \"            append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( \"        }\" + LS );\n\n        writer.write( LS );\n\n        for ( MojoDescriptor descriptor : mojoDescriptors )\n        {\n            writeGoal( writer, descriptor );\n        }\n\n        writer.write( \"        if ( getLog().isInfoEnabled() )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().info( sb.toString() );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param descriptor not null\n     * @throws IOException if any\n     */\n    private static void writeGoal( Writer writer, MojoDescriptor descriptor )\n        throws IOException\n    {\n        String goalDescription = toDescription( descriptor.getDescription() );\n\n        writer.write( \"        if ( goal == null || goal.length() <= 0 || \\\"\"\n            + StringUtils.escape( descriptor.getGoal() ) + \"\\\".equals( goal ) )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            append( sb, \\\"\" + StringUtils.escape( descriptor.getFullGoalName() ) + \"\\\", 0 );\"\n            + LS );\n        if ( StringUtils.isNotEmpty( descriptor.getDeprecated() ) )\n        {\n            writer.write( \"            append( sb, \\\"Deprecated. \" + toDescription( descriptor.getDeprecated() )\n                + \"\\\", 1 );\" + LS );\n            writer.write( \"            if ( detail )\" + LS );\n            writer.write( \"            {\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n            writer.write( \"                append( sb, \\\"\" + goalDescription + \"\\\", 1 );\" + LS );\n            writer.write( \"            }\" + LS );\n        }\n        else\n        {\n            writer.write( \"            append( sb, \\\"\" + goalDescription + \"\\\", 1 );\" + LS );\n        }\n        writer.write( \"            append( sb, \\\"\\\", 0 );\" + LS );\n\n        if ( descriptor.getParameters() != null && descriptor.getParameters().size() > 0 )\n        {\n            @SuppressWarnings( \"unchecked\" )\n            List<Parameter> params = descriptor.getParameters();\n\n            PluginUtils.sortMojoParameters( params );\n\n            writer.write( \"            if ( detail )\" + LS );\n            writer.write( \"            {\" + LS );\n\n            writer.write( \"                append( sb, \\\"Available parameters:\\\", 1 );\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n\n            for ( Parameter parameter : params )\n            {\n                if ( parameter.isEditable() )\n                {\n                    writer.write( LS );\n                    writeParameter( writer, parameter );\n                }\n            }\n\n            writer.write( \"            }\" + LS );\n        }\n\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param parameter not null\n     * @throws IOException if any\n     */\n    private static void writeParameter( Writer writer, Parameter parameter )\n        throws IOException\n    {\n        String expression = parameter.getExpression();\n\n        if ( expression == null || !expression.startsWith( \"${component.\" ) )\n        {\n            String parameterName = StringUtils.escape( parameter.getName() );\n            String parameterDescription = toDescription( parameter.getDescription() );\n            String parameterDefaultValue = \"\";\n            if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) )\n            {\n                parameterDefaultValue = \" (Default: \" + StringUtils.escape( parameter.getDefaultValue() ) + \")\";\n            }\n            writer.write( \"                append( sb, \\\"\" + parameterName + parameterDefaultValue + \"\\\", 2 );\" + LS );\n            if ( StringUtils.isNotEmpty( parameter.getDeprecated() ) )\n            {\n                writer.write( \"                append( sb, \\\"Deprecated. \" + toDescription( parameter.getDeprecated() )\n                    + \"\\\", 3 );\" + LS );\n                writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n            }\n            writer.write( \"                append( sb, \\\"\" + parameterDescription + \"\\\", 3 );\" + LS );\n            if ( parameter.isRequired() )\n            {\n                writer.write( \"                append( sb, \\\"Required: Yes\\\", 3 );\" + LS );\n            }\n            if ( StringUtils.isNotEmpty( parameter.getExpression() ) )\n            {\n                writer.write( \"                append( sb, \\\"Expression: \"\n                    + StringUtils.escape( parameter.getExpression() ) + \"\\\", 3 );\" + LS );\n            }\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n        }\n    }\n\n    /**\n     * @param writer not null\n     * @param useJava5 If the generated code should use Java5 features\n     * @throws IOException if any\n     */\n    private static void writeUtilities( Writer writer, boolean useJava5 )\n        throws IOException\n    {\n        writer.write( \"    /**\" + LS );\n        writer.write( \"     * <p>Repeat a String <code>n<\/code> times to form a new string.<\/p>\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @param str String to repeat\" + LS );\n        writer.write( \"     * @param repeat number of times to repeat str\" + LS );\n        writer.write( \"     * @return String with repeated String\" + LS );\n        writer.write( \"     * @throws NegativeArraySizeException if <code>repeat < 0<\/code>\" + LS );\n        writer.write( \"     * @throws NullPointerException if str is <code>null<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static String repeat( String str, int repeat )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        StringBuffer buffer = new StringBuffer( repeat * str.length() );\" + LS );\n        writer.write( LS );\n        writer.write( \"        for ( int i = 0; i < repeat; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            buffer.append( str );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return buffer.toString();\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Append a description to the buffer by respecting the indentSize and lineLength \"\n            + \"parameters.\" + LS );\n        writer.write( \"     * <b>Note<\/b>: The last character is always a new line.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param sb The buffer to append the description, not <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param description The description, not <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indent The base indentation level of each line, must not be negative.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private void append( StringBuffer sb, String description, int indent )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        for ( Iterator it = toLines( description, indent, indentSize, lineLength )\"\n            + \".iterator(); it.hasNext(); )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            sb.append( it.next().toString() ).append( '\\\\n' );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Splits the specified text into lines of convenient display length.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param text The text to split into lines, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indent The base indentation level of each line, must not be negative.\" + LS );\n        writer.write( \"     * @param indentSize The size of each indentation, must not be negative.\" + LS );\n        writer.write( \"     * @param lineLength The length of the line, must not be negative.\" + LS );\n        writer.write( \"     * @return The sequence of display lines, never <code>null<\/code>.\" + LS );\n        writer.write( \"     * @throws NegativeArraySizeException if <code>indent < 0<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static List toLines( String text, int indent, int indentSize, int lineLength )\"\n            + LS );\n        writer.write( \"    {\" + LS );\n        if ( useJava5 )\n        {\n            writer.write( \"        List<String> lines = new ArrayList<String>();\" + LS );\n        }\n        else\n        {\n            writer.write( \"        List lines = new ArrayList();\" + LS );\n        }\n        writer.write( LS );\n        writer.write( \"        String ind = repeat( \\\"\\\\t\\\", indent );\" + LS );\n        writer.write( \"        String[] plainLines = text.split( \\\"(\\\\r\\\\n)|(\\\\r)|(\\\\n)\\\" );\" + LS );\n        writer.write( \"        for ( int i = 0; i < plainLines.length; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            toLines( lines, ind + plainLines[i], indentSize, lineLength );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return lines;\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Adds the specified line to the output sequence, performing line wrapping if necessary.\"\n            + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param lines The sequence of display lines, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param line The line to add, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indentSize The size of each indentation, must not be negative.\" + LS );\n        writer.write( \"     * @param lineLength The length of the line, must not be negative.\" + LS );\n        writer.write( \"     */\" + LS );\n        if ( useJava5 )\n        {\n            writer.write( \"    private static void toLines( List<String> lines, String line, int indentSize, int lineLength )\"\n                + LS );\n        }\n        else\n        {\n            writer.write( \"    private static void toLines( List lines, String line, int indentSize, int lineLength )\"\n                + LS );\n        }\n        writer.write( \"    {\" + LS );\n        writer.write( \"        int lineIndent = getIndentLevel( line );\" + LS );\n        writer.write( \"        StringBuffer buf = new StringBuffer( 256 );\" + LS );\n        writer.write( \"        String[] tokens = line.split( \\\" +\\\" );\" + LS );\n        writer.write( \"        for ( int i = 0; i < tokens.length; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            String token = tokens[i];\" + LS );\n        writer.write( \"            if ( i > 0 )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                if ( buf.length() + token.length() >= lineLength )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    lines.add( buf.toString() );\" + LS );\n        writer.write( \"                    buf.setLength( 0 );\" + LS );\n        writer.write( \"                    buf.append( repeat( \\\" \\\", lineIndent * indentSize ) );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( ' ' );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"            for ( int j = 0; j < token.length(); j++ )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                char c = token.charAt( j );\" + LS );\n        writer.write( \"                if ( c == '\\\\t' )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( repeat( \\\" \\\", indentSize - buf.length() % indentSize ) );\"\n            + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else if ( c == '\\\\u00A0' )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( ' ' );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( c );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        lines.add( buf.toString() );\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Gets the indentation level of the specified line.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param line The line whose indentation level should be retrieved, must not be \"\n            + \"<code>null<\/code>.\" + LS );\n        writer.write( \"     * @return The indentation level of the line.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static int getIndentLevel( String line )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        int level = 0;\" + LS );\n        writer.write( \"        for ( int i = 0; i < line.length() && line.charAt( i ) == '\\\\t'; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            level++;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        for ( int i = level + 1; i <= level + 4 && i < line.length(); i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            if ( line.charAt( i ) == '\\\\t' )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                level++;\" + LS );\n        writer.write( \"                break;\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        return level;\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    /**\n     * Gets the effective string to use for the plugin/mojo/parameter description.\n     *\n     * @param description The description of the element, may be <code>null<\/code>.\n     * @return The effective description string, never <code>null<\/code>.\n     */\n    private static String toDescription( String description )\n    {\n        if ( StringUtils.isNotEmpty( description ) )\n        {\n            return StringUtils.escape( PluginUtils.toText( description ) );\n        }\n\n        return \"(no description available)\";\n    }\n\n    /**\n     * Converts a HTML fragment as extracted from a javadoc comment to a plain text string. This method tries to retain\n     * as much of the text formatting as possible by means of the following transformations:\n     * <ul>\n     * <li>List items are converted to leading tabs (U+0009), followed by the item number/bullet, another tab and\n     * finally the item contents. Each tab denotes an increase of indentation.<\/li>\n     * <li>Flow breaking elements as well as literal line terminators in preformatted text are converted to a newline\n     * (U+000A) to denote a mandatory line break.<\/li>\n     * <li>Consecutive spaces and line terminators from character data outside of preformatted text will be normalized\n     * to a single space. The resulting space denotes a possible point for line wrapping.<\/li>\n     * <li>Each space in preformatted text will be converted to a non-breaking space (U+00A0).<\/li>\n     * <\/ul>\n     *\n     * @param html The HTML fragment to convert to plain text, may be <code>null<\/code>.\n     * @return A string with HTML tags converted into pure text, never <code>null<\/code>.\n     * @deprecated since 2.4.3, using {@link PluginUtils#toText(String)} instead of.\n     */\n    protected static String toText( String html )\n    {\n        return PluginUtils.toText( html );\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * Generates an <code>HelpMojo<\/code> class.\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    /** Line separator */\n    private static final String LS = System.getProperty( \"line.separator\" );\n\n    /** Default generated class name */\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    /** Default goal */\n    private static final String HELP_GOAL = \"help\";\n\n    private String helpPackageName;\n    \n    /** Flag to indicate if the generated help mojo should use Java 5 features */\n    private boolean useJava5;\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        execute( destinationDirectory, new DefaultPluginToolsRequest( null, pluginDescriptor ) );\n    }\n    \n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws IOException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n        \n        if ( pluginDescriptor.getMojos() == null || pluginDescriptor.getMojos().size() < 1 )\n        {\n            return;\n        }\n\n        MojoDescriptor helpDescriptor = makeHelpDescriptor( pluginDescriptor );\n\n        // Verify that no help goal already exists\n        for ( @SuppressWarnings( \"unchecked\" )\n        Iterator<MojoDescriptor> it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = it.next();\n\n            if ( descriptor.getGoal().equals( helpDescriptor.getGoal() )\n                && !descriptor.getImplementation().equals( helpDescriptor.getImplementation() ) )\n            {\n                if ( getLogger().isWarnEnabled() )\n                {\n                    getLogger().warn(\n                                      \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                          + \") already exists in this plugin. SKIPPED THE \"\n                                          + helpDescriptor.getImplementation() + \" GENERATION.\\n\" );\n                }\n\n                return;\n            }\n        }\n\n        String sourcePath = helpDescriptor.getImplementation().replace( '.', File.separatorChar ) + \".java\";\n        File helpClass = new File( destinationDirectory, sourcePath );\n        helpClass.getParentFile().mkdirs();\n\n        Writer writer = null;\n        try\n        {\n            writer = new OutputStreamWriter( new FileOutputStream( helpClass ), request.getEncoding() );\n            writeClass( writer, pluginDescriptor, helpDescriptor, useJava5 );\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    public PluginHelpGenerator setHelpPackageName( String helpPackageName )\n    {\n        this.helpPackageName = helpPackageName;\n        return this;\n    }\n\n    public PluginHelpGenerator setUseJava5( boolean useJava5 )\n    {\n        this.useJava5 = useJava5;\n        return this;\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * Creates a minimalistic mojo descriptor for the generated help goal.\n     *\n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *            <code>null<\/code>.\n     * @return The mojo descriptor for the generated help goal, never <code>null<\/code>.\n     */\n    private MojoDescriptor makeHelpDescriptor( PluginDescriptor pluginDescriptor )\n    {\n        MojoDescriptor descriptor = new MojoDescriptor();\n\n        descriptor.setPluginDescriptor( pluginDescriptor );\n\n        descriptor.setLanguage( \"java\" );\n\n        descriptor.setGoal( HELP_GOAL );\n\n        String packageName = helpPackageName;\n        if ( StringUtils.isEmpty( packageName ) )\n        {\n            packageName = discoverPackageName( pluginDescriptor );\n        }\n        if ( StringUtils.isNotEmpty( packageName ) )\n        {\n            descriptor.setImplementation( packageName + '.' + HELP_MOJO_CLASS_NAME );\n        }\n        else\n        {\n            descriptor.setImplementation( HELP_MOJO_CLASS_NAME );\n        }\n\n        descriptor.setDescription( \"Display help information on \" + pluginDescriptor.getArtifactId()\n            + \".<br/> Call <pre>  mvn \" + descriptor.getFullGoalName()\n            + \" -Ddetail=true -Dgoal=&lt;goal-name&gt;<\/pre> to display parameter details.\" );\n\n        try\n        {\n            Parameter param = new Parameter();\n            param.setName( \"detail\" );\n            param.setType( \"boolean\" );\n            param.setDescription( \"If <code>true<\/code>, display all settable properties for each goal.\" );\n            param.setDefaultValue( \"false\" );\n            param.setExpression( \"${detail}\" );\n            descriptor.addParameter( param );\n\n            param = new Parameter();\n            param.setName( \"goal\" );\n            param.setType( \"java.lang.String\" );\n            param.setDescription( \"The name of the goal for which to show help.\"\n                + \" If unspecified, all goals will be displayed.\" );\n            param.setExpression( \"${goal}\" );\n            descriptor.addParameter( param );\n\n            param = new Parameter();\n            param.setName( \"lineLength\" );\n            param.setType( \"int\" );\n            param.setDescription( \"The maximum length of a display line, should be positive.\" );\n            param.setDefaultValue( \"80\" );\n            param.setExpression( \"${lineLength}\" );\n            descriptor.addParameter( param );\n\n            param = new Parameter();\n            param.setName( \"indentSize\" );\n            param.setType( \"int\" );\n            param.setDescription( \"The number of spaces per indentation level, should be positive.\" );\n            param.setDefaultValue( \"2\" );\n            param.setExpression( \"${indentSize}\" );\n            descriptor.addParameter( param );\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( \"Failed to setup parameters for help goal\", e );\n        }\n\n        return descriptor;\n    }\n\n    /**\n     * Find the best package name, based on the number of hits of actual Mojo classes.\n     *\n     * @param pluginDescriptor not null\n     * @return the best name of the package for the generated mojo\n     */\n    private static String discoverPackageName( PluginDescriptor pluginDescriptor )\n    {\n        Map<String, Integer> packageNames = new HashMap<String, Integer>();\n        for ( @SuppressWarnings( \"unchecked\" )\n        Iterator<MojoDescriptor> it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = it.next();\n\n            String impl = descriptor.getImplementation();\n            if ( impl.lastIndexOf( '.' ) != -1 )\n            {\n                String name = impl.substring( 0, impl.lastIndexOf( '.' ) );\n                if ( packageNames.get( name ) != null )\n                {\n                    int next = ( (Integer) packageNames.get( name ) ).intValue() + 1;\n                    packageNames.put( name, new Integer( next ) );\n                }\n                else\n                {\n                    packageNames.put( name, new Integer( 1 ) );\n                }\n            }\n            else\n            {\n                packageNames.put( \"\", new Integer( 1 ) );\n            }\n        }\n\n        String packageName = \"\";\n        int max = 0;\n        for ( String key : packageNames.keySet() )\n        {\n            int value = ( (Integer) packageNames.get( key ) ).intValue();\n            if ( value > max )\n            {\n                max = value;\n                packageName = key;\n            }\n        }\n\n        return packageName;\n    }\n\n    /**\n     * Generates the <code>HelpMojo<\/code> class.\n     *\n     * @param writer not null\n     * @param pluginDescriptor not null\n     * @param helpDescriptor not null\n     * @param useJava5 If the generated code should use Java5 features\n     * @throws IOException if any\n     */\n    private static void writeClass( Writer writer, PluginDescriptor pluginDescriptor, MojoDescriptor helpDescriptor,\n                                    boolean useJava5 )\n        throws IOException\n    {\n        String packageName = \"\";\n        String simpleName = helpDescriptor.getImplementation();\n        int dot = simpleName.lastIndexOf( '.' );\n        if ( dot >= 0 )\n        {\n            packageName = simpleName.substring( 0, dot );\n            simpleName = simpleName.substring( dot + 1 );\n        }\n\n        if ( packageName.length() > 0 )\n        {\n            writer.write( \"package \" + packageName + \";\" + LS );\n            writer.write( LS );\n        }\n\n        writeImports( writer );\n        writer.write( LS );\n\n        writeMojoJavadoc( writer, pluginDescriptor, helpDescriptor );\n\n        if ( useJava5 )\n        {\n            writer.write( \"@SuppressWarnings( \\\"all\\\" )\" + LS );\n        }\n\n        writer.write( \"public class \" + simpleName + LS );\n        writer.write( \"    extends AbstractMojo\" + LS );\n        writer.write( \"{\" + LS );\n\n        writeVariables( writer, helpDescriptor );\n\n        writer.write( LS );\n\n        writeExecute( writer, pluginDescriptor, helpDescriptor );\n\n        writer.write( LS );\n        writeUtilities( writer, useJava5 );\n        writer.write( \"}\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @throws IOException if any\n     */\n    private static void writeImports( Writer writer )\n        throws IOException\n    {\n        writer.write( \"import java.util.ArrayList;\" + LS );\n        writer.write( \"import java.util.Iterator;\" + LS );\n        writer.write( \"import java.util.List;\" + LS );\n        writer.write( LS );\n        writer.write( \"import org.apache.maven.plugin.AbstractMojo;\" + LS );\n        writer.write( \"import org.apache.maven.plugin.MojoExecutionException;\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param pluginDescriptor not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeMojoJavadoc( Writer writer, PluginDescriptor pluginDescriptor,\n                                          MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        StringBuffer author = new StringBuffer();\n        author.append( PluginHelpGenerator.class.getName() );\n\n        String resource = \"META-INF/maven/org.apache.maven.plugin-tools/maven-plugin-tools-api/pom.properties\";\n        InputStream resourceAsStream = PluginHelpGenerator.class.getClassLoader().getResourceAsStream( resource );\n\n        if ( resourceAsStream != null )\n        {\n            try\n            {\n                Properties properties = new Properties();\n                properties.load( resourceAsStream );\n\n                author.append( \" (version \" ).append( properties.getProperty( \"version\", \"unknown\" ) ).append( \")\" );\n            }\n            catch ( IOException e )\n            {\n                // nope\n            }\n        }\n\n        writer.write( \"/**\" + LS );\n        writer.write( \" * \" + helpDescriptor.getDescription() + LS );\n        writer.write( \" *\" + LS );\n        writer.write( \" * @version generated on \" + new Date() + LS );\n        writer.write( \" * @author \" + author.toString() + LS );\n        writer.write( \" * @goal \" + helpDescriptor.getGoal() + LS );\n        writer.write( \" * @requiresProject false\" + LS );\n        writer.write( \" * @threadSafe\" + LS );\n        writer.write( \" */\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeVariables( Writer writer, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        for ( @SuppressWarnings( \"unchecked\" )\n        Iterator<Parameter> it = helpDescriptor.getParameters().iterator(); it.hasNext(); )\n        {\n            Parameter param = it.next();\n            writer.write( \"    /**\" + LS );\n            writer.write( \"     * \" + StringUtils.escape( param.getDescription() ) + LS );\n            writer.write( \"     * \" + LS );\n            writer.write( \"     * @parameter\" );\n            if ( StringUtils.isNotEmpty( param.getExpression() ) )\n            {\n                writer.write( \" expression=\\\"\" );\n                writer.write( StringUtils.escape( param.getExpression() ) );\n                writer.write( \"\\\"\" );\n            }\n            if ( StringUtils.isNotEmpty( param.getDefaultValue() ) )\n            {\n                writer.write( \" default-value=\\\"\" );\n                writer.write( StringUtils.escape( param.getDefaultValue() ) );\n                writer.write( \"\\\"\" );\n            }\n            writer.write( LS );\n            writer.write( \"     */\" + LS );\n            writer.write( \"    private \" + param.getType() + \" \" + param.getName() + \";\" + LS );\n            writer.write( LS );\n        }\n    }\n\n    /**\n     * @param writer not null\n     * @param pluginDescriptor not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeExecute( Writer writer, PluginDescriptor pluginDescriptor, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        List<MojoDescriptor> mojoDescriptors = new ArrayList<MojoDescriptor>();\n\n        mojoDescriptors.add( helpDescriptor );\n        for ( @SuppressWarnings( \"unchecked\" )\n        Iterator<MojoDescriptor> it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor mojoDescriptor = it.next();\n\n            if ( !helpDescriptor.getGoal().equals( mojoDescriptor.getGoal() ) )\n            {\n                mojoDescriptors.add( mojoDescriptor );\n            }\n        }\n\n        PluginUtils.sortMojos( mojoDescriptors );\n\n        writer.write( \"    /** {@inheritDoc} */\" + LS );\n        writer.write( \"    public void execute()\" + LS );\n        writer.write( \"        throws MojoExecutionException\" + LS );\n        writer.write( \"    {\" + LS );\n\n        writer.write( \"        if ( lineLength <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().warn( \\\"The parameter 'lineLength' should be positive, using '80' as \"\n            + \"default.\\\" );\" + LS );\n        writer.write( \"            lineLength = 80;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        if ( indentSize <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().warn( \\\"The parameter 'indentSize' should be positive, using '2' as \"\n            + \"default.\\\" );\" + LS );\n        writer.write( \"            indentSize = 2;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        StringBuffer sb = new StringBuffer();\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        append( sb, \\\"\" + StringUtils.escape( pluginDescriptor.getId() ) + \"\\\", 0 );\" + LS );\n        writer.write( \"        append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( LS );\n\n        if ( StringUtils.isNotEmpty( pluginDescriptor.getName() )\n            && ( pluginDescriptor.getName().indexOf( pluginDescriptor.getId() ) != -1 ) )\n        {\n            writer.write( \"        append( sb, \\\"\"\n                + StringUtils.escape( pluginDescriptor.getName() + \" \" + pluginDescriptor.getVersion() )\n                + \"\\\", 0 );\" + LS );\n        }\n        else\n        {\n            if ( StringUtils.isNotEmpty( pluginDescriptor.getName() ) )\n            {\n                writer.write( \"        append( sb, \\\"\" + StringUtils.escape( pluginDescriptor.getName() )\n                    + \"\\\", 0 );\" + LS );\n            }\n            else\n            {\n                writer.write( \"        append( sb, \\\"\" + StringUtils.escape( pluginDescriptor.getId() )\n                    + \"\\\", 0 );\" + LS );\n            }\n        }\n        writer.write( \"        append( sb, \\\"\" + toDescription( pluginDescriptor.getDescription() ) + \"\\\", 1 );\"\n            + LS );\n        writer.write( \"        append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        if ( goal == null || goal.length() <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            append( sb, \\\"This plugin has \" + mojoDescriptors.size() + \" \"\n            + ( mojoDescriptors.size() > 1 ? \"goals\" : \"goal\" ) + \":\\\", 0 );\" + LS );\n        writer.write( \"            append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( \"        }\" + LS );\n\n        writer.write( LS );\n\n        for ( Iterator<MojoDescriptor> it = mojoDescriptors.iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = it.next();\n\n            writeGoal( writer, descriptor );\n        }\n\n        writer.write( \"        if ( getLog().isInfoEnabled() )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().info( sb.toString() );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param descriptor not null\n     * @throws IOException if any\n     */\n    private static void writeGoal( Writer writer, MojoDescriptor descriptor )\n        throws IOException\n    {\n        String goalDescription = toDescription( descriptor.getDescription() );\n\n        writer.write( \"        if ( goal == null || goal.length() <= 0 || \\\"\"\n            + StringUtils.escape( descriptor.getGoal() ) + \"\\\".equals( goal ) )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            append( sb, \\\"\" + StringUtils.escape( descriptor.getFullGoalName() ) + \"\\\", 0 );\"\n            + LS );\n        if ( StringUtils.isNotEmpty( descriptor.getDeprecated() ) )\n        {\n            writer.write( \"            append( sb, \\\"Deprecated. \" + toDescription( descriptor.getDeprecated() )\n                + \"\\\", 1 );\" + LS );\n            writer.write( \"            if ( detail )\" + LS );\n            writer.write( \"            {\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n            writer.write( \"                append( sb, \\\"\" + goalDescription + \"\\\", 1 );\" + LS );\n            writer.write( \"            }\" + LS );\n        }\n        else\n        {\n            writer.write( \"            append( sb, \\\"\" + goalDescription + \"\\\", 1 );\" + LS );\n        }\n        writer.write( \"            append( sb, \\\"\\\", 0 );\" + LS );\n\n        if ( descriptor.getParameters() != null && descriptor.getParameters().size() > 0 )\n        {\n            @SuppressWarnings( \"unchecked\" )\n            List<Parameter> params = descriptor.getParameters();\n\n            PluginUtils.sortMojoParameters( params );\n\n            writer.write( \"            if ( detail )\" + LS );\n            writer.write( \"            {\" + LS );\n\n            writer.write( \"                append( sb, \\\"Available parameters:\\\", 1 );\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n\n            for ( Parameter parameter : params )\n            {\n                if ( parameter.isEditable() )\n                {\n                    writer.write( LS );\n                    writeParameter( writer, parameter );\n                }\n            }\n\n            writer.write( \"            }\" + LS );\n        }\n\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param parameter not null\n     * @throws IOException if any\n     */\n    private static void writeParameter( Writer writer, Parameter parameter )\n        throws IOException\n    {\n        String expression = parameter.getExpression();\n\n        if ( expression == null || !expression.startsWith( \"${component.\" ) )\n        {\n            String parameterName = StringUtils.escape( parameter.getName() );\n            String parameterDescription = toDescription( parameter.getDescription() );\n            String parameterDefaultValue = \"\";\n            if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) )\n            {\n                parameterDefaultValue = \" (Default: \" + StringUtils.escape( parameter.getDefaultValue() ) + \")\";\n            }\n            writer.write( \"                append( sb, \\\"\" + parameterName + parameterDefaultValue + \"\\\", 2 );\" + LS );\n            if ( StringUtils.isNotEmpty( parameter.getDeprecated() ) )\n            {\n                writer.write( \"                append( sb, \\\"Deprecated. \" + toDescription( parameter.getDeprecated() )\n                    + \"\\\", 3 );\" + LS );\n                writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n            }\n            writer.write( \"                append( sb, \\\"\" + parameterDescription + \"\\\", 3 );\" + LS );\n            if ( parameter.isRequired() )\n            {\n                writer.write( \"                append( sb, \\\"Required: Yes\\\", 3 );\" + LS );\n            }\n            if ( StringUtils.isNotEmpty( parameter.getExpression() ) )\n            {\n                writer.write( \"                append( sb, \\\"Expression: \"\n                    + StringUtils.escape( parameter.getExpression() ) + \"\\\", 3 );\" + LS );\n            }\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n        }\n    }\n\n    /**\n     * @param writer not null\n     * @param useJava5 If the generated code should use Java5 features\n     * @throws IOException if any\n     */\n    private static void writeUtilities( Writer writer, boolean useJava5 )\n        throws IOException\n    {\n        writer.write( \"    /**\" + LS );\n        writer.write( \"     * <p>Repeat a String <code>n<\/code> times to form a new string.<\/p>\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @param str String to repeat\" + LS );\n        writer.write( \"     * @param repeat number of times to repeat str\" + LS );\n        writer.write( \"     * @return String with repeated String\" + LS );\n        writer.write( \"     * @throws NegativeArraySizeException if <code>repeat < 0<\/code>\" + LS );\n        writer.write( \"     * @throws NullPointerException if str is <code>null<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static String repeat( String str, int repeat )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        StringBuffer buffer = new StringBuffer( repeat * str.length() );\" + LS );\n        writer.write( LS );\n        writer.write( \"        for ( int i = 0; i < repeat; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            buffer.append( str );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return buffer.toString();\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Append a description to the buffer by respecting the indentSize and lineLength \"\n            + \"parameters.\" + LS );\n        writer.write( \"     * <b>Note<\/b>: The last character is always a new line.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param sb The buffer to append the description, not <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param description The description, not <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indent The base indentation level of each line, must not be negative.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private void append( StringBuffer sb, String description, int indent )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        for ( Iterator it = toLines( description, indent, indentSize, lineLength )\"\n            + \".iterator(); it.hasNext(); )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            sb.append( it.next().toString() ).append( '\\\\n' );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Splits the specified text into lines of convenient display length.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param text The text to split into lines, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indent The base indentation level of each line, must not be negative.\" + LS );\n        writer.write( \"     * @param indentSize The size of each indentation, must not be negative.\" + LS );\n        writer.write( \"     * @param lineLength The length of the line, must not be negative.\" + LS );\n        writer.write( \"     * @return The sequence of display lines, never <code>null<\/code>.\" + LS );\n        writer.write( \"     * @throws NegativeArraySizeException if <code>indent < 0<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static List toLines( String text, int indent, int indentSize, int lineLength )\"\n            + LS );\n        writer.write( \"    {\" + LS );\n        if ( useJava5 )\n        {\n            writer.write( \"        List<String> lines = new ArrayList<String>();\" + LS );\n        }\n        else\n        {\n            writer.write( \"        List lines = new ArrayList();\" + LS );\n        }\n        writer.write( LS );\n        writer.write( \"        String ind = repeat( \\\"\\\\t\\\", indent );\" + LS );\n        writer.write( \"        String[] plainLines = text.split( \\\"(\\\\r\\\\n)|(\\\\r)|(\\\\n)\\\" );\" + LS );\n        writer.write( \"        for ( int i = 0; i < plainLines.length; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            toLines( lines, ind + plainLines[i], indentSize, lineLength );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return lines;\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Adds the specified line to the output sequence, performing line wrapping if necessary.\"\n            + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param lines The sequence of display lines, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param line The line to add, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indentSize The size of each indentation, must not be negative.\" + LS );\n        writer.write( \"     * @param lineLength The length of the line, must not be negative.\" + LS );\n        writer.write( \"     */\" + LS );\n        if ( useJava5 )\n        {\n            writer.write( \"    private static void toLines( List<String> lines, String line, int indentSize, int lineLength )\"\n                + LS );\n        }\n        else\n        {\n            writer.write( \"    private static void toLines( List lines, String line, int indentSize, int lineLength )\"\n                + LS );\n        }\n        writer.write( \"    {\" + LS );\n        writer.write( \"        int lineIndent = getIndentLevel( line );\" + LS );\n        writer.write( \"        StringBuffer buf = new StringBuffer( 256 );\" + LS );\n        writer.write( \"        String[] tokens = line.split( \\\" +\\\" );\" + LS );\n        writer.write( \"        for ( int i = 0; i < tokens.length; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            String token = tokens[i];\" + LS );\n        writer.write( \"            if ( i > 0 )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                if ( buf.length() + token.length() >= lineLength )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    lines.add( buf.toString() );\" + LS );\n        writer.write( \"                    buf.setLength( 0 );\" + LS );\n        writer.write( \"                    buf.append( repeat( \\\" \\\", lineIndent * indentSize ) );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( ' ' );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"            for ( int j = 0; j < token.length(); j++ )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                char c = token.charAt( j );\" + LS );\n        writer.write( \"                if ( c == '\\\\t' )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( repeat( \\\" \\\", indentSize - buf.length() % indentSize ) );\"\n            + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else if ( c == '\\\\u00A0' )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( ' ' );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( c );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        lines.add( buf.toString() );\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Gets the indentation level of the specified line.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param line The line whose indentation level should be retrieved, must not be \"\n            + \"<code>null<\/code>.\" + LS );\n        writer.write( \"     * @return The indentation level of the line.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static int getIndentLevel( String line )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        int level = 0;\" + LS );\n        writer.write( \"        for ( int i = 0; i < line.length() && line.charAt( i ) == '\\\\t'; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            level++;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        for ( int i = level + 1; i <= level + 4 && i < line.length(); i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            if ( line.charAt( i ) == '\\\\t' )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                level++;\" + LS );\n        writer.write( \"                break;\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        return level;\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    /**\n     * Gets the effective string to use for the plugin/mojo/parameter description.\n     *\n     * @param description The description of the element, may be <code>null<\/code>.\n     * @return The effective description string, never <code>null<\/code>.\n     */\n    private static String toDescription( String description )\n    {\n        if ( StringUtils.isNotEmpty( description ) )\n        {\n            return StringUtils.escape( PluginUtils.toText( description ) );\n        }\n\n        return \"(no description available)\";\n    }\n\n    /**\n     * Converts a HTML fragment as extracted from a javadoc comment to a plain text string. This method tries to retain\n     * as much of the text formatting as possible by means of the following transformations:\n     * <ul>\n     * <li>List items are converted to leading tabs (U+0009), followed by the item number/bullet, another tab and\n     * finally the item contents. Each tab denotes an increase of indentation.<\/li>\n     * <li>Flow breaking elements as well as literal line terminators in preformatted text are converted to a newline\n     * (U+000A) to denote a mandatory line break.<\/li>\n     * <li>Consecutive spaces and line terminators from character data outside of preformatted text will be normalized\n     * to a single space. The resulting space denotes a possible point for line wrapping.<\/li>\n     * <li>Each space in preformatted text will be converted to a non-breaking space (U+00A0).<\/li>\n     * <\/ul>\n     *\n     * @param html The HTML fragment to convert to plain text, may be <code>null<\/code>.\n     * @return A string with HTML tags converted into pure text, never <code>null<\/code>.\n     * @deprecated since 2.4.3, using {@link PluginUtils#toText(String)} instead of.\n     */\n    protected static String toText( String html )\n    {\n        return PluginUtils.toText( html );\n    }\n}\n","lineNo":257}
{"Refactored Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * Generates an <code>HelpMojo<\/code> class.\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    /** Line separator */\n    private static final String LS = System.getProperty( \"line.separator\" );\n\n    /** Default generated class name */\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    /** Default goal */\n    private static final String HELP_GOAL = \"help\";\n\n    private String helpPackageName;\n    \n    /** Flag to indicate if the generated help mojo should use Java 5 features */\n    private boolean useJava5;\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        execute( destinationDirectory, new DefaultPluginToolsRequest( null, pluginDescriptor ) );\n    }\n    \n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws IOException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n        \n        if ( pluginDescriptor.getMojos() == null || pluginDescriptor.getMojos().size() < 1 )\n        {\n            return;\n        }\n\n        MojoDescriptor helpDescriptor = makeHelpDescriptor( pluginDescriptor );\n\n        // Verify that no help goal already exists\n        for ( @SuppressWarnings( \"unchecked\" )\n        Iterator<MojoDescriptor> it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = it.next();\n\n            if ( descriptor.getGoal().equals( helpDescriptor.getGoal() )\n                && !descriptor.getImplementation().equals( helpDescriptor.getImplementation() ) )\n            {\n                if ( getLogger().isWarnEnabled() )\n                {\n                    getLogger().warn(\n                                      \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                          + \") already exists in this plugin. SKIPPED THE \"\n                                          + helpDescriptor.getImplementation() + \" GENERATION.\\n\" );\n                }\n\n                return;\n            }\n        }\n\n        String sourcePath = helpDescriptor.getImplementation().replace( '.', File.separatorChar ) + \".java\";\n        File helpClass = new File( destinationDirectory, sourcePath );\n        helpClass.getParentFile().mkdirs();\n\n        Writer writer = null;\n        try\n        {\n            writer = new OutputStreamWriter( new FileOutputStream( helpClass ), request.getEncoding() );\n            writeClass( writer, pluginDescriptor, helpDescriptor, useJava5 );\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    public PluginHelpGenerator setHelpPackageName( String helpPackageName )\n    {\n        this.helpPackageName = helpPackageName;\n        return this;\n    }\n\n    public PluginHelpGenerator setUseJava5( boolean useJava5 )\n    {\n        this.useJava5 = useJava5;\n        return this;\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * Creates a minimalistic mojo descriptor for the generated help goal.\n     *\n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *            <code>null<\/code>.\n     * @return The mojo descriptor for the generated help goal, never <code>null<\/code>.\n     */\n    private MojoDescriptor makeHelpDescriptor( PluginDescriptor pluginDescriptor )\n    {\n        MojoDescriptor descriptor = new MojoDescriptor();\n\n        descriptor.setPluginDescriptor( pluginDescriptor );\n\n        descriptor.setLanguage( \"java\" );\n\n        descriptor.setGoal( HELP_GOAL );\n\n        String packageName = helpPackageName;\n        if ( StringUtils.isEmpty( packageName ) )\n        {\n            packageName = discoverPackageName( pluginDescriptor );\n        }\n        if ( StringUtils.isNotEmpty( packageName ) )\n        {\n            descriptor.setImplementation( packageName + '.' + HELP_MOJO_CLASS_NAME );\n        }\n        else\n        {\n            descriptor.setImplementation( HELP_MOJO_CLASS_NAME );\n        }\n\n        descriptor.setDescription( \"Display help information on \" + pluginDescriptor.getArtifactId()\n            + \".<br/> Call <pre>  mvn \" + descriptor.getFullGoalName()\n            + \" -Ddetail=true -Dgoal=&lt;goal-name&gt;<\/pre> to display parameter details.\" );\n\n        try\n        {\n            Parameter param = new Parameter();\n            param.setName( \"detail\" );\n            param.setType( \"boolean\" );\n            param.setDescription( \"If <code>true<\/code>, display all settable properties for each goal.\" );\n            param.setDefaultValue( \"false\" );\n            param.setExpression( \"${detail}\" );\n            descriptor.addParameter( param );\n\n            param = new Parameter();\n            param.setName( \"goal\" );\n            param.setType( \"java.lang.String\" );\n            param.setDescription( \"The name of the goal for which to show help.\"\n                + \" If unspecified, all goals will be displayed.\" );\n            param.setExpression( \"${goal}\" );\n            descriptor.addParameter( param );\n\n            param = new Parameter();\n            param.setName( \"lineLength\" );\n            param.setType( \"int\" );\n            param.setDescription( \"The maximum length of a display line, should be positive.\" );\n            param.setDefaultValue( \"80\" );\n            param.setExpression( \"${lineLength}\" );\n            descriptor.addParameter( param );\n\n            param = new Parameter();\n            param.setName( \"indentSize\" );\n            param.setType( \"int\" );\n            param.setDescription( \"The number of spaces per indentation level, should be positive.\" );\n            param.setDefaultValue( \"2\" );\n            param.setExpression( \"${indentSize}\" );\n            descriptor.addParameter( param );\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( \"Failed to setup parameters for help goal\", e );\n        }\n\n        return descriptor;\n    }\n\n    /**\n     * Find the best package name, based on the number of hits of actual Mojo classes.\n     *\n     * @param pluginDescriptor not null\n     * @return the best name of the package for the generated mojo\n     */\n    private static String discoverPackageName( PluginDescriptor pluginDescriptor )\n    {\n        Map<String, Integer> packageNames = new HashMap<String, Integer>();\n        for ( @SuppressWarnings( \"unchecked\" )\n        Iterator<MojoDescriptor> it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = it.next();\n\n            String impl = descriptor.getImplementation();\n            if ( impl.lastIndexOf( '.' ) != -1 )\n            {\n                String name = impl.substring( 0, impl.lastIndexOf( '.' ) );\n                if ( packageNames.get( name ) != null )\n                {\n                    int next = ( (Integer) packageNames.get( name ) ).intValue() + 1;\n                    packageNames.put( name, new Integer( next ) );\n                }\n                else\n                {\n                    packageNames.put( name, new Integer( 1 ) );\n                }\n            }\n            else\n            {\n                packageNames.put( \"\", new Integer( 1 ) );\n            }\n        }\n\n        String packageName = \"\";\n        int max = 0;\n        for ( String key : packageNames.keySet() )\n        {\n            int value = ( (Integer) packageNames.get( key ) ).intValue();\n            if ( value > max )\n            {\n                max = value;\n                packageName = key;\n            }\n        }\n\n        return packageName;\n    }\n\n    /**\n     * Generates the <code>HelpMojo<\/code> class.\n     *\n     * @param writer not null\n     * @param pluginDescriptor not null\n     * @param helpDescriptor not null\n     * @param useJava5 If the generated code should use Java5 features\n     * @throws IOException if any\n     */\n    private static void writeClass( Writer writer, PluginDescriptor pluginDescriptor, MojoDescriptor helpDescriptor,\n                                    boolean useJava5 )\n        throws IOException\n    {\n        String packageName = \"\";\n        String simpleName = helpDescriptor.getImplementation();\n        int dot = simpleName.lastIndexOf( '.' );\n        if ( dot >= 0 )\n        {\n            packageName = simpleName.substring( 0, dot );\n            simpleName = simpleName.substring( dot + 1 );\n        }\n\n        if ( packageName.length() > 0 )\n        {\n            writer.write( \"package \" + packageName + \";\" + LS );\n            writer.write( LS );\n        }\n\n        writeImports( writer );\n        writer.write( LS );\n\n        writeMojoJavadoc( writer, pluginDescriptor, helpDescriptor );\n\n        if ( useJava5 )\n        {\n            writer.write( \"@SuppressWarnings( \\\"all\\\" )\" + LS );\n        }\n\n        writer.write( \"public class \" + simpleName + LS );\n        writer.write( \"    extends AbstractMojo\" + LS );\n        writer.write( \"{\" + LS );\n\n        writeVariables( writer, helpDescriptor );\n\n        writer.write( LS );\n\n        writeExecute( writer, pluginDescriptor, helpDescriptor );\n\n        writer.write( LS );\n        writeUtilities( writer, useJava5 );\n        writer.write( \"}\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @throws IOException if any\n     */\n    private static void writeImports( Writer writer )\n        throws IOException\n    {\n        writer.write( \"import java.util.ArrayList;\" + LS );\n        writer.write( \"import java.util.Iterator;\" + LS );\n        writer.write( \"import java.util.List;\" + LS );\n        writer.write( LS );\n        writer.write( \"import org.apache.maven.plugin.AbstractMojo;\" + LS );\n        writer.write( \"import org.apache.maven.plugin.MojoExecutionException;\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param pluginDescriptor not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeMojoJavadoc( Writer writer, PluginDescriptor pluginDescriptor,\n                                          MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        StringBuffer author = new StringBuffer();\n        author.append( PluginHelpGenerator.class.getName() );\n\n        String resource = \"META-INF/maven/org.apache.maven.plugin-tools/maven-plugin-tools-api/pom.properties\";\n        InputStream resourceAsStream = PluginHelpGenerator.class.getClassLoader().getResourceAsStream( resource );\n\n        if ( resourceAsStream != null )\n        {\n            try\n            {\n                Properties properties = new Properties();\n                properties.load( resourceAsStream );\n\n                author.append( \" (version \" ).append( properties.getProperty( \"version\", \"unknown\" ) ).append( \")\" );\n            }\n            catch ( IOException e )\n            {\n                // nope\n            }\n        }\n\n        writer.write( \"/**\" + LS );\n        writer.write( \" * \" + helpDescriptor.getDescription() + LS );\n        writer.write( \" *\" + LS );\n        writer.write( \" * @version generated on \" + new Date() + LS );\n        writer.write( \" * @author \" + author.toString() + LS );\n        writer.write( \" * @goal \" + helpDescriptor.getGoal() + LS );\n        writer.write( \" * @requiresProject false\" + LS );\n        writer.write( \" * @threadSafe\" + LS );\n        writer.write( \" */\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeVariables( Writer writer, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        for ( @SuppressWarnings( \"unchecked\" )\n        Iterator<Parameter> it = helpDescriptor.getParameters().iterator(); it.hasNext(); )\n        {\n            Parameter param = it.next();\n            writer.write( \"    /**\" + LS );\n            writer.write( \"     * \" + StringUtils.escape( param.getDescription() ) + LS );\n            writer.write( \"     * \" + LS );\n            writer.write( \"     * @parameter\" );\n            if ( StringUtils.isNotEmpty( param.getExpression() ) )\n            {\n                writer.write( \" expression=\\\"\" );\n                writer.write( StringUtils.escape( param.getExpression() ) );\n                writer.write( \"\\\"\" );\n            }\n            if ( StringUtils.isNotEmpty( param.getDefaultValue() ) )\n            {\n                writer.write( \" default-value=\\\"\" );\n                writer.write( StringUtils.escape( param.getDefaultValue() ) );\n                writer.write( \"\\\"\" );\n            }\n            writer.write( LS );\n            writer.write( \"     */\" + LS );\n            writer.write( \"    private \" + param.getType() + \" \" + param.getName() + \";\" + LS );\n            writer.write( LS );\n        }\n    }\n\n    /**\n     * @param writer not null\n     * @param pluginDescriptor not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeExecute( Writer writer, PluginDescriptor pluginDescriptor, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        List<MojoDescriptor> mojoDescriptors = new ArrayList<MojoDescriptor>();\n\n        mojoDescriptors.add( helpDescriptor );\n        for ( @SuppressWarnings( \"unchecked\" )\n        Iterator<MojoDescriptor> it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor mojoDescriptor = it.next();\n\n            if ( !helpDescriptor.getGoal().equals( mojoDescriptor.getGoal() ) )\n            {\n                mojoDescriptors.add( mojoDescriptor );\n            }\n        }\n\n        PluginUtils.sortMojos( mojoDescriptors );\n\n        writer.write( \"    /** {@inheritDoc} */\" + LS );\n        writer.write( \"    public void execute()\" + LS );\n        writer.write( \"        throws MojoExecutionException\" + LS );\n        writer.write( \"    {\" + LS );\n\n        writer.write( \"        if ( lineLength <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().warn( \\\"The parameter 'lineLength' should be positive, using '80' as \"\n            + \"default.\\\" );\" + LS );\n        writer.write( \"            lineLength = 80;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        if ( indentSize <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().warn( \\\"The parameter 'indentSize' should be positive, using '2' as \"\n            + \"default.\\\" );\" + LS );\n        writer.write( \"            indentSize = 2;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        StringBuffer sb = new StringBuffer();\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        append( sb, \\\"\" + StringUtils.escape( pluginDescriptor.getId() ) + \"\\\", 0 );\" + LS );\n        writer.write( \"        append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( LS );\n\n        if ( StringUtils.isNotEmpty( pluginDescriptor.getName() )\n            && ( pluginDescriptor.getName().indexOf( pluginDescriptor.getId() ) != -1 ) )\n        {\n            writer.write( \"        append( sb, \\\"\"\n                + StringUtils.escape( pluginDescriptor.getName() + \" \" + pluginDescriptor.getVersion() )\n                + \"\\\", 0 );\" + LS );\n        }\n        else\n        {\n            if ( StringUtils.isNotEmpty( pluginDescriptor.getName() ) )\n            {\n                writer.write( \"        append( sb, \\\"\" + StringUtils.escape( pluginDescriptor.getName() )\n                    + \"\\\", 0 );\" + LS );\n            }\n            else\n            {\n                writer.write( \"        append( sb, \\\"\" + StringUtils.escape( pluginDescriptor.getId() )\n                    + \"\\\", 0 );\" + LS );\n            }\n        }\n        writer.write( \"        append( sb, \\\"\" + toDescription( pluginDescriptor.getDescription() ) + \"\\\", 1 );\"\n            + LS );\n        writer.write( \"        append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        if ( goal == null || goal.length() <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            append( sb, \\\"This plugin has \" + mojoDescriptors.size() + \" \"\n            + ( mojoDescriptors.size() > 1 ? \"goals\" : \"goal\" ) + \":\\\", 0 );\" + LS );\n        writer.write( \"            append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( \"        }\" + LS );\n\n        writer.write( LS );\n\n        for ( Iterator<MojoDescriptor> it = mojoDescriptors.iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = it.next();\n\n            writeGoal( writer, descriptor );\n        }\n\n        writer.write( \"        if ( getLog().isInfoEnabled() )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().info( sb.toString() );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param descriptor not null\n     * @throws IOException if any\n     */\n    private static void writeGoal( Writer writer, MojoDescriptor descriptor )\n        throws IOException\n    {\n        String goalDescription = toDescription( descriptor.getDescription() );\n\n        writer.write( \"        if ( goal == null || goal.length() <= 0 || \\\"\"\n            + StringUtils.escape( descriptor.getGoal() ) + \"\\\".equals( goal ) )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            append( sb, \\\"\" + StringUtils.escape( descriptor.getFullGoalName() ) + \"\\\", 0 );\"\n            + LS );\n        if ( StringUtils.isNotEmpty( descriptor.getDeprecated() ) )\n        {\n            writer.write( \"            append( sb, \\\"Deprecated. \" + toDescription( descriptor.getDeprecated() )\n                + \"\\\", 1 );\" + LS );\n            writer.write( \"            if ( detail )\" + LS );\n            writer.write( \"            {\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n            writer.write( \"                append( sb, \\\"\" + goalDescription + \"\\\", 1 );\" + LS );\n            writer.write( \"            }\" + LS );\n        }\n        else\n        {\n            writer.write( \"            append( sb, \\\"\" + goalDescription + \"\\\", 1 );\" + LS );\n        }\n        writer.write( \"            append( sb, \\\"\\\", 0 );\" + LS );\n\n        if ( descriptor.getParameters() != null && descriptor.getParameters().size() > 0 )\n        {\n            @SuppressWarnings( \"unchecked\" )\n            List<Parameter> params = descriptor.getParameters();\n\n            PluginUtils.sortMojoParameters( params );\n\n            writer.write( \"            if ( detail )\" + LS );\n            writer.write( \"            {\" + LS );\n\n            writer.write( \"                append( sb, \\\"Available parameters:\\\", 1 );\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n\n            for ( Parameter parameter : params )\n            {\n                if ( parameter.isEditable() )\n                {\n                    writer.write( LS );\n                    writeParameter( writer, parameter );\n                }\n            }\n\n            writer.write( \"            }\" + LS );\n        }\n\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param parameter not null\n     * @throws IOException if any\n     */\n    private static void writeParameter( Writer writer, Parameter parameter )\n        throws IOException\n    {\n        String expression = parameter.getExpression();\n\n        if ( expression == null || !expression.startsWith( \"${component.\" ) )\n        {\n            String parameterName = StringUtils.escape( parameter.getName() );\n            String parameterDescription = toDescription( parameter.getDescription() );\n            String parameterDefaultValue = \"\";\n            if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) )\n            {\n                parameterDefaultValue = \" (Default: \" + StringUtils.escape( parameter.getDefaultValue() ) + \")\";\n            }\n            writer.write( \"                append( sb, \\\"\" + parameterName + parameterDefaultValue + \"\\\", 2 );\" + LS );\n            if ( StringUtils.isNotEmpty( parameter.getDeprecated() ) )\n            {\n                writer.write( \"                append( sb, \\\"Deprecated. \" + toDescription( parameter.getDeprecated() )\n                    + \"\\\", 3 );\" + LS );\n                writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n            }\n            writer.write( \"                append( sb, \\\"\" + parameterDescription + \"\\\", 3 );\" + LS );\n            if ( parameter.isRequired() )\n            {\n                writer.write( \"                append( sb, \\\"Required: Yes\\\", 3 );\" + LS );\n            }\n            if ( StringUtils.isNotEmpty( parameter.getExpression() ) )\n            {\n                writer.write( \"                append( sb, \\\"Expression: \"\n                    + StringUtils.escape( parameter.getExpression() ) + \"\\\", 3 );\" + LS );\n            }\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n        }\n    }\n\n    /**\n     * @param writer not null\n     * @param useJava5 If the generated code should use Java5 features\n     * @throws IOException if any\n     */\n    private static void writeUtilities( Writer writer, boolean useJava5 )\n        throws IOException\n    {\n        writer.write( \"    /**\" + LS );\n        writer.write( \"     * <p>Repeat a String <code>n<\/code> times to form a new string.<\/p>\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @param str String to repeat\" + LS );\n        writer.write( \"     * @param repeat number of times to repeat str\" + LS );\n        writer.write( \"     * @return String with repeated String\" + LS );\n        writer.write( \"     * @throws NegativeArraySizeException if <code>repeat < 0<\/code>\" + LS );\n        writer.write( \"     * @throws NullPointerException if str is <code>null<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static String repeat( String str, int repeat )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        StringBuffer buffer = new StringBuffer( repeat * str.length() );\" + LS );\n        writer.write( LS );\n        writer.write( \"        for ( int i = 0; i < repeat; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            buffer.append( str );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return buffer.toString();\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Append a description to the buffer by respecting the indentSize and lineLength \"\n            + \"parameters.\" + LS );\n        writer.write( \"     * <b>Note<\/b>: The last character is always a new line.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param sb The buffer to append the description, not <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param description The description, not <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indent The base indentation level of each line, must not be negative.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private void append( StringBuffer sb, String description, int indent )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        for ( Iterator it = toLines( description, indent, indentSize, lineLength )\"\n            + \".iterator(); it.hasNext(); )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            sb.append( it.next().toString() ).append( '\\\\n' );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Splits the specified text into lines of convenient display length.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param text The text to split into lines, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indent The base indentation level of each line, must not be negative.\" + LS );\n        writer.write( \"     * @param indentSize The size of each indentation, must not be negative.\" + LS );\n        writer.write( \"     * @param lineLength The length of the line, must not be negative.\" + LS );\n        writer.write( \"     * @return The sequence of display lines, never <code>null<\/code>.\" + LS );\n        writer.write( \"     * @throws NegativeArraySizeException if <code>indent < 0<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static List toLines( String text, int indent, int indentSize, int lineLength )\"\n            + LS );\n        writer.write( \"    {\" + LS );\n        if ( useJava5 )\n        {\n            writer.write( \"        List<String> lines = new ArrayList<String>();\" + LS );\n        }\n        else\n        {\n            writer.write( \"        List lines = new ArrayList();\" + LS );\n        }\n        writer.write( LS );\n        writer.write( \"        String ind = repeat( \\\"\\\\t\\\", indent );\" + LS );\n        writer.write( \"        String[] plainLines = text.split( \\\"(\\\\r\\\\n)|(\\\\r)|(\\\\n)\\\" );\" + LS );\n        writer.write( \"        for ( int i = 0; i < plainLines.length; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            toLines( lines, ind + plainLines[i], indentSize, lineLength );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return lines;\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Adds the specified line to the output sequence, performing line wrapping if necessary.\"\n            + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param lines The sequence of display lines, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param line The line to add, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indentSize The size of each indentation, must not be negative.\" + LS );\n        writer.write( \"     * @param lineLength The length of the line, must not be negative.\" + LS );\n        writer.write( \"     */\" + LS );\n        if ( useJava5 )\n        {\n            writer.write( \"    private static void toLines( List<String> lines, String line, int indentSize, int lineLength )\"\n                + LS );\n        }\n        else\n        {\n            writer.write( \"    private static void toLines( List lines, String line, int indentSize, int lineLength )\"\n                + LS );\n        }\n        writer.write( \"    {\" + LS );\n        writer.write( \"        int lineIndent = getIndentLevel( line );\" + LS );\n        writer.write( \"        StringBuffer buf = new StringBuffer( 256 );\" + LS );\n        writer.write( \"        String[] tokens = line.split( \\\" +\\\" );\" + LS );\n        writer.write( \"        for ( int i = 0; i < tokens.length; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            String token = tokens[i];\" + LS );\n        writer.write( \"            if ( i > 0 )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                if ( buf.length() + token.length() >= lineLength )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    lines.add( buf.toString() );\" + LS );\n        writer.write( \"                    buf.setLength( 0 );\" + LS );\n        writer.write( \"                    buf.append( repeat( \\\" \\\", lineIndent * indentSize ) );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( ' ' );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"            for ( int j = 0; j < token.length(); j++ )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                char c = token.charAt( j );\" + LS );\n        writer.write( \"                if ( c == '\\\\t' )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( repeat( \\\" \\\", indentSize - buf.length() % indentSize ) );\"\n            + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else if ( c == '\\\\u00A0' )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( ' ' );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( c );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        lines.add( buf.toString() );\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Gets the indentation level of the specified line.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param line The line whose indentation level should be retrieved, must not be \"\n            + \"<code>null<\/code>.\" + LS );\n        writer.write( \"     * @return The indentation level of the line.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static int getIndentLevel( String line )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        int level = 0;\" + LS );\n        writer.write( \"        for ( int i = 0; i < line.length() && line.charAt( i ) == '\\\\t'; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            level++;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        for ( int i = level + 1; i <= level + 4 && i < line.length(); i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            if ( line.charAt( i ) == '\\\\t' )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                level++;\" + LS );\n        writer.write( \"                break;\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        return level;\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    /**\n     * Gets the effective string to use for the plugin/mojo/parameter description.\n     *\n     * @param description The description of the element, may be <code>null<\/code>.\n     * @return The effective description string, never <code>null<\/code>.\n     */\n    private static String toDescription( String description )\n    {\n        if ( StringUtils.isNotEmpty( description ) )\n        {\n            return StringUtils.escape( PluginUtils.toText( description ) );\n        }\n\n        return \"(no description available)\";\n    }\n\n    /**\n     * Converts a HTML fragment as extracted from a javadoc comment to a plain text string. This method tries to retain\n     * as much of the text formatting as possible by means of the following transformations:\n     * <ul>\n     * <li>List items are converted to leading tabs (U+0009), followed by the item number/bullet, another tab and\n     * finally the item contents. Each tab denotes an increase of indentation.<\/li>\n     * <li>Flow breaking elements as well as literal line terminators in preformatted text are converted to a newline\n     * (U+000A) to denote a mandatory line break.<\/li>\n     * <li>Consecutive spaces and line terminators from character data outside of preformatted text will be normalized\n     * to a single space. The resulting space denotes a possible point for line wrapping.<\/li>\n     * <li>Each space in preformatted text will be converted to a non-breaking space (U+00A0).<\/li>\n     * <\/ul>\n     *\n     * @param html The HTML fragment to convert to plain text, may be <code>null<\/code>.\n     * @return A string with HTML tags converted into pure text, never <code>null<\/code>.\n     * @deprecated since 2.4.3, using {@link PluginUtils#toText(String)} instead of.\n     */\n    protected static String toText( String html )\n    {\n        return PluginUtils.toText( html );\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * Generates an <code>HelpMojo<\/code> class.\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    /** Line separator */\n    private static final String LS = System.getProperty( \"line.separator\" );\n\n    /** Default generated class name */\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    /** Default goal */\n    private static final String HELP_GOAL = \"help\";\n\n    private String helpPackageName;\n    \n    /** Flag to indicate if the generated help mojo should use Java 5 features */\n    private boolean useJava5;\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        execute( destinationDirectory, new DefaultPluginToolsRequest( null, pluginDescriptor ) );\n    }\n    \n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginToolsRequest request )\n        throws IOException\n    {\n        PluginDescriptor pluginDescriptor = request.getPluginDescriptor();\n        \n        if ( pluginDescriptor.getMojos() == null || pluginDescriptor.getMojos().size() < 1 )\n        {\n            return;\n        }\n\n        MojoDescriptor helpDescriptor = makeHelpDescriptor( pluginDescriptor );\n\n        // Verify that no help goal already exists\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            if ( descriptor.getGoal().equals( helpDescriptor.getGoal() )\n                && !descriptor.getImplementation().equals( helpDescriptor.getImplementation() ) )\n            {\n                if ( getLogger().isWarnEnabled() )\n                {\n                    getLogger().warn(\n                                      \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                          + \") already exists in this plugin. SKIPPED THE \"\n                                          + helpDescriptor.getImplementation() + \" GENERATION.\\n\" );\n                }\n\n                return;\n            }\n        }\n\n        String sourcePath = helpDescriptor.getImplementation().replace( '.', File.separatorChar ) + \".java\";\n        File helpClass = new File( destinationDirectory, sourcePath );\n        helpClass.getParentFile().mkdirs();\n\n        Writer writer = null;\n        try\n        {\n            writer = new OutputStreamWriter( new FileOutputStream( helpClass ), request.getEncoding() );\n            writeClass( writer, pluginDescriptor, helpDescriptor, useJava5 );\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    public PluginHelpGenerator setHelpPackageName( String helpPackageName )\n    {\n        this.helpPackageName = helpPackageName;\n        return this;\n    }\n\n    public PluginHelpGenerator setUseJava5( boolean useJava5 )\n    {\n        this.useJava5 = useJava5;\n        return this;\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * Creates a minimalistic mojo descriptor for the generated help goal.\n     *\n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *            <code>null<\/code>.\n     * @return The mojo descriptor for the generated help goal, never <code>null<\/code>.\n     */\n    private MojoDescriptor makeHelpDescriptor( PluginDescriptor pluginDescriptor )\n    {\n        MojoDescriptor descriptor = new MojoDescriptor();\n\n        descriptor.setPluginDescriptor( pluginDescriptor );\n\n        descriptor.setLanguage( \"java\" );\n\n        descriptor.setGoal( HELP_GOAL );\n\n        String packageName = helpPackageName;\n        if ( StringUtils.isEmpty( packageName ) )\n        {\n            packageName = discoverPackageName( pluginDescriptor );\n        }\n        if ( StringUtils.isNotEmpty( packageName ) )\n        {\n            descriptor.setImplementation( packageName + '.' + HELP_MOJO_CLASS_NAME );\n        }\n        else\n        {\n            descriptor.setImplementation( HELP_MOJO_CLASS_NAME );\n        }\n\n        descriptor.setDescription( \"Display help information on \" + pluginDescriptor.getArtifactId()\n            + \".<br/> Call <pre>  mvn \" + descriptor.getFullGoalName()\n            + \" -Ddetail=true -Dgoal=&lt;goal-name&gt;<\/pre> to display parameter details.\" );\n\n        try\n        {\n            Parameter param = new Parameter();\n            param.setName( \"detail\" );\n            param.setType( \"boolean\" );\n            param.setDescription( \"If <code>true<\/code>, display all settable properties for each goal.\" );\n            param.setDefaultValue( \"false\" );\n            param.setExpression( \"${detail}\" );\n            descriptor.addParameter( param );\n\n            param = new Parameter();\n            param.setName( \"goal\" );\n            param.setType( \"java.lang.String\" );\n            param.setDescription( \"The name of the goal for which to show help.\"\n                + \" If unspecified, all goals will be displayed.\" );\n            param.setExpression( \"${goal}\" );\n            descriptor.addParameter( param );\n\n            param = new Parameter();\n            param.setName( \"lineLength\" );\n            param.setType( \"int\" );\n            param.setDescription( \"The maximum length of a display line, should be positive.\" );\n            param.setDefaultValue( \"80\" );\n            param.setExpression( \"${lineLength}\" );\n            descriptor.addParameter( param );\n\n            param = new Parameter();\n            param.setName( \"indentSize\" );\n            param.setType( \"int\" );\n            param.setDescription( \"The number of spaces per indentation level, should be positive.\" );\n            param.setDefaultValue( \"2\" );\n            param.setExpression( \"${indentSize}\" );\n            descriptor.addParameter( param );\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( \"Failed to setup parameters for help goal\", e );\n        }\n\n        return descriptor;\n    }\n\n    /**\n     * Find the best package name, based on the number of hits of actual Mojo classes.\n     *\n     * @param pluginDescriptor not null\n     * @return the best name of the package for the generated mojo\n     */\n    private static String discoverPackageName( PluginDescriptor pluginDescriptor )\n    {\n        Map packageNames = new HashMap();\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            String impl = descriptor.getImplementation();\n            if ( impl.lastIndexOf( '.' ) != -1 )\n            {\n                String name = impl.substring( 0, impl.lastIndexOf( '.' ) );\n                if ( packageNames.get( name ) != null )\n                {\n                    int next = ( (Integer) packageNames.get( name ) ).intValue() + 1;\n                    packageNames.put( name, new Integer( next ) );\n                }\n                else\n                {\n                    packageNames.put( name, new Integer( 1 ) );\n                }\n            }\n            else\n            {\n                packageNames.put( \"\", new Integer( 1 ) );\n            }\n        }\n\n        String packageName = \"\";\n        int max = 0;\n        for ( Iterator it = packageNames.keySet().iterator(); it.hasNext(); )\n        {\n            String key = it.next().toString();\n            int value = ( (Integer) packageNames.get( key ) ).intValue();\n            if ( value > max )\n            {\n                max = value;\n                packageName = key;\n            }\n        }\n\n        return packageName;\n    }\n\n    /**\n     * Generates the <code>HelpMojo<\/code> class.\n     *\n     * @param writer not null\n     * @param pluginDescriptor not null\n     * @param helpDescriptor not null\n     * @param useJava5 If the generated code should use Java5 features\n     * @throws IOException if any\n     */\n    private static void writeClass( Writer writer, PluginDescriptor pluginDescriptor, MojoDescriptor helpDescriptor,\n                                    boolean useJava5 )\n        throws IOException\n    {\n        String packageName = \"\";\n        String simpleName = helpDescriptor.getImplementation();\n        int dot = simpleName.lastIndexOf( '.' );\n        if ( dot >= 0 )\n        {\n            packageName = simpleName.substring( 0, dot );\n            simpleName = simpleName.substring( dot + 1 );\n        }\n\n        if ( packageName.length() > 0 )\n        {\n            writer.write( \"package \" + packageName + \";\" + LS );\n            writer.write( LS );\n        }\n\n        writeImports( writer );\n        writer.write( LS );\n\n        writeMojoJavadoc( writer, pluginDescriptor, helpDescriptor );\n\n        if ( useJava5 )\n        {\n            writer.write( \"@SuppressWarnings( \\\"all\\\" )\" + LS );\n        }\n\n        writer.write( \"public class \" + simpleName + LS );\n        writer.write( \"    extends AbstractMojo\" + LS );\n        writer.write( \"{\" + LS );\n\n        writeVariables( writer, helpDescriptor );\n\n        writer.write( LS );\n\n        writeExecute( writer, pluginDescriptor, helpDescriptor );\n\n        writer.write( LS );\n        writeUtilities( writer, useJava5 );\n        writer.write( \"}\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @throws IOException if any\n     */\n    private static void writeImports( Writer writer )\n        throws IOException\n    {\n        writer.write( \"import java.util.ArrayList;\" + LS );\n        writer.write( \"import java.util.Iterator;\" + LS );\n        writer.write( \"import java.util.List;\" + LS );\n        writer.write( LS );\n        writer.write( \"import org.apache.maven.plugin.AbstractMojo;\" + LS );\n        writer.write( \"import org.apache.maven.plugin.MojoExecutionException;\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param pluginDescriptor not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeMojoJavadoc( Writer writer, PluginDescriptor pluginDescriptor,\n                                          MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        StringBuffer author = new StringBuffer();\n        author.append( PluginHelpGenerator.class.getName() );\n\n        String resource = \"META-INF/maven/org.apache.maven.plugin-tools/maven-plugin-tools-api/pom.properties\";\n        InputStream resourceAsStream = PluginHelpGenerator.class.getClassLoader().getResourceAsStream( resource );\n\n        if ( resourceAsStream != null )\n        {\n            try\n            {\n                Properties properties = new Properties();\n                properties.load( resourceAsStream );\n\n                author.append( \" (version \" ).append( properties.getProperty( \"version\", \"unknown\" ) ).append( \")\" );\n            }\n            catch ( IOException e )\n            {\n                // nope\n            }\n        }\n\n        writer.write( \"/**\" + LS );\n        writer.write( \" * \" + helpDescriptor.getDescription() + LS );\n        writer.write( \" *\" + LS );\n        writer.write( \" * @version generated on \" + new Date() + LS );\n        writer.write( \" * @author \" + author.toString() + LS );\n        writer.write( \" * @goal \" + helpDescriptor.getGoal() + LS );\n        writer.write( \" * @requiresProject false\" + LS );\n        writer.write( \" * @threadSafe\" + LS );\n        writer.write( \" */\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeVariables( Writer writer, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        for ( Iterator it = helpDescriptor.getParameters().iterator(); it.hasNext(); )\n        {\n            Parameter param = (Parameter) it.next();\n            writer.write( \"    /**\" + LS );\n            writer.write( \"     * \" + StringUtils.escape( param.getDescription() ) + LS );\n            writer.write( \"     * \" + LS );\n            writer.write( \"     * @parameter\" );\n            if ( StringUtils.isNotEmpty( param.getExpression() ) )\n            {\n                writer.write( \" expression=\\\"\" );\n                writer.write( StringUtils.escape( param.getExpression() ) );\n                writer.write( \"\\\"\" );\n            }\n            if ( StringUtils.isNotEmpty( param.getDefaultValue() ) )\n            {\n                writer.write( \" default-value=\\\"\" );\n                writer.write( StringUtils.escape( param.getDefaultValue() ) );\n                writer.write( \"\\\"\" );\n            }\n            writer.write( LS );\n            writer.write( \"     */\" + LS );\n            writer.write( \"    private \" + param.getType() + \" \" + param.getName() + \";\" + LS );\n            writer.write( LS );\n        }\n    }\n\n    /**\n     * @param writer not null\n     * @param pluginDescriptor not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeExecute( Writer writer, PluginDescriptor pluginDescriptor, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        List mojoDescriptors = new ArrayList();\n\n        mojoDescriptors.add( helpDescriptor );\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor mojoDescriptor = (MojoDescriptor) it.next();\n\n            if ( !helpDescriptor.getGoal().equals( mojoDescriptor.getGoal() ) )\n            {\n                mojoDescriptors.add( mojoDescriptor );\n            }\n        }\n\n        PluginUtils.sortMojos( mojoDescriptors );\n\n        writer.write( \"    /** {@inheritDoc} */\" + LS );\n        writer.write( \"    public void execute()\" + LS );\n        writer.write( \"        throws MojoExecutionException\" + LS );\n        writer.write( \"    {\" + LS );\n\n        writer.write( \"        if ( lineLength <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().warn( \\\"The parameter 'lineLength' should be positive, using '80' as \"\n            + \"default.\\\" );\" + LS );\n        writer.write( \"            lineLength = 80;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        if ( indentSize <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().warn( \\\"The parameter 'indentSize' should be positive, using '2' as \"\n            + \"default.\\\" );\" + LS );\n        writer.write( \"            indentSize = 2;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        StringBuffer sb = new StringBuffer();\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        append( sb, \\\"\" + StringUtils.escape( pluginDescriptor.getId() ) + \"\\\", 0 );\" + LS );\n        writer.write( \"        append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( LS );\n\n        if ( StringUtils.isNotEmpty( pluginDescriptor.getName() )\n            && ( pluginDescriptor.getName().indexOf( pluginDescriptor.getId() ) != -1 ) )\n        {\n            writer.write( \"        append( sb, \\\"\"\n                + StringUtils.escape( pluginDescriptor.getName() + \" \" + pluginDescriptor.getVersion() )\n                + \"\\\", 0 );\" + LS );\n        }\n        else\n        {\n            if ( StringUtils.isNotEmpty( pluginDescriptor.getName() ) )\n            {\n                writer.write( \"        append( sb, \\\"\" + StringUtils.escape( pluginDescriptor.getName() )\n                    + \"\\\", 0 );\" + LS );\n            }\n            else\n            {\n                writer.write( \"        append( sb, \\\"\" + StringUtils.escape( pluginDescriptor.getId() )\n                    + \"\\\", 0 );\" + LS );\n            }\n        }\n        writer.write( \"        append( sb, \\\"\" + toDescription( pluginDescriptor.getDescription() ) + \"\\\", 1 );\"\n            + LS );\n        writer.write( \"        append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        if ( goal == null || goal.length() <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            append( sb, \\\"This plugin has \" + mojoDescriptors.size() + \" \"\n            + ( mojoDescriptors.size() > 1 ? \"goals\" : \"goal\" ) + \":\\\", 0 );\" + LS );\n        writer.write( \"            append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( \"        }\" + LS );\n\n        writer.write( LS );\n\n        for ( Iterator it = mojoDescriptors.iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            writeGoal( writer, descriptor );\n        }\n\n        writer.write( \"        if ( getLog().isInfoEnabled() )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().info( sb.toString() );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param descriptor not null\n     * @throws IOException if any\n     */\n    private static void writeGoal( Writer writer, MojoDescriptor descriptor )\n        throws IOException\n    {\n        String goalDescription = toDescription( descriptor.getDescription() );\n\n        writer.write( \"        if ( goal == null || goal.length() <= 0 || \\\"\"\n            + StringUtils.escape( descriptor.getGoal() ) + \"\\\".equals( goal ) )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            append( sb, \\\"\" + StringUtils.escape( descriptor.getFullGoalName() ) + \"\\\", 0 );\"\n            + LS );\n        if ( StringUtils.isNotEmpty( descriptor.getDeprecated() ) )\n        {\n            writer.write( \"            append( sb, \\\"Deprecated. \" + toDescription( descriptor.getDeprecated() )\n                + \"\\\", 1 );\" + LS );\n            writer.write( \"            if ( detail )\" + LS );\n            writer.write( \"            {\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n            writer.write( \"                append( sb, \\\"\" + goalDescription + \"\\\", 1 );\" + LS );\n            writer.write( \"            }\" + LS );\n        }\n        else\n        {\n            writer.write( \"            append( sb, \\\"\" + goalDescription + \"\\\", 1 );\" + LS );\n        }\n        writer.write( \"            append( sb, \\\"\\\", 0 );\" + LS );\n\n        if ( descriptor.getParameters() != null && descriptor.getParameters().size() > 0 )\n        {\n            List params = descriptor.getParameters();\n\n            PluginUtils.sortMojoParameters( params );\n\n            writer.write( \"            if ( detail )\" + LS );\n            writer.write( \"            {\" + LS );\n\n            writer.write( \"                append( sb, \\\"Available parameters:\\\", 1 );\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n\n            for ( Iterator it = params.iterator(); it.hasNext(); )\n            {\n                Parameter parameter = (Parameter) it.next();\n\n                if ( parameter.isEditable() )\n                {\n                    writer.write( LS );\n                    writeParameter( writer, parameter );\n                }\n            }\n\n            writer.write( \"            }\" + LS );\n        }\n\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param parameter not null\n     * @throws IOException if any\n     */\n    private static void writeParameter( Writer writer, Parameter parameter )\n        throws IOException\n    {\n        String expression = parameter.getExpression();\n\n        if ( expression == null || !expression.startsWith( \"${component.\" ) )\n        {\n            String parameterName = StringUtils.escape( parameter.getName() );\n            String parameterDescription = toDescription( parameter.getDescription() );\n            String parameterDefaultValue = \"\";\n            if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) )\n            {\n                parameterDefaultValue = \" (Default: \" + StringUtils.escape( parameter.getDefaultValue() ) + \")\";\n            }\n            writer.write( \"                append( sb, \\\"\" + parameterName + parameterDefaultValue + \"\\\", 2 );\" + LS );\n            if ( StringUtils.isNotEmpty( parameter.getDeprecated() ) )\n            {\n                writer.write( \"                append( sb, \\\"Deprecated. \" + toDescription( parameter.getDeprecated() )\n                    + \"\\\", 3 );\" + LS );\n                writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n            }\n            writer.write( \"                append( sb, \\\"\" + parameterDescription + \"\\\", 3 );\" + LS );\n            if ( parameter.isRequired() )\n            {\n                writer.write( \"                append( sb, \\\"Required: Yes\\\", 3 );\" + LS );\n            }\n            if ( StringUtils.isNotEmpty( parameter.getExpression() ) )\n            {\n                writer.write( \"                append( sb, \\\"Expression: \"\n                    + StringUtils.escape( parameter.getExpression() ) + \"\\\", 3 );\" + LS );\n            }\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n        }\n    }\n\n    /**\n     * @param writer not null\n     * @param useJava5 If the generated code should use Java5 features\n     * @throws IOException if any\n     */\n    private static void writeUtilities( Writer writer, boolean useJava5 )\n        throws IOException\n    {\n        writer.write( \"    /**\" + LS );\n        writer.write( \"     * <p>Repeat a String <code>n<\/code> times to form a new string.<\/p>\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @param str String to repeat\" + LS );\n        writer.write( \"     * @param repeat number of times to repeat str\" + LS );\n        writer.write( \"     * @return String with repeated String\" + LS );\n        writer.write( \"     * @throws NegativeArraySizeException if <code>repeat < 0<\/code>\" + LS );\n        writer.write( \"     * @throws NullPointerException if str is <code>null<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static String repeat( String str, int repeat )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        StringBuffer buffer = new StringBuffer( repeat * str.length() );\" + LS );\n        writer.write( LS );\n        writer.write( \"        for ( int i = 0; i < repeat; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            buffer.append( str );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return buffer.toString();\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Append a description to the buffer by respecting the indentSize and lineLength \"\n            + \"parameters.\" + LS );\n        writer.write( \"     * <b>Note<\/b>: The last character is always a new line.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param sb The buffer to append the description, not <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param description The description, not <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indent The base indentation level of each line, must not be negative.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private void append( StringBuffer sb, String description, int indent )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        for ( Iterator it = toLines( description, indent, indentSize, lineLength )\"\n            + \".iterator(); it.hasNext(); )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            sb.append( it.next().toString() ).append( '\\\\n' );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Splits the specified text into lines of convenient display length.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param text The text to split into lines, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indent The base indentation level of each line, must not be negative.\" + LS );\n        writer.write( \"     * @param indentSize The size of each indentation, must not be negative.\" + LS );\n        writer.write( \"     * @param lineLength The length of the line, must not be negative.\" + LS );\n        writer.write( \"     * @return The sequence of display lines, never <code>null<\/code>.\" + LS );\n        writer.write( \"     * @throws NegativeArraySizeException if <code>indent < 0<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static List toLines( String text, int indent, int indentSize, int lineLength )\"\n            + LS );\n        writer.write( \"    {\" + LS );\n        if ( useJava5 )\n        {\n            writer.write( \"        List<String> lines = new ArrayList<String>();\" + LS );\n        }\n        else\n        {\n            writer.write( \"        List lines = new ArrayList();\" + LS );\n        }\n        writer.write( LS );\n        writer.write( \"        String ind = repeat( \\\"\\\\t\\\", indent );\" + LS );\n        writer.write( \"        String[] plainLines = text.split( \\\"(\\\\r\\\\n)|(\\\\r)|(\\\\n)\\\" );\" + LS );\n        writer.write( \"        for ( int i = 0; i < plainLines.length; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            toLines( lines, ind + plainLines[i], indentSize, lineLength );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return lines;\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Adds the specified line to the output sequence, performing line wrapping if necessary.\"\n            + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param lines The sequence of display lines, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param line The line to add, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indentSize The size of each indentation, must not be negative.\" + LS );\n        writer.write( \"     * @param lineLength The length of the line, must not be negative.\" + LS );\n        writer.write( \"     */\" + LS );\n        if ( useJava5 )\n        {\n            writer.write( \"    private static void toLines( List<String> lines, String line, int indentSize, int lineLength )\"\n                + LS );\n        }\n        else\n        {\n            writer.write( \"    private static void toLines( List lines, String line, int indentSize, int lineLength )\"\n                + LS );\n        }\n        writer.write( \"    {\" + LS );\n        writer.write( \"        int lineIndent = getIndentLevel( line );\" + LS );\n        writer.write( \"        StringBuffer buf = new StringBuffer( 256 );\" + LS );\n        writer.write( \"        String[] tokens = line.split( \\\" +\\\" );\" + LS );\n        writer.write( \"        for ( int i = 0; i < tokens.length; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            String token = tokens[i];\" + LS );\n        writer.write( \"            if ( i > 0 )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                if ( buf.length() + token.length() >= lineLength )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    lines.add( buf.toString() );\" + LS );\n        writer.write( \"                    buf.setLength( 0 );\" + LS );\n        writer.write( \"                    buf.append( repeat( \\\" \\\", lineIndent * indentSize ) );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( ' ' );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"            for ( int j = 0; j < token.length(); j++ )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                char c = token.charAt( j );\" + LS );\n        writer.write( \"                if ( c == '\\\\t' )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( repeat( \\\" \\\", indentSize - buf.length() % indentSize ) );\"\n            + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else if ( c == '\\\\u00A0' )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( ' ' );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( c );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        lines.add( buf.toString() );\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Gets the indentation level of the specified line.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param line The line whose indentation level should be retrieved, must not be \"\n            + \"<code>null<\/code>.\" + LS );\n        writer.write( \"     * @return The indentation level of the line.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static int getIndentLevel( String line )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        int level = 0;\" + LS );\n        writer.write( \"        for ( int i = 0; i < line.length() && line.charAt( i ) == '\\\\t'; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            level++;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        for ( int i = level + 1; i <= level + 4 && i < line.length(); i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            if ( line.charAt( i ) == '\\\\t' )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                level++;\" + LS );\n        writer.write( \"                break;\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        return level;\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    /**\n     * Gets the effective string to use for the plugin/mojo/parameter description.\n     *\n     * @param description The description of the element, may be <code>null<\/code>.\n     * @return The effective description string, never <code>null<\/code>.\n     */\n    private static String toDescription( String description )\n    {\n        if ( StringUtils.isNotEmpty( description ) )\n        {\n            return StringUtils.escape( PluginUtils.toText( description ) );\n        }\n\n        return \"(no description available)\";\n    }\n\n    /**\n     * Converts a HTML fragment as extracted from a javadoc comment to a plain text string. This method tries to retain\n     * as much of the text formatting as possible by means of the following transformations:\n     * <ul>\n     * <li>List items are converted to leading tabs (U+0009), followed by the item number/bullet, another tab and\n     * finally the item contents. Each tab denotes an increase of indentation.<\/li>\n     * <li>Flow breaking elements as well as literal line terminators in preformatted text are converted to a newline\n     * (U+000A) to denote a mandatory line break.<\/li>\n     * <li>Consecutive spaces and line terminators from character data outside of preformatted text will be normalized\n     * to a single space. The resulting space denotes a possible point for line wrapping.<\/li>\n     * <li>Each space in preformatted text will be converted to a non-breaking space (U+00A0).<\/li>\n     * <\/ul>\n     *\n     * @param html The HTML fragment to convert to plain text, may be <code>null<\/code>.\n     * @return A string with HTML tags converted into pure text, never <code>null<\/code>.\n     * @deprecated since 2.4.3, using {@link PluginUtils#toText(String)} instead of.\n     */\n    protected static String toText( String html )\n    {\n        return PluginUtils.toText( html );\n    }\n}\n","lineNo":517}
{"Refactored Sample":"package org.apache.maven.plugin.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.generator.Generator;\nimport org.apache.maven.tools.plugin.scanner.MojoScanner;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.util.ReaderFactory;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Set;\n\n/**\n * Abstract class for this Plugin.\n *\n * @author <a href=\"mailto:jason@maven.org\">Jason van Zyl<\/a>\n * @version $Id$\n */\npublic abstract class AbstractGeneratorMojo\n    extends AbstractMojo\n{\n    /**\n     * The project currently being built.\n     *\n     * @parameter default-value=\"${project}\"\n     * @required\n     * @readonly\n     */\n    protected MavenProject project;\n\n    /**\n     * The component used for scanning the source tree for mojos.\n     *\n     * @component\n     * @required\n     */\n    protected MojoScanner mojoScanner;\n\n    /**\n     * The file encoding of the source files.\n     * \n     * @parameter expression=\"${encoding}\" default-value=\"${project.build.sourceEncoding}\"\n     * @since 2.5\n     */\n    protected String encoding;\n\n    /**\n     * The goal prefix that will appear before the \":\".\n     *\n     * @parameter\n     */\n    protected String goalPrefix;\n\n    /**\n     * The role names of mojo extractors to use.\n     * <p/>\n     * If not set, all mojo extractors will be used. If set to an empty extractor name, no mojo extractors\n     * will be used.\n     * <p/>\n     * Example:\n     * <p/>\n     * <pre>\n     *  &lt;!-- Use all mojo extractors --&gt;\n     *  &lt;extractors/&gt;\n     *  \n     *  &lt;!-- Use no mojo extractors --&gt;\n     *  &lt;extractors&gt;\n     *      &lt;extractor/&gt;\n     *  &lt;/extractors&gt;\n     *  \n     *  &lt;!-- Use only bsh mojo extractor --&gt;\n     *  &lt;extractors&gt;\n     *      &lt;extractor&gt;bsh&lt;/extractor&gt;\n     *  &lt;/extractors&gt;\n     * <\/pre>\n     *\n     * @parameter\n     */\n    protected Set/* <String> */extractors;\n\n    /**\n     * @return the output directory where files will be generated.\n     */\n    protected abstract File getOutputDirectory();\n\n    /**\n     * @return the wanted <code>Generator<\/code> implementation.\n     */\n    protected abstract Generator createGenerator();\n\n    /** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !\"maven-plugin\".equals( project.getPackaging() ) )\n        {\n            return;\n        }\n\n        String defaultGoalPrefix = PluginDescriptor.getGoalPrefixFromArtifactId( project.getArtifactId() );\n        if ( goalPrefix == null )\n        {\n            goalPrefix = defaultGoalPrefix;\n        }\n        else if ( !goalPrefix.equals( defaultGoalPrefix ) )\n        {\n            getLog().warn(\n                           \"\\n\\nGoal prefix is specified as: '\" + goalPrefix + \"'. \"\n                               + \"Maven currently expects it to be '\" + defaultGoalPrefix + \"'.\\n\" );\n        }\n\n        mojoScanner.setActiveExtractors( extractors );\n\n        // TODO: could use this more, eg in the writing of the plugin descriptor!\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.setGroupId( project.getGroupId() );\n\n        pluginDescriptor.setArtifactId( project.getArtifactId() );\n\n        pluginDescriptor.setVersion( project.getVersion() );\n\n        pluginDescriptor.setGoalPrefix( goalPrefix );\n\n        pluginDescriptor.setName( project.getName() );\n\n        pluginDescriptor.setDescription( project.getDescription() );\n\n        if ( encoding == null || encoding.length() < 1 )\n        {\n            getLog().warn( \"Using platform encoding (\" + ReaderFactory.FILE_ENCODING\n                                  + \" actually) to read mojo metadata, i.e. build is platform dependent!\" );\n        }\n        else\n        {\n            getLog().info( \"Using '\" + encoding + \"' encoding to read mojo metadata.\" );\n        }\n        \n        try\n        {\n            pluginDescriptor.setDependencies( PluginUtils.toComponentDependencies( project.getRuntimeDependencies() ) );\n            \n            PluginToolsRequest request = new DefaultPluginToolsRequest( project, pluginDescriptor );\n            request.setEncoding( encoding );\n\n            mojoScanner.populatePluginDescriptor( request );\n\n            getOutputDirectory().mkdirs();\n\n            createGenerator().execute( getOutputDirectory(), request );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error writing plugin descriptor\", e );\n        }\n        catch ( InvalidPluginDescriptorException e )\n        {\n            throw new MojoExecutionException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                              e );\n        }\n        catch ( ExtractionException e )\n        {\n            throw new MojoExecutionException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                              e );\n        }\n        catch ( LinkageError e )\n        {\n            throw new MojoExecutionException( \"The API of the mojo scanner is not compatible with this plugin version.\"\n                + \" Please check the plugin dependencies configured in the POM and ensure the versions match.\", e );\n        }\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.plugin.plugin;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.apache.maven.tools.plugin.generator.Generator;\nimport org.apache.maven.tools.plugin.scanner.MojoScanner;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.util.ReaderFactory;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Set;\n\n/**\n * Abstract class for this Plugin.\n *\n * @author <a href=\"mailto:jason@maven.org\">Jason van Zyl<\/a>\n * @version $Id$\n */\npublic abstract class AbstractGeneratorMojo\n    extends AbstractMojo\n{\n    /**\n     * The project currently being built.\n     *\n     * @parameter default-value=\"${project}\"\n     * @required\n     * @readonly\n     */\n    protected MavenProject project;\n\n    /**\n     * The component used for scanning the source tree for mojos.\n     *\n     * @component\n     * @required\n     */\n    protected MojoScanner mojoScanner;\n\n    /**\n     * The file encoding of the source files.\n     * \n     * @parameter expression=\"${encoding}\" default-value=\"${project.build.sourceEncoding}\"\n     * @since 2.5\n     */\n    protected String encoding;\n\n    /**\n     * The goal prefix that will appear before the \":\".\n     *\n     * @parameter\n     */\n    protected String goalPrefix;\n\n    /**\n     * The role names of mojo extractors to use.\n     * <p/>\n     * If not set, all mojo extractors will be used. If set to an empty extractor name, no mojo extractors\n     * will be used.\n     * <p/>\n     * Example:\n     * <p/>\n     * <pre>\n     *  &lt;!-- Use all mojo extractors --&gt;\n     *  &lt;extractors/&gt;\n     *  \n     *  &lt;!-- Use no mojo extractors --&gt;\n     *  &lt;extractors&gt;\n     *      &lt;extractor/&gt;\n     *  &lt;/extractors&gt;\n     *  \n     *  &lt;!-- Use only bsh mojo extractor --&gt;\n     *  &lt;extractors&gt;\n     *      &lt;extractor&gt;bsh&lt;/extractor&gt;\n     *  &lt;/extractors&gt;\n     * <\/pre>\n     *\n     * @parameter\n     */\n    protected Set/* <String> */extractors;\n\n    /**\n     * @return the output directory where files will be generated.\n     */\n    protected abstract File getOutputDirectory();\n\n    /**\n     * @return the wanted <code>Generator<\/code> implementation.\n     */\n    protected abstract Generator createGenerator();\n\n    /** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !\"maven-plugin\".equals( project.getPackaging() ) )\n        {\n            return;\n        }\n\n        String defaultGoalPrefix = PluginDescriptor.getGoalPrefixFromArtifactId( project.getArtifactId() );\n        if ( goalPrefix == null )\n        {\n            goalPrefix = defaultGoalPrefix;\n        }\n        else if ( !goalPrefix.equals( defaultGoalPrefix ) )\n        {\n            getLog().warn(\n                           \"\\n\\nGoal prefix is specified as: '\" + goalPrefix + \"'. \"\n                               + \"Maven currently expects it to be '\" + defaultGoalPrefix + \"'.\\n\" );\n        }\n\n        mojoScanner.setActiveExtractors( extractors );\n\n        // TODO: could use this more, eg in the writing of the plugin descriptor!\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.setGroupId( project.getGroupId() );\n\n        pluginDescriptor.setArtifactId( project.getArtifactId() );\n\n        pluginDescriptor.setVersion( project.getVersion() );\n\n        pluginDescriptor.setGoalPrefix( goalPrefix );\n\n        pluginDescriptor.setName( project.getName() );\n\n        pluginDescriptor.setDescription( project.getDescription() );\n\n        if ( encoding == null || encoding.length() < 1 )\n        {\n            getLog().warn( \"Using platform encoding (\" + ReaderFactory.FILE_ENCODING\n                                  + \" actually) to read mojo metadata, i.e. build is platform dependent!\" );\n        }\n        else\n        {\n            getLog().info( \"Using '\" + encoding + \"' encoding to read mojo metadata.\" );\n        }\n        \n        try\n        {\n            pluginDescriptor.setDependencies( PluginUtils.toComponentDependencies( project.getRuntimeDependencies() ) );\n            \n            PluginToolsRequest request = new DefaultPluginToolsRequest( project, pluginDescriptor ).setEncoding( encoding );\n\n            mojoScanner.populatePluginDescriptor( request );\n\n            getOutputDirectory().mkdirs();\n\n            createGenerator().execute( getOutputDirectory(), request );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error writing plugin descriptor\", e );\n        }\n        catch ( InvalidPluginDescriptorException e )\n        {\n            throw new MojoExecutionException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                              e );\n        }\n        catch ( ExtractionException e )\n        {\n            throw new MojoExecutionException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\",\n                                              e );\n        }\n        catch ( LinkageError e )\n        {\n            throw new MojoExecutionException( \"The API of the mojo scanner is not compatible with this plugin version.\"\n                + \" Please check the plugin dependencies configured in the POM and ensure the versions match.\", e );\n        }\n    }\n\n}\n","lineNo":169}
{"Refactored Sample":"package org.apache.maven.tools.plugin.extractor.java;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport com.thoughtworks.qdox.JavaDocBuilder;\nimport com.thoughtworks.qdox.model.DocletTag;\nimport com.thoughtworks.qdox.model.JavaClass;\nimport com.thoughtworks.qdox.model.JavaField;\nimport com.thoughtworks.qdox.model.Type;\n\nimport org.apache.maven.plugin.descriptor.InvalidParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\n\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\n/**\n * Extracts Mojo descriptors from <a href=\"http://java.sun.com/\">Java<\/a> sources.\n * <br/>\n * For more information about the usage tag, have a look to:\n * <a href=\"http://maven.apache.org/developers/mojo-api-specification.html\">\n * http://maven.apache.org/developers/mojo-api-specification.html<\/a>\n *\n * @todo need to add validation directives so that systems embedding maven2 can\n * get validation directives to help users in IDEs.\n * @version $Id$\n * @see org.apache.maven.plugin.descriptor.MojoDescriptor\n */\npublic class JavaMojoDescriptorExtractor\n    extends AbstractLogEnabled\n    implements MojoDescriptorExtractor, JavaMojoAnnotation\n{\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#INSTANTIATION_STRATEGY} instead of. */\n    public static final String MAVEN_PLUGIN_INSTANTIATION = JavaMojoAnnotation.INSTANTIATION_STRATEGY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#CONFIGURATOR} instead of. */\n    public static final String CONFIGURATOR = JavaMojoAnnotation.CONFIGURATOR;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER} instead of. */\n    public static final String PARAMETER = JavaMojoAnnotation.PARAMETER;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_EXPRESSION} instead of. */\n    public static final String PARAMETER_EXPRESSION = JavaMojoAnnotation.PARAMETER_EXPRESSION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_DEFAULT_VALUE} instead of. */\n    public static final String PARAMETER_DEFAULT_VALUE = JavaMojoAnnotation.PARAMETER_DEFAULT_VALUE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_ALIAS} instead of. */\n    public static final String PARAMETER_ALIAS = JavaMojoAnnotation.PARAMETER_ALIAS;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#SINCE} instead of. */\n    public static final String SINCE = JavaMojoAnnotation.SINCE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_IMPLEMENTATION} instead of. */\n    public static final String PARAMETER_IMPLEMENTATION = JavaMojoAnnotation.PARAMETER_IMPLEMENTATION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_PROPERTY} instead of. */\n    public static final String PARAMETER_PROPERTY = JavaMojoAnnotation.PARAMETER_PROPERTY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRED} instead of. */\n    public static final String REQUIRED = JavaMojoAnnotation.REQUIRED;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#DEPRECATED} instead of. */\n    public static final String DEPRECATED = JavaMojoAnnotation.DEPRECATED;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#READONLY} instead of. */\n    public static final String READONLY = JavaMojoAnnotation.READONLY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#GOAL} instead of. */\n    public static final String GOAL = JavaMojoAnnotation.GOAL;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PHASE} instead of. */\n    public static final String PHASE = JavaMojoAnnotation.PHASE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE} instead of. */\n    public static final String EXECUTE = JavaMojoAnnotation.EXECUTE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE_LIFECYCLE} instead of. */\n    public static final String EXECUTE_LIFECYCLE = JavaMojoAnnotation.EXECUTE_LIFECYCLE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE_PHASE} instead of. */\n    public static final String EXECUTE_PHASE = JavaMojoAnnotation.EXECUTE_PHASE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE_GOAL} instead of. */\n    public static final String EXECUTE_GOAL = JavaMojoAnnotation.EXECUTE_GOAL;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#DESCRIPTION} instead of. */\n    public static final String GOAL_DESCRIPTION = JavaMojoAnnotation.DESCRIPTION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_DEPENDENCY_RESOLUTION} instead of. */\n    public static final String GOAL_REQUIRES_DEPENDENCY_RESOLUTION = JavaMojoAnnotation.REQUIRES_DEPENDENCY_RESOLUTION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_PROJECT} instead of. */\n    public static final String GOAL_REQUIRES_PROJECT = JavaMojoAnnotation.REQUIRES_PROJECT;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_REPORTS} instead of. */\n    public static final String GOAL_REQUIRES_REPORTS = JavaMojoAnnotation.REQUIRES_REPORTS;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#AGGREGATOR} instead of. */\n    public static final String GOAL_IS_AGGREGATOR = JavaMojoAnnotation.AGGREGATOR;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_ONLINE} instead of. */\n    public static final String GOAL_REQUIRES_ONLINE = JavaMojoAnnotation.REQUIRES_ONLINE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#INHERIT_BY_DEFAULT} instead of. */\n    public static final String GOAL_INHERIT_BY_DEFAULT = JavaMojoAnnotation.INHERIT_BY_DEFAULT;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#MULTI_EXECUTION_STRATEGY} instead of. */\n    public static final String GOAL_MULTI_EXECUTION_STRATEGY = JavaMojoAnnotation.MULTI_EXECUTION_STRATEGY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_DIRECT_INVOCATION} instead of. */\n    public static final String GOAL_REQUIRES_DIRECT_INVOCATION = JavaMojoAnnotation.REQUIRES_DIRECT_INVOCATION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#COMPONENT} instead of. */\n    public static final String COMPONENT = JavaMojoAnnotation.COMPONENT;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#COMPONENT_ROLE} instead of. */\n    public static final String COMPONENT_ROLE = JavaMojoAnnotation.COMPONENT_ROLE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#COMPONENT_ROLEHINT} instead of. */\n    public static final String COMPONENT_ROLEHINT = JavaMojoAnnotation.COMPONENT_ROLEHINT;\n\n    /**\n     * @param parameter not null\n     * @param i positive number\n     * @throws InvalidParameterException if any\n     */\n    protected void validateParameter( Parameter parameter, int i )\n        throws InvalidParameterException\n    {\n        // TODO: remove when backward compatibility is no longer an issue.\n        String name = parameter.getName();\n\n        if ( name == null )\n        {\n            throw new InvalidParameterException( \"name\", i );\n        }\n\n        // TODO: remove when backward compatibility is no longer an issue.\n        String type = parameter.getType();\n\n        if ( type == null )\n        {\n            throw new InvalidParameterException( \"type\", i );\n        }\n\n        // TODO: remove when backward compatibility is no longer an issue.\n        String description = parameter.getDescription();\n\n        if ( description == null )\n        {\n            throw new InvalidParameterException( \"description\", i );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    // Mojo descriptor creation from @tags\n    // ----------------------------------------------------------------------\n\n    /**\n     * @param javaClass not null\n     * @return a mojo descriptor\n     * @throws InvalidPluginDescriptorException if any\n     */\n    protected MojoDescriptor createMojoDescriptor( JavaClass javaClass )\n        throws InvalidPluginDescriptorException\n    {\n        ExtendedMojoDescriptor mojoDescriptor = new ExtendedMojoDescriptor();\n        mojoDescriptor.setLanguage( \"java\" );\n        mojoDescriptor.setImplementation( javaClass.getFullyQualifiedName() );\n        mojoDescriptor.setDescription( javaClass.getComment() );\n\n        // ----------------------------------------------------------------------\n        // Mojo annotations in alphabetical order\n        // ----------------------------------------------------------------------\n\n        // Aggregator flag\n        DocletTag aggregator = findInClassHierarchy( javaClass, JavaMojoAnnotation.AGGREGATOR );\n        if ( aggregator != null )\n        {\n            mojoDescriptor.setAggregator( true );\n        }\n\n        // Configurator hint\n        DocletTag configurator = findInClassHierarchy( javaClass, JavaMojoAnnotation.CONFIGURATOR );\n        if ( configurator != null )\n        {\n            mojoDescriptor.setComponentConfigurator( configurator.getValue() );\n        }\n\n        // Additional phase to execute first\n        DocletTag execute = findInClassHierarchy( javaClass, JavaMojoAnnotation.EXECUTE );\n        if ( execute != null )\n        {\n            String executePhase = execute.getNamedParameter( JavaMojoAnnotation.EXECUTE_PHASE );\n            String executeGoal = execute.getNamedParameter( JavaMojoAnnotation.EXECUTE_GOAL );\n\n            if ( executePhase == null && executeGoal == null )\n            {\n                throw new InvalidPluginDescriptorException( \"@execute tag requires a 'phase' or 'goal' parameter\" );\n            }\n            else if ( executePhase != null && executeGoal != null )\n            {\n                throw new InvalidPluginDescriptorException(\n                    \"@execute tag can have only one of a 'phase' or 'goal' parameter\" );\n            }\n            mojoDescriptor.setExecutePhase( executePhase );\n            mojoDescriptor.setExecuteGoal( executeGoal );\n\n            String lifecycle = execute.getNamedParameter( JavaMojoAnnotation.EXECUTE_LIFECYCLE );\n            if ( lifecycle != null )\n            {\n                mojoDescriptor.setExecuteLifecycle( lifecycle );\n                if ( mojoDescriptor.getExecuteGoal() != null )\n                {\n                    throw new InvalidPluginDescriptorException(\n                        \"@execute lifecycle requires a phase instead of a goal\" );\n                }\n            }\n        }\n\n        // Goal name\n        DocletTag goal = findInClassHierarchy( javaClass, JavaMojoAnnotation.GOAL );\n        if ( goal != null )\n        {\n            mojoDescriptor.setGoal( goal.getValue() );\n        }\n\n        // inheritByDefault flag\n        boolean value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.INHERIT_BY_DEFAULT,\n                                mojoDescriptor.isInheritedByDefault() );\n        mojoDescriptor.setInheritedByDefault( value );\n\n        // instantiationStrategy\n        DocletTag tag = findInClassHierarchy( javaClass, JavaMojoAnnotation.INSTANTIATION_STRATEGY );\n        if ( tag != null )\n        {\n            mojoDescriptor.setInstantiationStrategy( tag.getValue() );\n        }\n        tag = findInClassHierarchy( javaClass, JavaMojoAnnotation.MULTI_EXECUTION_STRATEGY );\n        if ( tag != null )\n        {\n            mojoDescriptor.setExecutionStrategy( MojoDescriptor.MULTI_PASS_EXEC_STRATEGY );\n        }\n        else\n        {\n            mojoDescriptor.setExecutionStrategy( MojoDescriptor.SINGLE_PASS_EXEC_STRATEGY );\n        }\n\n        // Phase name\n        DocletTag phase = findInClassHierarchy( javaClass, JavaMojoAnnotation.PHASE );\n        if ( phase != null )\n        {\n            mojoDescriptor.setPhase( phase.getValue() );\n        }\n\n        // Dependency resolution flag\n        DocletTag requiresDependencyResolution =\n            findInClassHierarchy( javaClass, JavaMojoAnnotation.REQUIRES_DEPENDENCY_RESOLUTION );\n        if ( requiresDependencyResolution != null )\n        {\n            String v = requiresDependencyResolution.getValue();\n\n            if ( StringUtils.isEmpty( v ) )\n            {\n                v = \"runtime\";\n            }\n\n            mojoDescriptor.setDependencyResolutionRequired( v );\n        }\n\n        // Dependency collection flag\n        DocletTag requiresDependencyCollection =\n            findInClassHierarchy( javaClass, JavaMojoAnnotation.REQUIRES_DEPENDENCY_COLLECTION );\n        if ( requiresDependencyCollection != null )\n        {\n            String v = requiresDependencyCollection.getValue();\n\n            if ( StringUtils.isEmpty( v ) )\n            {\n                v = \"runtime\";\n            }\n\n            mojoDescriptor.setDependencyCollectionRequired( v );\n        }\n\n        // requiresDirectInvocation flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_DIRECT_INVOCATION,\n                                mojoDescriptor.isDirectInvocationOnly() );\n        mojoDescriptor.setDirectInvocationOnly( value );\n\n        // Online flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_ONLINE, mojoDescriptor.isOnlineRequired() );\n        mojoDescriptor.setOnlineRequired( value );\n\n        // Project flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_PROJECT, mojoDescriptor.isProjectRequired() );\n        mojoDescriptor.setProjectRequired( value );\n\n        // requiresReports flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_REPORTS, mojoDescriptor.isRequiresReports() );\n        mojoDescriptor.setRequiresReports( value );\n\n        // ----------------------------------------------------------------------\n        // Javadoc annotations in alphabetical order\n        // ----------------------------------------------------------------------\n\n        // Deprecation hint\n        DocletTag deprecated = javaClass.getTagByName( JavaMojoAnnotation.DEPRECATED );\n        if ( deprecated != null )\n        {\n            mojoDescriptor.setDeprecated( deprecated.getValue() );\n        }\n\n        // What version it was introduced in\n        DocletTag since = findInClassHierarchy( javaClass, JavaMojoAnnotation.SINCE );\n        if ( since != null )\n        {\n            mojoDescriptor.setSince( since.getValue() );\n        }\n\n        // Thread-safe mojo \n\n        value = getBooleanTagValue( javaClass, JavaMojoAnnotation.THREAD_SAFE, true, mojoDescriptor.isThreadSafe() );\n        mojoDescriptor.setThreadSafe( value );\n\n        extractParameters( mojoDescriptor, javaClass );\n\n        return mojoDescriptor;\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName not null\n     * @param defaultValue the wanted default value\n     * @return the boolean value of the given tagName\n     * @see #findInClassHierarchy(JavaClass, String)\n     */\n    private static boolean getBooleanTagValue( JavaClass javaClass, String tagName, boolean defaultValue )\n    {\n        DocletTag tag = findInClassHierarchy( javaClass, tagName );\n\n        if ( tag != null )\n        {\n            String value = tag.getValue();\n\n            if ( StringUtils.isNotEmpty( value ) )\n            {\n                defaultValue = Boolean.valueOf( value ).booleanValue();\n            }\n        }\n        return defaultValue;\n    }\n\n    /**\n     * @param javaClass     not null\n     * @param tagName       not null\n     * @param defaultForTag The wanted default value when only the tagname is present\n     * @param defaultValue  the wanted default value when the tag is not specified\n     * @return the boolean value of the given tagName\n     * @see #findInClassHierarchy(JavaClass, String)\n     */\n    private static boolean getBooleanTagValue( JavaClass javaClass, String tagName, boolean defaultForTag,\n                                               boolean defaultValue )\n    {\n        DocletTag tag = findInClassHierarchy( javaClass, tagName );\n\n        if ( tag != null )\n        {\n            String value = tag.getValue();\n\n            if ( StringUtils.isNotEmpty( value ) )\n            {\n                return Boolean.valueOf( value ).booleanValue();\n            }\n            else\n            {\n                return defaultForTag;\n            }\n        }\n        return defaultValue;\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName not null\n     * @return docletTag instance\n     */\n    private static DocletTag findInClassHierarchy( JavaClass javaClass, String tagName )\n    {\n        DocletTag tag = javaClass.getTagByName( tagName );\n\n        if ( tag == null )\n        {\n            JavaClass superClass = javaClass.getSuperJavaClass();\n\n            if ( superClass != null )\n            {\n                tag = findInClassHierarchy( superClass, tagName );\n            }\n        }\n\n        return tag;\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @param javaClass not null\n     * @throws InvalidPluginDescriptorException if any\n     */\n    private void extractParameters( MojoDescriptor mojoDescriptor, JavaClass javaClass )\n        throws InvalidPluginDescriptorException\n    {\n        // ---------------------------------------------------------------------------------\n        // We're resolving class-level, ancestor-class-field, local-class-field order here.\n        // ---------------------------------------------------------------------------------\n\n        Map rawParams = extractFieldParameterTags( javaClass );\n\n        for ( Iterator it = rawParams.entrySet().iterator(); it.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) it.next();\n\n            JavaField field = (JavaField) entry.getValue();\n\n            Type type = field.getType();\n\n            Parameter pd = new Parameter();\n\n            if ( !type.isArray() )\n            {\n                pd.setType( type.getValue() );\n            }\n            else\n            {\n                StringBuffer value = new StringBuffer( type.getValue() );\n\n                int remaining = type.getDimensions();\n\n                while ( remaining-- > 0 )\n                {\n                    value.append( \"[]\" );\n                }\n\n                pd.setType( value.toString() );\n            }\n\n            pd.setDescription( field.getComment() );\n\n            DocletTag componentTag = field.getTagByName( JavaMojoAnnotation.COMPONENT );\n            if ( componentTag != null )\n            {\n                String role = componentTag.getNamedParameter( JavaMojoAnnotation.COMPONENT_ROLE );\n\n                if ( role == null )\n                {\n                    role = field.getType().toString();\n                }\n\n                String roleHint = componentTag.getNamedParameter( JavaMojoAnnotation.COMPONENT_ROLEHINT );\n\n                if ( roleHint == null )\n                {\n                    // support alternate syntax for better compatibility with the Plexus CDC.\n                    roleHint = componentTag.getNamedParameter( \"role-hint\" );\n                }\n\n                pd.setRequirement( new Requirement( role, roleHint ) );\n\n                pd.setName( (String) entry.getKey() );\n\n                pd.setEditable( false );\n                /* TODO: or better like this? Need @component fields be editable for the user?\n                pd.setEditable( field.getTagByName( READONLY ) == null );\n                */\n            }\n            else\n            {\n                DocletTag parameter = field.getTagByName( JavaMojoAnnotation.PARAMETER );\n\n                // ----------------------------------------------------------------------\n                // We will look for a property name here first and use that if present\n                // i.e:\n                //\n                // @parameter property=\"project\"\n                //\n                // Which will become the name used for the configuration element which\n                // will in turn will allow plexus to use the corresponding setter.\n                // ----------------------------------------------------------------------\n\n                String property = parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_PROPERTY );\n\n                if ( !StringUtils.isEmpty( property ) )\n                {\n                    pd.setName( property );\n                }\n                else\n                {\n                    pd.setName( (String) entry.getKey() );\n                }\n\n                pd.setRequired( field.getTagByName( JavaMojoAnnotation.REQUIRED ) != null );\n\n                pd.setEditable( field.getTagByName( JavaMojoAnnotation.READONLY ) == null );\n\n                DocletTag deprecationTag = field.getTagByName( JavaMojoAnnotation.DEPRECATED );\n\n                if ( deprecationTag != null )\n                {\n                    pd.setDeprecated( deprecationTag.getValue() );\n                }\n\n                DocletTag sinceTag = field.getTagByName( JavaMojoAnnotation.SINCE );\n                if ( sinceTag != null )\n                {\n                    pd.setSince( sinceTag.getValue() );\n                }\n\n                String alias = parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_ALIAS );\n\n                if ( !StringUtils.isEmpty( alias ) )\n                {\n                    pd.setAlias( alias );\n                }\n\n                String expression = parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_EXPRESSION );\n                pd.setExpression( expression );\n\n                if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${component.\" ) )\n                {\n                    getLogger().warn( javaClass.getFullyQualifiedName() + \"#\" + field.getName() + \":\" );\n                    getLogger().warn( \"  The syntax\" );\n                    getLogger().warn( \"    @parameter expression=\\\"${component.<role>#<roleHint>}\\\"\" );\n                    getLogger().warn( \"  is deprecated, please use\" );\n                    getLogger().warn( \"    @component role=\\\"<role>\\\" roleHint=\\\"<roleHint>\\\"\" );\n                    getLogger().warn( \"  instead.\" );\n                }\n\n                if ( \"${reports}\".equals( pd.getExpression() ) )\n                {\n                    mojoDescriptor.setRequiresReports( true );\n                }\n\n                pd.setDefaultValue( parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_DEFAULT_VALUE ) );\n\n                pd.setImplementation( parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_IMPLEMENTATION ) );\n            }\n\n            mojoDescriptor.addParameter( pd );\n        }\n    }\n\n    /**\n     * @param javaClass not null\n     * @return map with Mojo parameters names as keys\n     */\n    private Map extractFieldParameterTags( JavaClass javaClass )\n    {\n        Map rawParams;\n\n        // we have to add the parent fields first, so that they will be overwritten by the local fields if\n        // that actually happens...\n        JavaClass superClass = javaClass.getSuperJavaClass();\n\n        if ( superClass != null )\n        {\n            rawParams = extractFieldParameterTags( superClass );\n        }\n        else\n        {\n            rawParams = new TreeMap();\n        }\n\n        JavaField[] classFields = javaClass.getFields();\n\n        if ( classFields != null )\n        {\n            for ( int i = 0; i < classFields.length; i++ )\n            {\n                JavaField field = classFields[i];\n\n                if ( field.getTagByName( JavaMojoAnnotation.PARAMETER ) != null\n                    || field.getTagByName( JavaMojoAnnotation.COMPONENT ) != null )\n                {\n                    rawParams.put( field.getName(), field );\n                }\n            }\n        }\n        return rawParams;\n    }\n\n    /** {@inheritDoc} */\n    public List execute( MavenProject project, PluginDescriptor pluginDescriptor )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        return execute( new DefaultPluginToolsRequest( project, pluginDescriptor ) );\n    }\n    \n    /** {@inheritDoc} */\n    public List execute( PluginToolsRequest request )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        JavaClass[] javaClasses = discoverClasses( request );\n\n        List descriptors = new ArrayList();\n\n        for ( int i = 0; i < javaClasses.length; i++ )\n        {\n            DocletTag tag = javaClasses[i].getTagByName( GOAL );\n\n            if ( tag != null )\n            {\n                MojoDescriptor mojoDescriptor = createMojoDescriptor( javaClasses[i] );\n                mojoDescriptor.setPluginDescriptor( request.getPluginDescriptor() );\n\n                // Validate the descriptor as best we can before allowing it to be processed.\n                validate( mojoDescriptor );\n\n                descriptors.add( mojoDescriptor );\n            }\n        }\n\n        return descriptors;\n    }\n\n    /**\n     * @param request The plugin request.\n     * @return an array of java class\n     */\n    protected JavaClass[] discoverClasses( final PluginToolsRequest request )\n    {\n        JavaDocBuilder builder = new JavaDocBuilder();\n        builder.setEncoding( request.getEncoding() );\n        \n        MavenProject project = request.getProject();\n\n        for ( Iterator i = project.getCompileSourceRoots().iterator(); i.hasNext(); )\n        {\n            builder.addSourceTree( new File( (String) i.next() ) );\n        }\n\n        // TODO be more dynamic\n        if ( !project.getCompileSourceRoots()\n            .contains( new File( project.getBasedir(), \"target/generated-sources/plugin\" ).getAbsolutePath() ) )\n        {\n            builder.addSourceTree( new File( project.getBasedir(), \"target/generated-sources/plugin\" ) );\n        }\n\n        return builder.getClasses();\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @throws InvalidParameterException if any\n     */\n    protected void validate( MojoDescriptor mojoDescriptor )\n        throws InvalidParameterException\n    {\n        List parameters = mojoDescriptor.getParameters();\n\n        if ( parameters != null )\n        {\n            for ( int j = 0; j < parameters.size(); j++ )\n            {\n                validateParameter( (Parameter) parameters.get( j ), j );\n            }\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.extractor.java;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport com.thoughtworks.qdox.JavaDocBuilder;\nimport com.thoughtworks.qdox.model.DocletTag;\nimport com.thoughtworks.qdox.model.JavaClass;\nimport com.thoughtworks.qdox.model.JavaField;\nimport com.thoughtworks.qdox.model.Type;\n\nimport org.apache.maven.plugin.descriptor.InvalidParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.ExtendedMojoDescriptor;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\n\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\n/**\n * Extracts Mojo descriptors from <a href=\"http://java.sun.com/\">Java<\/a> sources.\n * <br/>\n * For more information about the usage tag, have a look to:\n * <a href=\"http://maven.apache.org/developers/mojo-api-specification.html\">\n * http://maven.apache.org/developers/mojo-api-specification.html<\/a>\n *\n * @todo need to add validation directives so that systems embedding maven2 can\n * get validation directives to help users in IDEs.\n * @version $Id$\n * @see org.apache.maven.plugin.descriptor.MojoDescriptor\n */\npublic class JavaMojoDescriptorExtractor\n    extends AbstractLogEnabled\n    implements MojoDescriptorExtractor, JavaMojoAnnotation\n{\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#INSTANTIATION_STRATEGY} instead of. */\n    public static final String MAVEN_PLUGIN_INSTANTIATION = JavaMojoAnnotation.INSTANTIATION_STRATEGY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#CONFIGURATOR} instead of. */\n    public static final String CONFIGURATOR = JavaMojoAnnotation.CONFIGURATOR;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER} instead of. */\n    public static final String PARAMETER = JavaMojoAnnotation.PARAMETER;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_EXPRESSION} instead of. */\n    public static final String PARAMETER_EXPRESSION = JavaMojoAnnotation.PARAMETER_EXPRESSION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_DEFAULT_VALUE} instead of. */\n    public static final String PARAMETER_DEFAULT_VALUE = JavaMojoAnnotation.PARAMETER_DEFAULT_VALUE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_ALIAS} instead of. */\n    public static final String PARAMETER_ALIAS = JavaMojoAnnotation.PARAMETER_ALIAS;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#SINCE} instead of. */\n    public static final String SINCE = JavaMojoAnnotation.SINCE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_IMPLEMENTATION} instead of. */\n    public static final String PARAMETER_IMPLEMENTATION = JavaMojoAnnotation.PARAMETER_IMPLEMENTATION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_PROPERTY} instead of. */\n    public static final String PARAMETER_PROPERTY = JavaMojoAnnotation.PARAMETER_PROPERTY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRED} instead of. */\n    public static final String REQUIRED = JavaMojoAnnotation.REQUIRED;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#DEPRECATED} instead of. */\n    public static final String DEPRECATED = JavaMojoAnnotation.DEPRECATED;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#READONLY} instead of. */\n    public static final String READONLY = JavaMojoAnnotation.READONLY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#GOAL} instead of. */\n    public static final String GOAL = JavaMojoAnnotation.GOAL;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PHASE} instead of. */\n    public static final String PHASE = JavaMojoAnnotation.PHASE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE} instead of. */\n    public static final String EXECUTE = JavaMojoAnnotation.EXECUTE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE_LIFECYCLE} instead of. */\n    public static final String EXECUTE_LIFECYCLE = JavaMojoAnnotation.EXECUTE_LIFECYCLE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE_PHASE} instead of. */\n    public static final String EXECUTE_PHASE = JavaMojoAnnotation.EXECUTE_PHASE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE_GOAL} instead of. */\n    public static final String EXECUTE_GOAL = JavaMojoAnnotation.EXECUTE_GOAL;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#DESCRIPTION} instead of. */\n    public static final String GOAL_DESCRIPTION = JavaMojoAnnotation.DESCRIPTION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_DEPENDENCY_RESOLUTION} instead of. */\n    public static final String GOAL_REQUIRES_DEPENDENCY_RESOLUTION = JavaMojoAnnotation.REQUIRES_DEPENDENCY_RESOLUTION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_PROJECT} instead of. */\n    public static final String GOAL_REQUIRES_PROJECT = JavaMojoAnnotation.REQUIRES_PROJECT;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_REPORTS} instead of. */\n    public static final String GOAL_REQUIRES_REPORTS = JavaMojoAnnotation.REQUIRES_REPORTS;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#AGGREGATOR} instead of. */\n    public static final String GOAL_IS_AGGREGATOR = JavaMojoAnnotation.AGGREGATOR;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_ONLINE} instead of. */\n    public static final String GOAL_REQUIRES_ONLINE = JavaMojoAnnotation.REQUIRES_ONLINE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#INHERIT_BY_DEFAULT} instead of. */\n    public static final String GOAL_INHERIT_BY_DEFAULT = JavaMojoAnnotation.INHERIT_BY_DEFAULT;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#MULTI_EXECUTION_STRATEGY} instead of. */\n    public static final String GOAL_MULTI_EXECUTION_STRATEGY = JavaMojoAnnotation.MULTI_EXECUTION_STRATEGY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_DIRECT_INVOCATION} instead of. */\n    public static final String GOAL_REQUIRES_DIRECT_INVOCATION = JavaMojoAnnotation.REQUIRES_DIRECT_INVOCATION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#COMPONENT} instead of. */\n    public static final String COMPONENT = JavaMojoAnnotation.COMPONENT;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#COMPONENT_ROLE} instead of. */\n    public static final String COMPONENT_ROLE = JavaMojoAnnotation.COMPONENT_ROLE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#COMPONENT_ROLEHINT} instead of. */\n    public static final String COMPONENT_ROLEHINT = JavaMojoAnnotation.COMPONENT_ROLEHINT;\n\n    /**\n     * @param parameter not null\n     * @param i positive number\n     * @throws InvalidParameterException if any\n     */\n    protected void validateParameter( Parameter parameter, int i )\n        throws InvalidParameterException\n    {\n        // TODO: remove when backward compatibility is no longer an issue.\n        String name = parameter.getName();\n\n        if ( name == null )\n        {\n            throw new InvalidParameterException( \"name\", i );\n        }\n\n        // TODO: remove when backward compatibility is no longer an issue.\n        String type = parameter.getType();\n\n        if ( type == null )\n        {\n            throw new InvalidParameterException( \"type\", i );\n        }\n\n        // TODO: remove when backward compatibility is no longer an issue.\n        String description = parameter.getDescription();\n\n        if ( description == null )\n        {\n            throw new InvalidParameterException( \"description\", i );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    // Mojo descriptor creation from @tags\n    // ----------------------------------------------------------------------\n\n    /**\n     * @param javaClass not null\n     * @return a mojo descriptor\n     * @throws InvalidPluginDescriptorException if any\n     */\n    protected MojoDescriptor createMojoDescriptor( JavaClass javaClass )\n        throws InvalidPluginDescriptorException\n    {\n        ExtendedMojoDescriptor mojoDescriptor = new ExtendedMojoDescriptor();\n        mojoDescriptor.setLanguage( \"java\" );\n        mojoDescriptor.setImplementation( javaClass.getFullyQualifiedName() );\n        mojoDescriptor.setDescription( javaClass.getComment() );\n\n        // ----------------------------------------------------------------------\n        // Mojo annotations in alphabetical order\n        // ----------------------------------------------------------------------\n\n        // Aggregator flag\n        DocletTag aggregator = findInClassHierarchy( javaClass, JavaMojoAnnotation.AGGREGATOR );\n        if ( aggregator != null )\n        {\n            mojoDescriptor.setAggregator( true );\n        }\n\n        // Configurator hint\n        DocletTag configurator = findInClassHierarchy( javaClass, JavaMojoAnnotation.CONFIGURATOR );\n        if ( configurator != null )\n        {\n            mojoDescriptor.setComponentConfigurator( configurator.getValue() );\n        }\n\n        // Additional phase to execute first\n        DocletTag execute = findInClassHierarchy( javaClass, JavaMojoAnnotation.EXECUTE );\n        if ( execute != null )\n        {\n            String executePhase = execute.getNamedParameter( JavaMojoAnnotation.EXECUTE_PHASE );\n            String executeGoal = execute.getNamedParameter( JavaMojoAnnotation.EXECUTE_GOAL );\n\n            if ( executePhase == null && executeGoal == null )\n            {\n                throw new InvalidPluginDescriptorException( \"@execute tag requires a 'phase' or 'goal' parameter\" );\n            }\n            else if ( executePhase != null && executeGoal != null )\n            {\n                throw new InvalidPluginDescriptorException(\n                    \"@execute tag can have only one of a 'phase' or 'goal' parameter\" );\n            }\n            mojoDescriptor.setExecutePhase( executePhase );\n            mojoDescriptor.setExecuteGoal( executeGoal );\n\n            String lifecycle = execute.getNamedParameter( JavaMojoAnnotation.EXECUTE_LIFECYCLE );\n            if ( lifecycle != null )\n            {\n                mojoDescriptor.setExecuteLifecycle( lifecycle );\n                if ( mojoDescriptor.getExecuteGoal() != null )\n                {\n                    throw new InvalidPluginDescriptorException(\n                        \"@execute lifecycle requires a phase instead of a goal\" );\n                }\n            }\n        }\n\n        // Goal name\n        DocletTag goal = findInClassHierarchy( javaClass, JavaMojoAnnotation.GOAL );\n        if ( goal != null )\n        {\n            mojoDescriptor.setGoal( goal.getValue() );\n        }\n\n        // inheritByDefault flag\n        boolean value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.INHERIT_BY_DEFAULT,\n                                mojoDescriptor.isInheritedByDefault() );\n        mojoDescriptor.setInheritedByDefault( value );\n\n        // instantiationStrategy\n        DocletTag tag = findInClassHierarchy( javaClass, JavaMojoAnnotation.INSTANTIATION_STRATEGY );\n        if ( tag != null )\n        {\n            mojoDescriptor.setInstantiationStrategy( tag.getValue() );\n        }\n        tag = findInClassHierarchy( javaClass, JavaMojoAnnotation.MULTI_EXECUTION_STRATEGY );\n        if ( tag != null )\n        {\n            mojoDescriptor.setExecutionStrategy( MojoDescriptor.MULTI_PASS_EXEC_STRATEGY );\n        }\n        else\n        {\n            mojoDescriptor.setExecutionStrategy( MojoDescriptor.SINGLE_PASS_EXEC_STRATEGY );\n        }\n\n        // Phase name\n        DocletTag phase = findInClassHierarchy( javaClass, JavaMojoAnnotation.PHASE );\n        if ( phase != null )\n        {\n            mojoDescriptor.setPhase( phase.getValue() );\n        }\n\n        // Dependency resolution flag\n        DocletTag requiresDependencyResolution =\n            findInClassHierarchy( javaClass, JavaMojoAnnotation.REQUIRES_DEPENDENCY_RESOLUTION );\n        if ( requiresDependencyResolution != null )\n        {\n            String v = requiresDependencyResolution.getValue();\n\n            if ( StringUtils.isEmpty( v ) )\n            {\n                v = \"runtime\";\n            }\n\n            mojoDescriptor.setDependencyResolutionRequired( v );\n        }\n\n        // What version it was introduced in\n        DocletTag requiresDependencyCollection =\n            findInClassHierarchy( javaClass, JavaMojoAnnotation.REQUIRES_DEPENDENCY_COLLECTION );\n        if ( requiresDependencyCollection != null )\n        {\n            mojoDescriptor.setRequiresDependencyCollection( requiresDependencyCollection.getValue() );\n        }\n\n        // requiresDirectInvocation flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_DIRECT_INVOCATION,\n                                mojoDescriptor.isDirectInvocationOnly() );\n        mojoDescriptor.setDirectInvocationOnly( value );\n\n        // Online flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_ONLINE, mojoDescriptor.isOnlineRequired() );\n        mojoDescriptor.setOnlineRequired( value );\n\n        // Project flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_PROJECT, mojoDescriptor.isProjectRequired() );\n        mojoDescriptor.setProjectRequired( value );\n\n        // requiresReports flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_REPORTS, mojoDescriptor.isRequiresReports() );\n        mojoDescriptor.setRequiresReports( value );\n\n        // -------------------------------------------------------- --------------\n        // Javadoc annotations in alphabetical order\n        // ----------------------------------------------------------------------\n\n        // Deprecation hint\n        DocletTag deprecated = javaClass.getTagByName( JavaMojoAnnotation.DEPRECATED );\n        if ( deprecated != null )\n        {\n            mojoDescriptor.setDeprecated( deprecated.getValue() );\n        }\n\n        // What version it was introduced in\n        DocletTag since = findInClassHierarchy( javaClass, JavaMojoAnnotation.SINCE );\n        if ( since != null )\n        {\n            mojoDescriptor.setSince( since.getValue() );\n        }\n\n        // Threadsafe mojo \n\n        value = getBooleanTagValue( javaClass, JavaMojoAnnotation.THREADSAFE, true, mojoDescriptor.isThreadSafe() );\n        mojoDescriptor.setThreadSafe( value );\n\n        extractParameters( mojoDescriptor, javaClass );\n\n        return mojoDescriptor;\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName not null\n     * @param defaultValue the wanted default value\n     * @return the boolean value of the given tagName\n     * @see #findInClassHierarchy(JavaClass, String)\n     */\n    private static boolean getBooleanTagValue( JavaClass javaClass, String tagName, boolean defaultValue )\n    {\n        DocletTag tag = findInClassHierarchy( javaClass, tagName );\n\n        if ( tag != null )\n        {\n            String value = tag.getValue();\n\n            if ( StringUtils.isNotEmpty( value ) )\n            {\n                defaultValue = Boolean.valueOf( value ).booleanValue();\n            }\n        }\n        return defaultValue;\n    }\n\n    /**\n     * @param javaClass     not null\n     * @param tagName       not null\n     * @param defaultForTag The wanted default value when only the tagname is present\n     * @param defaultValue  the wanted default value when the tag is not specified\n     * @return the boolean value of the given tagName\n     * @see #findInClassHierarchy(JavaClass, String)\n     */\n    private static boolean getBooleanTagValue( JavaClass javaClass, String tagName, boolean defaultForTag,\n                                               boolean defaultValue )\n    {\n        DocletTag tag = findInClassHierarchy( javaClass, tagName );\n\n        if ( tag != null )\n        {\n            String value = tag.getValue();\n\n            if ( StringUtils.isEmpty( value ) )\n            {\n                return defaultForTag;\n            }\n            else if ( StringUtils.isNotEmpty( value ) )\n            {\n                return Boolean.valueOf( value ).booleanValue();\n            }\n        }\n        return defaultValue;\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName not null\n     * @return docletTag instance\n     */\n    private static DocletTag findInClassHierarchy( JavaClass javaClass, String tagName )\n    {\n        DocletTag tag = javaClass.getTagByName( tagName );\n\n        if ( tag == null )\n        {\n            JavaClass superClass = javaClass.getSuperJavaClass();\n\n            if ( superClass != null )\n            {\n                tag = findInClassHierarchy( superClass, tagName );\n            }\n        }\n\n        return tag;\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @param javaClass not null\n     * @throws InvalidPluginDescriptorException if any\n     */\n    private void extractParameters( MojoDescriptor mojoDescriptor, JavaClass javaClass )\n        throws InvalidPluginDescriptorException\n    {\n        // ---------------------------------------------------------------------------------\n        // We're resolving class-level, ancestor-class-field, local-class-field order here.\n        // ---------------------------------------------------------------------------------\n\n        Map rawParams = extractFieldParameterTags( javaClass );\n\n        for ( Iterator it = rawParams.entrySet().iterator(); it.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) it.next();\n\n            JavaField field = (JavaField) entry.getValue();\n\n            Type type = field.getType();\n\n            Parameter pd = new Parameter();\n\n            if ( !type.isArray() )\n            {\n                pd.setType( type.getValue() );\n            }\n            else\n            {\n                StringBuffer value = new StringBuffer( type.getValue() );\n\n                int remaining = type.getDimensions();\n\n                while ( remaining-- > 0 )\n                {\n                    value.append( \"[]\" );\n                }\n\n                pd.setType( value.toString() );\n            }\n\n            pd.setDescription( field.getComment() );\n\n            DocletTag componentTag = field.getTagByName( JavaMojoAnnotation.COMPONENT );\n            if ( componentTag != null )\n            {\n                String role = componentTag.getNamedParameter( JavaMojoAnnotation.COMPONENT_ROLE );\n\n                if ( role == null )\n                {\n                    role = field.getType().toString();\n                }\n\n                String roleHint = componentTag.getNamedParameter( JavaMojoAnnotation.COMPONENT_ROLEHINT );\n\n                if ( roleHint == null )\n                {\n                    // support alternate syntax for better compatibility with the Plexus CDC.\n                    roleHint = componentTag.getNamedParameter( \"role-hint\" );\n                }\n\n                pd.setRequirement( new Requirement( role, roleHint ) );\n\n                pd.setName( (String) entry.getKey() );\n\n                pd.setEditable( false );\n                /* TODO: or better like this? Need @component fields be editable for the user?\n                pd.setEditable( field.getTagByName( READONLY ) == null );\n                */\n            }\n            else\n            {\n                DocletTag parameter = field.getTagByName( JavaMojoAnnotation.PARAMETER );\n\n                // ----------------------------------------------------------------------\n                // We will look for a property name here first and use that if present\n                // i.e:\n                //\n                // @parameter property=\"project\"\n                //\n                // Which will become the name used for the configuration element which\n                // will in turn will allow plexus to use the corresponding setter.\n                // ----------------------------------------------------------------------\n\n                String property = parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_PROPERTY );\n\n                if ( !StringUtils.isEmpty( property ) )\n                {\n                    pd.setName( property );\n                }\n                else\n                {\n                    pd.setName( (String) entry.getKey() );\n                }\n\n                pd.setRequired( field.getTagByName( JavaMojoAnnotation.REQUIRED ) != null );\n\n                pd.setEditable( field.getTagByName( JavaMojoAnnotation.READONLY ) == null );\n\n                DocletTag deprecationTag = field.getTagByName( JavaMojoAnnotation.DEPRECATED );\n\n                if ( deprecationTag != null )\n                {\n                    pd.setDeprecated( deprecationTag.getValue() );\n                }\n\n                DocletTag sinceTag = field.getTagByName( JavaMojoAnnotation.SINCE );\n                if ( sinceTag != null )\n                {\n                    pd.setSince( sinceTag.getValue() );\n                }\n\n                String alias = parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_ALIAS );\n\n                if ( !StringUtils.isEmpty( alias ) )\n                {\n                    pd.setAlias( alias );\n                }\n\n                String expression = parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_EXPRESSION );\n                pd.setExpression( expression );\n\n                if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${component.\" ) )\n                {\n                    getLogger().warn( javaClass.getFullyQualifiedName() + \"#\" + field.getName() + \":\" );\n                    getLogger().warn( \"  The syntax\" );\n                    getLogger().warn( \"    @parameter expression=\\\"${component.<role>#<roleHint>}\\\"\" );\n                    getLogger().warn( \"  is deprecated, please use\" );\n                    getLogger().warn( \"    @component role=\\\"<role>\\\" roleHint=\\\"<roleHint>\\\"\" );\n                    getLogger().warn( \"  instead.\" );\n                }\n\n                if ( \"${reports}\".equals( pd.getExpression() ) )\n                {\n                    mojoDescriptor.setRequiresReports( true );\n                }\n\n                pd.setDefaultValue( parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_DEFAULT_VALUE ) );\n\n                pd.setImplementation( parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_IMPLEMENTATION ) );\n            }\n\n            mojoDescriptor.addParameter( pd );\n        }\n    }\n\n    /**\n     * @param javaClass not null\n     * @return map with Mojo parameters names as keys\n     */\n    private Map extractFieldParameterTags( JavaClass javaClass )\n    {\n        Map rawParams;\n\n        // we have to add the parent fields first, so that they will be overwritten by the local fields if\n        // that actually happens...\n        JavaClass superClass = javaClass.getSuperJavaClass();\n\n        if ( superClass != null )\n        {\n            rawParams = extractFieldParameterTags( superClass );\n        }\n        else\n        {\n            rawParams = new TreeMap();\n        }\n\n        JavaField[] classFields = javaClass.getFields();\n\n        if ( classFields != null )\n        {\n            for ( int i = 0; i < classFields.length; i++ )\n            {\n                JavaField field = classFields[i];\n\n                if ( field.getTagByName( JavaMojoAnnotation.PARAMETER ) != null\n                    || field.getTagByName( JavaMojoAnnotation.COMPONENT ) != null )\n                {\n                    rawParams.put( field.getName(), field );\n                }\n            }\n        }\n        return rawParams;\n    }\n\n    /** {@inheritDoc} */\n    public List execute( MavenProject project, PluginDescriptor pluginDescriptor )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        return execute( new DefaultPluginToolsRequest( project, pluginDescriptor ) );\n    }\n    \n    /** {@inheritDoc} */\n    public List execute( PluginToolsRequest request )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        JavaClass[] javaClasses = discoverClasses( request );\n\n        List descriptors = new ArrayList();\n\n        for ( int i = 0; i < javaClasses.length; i++ )\n        {\n            DocletTag tag = javaClasses[i].getTagByName( GOAL );\n\n            if ( tag != null )\n            {\n                MojoDescriptor mojoDescriptor = createMojoDescriptor( javaClasses[i] );\n                mojoDescriptor.setPluginDescriptor( request.getPluginDescriptor() );\n\n                // Validate the descriptor as best we can before allowing it to be processed.\n                validate( mojoDescriptor );\n\n                descriptors.add( mojoDescriptor );\n            }\n        }\n\n        return descriptors;\n    }\n\n    /**\n     * @param request The plugin request.\n     * @return an array of java class\n     */\n    protected JavaClass[] discoverClasses( final PluginToolsRequest request )\n    {\n        JavaDocBuilder builder = new JavaDocBuilder();\n        builder.setEncoding( request.getEncoding() );\n        \n        MavenProject project = request.getProject();\n\n        for ( Iterator i = project.getCompileSourceRoots().iterator(); i.hasNext(); )\n        {\n            builder.addSourceTree( new File( (String) i.next() ) );\n        }\n\n        // TODO be more dynamic\n        if ( !project.getCompileSourceRoots()\n            .contains( new File( project.getBasedir(), \"target/generated-sources/plugin\" ).getAbsolutePath() ) )\n        {\n            builder.addSourceTree( new File( project.getBasedir(), \"target/generated-sources/plugin\" ) );\n        }\n\n        return builder.getClasses();\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @throws InvalidParameterException if any\n     */\n    protected void validate( MojoDescriptor mojoDescriptor )\n        throws InvalidParameterException\n    {\n        List parameters = mojoDescriptor.getParameters();\n\n        if ( parameters != null )\n        {\n            for ( int j = 0; j < parameters.size(); j++ )\n            {\n                validateParameter( (Parameter) parameters.get( j ), j );\n            }\n        }\n    }\n}\n","lineNo":312}
{"Refactored Sample":"package org.apache.maven.tools.plugin.extractor.ant;\n\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.path.PathTranslator;\nimport org.apache.maven.tools.plugin.DefaultPluginToolsRequest;\nimport org.apache.maven.tools.plugin.PluginToolsRequest;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.codehaus.plexus.component.repository.ComponentRequirement;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport junit.framework.TestCase;\n\npublic class AntMojoDescriptorExtractorTest\n    extends TestCase\n{\n    \n    public void testBasicMojoExtraction_CheckInjectedParametersAndRequirements()\n        throws InvalidPluginDescriptorException, ExtractionException\n    {\n        Map scriptMap = buildTestMap( \"basic\" );\n        \n        PluginDescriptor pd = new PluginDescriptor();\n        \n        pd.setArtifactId( \"test-plugin\" );\n        pd.setGroupId( \"org.mytest\" );\n        pd.setVersion( \"1\" );\n        pd.setGoalPrefix( \"mytest\" );\n        \n        PluginToolsRequest request = new DefaultPluginToolsRequest( new MavenProject(), pd );\n        \n        List metadata = new AntMojoDescriptorExtractor().extractMojoDescriptorsFromMetadata( scriptMap, request );\n        \n        assertEquals( 2, metadata.size() );\n        \n        for ( Iterator it = metadata.iterator(); it.hasNext(); )\n        {\n            MojoDescriptor desc = (MojoDescriptor) it.next();\n            \n            if ( \"test\".equals( desc.getGoal() ) )\n            {\n                assertTrue( desc.getImplementation().indexOf( \":\" ) < 0 );\n            }\n            else if ( \"test2\".equals( desc.getGoal() ) )\n            {\n                assertTrue( desc.getImplementation().endsWith( \":test2\" ) );\n            }\n            \n            List params = desc.getParameters();\n            Map paramMap = new HashMap();\n            for ( Iterator paramIterator = params.iterator(); paramIterator.hasNext(); )\n            {\n                Parameter param = (Parameter) paramIterator.next();\n                paramMap.put( param.getName(), param );\n            }\n            \n            assertNotNull( \"Mojo descriptor: \" + desc.getGoal() + \" is missing 'basedir' parameter.\", paramMap.get( \"basedir\" ) );\n            assertNotNull( \"Mojo descriptor: \" + desc.getGoal() + \" is missing 'messageLevel' parameter.\", paramMap.get( \"messageLevel\" ) );\n            assertNotNull( \"Mojo descriptor: \" + desc.getGoal() + \" is missing 'project' parameter.\", paramMap.get( \"project\" ) );\n            assertNotNull( \"Mojo descriptor: \" + desc.getGoal() + \" is missing 'session' parameter.\", paramMap.get( \"session\" ) );\n            assertNotNull( \"Mojo descriptor: \" + desc.getGoal() + \" is missing 'mojoExecution' parameter.\", paramMap.get( \"mojoExecution\" ) );\n            \n            List components = desc.getRequirements();\n\n            assertNotNull( components );\n            assertEquals( 1, components.size() );\n            \n            ComponentRequirement req = (ComponentRequirement) components.get( 0 );\n            assertEquals( \"Mojo descriptor: \" + desc.getGoal() + \" is missing 'PathTranslator' component requirement.\", PathTranslator.class.getName(), req.getRole() );\n        }\n    }\n    \n    private Map buildTestMap( String resourceDirName )\n    {\n        Map result = new HashMap();\n        \n        ClassLoader cloader = Thread.currentThread().getContextClassLoader();\n        URL mojosXmlUrl = cloader.getResource( resourceDirName + \"/test.mojos.xml\" );\n        \n        if ( mojosXmlUrl == null )\n        {\n            fail( \"No classpath resource named: '\" + resourceDirName + \"/test.mojos.xml' could be found.\" );\n        }\n        \n        File mojosXml = new File( StringUtils.replace( mojosXmlUrl.getPath(), \"%20\", \" \" ) );\n        File dir = mojosXml.getParentFile();\n        \n        Set scripts = new HashSet();\n        String[] listing = dir.list();\n        for ( int i = 0; listing != null && i < listing.length; i++ )\n        {\n            if ( listing[i].endsWith( \".mojos.xml\" ) )\n            {\n                File f = new File( dir, listing[i] ).getAbsoluteFile();\n                \n                scripts.add( f );\n            }\n        }\n        \n        result.put( dir.getAbsolutePath(), scripts );\n        \n        return result;\n    }\n    \n    // TODO\n\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.extractor.ant;\n\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.path.PathTranslator;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\nimport org.codehaus.plexus.component.repository.ComponentRequirement;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport junit.framework.TestCase;\n\npublic class AntMojoDescriptorExtractorTest\n    extends TestCase\n{\n    \n    public void testBasicMojoExtraction_CheckInjectedParametersAndRequirements()\n        throws InvalidPluginDescriptorException, ExtractionException\n    {\n        Map scriptMap = buildTestMap( \"basic\" );\n        \n        PluginDescriptor pd = new PluginDescriptor();\n        \n        pd.setArtifactId( \"test-plugin\" );\n        pd.setGroupId( \"org.mytest\" );\n        pd.setVersion( \"1\" );\n        pd.setGoalPrefix( \"mytest\" );\n        \n        List metadata = new AntMojoDescriptorExtractor().extractMojoDescriptorsFromMetadata( scriptMap, pd );\n        \n        assertEquals( 2, metadata.size() );\n        \n        for ( Iterator it = metadata.iterator(); it.hasNext(); )\n        {\n            MojoDescriptor desc = (MojoDescriptor) it.next();\n            \n            if ( \"test\".equals( desc.getGoal() ) )\n            {\n                assertTrue( desc.getImplementation().indexOf( \":\" ) < 0 );\n            }\n            else if ( \"test2\".equals( desc.getGoal() ) )\n            {\n                assertTrue( desc.getImplementation().endsWith( \":test2\" ) );\n            }\n            \n            List params = desc.getParameters();\n            Map paramMap = new HashMap();\n            for ( Iterator paramIterator = params.iterator(); paramIterator.hasNext(); )\n            {\n                Parameter param = (Parameter) paramIterator.next();\n                paramMap.put( param.getName(), param );\n            }\n            \n            assertNotNull( \"Mojo descriptor: \" + desc.getGoal() + \" is missing 'basedir' parameter.\", paramMap.get( \"basedir\" ) );\n            assertNotNull( \"Mojo descriptor: \" + desc.getGoal() + \" is missing 'messageLevel' parameter.\", paramMap.get( \"messageLevel\" ) );\n            assertNotNull( \"Mojo descriptor: \" + desc.getGoal() + \" is missing 'project' parameter.\", paramMap.get( \"project\" ) );\n            assertNotNull( \"Mojo descriptor: \" + desc.getGoal() + \" is missing 'session' parameter.\", paramMap.get( \"session\" ) );\n            assertNotNull( \"Mojo descriptor: \" + desc.getGoal() + \" is missing 'mojoExecution' parameter.\", paramMap.get( \"mojoExecution\" ) );\n            \n            List components = desc.getRequirements();\n\n            assertNotNull( components );\n            assertEquals( 1, components.size() );\n            \n            ComponentRequirement req = (ComponentRequirement) components.get( 0 );\n            assertEquals( \"Mojo descriptor: \" + desc.getGoal() + \" is missing 'PathTranslator' component requirement.\", PathTranslator.class.getName(), req.getRole() );\n        }\n    }\n    \n    private Map buildTestMap( String resourceDirName )\n    {\n        Map result = new HashMap();\n        \n        ClassLoader cloader = Thread.currentThread().getContextClassLoader();\n        URL mojosXmlUrl = cloader.getResource( resourceDirName + \"/test.mojos.xml\" );\n        \n        if ( mojosXmlUrl == null )\n        {\n            fail( \"No classpath resource named: '\" + resourceDirName + \"/test.mojos.xml' could be found.\" );\n        }\n        \n        File mojosXml = new File( StringUtils.replace( mojosXmlUrl.getPath(), \"%20\", \" \" ) );\n        File dir = mojosXml.getParentFile();\n        \n        Set scripts = new HashSet();\n        String[] listing = dir.list();\n        for ( int i = 0; listing != null && i < listing.length; i++ )\n        {\n            if ( listing[i].endsWith( \".mojos.xml\" ) )\n            {\n                File f = new File( dir, listing[i] ).getAbsoluteFile();\n                \n                scripts.add( f );\n            }\n        }\n        \n        result.put( dir.getAbsolutePath(), scripts );\n        \n        return result;\n    }\n    \n    // TODO\n\n}\n","lineNo":42}
{"Refactored Sample":"package org.apache.maven.tools.plugin.extractor.java;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport com.thoughtworks.qdox.JavaDocBuilder;\nimport com.thoughtworks.qdox.model.DocletTag;\nimport com.thoughtworks.qdox.model.JavaClass;\nimport com.thoughtworks.qdox.model.JavaField;\nimport com.thoughtworks.qdox.model.Type;\n\nimport org.apache.maven.plugin.descriptor.InvalidParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\n\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\n/**\n * Extracts Mojo descriptors from <a href=\"http://java.sun.com/\">Java<\/a> sources.\n * <br/>\n * For more information about the usage tag, have a look to:\n * <a href=\"http://maven.apache.org/developers/mojo-api-specification.html\">\n * http://maven.apache.org/developers/mojo-api-specification.html<\/a>\n *\n * @todo need to add validation directives so that systems embedding maven2 can\n * get validation directives to help users in IDEs.\n * @version $Id$\n * @see org.apache.maven.plugin.descriptor.MojoDescriptor\n */\npublic class JavaMojoDescriptorExtractor\n    extends AbstractLogEnabled\n    implements MojoDescriptorExtractor, JavaMojoAnnotation\n{\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#INSTANTIATION_STRATEGY} instead of. */\n    public static final String MAVEN_PLUGIN_INSTANTIATION = JavaMojoAnnotation.INSTANTIATION_STRATEGY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#CONFIGURATOR} instead of. */\n    public static final String CONFIGURATOR = JavaMojoAnnotation.CONFIGURATOR;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER} instead of. */\n    public static final String PARAMETER = JavaMojoAnnotation.PARAMETER;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_EXPRESSION} instead of. */\n    public static final String PARAMETER_EXPRESSION = JavaMojoAnnotation.PARAMETER_EXPRESSION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_DEFAULT_VALUE} instead of. */\n    public static final String PARAMETER_DEFAULT_VALUE = JavaMojoAnnotation.PARAMETER_DEFAULT_VALUE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_ALIAS} instead of. */\n    public static final String PARAMETER_ALIAS = JavaMojoAnnotation.PARAMETER_ALIAS;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#SINCE} instead of. */\n    public static final String SINCE = JavaMojoAnnotation.SINCE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_IMPLEMENTATION} instead of. */\n    public static final String PARAMETER_IMPLEMENTATION = JavaMojoAnnotation.PARAMETER_IMPLEMENTATION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_PROPERTY} instead of. */\n    public static final String PARAMETER_PROPERTY = JavaMojoAnnotation.PARAMETER_PROPERTY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRED} instead of. */\n    public static final String REQUIRED = JavaMojoAnnotation.REQUIRED;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#DEPRECATED} instead of. */\n    public static final String DEPRECATED = JavaMojoAnnotation.DEPRECATED;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#READONLY} instead of. */\n    public static final String READONLY = JavaMojoAnnotation.READONLY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#GOAL} instead of. */\n    public static final String GOAL = JavaMojoAnnotation.GOAL;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PHASE} instead of. */\n    public static final String PHASE = JavaMojoAnnotation.PHASE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE} instead of. */\n    public static final String EXECUTE = JavaMojoAnnotation.EXECUTE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE_LIFECYCLE} instead of. */\n    public static final String EXECUTE_LIFECYCLE = JavaMojoAnnotation.EXECUTE_LIFECYCLE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE_PHASE} instead of. */\n    public static final String EXECUTE_PHASE = JavaMojoAnnotation.EXECUTE_PHASE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE_GOAL} instead of. */\n    public static final String EXECUTE_GOAL = JavaMojoAnnotation.EXECUTE_GOAL;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#DESCRIPTION} instead of. */\n    public static final String GOAL_DESCRIPTION = JavaMojoAnnotation.DESCRIPTION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_DEPENDENCY_RESOLUTION} instead of. */\n    public static final String GOAL_REQUIRES_DEPENDENCY_RESOLUTION = JavaMojoAnnotation.REQUIRES_DEPENDENCY_RESOLUTION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_PROJECT} instead of. */\n    public static final String GOAL_REQUIRES_PROJECT = JavaMojoAnnotation.REQUIRES_PROJECT;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_REPORTS} instead of. */\n    public static final String GOAL_REQUIRES_REPORTS = JavaMojoAnnotation.REQUIRES_REPORTS;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#AGGREGATOR} instead of. */\n    public static final String GOAL_IS_AGGREGATOR = JavaMojoAnnotation.AGGREGATOR;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_ONLINE} instead of. */\n    public static final String GOAL_REQUIRES_ONLINE = JavaMojoAnnotation.REQUIRES_ONLINE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#INHERIT_BY_DEFAULT} instead of. */\n    public static final String GOAL_INHERIT_BY_DEFAULT = JavaMojoAnnotation.INHERIT_BY_DEFAULT;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#MULTI_EXECUTION_STRATEGY} instead of. */\n    public static final String GOAL_MULTI_EXECUTION_STRATEGY = JavaMojoAnnotation.MULTI_EXECUTION_STRATEGY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_DIRECT_INVOCATION} instead of. */\n    public static final String GOAL_REQUIRES_DIRECT_INVOCATION = JavaMojoAnnotation.REQUIRES_DIRECT_INVOCATION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#COMPONENT} instead of. */\n    public static final String COMPONENT = JavaMojoAnnotation.COMPONENT;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#COMPONENT_ROLE} instead of. */\n    public static final String COMPONENT_ROLE = JavaMojoAnnotation.COMPONENT_ROLE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#COMPONENT_ROLEHINT} instead of. */\n    public static final String COMPONENT_ROLEHINT = JavaMojoAnnotation.COMPONENT_ROLEHINT;\n\n    /**\n     * @param parameter not null\n     * @param i positive number\n     * @throws InvalidParameterException if any\n     */\n    protected void validateParameter( Parameter parameter, int i )\n        throws InvalidParameterException\n    {\n        // TODO: remove when backward compatibility is no longer an issue.\n        String name = parameter.getName();\n\n        if ( name == null )\n        {\n            throw new InvalidParameterException( \"name\", i );\n        }\n\n        // TODO: remove when backward compatibility is no longer an issue.\n        String type = parameter.getType();\n\n        if ( type == null )\n        {\n            throw new InvalidParameterException( \"type\", i );\n        }\n\n        // TODO: remove when backward compatibility is no longer an issue.\n        String description = parameter.getDescription();\n\n        if ( description == null )\n        {\n            throw new InvalidParameterException( \"description\", i );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    // Mojo descriptor creation from @tags\n    // ----------------------------------------------------------------------\n\n    /**\n     * @param javaClass not null\n     * @return a mojo descriptor\n     * @throws InvalidPluginDescriptorException if any\n     */\n    protected MojoDescriptor createMojoDescriptor( JavaClass javaClass )\n        throws InvalidPluginDescriptorException\n    {\n        MojoDescriptor mojoDescriptor = new MojoDescriptor();\n        mojoDescriptor.setLanguage( \"java\" );\n        mojoDescriptor.setImplementation( javaClass.getFullyQualifiedName() );\n        mojoDescriptor.setDescription( javaClass.getComment() );\n\n        // ----------------------------------------------------------------------\n        // Mojo annotations in alphabetical order\n        // ----------------------------------------------------------------------\n\n        // Aggregator flag\n        DocletTag aggregator = findInClassHierarchy( javaClass, JavaMojoAnnotation.AGGREGATOR );\n        if ( aggregator != null )\n        {\n            mojoDescriptor.setAggregator( true );\n        }\n\n        // Configurator hint\n        DocletTag configurator = findInClassHierarchy( javaClass, JavaMojoAnnotation.CONFIGURATOR );\n        if ( configurator != null )\n        {\n            mojoDescriptor.setComponentConfigurator( configurator.getValue() );\n        }\n\n        // Additional phase to execute first\n        DocletTag execute = findInClassHierarchy( javaClass, JavaMojoAnnotation.EXECUTE );\n        if ( execute != null )\n        {\n            String executePhase = execute.getNamedParameter( JavaMojoAnnotation.EXECUTE_PHASE );\n            String executeGoal = execute.getNamedParameter( JavaMojoAnnotation.EXECUTE_GOAL );\n\n            if ( executePhase == null && executeGoal == null )\n            {\n                throw new InvalidPluginDescriptorException( \"@execute tag requires a 'phase' or 'goal' parameter\" );\n            }\n            else if ( executePhase != null && executeGoal != null )\n            {\n                throw new InvalidPluginDescriptorException(\n                    \"@execute tag can have only one of a 'phase' or 'goal' parameter\" );\n            }\n            mojoDescriptor.setExecutePhase( executePhase );\n            mojoDescriptor.setExecuteGoal( executeGoal );\n\n            String lifecycle = execute.getNamedParameter( JavaMojoAnnotation.EXECUTE_LIFECYCLE );\n            if ( lifecycle != null )\n            {\n                mojoDescriptor.setExecuteLifecycle( lifecycle );\n                if ( mojoDescriptor.getExecuteGoal() != null )\n                {\n                    throw new InvalidPluginDescriptorException(\n                        \"@execute lifecycle requires a phase instead of a goal\" );\n                }\n            }\n        }\n\n        // Goal name\n        DocletTag goal = findInClassHierarchy( javaClass, JavaMojoAnnotation.GOAL );\n        if ( goal != null )\n        {\n            mojoDescriptor.setGoal( goal.getValue() );\n        }\n\n        // inheritByDefault flag\n        boolean value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.INHERIT_BY_DEFAULT,\n                                mojoDescriptor.isInheritedByDefault() );\n        mojoDescriptor.setInheritedByDefault( value );\n\n        // instantiationStrategy\n        DocletTag tag = findInClassHierarchy( javaClass, JavaMojoAnnotation.INSTANTIATION_STRATEGY );\n        if ( tag != null )\n        {\n            mojoDescriptor.setInstantiationStrategy( tag.getValue() );\n        }\n        tag = findInClassHierarchy( javaClass, JavaMojoAnnotation.MULTI_EXECUTION_STRATEGY );\n        if ( tag != null )\n        {\n            mojoDescriptor.setExecutionStrategy( MojoDescriptor.MULTI_PASS_EXEC_STRATEGY );\n        }\n        else\n        {\n            mojoDescriptor.setExecutionStrategy( MojoDescriptor.SINGLE_PASS_EXEC_STRATEGY );\n        }\n\n        // Phase name\n        DocletTag phase = findInClassHierarchy( javaClass, JavaMojoAnnotation.PHASE );\n        if ( phase != null )\n        {\n            mojoDescriptor.setPhase( phase.getValue() );\n        }\n\n        // Dependency resolution flag\n        DocletTag requiresDependencyResolution =\n            findInClassHierarchy( javaClass, JavaMojoAnnotation.REQUIRES_DEPENDENCY_RESOLUTION );\n        if ( requiresDependencyResolution != null )\n        {\n            String v = requiresDependencyResolution.getValue();\n\n            if ( StringUtils.isEmpty( v ) )\n            {\n                v = \"runtime\";\n            }\n\n            mojoDescriptor.setDependencyResolutionRequired( v );\n        }\n\n        // requiresDirectInvocation flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_DIRECT_INVOCATION,\n                                mojoDescriptor.isDirectInvocationOnly() );\n        mojoDescriptor.setDirectInvocationOnly( value );\n\n        // Online flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_ONLINE, mojoDescriptor.isOnlineRequired() );\n        mojoDescriptor.setOnlineRequired( value );\n\n        // Project flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_PROJECT, mojoDescriptor.isProjectRequired() );\n        mojoDescriptor.setProjectRequired( value );\n\n        // requiresReports flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_REPORTS, mojoDescriptor.isRequiresReports() );\n        mojoDescriptor.setRequiresReports( value );\n\n        // ----------------------------------------------------------------------\n        // Javadoc annotations in alphabetical order\n        // ----------------------------------------------------------------------\n\n        // Deprecation hint\n        DocletTag deprecated = javaClass.getTagByName( JavaMojoAnnotation.DEPRECATED );\n        if ( deprecated != null )\n        {\n            mojoDescriptor.setDeprecated( deprecated.getValue() );\n        }\n\n        // What version it was introduced in\n        DocletTag since = findInClassHierarchy( javaClass, JavaMojoAnnotation.SINCE );\n        if ( since != null )\n        {\n            mojoDescriptor.setSince( since.getValue() );\n        }\n\n        extractParameters( mojoDescriptor, javaClass );\n\n        return mojoDescriptor;\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName not null\n     * @param defaultValue the wanted default value\n     * @return the boolean value of the given tagName\n     * @see #findInClassHierarchy(JavaClass, String)\n     */\n    private static boolean getBooleanTagValue( JavaClass javaClass, String tagName, boolean defaultValue )\n    {\n        DocletTag tag = findInClassHierarchy( javaClass, tagName );\n\n        if ( tag != null )\n        {\n            String value = tag.getValue();\n\n            if ( StringUtils.isNotEmpty( value ) )\n            {\n                defaultValue = Boolean.valueOf( value ).booleanValue();\n            }\n        }\n        return defaultValue;\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName not null\n     * @return docletTag instance\n     */\n    private static DocletTag findInClassHierarchy( JavaClass javaClass, String tagName )\n    {\n        DocletTag tag = javaClass.getTagByName( tagName );\n\n        if ( tag == null )\n        {\n            JavaClass superClass = javaClass.getSuperJavaClass();\n\n            if ( superClass != null )\n            {\n                tag = findInClassHierarchy( superClass, tagName );\n            }\n        }\n\n        return tag;\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @param javaClass not null\n     * @throws InvalidPluginDescriptorException if any\n     */\n    private void extractParameters( MojoDescriptor mojoDescriptor, JavaClass javaClass )\n        throws InvalidPluginDescriptorException\n    {\n        // ---------------------------------------------------------------------------------\n        // We're resolving class-level, ancestor-class-field, local-class-field order here.\n        // ---------------------------------------------------------------------------------\n\n        Map rawParams = extractFieldParameterTags( javaClass );\n\n        for ( Iterator it = rawParams.entrySet().iterator(); it.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) it.next();\n\n            JavaField field = (JavaField) entry.getValue();\n\n            Type type = field.getType();\n\n            Parameter pd = new Parameter();\n\n            if ( !type.isArray() )\n            {\n                pd.setType( type.getValue() );\n            }\n            else\n            {\n                StringBuffer value = new StringBuffer( type.getValue() );\n\n                int remaining = type.getDimensions();\n\n                while ( remaining-- > 0 )\n                {\n                    value.append( \"[]\" );\n                }\n\n                pd.setType( value.toString() );\n            }\n\n            pd.setDescription( field.getComment() );\n\n            DocletTag componentTag = field.getTagByName( JavaMojoAnnotation.COMPONENT );\n            if ( componentTag != null )\n            {\n                String role = componentTag.getNamedParameter( JavaMojoAnnotation.COMPONENT_ROLE );\n\n                if ( role == null )\n                {\n                    role = field.getType().toString();\n                }\n\n                String roleHint = componentTag.getNamedParameter( JavaMojoAnnotation.COMPONENT_ROLEHINT );\n\n                if ( roleHint == null )\n                {\n                    // support alternate syntax for better compatibility with the Plexus CDC.\n                    roleHint = componentTag.getNamedParameter( \"role-hint\" );\n                }\n\n                pd.setRequirement( new Requirement( role, roleHint ) );\n\n                pd.setName( (String) entry.getKey() );\n\n                pd.setEditable( false );\n                /* TODO: or better like this? Need @component fields be editable for the user?\n                pd.setEditable( field.getTagByName( READONLY ) == null );\n                */\n            }\n            else\n            {\n                DocletTag parameter = field.getTagByName( JavaMojoAnnotation.PARAMETER );\n\n                // ----------------------------------------------------------------------\n                // We will look for a property name here first and use that if present\n                // i.e:\n                //\n                // @parameter property=\"project\"\n                //\n                // Which will become the name used for the configuration element which\n                // will in turn will allow plexus to use the corresponding setter.\n                // ----------------------------------------------------------------------\n\n                String property = parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_PROPERTY );\n\n                if ( !StringUtils.isEmpty( property ) )\n                {\n                    pd.setName( property );\n                }\n                else\n                {\n                    pd.setName( (String) entry.getKey() );\n                }\n\n                pd.setRequired( field.getTagByName( JavaMojoAnnotation.REQUIRED ) != null );\n\n                pd.setEditable( field.getTagByName( JavaMojoAnnotation.READONLY ) == null );\n\n                DocletTag deprecationTag = field.getTagByName( JavaMojoAnnotation.DEPRECATED );\n\n                if ( deprecationTag != null )\n                {\n                    pd.setDeprecated( deprecationTag.getValue() );\n                }\n\n                DocletTag sinceTag = field.getTagByName( JavaMojoAnnotation.SINCE );\n                if ( sinceTag != null )\n                {\n                    pd.setSince( sinceTag.getValue() );\n                }\n\n                String alias = parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_ALIAS );\n\n                if ( !StringUtils.isEmpty( alias ) )\n                {\n                    pd.setAlias( alias );\n                }\n\n                String expression = parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_EXPRESSION );\n                pd.setExpression( expression );\n\n                if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${component.\" ) )\n                {\n                    getLogger().warn( javaClass.getFullyQualifiedName() + \"#\" + field.getName() + \":\" );\n                    getLogger().warn( \"  The syntax\" );\n                    getLogger().warn( \"    @parameter expression=\\\"${component.<role>#<roleHint>}\\\"\" );\n                    getLogger().warn( \"  is deprecated, please use\" );\n                    getLogger().warn( \"    @component role=\\\"<role>\\\" roleHint=\\\"<roleHint>\\\"\" );\n                    getLogger().warn( \"  instead.\" );\n                }\n\n                if ( \"${reports}\".equals( pd.getExpression() ) )\n                {\n                    mojoDescriptor.setRequiresReports( true );\n                }\n\n                pd.setDefaultValue( parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_DEFAULT_VALUE ) );\n\n                pd.setImplementation( parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_IMPLEMENTATION ) );\n            }\n\n            mojoDescriptor.addParameter( pd );\n        }\n    }\n\n    /**\n     * @param javaClass not null\n     * @return map with Mojo parameters names as keys\n     */\n    private Map extractFieldParameterTags( JavaClass javaClass )\n    {\n        Map rawParams;\n\n        // we have to add the parent fields first, so that they will be overwritten by the local fields if\n        // that actually happens...\n        JavaClass superClass = javaClass.getSuperJavaClass();\n\n        if ( superClass != null )\n        {\n            rawParams = extractFieldParameterTags( superClass );\n        }\n        else\n        {\n            rawParams = new TreeMap();\n        }\n\n        JavaField[] classFields = javaClass.getFields();\n\n        if ( classFields != null )\n        {\n            for ( int i = 0; i < classFields.length; i++ )\n            {\n                JavaField field = classFields[i];\n\n                if ( field.getTagByName( JavaMojoAnnotation.PARAMETER ) != null\n                    || field.getTagByName( JavaMojoAnnotation.COMPONENT ) != null )\n                {\n                    rawParams.put( field.getName(), field );\n                }\n            }\n        }\n        return rawParams;\n    }\n\n    /** {@inheritDoc} */\n    public List execute( MavenProject project, PluginDescriptor pluginDescriptor )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        JavaClass[] javaClasses = discoverClasses( project );\n\n        List descriptors = new ArrayList();\n\n        for ( int i = 0; i < javaClasses.length; i++ )\n        {\n            DocletTag tag = javaClasses[i].getTagByName( GOAL );\n\n            if ( tag != null )\n            {\n                MojoDescriptor mojoDescriptor = createMojoDescriptor( javaClasses[i] );\n                mojoDescriptor.setPluginDescriptor( pluginDescriptor );\n\n                // Validate the descriptor as best we can before allowing it to be processed.\n                validate( mojoDescriptor );\n\n                descriptors.add( mojoDescriptor );\n            }\n        }\n\n        return descriptors;\n    }\n\n    /**\n     * @param project not null\n     * @return an array of java class\n     */\n    protected JavaClass[] discoverClasses( final MavenProject project )\n    {\n        JavaDocBuilder builder = new JavaDocBuilder();\n\n        for ( Iterator i = project.getCompileSourceRoots().iterator(); i.hasNext(); )\n        {\n            builder.addSourceTree( new File( (String) i.next() ) );\n        }\n\n        // TODO be more dynamic\n        if ( !project.getCompileSourceRoots()\n            .contains( new File( project.getBasedir(), \"target/generated-sources/plugin\" ).getAbsolutePath() ) )\n        {\n            builder.addSourceTree( new File( project.getBasedir(), \"target/generated-sources/plugin\" ) );\n        }\n\n        return builder.getClasses();\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @throws InvalidParameterException if any\n     */\n    protected void validate( MojoDescriptor mojoDescriptor )\n        throws InvalidParameterException\n    {\n        List parameters = mojoDescriptor.getParameters();\n\n        if ( parameters != null )\n        {\n            for ( int j = 0; j < parameters.size(); j++ )\n            {\n                validateParameter( (Parameter) parameters.get( j ), j );\n            }\n        }\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.extractor.java;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport com.thoughtworks.qdox.JavaDocBuilder;\nimport com.thoughtworks.qdox.model.DocletTag;\nimport com.thoughtworks.qdox.model.JavaClass;\nimport com.thoughtworks.qdox.model.JavaField;\nimport com.thoughtworks.qdox.model.Type;\n\nimport org.apache.maven.plugin.descriptor.InvalidParameterException;\nimport org.apache.maven.plugin.descriptor.InvalidPluginDescriptorException;\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.plugin.descriptor.Requirement;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.extractor.MojoDescriptorExtractor;\nimport org.apache.maven.tools.plugin.extractor.ExtractionException;\n\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\n/**\n * Extracts Mojo descriptors from <a href=\"http://java.sun.com/\">Java<\/a> sources.\n * <br/>\n * For more information about the usage tag, have a look to:\n * <a href=\"http://maven.apache.org/developers/mojo-api-specification.html\">\n * http://maven.apache.org/developers/mojo-api-specification.html<\/a>\n *\n * @todo need to add validation directives so that systems embedding maven2 can\n * get validation directives to help users in IDEs.\n * @version $Id$\n * @see org.apache.maven.plugin.descriptor.MojoDescriptor\n */\npublic class JavaMojoDescriptorExtractor\n    extends AbstractLogEnabled\n    implements MojoDescriptorExtractor, JavaMojoAnnotation\n{\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#INSTANTIATION_STRATEGY} instead of. */\n    public static final String MAVEN_PLUGIN_INSTANTIATION = JavaMojoAnnotation.INSTANTIATION_STRATEGY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#CONFIGURATOR} instead of. */\n    public static final String CONFIGURATOR = JavaMojoAnnotation.CONFIGURATOR;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER} instead of. */\n    public static final String PARAMETER = JavaMojoAnnotation.PARAMETER;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_EXPRESSION} instead of. */\n    public static final String PARAMETER_EXPRESSION = JavaMojoAnnotation.PARAMETER_EXPRESSION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_DEFAULT_VALUE} instead of. */\n    public static final String PARAMETER_DEFAULT_VALUE = JavaMojoAnnotation.PARAMETER_DEFAULT_VALUE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_ALIAS} instead of. */\n    public static final String PARAMETER_ALIAS = JavaMojoAnnotation.PARAMETER_ALIAS;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#SINCE} instead of. */\n    public static final String SINCE = JavaMojoAnnotation.SINCE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_IMPLEMENTATION} instead of. */\n    public static final String PARAMETER_IMPLEMENTATION = JavaMojoAnnotation.PARAMETER_IMPLEMENTATION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PARAMETER_PROPERTY} instead of. */\n    public static final String PARAMETER_PROPERTY = JavaMojoAnnotation.PARAMETER_PROPERTY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRED} instead of. */\n    public static final String REQUIRED = JavaMojoAnnotation.REQUIRED;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#DEPRECATED} instead of. */\n    public static final String DEPRECATED = JavaMojoAnnotation.DEPRECATED;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#READONLY} instead of. */\n    public static final String READONLY = JavaMojoAnnotation.READONLY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#GOAL} instead of. */\n    public static final String GOAL = JavaMojoAnnotation.GOAL;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#PHASE} instead of. */\n    public static final String PHASE = JavaMojoAnnotation.PHASE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE} instead of. */\n    public static final String EXECUTE = JavaMojoAnnotation.EXECUTE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE_LIFECYCLE} instead of. */\n    public static final String EXECUTE_LIFECYCLE = JavaMojoAnnotation.EXECUTE_LIFECYCLE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE_PHASE} instead of. */\n    public static final String EXECUTE_PHASE = JavaMojoAnnotation.EXECUTE_PHASE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#EXECUTE_GOAL} instead of. */\n    public static final String EXECUTE_GOAL = JavaMojoAnnotation.EXECUTE_GOAL;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#DESCRIPTION} instead of. */\n    public static final String GOAL_DESCRIPTION = JavaMojoAnnotation.DESCRIPTION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_DEPENDENCY_RESOLUTION} instead of. */\n    public static final String GOAL_REQUIRES_DEPENDENCY_RESOLUTION = JavaMojoAnnotation.REQUIRES_DEPENDENCY_RESOLUTION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_PROJECT} instead of. */\n    public static final String GOAL_REQUIRES_PROJECT = JavaMojoAnnotation.REQUIRES_PROJECT;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_REPORTS} instead of. */\n    public static final String GOAL_REQUIRES_REPORTS = JavaMojoAnnotation.REQUIRES_REPORTS;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#AGGREGATOR} instead of. */\n    public static final String GOAL_IS_AGGREGATOR = JavaMojoAnnotation.AGGREGATOR;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_ONLINE} instead of. */\n    public static final String GOAL_REQUIRES_ONLINE = JavaMojoAnnotation.REQUIRES_ONLINE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#INHERIT_BY_DEFAULT} instead of. */\n    public static final String GOAL_INHERIT_BY_DEFAULT = JavaMojoAnnotation.INHERIT_BY_DEFAULT;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#MULTI_EXECUTION_STRATEGY} instead of. */\n    public static final String GOAL_MULTI_EXECUTION_STRATEGY = JavaMojoAnnotation.MULTI_EXECUTION_STRATEGY;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#REQUIRES_DIRECT_INVOCATION} instead of. */\n    public static final String GOAL_REQUIRES_DIRECT_INVOCATION = JavaMojoAnnotation.REQUIRES_DIRECT_INVOCATION;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#COMPONENT} instead of. */\n    public static final String COMPONENT = JavaMojoAnnotation.COMPONENT;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#COMPONENT_ROLE} instead of. */\n    public static final String COMPONENT_ROLE = JavaMojoAnnotation.COMPONENT_ROLE;\n\n    /** @deprecated since 2.4, use {@link JavaMojoAnnotation#COMPONENT_ROLEHINT} instead of. */\n    public static final String COMPONENT_ROLEHINT = JavaMojoAnnotation.COMPONENT_ROLEHINT;\n\n    /**\n     * @param parameter not null\n     * @param i positive number\n     * @throws InvalidParameterException if any\n     */\n    protected void validateParameter( Parameter parameter, int i )\n        throws InvalidParameterException\n    {\n        // TODO: remove when backward compatibility is no longer an issue.\n        String name = parameter.getName();\n\n        if ( name == null )\n        {\n            throw new InvalidParameterException( \"name\", i );\n        }\n\n        // TODO: remove when backward compatibility is no longer an issue.\n        String type = parameter.getType();\n\n        if ( type == null )\n        {\n            throw new InvalidParameterException( \"type\", i );\n        }\n\n        // TODO: remove when backward compatibility is no longer an issue.\n        String description = parameter.getDescription();\n\n        if ( description == null )\n        {\n            throw new InvalidParameterException( \"description\", i );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    // Mojo descriptor creation from @tags\n    // ----------------------------------------------------------------------\n\n    /**\n     * @param javaClass not null\n     * @return a mojo descriptor\n     * @throws InvalidPluginDescriptorException if any\n     */\n    protected MojoDescriptor createMojoDescriptor( JavaClass javaClass )\n        throws InvalidPluginDescriptorException\n    {\n        MojoDescriptor mojoDescriptor = new MojoDescriptor();\n        mojoDescriptor.setLanguage( \"java\" );\n        mojoDescriptor.setImplementation( javaClass.getFullyQualifiedName() );\n        mojoDescriptor.setDescription( javaClass.getComment() );\n\n        // ----------------------------------------------------------------------\n        // Mojo annotations in alphabetical order\n        // ----------------------------------------------------------------------\n\n        // Aggregator flag\n        DocletTag aggregator = findInClassHierarchy( javaClass, JavaMojoAnnotation.AGGREGATOR );\n        if ( aggregator != null )\n        {\n            mojoDescriptor.setAggregator( true );\n        }\n\n        // Configurator hint\n        DocletTag configurator = findInClassHierarchy( javaClass, JavaMojoAnnotation.CONFIGURATOR );\n        if ( configurator != null )\n        {\n            mojoDescriptor.setComponentConfigurator( configurator.getValue() );\n        }\n\n        // Additional phase to execute first\n        DocletTag execute = findInClassHierarchy( javaClass, JavaMojoAnnotation.EXECUTE );\n        if ( execute != null )\n        {\n            String executePhase = execute.getNamedParameter( JavaMojoAnnotation.EXECUTE_PHASE );\n            String executeGoal = execute.getNamedParameter( JavaMojoAnnotation.EXECUTE_GOAL );\n\n            if ( executePhase == null && executeGoal == null )\n            {\n                throw new InvalidPluginDescriptorException( \"@execute tag requires a 'phase' or 'goal' parameter\" );\n            }\n            else if ( executePhase != null && executeGoal != null )\n            {\n                throw new InvalidPluginDescriptorException(\n                    \"@execute tag can have only one of a 'phase' or 'goal' parameter\" );\n            }\n            mojoDescriptor.setExecutePhase( executePhase );\n            mojoDescriptor.setExecuteGoal( executeGoal );\n\n            String lifecycle = execute.getNamedParameter( JavaMojoAnnotation.EXECUTE_LIFECYCLE );\n            if ( lifecycle != null )\n            {\n                mojoDescriptor.setExecuteLifecycle( lifecycle );\n                if ( mojoDescriptor.getExecuteGoal() != null )\n                {\n                    throw new InvalidPluginDescriptorException(\n                        \"@execute lifecycle requires a phase instead of a goal\" );\n                }\n            }\n        }\n\n        // Goal name\n        DocletTag goal = findInClassHierarchy( javaClass, JavaMojoAnnotation.GOAL );\n        if ( goal != null )\n        {\n            mojoDescriptor.setGoal( goal.getValue() );\n        }\n\n        // inheritByDefault flag\n        boolean value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.INHERIT_BY_DEFAULT,\n                                mojoDescriptor.isInheritedByDefault() );\n        mojoDescriptor.setInheritedByDefault( value );\n\n        // instantiationStrategy\n        DocletTag tag = findInClassHierarchy( javaClass, JavaMojoAnnotation.INSTANTIATION_STRATEGY );\n        if ( tag != null )\n        {\n            mojoDescriptor.setInstantiationStrategy( tag.getValue() );\n        }\n        tag = findInClassHierarchy( javaClass, JavaMojoAnnotation.MULTI_EXECUTION_STRATEGY );\n        if ( tag != null )\n        {\n            mojoDescriptor.setExecutionStrategy( MojoDescriptor.MULTI_PASS_EXEC_STRATEGY );\n        }\n        else\n        {\n            mojoDescriptor.setExecutionStrategy( MojoDescriptor.SINGLE_PASS_EXEC_STRATEGY );\n        }\n\n        // Phase name\n        DocletTag phase = findInClassHierarchy( javaClass, JavaMojoAnnotation.PHASE );\n        if ( phase != null )\n        {\n            mojoDescriptor.setPhase( phase.getValue() );\n        }\n\n        // Dependency resolution flag\n        DocletTag requiresDependencyResolution =\n            findInClassHierarchy( javaClass, JavaMojoAnnotation.REQUIRES_DEPENDENCY_RESOLUTION );\n        if ( requiresDependencyResolution != null )\n        {\n            String v = requiresDependencyResolution.getValue();\n\n            if ( StringUtils.isEmpty( v ) )\n            {\n                v = \"runtime\";\n            }\n\n            mojoDescriptor.setDependencyResolutionRequired( v );\n        }\n\n        // requiresDirectInvocation flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_DIRECT_INVOCATION,\n                                mojoDescriptor.isDirectInvocationOnly() );\n        mojoDescriptor.setDirectInvocationOnly( value );\n\n        // Online flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_ONLINE, mojoDescriptor.isOnlineRequired() );\n        mojoDescriptor.setOnlineRequired( value );\n\n        // Project flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_PROJECT, mojoDescriptor.isProjectRequired() );\n        mojoDescriptor.setProjectRequired( value );\n\n        // requiresReports flag\n        value =\n            getBooleanTagValue( javaClass, JavaMojoAnnotation.REQUIRES_REPORTS, mojoDescriptor.isRequiresReports() );\n        mojoDescriptor.setRequiresReports( value );\n\n        // ----------------------------------------------------------------------\n        // Javadoc annotations in alphabetical order\n        // ----------------------------------------------------------------------\n\n        // Deprecation hint\n        DocletTag deprecated = javaClass.getTagByName( JavaMojoAnnotation.DEPRECATED );\n        if ( deprecated != null )\n        {\n            mojoDescriptor.setDeprecated( deprecated.getValue() );\n        }\n\n        // What version it was introduced in\n        DocletTag since = findInClassHierarchy( javaClass, JavaMojoAnnotation.SINCE );\n        if ( since != null )\n        {\n            mojoDescriptor.setSince( since.getValue() );\n        }\n\n        extractParameters( mojoDescriptor, javaClass );\n\n        return mojoDescriptor;\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName not null\n     * @param defaultValue the wanted default value\n     * @return the boolean value of the given tagName\n     * @see #findInClassHierarchy(JavaClass, String)\n     */\n    private static boolean getBooleanTagValue( JavaClass javaClass, String tagName, boolean defaultValue )\n    {\n        DocletTag tag = findInClassHierarchy( javaClass, tagName );\n\n        if ( tag != null )\n        {\n            String value = tag.getValue();\n\n            if ( StringUtils.isNotEmpty( value ) )\n            {\n                defaultValue = Boolean.valueOf( value ).booleanValue();\n            }\n        }\n        return defaultValue;\n    }\n\n    /**\n     * @param javaClass not null\n     * @param tagName not null\n     * @return docletTag instance\n     */\n    private static DocletTag findInClassHierarchy( JavaClass javaClass, String tagName )\n    {\n        DocletTag tag = javaClass.getTagByName( tagName );\n\n        if ( tag == null )\n        {\n            JavaClass superClass = javaClass.getSuperJavaClass();\n\n            if ( superClass != null )\n            {\n                tag = findInClassHierarchy( superClass, tagName );\n            }\n        }\n\n        return tag;\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @param javaClass not null\n     * @throws InvalidPluginDescriptorException if any\n     */\n    private void extractParameters( MojoDescriptor mojoDescriptor, JavaClass javaClass )\n        throws InvalidPluginDescriptorException\n    {\n        // ---------------------------------------------------------------------------------\n        // We're resolving class-level, ancestor-class-field, local-class-field order here.\n        // ---------------------------------------------------------------------------------\n\n        Map rawParams = extractFieldParameterTags( javaClass );\n\n        for ( Iterator it = rawParams.entrySet().iterator(); it.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) it.next();\n\n            JavaField field = (JavaField) entry.getValue();\n\n            Type type = field.getType();\n\n            Parameter pd = new Parameter();\n\n            if ( !type.isArray() )\n            {\n                pd.setType( type.getValue() );\n            }\n            else\n            {\n                StringBuffer value = new StringBuffer( type.getValue() );\n\n                int remaining = type.getDimensions();\n\n                while ( remaining-- > 0 )\n                {\n                    value.append( \"[]\" );\n                }\n\n                pd.setType( value.toString() );\n            }\n\n            pd.setDescription( field.getComment() );\n\n            DocletTag componentTag = field.getTagByName( JavaMojoAnnotation.COMPONENT );\n            if ( componentTag != null )\n            {\n                String role = componentTag.getNamedParameter( JavaMojoAnnotation.COMPONENT_ROLE );\n\n                if ( role == null )\n                {\n                    role = field.getType().toString();\n                }\n\n                String roleHint = componentTag.getNamedParameter( JavaMojoAnnotation.COMPONENT_ROLEHINT );\n\n                if ( roleHint == null )\n                {\n                    // support alternate syntax for better compatibility with the Plexus CDC.\n                    roleHint = componentTag.getNamedParameter( \"role-hint\" );\n                }\n\n                pd.setRequirement( new Requirement( role, roleHint ) );\n\n                pd.setName( (String) entry.getKey() );\n\n                pd.setEditable( false );\n                /* TODO: or better like this? Need @component fields be editable for the user?\n                pd.setEditable( field.getTagByName( READONLY ) == null );\n                */\n            }\n            else\n            {\n                DocletTag parameter = field.getTagByName( JavaMojoAnnotation.PARAMETER );\n\n                // ----------------------------------------------------------------------\n                // We will look for a property name here first and use that if present\n                // i.e:\n                //\n                // @parameter property=\"project\"\n                //\n                // Which will become the name used for the configuration element which\n                // will in turn will allow plexus to use the corresponding setter.\n                // ----------------------------------------------------------------------\n\n                String property = parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_PROPERTY );\n\n                if ( !StringUtils.isEmpty( property ) )\n                {\n                    pd.setName( property );\n                }\n                else\n                {\n                    pd.setName( (String) entry.getKey() );\n                }\n\n                pd.setRequired( field.getTagByName( JavaMojoAnnotation.REQUIRED ) != null );\n\n                pd.setEditable( field.getTagByName( JavaMojoAnnotation.READONLY ) == null );\n\n                DocletTag deprecationTag = field.getTagByName( JavaMojoAnnotation.DEPRECATED );\n\n                if ( deprecationTag != null )\n                {\n                    pd.setDeprecated( deprecationTag.getValue() );\n                }\n\n                DocletTag sinceTag = field.getTagByName( JavaMojoAnnotation.SINCE );\n                if ( sinceTag != null )\n                {\n                    pd.setSince( sinceTag.getValue() );\n                }\n\n                String alias = parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_ALIAS );\n\n                if ( !StringUtils.isEmpty( alias ) )\n                {\n                    pd.setAlias( alias );\n                }\n\n                pd.setExpression( parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_EXPRESSION ) );\n\n                if ( \"${reports}\".equals( pd.getExpression() ) )\n                {\n                    mojoDescriptor.setRequiresReports( true );\n                }\n\n                pd.setDefaultValue( parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_DEFAULT_VALUE ) );\n\n                pd.setImplementation( parameter.getNamedParameter( JavaMojoAnnotation.PARAMETER_IMPLEMENTATION ) );\n            }\n\n            mojoDescriptor.addParameter( pd );\n        }\n    }\n\n    /**\n     * @param javaClass not null\n     * @return map with Mojo parameters names as keys\n     */\n    private Map extractFieldParameterTags( JavaClass javaClass )\n    {\n        Map rawParams;\n\n        // we have to add the parent fields first, so that they will be overwritten by the local fields if\n        // that actually happens...\n        JavaClass superClass = javaClass.getSuperJavaClass();\n\n        if ( superClass != null )\n        {\n            rawParams = extractFieldParameterTags( superClass );\n        }\n        else\n        {\n            rawParams = new TreeMap();\n        }\n\n        JavaField[] classFields = javaClass.getFields();\n\n        if ( classFields != null )\n        {\n            for ( int i = 0; i < classFields.length; i++ )\n            {\n                JavaField field = classFields[i];\n\n                if ( field.getTagByName( JavaMojoAnnotation.PARAMETER ) != null\n                    || field.getTagByName( JavaMojoAnnotation.COMPONENT ) != null )\n                {\n                    rawParams.put( field.getName(), field );\n                }\n            }\n        }\n        return rawParams;\n    }\n\n    /** {@inheritDoc} */\n    public List execute( MavenProject project, PluginDescriptor pluginDescriptor )\n        throws ExtractionException, InvalidPluginDescriptorException\n    {\n        JavaClass[] javaClasses = discoverClasses( project );\n\n        List descriptors = new ArrayList();\n\n        for ( int i = 0; i < javaClasses.length; i++ )\n        {\n            DocletTag tag = javaClasses[i].getTagByName( GOAL );\n\n            if ( tag != null )\n            {\n                MojoDescriptor mojoDescriptor = createMojoDescriptor( javaClasses[i] );\n                mojoDescriptor.setPluginDescriptor( pluginDescriptor );\n\n                // Validate the descriptor as best we can before allowing it to be processed.\n                validate( mojoDescriptor );\n\n                descriptors.add( mojoDescriptor );\n            }\n        }\n\n        return descriptors;\n    }\n\n    /**\n     * @param project not null\n     * @return an array of java class\n     */\n    protected JavaClass[] discoverClasses( final MavenProject project )\n    {\n        JavaDocBuilder builder = new JavaDocBuilder();\n\n        for ( Iterator i = project.getCompileSourceRoots().iterator(); i.hasNext(); )\n        {\n            builder.addSourceTree( new File( (String) i.next() ) );\n        }\n\n        // TODO be more dynamic\n        if ( !project.getCompileSourceRoots()\n            .contains( new File( project.getBasedir(), \"target/generated-sources/plugin\" ).getAbsolutePath() ) )\n        {\n            builder.addSourceTree( new File( project.getBasedir(), \"target/generated-sources/plugin\" ) );\n        }\n\n        return builder.getClasses();\n    }\n\n    /**\n     * @param mojoDescriptor not null\n     * @throws InvalidParameterException if any\n     */\n    protected void validate( MojoDescriptor mojoDescriptor )\n        throws InvalidParameterException\n    {\n        List parameters = mojoDescriptor.getParameters();\n\n        if ( parameters != null )\n        {\n            for ( int j = 0; j < parameters.size(); j++ )\n            {\n                validateParameter( (Parameter) parameters.get( j ), j );\n            }\n        }\n    }\n}\n","lineNo":513}
{"Refactored Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * Generates an <code>HelpMojo<\/code> class.\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    /** Line separator */\n    private static final String LS = System.getProperty( \"line.separator\" );\n\n    /** Default generated class name */\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    /** Default goal */\n    private static final String HELP_GOAL = \"help\";\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        if ( pluginDescriptor.getMojos() == null || pluginDescriptor.getMojos().size() < 1 )\n        {\n            return;\n        }\n\n        MojoDescriptor helpDescriptor = makeHelpDescriptor( pluginDescriptor );\n\n        // Verify that no help goal already exists\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            if ( descriptor.getGoal().equals( helpDescriptor.getGoal() )\n                && !descriptor.getImplementation().equals( helpDescriptor.getImplementation() ) )\n            {\n                if ( getLogger().isWarnEnabled() )\n                {\n                    getLogger().warn(\n                                      \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                          + \") already exists in this plugin. SKIPPED THE \"\n                                          + helpDescriptor.getImplementation() + \" GENERATION.\\n\" );\n                }\n\n                return;\n            }\n        }\n\n        String sourcePath = helpDescriptor.getImplementation().replace( '.', File.separatorChar ) + \".java\";\n        File helpClass = new File( destinationDirectory, sourcePath );\n        helpClass.getParentFile().mkdirs();\n\n        Writer writer = null;\n        try\n        {\n            writer = new FileWriter( helpClass );\n            writeClass( writer, pluginDescriptor, helpDescriptor );\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * Creates a minimalistic mojo descriptor for the generated help goal.\n     *\n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *            <code>null<\/code>.\n     * @return The mojo descriptor for the generated help goal, never <code>null<\/code>.\n     */\n    private static MojoDescriptor makeHelpDescriptor( PluginDescriptor pluginDescriptor )\n    {\n        MojoDescriptor descriptor = new MojoDescriptor();\n\n        descriptor.setPluginDescriptor( pluginDescriptor );\n\n        descriptor.setLanguage( \"java\" );\n\n        descriptor.setGoal( HELP_GOAL );\n\n        String packageName = discoverPackageName( pluginDescriptor );\n        if ( StringUtils.isNotEmpty( packageName ) )\n        {\n            descriptor.setImplementation( packageName + '.' + HELP_MOJO_CLASS_NAME );\n        }\n        else\n        {\n            descriptor.setImplementation( HELP_MOJO_CLASS_NAME );\n        }\n\n        descriptor.setDescription( \"Display help information on \" + pluginDescriptor.getArtifactId()\n            + \".<br/> Call <pre>  mvn \" + descriptor.getFullGoalName()\n            + \" -Ddetail=true -Dgoal=&lt;goal-name&gt;<\/pre> to display parameter details.\" );\n\n        try\n        {\n            Parameter param = new Parameter();\n            param.setName( \"detail\" );\n            param.setType( \"boolean\" );\n            param.setDescription( \"If <code>true<\/code>, display all settable properties for each goal.\" );\n            param.setDefaultValue( \"false\" );\n            param.setExpression( \"${detail}\" );\n            descriptor.addParameter( param );\n\n            param = new Parameter();\n            param.setName( \"goal\" );\n            param.setType( \"java.lang.String\" );\n            param.setDescription( \"The name of the goal for which to show help.\"\n                + \" If unspecified, all goals will be displayed.\" );\n            param.setExpression( \"${goal}\" );\n            descriptor.addParameter( param );\n\n            param = new Parameter();\n            param.setName( \"lineLength\" );\n            param.setType( \"int\" );\n            param.setDescription( \"The maximum length of a display line, should be positive.\" );\n            param.setDefaultValue( \"80\" );\n            param.setExpression( \"${lineLength}\" );\n            descriptor.addParameter( param );\n\n            param = new Parameter();\n            param.setName( \"indentSize\" );\n            param.setType( \"int\" );\n            param.setDescription( \"The number of spaces per indentation level, should be positive.\" );\n            param.setDefaultValue( \"2\" );\n            param.setExpression( \"${indentSize}\" );\n            descriptor.addParameter( param );\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( \"Failed to setup parameters for help goal\", e );\n        }\n\n        return descriptor;\n    }\n\n    /**\n     * Find the best package name, based on the number of hits of actual Mojo classes.\n     *\n     * @param pluginDescriptor not null\n     * @return the best name of the package for the generated mojo\n     */\n    private static String discoverPackageName( PluginDescriptor pluginDescriptor )\n    {\n        Map packageNames = new HashMap();\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            String impl = descriptor.getImplementation();\n            if ( impl.lastIndexOf( '.' ) != -1 )\n            {\n                String name = impl.substring( 0, impl.lastIndexOf( '.' ) );\n                if ( packageNames.get( name ) != null )\n                {\n                    int next = ( (Integer) packageNames.get( name ) ).intValue() + 1;\n                    packageNames.put( name, Integer.valueOf( \"\" + next ) );\n                }\n                else\n                {\n                    packageNames.put( name, Integer.valueOf( \"\" + 1 ) );\n                }\n            }\n            else\n            {\n                packageNames.put( \"\", Integer.valueOf( \"\" + 1 ) );\n            }\n        }\n\n        String packageName = \"\";\n        int max = 0;\n        for ( Iterator it = packageNames.keySet().iterator(); it.hasNext(); )\n        {\n            String key = it.next().toString();\n            int value = ( (Integer) packageNames.get( key ) ).intValue();\n            if ( value > max )\n            {\n                max = value;\n                packageName = key;\n            }\n        }\n\n        return packageName;\n    }\n\n    /**\n     * Generates the <code>HelpMojo<\/code> class.\n     *\n     * @param writer not null\n     * @param pluginDescriptor not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeClass( Writer writer, PluginDescriptor pluginDescriptor, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        String packageName = \"\";\n        String simpleName = helpDescriptor.getImplementation();\n        int dot = simpleName.lastIndexOf( '.' );\n        if ( dot >= 0 )\n        {\n            packageName = simpleName.substring( 0, dot );\n            simpleName = simpleName.substring( dot + 1 );\n        }\n\n        if ( packageName.length() > 0 )\n        {\n            writer.write( \"package \" + packageName + \";\" + LS );\n            writer.write( LS );\n        }\n\n        writeImports( writer );\n        writer.write( LS );\n\n        writeMojoJavadoc( writer, pluginDescriptor, helpDescriptor );\n\n        writer.write( \"public class \" + simpleName + LS );\n        writer.write( \"    extends AbstractMojo\" + LS );\n        writer.write( \"{\" + LS );\n\n        writeVariables( writer, helpDescriptor );\n\n        writer.write( LS );\n\n        writeExecute( writer, pluginDescriptor, helpDescriptor );\n\n        writer.write( LS );\n        writeUtilities( writer );\n        writer.write( \"}\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @throws IOException if any\n     */\n    private static void writeImports( Writer writer )\n        throws IOException\n    {\n        writer.write( \"import java.util.ArrayList;\" + LS );\n        writer.write( \"import java.util.Iterator;\" + LS );\n        writer.write( \"import java.util.List;\" + LS );\n        writer.write( LS );\n        writer.write( \"import org.apache.maven.plugin.AbstractMojo;\" + LS );\n        writer.write( \"import org.apache.maven.plugin.MojoExecutionException;\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param pluginDescriptor not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeMojoJavadoc( Writer writer, PluginDescriptor pluginDescriptor,\n                                          MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        StringBuffer author = new StringBuffer();\n        author.append( PluginHelpGenerator.class.getName() );\n\n        String resource = \"META-INF/maven/org.apache.maven.plugin-tools/maven-plugin-tools-api/pom.properties\";\n        InputStream resourceAsStream = PluginHelpGenerator.class.getClassLoader().getResourceAsStream( resource );\n\n        if ( resourceAsStream != null )\n        {\n            try\n            {\n                Properties properties = new Properties();\n                properties.load( resourceAsStream );\n\n                author.append( \" (version \" ).append( properties.getProperty( \"version\", \"unknown\" ) ).append( \")\" );\n            }\n            catch ( IOException e )\n            {\n                // nope\n            }\n        }\n\n        writer.write( \"/**\" + LS );\n        writer.write( \" * \" + helpDescriptor.getDescription() + LS );\n        writer.write( \" *\" + LS );\n        writer.write( \" * @version generated on \" + new Date() + LS );\n        writer.write( \" * @author \" + author.toString() + LS );\n        writer.write( \" * @goal \" + helpDescriptor.getGoal() + LS );\n        writer.write( \" * @requiresProject false\" + LS );\n        writer.write( \" */\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeVariables( Writer writer, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        for ( Iterator it = helpDescriptor.getParameters().iterator(); it.hasNext(); )\n        {\n            Parameter param = (Parameter) it.next();\n            writer.write( \"    /**\" + LS );\n            writer.write( \"     * \" + StringUtils.escape( param.getDescription() ) + LS );\n            writer.write( \"     * \" + LS );\n            writer.write( \"     * @parameter\" );\n            if ( StringUtils.isNotEmpty( param.getExpression() ) )\n            {\n                writer.write( \" expression=\\\"\" );\n                writer.write( StringUtils.escape( param.getExpression() ) );\n                writer.write( \"\\\"\" );\n            }\n            if ( StringUtils.isNotEmpty( param.getDefaultValue() ) )\n            {\n                writer.write( \" default-value=\\\"\" );\n                writer.write( StringUtils.escape( param.getDefaultValue() ) );\n                writer.write( \"\\\"\" );\n            }\n            writer.write( LS );\n            writer.write( \"     */\" + LS );\n            writer.write( \"    private \" + param.getType() + \" \" + param.getName() + \";\" + LS );\n            writer.write( LS );\n        }\n    }\n\n    /**\n     * @param writer not null\n     * @param pluginDescriptor not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeExecute( Writer writer, PluginDescriptor pluginDescriptor, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        List mojoDescriptors = new ArrayList();\n\n        mojoDescriptors.add( helpDescriptor );\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor mojoDescriptor = (MojoDescriptor) it.next();\n\n            if ( !helpDescriptor.getGoal().equals( mojoDescriptor.getGoal() ) )\n            {\n                mojoDescriptors.add( mojoDescriptor );\n            }\n        }\n\n        PluginUtils.sortMojos( mojoDescriptors );\n\n        writer.write( \"    /** {@inheritDoc} */\" + LS );\n        writer.write( \"    public void execute()\" + LS );\n        writer.write( \"        throws MojoExecutionException\" + LS );\n        writer.write( \"    {\" + LS );\n\n        writer.write( \"        if ( lineLength <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().warn( \\\"The parameter 'lineLength' should be positive, using '80' as \"\n            + \"default.\\\" );\" + LS );\n        writer.write( \"            lineLength = 80;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        if ( indentSize <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().warn( \\\"The parameter 'indentSize' should be positive, using '2' as \"\n            + \"default.\\\" );\" + LS );\n        writer.write( \"            indentSize = 2;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        StringBuffer sb = new StringBuffer();\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        append( sb, \\\"\" + StringUtils.escape( pluginDescriptor.getId() ) + \"\\\", 0 );\" + LS );\n        writer.write( \"        append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        append( sb, \\\"\"\n            + StringUtils.escape( pluginDescriptor.getName() + \" \" + pluginDescriptor.getVersion() )\n            + \"\\\", 0 );\" + LS );\n        writer.write( \"        append( sb, \\\"\" + toDescription( pluginDescriptor.getDescription() ) + \"\\\", 1 );\"\n            + LS );\n        writer.write( \"        append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        if ( goal == null || goal.length() <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            append( sb, \\\"This plugin has \" + mojoDescriptors.size() + \" \"\n            + ( mojoDescriptors.size() > 1 ? \"goals\" : \"goal\" ) + \":\\\", 0 );\" + LS );\n        writer.write( \"            append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( \"        }\" + LS );\n\n        writer.write( LS );\n\n        Collections.sort( mojoDescriptors, new Comparator()\n        {\n            /** {@inheritDoc} */\n            public int compare( Object o1, Object o2 )\n            {\n                MojoDescriptor md1 = (MojoDescriptor) o1;\n                MojoDescriptor md2 = (MojoDescriptor) o2;\n\n                return md1.getId().compareTo( md2.getId() );\n            }\n        } );\n\n        for ( Iterator it = mojoDescriptors.iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            writeGoal( writer, descriptor );\n        }\n\n        writer.write( \"        if ( getLog().isInfoEnabled() )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().info( sb.toString() );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param descriptor not null\n     * @throws IOException if any\n     */\n    private static void writeGoal( Writer writer, MojoDescriptor descriptor )\n        throws IOException\n    {\n        String goalDescription = toDescription( descriptor.getDescription() );\n\n        writer.write( \"        if ( goal == null || goal.length() <= 0 || \\\"\"\n            + StringUtils.escape( descriptor.getGoal() ) + \"\\\".equals( goal ) )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            append( sb, \\\"\" + StringUtils.escape( descriptor.getFullGoalName() ) + \"\\\", 0 );\"\n            + LS );\n        if ( StringUtils.isNotEmpty( descriptor.getDeprecated() ) )\n        {\n            writer.write( \"            append( sb, \\\"Deprecated. \" + toDescription( descriptor.getDeprecated() )\n                + \"\\\", 1 );\" + LS );\n            writer.write( \"            if ( detail )\" + LS );\n            writer.write( \"            {\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n            writer.write( \"                append( sb, \\\"\" + goalDescription + \"\\\", 1 );\" + LS );\n            writer.write( \"            }\" + LS );\n        }\n        else\n        {\n            writer.write( \"            append( sb, \\\"\" + goalDescription + \"\\\", 1 );\" + LS );\n        }\n        writer.write( \"            append( sb, \\\"\\\", 0 );\" + LS );\n\n        if ( descriptor.getParameters() != null && descriptor.getParameters().size() > 0 )\n        {\n            List params = descriptor.getParameters();\n\n            Collections.sort( params, new Comparator()\n            {\n                /** {@inheritDoc} */\n                public int compare( Object o1, Object o2 )\n                {\n                    Parameter parameter1 = (Parameter) o1;\n                    Parameter parameter2 = (Parameter) o2;\n\n                    return parameter1.getName().compareTo( parameter2.getName() );\n                }\n            } );\n\n            writer.write( \"            if ( detail )\" + LS );\n            writer.write( \"            {\" + LS );\n\n            writer.write( \"                append( sb, \\\"Available parameters:\\\", 1 );\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n\n            for ( Iterator it = params.iterator(); it.hasNext(); )\n            {\n                Parameter parameter = (Parameter) it.next();\n\n                if ( parameter.isEditable() )\n                {\n                    writer.write( LS );\n                    writeParameter( writer, parameter );\n                }\n            }\n\n            writer.write( \"            }\" + LS );\n        }\n\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param parameter not null\n     * @throws IOException if any\n     */\n    private static void writeParameter( Writer writer, Parameter parameter )\n        throws IOException\n    {\n        String expression = parameter.getExpression();\n\n        if ( expression == null || !expression.startsWith( \"${component.\" ) )\n        {\n            String parameterName = StringUtils.escape( parameter.getName() );\n            String parameterDescription = toDescription( parameter.getDescription() );\n            String parameterDefaultValue = parameterName\n                + ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) ? \" (Default: \"\n                    + StringUtils.escape( parameter.getDefaultValue() ) + \")\" : \"\" );\n\n            writer.write( \"                append( sb, \\\"\" + parameterDefaultValue + \"\\\", 2 );\" + LS );\n            if ( StringUtils.isNotEmpty( parameter.getDeprecated() ) )\n            {\n                writer.write( \"                append( sb, \\\"Deprecated. \" + toDescription( parameter.getDeprecated() )\n                    + \"\\\", 3 );\" + LS );\n                writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n            }\n            writer.write( \"                append( sb, \\\"\" + parameterDescription + \"\\\", 3 );\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n        }\n    }\n\n    /**\n     * @param writer not null\n     * @throws IOException if any\n     */\n    private static void writeUtilities( Writer writer )\n        throws IOException\n    {\n        writer.write( \"    /**\" + LS );\n        writer.write( \"     * <p>Repeat a String <code>n<\/code> times to form a new string.<\/p>\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @param str String to repeat\" + LS );\n        writer.write( \"     * @param repeat number of times to repeat str\" + LS );\n        writer.write( \"     * @return String with repeated String\" + LS );\n        writer.write( \"     * @throws NegativeArraySizeException if <code>repeat < 0<\/code>\" + LS );\n        writer.write( \"     * @throws NullPointerException if str is <code>null<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static String repeat( String str, int repeat )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        StringBuffer buffer = new StringBuffer( repeat * str.length() );\" + LS );\n        writer.write( LS );\n        writer.write( \"        for ( int i = 0; i < repeat; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            buffer.append( str );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return buffer.toString();\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Append a description to the buffer by respecting the indentSize and lineLength \"\n            + \"parameters.\" + LS );\n        writer.write( \"     * <b>Note<\/b>: The last character is always a new line.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param sb The buffer to append the description, not <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param description The description, not <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indent The base indentation level of each line, must not be negative.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private void append( StringBuffer sb, String description, int indent )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        for ( Iterator it = toLines( description, indent, indentSize, lineLength )\"\n            + \".iterator(); it.hasNext(); )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            sb.append( it.next().toString() ).append( '\\\\n' );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Splits the specified text into lines of convenient display length.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param text The text to split into lines, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indent The base indentation level of each line, must not be negative.\" + LS );\n        writer.write( \"     * @param indentSize The size of each indentation, must not be negative.\" + LS );\n        writer.write( \"     * @param lineLength The length of the line, must not be negative.\" + LS );\n        writer.write( \"     * @return The sequence of display lines, never <code>null<\/code>.\" + LS );\n        writer.write( \"     * @throws NegativeArraySizeException if <code>indent < 0<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static List toLines( String text, int indent, int indentSize, int lineLength )\"\n            + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        List lines = new ArrayList();\" + LS );\n        writer.write( LS );\n        writer.write( \"        String ind = repeat( \\\"\\\\t\\\", indent );\" + LS );\n        writer.write( \"        String[] plainLines = text.split( \\\"(\\\\r\\\\n)|(\\\\r)|(\\\\n)\\\" );\" + LS );\n        writer.write( \"        for ( int i = 0; i < plainLines.length; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            toLines( lines, ind + plainLines[i], indentSize, lineLength );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return lines;\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Adds the specified line to the output sequence, performing line wrapping if necessary.\"\n            + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param lines The sequence of display lines, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param line The line to add, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indentSize The size of each indentation, must not be negative.\" + LS );\n        writer.write( \"     * @param lineLength The length of the line, must not be negative.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static void toLines( List lines, String line, int indentSize, int lineLength )\"\n            + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        int lineIndent = getIndentLevel( line );\" + LS );\n        writer.write( \"        StringBuffer buf = new StringBuffer( 256 );\" + LS );\n        writer.write( \"        String[] tokens = line.split( \\\" +\\\" );\" + LS );\n        writer.write( \"        for ( int i = 0; i < tokens.length; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            String token = tokens[i];\" + LS );\n        writer.write( \"            if ( i > 0 )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                if ( buf.length() + token.length() >= lineLength )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    lines.add( buf.toString() );\" + LS );\n        writer.write( \"                    buf.setLength( 0 );\" + LS );\n        writer.write( \"                    buf.append( repeat( \\\" \\\", lineIndent * indentSize ) );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( ' ' );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"            for ( int j = 0; j < token.length(); j++ )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                char c = token.charAt( j );\" + LS );\n        writer.write( \"                if ( c == '\\\\t' )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( repeat( \\\" \\\", indentSize - buf.length() % indentSize ) );\"\n            + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else if ( c == '\\\\u00A0' )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( ' ' );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( c );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        lines.add( buf.toString() );\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Gets the indentation level of the specified line.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param line The line whose indentation level should be retrieved, must not be \"\n            + \"<code>null<\/code>.\" + LS );\n        writer.write( \"     * @return The indentation level of the line.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static int getIndentLevel( String line )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        int level = 0;\" + LS );\n        writer.write( \"        for ( int i = 0; i < line.length() && line.charAt( i ) == '\\\\t'; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            level++;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        for ( int i = level + 1; i <= level + 4 && i < line.length(); i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            if ( line.charAt( i ) == '\\\\t' )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                level++;\" + LS );\n        writer.write( \"                break;\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        return level;\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    /**\n     * Gets the effective string to use for the plugin/mojo/parameter description.\n     *\n     * @param description The description of the element, may be <code>null<\/code>.\n     * @return The effective description string, never <code>null<\/code>.\n     */\n    private static String toDescription( String description )\n    {\n        if ( StringUtils.isNotEmpty( description ) )\n        {\n            return StringUtils.escape( PluginUtils.toText( description ) );\n        }\n\n        return \"(no description available)\";\n    }\n\n    /**\n     * Converts a HTML fragment as extracted from a javadoc comment to a plain text string. This method tries to retain\n     * as much of the text formatting as possible by means of the following transformations:\n     * <ul>\n     * <li>List items are converted to leading tabs (U+0009), followed by the item number/bullet, another tab and\n     * finally the item contents. Each tab denotes an increase of indentation.<\/li>\n     * <li>Flow breaking elements as well as literal line terminators in preformatted text are converted to a newline\n     * (U+000A) to denote a mandatory line break.<\/li>\n     * <li>Consecutive spaces and line terminators from character data outside of preformatted text will be normalized\n     * to a single space. The resulting space denotes a possible point for line wrapping.<\/li>\n     * <li>Each space in preformatted text will be converted to a non-breaking space (U+00A0).<\/li>\n     * <\/ul>\n     *\n     * @param html The HTML fragment to convert to plain text, may be <code>null<\/code>.\n     * @return A string with HTML tags converted into pure text, never <code>null<\/code>.\n     * @deprecated since 2.4.3, using {@link PluginUtils#toText(String)} instead of.\n     */\n    protected static String toText( String html )\n    {\n        return PluginUtils.toText( html );\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * Generates an <code>HelpMojo<\/code> class.\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    /** Line separator */\n    private static final String LS = System.getProperty( \"line.separator\" );\n\n    /** Default generated class name */\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    /** Default goal */\n    private static final String HELP_GOAL = \"help\";\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        if ( pluginDescriptor.getMojos() == null || pluginDescriptor.getMojos().size() < 1 )\n        {\n            return;\n        }\n\n        MojoDescriptor helpDescriptor = makeHelpDescriptor( pluginDescriptor );\n\n        // Verify that no help goal already exists\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            if ( descriptor.getGoal().equals( helpDescriptor.getGoal() )\n                && !descriptor.getImplementation().equals( helpDescriptor.getImplementation() ) )\n            {\n                if ( getLogger().isWarnEnabled() )\n                {\n                    getLogger().warn(\n                                      \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                          + \") already exists in this plugin. SKIPPED THE \"\n                                          + helpDescriptor.getImplementation() + \" GENERATION.\\n\" );\n                }\n\n                return;\n            }\n        }\n\n        String sourcePath = helpDescriptor.getImplementation().replace( '.', File.separatorChar ) + \".java\";\n        File helpClass = new File( destinationDirectory, sourcePath );\n        helpClass.getParentFile().mkdirs();\n\n        Writer writer = null;\n        try\n        {\n            writer = new FileWriter( helpClass );\n            writeClass( writer, pluginDescriptor, helpDescriptor );\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * Creates a minimalistic mojo descriptor for the generated help goal.\n     *\n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *            <code>null<\/code>.\n     * @return The mojo descriptor for the generated help goal, never <code>null<\/code>.\n     */\n    private static MojoDescriptor makeHelpDescriptor( PluginDescriptor pluginDescriptor )\n    {\n        MojoDescriptor descriptor = new MojoDescriptor();\n\n        descriptor.setPluginDescriptor( pluginDescriptor );\n\n        descriptor.setLanguage( \"java\" );\n\n        descriptor.setGoal( HELP_GOAL );\n\n        String packageName = discoverPackageName( pluginDescriptor );\n        if ( StringUtils.isNotEmpty( packageName ) )\n        {\n            descriptor.setImplementation( packageName + '.' + HELP_MOJO_CLASS_NAME );\n        }\n        else\n        {\n            descriptor.setImplementation( HELP_MOJO_CLASS_NAME );\n        }\n\n        descriptor.setDescription( \"Display help information on \" + pluginDescriptor.getArtifactId()\n            + \".<br/> Call <pre>  mvn \" + descriptor.getFullGoalName()\n            + \" -Ddetail=true -Dgoal=&lt;goal-name&gt;<\/pre> to display parameter details.\" );\n\n        try\n        {\n            Parameter param = new Parameter();\n            param.setName( \"detail\" );\n            param.setType( \"boolean\" );\n            param.setDescription( \"If <code>true<\/code>, display all settable properties for each goal.\" );\n            param.setDefaultValue( \"false\" );\n            param.setExpression( \"${detail}\" );\n            descriptor.addParameter( param );\n\n            param = new Parameter();\n            param.setName( \"goal\" );\n            param.setType( \"java.lang.String\" );\n            param.setDescription( \"The name of the goal for which to show help.\"\n                + \" If unspecified, all goals will be displayed.\" );\n            param.setExpression( \"${goal}\" );\n            descriptor.addParameter( param );\n\n            param = new Parameter();\n            param.setName( \"lineLength\" );\n            param.setType( \"int\" );\n            param.setDescription( \"The maximum length of a display line, should be positive.\" );\n            param.setDefaultValue( \"80\" );\n            param.setExpression( \"${lineLength}\" );\n            descriptor.addParameter( param );\n\n            param = new Parameter();\n            param.setName( \"indentSize\" );\n            param.setType( \"int\" );\n            param.setDescription( \"The number of spaces per indentation level, should be positive.\" );\n            param.setDefaultValue( \"2\" );\n            param.setExpression( \"${indentSize}\" );\n            descriptor.addParameter( param );\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( \"Failed to setup parameters for help goal\", e );\n        }\n\n        return descriptor;\n    }\n\n    /**\n     * Find the best package name, based on the number of hits of actual Mojo classes.\n     *\n     * @param pluginDescriptor not null\n     * @return the best name of the package for the generated mojo\n     */\n    private static String discoverPackageName( PluginDescriptor pluginDescriptor )\n    {\n        Map packageNames = new HashMap();\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            String impl = descriptor.getImplementation();\n            if ( impl.lastIndexOf( '.' ) != -1 )\n            {\n                String name = impl.substring( 0, impl.lastIndexOf( '.' ) );\n                if ( packageNames.get( name ) != null )\n                {\n                    int next = ( (Integer) packageNames.get( name ) ).intValue() + 1;\n                    packageNames.put( name, Integer.valueOf( \"\" + next ) );\n                }\n                else\n                {\n                    packageNames.put( name, Integer.valueOf( \"\" + 1 ) );\n                }\n            }\n            else\n            {\n                packageNames.put( \"\", Integer.valueOf( \"\" + 1 ) );\n            }\n        }\n\n        String packageName = \"\";\n        int max = 0;\n        for ( Iterator it = packageNames.keySet().iterator(); it.hasNext(); )\n        {\n            String key = it.next().toString();\n            int value = ( (Integer) packageNames.get( key ) ).intValue();\n            if ( value > max )\n            {\n                max = value;\n                packageName = key;\n            }\n        }\n\n        return packageName;\n    }\n\n    /**\n     * Generates the <code>HelpMojo<\/code> class.\n     *\n     * @param writer not null\n     * @param pluginDescriptor not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeClass( Writer writer, PluginDescriptor pluginDescriptor, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        String packageName = \"\";\n        String simpleName = helpDescriptor.getImplementation();\n        int dot = simpleName.lastIndexOf( '.' );\n        if ( dot >= 0 )\n        {\n            packageName = simpleName.substring( 0, dot );\n            simpleName = simpleName.substring( dot + 1 );\n        }\n\n        if ( packageName.length() > 0 )\n        {\n            writer.write( \"package \" + packageName + \";\" + LS );\n            writer.write( LS );\n        }\n\n        writeImports( writer );\n        writer.write( LS );\n\n        writeMojoJavadoc( writer, pluginDescriptor, helpDescriptor );\n\n        writer.write( \"public class \" + simpleName + LS );\n        writer.write( \"    extends AbstractMojo\" + LS );\n        writer.write( \"{\" + LS );\n\n        writeVariables( writer, helpDescriptor );\n\n        writer.write( LS );\n\n        writeExecute( writer, pluginDescriptor, helpDescriptor );\n\n        writer.write( LS );\n        writeUtilities( writer );\n        writer.write( \"}\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @throws IOException if any\n     */\n    private static void writeImports( Writer writer )\n        throws IOException\n    {\n        writer.write( \"import java.util.ArrayList;\" + LS );\n        writer.write( \"import java.util.Iterator;\" + LS );\n        writer.write( \"import java.util.List;\" + LS );\n        writer.write( LS );\n        writer.write( \"import org.apache.maven.plugin.AbstractMojo;\" + LS );\n        writer.write( \"import org.apache.maven.plugin.MojoExecutionException;\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param pluginDescriptor not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeMojoJavadoc( Writer writer, PluginDescriptor pluginDescriptor,\n                                          MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        StringBuffer author = new StringBuffer();\n        author.append( PluginHelpGenerator.class.getName() );\n\n        String resource = \"META-INF/maven/org.apache.maven.plugin-tools/maven-plugin-tools-api/pom.properties\";\n        InputStream resourceAsStream = PluginHelpGenerator.class.getClassLoader().getResourceAsStream( resource );\n\n        if ( resourceAsStream != null )\n        {\n            try\n            {\n                Properties properties = new Properties();\n                properties.load( resourceAsStream );\n\n                author.append( \" (version \" ).append( properties.getProperty( \"version\", \"unknown\" ) ).append( \")\" );\n            }\n            catch ( IOException e )\n            {\n                // nope\n            }\n        }\n\n        writer.write( \"/**\" + LS );\n        writer.write( \" * \" + helpDescriptor.getDescription() + LS );\n        writer.write( \" *\" + LS );\n        writer.write( \" * @version generated on \" + new Date() + LS );\n        writer.write( \" * @author \" + author.toString() + LS );\n        writer.write( \" * @goal \" + helpDescriptor.getGoal() + LS );\n        writer.write( \" * @requiresProject false\" + LS );\n        writer.write( \" */\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeVariables( Writer writer, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        for ( Iterator it = helpDescriptor.getParameters().iterator(); it.hasNext(); )\n        {\n            Parameter param = (Parameter) it.next();\n            writer.write( \"    /**\" + LS );\n            writer.write( \"     * \" + StringUtils.escape( param.getDescription() ) + LS );\n            writer.write( \"     * \" + LS );\n            writer.write( \"     * @parameter\" );\n            if ( StringUtils.isNotEmpty( param.getExpression() ) )\n            {\n                writer.write( \" expression=\\\"\" );\n                writer.write( StringUtils.escape( param.getExpression() ) );\n                writer.write( \"\\\"\" );\n            }\n            if ( StringUtils.isNotEmpty( param.getDefaultValue() ) )\n            {\n                writer.write( \" default-value=\\\"\" );\n                writer.write( StringUtils.escape( param.getDefaultValue() ) );\n                writer.write( \"\\\"\" );\n            }\n            writer.write( LS );\n            writer.write( \"     */\" + LS );\n            writer.write( \"    private \" + param.getType() + \" \" + param.getName() + \";\" + LS );\n            writer.write( LS );\n        }\n    }\n\n    /**\n     * @param writer not null\n     * @param pluginDescriptor not null\n     * @param helpDescriptor not null\n     * @throws IOException if any\n     */\n    private static void writeExecute( Writer writer, PluginDescriptor pluginDescriptor, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        List mojoDescriptors = new ArrayList();\n\n        mojoDescriptors.add( helpDescriptor );\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor mojoDescriptor = (MojoDescriptor) it.next();\n\n            if ( !helpDescriptor.getGoal().equals( mojoDescriptor.getGoal() ) )\n            {\n                mojoDescriptors.add( mojoDescriptor );\n            }\n        }\n\n        PluginUtils.sortMojos( mojoDescriptors );\n\n        writer.write( \"    /** {@inheritDoc} */\" + LS );\n        writer.write( \"    public void execute()\" + LS );\n        writer.write( \"        throws MojoExecutionException\" + LS );\n        writer.write( \"    {\" + LS );\n\n        writer.write( \"        if ( lineLength <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().warn( \\\"The parameter 'lineLength' should be positive, using '80' as \"\n            + \"default.\\\" );\" + LS );\n        writer.write( \"            lineLength = 80;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        if ( indentSize <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().warn( \\\"The parameter 'indentSize' should be positive, using '2' as \"\n            + \"default.\\\" );\" + LS );\n        writer.write( \"            indentSize = 2;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        StringBuffer sb = new StringBuffer();\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        append( sb, \\\"\" + StringUtils.escape( pluginDescriptor.getId() ) + \"\\\", 0 );\" + LS );\n        writer.write( \"        append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        append( sb, \\\"\"\n            + StringUtils.escape( pluginDescriptor.getName() + \" \" + pluginDescriptor.getVersion() )\n            + \"\\\", 0 );\" + LS );\n        writer.write( \"        append( sb, \\\"\" + toDescription( pluginDescriptor.getDescription() ) + \"\\\", 1 );\"\n            + LS );\n        writer.write( \"        append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        if ( goal == null || goal.length() <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            append( sb, \\\"This plugin has \" + mojoDescriptors.size() + \" \"\n            + ( mojoDescriptors.size() > 1 ? \"goals\" : \"goal\" ) + \":\\\", 0 );\" + LS );\n        writer.write( \"            append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( \"        }\" + LS );\n\n        writer.write( LS );\n\n        for ( Iterator it = mojoDescriptors.iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            writeGoal( writer, descriptor );\n        }\n\n        writer.write( \"        if ( getLog().isInfoEnabled() )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().info( sb.toString() );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param descriptor not null\n     * @throws IOException if any\n     */\n    private static void writeGoal( Writer writer, MojoDescriptor descriptor )\n        throws IOException\n    {\n        String goalDescription = toDescription( descriptor.getDescription() );\n\n        writer.write( \"        if ( goal == null || goal.length() <= 0 || \\\"\"\n            + StringUtils.escape( descriptor.getGoal() ) + \"\\\".equals( goal ) )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            append( sb, \\\"\" + StringUtils.escape( descriptor.getFullGoalName() ) + \"\\\", 0 );\"\n            + LS );\n        if ( StringUtils.isNotEmpty( descriptor.getDeprecated() ) )\n        {\n            writer.write( \"            append( sb, \\\"Deprecated. \" + toDescription( descriptor.getDeprecated() )\n                + \"\\\", 1 );\" + LS );\n            writer.write( \"            if ( detail )\" + LS );\n            writer.write( \"            {\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n            writer.write( \"                append( sb, \\\"\" + goalDescription + \"\\\", 1 );\" + LS );\n            writer.write( \"            }\" + LS );\n        }\n        else\n        {\n            writer.write( \"            append( sb, \\\"\" + goalDescription + \"\\\", 1 );\" + LS );\n        }\n        writer.write( \"            append( sb, \\\"\\\", 0 );\" + LS );\n\n        if ( descriptor.getParameters() != null && descriptor.getParameters().size() > 0 )\n        {\n            writer.write( \"            if ( detail )\" + LS );\n            writer.write( \"            {\" + LS );\n\n            writer.write( \"                append( sb, \\\"Available parameters:\\\", 1 );\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n\n            for ( Iterator it = descriptor.getParameters().iterator(); it.hasNext(); )\n            {\n                Parameter parameter = (Parameter) it.next();\n\n                if ( parameter.isEditable() )\n                {\n                    writer.write( LS );\n                    writeParameter( writer, parameter );\n                }\n            }\n\n            writer.write( \"            }\" + LS );\n        }\n\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n    }\n\n    /**\n     * @param writer not null\n     * @param parameter not null\n     * @throws IOException if any\n     */\n    private static void writeParameter( Writer writer, Parameter parameter )\n        throws IOException\n    {\n        String expression = parameter.getExpression();\n\n        if ( expression == null || !expression.startsWith( \"${component.\" ) )\n        {\n            String parameterName = StringUtils.escape( parameter.getName() );\n            String parameterDescription = toDescription( parameter.getDescription() );\n            String parameterDefaultValue = parameterName\n                + ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) ? \" (Default: \"\n                    + StringUtils.escape( parameter.getDefaultValue() ) + \")\" : \"\" );\n\n            writer.write( \"                append( sb, \\\"\" + parameterDefaultValue + \"\\\", 2 );\" + LS );\n            if ( StringUtils.isNotEmpty( parameter.getDeprecated() ) )\n            {\n                writer.write( \"                append( sb, \\\"Deprecated. \" + toDescription( parameter.getDeprecated() )\n                    + \"\\\", 3 );\" + LS );\n                writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n            }\n            writer.write( \"                append( sb, \\\"\" + parameterDescription + \"\\\", 3 );\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n        }\n    }\n\n    /**\n     * @param writer not null\n     * @throws IOException if any\n     */\n    private static void writeUtilities( Writer writer )\n        throws IOException\n    {\n        writer.write( \"    /**\" + LS );\n        writer.write( \"     * <p>Repeat a String <code>n<\/code> times to form a new string.<\/p>\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @param str String to repeat\" + LS );\n        writer.write( \"     * @param repeat number of times to repeat str\" + LS );\n        writer.write( \"     * @return String with repeated String\" + LS );\n        writer.write( \"     * @throws NegativeArraySizeException if <code>repeat < 0<\/code>\" + LS );\n        writer.write( \"     * @throws NullPointerException if str is <code>null<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static String repeat( String str, int repeat )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        StringBuffer buffer = new StringBuffer( repeat * str.length() );\" + LS );\n        writer.write( LS );\n        writer.write( \"        for ( int i = 0; i < repeat; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            buffer.append( str );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return buffer.toString();\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Append a description to the buffer by respecting the indentSize and lineLength \"\n            + \"parameters.\" + LS );\n        writer.write( \"     * <b>Note<\/b>: The last character is always a new line.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param sb The buffer to append the description, not <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param description The description, not <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indent The base indentation level of each line, must not be negative.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private void append( StringBuffer sb, String description, int indent )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        for ( Iterator it = toLines( description, indent, indentSize, lineLength )\"\n            + \".iterator(); it.hasNext(); )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            sb.append( it.next().toString() ).append( '\\\\n' );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Splits the specified text into lines of convenient display length.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param text The text to split into lines, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indent The base indentation level of each line, must not be negative.\" + LS );\n        writer.write( \"     * @param indentSize The size of each indentation, must not be negative.\" + LS );\n        writer.write( \"     * @param lineLength The length of the line, must not be negative.\" + LS );\n        writer.write( \"     * @return The sequence of display lines, never <code>null<\/code>.\" + LS );\n        writer.write( \"     * @throws NegativeArraySizeException if <code>indent < 0<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static List toLines( String text, int indent, int indentSize, int lineLength )\"\n            + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        List lines = new ArrayList();\" + LS );\n        writer.write( LS );\n        writer.write( \"        String ind = repeat( \\\"\\\\t\\\", indent );\" + LS );\n        writer.write( \"        String[] plainLines = text.split( \\\"(\\\\r\\\\n)|(\\\\r)|(\\\\n)\\\" );\" + LS );\n        writer.write( \"        for ( int i = 0; i < plainLines.length; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            toLines( lines, ind + plainLines[i], indentSize, lineLength );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return lines;\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Adds the specified line to the output sequence, performing line wrapping if necessary.\"\n            + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param lines The sequence of display lines, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param line The line to add, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indentSize The size of each indentation, must not be negative.\" + LS );\n        writer.write( \"     * @param lineLength The length of the line, must not be negative.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static void toLines( List lines, String line, int indentSize, int lineLength )\"\n            + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        int lineIndent = getIndentLevel( line );\" + LS );\n        writer.write( \"        StringBuffer buf = new StringBuffer( 256 );\" + LS );\n        writer.write( \"        String[] tokens = line.split( \\\" +\\\" );\" + LS );\n        writer.write( \"        for ( int i = 0; i < tokens.length; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            String token = tokens[i];\" + LS );\n        writer.write( \"            if ( i > 0 )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                if ( buf.length() + token.length() >= lineLength )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    lines.add( buf.toString() );\" + LS );\n        writer.write( \"                    buf.setLength( 0 );\" + LS );\n        writer.write( \"                    buf.append( repeat( \\\" \\\", lineIndent * indentSize ) );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( ' ' );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"            for ( int j = 0; j < token.length(); j++ )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                char c = token.charAt( j );\" + LS );\n        writer.write( \"                if ( c == '\\\\t' )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( repeat( \\\" \\\", indentSize - buf.length() % indentSize ) );\"\n            + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else if ( c == '\\\\u00A0' )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( ' ' );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( c );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        lines.add( buf.toString() );\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Gets the indentation level of the specified line.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param line The line whose indentation level should be retrieved, must not be \"\n            + \"<code>null<\/code>.\" + LS );\n        writer.write( \"     * @return The indentation level of the line.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static int getIndentLevel( String line )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        int level = 0;\" + LS );\n        writer.write( \"        for ( int i = 0; i < line.length() && line.charAt( i ) == '\\\\t'; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            level++;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        for ( int i = level + 1; i <= level + 4 && i < line.length(); i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            if ( line.charAt( i ) == '\\\\t' )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                level++;\" + LS );\n        writer.write( \"                break;\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        return level;\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    /**\n     * Gets the effective string to use for the plugin/mojo/parameter description.\n     *\n     * @param description The description of the element, may be <code>null<\/code>.\n     * @return The effective description string, never <code>null<\/code>.\n     */\n    private static String toDescription( String description )\n    {\n        if ( StringUtils.isNotEmpty( description ) )\n        {\n            return StringUtils.escape( PluginUtils.toText( description ) );\n        }\n\n        return \"(no description available)\";\n    }\n\n    /**\n     * Converts a HTML fragment as extracted from a javadoc comment to a plain text string. This method tries to retain\n     * as much of the text formatting as possible by means of the following transformations:\n     * <ul>\n     * <li>List items are converted to leading tabs (U+0009), followed by the item number/bullet, another tab and\n     * finally the item contents. Each tab denotes an increase of indentation.<\/li>\n     * <li>Flow breaking elements as well as literal line terminators in preformatted text are converted to a newline\n     * (U+000A) to denote a mandatory line break.<\/li>\n     * <li>Consecutive spaces and line terminators from character data outside of preformatted text will be normalized\n     * to a single space. The resulting space denotes a possible point for line wrapping.<\/li>\n     * <li>Each space in preformatted text will be converted to a non-breaking space (U+00A0).<\/li>\n     * <\/ul>\n     *\n     * @param html The HTML fragment to convert to plain text, may be <code>null<\/code>.\n     * @return A string with HTML tags converted into pure text, never <code>null<\/code>.\n     * @deprecated since 2.4.3, using {@link PluginUtils#toText(String)} instead of.\n     */\n    protected static String toText( String html )\n    {\n        return PluginUtils.toText( html );\n    }\n}\n","lineNo":515}
{"Refactored Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Stack;\n\nimport javax.swing.text.MutableAttributeSet;\nimport javax.swing.text.html.HTML;\nimport javax.swing.text.html.HTMLEditorKit;\nimport javax.swing.text.html.parser.ParserDelegator;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * Generates an <code>HelpMojo<\/code> class.\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    private static final String LS = System.getProperty( \"line.separator\" );\n\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    private static final String HELP_GOAL = \"help\";\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        if ( pluginDescriptor.getMojos() == null || pluginDescriptor.getMojos().size() < 1 )\n        {\n            return;\n        }\n\n        MojoDescriptor helpDescriptor = makeHelpDescriptor( pluginDescriptor );\n\n        // Verify that no help goal already exists\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            if ( descriptor.getGoal().equals( helpDescriptor.getGoal() )\n                && !descriptor.getImplementation().equals( helpDescriptor.getImplementation() ) )\n            {\n                if ( getLogger().isWarnEnabled() )\n                {\n                    getLogger().warn(\n                                      \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                          + \") already exists in this plugin. SKIPPED THE \"\n                                          + helpDescriptor.getImplementation() + \" GENERATION.\\n\" );\n                }\n\n                return;\n            }\n        }\n\n        String sourcePath = helpDescriptor.getImplementation().replace( '.', File.separatorChar ) + \".java\";\n        File helpClass = new File( destinationDirectory, sourcePath );\n        helpClass.getParentFile().mkdirs();\n\n        Writer writer = null;\n        try\n        {\n            writer = new FileWriter( helpClass );\n            writeClass( writer, pluginDescriptor, helpDescriptor );\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * Creates a minimalistic mojo descriptor for the generated help goal.\n     * \n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *            <code>null<\/code>.\n     * @return The mojo descriptor for the generated help goal, never <code>null<\/code>.\n     */\n    private static MojoDescriptor makeHelpDescriptor( PluginDescriptor pluginDescriptor )\n    {\n        MojoDescriptor descriptor = new MojoDescriptor();\n\n        descriptor.setPluginDescriptor( pluginDescriptor );\n\n        descriptor.setLanguage( \"java\" );\n\n        descriptor.setGoal( HELP_GOAL );\n\n        String packageName = discoverPackageName( pluginDescriptor );\n        if ( StringUtils.isNotEmpty( packageName ) )\n        {\n            descriptor.setImplementation( packageName + '.' + HELP_MOJO_CLASS_NAME );\n        }\n        else\n        {\n            descriptor.setImplementation( HELP_MOJO_CLASS_NAME );\n        }\n\n        descriptor.setDescription( \"Display help information on \" + pluginDescriptor.getArtifactId()\n            + \". Call <pre>  mvn \" + descriptor.getFullGoalName()\n            + \" -Ddetail=true -Dgoal=&lt;goal-name&gt;<\/pre> to display parameter details.\" );\n\n        try\n        {\n            {\n                Parameter param = new Parameter();\n                param.setName( \"detail\" );\n                param.setType( \"boolean\" );\n                param.setDescription( \"If <code>true<\/code>, display all settable properties for each goal.\" );\n                param.setDefaultValue( \"false\" );\n                param.setExpression( \"${detail}\" );\n                descriptor.addParameter( param );\n            }\n            {\n                Parameter param = new Parameter();\n                param.setName( \"goal\" );\n                param.setType( \"java.lang.String\" );\n                param.setDescription( \"The name of the goal for which to show help.\"\n                    + \" If unspecified, all goals will be displayed.\" );\n                param.setExpression( \"${goal}\" );\n                descriptor.addParameter( param );\n            }\n            {\n                Parameter param = new Parameter();\n                param.setName( \"lineLength\" );\n                param.setType( \"int\" );\n                param.setDescription( \"The maximum length of a display line.\" );\n                param.setDefaultValue( \"80\" );\n                param.setExpression( \"${lineLength}\" );\n                descriptor.addParameter( param );\n            }\n            {\n                Parameter param = new Parameter();\n                param.setName( \"indentSize\" );\n                param.setType( \"int\" );\n                param.setDescription( \"The number of spaces per indentation level.\" );\n                param.setDefaultValue( \"2\" );\n                param.setExpression( \"${indentSize}\" );\n                descriptor.addParameter( param );\n            }\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( \"Failed to setup parameters for help goal\", e );\n        }\n        \n        return descriptor;\n    }\n\n    /**\n     * Find the best package name, based on the number of hits of actual Mojo classes.\n     * \n     * @param pluginDescriptor\n     * @return the best name of the package for the generated mojo\n     */\n    private static String discoverPackageName( PluginDescriptor pluginDescriptor )\n    {\n        Map packageNames = new HashMap();\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            String impl = descriptor.getImplementation();\n            if ( impl.lastIndexOf( '.' ) != -1 )\n            {\n                String name = impl.substring( 0, impl.lastIndexOf( '.' ) );\n                if ( packageNames.get( name ) != null )\n                {\n                    int next = ( (Integer) packageNames.get( name ) ).intValue() + 1;\n                    packageNames.put( name, Integer.valueOf( \"\" + next ) );\n                }\n                else\n                {\n                    packageNames.put( name, Integer.valueOf( \"\" + 1 ) );\n                }\n            }\n            else\n            {\n                packageNames.put( \"\", Integer.valueOf( \"\" + 1 ) );\n            }\n        }\n\n        String packageName = \"\";\n        int max = 0;\n        for ( Iterator it = packageNames.keySet().iterator(); it.hasNext(); )\n        {\n            String key = it.next().toString();\n            int value = ( (Integer) packageNames.get( key ) ).intValue();\n            if ( value > max )\n            {\n                max = value;\n                packageName = key;\n            }\n        }\n\n        return packageName;\n    }\n\n    /**\n     * Generates the <code>HelpMojo<\/code> class.\n     * \n     * @param writer\n     * @param pluginDescriptor\n     * @param helpDescriptor\n     * @throws IOException if any\n     */\n    private static void writeClass( Writer writer, PluginDescriptor pluginDescriptor, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        String packageName = \"\";\n        String simpleName = helpDescriptor.getImplementation();\n        int dot = simpleName.lastIndexOf( '.' );\n        if ( dot >= 0 )\n        {\n            packageName = simpleName.substring( 0, dot );\n            simpleName = simpleName.substring( dot + 1 );\n        }\n\n        if ( packageName.length() > 0 )\n        {\n            writer.write( \"package \" + packageName + \";\" + LS );\n            writer.write( LS );\n        }\n\n        writeImports( writer );\n        writer.write( LS );\n\n        writeMojoJavadoc( writer, pluginDescriptor, helpDescriptor );\n\n        writer.write( \"public class \" + simpleName + LS );\n        writer.write( \"    extends AbstractMojo\" + LS );\n        writer.write( \"{\" + LS );\n\n        writeVariables( writer, helpDescriptor );\n\n        writer.write( LS );\n\n        writeExecute( writer, pluginDescriptor, helpDescriptor );\n\n        writer.write( LS );\n        writeUtilities( writer );\n        writer.write( \"}\" + LS );\n    }\n\n    private static void writeImports( Writer writer )\n        throws IOException\n    {\n        writer.write( \"import java.util.ArrayList;\" + LS );\n        writer.write( \"import java.util.Iterator;\" + LS );\n        writer.write( \"import java.util.List;\" + LS );\n        writer.write( LS );\n        writer.write( \"import org.apache.maven.plugin.AbstractMojo;\" + LS );\n        writer.write( \"import org.apache.maven.plugin.MojoExecutionException;\" + LS );\n    }\n\n    private static void writeMojoJavadoc( Writer writer, PluginDescriptor pluginDescriptor,\n                                          MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        writer.write( \"/**\" + LS );\n        writer.write( \" * \" + helpDescriptor.getDescription() + LS );\n        writer.write( \" *\" + LS );\n        writer.write( \" * @version generated on \" + new Date() + LS );\n        writer.write( \" * @goal \" + helpDescriptor.getGoal() + LS );\n        writer.write( \" * @requiresProject false\" + LS );\n        writer.write( \" */\" + LS );\n    }\n\n    private static void writeVariables( Writer writer, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        for ( Iterator it = helpDescriptor.getParameters().iterator(); it.hasNext(); )\n        {\n            Parameter param = (Parameter) it.next();\n            writer.write( \"    /**\" + LS );\n            writer.write( \"     * \" + StringUtils.escape( param.getDescription() ) + LS );\n            writer.write( \"     * \" + LS );\n            writer.write( \"     * @parameter\" );\n            if ( StringUtils.isNotEmpty( param.getExpression() ) )\n            {\n                writer.write( \" expression=\\\"\" );\n                writer.write( StringUtils.escape( param.getExpression() ) );\n                writer.write( \"\\\"\" );\n            }\n            if ( StringUtils.isNotEmpty( param.getDefaultValue() ) )\n            {\n                writer.write( \" default-value=\\\"\" );\n                writer.write( StringUtils.escape( param.getDefaultValue() ) );\n                writer.write( \"\\\"\" );\n            }\n            writer.write( LS );\n            writer.write( \"     */\" + LS );\n            writer.write( \"    private \" + param.getType() + \" \" + param.getName() + \";\" + LS );\n            writer.write( LS );\n        }\n    }\n\n    private static void writeExecute( Writer writer, PluginDescriptor pluginDescriptor, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        List mojoDescriptors = new ArrayList();\n\n        mojoDescriptors.add( helpDescriptor );\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor mojoDescriptor = (MojoDescriptor) it.next();\n\n            if ( !helpDescriptor.getGoal().equals( mojoDescriptor.getGoal() ) )\n            {\n                mojoDescriptors.add( mojoDescriptor );\n            }\n        }\n\n        PluginUtils.sortMojos( mojoDescriptors );\n\n        writer.write( \"    /** {@inheritDoc} */\" + LS );\n        writer.write( \"    public void execute()\" + LS );\n        writer.write( \"        throws MojoExecutionException\" + LS );\n        writer.write( \"    {\" + LS );\n\n        writer.write( \"        StringBuffer sb = new StringBuffer();\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        append( sb, \\\"\" + StringUtils.escape( pluginDescriptor.getId() ) + \"\\\", 0 );\" + LS );\n        writer.write( \"        append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        append( sb, \\\"\"\n            + StringUtils.escape( pluginDescriptor.getName() + \" \" + pluginDescriptor.getVersion() )\n            + \"\\\", 0 );\" + LS );\n        writer.write( \"        append( sb, \\\"\" + toDescription( pluginDescriptor.getDescription() ) + \"\\\", 1 );\" + LS );\n        writer.write( \"        append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        if ( goal == null || goal.length() <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            append( sb, \\\"This plugin has \" + mojoDescriptors.size() + \" \"\n            + ( mojoDescriptors.size() > 1 ? \"goals\" : \"goal\" ) + \":\\\", 0 );\" + LS );\n        writer.write( \"            append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( \"        }\" + LS );\n\n        writer.write( LS );\n\n        for ( Iterator it = mojoDescriptors.iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            writeGoal( writer, descriptor );\n        }\n\n        writer.write( \"        if ( getLog().isInfoEnabled() )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().info( sb.toString() );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    private static void writeGoal( Writer writer, MojoDescriptor descriptor )\n        throws IOException\n    {\n        String goalDescription = toDescription( descriptor.getDescription() );\n\n        writer.write( \"        if ( goal == null || goal.length() <= 0 || \\\"\"\n            + StringUtils.escape( descriptor.getGoal() ) + \"\\\".equals( goal ) )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            append( sb, \\\"\" + StringUtils.escape( descriptor.getFullGoalName() ) + \"\\\", 0 );\"\n            + LS );\n        if ( StringUtils.isNotEmpty( descriptor.getDeprecated() ) )\n        {\n            writer.write( \"            append( sb, \\\"Deprecated. \" + toDescription( descriptor.getDeprecated() )\n                + \"\\\", 1 );\" + LS );\n            writer.write( \"            if ( detail )\" + LS );\n            writer.write( \"            {\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n            writer.write( \"                append( sb, \\\"\" + goalDescription + \"\\\", 1 );\" + LS );\n            writer.write( \"            }\" + LS );\n        }\n        else\n        {\n            writer.write( \"            append( sb, \\\"\" + goalDescription + \"\\\", 1 );\" + LS );\n        }\n        writer.write( \"            append( sb, \\\"\\\", 0 );\" + LS );\n\n        if ( descriptor.getParameters() != null && descriptor.getParameters().size() > 0 )\n        {\n            writer.write( \"            if ( detail )\" + LS );\n            writer.write( \"            {\" + LS );\n\n            writer.write( \"                append( sb, \\\"Available parameters:\\\", 1 );\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n\n            for ( Iterator it = descriptor.getParameters().iterator(); it.hasNext(); )\n            {\n                Parameter parameter = (Parameter) it.next();\n\n                if ( parameter.isEditable() )\n                {\n                    writer.write( LS );\n                    writeParameter( writer, parameter );\n                }\n            }\n\n            writer.write( \"            }\" + LS );\n        }\n\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n    }\n\n    private static void writeParameter( Writer writer, Parameter parameter )\n        throws IOException\n    {\n        String expression = parameter.getExpression();\n\n        if ( expression == null || !expression.startsWith( \"${component.\" ) )\n        {\n            String parameterName = StringUtils.escape( parameter.getName() );\n            String parameterDescription = toDescription( parameter.getDescription() );\n            String parameterDefaultValue = parameterName\n                + ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) ? \" (Default: \"\n                    + StringUtils.escape( parameter.getDefaultValue() ) + \")\" : \"\" );\n\n            writer.write( \"                append( sb, \\\"\" + parameterDefaultValue + \"\\\", 2 );\" + LS );\n            if ( StringUtils.isNotEmpty( parameter.getDeprecated() ) )\n            {\n                writer.write( \"                append( sb, \\\"Deprecated. \" + toDescription( parameter.getDeprecated() )\n                    + \"\\\", 3 );\" + LS );\n                writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n            }\n            writer.write( \"                append( sb, \\\"\" + parameterDescription + \"\\\", 3 );\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n        }\n    }\n\n    private static void writeUtilities( Writer writer )\n        throws IOException\n    {\n        writer.write( \"    /**\" + LS );\n        writer.write( \"     * <p>Repeat a String <code>n<\/code> times to form a new string.<\/p>\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @param str String to repeat\" + LS );\n        writer.write( \"     * @param repeat number of times to repeat str\" + LS );\n        writer.write( \"     * @return String with repeated String\" + LS );\n        writer.write( \"     * @throws NegativeArraySizeException if <code>repeat < 0<\/code>\" + LS );\n        writer.write( \"     * @throws NullPointerException if str is <code>null<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static String repeat( String str, int repeat )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        StringBuffer buffer = new StringBuffer( repeat * str.length() );\" + LS );\n        writer.write( LS );\n        writer.write( \"        for ( int i = 0; i < repeat; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            buffer.append( str );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return buffer.toString();\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    private void append( StringBuffer sb, String description, int indent )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        for ( Iterator it = toLines( description, indent ).iterator(); it.hasNext(); )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            sb.append( it.next().toString() ).append( '\\\\n' );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Splits the specified text into lines of convenient display length.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param text The text to split into lines, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indent The base indentation level of each line, must not be negative.\" + LS );\n        writer.write( \"     * @return The sequence of display lines, never <code>null<\/code>.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private List toLines( String text, int indent )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        List lines = new ArrayList();\" + LS );\n        writer.write( LS );\n        writer.write( \"        String ind = repeat( \\\"\\\\t\\\", indent );\" + LS );\n        writer.write( \"        String[] plainLines = text.split( \\\"(\\\\r\\\\n)|(\\\\r)|(\\\\n)\\\" );\" + LS );\n        writer.write( \"        for ( int i = 0; i < plainLines.length; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            toLines( lines, ind + plainLines[i] );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return lines;\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Adds the specified line to the output sequence, performing line wrapping if necessary.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param lines The sequence of display lines, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param line The line to add, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private void toLines( List lines, String line )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        int lineIndent = getIndentLevel( line );\" + LS );\n        writer.write( \"        StringBuffer buf = new StringBuffer( 256 );\" + LS );\n        writer.write( \"        String[] tokens = line.split( \\\" +\\\" );\" + LS );\n        writer.write( \"        for ( int i = 0; i < tokens.length; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            String token = tokens[i];\" + LS );\n        writer.write( \"            if ( i > 0 )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                if ( buf.length() + token.length() >= lineLength )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    lines.add( buf.toString() );\" + LS );\n        writer.write( \"                    buf.setLength( 0 );\" + LS );\n        writer.write( \"                    buf.append( repeat( \\\" \\\", lineIndent * indentSize ) );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( ' ' );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"            for ( int j = 0; j < token.length(); j++ )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                char c = token.charAt( j );\" + LS );\n        writer.write( \"                if ( c == '\\\\t' )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( repeat( \\\" \\\", indentSize - buf.length() % indentSize ) );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else if ( c == '\\\\u00A0' )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( ' ' );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( c );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        lines.add( buf.toString() );\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Gets the indentation level of the specified line.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param line The line whose indentation level should be retrieved, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @return The indentation level of the line.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static int getIndentLevel( String line )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        int level = 0;\" + LS );\n        writer.write( \"        for ( int i = 0; i < line.length() && line.charAt( i ) == '\\\\t'; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            level++;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        for ( int i = level + 1; i <= level + 4 && i < line.length(); i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            if ( line.charAt( i ) == '\\\\t' )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                level++;\" + LS );\n        writer.write( \"                break;\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        return level;\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    /**\n     * Gets the effective string to use for the plugin/mojo/parameter description.\n     * \n     * @param description The description of the element, may be <code>null<\/code>.\n     * @return The effective description string, never <code>null<\/code>.\n     */\n    private static String toDescription( String description )\n    {\n        if ( StringUtils.isNotEmpty( description ) )\n        {\n            return StringUtils.escape( toText( description ) );\n        }\n        else\n        {\n            return \"(no description available)\";\n        }\n    }\n\n    /**\n     * Converts a HTML fragment as extracted from a javadoc comment to a plain text string. This method tries to retain\n     * as much of the text formatting as possible by means of the following transformations:\n     * <ul>\n     * <li>List items are converted to leading tabs (U+0009), followed by the item number/bullet, another tab and\n     * finally the item contents. Each tab denotes an increase of indentation.<\/li>\n     * <li>Flow breaking elements as well as literal line terminators in preformatted text are converted to a newline\n     * (U+000A) to denote a mandatory line break.<\/li>\n     * <li>Consecutive spaces and line terminators from character data outside of preformatted text will be normalized\n     * to a single space. The resulting space denotes a possible point for line wrapping.<\/li>\n     * <li>Each space in preformatted text will be converted to a non-breaking space (U+00A0).<\/li>\n     * <\/ul>\n     * \n     * @param html The HTML fragment to convert to plain text, may be <code>null<\/code>.\n     * @return A string with HTML tags converted into pure text, never <code>null<\/code>.\n     */\n    protected static String toText( String html )\n    {\n        if ( StringUtils.isEmpty( html ) )\n        {\n            return \"\";\n        }\n\n        final StringBuffer sb = new StringBuffer();\n\n        HTMLEditorKit.Parser parser = new ParserDelegator();\n        HTMLEditorKit.ParserCallback htmlCallback = new HTMLEditorKit.ParserCallback()\n        {\n            /**\n             * Holds the index of the current item in a numbered list.\n             */\n            class Counter\n            {\n                public int value;\n            }\n\n            /**\n             * A flag whether the parser is currently in the body element.\n             */\n            private boolean body;\n\n            /**\n             * A flag whether the parser is currently processing preformatted text, actually a counter to track nesting.\n             */\n            private int preformatted;\n\n            /**\n             * The current indentation depth for the output.\n             */\n            private int depth;\n\n            /**\n             * A stack of {@link Counter} objects corresponding to the nesting of (un-)ordered lists. A\n             * <code>null<\/code> element denotes an unordered list.\n             */\n            private Stack numbering = new Stack();\n\n            /**\n             * A flag whether an implicit line break is pending in the output buffer. This flag is used to postpone the\n             * output of implicit line breaks until we are sure that are not to be merged with other implicit line\n             * breaks.\n             */\n            private boolean pendingNewline;\n\n            /**\n             * A flag whether we have just parsed a simple tag.\n             */\n            private boolean simpleTag;\n\n            /** {@inheritDoc} */\n            public void handleSimpleTag( HTML.Tag t, MutableAttributeSet a, int pos )\n            {\n                simpleTag = true;\n                if ( body && HTML.Tag.BR.equals( t ) )\n                {\n                    newline( false );\n                }\n            }\n\n            /** {@inheritDoc} */\n            public void handleStartTag( HTML.Tag t, MutableAttributeSet a, int pos )\n            {\n                simpleTag = false;\n                if ( body && ( t.breaksFlow() || t.isBlock() ) )\n                {\n                    newline( true );\n                }\n                if ( HTML.Tag.OL.equals( t ) )\n                {\n                    numbering.push( new Counter() );\n                }\n                else if ( HTML.Tag.UL.equals( t ) )\n                {\n                    numbering.push( null );\n                }\n                else if ( HTML.Tag.LI.equals( t ) )\n                {\n                    Counter counter = (Counter) numbering.peek();\n                    if ( counter == null )\n                    {\n                        text( \"-\\t\" );\n                    }\n                    else\n                    {\n                        text( ++counter.value + \".\\t\" );\n                    }\n                    depth++;\n                }\n                else if ( HTML.Tag.DD.equals( t ) )\n                {\n                    depth++;\n                }\n                else if ( t.isPreformatted() )\n                {\n                    preformatted++;\n                }\n                else if ( HTML.Tag.BODY.equals( t ) )\n                {\n                    body = true;\n                }\n            }\n\n            /** {@inheritDoc} */\n            public void handleEndTag( HTML.Tag t, int pos )\n            {\n                if ( HTML.Tag.OL.equals( t ) || HTML.Tag.UL.equals( t ) )\n                {\n                    numbering.pop();\n                }\n                else if ( HTML.Tag.LI.equals( t ) || HTML.Tag.DD.equals( t ) )\n                {\n                    depth--;\n                }\n                else if ( t.isPreformatted() )\n                {\n                    preformatted--;\n                }\n                else if ( HTML.Tag.BODY.equals( t ) )\n                {\n                    body = false;\n                }\n                if ( body && ( t.breaksFlow() || t.isBlock() ) && !HTML.Tag.LI.equals( t ) )\n                {\n                    if ( ( HTML.Tag.P.equals( t ) || HTML.Tag.PRE.equals( t ) || HTML.Tag.OL.equals( t )\n                        || HTML.Tag.UL.equals( t ) || HTML.Tag.DL.equals( t ) )\n                        && numbering.isEmpty() )\n                    {\n                        newline( pendingNewline = false );\n                    }\n                    else\n                    {\n                        newline( true );\n                    }\n                }\n            }\n\n            /** {@inheritDoc} */\n            public void handleText( char[] data, int pos )\n            {\n                /*\n                 * NOTE: Parsers before JRE 1.6 will parse XML-conform simple tags like <br/> as \"<br>\" followed by\n                 * the text event \">...\" so we need to watch out for the closing angle bracket.\n                 */\n                int offset = 0;\n                if ( simpleTag && data[0] == '>' )\n                {\n                    simpleTag = false;\n                    for ( ++offset; offset < data.length && data[offset] <= ' '; )\n                    {\n                        offset++;\n                    }\n                }\n                if ( offset < data.length )\n                {\n                    String text = new String( data, offset, data.length - offset );\n                    text( text );\n                }\n            }\n\n            /** {@inheritDoc} */\n            public void flush()\n            {\n                flushPendingNewline();\n            }\n\n            /**\n             * Writes a line break to the plain text output.\n             * \n             * @param implicit A flag whether this is an explicit or implicit line break. Explicit line breaks are\n             *            always written to the output whereas consecutive implicit line breaks are merged into a single\n             *            line break.\n             */\n            private void newline( boolean implicit )\n            {\n                if ( implicit )\n                {\n                    pendingNewline = true;\n                }\n                else\n                {\n                    flushPendingNewline();\n                    sb.append( '\\n' );\n                }\n            }\n\n            /**\n             * Flushes a pending newline (if any).\n             */\n            private void flushPendingNewline()\n            {\n                if ( pendingNewline )\n                {\n                    pendingNewline = false;\n                    if ( sb.length() > 0 )\n                    {\n                        sb.append( '\\n' );\n                    }\n                }\n            }\n\n            /**\n             * Writes the specified character data to the plain text output. If the last output was a line break, the\n             * character data will automatically be prefixed with the current indent.\n             * \n             * @param data The character data, must not be <code>null<\/code>.\n             */\n            private void text( String data )\n            {\n                flushPendingNewline();\n                if ( sb.length() <= 0 || sb.charAt( sb.length() - 1 ) == '\\n' )\n                {\n                    for ( int i = 0; i < depth; i++ )\n                    {\n                        sb.append( '\\t' );\n                    }\n                }\n                String text;\n                if ( preformatted > 0 )\n                {\n                    text = data.replace( ' ', '\\u00A0' );\n                }\n                else\n                {\n                    text = data.replace( '\\n', ' ' );\n                }\n                sb.append( text );\n            }\n        };\n\n        try\n        {\n            parser.parse( new StringReader( PluginUtils.makeHtmlValid( html ) ), htmlCallback, true );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        return sb.toString().replace( '\\\"', '\\'' ); // for CDATA\n    }\n\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Stack;\n\nimport javax.swing.text.MutableAttributeSet;\nimport javax.swing.text.html.HTML;\nimport javax.swing.text.html.HTMLEditorKit;\nimport javax.swing.text.html.parser.ParserDelegator;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * Generates an <code>HelpMojo<\/code> class.\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    private static final String LS = System.getProperty( \"line.separator\" );\n\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    private static final String HELP_GOAL = \"help\";\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        if ( pluginDescriptor.getMojos() == null || pluginDescriptor.getMojos().size() < 1 )\n        {\n            return;\n        }\n\n        MojoDescriptor helpDescriptor = makeHelpDescriptor( pluginDescriptor );\n\n        // Verify that no help goal already exists\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            if ( descriptor.getGoal().equals( helpDescriptor.getGoal() )\n                && !descriptor.getImplementation().equals( helpDescriptor.getImplementation() ) )\n            {\n                if ( getLogger().isWarnEnabled() )\n                {\n                    getLogger().warn(\n                                      \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                          + \") already exists in this plugin. SKIPPED THE \"\n                                          + helpDescriptor.getImplementation() + \" GENERATION.\\n\" );\n                }\n\n                return;\n            }\n        }\n\n        String sourcePath = helpDescriptor.getImplementation().replace( '.', File.separatorChar ) + \".java\";\n        File helpClass = new File( destinationDirectory, sourcePath );\n        helpClass.getParentFile().mkdirs();\n\n        Writer writer = null;\n        try\n        {\n            writer = new FileWriter( helpClass );\n            writeClass( writer, pluginDescriptor, helpDescriptor );\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * Creates a minimalistic mojo descriptor for the generated help goal.\n     * \n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *            <code>null<\/code>.\n     * @return The mojo descriptor for the generated help goal, never <code>null<\/code>.\n     */\n    private static MojoDescriptor makeHelpDescriptor( PluginDescriptor pluginDescriptor )\n    {\n        MojoDescriptor descriptor = new MojoDescriptor();\n\n        descriptor.setPluginDescriptor( pluginDescriptor );\n\n        descriptor.setLanguage( \"java\" );\n\n        descriptor.setGoal( HELP_GOAL );\n\n        String packageName = discoverPackageName( pluginDescriptor );\n        if ( StringUtils.isNotEmpty( packageName ) )\n        {\n            descriptor.setImplementation( packageName + '.' + HELP_MOJO_CLASS_NAME );\n        }\n        else\n        {\n            descriptor.setImplementation( HELP_MOJO_CLASS_NAME );\n        }\n\n        descriptor.setDescription( \"Display help information on \" + pluginDescriptor.getArtifactId()\n            + \". Call <pre>  mvn \" + descriptor.getFullGoalName()\n            + \" -Ddetail=true -Dgoal=&lt;goal-name&gt;<\/pre> to display parameter details.\" );\n\n        try\n        {\n            {\n                Parameter param = new Parameter();\n                param.setName( \"detail\" );\n                param.setType( \"boolean\" );\n                param.setDescription( \"If <code>true<\/code>, display all settable properties for each goal.\" );\n                param.setDefaultValue( \"false\" );\n                param.setExpression( \"${detail}\" );\n                descriptor.addParameter( param );\n            }\n            {\n                Parameter param = new Parameter();\n                param.setName( \"goal\" );\n                param.setType( \"java.lang.String\" );\n                param.setDescription( \"The name of the goal for which to show help.\"\n                    + \" If unspecified, all goals will be displayed.\" );\n                param.setExpression( \"${goal}\" );\n                descriptor.addParameter( param );\n            }\n            {\n                Parameter param = new Parameter();\n                param.setName( \"lineLength\" );\n                param.setType( \"int\" );\n                param.setDescription( \"The maximum length of a display line.\" );\n                param.setDefaultValue( \"80\" );\n                param.setExpression( \"${lineLength}\" );\n                descriptor.addParameter( param );\n            }\n            {\n                Parameter param = new Parameter();\n                param.setName( \"indentSize\" );\n                param.setType( \"int\" );\n                param.setDescription( \"The number of spaces per indentation level.\" );\n                param.setDefaultValue( \"2\" );\n                param.setExpression( \"${indentSize}\" );\n                descriptor.addParameter( param );\n            }\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( \"Failed to setup parameters for help goal\", e );\n        }\n        \n        return descriptor;\n    }\n\n    /**\n     * Find the best package name, based on the number of hits of actual Mojo classes.\n     * \n     * @param pluginDescriptor\n     * @return the best name of the package for the generated mojo\n     */\n    private static String discoverPackageName( PluginDescriptor pluginDescriptor )\n    {\n        Map packageNames = new HashMap();\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            String impl = descriptor.getImplementation();\n            if ( impl.lastIndexOf( '.' ) != -1 )\n            {\n                String name = impl.substring( 0, impl.lastIndexOf( '.' ) );\n                if ( packageNames.get( name ) != null )\n                {\n                    int next = ( (Integer) packageNames.get( name ) ).intValue() + 1;\n                    packageNames.put( name, Integer.valueOf( \"\" + next ) );\n                }\n                else\n                {\n                    packageNames.put( name, Integer.valueOf( \"\" + 1 ) );\n                }\n            }\n            else\n            {\n                packageNames.put( \"\", Integer.valueOf( \"\" + 1 ) );\n            }\n        }\n\n        String packageName = \"\";\n        int max = 0;\n        for ( Iterator it = packageNames.keySet().iterator(); it.hasNext(); )\n        {\n            String key = it.next().toString();\n            int value = ( (Integer) packageNames.get( key ) ).intValue();\n            if ( value > max )\n            {\n                max = value;\n                packageName = key;\n            }\n        }\n\n        return packageName;\n    }\n\n    /**\n     * Generates the <code>HelpMojo<\/code> class.\n     * \n     * @param writer\n     * @param pluginDescriptor\n     * @param helpDescriptor\n     * @throws IOException if any\n     */\n    private static void writeClass( Writer writer, PluginDescriptor pluginDescriptor, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        String packageName = \"\";\n        String simpleName = helpDescriptor.getImplementation();\n        int dot = simpleName.lastIndexOf( '.' );\n        if ( dot >= 0 )\n        {\n            packageName = simpleName.substring( 0, dot );\n            simpleName = simpleName.substring( dot + 1 );\n        }\n\n        if ( packageName.length() > 0 )\n        {\n            writer.write( \"package \" + packageName + \";\" + LS );\n            writer.write( LS );\n        }\n\n        writeImports( writer );\n        writer.write( LS );\n\n        writeMojoJavadoc( writer, pluginDescriptor, helpDescriptor );\n\n        writer.write( \"public class \" + simpleName + LS );\n        writer.write( \"    extends AbstractMojo\" + LS );\n        writer.write( \"{\" + LS );\n\n        writeVariables( writer, helpDescriptor );\n\n        writer.write( LS );\n\n        writeExecute( writer, pluginDescriptor, helpDescriptor );\n\n        writer.write( LS );\n        writeUtilities( writer );\n        writer.write( \"}\" + LS );\n    }\n\n    private static void writeImports( Writer writer )\n        throws IOException\n    {\n        writer.write( \"import java.util.ArrayList;\" + LS );\n        writer.write( \"import java.util.Iterator;\" + LS );\n        writer.write( \"import java.util.List;\" + LS );\n        writer.write( LS );\n        writer.write( \"import org.apache.maven.plugin.AbstractMojo;\" + LS );\n        writer.write( \"import org.apache.maven.plugin.MojoExecutionException;\" + LS );\n    }\n\n    private static void writeMojoJavadoc( Writer writer, PluginDescriptor pluginDescriptor,\n                                          MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        writer.write( \"/**\" + LS );\n        writer.write( \" * \" + helpDescriptor.getDescription() + LS );\n        writer.write( \" *\" + LS );\n        writer.write( \" * @version generated on \" + new Date() + LS );\n        writer.write( \" * @goal \" + helpDescriptor.getGoal() + LS );\n        writer.write( \" * @requiresProject false\" + LS );\n        writer.write( \" */\" + LS );\n    }\n\n    private static void writeVariables( Writer writer, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        for ( Iterator it = helpDescriptor.getParameters().iterator(); it.hasNext(); )\n        {\n            Parameter param = (Parameter) it.next();\n            writer.write( \"    /**\" + LS );\n            writer.write( \"     * \" + StringUtils.escape( param.getDescription() ) + LS );\n            writer.write( \"     * \" + LS );\n            writer.write( \"     * @parameter\" );\n            if ( StringUtils.isNotEmpty( param.getExpression() ) )\n            {\n                writer.write( \" expression=\\\"\" );\n                writer.write( StringUtils.escape( param.getExpression() ) );\n                writer.write( \"\\\"\" );\n            }\n            if ( StringUtils.isNotEmpty( param.getDefaultValue() ) )\n            {\n                writer.write( \" default-value=\\\"\" );\n                writer.write( StringUtils.escape( param.getDefaultValue() ) );\n                writer.write( \"\\\"\" );\n            }\n            writer.write( LS );\n            writer.write( \"     */\" + LS );\n            writer.write( \"    private \" + param.getType() + \" \" + param.getName() + \";\" + LS );\n            writer.write( LS );\n        }\n    }\n\n    private static void writeExecute( Writer writer, PluginDescriptor pluginDescriptor, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        List mojoDescriptors = new ArrayList();\n\n        mojoDescriptors.add( helpDescriptor );\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor mojoDescriptor = (MojoDescriptor) it.next();\n\n            if ( !helpDescriptor.getGoal().equals( mojoDescriptor.getGoal() ) )\n            {\n                mojoDescriptors.add( mojoDescriptor );\n            }\n        }\n\n        PluginUtils.sortMojos( mojoDescriptors );\n\n        writer.write( \"    /** {@inheritDoc} */\" + LS );\n        writer.write( \"    public void execute()\" + LS );\n        writer.write( \"        throws MojoExecutionException\" + LS );\n        writer.write( \"    {\" + LS );\n\n        writer.write( \"        StringBuffer sb = new StringBuffer();\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        append( sb, \\\"\" + StringUtils.escape( pluginDescriptor.getId() ) + \"\\\", 0 );\" + LS );\n        writer.write( \"        append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        append( sb, \\\"\"\n            + StringUtils.escape( pluginDescriptor.getName() + \" \" + pluginDescriptor.getVersion() )\n            + \"\\\", 0 );\" + LS );\n        writer.write( \"        append( sb, \\\"\" + toDescription( pluginDescriptor.getDescription() ) + \"\\\", 1 );\" + LS );\n        writer.write( \"        append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( LS );\n\n        writer.write( \"        if ( goal == null || goal.length() <= 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            append( sb, \\\"This plugin has \" + mojoDescriptors.size() + \" \"\n            + ( mojoDescriptors.size() > 1 ? \"goals\" : \"goal\" ) + \":\\\", 0 );\" + LS );\n        writer.write( \"            append( sb, \\\"\\\", 0 );\" + LS );\n        writer.write( \"        }\" + LS );\n\n        writer.write( LS );\n\n        for ( Iterator it = mojoDescriptors.iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            writeGoal( writer, descriptor );\n        }\n\n        writer.write( \"        if ( getLog().isInfoEnabled() )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().info( sb.toString() );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    private static void writeGoal( Writer writer, MojoDescriptor descriptor )\n        throws IOException\n    {\n        writer.write( \"        if ( goal == null || goal.length() <= 0 || \\\"\"\n            + StringUtils.escape( descriptor.getGoal() ) + \"\\\".equals( goal ) )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            append( sb, \\\"\" + StringUtils.escape( descriptor.getFullGoalName() ) + \"\\\", 0 );\"\n            + LS );\n        writer.write( \"            append( sb, \\\"\" + toDescription( descriptor.getDescription() ) + \"\\\", 1 );\" + LS );\n        writer.write( \"            append( sb, \\\"\\\", 0 );\" + LS );\n\n        if ( descriptor.getParameters() != null && descriptor.getParameters().size() > 0 )\n        {\n            writer.write( \"            if ( detail )\" + LS );\n            writer.write( \"            {\" + LS );\n\n            writer.write( \"                append( sb, \\\"Available parameters:\\\", 1 );\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n\n            for ( Iterator it = descriptor.getParameters().iterator(); it.hasNext(); )\n            {\n                Parameter parameter = (Parameter) it.next();\n\n                if ( parameter.isEditable() )\n                {\n                    writer.write( LS );\n                    writeParameter( writer, parameter );\n                }\n            }\n\n            writer.write( \"            }\" + LS );\n        }\n\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n    }\n\n    private static void writeParameter( Writer writer, Parameter parameter )\n        throws IOException\n    {\n        String expression = parameter.getExpression();\n\n        if ( expression == null || !expression.startsWith( \"${component.\" ) )\n        {\n            String parameterName = StringUtils.escape( parameter.getName() );\n            String parameterDescription = toDescription( parameter.getDescription() );\n            String parameterDefaultValue = parameterName\n                + ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) ? \" (Default: \"\n                    + StringUtils.escape( parameter.getDefaultValue() ) + \")\" : \"\" );\n\n            writer.write( \"                append( sb, \\\"\" + parameterDefaultValue + \"\\\", 2 );\" + LS );\n            writer.write( \"                append( sb, \\\"\" + parameterDescription + \"\\\", 3 );\" + LS );\n            writer.write( \"                append( sb, \\\"\\\", 0 );\" + LS );\n        }\n    }\n\n    private static void writeUtilities( Writer writer )\n        throws IOException\n    {\n        writer.write( \"    /**\" + LS );\n        writer.write( \"     * <p>Repeat a String <code>n<\/code> times to form a new string.<\/p>\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @param str String to repeat\" + LS );\n        writer.write( \"     * @param repeat number of times to repeat str\" + LS );\n        writer.write( \"     * @return String with repeated String\" + LS );\n        writer.write( \"     * @throws NegativeArraySizeException if <code>repeat < 0<\/code>\" + LS );\n        writer.write( \"     * @throws NullPointerException if str is <code>null<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static String repeat( String str, int repeat )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        StringBuffer buffer = new StringBuffer( repeat * str.length() );\" + LS );\n        writer.write( LS );\n        writer.write( \"        for ( int i = 0; i < repeat; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            buffer.append( str );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return buffer.toString();\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    private void append( StringBuffer sb, String description, int indent )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        for ( Iterator it = toLines( description, indent ).iterator(); it.hasNext(); )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            sb.append( it.next().toString() ).append( '\\\\n' );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Splits the specified text into lines of convenient display length.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param text The text to split into lines, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param indent The base indentation level of each line, must not be negative.\" + LS );\n        writer.write( \"     * @return The sequence of display lines, never <code>null<\/code>.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private List toLines( String text, int indent )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        List lines = new ArrayList();\" + LS );\n        writer.write( LS );\n        writer.write( \"        String ind = repeat( \\\"\\\\t\\\", indent );\" + LS );\n        writer.write( \"        String[] plainLines = text.split( \\\"(\\\\r\\\\n)|(\\\\r)|(\\\\n)\\\" );\" + LS );\n        writer.write( \"        for ( int i = 0; i < plainLines.length; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            toLines( lines, ind + plainLines[i] );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return lines;\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Adds the specified line to the output sequence, performing line wrapping if necessary.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param lines The sequence of display lines, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @param line The line to add, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private void toLines( List lines, String line )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        int lineIndent = getIndentLevel( line );\" + LS );\n        writer.write( \"        StringBuffer buf = new StringBuffer( 256 );\" + LS );\n        writer.write( \"        String[] tokens = line.split( \\\" +\\\" );\" + LS );\n        writer.write( \"        for ( int i = 0; i < tokens.length; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            String token = tokens[i];\" + LS );\n        writer.write( \"            if ( i > 0 )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                if ( buf.length() + token.length() >= lineLength )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    lines.add( buf.toString() );\" + LS );\n        writer.write( \"                    buf.setLength( 0 );\" + LS );\n        writer.write( \"                    buf.append( repeat( \\\" \\\", lineIndent * indentSize ) );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( ' ' );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"            for ( int j = 0; j < token.length(); j++ )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                char c = token.charAt( j );\" + LS );\n        writer.write( \"                if ( c == '\\\\t' )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( repeat( \\\" \\\", indentSize - buf.length() % indentSize ) );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else if ( c == '\\\\u00A0' )\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( ' ' );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"                else\" + LS );\n        writer.write( \"                {\" + LS );\n        writer.write( \"                    buf.append( c );\" + LS );\n        writer.write( \"                }\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        lines.add( buf.toString() );\" + LS );\n        writer.write( \"    }\" + LS );\n\n        writer.write( LS );\n        writer.write( \"    /** \" + LS );\n        writer.write( \"     * Gets the indentation level of the specified line.\" + LS );\n        writer.write( \"     * \" + LS );\n        writer.write( \"     * @param line The line whose indentation level should be retrieved, must not be <code>null<\/code>.\" + LS );\n        writer.write( \"     * @return The indentation level of the line.\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static int getIndentLevel( String line )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        int level = 0;\" + LS );\n        writer.write( \"        for ( int i = 0; i < line.length() && line.charAt( i ) == '\\\\t'; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            level++;\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        for ( int i = level + 1; i <= level + 4 && i < line.length(); i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            if ( line.charAt( i ) == '\\\\t' )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                level++;\" + LS );\n        writer.write( \"                break;\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"        return level;\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    /**\n     * Gets the effective string to use for the plugin/mojo/parameter description.\n     * \n     * @param description The description of the element, may be <code>null<\/code>.\n     * @return The effective description string, never <code>null<\/code>.\n     */\n    private static String toDescription( String description )\n    {\n        if ( StringUtils.isNotEmpty( description ) )\n        {\n            return StringUtils.escape( toText( description ) );\n        }\n        else\n        {\n            return \"(no description available)\";\n        }\n    }\n\n    /**\n     * Converts a HTML fragment as extracted from a javadoc comment to a plain text string. This method tries to retain\n     * as much of the text formatting as possible by means of the following transformations:\n     * <ul>\n     * <li>List items are converted to leading tabs (U+0009), followed by the item number/bullet, another tab and\n     * finally the item contents. Each tab denotes an increase of indentation.<\/li>\n     * <li>Flow breaking elements as well as literal line terminators in preformatted text are converted to a newline\n     * (U+000A) to denote a mandatory line break.<\/li>\n     * <li>Consecutive spaces and line terminators from character data outside of preformatted text will be normalized\n     * to a single space. The resulting space denotes a possible point for line wrapping.<\/li>\n     * <li>Each space in preformatted text will be converted to a non-breaking space (U+00A0).<\/li>\n     * <\/ul>\n     * \n     * @param html The HTML fragment to convert to plain text, may be <code>null<\/code>.\n     * @return A string with HTML tags converted into pure text, never <code>null<\/code>.\n     */\n    protected static String toText( String html )\n    {\n        if ( StringUtils.isEmpty( html ) )\n        {\n            return \"\";\n        }\n\n        final StringBuffer sb = new StringBuffer();\n\n        HTMLEditorKit.Parser parser = new ParserDelegator();\n        HTMLEditorKit.ParserCallback htmlCallback = new HTMLEditorKit.ParserCallback()\n        {\n            /**\n             * Holds the index of the current item in a numbered list.\n             */\n            class Counter\n            {\n                public int value;\n            }\n\n            /**\n             * A flag whether the parser is currently in the body element.\n             */\n            private boolean body;\n\n            /**\n             * A flag whether the parser is currently processing preformatted text, actually a counter to track nesting.\n             */\n            private int preformatted;\n\n            /**\n             * The current indentation depth for the output.\n             */\n            private int depth;\n\n            /**\n             * A stack of {@link Counter} objects corresponding to the nesting of (un-)ordered lists. A\n             * <code>null<\/code> element denotes an unordered list.\n             */\n            private Stack numbering = new Stack();\n\n            /**\n             * A flag whether an implicit line break is pending in the output buffer. This flag is used to postpone the\n             * output of implicit line breaks until we are sure that are not to be merged with other implicit line\n             * breaks.\n             */\n            private boolean pendingNewline;\n\n            /**\n             * A flag whether we have just parsed a simple tag.\n             */\n            private boolean simpleTag;\n\n            /** {@inheritDoc} */\n            public void handleSimpleTag( HTML.Tag t, MutableAttributeSet a, int pos )\n            {\n                simpleTag = true;\n                if ( body && HTML.Tag.BR.equals( t ) )\n                {\n                    newline( false );\n                }\n            }\n\n            /** {@inheritDoc} */\n            public void handleStartTag( HTML.Tag t, MutableAttributeSet a, int pos )\n            {\n                simpleTag = false;\n                if ( body && ( t.breaksFlow() || t.isBlock() ) )\n                {\n                    newline( true );\n                }\n                if ( HTML.Tag.OL.equals( t ) )\n                {\n                    numbering.push( new Counter() );\n                }\n                else if ( HTML.Tag.UL.equals( t ) )\n                {\n                    numbering.push( null );\n                }\n                else if ( HTML.Tag.LI.equals( t ) )\n                {\n                    Counter counter = (Counter) numbering.peek();\n                    if ( counter == null )\n                    {\n                        text( \"-\\t\" );\n                    }\n                    else\n                    {\n                        text( ++counter.value + \".\\t\" );\n                    }\n                    depth++;\n                }\n                else if ( HTML.Tag.DD.equals( t ) )\n                {\n                    depth++;\n                }\n                else if ( t.isPreformatted() )\n                {\n                    preformatted++;\n                }\n                else if ( HTML.Tag.BODY.equals( t ) )\n                {\n                    body = true;\n                }\n            }\n\n            /** {@inheritDoc} */\n            public void handleEndTag( HTML.Tag t, int pos )\n            {\n                if ( HTML.Tag.OL.equals( t ) || HTML.Tag.UL.equals( t ) )\n                {\n                    numbering.pop();\n                }\n                else if ( HTML.Tag.LI.equals( t ) || HTML.Tag.DD.equals( t ) )\n                {\n                    depth--;\n                }\n                else if ( t.isPreformatted() )\n                {\n                    preformatted--;\n                }\n                else if ( HTML.Tag.BODY.equals( t ) )\n                {\n                    body = false;\n                }\n                if ( body && ( t.breaksFlow() || t.isBlock() ) && !HTML.Tag.LI.equals( t ) )\n                {\n                    if ( ( HTML.Tag.P.equals( t ) || HTML.Tag.PRE.equals( t ) || HTML.Tag.OL.equals( t )\n                        || HTML.Tag.UL.equals( t ) || HTML.Tag.DL.equals( t ) )\n                        && numbering.isEmpty() )\n                    {\n                        newline( pendingNewline = false );\n                    }\n                    else\n                    {\n                        newline( true );\n                    }\n                }\n            }\n\n            /** {@inheritDoc} */\n            public void handleText( char[] data, int pos )\n            {\n                /*\n                 * NOTE: Parsers before JRE 1.6 will parse XML-conform simple tags like <br/> as \"<br>\" followed by\n                 * the text event \">...\" so we need to watch out for the closing angle bracket.\n                 */\n                int offset = 0;\n                if ( simpleTag && data[0] == '>' )\n                {\n                    simpleTag = false;\n                    for ( ++offset; offset < data.length && data[offset] <= ' '; )\n                    {\n                        offset++;\n                    }\n                }\n                if ( offset < data.length )\n                {\n                    String text = new String( data, offset, data.length - offset );\n                    text( text );\n                }\n            }\n\n            /** {@inheritDoc} */\n            public void flush()\n            {\n                flushPendingNewline();\n            }\n\n            /**\n             * Writes a line break to the plain text output.\n             * \n             * @param implicit A flag whether this is an explicit or implicit line break. Explicit line breaks are\n             *            always written to the output whereas consecutive implicit line breaks are merged into a single\n             *            line break.\n             */\n            private void newline( boolean implicit )\n            {\n                if ( implicit )\n                {\n                    pendingNewline = true;\n                }\n                else\n                {\n                    flushPendingNewline();\n                    sb.append( '\\n' );\n                }\n            }\n\n            /**\n             * Flushes a pending newline (if any).\n             */\n            private void flushPendingNewline()\n            {\n                if ( pendingNewline )\n                {\n                    pendingNewline = false;\n                    if ( sb.length() > 0 )\n                    {\n                        sb.append( '\\n' );\n                    }\n                }\n            }\n\n            /**\n             * Writes the specified character data to the plain text output. If the last output was a line break, the\n             * character data will automatically be prefixed with the current indent.\n             * \n             * @param data The character data, must not be <code>null<\/code>.\n             */\n            private void text( String data )\n            {\n                flushPendingNewline();\n                if ( sb.length() <= 0 || sb.charAt( sb.length() - 1 ) == '\\n' )\n                {\n                    for ( int i = 0; i < depth; i++ )\n                    {\n                        sb.append( '\\t' );\n                    }\n                }\n                String text;\n                if ( preformatted > 0 )\n                {\n                    text = data.replace( ' ', '\\u00A0' );\n                }\n                else\n                {\n                    text = data.replace( '\\n', ' ' );\n                }\n                sb.append( text );\n            }\n        };\n\n        try\n        {\n            parser.parse( new StringReader( PluginUtils.makeHtmlValid( html ) ), htmlCallback, true );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        return sb.toString().replace( '\\\"', '\\'' ); // for CDATA\n    }\n\n}\n","lineNo":420}
{"Refactored Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.swing.text.html.HTMLEditorKit;\nimport javax.swing.text.html.parser.ParserDelegator;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * Generates an <code>HelpMojo<\/code> class.\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    private static final String LS = System.getProperty( \"line.separator\" );\n\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    private static final String HELP_GOAL = \"help\";\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        if ( pluginDescriptor.getMojos() == null || pluginDescriptor.getMojos().size() < 1 )\n        {\n            return;\n        }\n\n        MojoDescriptor helpDescriptor = makeHelpDescriptor( pluginDescriptor );\n\n        // Verify that no help goal already exists\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            if ( descriptor.getGoal().equals( helpDescriptor.getGoal() )\n                && !descriptor.getImplementation().equals( helpDescriptor.getImplementation() ) )\n            {\n                if ( getLogger().isWarnEnabled() )\n                {\n                    getLogger().warn(\n                                      \"\\n\\nA help goal (\" + descriptor.getImplementation()\n                                          + \") already exists in this plugin. SKIPPED THE \"\n                                          + helpDescriptor.getImplementation() + \" GENERATION.\\n\" );\n                }\n\n                return;\n            }\n        }\n\n        String sourcePath = helpDescriptor.getImplementation().replace( '.', File.separatorChar ) + \".java\";\n        File helpClass = new File( destinationDirectory, sourcePath );\n        helpClass.getParentFile().mkdirs();\n\n        Writer writer = null;\n        try\n        {\n            writer = new FileWriter( helpClass );\n            writeClass( writer, pluginDescriptor, helpDescriptor );\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * Creates a minimalistic mojo descriptor for the generated help goal.\n     * \n     * @param pluginDescriptor The descriptor of the plugin for which to generate a help goal, must not be\n     *            <code>null<\/code>.\n     * @return The mojo descriptor for the generated help goal, never <code>null<\/code>.\n     */\n    private static MojoDescriptor makeHelpDescriptor( PluginDescriptor pluginDescriptor )\n    {\n        MojoDescriptor descriptor = new MojoDescriptor();\n\n        descriptor.setPluginDescriptor( pluginDescriptor );\n\n        descriptor.setLanguage( \"java\" );\n\n        descriptor.setGoal( HELP_GOAL );\n\n        String packageName = discoverPackageName( pluginDescriptor );\n        if ( StringUtils.isNotEmpty( packageName ) )\n        {\n            descriptor.setImplementation( packageName + '.' + HELP_MOJO_CLASS_NAME );\n        }\n        else\n        {\n            descriptor.setImplementation( HELP_MOJO_CLASS_NAME );\n        }\n\n        descriptor.setDescription( \"Display help information on '\" + pluginDescriptor.getPluginLookupKey()\n            + \"' plugin. Call 'mvn \" + descriptor.getFullGoalName() + \" -Ddetail=true' to display parameter details.\" );\n\n        return descriptor;\n    }\n\n    /**\n     * Find the best package name, based on the number of hits of actual Mojo classes.\n     * \n     * @param pluginDescriptor\n     * @return the best name of the package for the generated mojo\n     */\n    private static String discoverPackageName( PluginDescriptor pluginDescriptor )\n    {\n        Map packageNames = new HashMap();\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            String impl = descriptor.getImplementation();\n            if ( impl.lastIndexOf( '.' ) != -1 )\n            {\n                String name = impl.substring( 0, impl.lastIndexOf( '.' ) );\n                if ( packageNames.get( name ) != null )\n                {\n                    int next = ( (Integer) packageNames.get( name ) ).intValue() + 1;\n                    packageNames.put( name, Integer.valueOf( \"\" + next ) );\n                }\n                else\n                {\n                    packageNames.put( name, Integer.valueOf( \"\" + 1 ) );\n                }\n            }\n            else\n            {\n                packageNames.put( \"\", Integer.valueOf( \"\" + 1 ) );\n            }\n        }\n\n        String packageName = \"\";\n        int max = 0;\n        for ( Iterator it = packageNames.keySet().iterator(); it.hasNext(); )\n        {\n            String key = it.next().toString();\n            int value = ( (Integer) packageNames.get( key ) ).intValue();\n            if ( value > max )\n            {\n                max = value;\n                packageName = key;\n            }\n        }\n\n        return packageName;\n    }\n\n    /**\n     * Generates the <code>HelpMojo<\/code> class.\n     * \n     * @param writer\n     * @param pluginDescriptor\n     * @param helpDescriptor\n     * @throws IOException if any\n     */\n    private static void writeClass( Writer writer, PluginDescriptor pluginDescriptor, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        String packageName = \"\";\n        String simpleName = helpDescriptor.getImplementation();\n        int dot = simpleName.lastIndexOf( '.' );\n        if ( dot >= 0 )\n        {\n            packageName = simpleName.substring( 0, dot );\n            simpleName = simpleName.substring( dot + 1 );\n        }\n\n        if ( packageName.length() > 0 )\n        {\n            writer.write( \"package \" + packageName + \";\" + LS );\n            writer.write( LS );\n        }\n\n        writeImports( writer );\n        writer.write( LS );\n\n        writeMojoJavadoc( writer, pluginDescriptor, helpDescriptor );\n\n        writer.write( \"public class \" + simpleName + LS );\n        writer.write( \"    extends AbstractMojo\" + LS );\n        writer.write( \"{\" + LS );\n\n        writeVariables( writer );\n\n        writer.write( LS );\n\n        writeExecute( writer, pluginDescriptor, helpDescriptor );\n\n        writer.write( LS );\n        writeUtilities( writer );\n        writer.write( \"}\" + LS );\n    }\n\n    private static void writeImports( Writer writer )\n        throws IOException\n    {\n        writer.write( \"import java.util.ArrayList;\" + LS );\n        writer.write( \"import java.util.Iterator;\" + LS );\n        writer.write( \"import java.util.List;\" + LS );\n        writer.write( \"import java.util.StringTokenizer;\" + LS );\n        writer.write( LS );\n        writer.write( \"import org.apache.maven.plugin.AbstractMojo;\" + LS );\n        writer.write( \"import org.apache.maven.plugin.MojoExecutionException;\" + LS );\n    }\n\n    private static void writeMojoJavadoc( Writer writer, PluginDescriptor pluginDescriptor,\n                                          MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        writer.write( \"/**\" + LS );\n        writer.write( \" * \" + helpDescriptor.getDescription() + LS );\n        writer.write( \" *\" + LS );\n        writer.write( \" * @version generated on \" + new Date() + LS );\n        writer.write( \" * @goal \" + helpDescriptor.getGoal() + LS );\n        writer.write( \" * @requiresProject false\" + LS );\n        writer.write( \" */\" + LS );\n    }\n\n    private static void writeVariables( Writer writer )\n        throws IOException\n    {\n        writer.write( \"    /** 80-character display buffer */\" + LS );\n        writer.write( \"    private static final int DEFAULT_WIDTH = 80;\" + LS );\n        writer.write( LS );\n        writer.write( \"    /** 2 indent spaces */\" + LS );\n        writer.write( \"    private static final int DEFAULT_INDENT = 2;\" + LS );\n        writer.write( LS );\n        writer.write( \"    /**\" + LS );\n        writer.write( \"     * If <code>true<\/code>, display all settable properties for each goal.\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @parameter expression=\\\"${detail}\\\" default-value=\\\"false\\\"\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private boolean detail;\" + LS );\n    }\n\n    private static void writeExecute( Writer writer, PluginDescriptor pluginDescriptor, MojoDescriptor helpDescriptor )\n        throws IOException\n    {\n        List mojoDescriptors = new ArrayList();\n\n        mojoDescriptors.add( helpDescriptor );\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor mojoDescriptor = (MojoDescriptor) it.next();\n\n            if ( !helpDescriptor.getGoal().equals( mojoDescriptor.getGoal() ) )\n            {\n                mojoDescriptors.add( mojoDescriptor );\n            }\n        }\n\n        Collections.sort( mojoDescriptors, new Comparator()\n        {\n\n            public int compare( Object arg0, Object arg1 )\n            {\n                MojoDescriptor mojo0 = (MojoDescriptor) arg0;\n                MojoDescriptor mojo1 = (MojoDescriptor) arg1;\n                return mojo0.getGoal().compareToIgnoreCase( mojo1.getGoal() );\n            }\n\n        } );\n\n        writer.write( \"    /** {@inheritDoc} */\" + LS );\n        writer.write( \"    public void execute()\" + LS );\n        writer.write( \"        throws MojoExecutionException\" + LS );\n        writer.write( \"    {\" + LS );\n\n        writer.write( \"        StringBuffer sb = new StringBuffer();\" + LS );\n        writer.write( LS );\n        writer.write( \"        sb.append( \\\"The '\" + pluginDescriptor.getPluginLookupKey() + \"' plugin has \"\n            + mojoDescriptors.size() + \" \"\n            + ( mojoDescriptors.size() > 1 ? \"goals\" : \"goal\" ) + \":\\\" ).append( \\\"\\\\n\\\" );\" + LS );\n        writer.write( \"        sb.append( \\\"\\\\n\\\" );\" + LS );\n\n        writer.write( LS );\n\n        for ( Iterator it = mojoDescriptors.iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            writeGoal( writer, descriptor );\n        }\n\n        writer.write( \"        if ( getLog().isInfoEnabled() )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().info( sb.toString() );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    private static void writeGoal( Writer writer, MojoDescriptor descriptor )\n        throws IOException\n    {\n        String goal = descriptor.getFullGoalName();\n        String description = StringUtils.isNotEmpty( descriptor.getDescription() ) ?\n            StringUtils.escape( toText( descriptor.getDescription() ) ) : \"No description available.\";\n\n        writer.write( \"        sb.append( \\\"\" + goal + \"\\\" ).append( \\\"\\\\n\\\" );\" + LS );\n        writer.write( \"        appendDescription( sb, \\\"\" + description + \"\\\", DEFAULT_INDENT );\" + LS );\n\n        if ( descriptor.getParameters() != null && descriptor.getParameters().size() > 0 )\n        {\n            writer.write( \"        if ( detail )\" + LS );\n            writer.write( \"        {\" + LS );\n\n            writer.write( \"            sb.append( \\\"\\\\n\\\" );\" + LS );\n            writer.write( LS );\n\n            writer.write( \"            sb.append( repeat( \\\" \\\", 2 ) );\" + LS );\n            writer.write( \"            sb.append( \\\"Available parameters:\\\" ).append( \\\"\\\\n\\\" );\" + LS );\n            writer.write( LS );\n            writer.write( \"            sb.append( \\\"\\\\n\\\" );\" + LS );\n            writer.write( LS );\n\n            for ( Iterator it = descriptor.getParameters().iterator(); it.hasNext(); )\n            {\n                Parameter parameter = (Parameter) it.next();\n\n                if ( parameter.isEditable() )\n                {\n                    writeParameter( writer, parameter );\n                }\n            }\n\n            writer.write( \"        }\" + LS );\n        }\n\n        writer.write( LS );\n        writer.write( \"        sb.append( \\\"\\\\n\\\" );\" + LS );\n        writer.write( LS );\n    }\n\n    private static void writeParameter( Writer writer, Parameter parameter )\n        throws IOException\n    {\n        String expression = parameter.getExpression();\n\n        if ( expression == null || !expression.startsWith( \"${component.\" ) )\n        {\n            String parameterName = parameter.getName();\n            String parameterDescription = StringUtils.isNotEmpty( parameter.getDescription() ) ?\n                StringUtils.escape( toText( parameter.getDescription() ) ) : \"No description available.\";\n            String parameterDefaultValue = parameterName\n                + ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) ? \" (Default: '\"\n                    + parameter.getDefaultValue() + \"')\" : \"\" );\n\n            writer.write( \"            appendDescription( sb, \\\"\" + parameterDefaultValue + \"\\\", 4 );\" + LS );\n            writer.write( \"            appendDescription( sb, \\\"\" + parameterDescription + \"\\\", 6 );\" + LS );\n        }\n    }\n\n    private static void writeUtilities( Writer writer )\n        throws IOException\n    {\n        writer.write( \"    /**\" + LS );\n        writer.write( \"     * <p>Repeat a String <code>n<\/code> times to form a new string.<\/p>\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @param str String to repeat\" + LS );\n        writer.write( \"     * @param repeat number of times to repeat str\" + LS );\n        writer.write( \"     * @return String with repeated String\" + LS );\n        writer.write( \"     * @throws NegativeArraySizeException if <code>repeat < 0<\/code>\" + LS );\n        writer.write( \"     * @throws NullPointerException if str is <code>null<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static String repeat( String str, int repeat )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        StringBuffer buffer = new StringBuffer( repeat * str.length() );\" + LS );\n        writer.write( LS );\n        writer.write( \"        for ( int i = 0; i < repeat; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            buffer.append( str );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return buffer.toString();\" + LS );\n        writer.write( \"    }\" + LS );\n        writer.write( LS );\n        writer.write( \"    /**\" + LS );\n        writer\n            .write( \"     * <p>Give a list of lines for the <code>str<\/code>. Each line is indented by <code>indent<\/code>\"\n                + LS );\n        writer.write( \"     * and has a maximum of <code>size<\/code> characters.<\/p>\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @param str String to split in lines\" + LS );\n        writer.write( \"     * @param indent the string to precede each line\" + LS );\n        writer.write( \"     * @param size the size of the character display buffer\" + LS );\n        writer.write( \"     * @return List of lines\" + LS );\n        writer.write( \"     * @throws IllegalArgumentException if <code>size < 0<\/code>\" + LS );\n        writer.write( \"     * @throws NullPointerException if str is <code>null<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static List toLines( String str, String indent, int size )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        List sentences = new ArrayList();\" + LS );\n        writer.write( LS );\n        writer.write( \"        if ( indent == null )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            indent = \\\"\\\";\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        if ( size < 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            throw new IllegalArgumentException( \\\"size should be positive\\\" );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        StringBuffer tmp = new StringBuffer( indent );\" + LS );\n        writer.write( \"        StringTokenizer tokenizer = new StringTokenizer( str, \\\" \\\" );\" + LS );\n        writer.write( \"        while ( tokenizer.hasMoreTokens() )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            String word = tokenizer.nextToken();\" + LS );\n        writer.write( LS );\n        writer.write( \"            if ( tmp.length() + word.length() + 1 < size )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                tmp.append( word ).append( \\\" \\\" );\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"            else\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                sentences.add( tmp.toString() );\" + LS );\n        writer.write( \"                tmp = new StringBuffer( indent );\" + LS );\n        writer.write( \"                tmp.append( word ).append( \\\" \\\" );\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        if ( tmp.toString().length() > 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            sentences.add( tmp.toString() );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return sentences;\" + LS );\n        writer.write( \"    }\" + LS );\n        writer.write( LS );\n        writer.write( \"    private static void appendDescription( StringBuffer sb, String description, int indent )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        for ( Iterator it = toLines( description, repeat( \\\" \\\", indent ), DEFAULT_WIDTH ).iterator(); it.hasNext(); )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            sb.append( it.next().toString() ).append( \\\"\\\\n\\\" );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    /**\n     * Remove HTML tags from a string\n     *\n     * @param str\n     * @return a String with HTML tags into pure text\n     * @throws IOException if any\n     */\n    protected static String toText( String str )\n        throws IOException\n    {\n        if ( StringUtils.isEmpty( str ) )\n        {\n            return \"\";\n        }\n\n        final StringBuffer sb = new StringBuffer();\n\n        HTMLEditorKit.Parser parser = new ParserDelegator();\n        HTMLEditorKit.ParserCallback htmlCallback = new HTMLEditorKit.ParserCallback()\n        {\n            /** {@inheritDoc} */\n            public void handleText( char[] data, int pos )\n            {\n                // the parser parses things like <br /> as \"\\n>\"\n                if ( data[0] == '>' )\n                {\n                    for ( int i = 1; i < data.length; i++ )\n                    {\n                        if ( data[i] == '\\n' )\n                        {\n                            sb.append( ' ' );\n                        }\n                        else\n                        {\n                            sb.append( data[i] );\n                        }\n                    }\n                }\n                else\n                {\n                    for ( int i = 0; i < data.length; i++ )\n                    {\n                        if ( data[i] == '\\n' )\n                        {\n                            sb.append( ' ' );\n                        }\n                        else\n                        {\n                            sb.append( data[i] );\n                        }\n                    }\n                }\n            }\n        };\n\n        parser.parse( new StringReader( PluginUtils.makeHtmlValid( str ) ), htmlCallback, true );\n\n        return StringUtils.replace( sb.toString(), \"\\\"\", \"'\" ); // for CDATA\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.swing.text.html.HTMLEditorKit;\nimport javax.swing.text.html.parser.ParserDelegator;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * Generates an <code>HelpMojo<\/code> class.\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    private static final String LS = System.getProperty( \"line.separator\" );\n\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    private static final String HELP_GOAL = \"help\";\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        if ( pluginDescriptor.getMojos() == null || pluginDescriptor.getMojos().size() < 1 )\n        {\n            return;\n        }\n\n        String packageName = discoverPackageName( pluginDescriptor );\n\n        File helpClass = new File( destinationDirectory, packageName.replace( '.', File.separatorChar )\n            + File.separator + HELP_MOJO_CLASS_NAME + \".java\" );\n\n        // Verify that no help goal already exists\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            if ( descriptor.getGoal().equals( HELP_GOAL )\n                && !descriptor.getImplementation().equals( packageName + \".\" + HELP_MOJO_CLASS_NAME ) )\n            {\n                if ( getLogger().isWarnEnabled() )\n                {\n                    getLogger().warn( \"\\n\\nAn help goal (\" + descriptor.getImplementation()\n                        + \") already exists in this plugin. SKIPPED THE \" + HELP_MOJO_CLASS_NAME + \" GENERATION.\\n\" );\n                }\n\n                return;\n            }\n        }\n\n        helpClass.getParentFile().mkdirs();\n\n        Writer writer = null;\n        try\n        {\n            writer = new FileWriter( helpClass );\n            writeClass( writer, packageName, pluginDescriptor );\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * @return the help goal for the generated mojo\n     */\n    private static String getHelpGoalName()\n    {\n        return HELP_GOAL;\n    }\n\n    /**\n     * @return the full help goal name for the generated mojo\n     */\n    private static String getFullHelpGoalName( PluginDescriptor pluginDescriptor )\n    {\n        return pluginDescriptor.getGoalPrefix() + \":\" + getHelpGoalName();\n    }\n\n    /**\n     * @param pluginDescriptor\n     * @return the help description for the generated mojo\n     */\n    private static String getHelpDescription( PluginDescriptor pluginDescriptor )\n    {\n        return \"Display help information on '\" + pluginDescriptor.getPluginLookupKey() + \"' plugin. Call 'mvn \"\n            + getFullHelpGoalName( pluginDescriptor ) + \" -Ddetail=true' to display all details.\";\n    }\n\n    /**\n     * Find the best package name, based on the number of hits of actual Mojo classes.\n     *\n     * @param pluginDescriptor\n     * @return the best name of the package for the generated mojo\n     */\n    private static String discoverPackageName( PluginDescriptor pluginDescriptor )\n    {\n        Map packageNames = new HashMap();\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            String impl = descriptor.getImplementation();\n            if ( impl.lastIndexOf( '.' ) != -1 )\n            {\n                String name = impl.substring( 0, impl.lastIndexOf( '.' ) );\n                if ( packageNames.get( name ) != null )\n                {\n                    int next = ( (Integer) packageNames.get( name ) ).intValue() + 1;\n                    packageNames.put( name, Integer.valueOf( \"\" + next ) );\n                }\n                else\n                {\n                    packageNames.put( name, Integer.valueOf( \"\" + 1 ) );\n                }\n            }\n            else\n            {\n                packageNames.put( \"\", Integer.valueOf( \"\" + 1 ) );\n            }\n        }\n\n        String packageName = \"\";\n        int max = 0;\n        for ( Iterator it = packageNames.keySet().iterator(); it.hasNext(); )\n        {\n            String key = it.next().toString();\n            int value = ( (Integer) packageNames.get( key ) ).intValue();\n            if ( value > max )\n            {\n                max = value;\n                packageName = key;\n            }\n        }\n\n        return packageName;\n    }\n\n    /**\n     * Generated the <code>HelpMojo<\/code> class.\n     *\n     * @param writer\n     * @param packageName\n     * @param pluginDescriptor\n     * @throws IOException if any\n     */\n    private static void writeClass( Writer writer, String packageName, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        if ( packageName.length() > 0 )\n        {\n            writer.write( \"package \" + packageName + \";\" + LS );\n            writer.write( LS );\n        }\n\n        writeImports( writer );\n        writer.write( LS );\n\n        writeMojoJavadoc( writer, pluginDescriptor );\n\n        writer.write( \"public class HelpMojo\" + LS );\n        writer.write( \"    extends AbstractMojo\" + LS );\n        writer.write( \"{\" + LS );\n\n        writeVariables( writer );\n\n        writer.write( LS );\n\n        writeExecute( writer, pluginDescriptor );\n\n        writer.write( LS );\n        writeUtilities( writer );\n        writer.write( \"}\" + LS );\n    }\n\n    private static void writeImports( Writer writer )\n        throws IOException\n    {\n        writer.write( \"import java.util.ArrayList;\" + LS );\n        writer.write( \"import java.util.Iterator;\" + LS );\n        writer.write( \"import java.util.List;\" + LS );\n        writer.write( \"import java.util.StringTokenizer;\" + LS );\n        writer.write( LS );\n        writer.write( \"import org.apache.maven.plugin.AbstractMojo;\" + LS );\n        writer.write( \"import org.apache.maven.plugin.MojoExecutionException;\" + LS );\n    }\n\n    private static void writeMojoJavadoc( Writer writer, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        writer.write( \"/**\" + LS );\n        writer.write( \" * \" + getHelpDescription( pluginDescriptor ) + LS );\n        writer.write( \" *\" + LS );\n        writer.write( \" * @version generated on \" + new Date() + LS );\n        writer.write( \" * @goal \" + getHelpGoalName() + LS );\n        writer.write( \" * @requiresProject false\" + LS );\n        writer.write( \" */\" + LS );\n    }\n\n    private static void writeVariables( Writer writer )\n        throws IOException\n    {\n        writer.write( \"    /** 80-character display buffer */\" + LS );\n        writer.write( \"    private static final int DEFAULT_WIDTH = 80;\" + LS );\n        writer.write( LS );\n        writer.write( \"    /** 2 indent spaces */\" + LS );\n        writer.write( \"    private static final int DEFAULT_INDENT = 2;\" + LS );\n        writer.write( LS );\n        writer.write( \"    /**\" + LS );\n        writer.write( \"     * If <code>true<\/code>, display all settable properties for each goal.\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @parameter expression=\\\"${detail}\\\" default-value=\\\"false\\\"\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private boolean detail;\" + LS );\n    }\n\n    private static void writeExecute( Writer writer, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        List mojoDescriptors = new ArrayList( pluginDescriptor.getMojos() );\n\n        for ( Iterator it = mojoDescriptors.iterator(); it.hasNext(); )\n        {\n            MojoDescriptor mojoDescriptor = (MojoDescriptor) it.next();\n\n            if ( getHelpGoalName().equals( mojoDescriptor.getGoal() ) )\n            {\n                // remove previously generated help goal\n                it.remove();\n            }\n        }\n\n        Collections.sort( mojoDescriptors, new Comparator()\n        {\n\n            public int compare( Object arg0, Object arg1 )\n            {\n                MojoDescriptor mojo0 = (MojoDescriptor) arg0;\n                MojoDescriptor mojo1 = (MojoDescriptor) arg1;\n                return mojo0.getGoal().compareToIgnoreCase( mojo1.getGoal() );\n            }\n\n        } );\n\n        writer.write( \"    /** {@inheritDoc} */\" + LS );\n        writer.write( \"    public void execute()\" + LS );\n        writer.write( \"        throws MojoExecutionException\" + LS );\n        writer.write( \"    {\" + LS );\n\n        writer.write( \"        StringBuffer sb = new StringBuffer();\" + LS );\n        writer.write( LS );\n        writer.write( \"        sb.append( \\\"The '\" + pluginDescriptor.getPluginLookupKey() + \"' plugin has \"\n            + ( mojoDescriptors.size() + 1 ) + \" \"\n            + ( ( mojoDescriptors.size() + 1 ) > 1 ? \"goals\" : \"goal\" ) + \":\\\" ).append( \\\"\\\\n\\\" );\" + LS );\n        writer.write( \"        sb.append( \\\"\\\\n\\\" );\" + LS );\n\n        writer.write( LS );\n\n        for ( Iterator it = mojoDescriptors.iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            writeGoal( writer, descriptor );\n        }\n\n        // TODO Should be discovered\n        writer.write( \"        sb.append( \\\"\" + getFullHelpGoalName( pluginDescriptor ) + \"\\\" ).append( \\\"\\\\n\\\" );\"\n            + LS );\n        writer.write( \"        appendDescription( sb, \\\"\" + getHelpDescription( pluginDescriptor ) + \"\\\", DEFAULT_INDENT );\" + LS );\n\n        writer.write( LS );\n\n        writer.write( \"        if ( getLog().isInfoEnabled() )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().info( sb.toString() );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    private static void writeGoal( Writer writer, MojoDescriptor descriptor )\n        throws IOException\n    {\n        String goal = descriptor.getFullGoalName();\n        String description = StringUtils.isNotEmpty( descriptor.getDescription() ) ?\n            StringUtils.escape( toText( descriptor.getDescription() ) ) : \"No description available.\";\n\n        writer.write( \"        sb.append( \\\"\" + goal + \"\\\" ).append( \\\"\\\\n\\\" );\" + LS );\n        writer.write( \"        appendDescription( sb, \\\"\" + description + \"\\\", DEFAULT_INDENT );\" + LS );\n\n        if ( descriptor.getParameters() != null && descriptor.getParameters().size() > 0 )\n        {\n            writer.write( \"        if ( detail )\" + LS );\n            writer.write( \"        {\" + LS );\n\n            writer.write( \"            sb.append( \\\"\\\\n\\\" );\" + LS );\n            writer.write( LS );\n\n            writer.write( \"            sb.append( repeat( \\\" \\\", 2 ) );\" + LS );\n            writer.write( \"            sb.append( \\\"Available parameters:\\\" ).append( \\\"\\\\n\\\" );\" + LS );\n            writer.write( LS );\n            writer.write( \"            sb.append( \\\"\\\\n\\\" );\" + LS );\n            writer.write( LS );\n\n            for ( Iterator it = descriptor.getParameters().iterator(); it.hasNext(); )\n            {\n                Parameter parameter = (Parameter) it.next();\n\n                if ( parameter.isEditable() )\n                {\n                    writeParameter( writer, parameter );\n                }\n            }\n\n            writer.write( \"        }\" + LS );\n        }\n\n        writer.write( LS );\n        writer.write( \"        sb.append( \\\"\\\\n\\\" );\" + LS );\n        writer.write( LS );\n    }\n\n    private static void writeParameter( Writer writer, Parameter parameter )\n        throws IOException\n    {\n        String expression = parameter.getExpression();\n\n        if ( expression == null || !expression.startsWith( \"${component.\" ) )\n        {\n            String parameterName = parameter.getName();\n            String parameterDescription = StringUtils.isNotEmpty( parameter.getDescription() ) ?\n                StringUtils.escape( toText( parameter.getDescription() ) ) : \"No description available.\";\n            String parameterDefaultValue = parameterName\n                + ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) ? \" (Default: '\"\n                    + parameter.getDefaultValue() + \"')\" : \"\" );\n\n            writer.write( \"            appendDescription( sb, \\\"\" + parameterDefaultValue + \"\\\", 4 );\" + LS );\n            writer.write( \"            appendDescription( sb, \\\"\" + parameterDescription + \"\\\", 6 );\" + LS );\n        }\n    }\n\n    private static void writeUtilities( Writer writer )\n        throws IOException\n    {\n        writer.write( \"    /**\" + LS );\n        writer.write( \"     * <p>Repeat a String <code>n<\/code> times to form a new string.<\/p>\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @param str String to repeat\" + LS );\n        writer.write( \"     * @param repeat number of times to repeat str\" + LS );\n        writer.write( \"     * @return String with repeated String\" + LS );\n        writer.write( \"     * @throws NegativeArraySizeException if <code>repeat < 0<\/code>\" + LS );\n        writer.write( \"     * @throws NullPointerException if str is <code>null<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static String repeat( String str, int repeat )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        StringBuffer buffer = new StringBuffer( repeat * str.length() );\" + LS );\n        writer.write( LS );\n        writer.write( \"        for ( int i = 0; i < repeat; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            buffer.append( str );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return buffer.toString();\" + LS );\n        writer.write( \"    }\" + LS );\n        writer.write( LS );\n        writer.write( \"    /**\" + LS );\n        writer\n            .write( \"     * <p>Give a list of lines for the <code>str<\/code>. Each line is indented by <code>indent<\/code>\"\n                + LS );\n        writer.write( \"     * and has a maximum of <code>size<\/code> characters.<\/p>\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @param str String to split in lines\" + LS );\n        writer.write( \"     * @param indent the string to precede each line\" + LS );\n        writer.write( \"     * @param size the size of the character display buffer\" + LS );\n        writer.write( \"     * @return List of lines\" + LS );\n        writer.write( \"     * @throws IllegalArgumentException if <code>size < 0<\/code>\" + LS );\n        writer.write( \"     * @throws NullPointerException if str is <code>null<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static List toLines( String str, String indent, int size )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        List sentences = new ArrayList();\" + LS );\n        writer.write( LS );\n        writer.write( \"        if ( indent == null )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            indent = \\\"\\\";\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        if ( size < 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            throw new IllegalArgumentException( \\\"size should be positive\\\" );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        StringBuffer tmp = new StringBuffer( indent );\" + LS );\n        writer.write( \"        StringTokenizer tokenizer = new StringTokenizer( str, \\\" \\\" );\" + LS );\n        writer.write( \"        while ( tokenizer.hasMoreTokens() )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            String word = tokenizer.nextToken();\" + LS );\n        writer.write( LS );\n        writer.write( \"            if ( tmp.length() + word.length() + 1 < size )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                tmp.append( word ).append( \\\" \\\" );\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"            else\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                sentences.add( tmp.toString() );\" + LS );\n        writer.write( \"                tmp = new StringBuffer( indent );\" + LS );\n        writer.write( \"                tmp.append( word ).append( \\\" \\\" );\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        if ( tmp.toString().length() > 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            sentences.add( tmp.toString() );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return sentences;\" + LS );\n        writer.write( \"    }\" + LS );\n        writer.write( LS );\n        writer.write( \"    private static void appendDescription( StringBuffer sb, String description, int indent )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        for ( Iterator it = toLines( description, repeat( \\\" \\\", indent ), DEFAULT_WIDTH ).iterator(); it.hasNext(); )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            sb.append( it.next().toString() ).append( \\\"\\\\n\\\" );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    /**\n     * Remove HTML tags from a string\n     *\n     * @param str\n     * @return a String with HTML tags into pure text\n     * @throws IOException if any\n     */\n    protected static String toText( String str )\n        throws IOException\n    {\n        if ( StringUtils.isEmpty( str ) )\n        {\n            return \"\";\n        }\n\n        final StringBuffer sb = new StringBuffer();\n\n        HTMLEditorKit.Parser parser = new ParserDelegator();\n        HTMLEditorKit.ParserCallback htmlCallback = new HTMLEditorKit.ParserCallback()\n        {\n            /** {@inheritDoc} */\n            public void handleText( char[] data, int pos )\n            {\n                // the parser parses things like <br /> as \"\\n>\"\n                if ( data[0] == '>' )\n                {\n                    for ( int i = 1; i < data.length; i++ )\n                    {\n                        if ( data[i] == '\\n' )\n                        {\n                            sb.append( ' ' );\n                        }\n                        else\n                        {\n                            sb.append( data[i] );\n                        }\n                    }\n                }\n                else\n                {\n                    for ( int i = 0; i < data.length; i++ )\n                    {\n                        if ( data[i] == '\\n' )\n                        {\n                            sb.append( ' ' );\n                        }\n                        else\n                        {\n                            sb.append( data[i] );\n                        }\n                    }\n                }\n            }\n        };\n\n        parser.parse( new StringReader( PluginUtils.makeHtmlValid( str ) ), htmlCallback, true );\n\n        return StringUtils.replace( sb.toString(), \"\\\"\", \"'\" ); // for CDATA\n    }\n}\n","lineNo":87}
{"Refactored Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.swing.text.html.HTMLEditorKit;\nimport javax.swing.text.html.parser.ParserDelegator;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * Generates an <code>HelpMojo<\/code> class.\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    private static final String LS = System.getProperty( \"line.separator\" );\n\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    private static final String HELP_GOAL = \"help\";\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        if ( pluginDescriptor.getMojos() == null || pluginDescriptor.getMojos().size() < 1 )\n        {\n            return;\n        }\n\n        String packageName = discoverPackageName( pluginDescriptor );\n\n        File helpClass = new File( destinationDirectory, packageName.replace( '.', File.separatorChar )\n            + File.separator + HELP_MOJO_CLASS_NAME + \".java\" );\n\n        // Verify that no help goal already exists\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            if ( descriptor.getGoal().equals( HELP_GOAL )\n                && !descriptor.getImplementation().equals( packageName + \".\" + HELP_MOJO_CLASS_NAME ) )\n            {\n                if ( getLogger().isWarnEnabled() )\n                {\n                    getLogger().warn( \"\\n\\nAn help goal (\" + descriptor.getImplementation()\n                        + \") already exists in this plugin. SKIPPED THE \" + HELP_MOJO_CLASS_NAME + \" GENERATION.\\n\" );\n                }\n\n                return;\n            }\n        }\n\n        helpClass.getParentFile().mkdirs();\n\n        Writer writer = null;\n        try\n        {\n            writer = new FileWriter( helpClass );\n            writeClass( writer, packageName, pluginDescriptor );\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * @return the help goal for the generated mojo\n     */\n    private static String getHelpGoalName()\n    {\n        return HELP_GOAL;\n    }\n\n    /**\n     * @return the full help goal name for the generated mojo\n     */\n    private static String getFullHelpGoalName( PluginDescriptor pluginDescriptor )\n    {\n        return pluginDescriptor.getGoalPrefix() + \":\" + getHelpGoalName();\n    }\n\n    /**\n     * @param pluginDescriptor\n     * @return the help description for the generated mojo\n     */\n    private static String getHelpDescription( PluginDescriptor pluginDescriptor )\n    {\n        return \"Display help information on '\" + pluginDescriptor.getPluginLookupKey() + \"' plugin. Call 'mvn \"\n            + getFullHelpGoalName( pluginDescriptor ) + \" -Ddetail=true' to display all details.\";\n    }\n\n    /**\n     * Find the best package name, based on the number of hits of actual Mojo classes.\n     *\n     * @param pluginDescriptor\n     * @return the best name of the package for the generated mojo\n     */\n    private static String discoverPackageName( PluginDescriptor pluginDescriptor )\n    {\n        Map packageNames = new HashMap();\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            String impl = descriptor.getImplementation();\n            if ( impl.lastIndexOf( '.' ) != -1 )\n            {\n                String name = impl.substring( 0, impl.lastIndexOf( '.' ) );\n                if ( packageNames.get( name ) != null )\n                {\n                    int next = ( (Integer) packageNames.get( name ) ).intValue() + 1;\n                    packageNames.put( name, Integer.valueOf( \"\" + next ) );\n                }\n                else\n                {\n                    packageNames.put( name, Integer.valueOf( \"\" + 1 ) );\n                }\n            }\n            else\n            {\n                packageNames.put( \"\", Integer.valueOf( \"\" + 1 ) );\n            }\n        }\n\n        String packageName = \"\";\n        int max = 0;\n        for ( Iterator it = packageNames.keySet().iterator(); it.hasNext(); )\n        {\n            String key = it.next().toString();\n            int value = ( (Integer) packageNames.get( key ) ).intValue();\n            if ( value > max )\n            {\n                max = value;\n                packageName = key;\n            }\n        }\n\n        return packageName;\n    }\n\n    /**\n     * Generated the <code>HelpMojo<\/code> class.\n     *\n     * @param writer\n     * @param packageName\n     * @param pluginDescriptor\n     * @throws IOException if any\n     */\n    private static void writeClass( Writer writer, String packageName, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        if ( packageName.length() > 0 )\n        {\n            writer.write( \"package \" + packageName + \";\" + LS );\n            writer.write( LS );\n        }\n\n        writeImports( writer );\n        writer.write( LS );\n\n        writeMojoJavadoc( writer, pluginDescriptor );\n\n        writer.write( \"public class HelpMojo\" + LS );\n        writer.write( \"    extends AbstractMojo\" + LS );\n        writer.write( \"{\" + LS );\n\n        writeVariables( writer );\n\n        writer.write( LS );\n\n        writeExecute( writer, pluginDescriptor );\n\n        writer.write( LS );\n        writeUtilities( writer );\n        writer.write( \"}\" + LS );\n    }\n\n    private static void writeImports( Writer writer )\n        throws IOException\n    {\n        writer.write( \"import java.util.ArrayList;\" + LS );\n        writer.write( \"import java.util.Iterator;\" + LS );\n        writer.write( \"import java.util.List;\" + LS );\n        writer.write( \"import java.util.StringTokenizer;\" + LS );\n        writer.write( LS );\n        writer.write( \"import org.apache.maven.plugin.AbstractMojo;\" + LS );\n        writer.write( \"import org.apache.maven.plugin.MojoExecutionException;\" + LS );\n    }\n\n    private static void writeMojoJavadoc( Writer writer, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        writer.write( \"/**\" + LS );\n        writer.write( \" * \" + getHelpDescription( pluginDescriptor ) + LS );\n        writer.write( \" *\" + LS );\n        writer.write( \" * @version generated on \" + new Date() + LS );\n        writer.write( \" * @goal \" + getHelpGoalName() + LS );\n        writer.write( \" * @requiresProject false\" + LS );\n        writer.write( \" */\" + LS );\n    }\n\n    private static void writeVariables( Writer writer )\n        throws IOException\n    {\n        writer.write( \"    /** 80-character display buffer */\" + LS );\n        writer.write( \"    private static final int DEFAULT_WIDTH = 80;\" + LS );\n        writer.write( LS );\n        writer.write( \"    /** 2 indent spaces */\" + LS );\n        writer.write( \"    private static final int DEFAULT_INDENT = 2;\" + LS );\n        writer.write( LS );\n        writer.write( \"    /**\" + LS );\n        writer.write( \"     * If <code>true<\/code>, display all settable properties for each goal.\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @parameter expression=\\\"${detail}\\\" default-value=\\\"false\\\"\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private boolean detail;\" + LS );\n    }\n\n    private static void writeExecute( Writer writer, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        List mojoDescriptors = new ArrayList( pluginDescriptor.getMojos() );\n\n        for ( Iterator it = mojoDescriptors.iterator(); it.hasNext(); )\n        {\n            MojoDescriptor mojoDescriptor = (MojoDescriptor) it.next();\n\n            if ( getHelpGoalName().equals( mojoDescriptor.getGoal() ) )\n            {\n                // remove previously generated help goal\n                it.remove();\n            }\n        }\n\n        Collections.sort( mojoDescriptors, new Comparator()\n        {\n\n            public int compare( Object arg0, Object arg1 )\n            {\n                MojoDescriptor mojo0 = (MojoDescriptor) arg0;\n                MojoDescriptor mojo1 = (MojoDescriptor) arg1;\n                return mojo0.getGoal().compareToIgnoreCase( mojo1.getGoal() );\n            }\n\n        } );\n\n        writer.write( \"    /** {@inheritDoc} */\" + LS );\n        writer.write( \"    public void execute()\" + LS );\n        writer.write( \"        throws MojoExecutionException\" + LS );\n        writer.write( \"    {\" + LS );\n\n        writer.write( \"        StringBuffer sb = new StringBuffer();\" + LS );\n        writer.write( LS );\n        writer.write( \"        sb.append( \\\"The '\" + pluginDescriptor.getPluginLookupKey() + \"' plugin has \"\n            + ( mojoDescriptors.size() + 1 ) + \" \"\n            + ( ( mojoDescriptors.size() + 1 ) > 1 ? \"goals\" : \"goal\" ) + \":\\\" ).append( \\\"\\\\n\\\" );\" + LS );\n        writer.write( \"        sb.append( \\\"\\\\n\\\" );\" + LS );\n\n        writer.write( LS );\n\n        for ( Iterator it = mojoDescriptors.iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            String goal = descriptor.getFullGoalName();\n            String description = StringUtils.isNotEmpty( descriptor.getDescription() ) ?\n                StringUtils.escape( toText( descriptor.getDescription() ) ) : \"No description available.\";\n\n            writer.write( \"        sb.append( \\\"\" + goal + \"\\\" ).append( \\\"\\\\n\\\" );\" + LS );\n            writer.write( \"        appendDescription( sb, \\\"\" + description + \"\\\", DEFAULT_INDENT );\" + LS );\n\n            if ( descriptor.getParameters() != null && descriptor.getParameters().size() > 0 )\n            {\n                writer.write( \"        if ( detail )\" + LS );\n                writer.write( \"        {\" + LS );\n\n                writer.write( \"            sb.append( \\\"\\\\n\\\" );\" + LS );\n                writer.write( LS );\n\n                writer.write( \"            sb.append( repeat( \\\" \\\", 2 ) );\" + LS );\n                writer.write( \"            sb.append( \\\"Available parameters:\\\" ).append( \\\"\\\\n\\\" );\" + LS );\n                writer.write( LS );\n                writer.write( \"            sb.append( \\\"\\\\n\\\" );\" + LS );\n                writer.write( LS );\n\n                for ( Iterator it2 = descriptor.getParameters().iterator(); it2.hasNext(); )\n                {\n                    Parameter parameter = (Parameter) it2.next();\n\n                    if ( parameter.isEditable() )\n                    {\n                        String expression = parameter.getExpression();\n\n                        if ( expression == null || !expression.startsWith( \"${component.\" ) )\n                        {\n                            String parameterName = parameter.getName();\n                            String parameterDescription = StringUtils.isNotEmpty( parameter.getDescription() ) ?\n                                StringUtils.escape( toText( parameter.getDescription() ) ) : \"No description available.\";\n                            String parameterDefaultValue = parameterName\n                                + ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) ? \" (Default: '\"\n                                    + parameter.getDefaultValue() + \"')\" : \"\" );\n\n                            writer.write( \"            appendDescription( sb, \\\"\" + parameterDefaultValue + \"\\\", 4 );\" + LS );\n                            writer.write( \"            appendDescription( sb, \\\"\" + parameterDescription + \"\\\", 6 );\" + LS );\n                        }\n                    }\n                }\n\n                writer.write( \"        }\" + LS );\n            }\n\n            writer.write( LS );\n            writer.write( \"        sb.append( \\\"\\\\n\\\" );\" + LS );\n            writer.write( LS );\n        }\n\n        // TODO Should be discovered\n        writer.write( \"        sb.append( \\\"\" + getFullHelpGoalName( pluginDescriptor ) + \"\\\" ).append( \\\"\\\\n\\\" );\"\n            + LS );\n        writer.write( \"        appendDescription( sb, \\\"\" + getHelpDescription( pluginDescriptor ) + \"\\\", DEFAULT_INDENT );\" + LS );\n\n        writer.write( LS );\n\n        writer.write( \"        if ( getLog().isInfoEnabled() )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().info( sb.toString() );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    private static void writeUtilities( Writer writer )\n        throws IOException\n    {\n        writer.write( \"    /**\" + LS );\n        writer.write( \"     * <p>Repeat a String <code>n<\/code> times to form a new string.<\/p>\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @param str String to repeat\" + LS );\n        writer.write( \"     * @param repeat number of times to repeat str\" + LS );\n        writer.write( \"     * @return String with repeated String\" + LS );\n        writer.write( \"     * @throws NegativeArraySizeException if <code>repeat < 0<\/code>\" + LS );\n        writer.write( \"     * @throws NullPointerException if str is <code>null<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static String repeat( String str, int repeat )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        StringBuffer buffer = new StringBuffer( repeat * str.length() );\" + LS );\n        writer.write( LS );\n        writer.write( \"        for ( int i = 0; i < repeat; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            buffer.append( str );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return buffer.toString();\" + LS );\n        writer.write( \"    }\" + LS );\n        writer.write( LS );\n        writer.write( \"    /**\" + LS );\n        writer\n            .write( \"     * <p>Give a list of lines for the <code>str<\/code>. Each line is indented by <code>indent<\/code>\"\n                + LS );\n        writer.write( \"     * and has a maximum of <code>size<\/code> characters.<\/p>\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @param str String to split in lines\" + LS );\n        writer.write( \"     * @param indent the string to precede each line\" + LS );\n        writer.write( \"     * @param size the size of the character display buffer\" + LS );\n        writer.write( \"     * @return List of lines\" + LS );\n        writer.write( \"     * @throws IllegalArgumentException if <code>size < 0<\/code>\" + LS );\n        writer.write( \"     * @throws NullPointerException if str is <code>null<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static List toLines( String str, String indent, int size )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        List sentences = new ArrayList();\" + LS );\n        writer.write( LS );\n        writer.write( \"        if ( indent == null )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            indent = \\\"\\\";\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        if ( size < 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            throw new IllegalArgumentException( \\\"size should be positive\\\" );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        StringBuffer tmp = new StringBuffer( indent );\" + LS );\n        writer.write( \"        StringTokenizer tokenizer = new StringTokenizer( str, \\\" \\\" );\" + LS );\n        writer.write( \"        while ( tokenizer.hasMoreTokens() )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            String word = tokenizer.nextToken();\" + LS );\n        writer.write( LS );\n        writer.write( \"            if ( tmp.length() + word.length() + 1 < size )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                tmp.append( word ).append( \\\" \\\" );\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"            else\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                sentences.add( tmp.toString() );\" + LS );\n        writer.write( \"                tmp = new StringBuffer( indent );\" + LS );\n        writer.write( \"                tmp.append( word ).append( \\\" \\\" );\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        if ( tmp.toString().length() > 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            sentences.add( tmp.toString() );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return sentences;\" + LS );\n        writer.write( \"    }\" + LS );\n        writer.write( LS );\n        writer.write( \"    private static void appendDescription( StringBuffer sb, String description, int indent )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        for ( Iterator it = toLines( description, repeat( \\\" \\\", indent ), DEFAULT_WIDTH ).iterator(); it.hasNext(); )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            sb.append( it.next().toString() ).append( \\\"\\\\n\\\" );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    /**\n     * Remove HTML tags from a string\n     *\n     * @param str\n     * @return a String with HTML tags into pure text\n     * @throws IOException if any\n     */\n    protected static String toText( String str )\n        throws IOException\n    {\n        if ( StringUtils.isEmpty( str ) )\n        {\n            return \"\";\n        }\n\n        final StringBuffer sb = new StringBuffer();\n\n        HTMLEditorKit.Parser parser = new ParserDelegator();\n        HTMLEditorKit.ParserCallback htmlCallback = new HTMLEditorKit.ParserCallback()\n        {\n            /** {@inheritDoc} */\n            public void handleText( char[] data, int pos )\n            {\n                // the parser parses things like <br /> as \"\\n>\"\n                if ( data[0] == '>' )\n                {\n                    for ( int i = 1; i < data.length; i++ )\n                    {\n                        if ( data[i] == '\\n' )\n                        {\n                            sb.append( ' ' );\n                        }\n                        else\n                        {\n                            sb.append( data[i] );\n                        }\n                    }\n                }\n                else\n                {\n                    for ( int i = 0; i < data.length; i++ )\n                    {\n                        if ( data[i] == '\\n' )\n                        {\n                            sb.append( ' ' );\n                        }\n                        else\n                        {\n                            sb.append( data[i] );\n                        }\n                    }\n                }\n            }\n        };\n\n        parser.parse( new StringReader( PluginUtils.makeHtmlValid( str ) ), htmlCallback, true );\n\n        return StringUtils.replace( sb.toString(), \"\\\"\", \"'\" ); // for CDATA\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.Writer;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport javax.swing.text.html.HTMLEditorKit;\nimport javax.swing.text.html.parser.ParserDelegator;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.logging.Logger;\nimport org.codehaus.plexus.logging.console.ConsoleLogger;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * Generates an <code>HelpMojo<\/code> class.\n *\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n * @since 2.4\n */\npublic class PluginHelpGenerator\n    extends AbstractLogEnabled\n    implements Generator\n{\n    private static final String LS = System.getProperty( \"line.separator\" );\n\n    private static final String HELP_MOJO_CLASS_NAME = \"HelpMojo\";\n\n    private static final String HELP_GOAL = \"help\";\n\n    /**\n     * Default constructor\n     */\n    public PluginHelpGenerator()\n    {\n        this.enableLogging( new ConsoleLogger( Logger.LEVEL_INFO, \"PluginHelpGenerator\" ) );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        if ( pluginDescriptor.getMojos() == null || pluginDescriptor.getMojos().size() < 1 )\n        {\n            return;\n        }\n\n        String packageName = discoverPackageName( pluginDescriptor );\n\n        File helpClass = new File( destinationDirectory, packageName.replace( '.', File.separatorChar )\n            + File.separator + HELP_MOJO_CLASS_NAME + \".java\" );\n\n        // Verify that no help goal already exists\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            if ( descriptor.getGoal().equals( HELP_GOAL )\n                && !descriptor.getImplementation().equals( packageName + \".\" + HELP_MOJO_CLASS_NAME ) )\n            {\n                if ( getLogger().isWarnEnabled() )\n                {\n                    getLogger().warn( \"\\n\\nAn help goal (\" + descriptor.getImplementation()\n                        + \") already exists in this plugin. SKIPPED THE \" + HELP_MOJO_CLASS_NAME + \" GENERATION.\\n\" );\n                }\n\n                return;\n            }\n        }\n\n        helpClass.getParentFile().mkdirs();\n\n        Writer writer = null;\n        try\n        {\n            writer = new FileWriter( helpClass );\n            writeClass( writer, packageName, pluginDescriptor );\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    // Private methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * @return the help goal for the generated mojo\n     */\n    private static String getHelpGoalName()\n    {\n        return HELP_GOAL;\n    }\n\n    /**\n     * @return the full help goal name for the generated mojo\n     */\n    private static String getFullHelpGoalName( PluginDescriptor pluginDescriptor )\n    {\n        return pluginDescriptor.getGoalPrefix() + \":\" + getHelpGoalName();\n    }\n\n    /**\n     * @param pluginDescriptor\n     * @return the help description for the generated mojo\n     */\n    private static String getHelpDescription( PluginDescriptor pluginDescriptor )\n    {\n        return \"Display help information on '\" + pluginDescriptor.getPluginLookupKey() + \"' plugin. Call 'mvn \"\n            + getFullHelpGoalName( pluginDescriptor ) + \" -Ddetail=true' to display all details.\";\n    }\n\n    /**\n     * Find the best package name, based on the number of hits of actual Mojo classes.\n     *\n     * @param pluginDescriptor\n     * @return the best name of the package for the generated mojo\n     */\n    private static String discoverPackageName( PluginDescriptor pluginDescriptor )\n    {\n        Map packageNames = new HashMap();\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            String impl = descriptor.getImplementation();\n            if ( impl.lastIndexOf( '.' ) != -1 )\n            {\n                String name = impl.substring( 0, impl.lastIndexOf( '.' ) );\n                if ( packageNames.get( name ) != null )\n                {\n                    int next = ( (Integer) packageNames.get( name ) ).intValue() + 1;\n                    packageNames.put( name, Integer.valueOf( \"\" + next ) );\n                }\n                else\n                {\n                    packageNames.put( name, Integer.valueOf( \"\" + 1 ) );\n                }\n            }\n            else\n            {\n                packageNames.put( \"\", Integer.valueOf( \"\" + 1 ) );\n            }\n        }\n\n        String packageName = \"\";\n        int max = 0;\n        for ( Iterator it = packageNames.keySet().iterator(); it.hasNext(); )\n        {\n            String key = it.next().toString();\n            int value = ( (Integer) packageNames.get( key ) ).intValue();\n            if ( value > max )\n            {\n                max = value;\n                packageName = key;\n            }\n        }\n\n        return packageName;\n    }\n\n    /**\n     * Generated the <code>HelpMojo<\/code> class.\n     *\n     * @param writer\n     * @param packageName\n     * @param pluginDescriptor\n     * @throws IOException if any\n     */\n    private static void writeClass( Writer writer, String packageName, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        if ( packageName.length() > 0 )\n        {\n            writer.write( \"package \" + packageName + \";\" + LS );\n            writer.write( LS );\n        }\n\n        writeImports( writer );\n        writer.write( LS );\n\n        writeMojoJavadoc( writer, pluginDescriptor );\n\n        writer.write( \"public class HelpMojo\" + LS );\n        writer.write( \"    extends AbstractMojo\" + LS );\n        writer.write( \"{\" + LS );\n\n        writeVariables( writer );\n\n        writer.write( LS );\n\n        writeExecute( writer, pluginDescriptor );\n\n        writer.write( LS );\n        writeUtilities( writer );\n        writer.write( \"}\" + LS );\n    }\n\n    private static void writeImports( Writer writer )\n        throws IOException\n    {\n        writer.write( \"import java.util.ArrayList;\" + LS );\n        writer.write( \"import java.util.Iterator;\" + LS );\n        writer.write( \"import java.util.List;\" + LS );\n        writer.write( \"import java.util.StringTokenizer;\" + LS );\n        writer.write( LS );\n        writer.write( \"import org.apache.maven.plugin.AbstractMojo;\" + LS );\n        writer.write( \"import org.apache.maven.plugin.MojoExecutionException;\" + LS );\n    }\n\n    private static void writeMojoJavadoc( Writer writer, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        writer.write( \"/**\" + LS );\n        writer.write( \" * \" + getHelpDescription( pluginDescriptor ) + LS );\n        writer.write( \" *\" + LS );\n        writer.write( \" * @version generated on \" + new Date() + LS );\n        writer.write( \" * @goal \" + getHelpGoalName() + LS );\n        writer.write( \" * @requiresProject false\" + LS );\n        writer.write( \" */\" + LS );\n    }\n\n    private static void writeVariables( Writer writer )\n        throws IOException\n    {\n        writer.write( \"    /** 80-character display buffer */\" + LS );\n        writer.write( \"    private static final int DEFAULT_WIDTH = 80;\" + LS );\n        writer.write( LS );\n        writer.write( \"    /** 2 indent spaces */\" + LS );\n        writer.write( \"    private static final int DEFAULT_INDENT = 2;\" + LS );\n        writer.write( LS );\n        writer.write( \"    /**\" + LS );\n        writer.write( \"     * If <code>true<\/code>, display all settable properties for each goal.\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @parameter expression=\\\"${detail}\\\" default-value=\\\"false\\\"\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private boolean detail;\" + LS );\n    }\n\n    private static void writeExecute( Writer writer, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        writer.write( \"    /** {@inheritDoc} */\" + LS );\n        writer.write( \"    public void execute()\" + LS );\n        writer.write( \"        throws MojoExecutionException\" + LS );\n        writer.write( \"    {\" + LS );\n\n        writer.write( \"        StringBuffer sb = new StringBuffer();\" + LS );\n        writer.write( LS );\n        writer.write( \"        sb.append( \\\"The '\" + pluginDescriptor.getPluginLookupKey() + \"' plugin has \"\n            + ( pluginDescriptor.getMojos().size() + 1 ) + \" \"\n            + ( ( pluginDescriptor.getMojos().size() + 1 ) > 1 ? \"goals\" : \"goal\" ) + \":\\\" ).append( \\\"\\\\n\\\" );\" + LS );\n        writer.write( \"        sb.append( \\\"\\\\n\\\" );\" + LS );\n\n        writer.write( LS );\n\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n\n            if ( getHelpGoalName().equals( descriptor.getGoal() ) )\n            {\n                // don't document help goal twice\n                continue;\n            }\n\n            String goal = descriptor.getFullGoalName();\n            String description = StringUtils.isNotEmpty( descriptor.getDescription() ) ?\n                StringUtils.escape( toText( descriptor.getDescription() ) ) : \"No description available.\";\n\n            writer.write( \"        sb.append( \\\"\" + goal + \"\\\" ).append( \\\"\\\\n\\\" );\" + LS );\n            writer.write( \"        appendDescription( sb, \\\"\" + description + \"\\\", DEFAULT_INDENT );\" + LS );\n\n            if ( descriptor.getParameters() != null && descriptor.getParameters().size() > 0 )\n            {\n                writer.write( \"        if ( detail )\" + LS );\n                writer.write( \"        {\" + LS );\n\n                writer.write( \"            sb.append( \\\"\\\\n\\\" );\" + LS );\n                writer.write( LS );\n\n                writer.write( \"            sb.append( repeat( \\\" \\\", 2 ) );\" + LS );\n                writer.write( \"            sb.append( \\\"Available parameters:\\\" ).append( \\\"\\\\n\\\" );\" + LS );\n                writer.write( LS );\n                writer.write( \"            sb.append( \\\"\\\\n\\\" );\" + LS );\n                writer.write( LS );\n\n                for ( Iterator it2 = descriptor.getParameters().iterator(); it2.hasNext(); )\n                {\n                    Parameter parameter = (Parameter) it2.next();\n\n                    if ( parameter.isEditable() )\n                    {\n                        String expression = parameter.getExpression();\n\n                        if ( expression == null || !expression.startsWith( \"${component.\" ) )\n                        {\n                            String parameterName = parameter.getName();\n                            String parameterDescription = StringUtils.isNotEmpty( parameter.getDescription() ) ?\n                                StringUtils.escape( toText( parameter.getDescription() ) ) : \"No description available.\";\n                            String parameterDefaultValue = parameterName\n                                + ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) ? \" (Default: '\"\n                                    + parameter.getDefaultValue() + \"')\" : \"\" );\n\n                            writer.write( \"            appendDescription( sb, \\\"\" + parameterDefaultValue + \"\\\", 4 );\" + LS );\n                            writer.write( \"            appendDescription( sb, \\\"\" + parameterDescription + \"\\\", 6 );\" + LS );\n                        }\n                    }\n                }\n\n                writer.write( \"        }\" + LS );\n            }\n\n            writer.write( LS );\n            writer.write( \"        sb.append( \\\"\\\\n\\\" );\" + LS );\n            writer.write( LS );\n        }\n\n        // TODO Should be discovered\n        writer.write( \"        sb.append( \\\"\" + getFullHelpGoalName( pluginDescriptor ) + \"\\\" ).append( \\\"\\\\n\\\" );\"\n            + LS );\n        writer.write( \"        appendDescription( sb, \\\"\" + getHelpDescription( pluginDescriptor ) + \"\\\", DEFAULT_INDENT );\" + LS );\n\n        writer.write( LS );\n\n        writer.write( \"        if ( getLog().isInfoEnabled() )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            getLog().info( sb.toString() );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    private static void writeUtilities( Writer writer )\n        throws IOException\n    {\n        writer.write( \"    /**\" + LS );\n        writer.write( \"     * <p>Repeat a String <code>n<\/code> times to form a new string.<\/p>\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @param str String to repeat\" + LS );\n        writer.write( \"     * @param repeat number of times to repeat str\" + LS );\n        writer.write( \"     * @return String with repeated String\" + LS );\n        writer.write( \"     * @throws NegativeArraySizeException if <code>repeat < 0<\/code>\" + LS );\n        writer.write( \"     * @throws NullPointerException if str is <code>null<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static String repeat( String str, int repeat )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        StringBuffer buffer = new StringBuffer( repeat * str.length() );\" + LS );\n        writer.write( LS );\n        writer.write( \"        for ( int i = 0; i < repeat; i++ )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            buffer.append( str );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return buffer.toString();\" + LS );\n        writer.write( \"    }\" + LS );\n        writer.write( LS );\n        writer.write( \"    /**\" + LS );\n        writer\n            .write( \"     * <p>Give a list of lines for the <code>str<\/code>. Each line is indented by <code>indent<\/code>\"\n                + LS );\n        writer.write( \"     * and has a maximum of <code>size<\/code> characters.<\/p>\" + LS );\n        writer.write( \"     *\" + LS );\n        writer.write( \"     * @param str String to split in lines\" + LS );\n        writer.write( \"     * @param indent the string to precede each line\" + LS );\n        writer.write( \"     * @param size the size of the character display buffer\" + LS );\n        writer.write( \"     * @return List of lines\" + LS );\n        writer.write( \"     * @throws IllegalArgumentException if <code>size < 0<\/code>\" + LS );\n        writer.write( \"     * @throws NullPointerException if str is <code>null<\/code>\" + LS );\n        writer.write( \"     */\" + LS );\n        writer.write( \"    private static List toLines( String str, String indent, int size )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        List sentences = new ArrayList();\" + LS );\n        writer.write( LS );\n        writer.write( \"        if ( indent == null )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            indent = \\\"\\\";\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        if ( size < 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            throw new IllegalArgumentException( \\\"size should be positive\\\" );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        StringBuffer tmp = new StringBuffer( indent );\" + LS );\n        writer.write( \"        StringTokenizer tokenizer = new StringTokenizer( str, \\\" \\\" );\" + LS );\n        writer.write( \"        while ( tokenizer.hasMoreTokens() )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            String word = tokenizer.nextToken();\" + LS );\n        writer.write( LS );\n        writer.write( \"            if ( tmp.length() + word.length() + 1 < size )\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                tmp.append( word ).append( \\\" \\\" );\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"            else\" + LS );\n        writer.write( \"            {\" + LS );\n        writer.write( \"                sentences.add( tmp.toString() );\" + LS );\n        writer.write( \"                tmp = new StringBuffer( indent );\" + LS );\n        writer.write( \"                tmp.append( word ).append( \\\" \\\" );\" + LS );\n        writer.write( \"            }\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        if ( tmp.toString().length() > 0 )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            sentences.add( tmp.toString() );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( LS );\n        writer.write( \"        return sentences;\" + LS );\n        writer.write( \"    }\" + LS );\n        writer.write( LS );\n        writer.write( \"    private static void appendDescription( StringBuffer sb, String description, int indent )\" + LS );\n        writer.write( \"    {\" + LS );\n        writer.write( \"        for ( Iterator it = toLines( description, repeat( \\\" \\\", indent ), DEFAULT_WIDTH ).iterator(); it.hasNext(); )\" + LS );\n        writer.write( \"        {\" + LS );\n        writer.write( \"            sb.append( it.next().toString() ).append( \\\"\\\\n\\\" );\" + LS );\n        writer.write( \"        }\" + LS );\n        writer.write( \"    }\" + LS );\n    }\n\n    /**\n     * Remove HTML tags from a string\n     *\n     * @param str\n     * @return a String with HTML tags into pure text\n     * @throws IOException if any\n     */\n    protected static String toText( String str )\n        throws IOException\n    {\n        if ( StringUtils.isEmpty( str ) )\n        {\n            return \"\";\n        }\n\n        final StringBuffer sb = new StringBuffer();\n\n        HTMLEditorKit.Parser parser = new ParserDelegator();\n        HTMLEditorKit.ParserCallback htmlCallback = new HTMLEditorKit.ParserCallback()\n        {\n            /** {@inheritDoc} */\n            public void handleText( char[] data, int pos )\n            {\n                // the parser parses things like <br /> as \"\\n>\"\n                if ( data[0] == '>' )\n                {\n                    for ( int i = 1; i < data.length; i++ )\n                    {\n                        if ( data[i] == '\\n' )\n                        {\n                            sb.append( ' ' );\n                        }\n                        else\n                        {\n                            sb.append( data[i] );\n                        }\n                    }\n                }\n                else\n                {\n                    for ( int i = 0; i < data.length; i++ )\n                    {\n                        if ( data[i] == '\\n' )\n                        {\n                            sb.append( ' ' );\n                        }\n                        else\n                        {\n                            sb.append( data[i] );\n                        }\n                    }\n                }\n            }\n        };\n\n        parser.parse( new StringReader( PluginUtils.makeHtmlValid( str ) ), htmlCallback, true );\n\n        return StringUtils.replace( sb.toString(), \"\\\"\", \"'\" ); // for CDATA\n    }\n}\n","lineNo":285}
{"Refactored Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.PrettyPrintXMLWriter;\nimport org.codehaus.plexus.util.xml.XMLWriter;\n\n/**\n * @todo add example usage tag that can be shown in the doco\n * @version $Id$\n */\npublic class PluginXdocGenerator\n    implements Generator\n{\n    private final Locale locale;\n\n    private final MavenProject project;\n\n    /**\n     * Default constructor using <code>Locale.ENGLISH<\/code> as locale.\n     * Used only in test cases.\n     */\n    public PluginXdocGenerator()\n    {\n        this.project = null;\n        this.locale = Locale.ENGLISH;\n    }\n\n    /**\n     * Constructor using <code>Locale.ENGLISH<\/code> as locale.\n     *\n     * @param project not null Maven project.\n     */\n    public PluginXdocGenerator( MavenProject project )\n    {\n        this.project = project;\n        this.locale = Locale.ENGLISH;\n    }\n\n    /**\n     * @param locale not null wanted locale.\n     */\n    public PluginXdocGenerator( MavenProject project, Locale locale )\n    {\n        this.project = project;\n        if ( locale == null )\n        {\n            this.locale = Locale.ENGLISH;\n        }\n        else\n        {\n            this.locale = locale;\n        }\n    }\n\n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n            processMojoDescriptor( descriptor, destinationDirectory );\n        }\n    }\n\n    protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, File destinationDirectory )\n        throws IOException\n    {\n        File outputFile = new File( destinationDirectory, getMojoFilename( mojoDescriptor, \"xml\" ) );\n        String encoding = \"UTF-8\";\n        Writer writer = null;\n        try\n        {\n            writer = new OutputStreamWriter( new FileOutputStream( outputFile ), encoding );\n\n            XMLWriter w = new PrettyPrintXMLWriter( new PrintWriter( writer ), encoding, null );\n            writeBody( mojoDescriptor, w );\n\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    private String getMojoFilename( MojoDescriptor mojo, String ext )\n    {\n        return mojo.getGoal() + \"-mojo.\" + ext;\n    }\n\n    private void writeBody( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"document\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"properties\" );\n\n        w.startElement( \"title\" );\n\n        // TODO: need a friendly name for a plugin\n        w.writeText( mojoDescriptor.getPluginDescriptor().getArtifactId() + \" - \" + mojoDescriptor.getFullGoalName() );\n\n        w.endElement(); // title\n\n        w.endElement(); // properties\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"body\" );\n\n        w.startElement( \"section\" );\n\n        w.addAttribute( \"name\", mojoDescriptor.getFullGoalName() );\n\n        writeReportNotice( mojoDescriptor, w );\n\n        w.startElement( \"p\" );\n        w.writeMarkup( \"<strong>\"+ getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.fullname\" ) + \"<\/strong>:\" );\n        w.endElement(); //p\n        w.startElement( \"p\" );\n        w.writeMarkup( mojoDescriptor.getPluginDescriptor().getGroupId() + \":\"\n            + mojoDescriptor.getPluginDescriptor().getArtifactId() + \":\"\n            + mojoDescriptor.getPluginDescriptor().getVersion() + \":\" + mojoDescriptor.getGoal() );\n        w.endElement(); //p\n\n        w.startElement( \"p\" );\n        w.writeMarkup( \"<strong>\"+ getBundle( locale ).getString( \"pluginxdoc.description\" ) + \"<\/strong>:\" );\n        w.endElement(); //p\n\n        w.startElement( \"p\" );\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getDescription() ) )\n        {\n            w.writeMarkup( PluginUtils.makeHtmlValid( mojoDescriptor.getDescription() ) );\n        }\n        else\n        {\n            w.writeText( getBundle( locale ).getString( \"pluginxdoc.nodescription\" ) );\n        }\n\n        w.endElement(); // p\n\n        writeGoalAttributes( mojoDescriptor, w );\n\n        writeGoalParameterTable( mojoDescriptor, w );\n\n        w.endElement(); // section\n\n        w.endElement(); // body\n\n        w.endElement(); // document\n    }\n\n    private void writeReportNotice( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        if ( PluginUtils.isMavenReport( mojoDescriptor.getImplementation(), project ) )\n        {\n            w.startElement( \"p\" );\n            w.writeMarkup( \"<strong>\" + getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.notice.note\" )\n                + \"<\/strong>: \" );\n            w.writeText( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.notice.isMavenReport\" ) );\n            w.endElement(); //p\n        }\n    }\n\n    private void writeGoalAttributes( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"p\" );\n        w.writeMarkup( \"<strong>\"+ getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.attributes\" ) + \"<\/strong>:\" );\n        w.endElement(); //p\n\n        w.startElement( \"ul\" );\n\n        String value = mojoDescriptor.getDeprecated();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.deprecated\" ) + \": \" + value + \".\" );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isProjectRequired() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.projectRequired\" ) + \".\" );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isAggregator() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.aggregator\" ) + \".\" );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isDirectInvocationOnly() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.directInvocationOnly\" ) + \".\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.isDependencyResolutionRequired();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.dependencyResolutionRequired\" ) + \": <code>\" + value + \"<\/code>.\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getSince();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.since\" ) + \": <code>\" + value + \"<\/code>.\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getPhase();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.phase\" ) + \": <code>\" + value + \"<\/code>.\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getExecutePhase();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executePhase1\" ) + \" <code>\" + value\n                + \"<\/code> \" + getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executePhase2\" ) + \".\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getExecuteGoal();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executeGoal1\" ) + \" <code>\" + value\n                + \"<\/code> \" + getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executeGoal2\" ) + \".\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getExecuteLifecycle();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executeLifecycle\" ) + \": <code>\" + value + \"<\/code>.\" );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isOnlineRequired() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.onlineRequired\" ) + \".\" );\n            w.endElement(); //li\n        }\n\n        if ( !mojoDescriptor.isInheritedByDefault() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.inheritedByDefault\" ) + \".\" );\n            w.endElement(); //li\n        }\n\n        w.endElement();//ul\n    }\n\n    private void writeGoalParameterTable( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        List parameterList = mojoDescriptor.getParameters();\n\n        //remove components and read-only parameters\n        List list = filterParameters( parameterList );\n\n        if ( list != null && list.size() > 0 )\n        {\n            writeParameterSummary( mojoDescriptor, list, w );\n\n            writeParameterDetails( mojoDescriptor, list, w );\n        }\n        else\n        {\n            w.startElement( \"subsection\" );\n            w.addAttribute( \"name\", getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameters\" ) );\n\n            w.startElement( \"p\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.noParameter\" ) );\n            w.endElement(); //p\n\n            w.endElement();\n        }\n    }\n\n    private List filterParameters( List parameterList )\n    {\n        List filtered = new ArrayList();\n\n        if ( parameterList != null )\n        {\n            for ( Iterator parameters = parameterList.iterator(); parameters.hasNext(); )\n            {\n                Parameter parameter = (Parameter) parameters.next();\n\n                if ( parameter.isEditable() )\n                {\n                    String expression = parameter.getExpression();\n\n                    if ( expression == null || !expression.startsWith( \"${component.\" ) )\n                    {\n                        filtered.add( parameter );\n                    }\n                }\n            }\n        }\n\n        return filtered;\n    }\n\n    private void writeParameterDetails( MojoDescriptor mojoDescriptor, List parameterList, XMLWriter w )\n    {\n        w.startElement( \"subsection\" );\n        w.addAttribute( \"name\", getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.details\" ) );\n\n        for ( Iterator parameters = parameterList.iterator(); parameters.hasNext(); )\n        {\n            Parameter parameter = (Parameter) parameters.next();\n\n            w.startElement( \"p\" );\n            w.writeMarkup( \"<strong><a name=\\\"\" + parameter.getName() + \"\\\">\" + parameter.getName() + \"<\/a>:<\/strong>\" );\n            w.endElement(); //p\n\n            String description = parameter.getDescription();\n            if ( StringUtils.isEmpty( description ) )\n            {\n                description = getBundle( locale ).getString( \"pluginxdoc.nodescription\" );\n            }\n            else\n            {\n                description = PluginUtils.makeHtmlValid( description );\n            }\n            w.startElement( \"p\" );\n            w.writeMarkup( description );\n            w.endElement(); //p\n\n            w.startElement( \"ul\" );\n\n            writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.deprecated\" ), parameter.getDeprecated(), w );\n\n            writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.type\" ), parameter.getType(), w );\n\n            if ( StringUtils.isNotEmpty( parameter.getSince() ) )\n            {\n                writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.since\" ), parameter.getSince(), w );\n            }\n            else\n            {\n                if ( StringUtils.isNotEmpty( mojoDescriptor.getSince() ) )\n                {\n                    writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.since\" ), mojoDescriptor.getSince(), w );\n                }\n            }\n\n            if ( parameter.isRequired() )\n            {\n                writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.required\" ), getBundle( locale ).getString( \"pluginxdoc.yes\" ), w );\n            }\n            else\n            {\n                writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.required\" ), getBundle( locale ).getString( \"pluginxdoc.no\" ), w );\n            }\n\n            writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.expression\" ), parameter.getExpression(), w );\n\n            writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.default\" ), parameter.getDefaultValue(), w );\n\n            w.endElement();//ul\n\n            if ( parameters.hasNext() )\n            {\n                w.writeMarkup( \"<hr/>\" );\n            }\n        }\n\n        w.endElement();\n    }\n\n    private void writeDetail( String param, String value, XMLWriter w )\n    {\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( \"<strong>\" + param + \"<\/strong>: <code>\" );\n            w.writeText( value );\n            w.writeMarkup( \"<\/code>\" );\n            w.endElement(); //li\n        }\n    }\n\n    private void writeParameterSummary( MojoDescriptor mojoDescriptor, List parameterList, XMLWriter w )\n    {\n        List requiredParams = getParametersByRequired( true, parameterList );\n        if ( requiredParams.size() > 0 )\n        {\n            writeParameterList( mojoDescriptor, getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.requiredParameters\" ), requiredParams, w );\n        }\n\n        List optionalParams = getParametersByRequired( false, parameterList );\n        if ( optionalParams.size() > 0 )\n        {\n            writeParameterList( mojoDescriptor, getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.optionalParameters\" ), optionalParams, w );\n        }\n    }\n\n    private void writeParameterList( MojoDescriptor mojoDescriptor, String title, List parameterList, XMLWriter w )\n    {\n        w.startElement( \"subsection\" );\n        w.addAttribute( \"name\", title );\n\n        w.startElement( \"table\" );\n        w.addAttribute( \"border\", \"0\" );\n        w.addAttribute( \"align\", \"left\" );\n\n        w.startElement( \"tr\" );\n        w.startElement( \"th\" );\n        w.writeText( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.name\" ) );\n        w.endElement();//th\n        w.startElement( \"th\" );\n        w.writeText( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.type\" ) );\n        w.endElement();//th\n        w.startElement( \"th\" );\n        w.writeText( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.since\" ) );\n        w.endElement();//th\n        w.startElement( \"th\" );\n        w.writeText( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.description\" ) );\n        w.endElement();//th\n        w.endElement();//tr\n\n        for ( Iterator parameters = parameterList.iterator(); parameters.hasNext(); )\n        {\n            Parameter parameter = (Parameter) parameters.next();\n\n            w.startElement( \"tr\" );\n            w.startElement( \"td\" );\n            w.writeMarkup( \"<strong><a href=\\\"#\" + parameter.getName() + \"\\\">\" + parameter.getName() + \"<\/a><\/strong>\" );\n            w.endElement();//td\n            w.startElement( \"td\" );\n            int index = parameter.getType().lastIndexOf( \".\" );\n            w.writeMarkup( \"<code>\" + parameter.getType().substring( index + 1 ) + \"<\/code>\" );\n            w.endElement();//td\n            w.startElement( \"td\" );\n            if ( StringUtils.isNotEmpty( parameter.getSince() ) )\n            {\n                w.writeMarkup( \"<code>\" + parameter.getSince() + \"<\/code>\" );\n            }\n            else\n            {\n                if ( StringUtils.isNotEmpty( mojoDescriptor.getSince() ) )\n                {\n                    w.writeMarkup( \"<code>\" + mojoDescriptor.getSince() + \"<\/code>\" );\n                }\n                else\n                {\n                    w.writeMarkup( \"<code>-<\/code>\" );\n                }\n            }\n            w.endElement();//td\n            w.startElement( \"td\" );\n            String description = parameter.getDescription();\n            if ( StringUtils.isEmpty( description ) )\n            {\n                description = getBundle( locale ).getString( \"pluginxdoc.nodescription\" );\n            }\n            else\n            {\n                description = PluginUtils.makeHtmlValid( description );\n            }\n            if ( StringUtils.isNotEmpty( parameter.getDeprecated() ) )\n            {\n                description = \"<strong>\" + getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.deprecated\" ) + \"<\/strong>. \" + description;\n            }\n            w.writeMarkup( description + \" \" );\n\n            if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) )\n            {\n                w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.defaultValue\" ) + \": <code>\" );\n                w.writeText( parameter.getDefaultValue() );\n                w.writeMarkup( \"<\/code>.\" );\n            }\n            w.endElement();//td\n            w.endElement(); //tr\n        }\n\n        w.endElement();//table\n        w.endElement();//section\n    }\n\n    private List getParametersByRequired( boolean required, List parameterList )\n    {\n        List list = new ArrayList();\n\n        for ( Iterator parameters = parameterList.iterator(); parameters.hasNext(); )\n        {\n            Parameter parameter = (Parameter) parameters.next();\n\n            if ( parameter.isRequired() == required )\n            {\n                list.add( parameter );\n            }\n        }\n\n        return list;\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"pluginxdoc\", locale, getClass().getClassLoader() );\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.tools.plugin.util.PluginUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.PrettyPrintXMLWriter;\nimport org.codehaus.plexus.util.xml.XMLWriter;\n\n/**\n * @todo add example usage tag that can be shown in the doco\n * @version $Id$\n */\npublic class PluginXdocGenerator\n    implements Generator\n{\n    private final Locale locale;\n\n    private final MavenProject project;\n\n    /**\n     * Default constructor using <code>Locale.ENGLISH<\/code> as locale.\n     * Used only in test cases.\n     */\n    public PluginXdocGenerator()\n    {\n        this.project = null;\n        this.locale = Locale.ENGLISH;\n    }\n\n    /**\n     * Constructor using <code>Locale.ENGLISH<\/code> as locale.\n     *\n     * @param project not null Maven project.\n     */\n    public PluginXdocGenerator( MavenProject project )\n    {\n        this.project = project;\n        this.locale = Locale.ENGLISH;\n    }\n\n    /**\n     * @param locale not null wanted locale.\n     */\n    public PluginXdocGenerator( MavenProject project, Locale locale )\n    {\n        this.project = project;\n        if ( locale == null )\n        {\n            this.locale = Locale.ENGLISH;\n        }\n        else\n        {\n            this.locale = locale;\n        }\n    }\n\n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n            processMojoDescriptor( descriptor, destinationDirectory );\n        }\n    }\n\n    protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, File destinationDirectory )\n        throws IOException\n    {\n        File outputFile = new File( destinationDirectory, getMojoFilename( mojoDescriptor, \"xml\" ) );\n        OutputStreamWriter writer = null;\n        try\n        {\n            writer = new OutputStreamWriter( new FileOutputStream( outputFile ), \"UTF-8\" );\n\n            writeBody( writer, mojoDescriptor );\n\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    private String getMojoFilename( MojoDescriptor mojo, String ext )\n    {\n        return mojo.getGoal() + \"-mojo.\" + ext;\n    }\n\n    private void writeBody( OutputStreamWriter writer, MojoDescriptor mojoDescriptor )\n    {\n        XMLWriter w = new PrettyPrintXMLWriter( new PrintWriter( writer ), writer.getEncoding(), null );\n\n        w.startElement( \"document\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"properties\" );\n\n        w.startElement( \"title\" );\n\n        // TODO: need a friendly name for a plugin\n        w.writeText( mojoDescriptor.getPluginDescriptor().getArtifactId() + \" - \" + mojoDescriptor.getFullGoalName() );\n\n        w.endElement(); // title\n\n        w.endElement(); // properties\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"body\" );\n\n        w.startElement( \"section\" );\n\n        w.addAttribute( \"name\", mojoDescriptor.getFullGoalName() );\n\n        writeReportNotice( mojoDescriptor, w );\n\n        w.startElement( \"p\" );\n        w.writeMarkup( \"<strong>\"+ getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.fullname\" ) + \"<\/strong>:\" );\n        w.endElement(); //p\n        w.startElement( \"p\" );\n        w.writeMarkup( mojoDescriptor.getPluginDescriptor().getGroupId() + \":\"\n            + mojoDescriptor.getPluginDescriptor().getArtifactId() + \":\"\n            + mojoDescriptor.getPluginDescriptor().getVersion() + \":\" + mojoDescriptor.getGoal() );\n        w.endElement(); //p\n\n        w.startElement( \"p\" );\n        w.writeMarkup( \"<strong>\"+ getBundle( locale ).getString( \"pluginxdoc.description\" ) + \"<\/strong>:\" );\n        w.endElement(); //p\n\n        w.startElement( \"p\" );\n        if ( StringUtils.isNotEmpty( mojoDescriptor.getDescription() ) )\n        {\n            w.writeMarkup( PluginUtils.makeHtmlValid( mojoDescriptor.getDescription() ) );\n        }\n        else\n        {\n            w.writeText( getBundle( locale ).getString( \"pluginxdoc.nodescription\" ) );\n        }\n\n        w.endElement(); // p\n\n        writeGoalAttributes( mojoDescriptor, w );\n\n        writeGoalParameterTable( mojoDescriptor, w );\n\n        w.endElement(); // section\n\n        w.endElement(); // body\n\n        w.endElement(); // document\n    }\n\n    private void writeReportNotice( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        if ( PluginUtils.isMavenReport( mojoDescriptor.getImplementation(), project ) )\n        {\n            w.startElement( \"p\" );\n            w.writeMarkup( \"<strong>\" + getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.notice.note\" )\n                + \"<\/strong>: \" );\n            w.writeText( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.notice.isMavenReport\" ) );\n            w.endElement(); //p\n        }\n    }\n\n    private void writeGoalAttributes( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"p\" );\n        w.writeMarkup( \"<strong>\"+ getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.attributes\" ) + \"<\/strong>:\" );\n        w.endElement(); //p\n\n        w.startElement( \"ul\" );\n\n        String value = mojoDescriptor.getDeprecated();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.deprecated\" ) + \": \" + value + \".\" );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isProjectRequired() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.projectRequired\" ) + \".\" );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isAggregator() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.aggregator\" ) + \".\" );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isDirectInvocationOnly() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.directInvocationOnly\" ) + \".\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.isDependencyResolutionRequired();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.dependencyResolutionRequired\" ) + \": <code>\" + value + \"<\/code>.\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getSince();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.since\" ) + \": <code>\" + value + \"<\/code>.\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getPhase();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.phase\" ) + \": <code>\" + value + \"<\/code>.\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getExecutePhase();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executePhase1\" ) + \" <code>\" + value\n                + \"<\/code> \" + getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executePhase2\" ) + \".\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getExecuteGoal();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executeGoal1\" ) + \" <code>\" + value\n                + \"<\/code> \" + getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executeGoal2\" ) + \".\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getExecuteLifecycle();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executeLifecycle\" ) + \": <code>\" + value + \"<\/code>.\" );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isOnlineRequired() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.onlineRequired\" ) + \".\" );\n            w.endElement(); //li\n        }\n\n        if ( !mojoDescriptor.isInheritedByDefault() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.inheritedByDefault\" ) + \".\" );\n            w.endElement(); //li\n        }\n\n        w.endElement();//ul\n    }\n\n    private void writeGoalParameterTable( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        List parameterList = mojoDescriptor.getParameters();\n\n        //remove components and read-only parameters\n        List list = filterParameters( parameterList );\n\n        if ( list != null && list.size() > 0 )\n        {\n            writeParameterSummary( mojoDescriptor, list, w );\n\n            writeParameterDetails( mojoDescriptor, list, w );\n        }\n        else\n        {\n            w.startElement( \"subsection\" );\n            w.addAttribute( \"name\", getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameters\" ) );\n\n            w.startElement( \"p\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.noParameter\" ) );\n            w.endElement(); //p\n\n            w.endElement();\n        }\n    }\n\n    private List filterParameters( List parameterList )\n    {\n        List filtered = new ArrayList();\n\n        if ( parameterList != null )\n        {\n            for ( Iterator parameters = parameterList.iterator(); parameters.hasNext(); )\n            {\n                Parameter parameter = (Parameter) parameters.next();\n\n                if ( parameter.isEditable() )\n                {\n                    String expression = parameter.getExpression();\n\n                    if ( expression == null || !expression.startsWith( \"${component.\" ) )\n                    {\n                        filtered.add( parameter );\n                    }\n                }\n            }\n        }\n\n        return filtered;\n    }\n\n    private void writeParameterDetails( MojoDescriptor mojoDescriptor, List parameterList, XMLWriter w )\n    {\n        w.startElement( \"subsection\" );\n        w.addAttribute( \"name\", getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.details\" ) );\n\n        for ( Iterator parameters = parameterList.iterator(); parameters.hasNext(); )\n        {\n            Parameter parameter = (Parameter) parameters.next();\n\n            w.startElement( \"p\" );\n            w.writeMarkup( \"<strong><a name=\\\"\" + parameter.getName() + \"\\\">\" + parameter.getName() + \"<\/a>:<\/strong>\" );\n            w.endElement(); //p\n\n            String description = parameter.getDescription();\n            if ( StringUtils.isEmpty( description ) )\n            {\n                description = getBundle( locale ).getString( \"pluginxdoc.nodescription\" );\n            }\n            else\n            {\n                description = PluginUtils.makeHtmlValid( description );\n            }\n            w.startElement( \"p\" );\n            w.writeMarkup( description );\n            w.endElement(); //p\n\n            w.startElement( \"ul\" );\n\n            writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.deprecated\" ), parameter.getDeprecated(), w );\n\n            writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.type\" ), parameter.getType(), w );\n\n            if ( StringUtils.isNotEmpty( parameter.getSince() ) )\n            {\n                writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.since\" ), parameter.getSince(), w );\n            }\n            else\n            {\n                if ( StringUtils.isNotEmpty( mojoDescriptor.getSince() ) )\n                {\n                    writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.since\" ), mojoDescriptor.getSince(), w );\n                }\n            }\n\n            if ( parameter.isRequired() )\n            {\n                writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.required\" ), getBundle( locale ).getString( \"pluginxdoc.yes\" ), w );\n            }\n            else\n            {\n                writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.required\" ), getBundle( locale ).getString( \"pluginxdoc.no\" ), w );\n            }\n\n            writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.expression\" ), parameter.getExpression(), w );\n\n            writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.default\" ), parameter.getDefaultValue(), w );\n\n            w.endElement();//ul\n\n            if ( parameters.hasNext() )\n            {\n                w.writeMarkup( \"<hr/>\" );\n            }\n        }\n\n        w.endElement();\n    }\n\n    private void writeDetail( String param, String value, XMLWriter w )\n    {\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( \"<strong>\" + param + \"<\/strong>: <code>\" );\n            w.writeText( value );\n            w.writeMarkup( \"<\/code>\" );\n            w.endElement(); //li\n        }\n    }\n\n    private void writeParameterSummary( MojoDescriptor mojoDescriptor, List parameterList, XMLWriter w )\n    {\n        List requiredParams = getParametersByRequired( true, parameterList );\n        if ( requiredParams.size() > 0 )\n        {\n            writeParameterList( mojoDescriptor, getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.requiredParameters\" ), requiredParams, w );\n        }\n\n        List optionalParams = getParametersByRequired( false, parameterList );\n        if ( optionalParams.size() > 0 )\n        {\n            writeParameterList( mojoDescriptor, getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.optionalParameters\" ), optionalParams, w );\n        }\n    }\n\n    private void writeParameterList( MojoDescriptor mojoDescriptor, String title, List parameterList, XMLWriter w )\n    {\n        w.startElement( \"subsection\" );\n        w.addAttribute( \"name\", title );\n\n        w.startElement( \"table\" );\n        w.addAttribute( \"border\", \"0\" );\n        w.addAttribute( \"align\", \"left\" );\n\n        w.startElement( \"tr\" );\n        w.startElement( \"th\" );\n        w.writeText( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.name\" ) );\n        w.endElement();//th\n        w.startElement( \"th\" );\n        w.writeText( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.type\" ) );\n        w.endElement();//th\n        w.startElement( \"th\" );\n        w.writeText( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.since\" ) );\n        w.endElement();//th\n        w.startElement( \"th\" );\n        w.writeText( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.description\" ) );\n        w.endElement();//th\n        w.endElement();//tr\n\n        for ( Iterator parameters = parameterList.iterator(); parameters.hasNext(); )\n        {\n            Parameter parameter = (Parameter) parameters.next();\n\n            w.startElement( \"tr\" );\n            w.startElement( \"td\" );\n            w.writeMarkup( \"<strong><a href=\\\"#\" + parameter.getName() + \"\\\">\" + parameter.getName() + \"<\/a><\/strong>\" );\n            w.endElement();//td\n            w.startElement( \"td\" );\n            int index = parameter.getType().lastIndexOf( \".\" );\n            w.writeMarkup( \"<code>\" + parameter.getType().substring( index + 1 ) + \"<\/code>\" );\n            w.endElement();//td\n            w.startElement( \"td\" );\n            if ( StringUtils.isNotEmpty( parameter.getSince() ) )\n            {\n                w.writeMarkup( \"<code>\" + parameter.getSince() + \"<\/code>\" );\n            }\n            else\n            {\n                if ( StringUtils.isNotEmpty( mojoDescriptor.getSince() ) )\n                {\n                    w.writeMarkup( \"<code>\" + mojoDescriptor.getSince() + \"<\/code>\" );\n                }\n                else\n                {\n                    w.writeMarkup( \"<code>-<\/code>\" );\n                }\n            }\n            w.endElement();//td\n            w.startElement( \"td\" );\n            String description = parameter.getDescription();\n            if ( StringUtils.isEmpty( description ) )\n            {\n                description = getBundle( locale ).getString( \"pluginxdoc.nodescription\" );\n            }\n            else\n            {\n                description = PluginUtils.makeHtmlValid( description );\n            }\n            if ( StringUtils.isNotEmpty( parameter.getDeprecated() ) )\n            {\n                description = \"<strong>\" + getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.deprecated\" ) + \"<\/strong>. \" + description;\n            }\n            w.writeMarkup( description + \" \" );\n\n            if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) )\n            {\n                w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.defaultValue\" ) + \": <code>\" );\n                w.writeText( parameter.getDefaultValue() );\n                w.writeMarkup( \"<\/code>.\" );\n            }\n            w.endElement();//td\n            w.endElement(); //tr\n        }\n\n        w.endElement();//table\n        w.endElement();//section\n    }\n\n    private List getParametersByRequired( boolean required, List parameterList )\n    {\n        List list = new ArrayList();\n\n        for ( Iterator parameters = parameterList.iterator(); parameters.hasNext(); )\n        {\n            Parameter parameter = (Parameter) parameters.next();\n\n            if ( parameter.isRequired() == required )\n            {\n                list.add( parameter );\n            }\n        }\n\n        return list;\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"pluginxdoc\", locale, getClass().getClassLoader() );\n    }\n}\n","lineNo":107}
{"Refactored Sample":"package org.apache.maven.tools.plugin.javadoc.stubs;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.DefaultArtifact;\nimport org.apache.maven.artifact.handler.DefaultArtifactHandler;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.repository.DefaultArtifactRepository;\nimport org.apache.maven.artifact.repository.layout.DefaultRepositoryLayout;\nimport org.apache.maven.artifact.versioning.VersionRange;\nimport org.apache.maven.model.Build;\nimport org.apache.maven.model.Model;\nimport org.apache.maven.model.Resource;\nimport org.apache.maven.model.io.xpp3.MavenXpp3Reader;\nimport org.apache.maven.plugin.testing.stubs.MavenProjectStub;\nimport org.codehaus.plexus.util.ReaderFactory;\n\n/**\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n */\npublic class DefaultMavenProjectStub\n    extends MavenProjectStub\n{\n    private Build build;\n\n    public DefaultMavenProjectStub()\n    {\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        Model model = null;\n\n        try\n        {\n            File pomFile = new File( getBasedir(), \"javadoc-plugin-config.xml\" );\n            model = pomReader.read( ReaderFactory.newXmlReader( pomFile ) );\n            setModel( model );\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        setGroupId( model.getGroupId() );\n        setArtifactId( model.getArtifactId() );\n        setVersion( model.getVersion() );\n        setName( model.getName() );\n        setUrl( model.getUrl() );\n        setPackaging( model.getPackaging() );\n\n        Build build = new Build();\n\n        build.setFinalName( model.getArtifactId() );\n        build.setSourceDirectory( getBasedir() + \"/src/main/java\" );\n\n        Resource resource = new Resource();\n        resource.setDirectory( getBasedir() + \"/src/main/resources\" );\n        build.setResources( Collections.singletonList( resource ) );\n        build.setDirectory( super.getBasedir() + \"/target/test/unit/javadoc/target\" );\n        build.setOutputDirectory( super.getBasedir() + \"/target/test/unit/javadoc/target/classes\" );\n\n        build.setTestSourceDirectory( getBasedir() + \"/src/test/java\" );\n        resource = new Resource();\n        resource.setDirectory( getBasedir() + \"/src/test/resources\" );\n        build.setTestResources( Collections.singletonList( resource ) );\n        build.setTestOutputDirectory( super.getBasedir() + \"/target/test/unit/javadoc/target/test-classes\" );\n\n        setBuild( build );\n\n        List compileSourceRoots = new ArrayList();\n        compileSourceRoots.add( getBasedir() + \"/src/main/java\" );\n        setCompileSourceRoots( compileSourceRoots );\n    }\n\n    /** {@inheritDoc} */\n    public Build getBuild()\n    {\n        return build;\n    }\n\n    /** {@inheritDoc} */\n    public void setBuild( Build build )\n    {\n        this.build = build;\n    }\n\n    /** {@inheritDoc} */\n    public File getBasedir()\n    {\n        return new File( super.getBasedir() + \"/src/test/resources/unit/javadoc\" );\n    }\n\n    /** {@inheritDoc} */\n    public List getRemoteArtifactRepositories()\n    {\n        ArtifactRepository repository = new DefaultArtifactRepository( \"central\", \"http://repo1.maven.org/maven2\",\n                                                                       new DefaultRepositoryLayout() );\n\n        return Collections.singletonList( repository );\n    }\n\n    /** {@inheritDoc} */\n    public List getCompileArtifacts()\n    {\n        Artifact art = new DefaultArtifact( \"org.apache.maven\", \"maven-plugin-api\", VersionRange.createFromVersion( \"2.0\" ),\n                                            Artifact.SCOPE_COMPILE, \"jar\", null, new DefaultArtifactHandler( \"jar\" ), false );\n        art.setFile( new File( super.getBasedir() + \"/target/local-repo/org/apache/maven/maven-plugin-api/2.0/maven-plugin-api-2.0.jar\" ) );\n        return Collections.singletonList( art );\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.javadoc.stubs;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.DefaultArtifact;\nimport org.apache.maven.artifact.handler.DefaultArtifactHandler;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.repository.DefaultArtifactRepository;\nimport org.apache.maven.artifact.repository.layout.DefaultRepositoryLayout;\nimport org.apache.maven.artifact.versioning.VersionRange;\nimport org.apache.maven.model.Build;\nimport org.apache.maven.model.Model;\nimport org.apache.maven.model.Resource;\nimport org.apache.maven.model.io.xpp3.MavenXpp3Reader;\nimport org.apache.maven.plugin.testing.stubs.MavenProjectStub;\n\n/**\n * @author <a href=\"mailto:vincent.siveton@gmail.com\">Vincent Siveton<\/a>\n * @version $Id$\n */\npublic class DefaultMavenProjectStub\n    extends MavenProjectStub\n{\n    private Build build;\n\n    public DefaultMavenProjectStub()\n    {\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        Model model = null;\n\n        try\n        {\n            model = pomReader.read( new FileReader( new File( getBasedir(), \"javadoc-plugin-config.xml\" ) ) );\n            setModel( model );\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        setGroupId( model.getGroupId() );\n        setArtifactId( model.getArtifactId() );\n        setVersion( model.getVersion() );\n        setName( model.getName() );\n        setUrl( model.getUrl() );\n        setPackaging( model.getPackaging() );\n\n        Build build = new Build();\n\n        build.setFinalName( model.getArtifactId() );\n        build.setSourceDirectory( getBasedir() + \"/src/main/java\" );\n\n        Resource resource = new Resource();\n        resource.setDirectory( getBasedir() + \"/src/main/resources\" );\n        build.setResources( Collections.singletonList( resource ) );\n        build.setDirectory( super.getBasedir() + \"/target/test/unit/javadoc/target\" );\n        build.setOutputDirectory( super.getBasedir() + \"/target/test/unit/javadoc/target/classes\" );\n\n        build.setTestSourceDirectory( getBasedir() + \"/src/test/java\" );\n        resource = new Resource();\n        resource.setDirectory( getBasedir() + \"/src/test/resources\" );\n        build.setTestResources( Collections.singletonList( resource ) );\n        build.setTestOutputDirectory( super.getBasedir() + \"/target/test/unit/javadoc/target/test-classes\" );\n\n        setBuild( build );\n\n        List compileSourceRoots = new ArrayList();\n        compileSourceRoots.add( getBasedir() + \"/src/main/java\" );\n        setCompileSourceRoots( compileSourceRoots );\n    }\n\n    /** {@inheritDoc} */\n    public Build getBuild()\n    {\n        return build;\n    }\n\n    /** {@inheritDoc} */\n    public void setBuild( Build build )\n    {\n        this.build = build;\n    }\n\n    /** {@inheritDoc} */\n    public File getBasedir()\n    {\n        return new File( super.getBasedir() + \"/src/test/resources/unit/javadoc\" );\n    }\n\n    /** {@inheritDoc} */\n    public List getRemoteArtifactRepositories()\n    {\n        ArtifactRepository repository = new DefaultArtifactRepository( \"central\", \"http://repo1.maven.org/maven2\",\n                                                                       new DefaultRepositoryLayout() );\n\n        return Collections.singletonList( repository );\n    }\n\n    /** {@inheritDoc} */\n    public List getCompileArtifacts()\n    {\n        Artifact art = new DefaultArtifact( \"org.apache.maven\", \"maven-plugin-api\", VersionRange.createFromVersion( \"2.0\" ),\n                                            Artifact.SCOPE_COMPILE, \"jar\", null, new DefaultArtifactHandler( \"jar\" ), false );\n        art.setFile( new File( super.getBasedir() + \"/target/local-repo/org/apache/maven/maven-plugin-api/2.0/maven-plugin-api-2.0.jar\" ) );\n        return Collections.singletonList( art );\n    }\n}\n","lineNo":57}
{"Refactored Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringInputStream;\nimport org.codehaus.plexus.util.StringOutputStream;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.PrettyPrintXMLWriter;\nimport org.codehaus.plexus.util.xml.XMLWriter;\nimport org.w3c.tidy.Tidy;\n\n/**\n * @todo add example usage tag that can be shown in the doco\n * @version $Id$\n */\npublic class PluginXdocGenerator\n    implements Generator\n{\n    private final Locale locale;\n\n    /**\n     * Default constructor using <code>Locale.ENGLISH<\/code> as locale.\n     */\n    public PluginXdocGenerator()\n    {\n        this.locale = Locale.ENGLISH;\n    }\n\n    /**\n     * @param locale not null wanted locale.\n     */\n    public PluginXdocGenerator( Locale locale )\n    {\n        if ( locale == null )\n        {\n            this.locale = Locale.ENGLISH;\n        }\n        else\n        {\n            this.locale = locale;\n        }\n    }\n\n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n            processMojoDescriptor( descriptor, destinationDirectory );\n        }\n    }\n\n    protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, File destinationDirectory )\n        throws IOException\n    {\n        File outputFile = new File( destinationDirectory, getMojoFilename( mojoDescriptor, \"xml\" ) );\n        OutputStreamWriter writer = null;\n        try\n        {\n            writer = new OutputStreamWriter( new FileOutputStream( outputFile ), \"UTF-8\" );\n\n            writeBody( writer, mojoDescriptor );\n\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    private String getMojoFilename( MojoDescriptor mojo, String ext )\n    {\n        return mojo.getGoal() + \"-mojo.\" + ext;\n    }\n\n    private void writeBody( OutputStreamWriter writer, MojoDescriptor mojoDescriptor )\n    {\n        XMLWriter w = new PrettyPrintXMLWriter( new PrintWriter( writer ), writer.getEncoding(), null );\n\n        w.startElement( \"document\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"properties\" );\n\n        w.startElement( \"title\" );\n\n        // TODO: need a friendly name for a plugin\n        w.writeText( mojoDescriptor.getPluginDescriptor().getArtifactId() + \" - \" + mojoDescriptor.getFullGoalName() );\n\n        w.endElement(); // title\n\n        w.endElement(); // properties\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"body\" );\n\n        w.startElement( \"section\" );\n\n        w.addAttribute( \"name\", mojoDescriptor.getFullGoalName() );\n\n        w.startElement( \"p\" );\n        w.writeMarkup( \"<strong>\"+ getBundle( locale ).getString( \"pluginxdoc.fullname\" ) + \"<\/strong>:\" );\n        w.endElement(); //p\n        w.startElement( \"p\" );\n        w.writeMarkup( mojoDescriptor.getPluginDescriptor().getGroupId() + \":\"\n            + mojoDescriptor.getPluginDescriptor().getArtifactId() + \":\"\n            + mojoDescriptor.getPluginDescriptor().getVersion() + \":\" + mojoDescriptor.getGoal() );\n        w.endElement(); //p\n\n        w.startElement( \"p\" );\n        w.writeMarkup( \"<strong>\"+ getBundle( locale ).getString( \"pluginxdoc.description\" ) + \"<\/strong>:\" );\n        w.endElement(); //p\n\n        w.startElement( \"p\" );\n        if ( mojoDescriptor.getDescription() != null )\n        {\n            w.writeMarkup( makeHtmlValid( mojoDescriptor.getDescription() ) );\n        }\n        else\n        {\n            w.writeText( getBundle( locale ).getString( \"pluginxdoc.nodescription\" ) );\n        }\n\n        w.endElement(); // p\n\n        writeGoalAttributes( mojoDescriptor, w );\n\n        writeGoalParameterTable( mojoDescriptor, w );\n\n        w.endElement(); // section\n\n        w.endElement(); // body\n\n        w.endElement(); // document\n    }\n\n    private void writeGoalAttributes( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"p\" );\n        w.writeMarkup( \"<strong>\"+ getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.attributes\" ) + \"<\/strong>:\" );\n        w.endElement(); //p\n\n        w.startElement( \"ul\" );\n\n        String value = mojoDescriptor.getDeprecated();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.deprecated\" ) + \": \" + value + \".\" );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isProjectRequired() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.projectRequired\" ) );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isAggregator() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.aggregator\" ) );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isDirectInvocationOnly() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.directInvocationOnly\" ) );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.isDependencyResolutionRequired();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.dependencyResolutionRequired\" ) + \": <code>\" + value + \"<\/code>.\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getSince();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.since\" ) + \": <code>\" + value + \"<\/code>.\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getPhase();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.phase\" ) + \": <code>\" + value + \"<\/code>.\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getExecutePhase();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executePhase1\" ) + \" <code>\" + value\n                + \"<\/code>\" + getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executePhase2\" ) + \".\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getExecuteGoal();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executeGoal1\" ) + \" <code>\" + value\n                + \"<\/code> \" + getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executeGoal2\" ) + \".\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getExecuteLifecycle();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executeLifecycle\" ) + \": <code>\" + value + \"<\/code>.\" );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isOnlineRequired() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.onlineRequired\" ) );\n            w.endElement(); //li\n        }\n\n        if ( !mojoDescriptor.isInheritedByDefault() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.inheritedByDefault\" ) );\n            w.endElement(); //li\n        }\n\n        w.endElement();//ul\n    }\n\n    private void writeGoalParameterTable( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        List parameterList = mojoDescriptor.getParameters();\n\n        //remove components and read-only parameters\n        List list = filterParameters( parameterList );\n\n        if ( list != null && list.size() > 0 )\n        {\n            writeParameterSummary( mojoDescriptor, list, w );\n\n            writeParameterDetails( mojoDescriptor, list, w );\n        }\n    }\n\n    private List filterParameters( List parameterList )\n    {\n        List filtered = new ArrayList();\n\n        if ( parameterList != null )\n        {\n            for ( Iterator parameters = parameterList.iterator(); parameters.hasNext(); )\n            {\n                Parameter parameter = (Parameter) parameters.next();\n\n                if ( parameter.isEditable() )\n                {\n                    String expression = parameter.getExpression();\n\n                    if ( expression == null || !expression.startsWith( \"${component.\" ) )\n                    {\n                        filtered.add( parameter );\n                    }\n                }\n            }\n        }\n\n        return filtered;\n    }\n\n    private void writeParameterDetails( MojoDescriptor mojoDescriptor, List parameterList, XMLWriter w )\n    {\n        w.startElement( \"subsection\" );\n        w.addAttribute( \"name\", getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.details\" ) );\n\n        for ( Iterator parameters = parameterList.iterator(); parameters.hasNext(); )\n        {\n            Parameter parameter = (Parameter) parameters.next();\n\n            w.startElement( \"p\" );\n            w.writeMarkup( \"<strong><a name=\\\"\" + parameter.getName() + \"\\\">\" + parameter.getName() + \"<\/a>:<\/strong>\" );\n            w.endElement(); //p\n\n            String description = parameter.getDescription();\n            if ( StringUtils.isEmpty( description ) )\n            {\n                description = getBundle( locale ).getString( \"pluginxdoc.nodescription\" );\n            }\n            else\n            {\n                description = makeHtmlValid( description );\n            }\n            w.startElement( \"p\" );\n            w.writeMarkup( description );\n            w.endElement(); //p\n\n            w.startElement( \"ul\" );\n\n            writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.deprecated\" ), parameter.getDeprecated(), w );\n\n            writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.type\" ), parameter.getType(), w );\n\n            if ( StringUtils.isNotEmpty( parameter.getSince() ) )\n            {\n                writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.since\" ), parameter.getSince(), w );\n            }\n            else\n            {\n                if ( StringUtils.isNotEmpty( mojoDescriptor.getSince() ) )\n                {\n                    writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.since\" ), mojoDescriptor.getSince(), w );\n                }\n            }\n\n            if ( parameter.isRequired() )\n            {\n                writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.required\" ), getBundle( locale ).getString( \"pluginxdoc.yes\" ), w );\n            }\n            else\n            {\n                writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.required\" ), getBundle( locale ).getString( \"pluginxdoc.no\" ), w );\n            }\n\n            writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.expression\" ), parameter.getExpression(), w );\n\n            writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.default\" ), parameter.getDefaultValue(), w );\n\n            w.endElement();//ul\n\n            if ( parameters.hasNext() )\n            {\n                w.writeMarkup( \"<hr/>\" );\n            }\n        }\n\n        w.endElement();\n    }\n\n    private void writeDetail( String param, String value, XMLWriter w )\n    {\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( \"<strong>\" + param + \"<\/strong>: <code>\" );\n            w.writeText( value );\n            w.writeMarkup( \"<\/code>\" );\n            w.endElement(); //li\n        }\n    }\n\n    private void writeParameterSummary( MojoDescriptor mojoDescriptor, List parameterList, XMLWriter w )\n    {\n        List requiredParams = getParametersByRequired( true, parameterList );\n        if ( requiredParams.size() > 0 )\n        {\n            writeParameterList( mojoDescriptor, getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.requiredParameters\" ), requiredParams, w );\n        }\n\n        List optionalParams = getParametersByRequired( false, parameterList );\n        if ( optionalParams.size() > 0 )\n        {\n            writeParameterList( mojoDescriptor, getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.optionalParameters\" ), optionalParams, w );\n        }\n    }\n\n    private void writeParameterList( MojoDescriptor mojoDescriptor, String title, List parameterList, XMLWriter w )\n    {\n        w.startElement( \"subsection\" );\n        w.addAttribute( \"name\", title );\n\n        w.startElement( \"table\" );\n        w.addAttribute( \"border\", \"0\" );\n        w.addAttribute( \"align\", \"left\" );\n\n        w.startElement( \"tr\" );\n        w.startElement( \"th\" );\n        w.writeText( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.name\" ) );\n        w.endElement();//th\n        w.startElement( \"th\" );\n        w.writeText( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.type\" ) );\n        w.endElement();//th\n        w.startElement( \"th\" );\n        w.writeText( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.since\" ) );\n        w.endElement();//th\n        w.startElement( \"th\" );\n        w.writeText( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.description\" ) );\n        w.endElement();//th\n        w.endElement();//tr\n\n        for ( Iterator parameters = parameterList.iterator(); parameters.hasNext(); )\n        {\n            Parameter parameter = (Parameter) parameters.next();\n\n            w.startElement( \"tr\" );\n            w.startElement( \"td\" );\n            w.writeMarkup( \"<strong><a href=\\\"#\" + parameter.getName() + \"\\\">\" + parameter.getName() + \"<\/a><\/strong>\" );\n            w.endElement();//td\n            w.startElement( \"td\" );\n            int index = parameter.getType().lastIndexOf( \".\" );\n            w.writeMarkup( \"<code>\" + parameter.getType().substring( index + 1 ) + \"<\/code>\" );\n            w.endElement();//td\n            w.startElement( \"td\" );\n            if ( StringUtils.isNotEmpty( parameter.getSince() ) )\n            {\n                w.writeMarkup( \"<code>\" + parameter.getSince() + \"<\/code>\" );\n            }\n            else\n            {\n                if ( StringUtils.isNotEmpty( mojoDescriptor.getSince() ) )\n                {\n                    w.writeMarkup( \"<code>\" + mojoDescriptor.getSince() + \"<\/code>\" );\n                }\n                else\n                {\n                    w.writeMarkup( \"<code>-<\/code>\" );\n                }\n            }\n            w.endElement();//td\n            w.startElement( \"td\" );\n            String description = parameter.getDescription();\n            if ( StringUtils.isEmpty( description ) )\n            {\n                description = getBundle( locale ).getString( \"pluginxdoc.nodescription\" );\n            }\n            else\n            {\n                description = makeHtmlValid( description );\n            }\n            if ( StringUtils.isNotEmpty( parameter.getDeprecated() ) )\n            {\n                description = \"<strong>\" + getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.deprecated\" ) + \"<\/strong>. \" + description;\n            }\n            w.writeMarkup( description + \" \" );\n\n            if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) )\n            {\n                w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.defaultValue\" ) + \": <code>\" );\n                w.writeText( parameter.getDefaultValue() );\n                w.writeMarkup( \"<\/code>.\" );\n            }\n            w.endElement();//td\n            w.endElement(); //tr\n        }\n\n        w.endElement();//table\n        w.endElement();//section\n    }\n\n    private List getParametersByRequired( boolean required, List parameterList )\n    {\n        List list = new ArrayList();\n\n        for ( Iterator parameters = parameterList.iterator(); parameters.hasNext(); )\n        {\n            Parameter parameter = (Parameter) parameters.next();\n\n            if ( parameter.isRequired() == required )\n            {\n                list.add( parameter );\n            }\n        }\n\n        return list;\n    }\n\n    /**\n     * @param description Javadoc description with HTML tags\n     * @return the description with valid HTML tags\n     */\n    protected static String makeHtmlValid( String description )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return \"\";\n        }\n\n        StringOutputStream out = new StringOutputStream();\n\n        // Using jTidy to clean comment\n        Tidy tidy = new Tidy();\n        tidy.setDocType( \"loose\" );\n        tidy.setXHTML( true );\n        tidy.setXmlOut( true );\n        tidy.setMakeClean( true );\n        tidy.setQuiet( true );\n        tidy.setShowWarnings( false );\n        tidy.parse( new StringInputStream( decodeJavadocTags( description ) ), out );\n\n        // strip the header/body stuff\n        String LS = System.getProperty( \"line.separator\" );\n        String commentCleaned = out.toString();\n        if ( StringUtils.isEmpty( commentCleaned ) )\n        {\n            return \"\";\n        }\n        int startPos = commentCleaned.indexOf( \"<body>\" + LS ) + 6 + LS.length();\n        int endPos = commentCleaned.indexOf( LS + \"<\/body>\" );\n\n        return commentCleaned.substring( startPos, endPos );\n    }\n\n    /**\n     * Decodes javadoc inline tags into equivalent HTML tags. For instance, the inline tag \"{@code <A&B>}\" should be\n     * rendered as \"<code>&lt;A&amp;B&gt;<\/code>\".\n     *\n     * @param description The javadoc description to decode, may be <code>null<\/code>.\n     * @return The decoded description, never <code>null<\/code>.\n     */\n    protected static String decodeJavadocTags( String description )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return \"\";\n        }\n\n        StringBuffer decoded = new StringBuffer( description.length() + 1024 );\n\n        Matcher matcher = Pattern.compile( \"\\\\{@(\\\\w+)\\\\s*([^\\\\}]*)\\\\}\" ).matcher( description );\n        while ( matcher.find() )\n        {\n            String tag = matcher.group( 1 );\n            String text = matcher.group( 2 );\n            text = StringUtils.replace( text, \"&\", \"&amp;\" );\n            text = StringUtils.replace( text, \"<\", \"&lt;\" );\n            text = StringUtils.replace( text, \">\", \"&gt;\" );\n            if ( \"code\".equals( tag ) )\n            {\n                text = \"<code>\" + text + \"<\/code>\";\n            }\n            else if ( \"link\".equals( tag ) || \"linkplain\".equals( tag ) || \"value\".equals( tag ) )\n            {\n                String pattern = \"(([^#\\\\.\\\\s]+\\\\.)*([^#\\\\.\\\\s]+))?\" + \"(#([^\\\\(\\\\s]*)(\\\\([^\\\\)]*\\\\))?\\\\s*(\\\\S.*)?)?\";\n                final int LABEL = 7;\n                final int CLASS = 3;\n                final int MEMBER = 5;\n                final int ARGS = 6;\n                Matcher link = Pattern.compile( pattern ).matcher( text );\n                if ( link.matches() )\n                {\n                    text = link.group( LABEL );\n                    if ( StringUtils.isEmpty( text ) )\n                    {\n                        text = link.group( CLASS );\n                        if ( StringUtils.isEmpty( text ) )\n                        {\n                            text = \"\";\n                        }\n                        if ( StringUtils.isNotEmpty( link.group( MEMBER ) ) )\n                        {\n                            if ( StringUtils.isNotEmpty( text ) )\n                            {\n                                text += '.';\n                            }\n                            text += link.group( MEMBER );\n                            if ( StringUtils.isNotEmpty( link.group( ARGS ) ) )\n                            {\n                                text += \"()\";\n                            }\n                        }\n                    }\n                }\n                if ( !\"linkplain\".equals( tag ) )\n                {\n                    text = \"<code>\" + text + \"<\/code>\";\n                }\n            }\n            matcher.appendReplacement( decoded, ( text != null ) ? quoteReplacement( text ) : \"\" );\n        }\n        matcher.appendTail( decoded );\n\n        return decoded.toString();\n    }\n\n    /**\n     * Returns a literal replacement <code>String<\/code> for the specified <code>String<\/code>. This method\n     * produces a <code>String<\/code> that will work as a literal replacement <code>s<\/code> in the\n     * <code>appendReplacement<\/code> method of the {@link Matcher} class. The <code>String<\/code> produced will\n     * match the sequence of characters in <code>s<\/code> treated as a literal sequence. Slashes ('\\') and dollar\n     * signs ('$') will be given no special meaning.\n     *\n     * TODO: copied from Matcher class of Java 1.5, remove once target platform can be upgraded\n     * @see <a href=\"http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/Matcher.html\">\n     * http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/Matcher.html<\/a>\n     *\n     * @param s The string to be literalized\n     * @return A literal string replacement\n     */\n    private static String quoteReplacement( String s )\n    {\n        if ( ( s.indexOf( '\\\\' ) == -1 ) && ( s.indexOf( '$' ) == -1 ) )\n            return s;\n        StringBuffer sb = new StringBuffer();\n        for ( int i = 0; i < s.length(); i++ )\n        {\n            char c = s.charAt( i );\n            if ( c == '\\\\' )\n            {\n                sb.append( '\\\\' );\n                sb.append( '\\\\' );\n            }\n            else if ( c == '$' )\n            {\n                sb.append( '\\\\' );\n                sb.append( '$' );\n            }\n            else\n            {\n                sb.append( c );\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"pluginxdoc\", locale, getClass().getClassLoader() );\n    }\n}\n","Smelly Sample":"package org.apache.maven.tools.plugin.generator;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.plugin.descriptor.MojoDescriptor;\nimport org.apache.maven.plugin.descriptor.Parameter;\nimport org.apache.maven.plugin.descriptor.PluginDescriptor;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringInputStream;\nimport org.codehaus.plexus.util.StringOutputStream;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.xml.PrettyPrintXMLWriter;\nimport org.codehaus.plexus.util.xml.XMLWriter;\nimport org.w3c.tidy.Tidy;\n\n/**\n * @todo add example usage tag that can be shown in the doco\n * @version $Id$\n */\npublic class PluginXdocGenerator\n    implements Generator\n{\n    private final Locale locale;\n\n    /**\n     * Default constructor using <code>Locale.ENGLISH<\/code> as locale.\n     */\n    public PluginXdocGenerator()\n    {\n        this.locale = Locale.ENGLISH;\n    }\n\n    /**\n     * @param locale not null wanted locale.\n     */\n    public PluginXdocGenerator( Locale locale )\n    {\n        if ( locale == null )\n        {\n            this.locale = Locale.ENGLISH;\n        }\n        else\n        {\n            this.locale = locale;\n        }\n    }\n\n    /** {@inheritDoc} */\n    public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n            processMojoDescriptor( descriptor, destinationDirectory );\n        }\n    }\n\n    protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, File destinationDirectory )\n        throws IOException\n    {\n        FileWriter writer = null;\n        try\n        {\n            writer = new FileWriter( new File( destinationDirectory, getMojoFilename( mojoDescriptor, \"xml\" ) ) );\n\n            writeBody( writer, mojoDescriptor );\n\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }\n\n    private String getMojoFilename( MojoDescriptor mojo, String ext )\n    {\n        return mojo.getGoal() + \"-mojo.\" + ext;\n    }\n\n    private void writeBody( FileWriter writer, MojoDescriptor mojoDescriptor )\n    {\n        XMLWriter w = new PrettyPrintXMLWriter( writer );\n\n        w.startElement( \"document\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"properties\" );\n\n        w.startElement( \"title\" );\n\n        // TODO: need a friendly name for a plugin\n        w.writeText( mojoDescriptor.getPluginDescriptor().getArtifactId() + \" - \" + mojoDescriptor.getFullGoalName() );\n\n        w.endElement(); // title\n\n        w.endElement(); // properties\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"body\" );\n\n        w.startElement( \"section\" );\n\n        w.addAttribute( \"name\", mojoDescriptor.getFullGoalName() );\n\n        w.startElement( \"p\" );\n        w.writeMarkup( \"<strong>\"+ getBundle( locale ).getString( \"pluginxdoc.fullname\" ) + \"<\/strong>:\" );\n        w.endElement(); //p\n        w.startElement( \"p\" );\n        w.writeMarkup( mojoDescriptor.getPluginDescriptor().getGroupId() + \":\"\n            + mojoDescriptor.getPluginDescriptor().getArtifactId() + \":\"\n            + mojoDescriptor.getPluginDescriptor().getVersion() + \":\" + mojoDescriptor.getGoal() );\n        w.endElement(); //p\n\n        w.startElement( \"p\" );\n        w.writeMarkup( \"<strong>\"+ getBundle( locale ).getString( \"pluginxdoc.description\" ) + \"<\/strong>:\" );\n        w.endElement(); //p\n\n        w.startElement( \"p\" );\n        if ( mojoDescriptor.getDescription() != null )\n        {\n            w.writeMarkup( makeHtmlValid( mojoDescriptor.getDescription() ) );\n        }\n        else\n        {\n            w.writeText( getBundle( locale ).getString( \"pluginxdoc.nodescription\" ) );\n        }\n\n        w.endElement(); // p\n\n        writeGoalAttributes( mojoDescriptor, w );\n\n        writeGoalParameterTable( mojoDescriptor, w );\n\n        w.endElement(); // section\n\n        w.endElement(); // body\n\n        w.endElement(); // document\n    }\n\n    private void writeGoalAttributes( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"p\" );\n        w.writeMarkup( \"<strong>\"+ getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.attributes\" ) + \"<\/strong>:\" );\n        w.endElement(); //p\n\n        w.startElement( \"ul\" );\n\n        String value = mojoDescriptor.getDeprecated();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.deprecated\" ) + \": \" + value + \".\" );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isProjectRequired() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.projectRequired\" ) );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isAggregator() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.aggregator\" ) );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isDirectInvocationOnly() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.directInvocationOnly\" ) );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.isDependencyResolutionRequired();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.dependencyResolutionRequired\" ) + \": <code>\" + value + \"<\/code>.\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getSince();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.since\" ) + \": <code>\" + value + \"<\/code>.\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getPhase();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.phase\" ) + \": <code>\" + value + \"<\/code>.\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getExecutePhase();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executePhase1\" ) + \" <code>\" + value\n                + \"<\/code>\" + getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executePhase2\" ) + \".\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getExecuteGoal();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executeGoal1\" ) + \" <code>\" + value\n                + \"<\/code> \" + getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executeGoal2\" ) + \".\" );\n            w.endElement(); //li\n        }\n\n        value = mojoDescriptor.getExecuteLifecycle();\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.executeLifecycle\" ) + \": <code>\" + value + \"<\/code>.\" );\n            w.endElement(); //li\n        }\n\n        if ( mojoDescriptor.isOnlineRequired() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.onlineRequired\" ) );\n            w.endElement(); //li\n        }\n\n        if ( !mojoDescriptor.isInheritedByDefault() )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.inheritedByDefault\" ) );\n            w.endElement(); //li\n        }\n\n        w.endElement();//ul\n    }\n\n    private void writeGoalParameterTable( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        List parameterList = mojoDescriptor.getParameters();\n\n        //remove components and read-only parameters\n        List list = filterParameters( parameterList );\n\n        if ( list != null && list.size() > 0 )\n        {\n            writeParameterSummary( mojoDescriptor, list, w );\n\n            writeParameterDetails( mojoDescriptor, list, w );\n        }\n    }\n\n    private List filterParameters( List parameterList )\n    {\n        List filtered = new ArrayList();\n\n        if ( parameterList != null )\n        {\n            for ( Iterator parameters = parameterList.iterator(); parameters.hasNext(); )\n            {\n                Parameter parameter = (Parameter) parameters.next();\n\n                if ( parameter.isEditable() )\n                {\n                    String expression = parameter.getExpression();\n\n                    if ( expression == null || !expression.startsWith( \"${component.\" ) )\n                    {\n                        filtered.add( parameter );\n                    }\n                }\n            }\n        }\n\n        return filtered;\n    }\n\n    private void writeParameterDetails( MojoDescriptor mojoDescriptor, List parameterList, XMLWriter w )\n    {\n        w.startElement( \"subsection\" );\n        w.addAttribute( \"name\", getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.details\" ) );\n\n        for ( Iterator parameters = parameterList.iterator(); parameters.hasNext(); )\n        {\n            Parameter parameter = (Parameter) parameters.next();\n\n            w.startElement( \"p\" );\n            w.writeMarkup( \"<strong><a name=\\\"\" + parameter.getName() + \"\\\">\" + parameter.getName() + \"<\/a>:<\/strong>\" );\n            w.endElement(); //p\n\n            String description = parameter.getDescription();\n            if ( StringUtils.isEmpty( description ) )\n            {\n                description = getBundle( locale ).getString( \"pluginxdoc.nodescription\" );\n            }\n            else\n            {\n                description = makeHtmlValid( description );\n            }\n            w.startElement( \"p\" );\n            w.writeMarkup( description );\n            w.endElement(); //p\n\n            w.startElement( \"ul\" );\n\n            writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.deprecated\" ), parameter.getDeprecated(), w );\n\n            writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.type\" ), parameter.getType(), w );\n\n            if ( StringUtils.isNotEmpty( parameter.getSince() ) )\n            {\n                writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.since\" ), parameter.getSince(), w );\n            }\n            else\n            {\n                if ( StringUtils.isNotEmpty( mojoDescriptor.getSince() ) )\n                {\n                    writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.since\" ), mojoDescriptor.getSince(), w );\n                }\n            }\n\n            if ( parameter.isRequired() )\n            {\n                writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.required\" ), getBundle( locale ).getString( \"pluginxdoc.yes\" ), w );\n            }\n            else\n            {\n                writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.required\" ), getBundle( locale ).getString( \"pluginxdoc.no\" ), w );\n            }\n\n            writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.expression\" ), parameter.getExpression(), w );\n\n            writeDetail( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.default\" ), parameter.getDefaultValue(), w );\n\n            w.endElement();//ul\n\n            if ( parameters.hasNext() )\n            {\n                w.writeMarkup( \"<hr/>\" );\n            }\n        }\n\n        w.endElement();\n    }\n\n    private void writeDetail( String param, String value, XMLWriter w )\n    {\n        if ( StringUtils.isNotEmpty( value ) )\n        {\n            w.startElement( \"li\" );\n            w.writeMarkup( \"<strong>\" + param + \"<\/strong>: <code>\" );\n            w.writeText( value );\n            w.writeMarkup( \"<\/code>\" );\n            w.endElement(); //li\n        }\n    }\n\n    private void writeParameterSummary( MojoDescriptor mojoDescriptor, List parameterList, XMLWriter w )\n    {\n        List requiredParams = getParametersByRequired( true, parameterList );\n        if ( requiredParams.size() > 0 )\n        {\n            writeParameterList( mojoDescriptor, getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.requiredParameters\" ), requiredParams, w );\n        }\n\n        List optionalParams = getParametersByRequired( false, parameterList );\n        if ( optionalParams.size() > 0 )\n        {\n            writeParameterList( mojoDescriptor, getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.optionalParameters\" ), optionalParams, w );\n        }\n    }\n\n    private void writeParameterList( MojoDescriptor mojoDescriptor, String title, List parameterList, XMLWriter w )\n    {\n        w.startElement( \"subsection\" );\n        w.addAttribute( \"name\", title );\n\n        w.startElement( \"table\" );\n        w.addAttribute( \"border\", \"0\" );\n        w.addAttribute( \"align\", \"left\" );\n\n        w.startElement( \"tr\" );\n        w.startElement( \"th\" );\n        w.writeText( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.name\" ) );\n        w.endElement();//th\n        w.startElement( \"th\" );\n        w.writeText( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.type\" ) );\n        w.endElement();//th\n        w.startElement( \"th\" );\n        w.writeText( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.since\" ) );\n        w.endElement();//th\n        w.startElement( \"th\" );\n        w.writeText( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.description\" ) );\n        w.endElement();//th\n        w.endElement();//tr\n\n        for ( Iterator parameters = parameterList.iterator(); parameters.hasNext(); )\n        {\n            Parameter parameter = (Parameter) parameters.next();\n\n            w.startElement( \"tr\" );\n            w.startElement( \"td\" );\n            w.writeMarkup( \"<strong><a href=\\\"#\" + parameter.getName() + \"\\\">\" + parameter.getName() + \"<\/a><\/strong>\" );\n            w.endElement();//td\n            w.startElement( \"td\" );\n            int index = parameter.getType().lastIndexOf( \".\" );\n            w.writeMarkup( \"<code>\" + parameter.getType().substring( index + 1 ) + \"<\/code>\" );\n            w.endElement();//td\n            w.startElement( \"td\" );\n            if ( StringUtils.isNotEmpty( parameter.getSince() ) )\n            {\n                w.writeMarkup( \"<code>\" + parameter.getSince() + \"<\/code>\" );\n            }\n            else\n            {\n                if ( StringUtils.isNotEmpty( mojoDescriptor.getSince() ) )\n                {\n                    w.writeMarkup( \"<code>\" + mojoDescriptor.getSince() + \"<\/code>\" );\n                }\n                else\n                {\n                    w.writeMarkup( \"<code>-<\/code>\" );\n                }\n            }\n            w.endElement();//td\n            w.startElement( \"td\" );\n            String description = parameter.getDescription();\n            if ( StringUtils.isEmpty( description ) )\n            {\n                description = getBundle( locale ).getString( \"pluginxdoc.nodescription\" );\n            }\n            else\n            {\n                description = makeHtmlValid( description );\n            }\n            if ( StringUtils.isNotEmpty( parameter.getDeprecated() ) )\n            {\n                description = \"<strong>\" + getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.deprecated\" ) + \"<\/strong>. \" + description;\n            }\n            w.writeMarkup( description + \" \" );\n\n            if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) )\n            {\n                w.writeMarkup( getBundle( locale ).getString( \"pluginxdoc.mojodescriptor.parameter.defaultValue\" ) + \": <code>\" );\n                w.writeText( parameter.getDefaultValue() );\n                w.writeMarkup( \"<\/code>.\" );\n            }\n            w.endElement();//td\n            w.endElement(); //tr\n        }\n\n        w.endElement();//table\n        w.endElement();//section\n    }\n\n    private List getParametersByRequired( boolean required, List parameterList )\n    {\n        List list = new ArrayList();\n\n        for ( Iterator parameters = parameterList.iterator(); parameters.hasNext(); )\n        {\n            Parameter parameter = (Parameter) parameters.next();\n\n            if ( parameter.isRequired() == required )\n            {\n                list.add( parameter );\n            }\n        }\n\n        return list;\n    }\n\n    /**\n     * @param description Javadoc description with HTML tags\n     * @return the description with valid HTML tags\n     */\n    protected static String makeHtmlValid( String description )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return \"\";\n        }\n\n        StringOutputStream out = new StringOutputStream();\n\n        // Using jTidy to clean comment\n        Tidy tidy = new Tidy();\n        tidy.setDocType( \"loose\" );\n        tidy.setXHTML( true );\n        tidy.setXmlOut( true );\n        tidy.setMakeClean( true );\n        tidy.setQuiet( true );\n        tidy.setShowWarnings( false );\n        tidy.parse( new StringInputStream( decodeJavadocTags( description ) ), out );\n\n        // strip the header/body stuff\n        String LS = System.getProperty( \"line.separator\" );\n        String commentCleaned = out.toString();\n        if ( StringUtils.isEmpty( commentCleaned ) )\n        {\n            return \"\";\n        }\n        int startPos = commentCleaned.indexOf( \"<body>\" + LS ) + 6 + LS.length();\n        int endPos = commentCleaned.indexOf( LS + \"<\/body>\" );\n\n        return commentCleaned.substring( startPos, endPos );\n    }\n\n    /**\n     * Decodes javadoc inline tags into equivalent HTML tags. For instance, the inline tag \"{@code <A&B>}\" should be\n     * rendered as \"<code>&lt;A&amp;B&gt;<\/code>\".\n     *\n     * @param description The javadoc description to decode, may be <code>null<\/code>.\n     * @return The decoded description, never <code>null<\/code>.\n     */\n    protected static String decodeJavadocTags( String description )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return \"\";\n        }\n\n        StringBuffer decoded = new StringBuffer( description.length() + 1024 );\n\n        Matcher matcher = Pattern.compile( \"\\\\{@(\\\\w+)\\\\s*([^\\\\}]*)\\\\}\" ).matcher( description );\n        while ( matcher.find() )\n        {\n            String tag = matcher.group( 1 );\n            String text = matcher.group( 2 );\n            text = StringUtils.replace( text, \"&\", \"&amp;\" );\n            text = StringUtils.replace( text, \"<\", \"&lt;\" );\n            text = StringUtils.replace( text, \">\", \"&gt;\" );\n            if ( \"code\".equals( tag ) )\n            {\n                text = \"<code>\" + text + \"<\/code>\";\n            }\n            else if ( \"link\".equals( tag ) || \"linkplain\".equals( tag ) || \"value\".equals( tag ) )\n            {\n                String pattern = \"(([^#\\\\.\\\\s]+\\\\.)*([^#\\\\.\\\\s]+))?\" + \"(#([^\\\\(\\\\s]*)(\\\\([^\\\\)]*\\\\))?\\\\s*(\\\\S.*)?)?\";\n                final int LABEL = 7;\n                final int CLASS = 3;\n                final int MEMBER = 5;\n                final int ARGS = 6;\n                Matcher link = Pattern.compile( pattern ).matcher( text );\n                if ( link.matches() )\n                {\n                    text = link.group( LABEL );\n                    if ( StringUtils.isEmpty( text ) )\n                    {\n                        text = link.group( CLASS );\n                        if ( StringUtils.isEmpty( text ) )\n                        {\n                            text = \"\";\n                        }\n                        if ( StringUtils.isNotEmpty( link.group( MEMBER ) ) )\n                        {\n                            if ( StringUtils.isNotEmpty( text ) )\n                            {\n                                text += '.';\n                            }\n                            text += link.group( MEMBER );\n                            if ( StringUtils.isNotEmpty( link.group( ARGS ) ) )\n                            {\n                                text += \"()\";\n                            }\n                        }\n                    }\n                }\n                if ( !\"linkplain\".equals( tag ) )\n                {\n                    text = \"<code>\" + text + \"<\/code>\";\n                }\n            }\n            matcher.appendReplacement( decoded, ( text != null ) ? quoteReplacement( text ) : \"\" );\n        }\n        matcher.appendTail( decoded );\n\n        return decoded.toString();\n    }\n\n    /**\n     * Returns a literal replacement <code>String<\/code> for the specified <code>String<\/code>. This method\n     * produces a <code>String<\/code> that will work as a literal replacement <code>s<\/code> in the\n     * <code>appendReplacement<\/code> method of the {@link Matcher} class. The <code>String<\/code> produced will\n     * match the sequence of characters in <code>s<\/code> treated as a literal sequence. Slashes ('\\') and dollar\n     * signs ('$') will be given no special meaning.\n     *\n     * TODO: copied from Matcher class of Java 1.5, remove once target platform can be upgraded\n     * @see <a href=\"http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/Matcher.html\">\n     * http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/Matcher.html<\/a>\n     *\n     * @param s The string to be literalized\n     * @return A literal string replacement\n     */\n    private static String quoteReplacement( String s )\n    {\n        if ( ( s.indexOf( '\\\\' ) == -1 ) && ( s.indexOf( '$' ) == -1 ) )\n            return s;\n        StringBuffer sb = new StringBuffer();\n        for ( int i = 0; i < s.length(); i++ )\n        {\n            char c = s.charAt( i );\n            if ( c == '\\\\' )\n            {\n                sb.append( '\\\\' );\n                sb.append( '\\\\' );\n            }\n            else if ( c == '$' )\n            {\n                sb.append( '\\\\' );\n                sb.append( '$' );\n            }\n            else\n            {\n                sb.append( c );\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"pluginxdoc\", locale, getClass().getClassLoader() );\n    }\n}\n","lineNo":92}
